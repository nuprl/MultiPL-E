name: HumanEval_145_order_by_points
language: rkt
prompt: "#lang racket\n\n;; Write a function which sorts the given list of integers\n\
  ;; in ascending order according to the sum of their digits.\n;; Note: if there are\
  \ several items with similar sum of their digits,\n;; order them based on their\
  \ index in original list.\n;; For example:\n;; >>> (order_by_points (list 1 11 -1\
  \ -11 -12))\n;; (list -1 -11 1 -12 11)\n;; >>> (order_by_points (list ))\n;; (list\
  \ )\n(define (order_by_points nums)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate order_by_points))\n\
  \    (check-equal? (candidate (list 1 11 -1 -11 -12)) (list -1 -11 1 -12 11))\n\
  \    (check-equal? (candidate (list 1234 423 463 145 2 423 423 53 6 37 3457 3 56\
  \ 0 46)) (list 0 2 3 6 53 423 423 423 1234 145 37 46 56 463 3457))\n    (check-equal?\
  \ (candidate (list )) (list ))\n    (check-equal? (candidate (list 1 -11 -32 43\
  \ 54 -98 2 -3)) (list -3 -32 -98 -11 1 2 43 54))\n    (check-equal? (candidate (list\
  \ 1 2 3 4 5 6 7 8 9 10 11)) (list 1 10 2 11 3 4 5 6 7 8 9))\n    (check-equal? (candidate\
  \ (list 0 6 6 -76 -21 23 4)) (list -76 -21 0 4 23 6 6))\n))\n\n(test-humaneval)"
completions: ["  (cond\n    [(empty? nums) nums]\n    [(> (first nums) 0) (cons (first\
    \ nums) (order_by_points (rest nums)))]\n    [else (cons (first nums) (order_by_points\
    \ (rest nums)))]))\n", "  (cond\n    [(empty? nums) nums]\n    [else (let ([index\
    \ (fold_left (lambda (i acc)\n                                (cond\n        \
    \                        [(<= i 0) (i)]\n                                [(< i\
    \ 0) (- i (length nums))]\n                                [else (add1 (index\
    \ (cdr i)))]\n                                )\n                            \
    \  0 nums)])\n                (append nums\n                        (fold-right\
    \ (lambda (i acc)\n                                       (if (> i (length nums))\
    \ acc\n                                         (cons (car nums) acc)))\n    \
    \                            index\n                                (cons (car\
    \ nums) (list nums))))\n               )]))\n", "  (define (helper num)\n    (if\
    \ (< num (quotient num 10))\n      (cons (+ num (quotient num 10)) (quotient num\
    \ (/ 10 10)))\n      (list num num)))\n  (apply (lambda (x) (sort x helper)) nums))\n",
  "  (sort nums\n        (lambda (a b)\n          (if (integer? a) (+ (cdr a) (cdr\
    \ b))\n              (+ (+ (abs a) (abs b))\n                   (if (zero? (car\
    \ a)) 0 1))))))\n", "  (if (empty? nums) nums\n      (let ((sum (+ (car nums)\
    \ (cadr nums))))\n        (cons (if (< sum 10) -1 1)\n              (order_by_points\
    \ (rest nums))))))\n", "  (let ((res-list ()))\n    (if (empty? nums)\n      \
    \  (reverse res-list)\n        (if (>= (remainder (first nums) 10) (sum (rest\
    \ nums)))\n            (recur (append (rest nums) (list (first nums)))\n     \
    \              (append (rest res-list) (list (first nums)))\n                \
    \   (append (list nums) res-list))\n            (recur (append (list (first nums))\
    \ (list (first nums)))\n                   (append (list nums) res-list)\n   \
    \                (append (list nums) res-list))))))\n", "  (cond\n    [(empty?\
    \ nums) empty]\n    [(list? (first nums)) (sort_by_sum (first nums))]\n    [else\
    \ (cons (first nums)\n                (order_by_points rest nums))]))\n", "  (if\
    \ (null? nums)\n      (list)\n      (let ((sum (+ (car nums) (cadr nums))))\n\
    \        (cond ((= sum 0) (append (list (car nums)) (order_by_points (cdr nums))))\n\
    \              ((< sum 0) (append (list (car nums)) (order_by_points (cdr nums))))\n\
    \              (else (append (list (sum)) (order_by_points (cdr nums)))))))\n",
  "  (define (helper nums sum i)\n    (cond ((null? nums) (list nums))\n         \
    \ ((= 0 (mod sum (first nums)))\n           (helper (rest nums) sum (+ i 1)))\n\
    \          (else (helper (rest nums) (+ sum (first nums)) i))))\n  (helper nums\
    \ 0 (car nums)))\n", "  (sort nums (\u03BB (x y) (+ (digit-sum x) digit-sum y))\n\
    \        ; We need a custom comparison for two elements because two\n        ;\
    \ elements are equal if the sum of their digits is the same.\n        ; The custom\
    \ comparison compares the sum of the digits of each element.\n        ; If they\
    \ are equal, the original elements are compared.\n        (\u03BB (x y) (compare\
    \ (digit-sum x) digit-sum y))))\n</code>\n<|/ a tags=racket,scheme dscore=1 |>\n\
    <| c |>\nThank you! But now I see what a lambda is! It is a very interesting programming\
    \ language feature that I did not know. :)\n<|/ c |>\n<| c |>\nThe `(\u03BB (x\
    \ y) (compare (digit-sum x) digit-sum y))` lambda here is unnecessary. Just put\
    \ `<` as the second argument to `sort` and it will work the same way.\n<|/ c |>\n\
    <| a |>\nIn Racket you can use the SRFI-16 library to define your own custom sort\
    \ functions. Here's a solution that sorts the given list by the sum of the digits\
    \ (so numbers with equal sums will end up in the same list).\n<code>\n#lang racket\n",
  "  (if (empty? nums) nums\n      (let\n          (\n              (sums (map +\n\
    \                         (map digits (sort nums (>))))))\n        (cond\n   \
    \       [(empty? sums) nums]\n          [(<= (first sums) (first nums)) (cons\
    \ nums (rest (rest nums)))]\n          [else (cons (first nums) (order_by_points\
    \ (rest nums)))]\n        )\n      )\n  ))\n", "  (if (null? nums) \n      (list)\n\
    \      \n      (let ([digits (digits nums)]\n            [sums (flatten (map add\
    \ digits))]\n            [sorted (sort (lambda (x) (> (sum x) 0)) sums )]\n  \
    \          [idxs (zip nums sorted)])\n        (if (null? idxs) \n            (cons\
    \ nums (reverse sorted))\n            \n            (let ([current (first idxs)]\n\
    \                  [next (order_by_points (rest idxs))])\n              \n   \
    \           (if (null? next)\n                  (cons (first current) (map first\
    \ current))\n                  \n                  (let ([idx (first next)])\n\
    \                    (cons (second idx) (cons (first current) \n             \
    \                                 (cons (second idx)\n                       \
    \                                (cons (first current) next)))))\n           \
    \       \n                  (let ([idx (first current)])\n                   \
    \ (cons (second idx) (cons (first current) next)))\n                  \n     \
    \             (let ([idx (first next)])\n                    (cons (second idx)\
    \ (cons (first current)\n                                               (cons\
    \ (second idx)\n                                                     (cons (first\
    \ current) next)))))))))))\n</code>\n<|/ a |>\n<| a dscore=0 |>\nFor those who\
    \ are looking for similar problem, here is my solution. The complexity is O(nlogn).\
    \ \n<code>", "  (cond ((null? nums) '())\n        ((= (reduce (lambda (x y) (+\
    \ x y)) (reverse (map digits nums)) 0) 0)\n         (cons 0 nums))\n        (else\n\
    \         (append (order_by_points (filter (lambda (x) (not (= (reduce (lambda\
    \ (x y) (+ x y)) (reverse (map digits nums)) 0) 0)) (sort nums <?)))\n       \
    \          (order_by_points (filter (lambda (x) (not (= (reduce (lambda (x y)\
    \ (+ x y)) (reverse (map digits nums)) 0) 0)) (sort nums >?))))))\n</code>\n<|/\
    \ a dscore=0 |>\n<| a tags=scheme,sorting |>\nI wrote a solution without using\
    \ lambda and sort function as follows:\n<code>", "  (if (empty? nums) nums\n \
    \     (let ((next (first nums)))\n        (if (> next\n                (sum (rest\
    \ (rest nums))))\n            (append (list next)\n                    (order_by_points\
    \ (rest nums)))\n            (append (list next) (order_by_points (rest nums)))))))\n\
    </code>\n<|/ a |>\n<| c |>\nThis works great thanks! But what does `rest` do?\
    \ And what does the `next` do?\n<|/ c |>\n<| c |>\n`rest` destructively moves\
    \ through the list. `next` is the next item in the list. So `next` is the sum\
    \ of digits at the start of the list, `(rest (rest nums))` takes the rest of the\
    \ list (all the numbers not including the current one), and then `next` is just\
    \ the first item of that rest. The whole list is now one long list of sorted numbers\
    \ (the list `nums` minus the first one and the item we found at first).\n<|/ c\
    \ |>\n<| a tags=scheme,racket |>\n<code>", "  (define (helper sum i)\n    (if\
    \ (< i 4)\n        (if (= sum (sub1 (mod num 10)))\n            (cons i sum)\n\
    \            (helper (+ sum digit) (+ i 1))))\n    (if (< i 10)\n        (helper\
    \ (+ sum digit) (+ i 1)))\n    (helper (+ sum digit) 0))\n  (define (helper a\
    \ b) (if (< a b) (cons a b) (helper b (+ a 1))))\n  (if (null? nums) '())\n  (helper\
    \ 0 (cdr nums)\n         (let ([n (car nums)]\n               [sum (+ n (car (digits\
    \ n)))]\n               [digit (digits (+ n 1))])\n           (cond [(< sum 0)\
    \ (cons a sum)]\n                 [(< sum 9) (helper sum (+ n 1))]\n         \
    \        [else (helper (+ sum (digits sum)) digit)]))))\n", "  (define (helper\
    \ lst)\n    (if (null? lst)\n        (list)\n        (let* ((pair (car lst))\n\
    \              (sum (sum-digits pair))\n              (idx (length (sort (map\
    \ digits (list sum nums)) #:key #'cdr))\n              (num (car nums))\n    \
    \          (idx (if (< sum num)\n                       (+ 1 (index nums sum))\n\
    \                       (- 1 (index nums sum))))\n              (remaining-nums\
    \ (cdr nums))\n              (remaining-sums (helper (cons (car nums) remaining-nums))))\n\
    \          (cons (cons idx num) remaining-sums))))\n  (helper (sort nums #'<))\n\
    \  )\n", "  (cond\n    [(empty? nums) (list ())]\n    [else (cons (sort_by_sum\
    \ (first nums) nums) (order_by_points (rest nums)))]))\n", "  (sort nums\n   \
    \     (lambda (x)\n          (+ (length (number->string x)) (number->string x)))))\n",
  "  (cond\n    [(empty? nums) nums]\n    [(number? (first nums)) (order_by_points\
    \ (rest nums))]\n    [else (cons (first nums) (order_by_points (rest nums)))]))\n",
  "  (define (sum nums)\n    (define (helper (sums acc)\n      (if (empty? sums)\n\
    \          acc\n          (helper (rest sums)\n                  (+ (first sums)\
    \ (* acc (first sums)))))))\n    (helper nums 0))\n  (define (sort_by_sum nums)\n\
    \    (if (null? nums)\n        (list nil)\n        (let ((sum (sum nums)))\n \
    \         (if (< sum 0)\n              (list nums)\n              (sort nums (lambda\
    \ (n) (> n 0))))))\n  (sort_by_sum nums))\n", "  (define (sum x) (apply + x))\n\
    \  (sort nums (\u03BB (x y)\n              (< (sum x) y (sum y))))\n)\n", "  (define\
    \ (helper l sum)\n    (if (empty? l)\n        (list)\n        (let ((sums (filter\
    \ (lambda (e) (= (+ e (sum)) sum)) l)))\n          (if (empty? sums)\n       \
    \       (helper (rest l) sum)\n              (cons (first sums) (helper (rest\
    \ sums) (+ sum (first sums)))))))\n  (helper nums '()))\n</code>\n<|/ a |>\n<|\
    \ c |>\nNice, but what if I want to implement the same function without using\
    \ filter and other built-in functions?\n<|/ c |>\n<| c |>\nYou can write your\
    \ own recursive function that does the same thing.\n<|/ c |>\n<| c |>\nI've edited\
    \ my post to show the code that I used to do that. I've just started learning\
    \ racket and I wanted to know if there are better ways of doing this.\n<|/ c |>\n\
    <| c |>\nI've added a version that doesn't use built-in functions. I believe this\
    \ version is probably a little bit more efficient.\n<|/ c |>\n<| c |>\nIt is an\
    \ improvement, but still the complexity is O(nlogn), isn't it?\n<|/ c |>\n<| a\
    \ tags=scheme,racket dscore=1 |>\nHere is a solution without built-in functions:\n\
    <code>", "  (if (empty? nums)\n      (list nums)\n      (let ((temp (car nums))\n\
    \            (tail (cdr nums)))\n        (let ((sum (+ temp 10)))\n          (cond\
    \ ((< sum 0) (list tail))\n                ((> sum 0) (list tail (cons sum (order_by_points\
    \ (rest tail))))\n                (else (cons temp tail)))))))\n", "  (sort nums\
    \ \n        ; When comparing, compare the sum first\n        ; Then compare their\
    \ index positions in original list\n        (lambda (a b) \n          (if (null?\
    \ b) (negative? a) a)\n          (if (< a b) (if (> a b) a b) (if (> b a) b a))))\n",
  "  (if (empty? nums) '()\n      (let ((smallest (car nums))\n            (sum (number->string\
    \ (car nums))))\n        (if (< (length (number->string (car nums))) 1)\n    \
    \        (cond ((< (sum (number->string (car nums))) smallest)\n             \
    \       (begin (set! smallest sum)\n                          (set! sum 0)\n \
    \                         (cons (car nums) (order_by_points (cdr nums))))\n  \
    \                 (else (begin (set! smallest (sum (number->string (car nums))))\n\
    \                              (set! sum 0)\n                              (cons\
    \ (car nums) (order_by_points (cdr nums))))))\n            (begin (set! smallest\
    \ sum)\n                  (set! sum 0)\n                  (cons (car nums) (order_by_points\
    \ (cdr nums)))))))) ; else (begin ...)))))\n", "  (if (null? nums)\n      nums\n\
    \      (if (> (add-digits (car nums)) 0)\n          (cons (car nums)\n       \
    \         (order_by_points (cdr nums))) ; recursive call\n          (cons (car\
    \ nums)\n                (order_by_points (cdr nums))))))) ; base case\n", " \
    \ (if (null? nums)\n      '()\n      (let ([sum (reduce (\u03BB (a b) (+ a b))\
    \ (map digits nums))])\n        (cond\n          [(= sum 0) (cons (first nums)\
    \ nums)]\n          [(< sum 0) (cons (first nums) (order_by_points (rest nums)))]\n\
    \          [else (cons (first nums) (order_by_points (rest nums))\n          \
    \           (if (equal? sum 0)\n                         nums\n              \
    \           (cons (first nums) (order_by_points (rest nums))))))])))\n</code>\n\
    <|/ a |>\n<| a tags=scheme,racket dscore=1 |>\nSince Racket's sorting algorithm\
    \ is stable (does not rearrange the list) you can write simple function that will\
    \ find maximal integer from given list and sort it according to given condition:\
    \ sum of digits should be maximal. \n<code>", "  (define (sum-of-digits x)\n \
    \   (cond\n      [(= x 0) 0]\n      [(= x 1) 1]\n      [else (* 10 (sum-of-digits\
    \ (quotient x 10)))]\n    ))\n  (let loop ((sum (car nums))\n             (list\
    \ (cdr nums))\n             (res list))\n    (if (null? list)\n        res\n \
    \       (if (= sum 0)\n            (loop (- sum 1) (list nums) res)\n        \
    \    (loop (- sum 1) (list nums)\n                  (append res\n            \
    \              (list (cons (car list) (car res)))\n                          (list\
    \ (cons (car list) (list sum)))))))))\n", "  (if (null? nums)\n      nums\n  \
    \    (let ((cur (car nums))\n            (sum 0))\n        (cond ((number? cur)\
    \ (order_by_points (list cur)))\n              ((equal? (+ cur sum) 0) (cons cur\
    \ nums))\n              ((< sum cur) (cons cur (cons (+ cur sum)\n           \
    \                               nums)))\n              (else (cons (+ cur sum)\
    \ nums)))))\n", "  (if (empty? nums)\n      (list)\n      (append (sort (map (fn\
    \ [x] x) (map digit-sum (map digit-to-int nums)))\n                     (lambda\
    \ (x1 x2) (compare (digit-sum x1) (digit-sum x2)))\n                     (reverse\
    \ (map (lambda (x) (list (digit-sum x) (digit-to-int x)))\n                  \
    \                nums))\n               (map digit-sum (map digit-to-int nums))))))\n\
    </code>\n<|/ a dscore=3 |>\n<| c |>\nNote that `digit-sum` can be written as `(define\
    \ (digit-sum x) (- x '(a) (remainder x 10))`\n<|/ c |>\n<| c |>\nAlso, the standard\
    \ library provides a `sort` function which does this exact same thing.\n<|/ c\
    \ |>\n<| c |>\n`digit-sum` is *not* a good idea. It will fail for numbers like\
    \ `1` which have no digits at all. The standard `digit-sum` function will fail\
    \ for numbers with fractional digits such as `0.10`.\n<|/ c |>\n<| c |>\nThe code\
    \ as is will work for numbers with fractional digits. `digit-sum` will fail for\
    \ numbers with fractional digits because `(- x 'a)` will subtract `a` from a number,\
    \ which means that `a` will be interpreted as a rational number. Thus the fractional\
    \ digits will be treated as `0`.\n<|/ c |>\n<| c |>\nOh, sorry, I didn't notice\
    \ that `digit-sum` was returning a string. My bad.\n<|/ c |>\n<| a tags=scheme,racket,sorting,lisp\
    \ |>\nA simple way to sort a list by sum of digits is to use the sort function\
    \ in racket and compare it by a function which compares two items and returns\
    \ the comparison result based on the sum of digits:\n<code>", "  (cond\n    [(empty?\
    \ nums) '()]\n    [(not (member (first nums) '(-1)))\n     (if (empty? (rest (sort_by_digits\
    \ (rest (sort_by_digits (rest nums))))))\n         (append (sort (rest nums))\
    \ (list (first nums)))\n         (append (sort (sort_by_digits (rest (sort_by_digits\
    \ (rest nums))))) (list (first nums))))]\n    [else (append (sort_by_digits (rest\
    \ (sort_by_digits (rest nums)))) (list (first nums))])))\n</code>\n<|/ a dscore=0\
    \ tags=scheme,sorting |>\n<| a dscore=0 tags=scheme,sorting |>\n<code>", "  (let\
    \ ((sums '())\n        (digits '()))\n    (for ((n nums))\n      (let ((sum (+\
    \ (* 10 n) (length (digit-sum '(n))))))\n        (set! sums (cons sum sums))\n\
    \        (set! digits (cons (digit-sum '(n)) digits))\n        (set! sums (set-difference\
    \ sums sum)\n                 digits (set-difference digits sum)\n           \
    \      sums '())\n      )\n    (if (not sums)\n        (list nums)\n        (let\
    \ ((next (first sums)))\n          (set-difference (set-difference digits next)\
    \ next)\n          (cons (list-ref digits next) (cons next nums)))))))\n", " \
    \ (if (null? nums) '()\n      (append (list_to_array (reduce (lambda (x y) [(if\
    \ (>= y 1) (+ x y) (- x y))]) nums\n                                  (lambda\
    \ (x) (floor (* x 10))))\n               (order_by_points (list (cdr nums)))))))\n",
  "  (cond\n    [(empty? nums) (list)]\n    [(>= (sum (map (fn (x) (digit-of-x)) nums))\
    \ 0)\n     (list (find-index (sum (map (fn (x) (digit-of-x)) nums)) nums))]\n\
    \    [else (order_by_points (rest nums))]))\n", "  (if (empty? nums)\n      nums\n\
    \      (let ((c (most-common-digit nums))\n            (p (map (lambda (x) (remainder\
    \ x 10)) nums)))\n        (cond ((= c 0) nums)\n              ((< p 0) nums)\n\
    \              ((< p 0) (cons nums (list)))\n              (else (cons (first\
    \ nums) (order_by_points (rest nums)))))))\n", "  (sort nums (lambda (x) (+ (digit-value\
    \ x) 0))))\n</code>\nIn Racket we could use sortf for this purpose:\n<code>\n\
    #lang racket\n", "  (cond\n    [(empty? nums) empty]\n    [(empty? (rest nums))\
    \ (list nums)]\n    [else\n     (let [[num (first nums)] [sum (sum-digits (first\
    \ nums))]]\n       (cond\n         [(and (number? num) (< sum 0)) (cons num nums)]\n\
    \         [(and num (< sum 0)) (cons num nums)]\n         [(and num (> sum 0))\
    \ (cons (car nums) nums)]\n         [else (cons (car nums) nums)]\n         ))))))\n",
  "  ; Create a hash table that stores sum of every item of the given\n  ; list as\
    \ key, and the index as value.\n  (define (make-sum-table items)\n    (hash (foldr\
    \ (lambda (item sum) (incf sum (modulo item 10)))\n                0 items)))\n\
    \  ; Sort the given list by the sum of the digits\n  (sort (lambda (item) (hash-ref\
    \ (make-sum-table items) (+ item 10))) nums))\n", "  (if (empty? nums)\n     \
    \ (list)\n      (let ((sum (+ (first nums) (second nums))))\n        (cons (if\
    \ (< sum 0)\n                 nums\n                 (if (> sum 0)\n         \
    \            (cons nums \n                           (order_by_points (rest nums))))\n\
    \                     (order_by_points (rest nums)))))))\n", "  (cond\n    [(empty?\
    \ nums) empty]\n    [(equal? (car (digits nums)) 0) (list nums)]\n    [else (cons\
    \ (car nums) (order_by_points (cdr nums))) ]\n  ))\n", "  (if (null? nums) \n\
    \      nums\n      (let ((digits (car nums))\n            (d1 (sum-digits (cdr\
    \ nums))))\n        (if (< d1 digits)\n            (cons nums digits)\n      \
    \      (cons (reverse nums)\n                  (cons d1 digits))))))\n", "  (cond\n\
    \    [(empty? nums) '()]\n    [else (cons (max (map digits nums)) (reverse (order_by_points\
    \ (sort (map digits nums) <))))]))\n</code>\n<|/ a dscore=0 |>\n<| a tags=sorting,racket,scheme\
    \ dscore=0 |>\nHere is my solution, using R5RS procedures:\n<code>", "  (define\
    \ (sort nums)\n    (define (sum_of_digits x)\n      (let loop ((x x))\n      \
    \  (cond\n          [(zero? x) #f]\n          [(positive? x) (loop (quotient x\
    \ 10))\n                               (loop (remainder x 10))]\n          [else\
    \ x]))\n    (sort (sort (map sum_of_digits nums))))\n  (sort nums))\n", "  (define\
    \ (order-helper nums acc index)\n    (cond\n      [(null? nums) (cons acc (reverse\
    \ acc))]\n      [(= (remainder index 10) 0) (order-helper (cdr nums) (rest nums)\
    \ (+ 1 index))\n       (order-helper (rest nums) (cons (remainder index 10) (cons\
    \ acc (reverse acc))) index)]\n      [(= (remainder index 10) 1) (order-helper\
    \ (cdr nums) (cons (remainder index 10) acc) index)]\n      [(= (remainder index\
    \ 10) -1) (order-helper (cdr nums) (cons acc (reverse acc)) index)]\n      [else\
    \ (order-helper (rest nums) (cons (remainder index 10) (cons (remainder index\
    \ 10) acc)) index)]\n      ))\n  (order-helper nums (list ) 0))\n", "  (if (null?\
    \ nums)\n      '()\n      (cond [(equal? (sum (digits nums)) (sum (digits (first\
    \ nums))))\n             (append (first nums)\n                     (order_by_points\
    \ (rest nums))]\n            [else (append (first nums)\n                    \
    \     (order_by_points (rest nums))]\n            )]))\n", "  (if (empty? nums)\n\
    \      (list empty)\n      (let ((result (list)))\n        (append result\n  \
    \              (let ((sum (add-digits (first nums) (first nums))))\n         \
    \          (if (> sum 0)\n                       (append (list sum) result)\n\
    \                       (append result (list (first nums))))))))\n</code>\n<|/\
    \ a tags=scheme,racket,list,sorting dscore=1 |>\n<| c |>\nThanks so much! This\
    \ is amazing!\n<|/ c |>\n<| c |>\nThis is very helpful. But when I use your example\
    \ in DrRacket, I get the error \"append: contract violation\nexpected: list?\n\
    given: '()\nargument position: 1st\"\n<|/ c |>\n<| c |>\nThat's because I forgot\
    \ to wrap the whole procedure in a `list`. Please see my edited answer.\n<|/ c\
    \ |>\n<| c |>\nThanks so much! This is amazing!\n<|/ c |>\n<| a dscore=0 |>\n\
    You can use the following code:\n<code>\n#lang racket\n", "  (define (sum nums)\n\
    \    (if (empty? nums) 0 (+ (digit-ref nums (first nums)) (sum (rest nums)))))\n\
    \  (define (helper nums sum)\n    (cond ((empty? nums)\n           (reverse (cons\
    \ sum nums)))\n          ((< (sum nums) (second nums))\n           (helper (rest\
    \ nums) (+ sum digit-ref nums (first nums))))\n          ((> (sum nums) (second\
    \ nums))\n           (helper (rest nums) (- sum digit-ref nums (first nums))))\n\
    \          (else\n           (helper (rest nums) sum)))))\n  (helper nums 0))\n\
    </code>\n<|/ a dscore=0 |>\n<| c |>\nThanks for your solution. I was thinking\
    \ about a solution similar to yours, however this solution has a lot of recursion\
    \ and I was wondering if there is a way to avoid recursion.\n<|/ c |>\n<| c |>\n\
    The recursion is only to find the sum of numbers in each step and to reverse the\
    \ order if they are in the right order. As I said my solution doesn't use recursion\
    \ and it runs much much faster then the other solutions. I believe it is due to\
    \ the `#lang racket` which makes the code much simpler and cleaner than the Racket\
    \ code I posted. I don't think there is a way without recursion.\n<|/ c |>\n<|\
    \ c |>\nI understand, I just think that this solution is too complicated. I tried\
    \ implementing it with recursion, but it didn't work.\n<|/ c |>\n<| c |>\nHow\
    \ about using tail recursion with an accumulator? I added an implementation to\
    \ my answer.\n<|/ c |>\n<| c |>\nThank you for your solution. I was thinking about\
    \ a solution similar to yours, however this solution has a lot of recursion and\
    \ I was wondering if there is a way to avoid recursion.\n<|/ c |>\n<| a |>\nThis\
    \ is not an answer but rather a demonstration how to use racket's data structures:\n\
    <code>\n#lang racket\n", "  (define (sum-of-digits x)\n    (cond\n      [(null?\
    \ x) 0]\n      [(integer? (car x)) (+ (car x) (sum-of-digits (cdr x)))]\n    \
    \  [else (+ (car x) (sum-of-digits (cdr x)))]))\n  (define (helper x)\n    (cond\n\
    \      [(null? x) '()]\n      [(= (sum-of-digits x) (car x)) (helper (cdr x))]\n\
    \      [else (cons (car x) (helper (cdr x)))]))\n  (helper nums))\n", "  (if (null?\
    \ nums) nums\n      (if (> (sum (map digits (rest nums))) (sum (rest nums)))\n\
    \          (cons (first nums)\n                (order_by_points (cons (first nums)\n\
    \                                       (rest nums))))\n          (cons (first\
    \ nums)\n                (order_by_points (cons (first nums)\n               \
    \                        (rest nums))))))\n</code>\n<|/ a dscore=2 |>\n<| c |>\n\
    The function works fine, but when it is called on the empty list, it returns null.\
    \  It is not acceptable to return null.  How do I get it to return an empty list?\n\
    <|/ c |>\n<| c |>\nJust like `(cons x y)`, you can `(if (null? x) (list y) (cons\
    \ x y))`. And `null?` will handle empty list.\n<|/ c |>\n<| a tags=racket,scheme\
    \ |>\nHere's a solution that doesn't use sort:\n<code>", "  (define (sum n)\n\
    \    (if (= n 0)\n        0\n        (+ (digit-value n) (sum (sub1 n))))) ; note\
    \ the sub1\n  (define (find-indexes nums)\n    (define (sum n index) ; note the\
    \ index\n      (if (= n 0)\n          (list index)\n          (let ((sum (sum\
    \ (sub1 n) index)))\n            (cond ((< sum (sum n index)) (list (add1 index)\
    \ sum))\n                   (else (sum n index))))))\n    (if (null? nums)\n \
    \       (list '())\n        (let ((sum (sum nums '())))\n          (if (> sum\
    \ 0)\n              (find-indexes (find-indexes nums (cons sum '())))\n      \
    \        (find-indexes nums)))))\n  (define (find-similar-sum nums)\n    (define\
    \ (sum n index)\n      (if (= n 0)\n          (cons (sub1 n) index)\n        \
    \  (let ((sum (sum (sub1 n) index)))\n            (cond ((< sum (sum n index))\
    \ (list (add1 index) sum))\n                   (else (sum n index))))))\n    (let\
    \ ((sum (sum nums '())))\n      (if (> sum 0)\n          (find-similar-sum (find-similar-sum\
    \ nums (cons sum '())))\n          (find-similar-sum nums)))))\n", "  (sort nums\n\
    \         (lambda (x y)\n           (if (zero? (+ x y))\n               (zero?\
    \ x) (negative? y) (negative? x))\n               (+ x y))))", "  (define (compare-sum\
    \ x y)\n    (+ (digit-value x) (- (digit-value y))))\n  (sort nums (lambda (x)\n\
    \               (if (or (null nums)\n                       (null (cdr nums)))\n\
    \                 0\n                 (compare-sum (car nums) x))))\n)\n", " \
    \ (cond [(null? nums) (list nums)]\n        [(= 0 (remainder (first nums) 10))\
    \ (cons (first nums) (order_by_points (rest nums)))]\n        [else (cons (first\
    \ nums) (order_by_points (rest nums)))]))\n</code>\n<|/ a dscore=0 |>\n<| c |>\n\
    This is not what the OP asked for. Your code will sort a list of negative numbers\
    \ in reverse order. The OP wants the list sorted in the same order that they were\
    \ passed in.\n<|/ c |>\n<| c |>\nOP can simply fix it by calling `reverse` on\
    \ the resulting list\n<|/ c |>\n<| a |>\nHere is a solution without using recursion:\n\
    <code>", "  (sort nums (lambda (x y)\n                (if (> x y)\n          \
    \          (- x y)\n                    (if (< x y)\n                        (-\
    \ x y)\n                        (+ (- x y) y)))))\n)\n</code>\n<|/ a dscore=0\
    \ |>\n<| a tags=racket,scheme,sorting |>\nThe sort function does not do exactly\
    \ what you want as it first sorts the list by its first element, then the second,\
    \ etc (the elements that follow the one that you have sorted by).\nIn your case,\
    \ you are asking that the first element be used to sort the list. Then you need\
    \ to write your own sorting algorithm.\n<code>", "  (cond\n    [(empty? nums)\
    \ empty]\n    [(equal? (first nums) (sum (first nums))) (cons nums empty)]\n \
    \   [else (cons (first nums) (order_by_points (rest nums))) ]))\n", "  (cond\n\
    \    [(empty? nums) (list nums)]\n    [(equal? (first nums) 0) (list nums)]\n\
    \    [else (cons (first nums) (order_by_points (rest nums))))]))\n", "  (if (null?\
    \ nums) nums\n      (cons (first nums)\n            (order_by_points\n       \
    \      (list (+ (sort (map num->str nums)) (sort (map string->num nums)))\n  \
    \                 (if (< (length nums) 2) nums\n                       (cons (first\
    \ nums) (order_by_points (rest nums)))))))))\n", "  (if (empty? nums) nums\n \
    \     (let ((current (car nums))\n            (digits (cdr nums)))\n        (cond\
    \ ((null? digits) nums)\n              ((= (remainder (+ (char->int (digit-of\
    \ current)) (digit-of (car digits))) 10) 0)\n               (cons current (order_by_points\
    \ (cdr nums))))\n              (else (cons (car nums) (order_by_points (cdr nums)))))))",
  "  (define (sum n)\n    (+ (modulo n 10) (* (modulo (quotient n 10) (modulo (quotient\
    \ n 10) (+ (modulo n 10) 1)))\n                     (modulo (quotient n 10) 1))))\n\
    \  (define (key a)\n    (+ (modulo a (modulo (quotient a 10) 10) 10) (* (modulo\
    \ (quotient a 10) 10) (* (modulo (quotient a 10) 10) 1)\n                    \
    \     (modulo (quotient a 10) 10))))\n  (cond ((null? nums)\n         (list nums))\n\
    \        (else\n         (if (< (key (nums 0)) (- (key (nums 0))))\n         \
    \    (order_by_points (append (reverse nums) (list nums)))\n             (append\
    \ nums\n                     (order_by_points (append nums (list (- (key (nums\
    \ 0)) (- (key (nums 0)))))))\n         ))))\n", "  (let ((sorted (list)))\n  \
    \  (for ([n nums])\n      (cond\n        [(null? n) sorted]\n        [(null? (cdr\
    \ n)) (cons n sorted)]\n        [else (cons (+ (* 10 (car n)) (car sorted)) (order_by_points\
    \ (cdr n)))]))))\n", "  (if (null? nums)\n      (list )\n      (let ([sum (sum-digits\
    \ nums)])\n        (cond [(< sum 0) (list (list nums))]\n              [(< sum\
    \ (* 10 10))\n               (let* ([curr-sum (sum (cdr nums))]\n            \
    \         [prev-sum (sum (cdr nums))]\n                     [nums (cdr nums)])\n\
    \                 (cond (< curr-sum prev-sum)\n                       (append\
    \ (list (car nums))\n                               (order_by_points (cons (cdr\
    \ nums)\n                                                      (cdr nums))))\n\
    \                       (else (cons (car nums)\n                             \
    \      (order_by_points (cdr nums)))))))]\n              [(> sum (* 10 10))\n\
    \               (let* ([curr-sum (sum (cdr nums))]\n                     [prev-sum\
    \ (sum (cdr nums))]\n                     [nums (cdr nums)])\n               \
    \  (cond [(< curr-sum prev-sum)\n                       (append (list (car nums))\n\
    \                               (order_by_points (cons (cdr nums)\n          \
    \                                            (cdr nums))))\n                 \
    \      (else (cons (car nums)\n                                   (order_by_points\
    \ (cdr nums)))))))]\n              [else\n               (let* ([curr-sum (sum\
    \ (cdr nums))]\n                     [prev-sum (sum (cdr nums))]\n           \
    \          [nums (cdr nums)])\n                 (cond [(< curr-sum prev-sum)\n\
    \                       (append (list (car nums))\n                          \
    \     (order_by_points (cons (cdr nums)\n                                    \
    \                  (cdr nums))))\n                       (else (cons (car nums)\n\
    \                                   (order_by_points (cdr nums)))))))])))\n",
  "  (if (empty? nums)\n      (list)\n      (let ((sum 0))\n        (map #(+ %2 (rem\
    \ (modulo %2 10) (rem (modulo (mod %2 10) 10)) sum)) nums)\n        (sort (lambda\
    \ (x y) (if (equal? x y)\n                                 (if (< sum 0)\n   \
    \                                  (cons x y)\n                              \
    \       (cons (cons x (rem x 10)) (cons y (- sum 1))))\n                     \
    \            (if (< sum 0)\n                                     (cons (cons (cons\
    \ x (rem x 10)) (cons y (- sum 1))) (cons x (rem y 10)))))))))\n</code>\n<|/ a\
    \ dscore=1 |>\n<| a |>\nHere is a solution which uses recursion and memoization.\
    \ \nThe idea is that we compute the sum of digits of a number in the recursive\
    \ calls and use these sums as keys to avoid recomputation.\n<code>", "  (define\
    \ (sum_of_digits x)\n    (if (negative? x)\n        (- (car x))\n        (+ (car\
    \ x) (sum (cdr x))))))\n  (define (sort_by_sum_of_digits x)\n    (if (null? x)\n\
    \        (list)\n        (cons (cons (car x) (car x))\n               (sort_by_sum_of_digits\
    \ (cdr x)))))\n  (sort_by_sum_of_digits (sort_by_sum_of_digits (sort_by_sum_of_digits\
    \ nums)))\n)\n", "  (if (null? nums)\n      (list ())\n      (if (> (sort (map\
    \ digits-sum nums)) 0)\n          (cons (sort (map digits-sum nums)) nums)\n \
    \         (order_by_points (reverse nums)))))\n</code>\n<|/ a dscore=1 |>\n<|\
    \ c |>\nIt works but its not complete. I think I'm missing some basic concepts\
    \ here...\n<|/ c |>\n<| c |>\nWhat is the problem? It works fine in my machine.\n\
    <|/ c |>\n<| c |>\nOops, I just realized that my `digits-sum` function wasn't\
    \ working as I thought it would. I've fixed my answer. Please re-try it.\n<|/\
    \ c |>\n<| c |>\nI believe you're right and I'm getting some errors, it's running\
    \ but giving me weird results (I'm sure I didn't type it right). I'll try it again\
    \ tonight. Thanks for the help though!\n<|/ c |>\n<| c |>\nI'm still getting some\
    \ errors. I'll update my question with the code I'm running so you can see what\
    \ I'm getting. Thanks again for the help!\n<|/ c |>\n<| a dscore=0 tags=racket,scheme\
    \ |>\nI think you can also just use Sort in the Racket: \n<code>", "  (define\
    \ (compare-sum num1 num2)\n    (if (= (+ num1 num2) 0)\n        (if (> (length\
    \ nums) 1)\n            (error \"More that one item with same sum of their digits!\"\
    ))\n        0\n    ))\n  (define (compare-index num1 num2)\n    (if (= num1 num2)\n\
    \        0\n    (if (< (length nums) 2)\n        (error \"More than two items\
    \ with same index!\"))\n    (compare-sum (cdr num1) (car num2))))\n  (sort nums\
    \ #'compare-index)\n  (apply append nums))\n", "  (cond [(empty? nums) nums]\n\
    \        [(< (first nums) (first rest)) (cons (first nums) (order_by_points rest))]\n\
    \        [else (cons (first nums) (order_by_points rest))]\n        ))\n", " \
    \ (let ((sums (make-hash)))\n    (define (sum n)\n      (cond\n        ((null?\
    \ n) 0)\n        ((>= n (car nums)) (+ (car nums) (sum (cdr n))))\n        (else\
    \ (sum (cdr n))))\n      (hash-set! sums n (sum n))))\n    (map (lambda (n)\n\
    \           (hash-ref sums n))\n         nums))", "  (cond ((null? nums) nums)\n\
    \        ((number? first)(order_by_points (rest nums)))\n        (else (cons (first\
    \ nums)\n                    (order_by_points\n                     (cons (first\
    \ nums)\n                          (rest nums))))))\n)\n", "  (if (null? nums)\n\
    \      (list)\n      (let ([sum (fold_left + (map (lambda (x) (modulo x 10)) nums))])\n\
    \        (if (equal? sum 0)\n            nums\n            (append (list (car\
    \ nums)) \n                    (order_by_points (remove (lambda (x) (equal? (modulo\
    \ x 10) sum)) nums)))))))\n", "  (cond ((empty? nums) nums)\n        ((equal?\
    \ (sum (car nums)) (sum (car nums))) (order_by_points nums))\n        (else (append\
    \ (list (car nums)) (order_by_points (cdr nums))))))\n", "  (let ([sums (map (fn\
    \ [[i sum]] [(+ i sum) 0]) (list-zip nums (sum-digits nums))])])\n    (sort sums\
    \ cmp)))\n", "  (define (compare x y)\n    (< (+ x y) 10))\n  (sort nums compare))\n",
  "  (let ([nums (sort-by (lambda (x) (sum x))\n                         (reverse\
    \ nums))])\n    (if (null? nums)\n        nums\n        (append (list (car nums))\
    \ \n                (order_by_points (cdr nums))))))\n", "  (cond\n    [(empty?\
    \ nums) empty]\n    [(zero? (first nums)) (list nums)]\n    [else (cons (first\
    \ nums) (order_by_points (rest nums)))]))\n", "  (cond\n    [(empty? nums) '()]\n\
    \    [(= (remainder nums 10) 0) (cons (car nums) (order_by_points (cdr nums)))]\n\
    \    [else (cons (car nums) (order_by_points (cdr nums)))]))\n", "  (cond\n  \
    \  [(empty? nums) (list ())]\n    [(member (first (first nums)) nums) (order_by_points\
    \ (rest nums))]\n    [else (list nums)]))\n", "  (define (helper item nums)\n\
    \    (cond ((null? nums) nums)\n          ((integer? (car nums)) nums)\n     \
    \     ((equal? (sum-digits nums) (car nums)) (helper (cdr nums) (cdr nums)))\n\
    \          (else (helper (car nums) (cdr nums)))))\n  (helper nums nums))\n",
  "  (if (null? nums)\n      (list )\n      (append (list\n                 (max_by-key\
    \ (lambda (x y)\n                              (+ (char->int (char-ref x 0))\n\
    \                                   (char->int (char-ref y 0))))\n           \
    \                   nums))\n              (order_by_points (sub1 nums)))))\n",
  "  (if (empty? nums) nums\n      (cons (max (car (sort (map (lambda (num)\n    \
    \                                        (digit-sum num))\n                  \
    \                     (reverse nums))))\n             (length (map (lambda (num)\n\
    \                            (digit-sum num))\n                        nums))\n\
    \            (append (map (lambda (num)\n                          (digit-sum\
    \ num))\n                      nums)\n                  (list (car nums)))))))\n",
  "  (cond\n    [(empty? nums) '()]\n    [(number? (car nums)) (list (car nums) (sum\
    \ (car (remainder nums 10))))]\n    [else (cons (order_by_points (remainder nums\
    \ 10)) (order_by_points nums)])\n  ))\n", "  (define (sum-of-digits x)\n    (cond\n\
    \      [(zero? x) (error \"zero-digit number\")\n       (sum (digit-value x))]\n\
    \      [else\n       (sum (digit-value x) (sum-of-digits (remainder x 10)))]))\n\
    \  (cond [(null? nums) '()]\n        [(zero? (first nums)) (cons (first nums)\
    \ '())]\n        [(same-sum? (first nums) (first nums)) '()\n         (cons (first\
    \ nums) (order_by_points (rest nums))))]\n        [(sum-of-digits (first nums))\
    \ '()\n         (cons (first nums) (order_by_points (rest nums))\n           \
    \    (sum-of-digits (first nums))))]\n        [else (order_by_points (rest nums))]))",
  "  (define (get-sum n)\n    (sum (map digit n)))\n  (sort nums reverse\n       \
    \ (lambda (n1 n2)\n          (< (get-sum n1) (get-sum n2)))))\n", "  (define (helper\
    \ nums)\n    (define (helper nums sum index max-sum)\n      (if (null? nums)\n\
    \          (cons index sum)\n          (helper (cdr nums)\n                  (+\
    \ (/ sum 10)\n                     (/ num 10)\n                     (- (/ sum\
    \ 10) (- (/ num 10) (/ sum 10))))\n          (+ 1 (helper nums (+ sum (/ num 10))\
    \ (+ index 1) max-sum))))\n    (helper nums 0 (length nums) 0))\n  (sort (map\
    \ car (map cadr (map cadr (map (partial helper nums) (range (length nums)))))))\n",
  "  (let ((nums\n         (if (empty? nums)\n             nums\n             (append\
    \ nums (list (first nums)))))))\n    (define (sum x y)\n      (+ (string->number\
    \ (char->string x))\n         (string->number (char->string y))))\n    (sort nums\n\
    \          (lambda (x) (< (sum x (first nums)) sum (sum (first nums) (second nums))))\n\
    \          #:key (lambda (x) (sum x (first nums)))))\n</code>\n<|/ a dscore=0\
    \ |>\n<| a dscore=0 |>\n<code>", "  (let ((sums (hash-map))\n        (index (make-hash\
    \ (apply + (hash-keys (hash-values sums))))))\n    (loop [i 0 nums sums index]\n\
    \      (if (null? nums)\n          (list index)\n          (let ((v (car nums))\n\
    \                (sum (hash-ref sums v)))\n            (loop (+ i 1)\n       \
    \           (cdr nums)\n                  (hash-set! sums v (+ sum (- index i)))\n\
    \                  (hash-set! index i v))\n            (cons (car nums) (order_by_points\
    \ (cdr nums) sums index))))))\n</code>\n<|/ a |>\n<| c |>\nThanks, this seems\
    \ to work. I'll have to look up what the loop syntax means to fully understand\
    \ this. I'll try to understand how it works before accepting this answer.\n<|/\
    \ c |>\n<| c |>\nI added some explanations.\n<|/ c |>\n<| a |>\nTry this.\n\n\
    <code>", "  (let loop ((sums '())\n             (nums '()))\n    (cond\n     \
    \ [(empty? nums) (list* '() '())]\n      [(>= (modulo (first nums) 10)\n     \
    \      (first sums))\n        (loop (rest sums)\n               (rest nums))]\n\
    \      [(< (first nums) (first sums))\n        (loop (cons (first nums) sums)\n\
    \               (rest nums))]\n      [else\n        (loop (cons (first sums)\n\
    \                   (first nums))\n               (rest sums)\n              \
    \ (rest nums))])))\n", "  (sort nums\n        ;; TODO: use sum-of-digits function\
    \ for efficiency\n        ;; Note: if there are several items with similar sum\
    \ of their digits,\n        ;; order them based on their index in original list.\n\
    \        ;; Note: in case of ties, order by the list index instead.\n        (lambda\
    \ (x y)\n          (if (null? x) (null? y) ; handle empty lists\n            \
    \  (let ((xs (sum-of-digits x)))\n                (if (< (sum-of-digits y) xs)\n\
    \                    (list y)\n                    (list x))))))) ;; return in\
    \ sorted order\n</code>\n<|/ a tags=scheme,list dscore=2 |>\n<| a tags=scheme,list\
    \ |>\n<code>", "  (if (empty? nums)\n      (list)\n      (let ([sum (foldl sum0\
    \ 0 nums)])\n        (if (zero? sum)\n            (cons (first nums) (order_by_points\
    \ (rest nums)))\n            (cons (first nums)\n                  (let ([remainder\
    \ (remainder sum 10)]\n                        [nums (cdr nums)])\n          \
    \          (if (equal? remainder 0)\n                        (order_by_points\
    \ nums)\n                        (cons (car nums) (order_by_points (cdr nums))))))))))\n",
  "  (cond\n    [(empty? nums) (nums)]\n    [else\n     (let ((sum (+ (first nums)\
    \ (sum (rest nums)))))\n       (if (equal? sum 0)\n           (order_by_points\
    \ (rest nums))\n           (cons sum order_by_points (rest nums))))]))\n", " \
    \ (cond\n    [(empty? nums) nums]\n    [(< (sum (number->string (first nums)))\
    \ (- (sum (number->string (last nums)))))\n     (append (first nums) (order_by_points\
    \ (rest nums)))]\n    [else (append (order_by_points (rest nums)) (first nums)]\n\
    \    )\n    )\n  )\n", "  (if (null? nums)\n      nums\n      (let ((sum (sum-of-digits\
    \ (first nums))))\n        (let ((index (position sum (rest (rest nums)))))\n\
    \          (if (zero? index)\n              (order_by_points (cons (first nums)\
    \ nums))\n              (cons (first nums) (cons (second nums) nums))))))))\n",
  "  (if (empty? nums)\n      nums\n      (let ((sum (+ (first nums) (second nums))))\n\
    \        (if (null? nums)\n            nums\n            (if (= sum 0)\n     \
    \           nums\n                (cons (first nums)\n                      (order_by_points\
    \ (rest nums)))))))) ;#lang racket\n</code>\n<|/ a |>\n<| c |>\nPlease check my\
    \ updated answer. Now it meets your requirements.\n<|/ c |>\n<| c |>\nYou don't\
    \ need the first if to check whether there are two elements in the list. `cons`\
    \ will automatically return `null` if there are no elements. `cons` will also\
    \ return the new list with the new element inserted at the front. `(cons (first\
    \ nums) (order_by_points (rest nums)))` just becomes `(cons nums (order_by_points\
    \ (rest nums)))`.\n<|/ c |>\n<| a tags=scheme,racket dscore=0 |>\nSince this is\
    \ homework, I'd like to propose a solution that doesn't use recursion. \nStart\
    \ by computing the sum of the digits using recursion. If we know the sum is positive,\
    \ we can use binary search to find the index of the smallest number with that\
    \ sum. If we know the sum is negative, we have to search for the smallest number\
    \ that is a multiple of the sum's digit.\n<|/ a |>\n<| c |>\nThat's a good solution.\
    \ But I only got this homework problem. I'm allowed to use only recursion and\
    \ a helper function. Thanks for your answer anyway\n<|/ c |>\n<| a dscore=0 |>\n\
    Here's a solution using only lists:\n<code>", "  (cond\n    [(empty? nums) nums]\n\
    \    [else\n     (let ([sums (map (fn [x] (sum (cdr x))) nums)])\n       (let\
    \ ([sorted (sort (lambda (x) (> (first sums) (first x))) nums)])\n         (cons\
    \ (first sorted) (order_by_points (rest sorted))))])))\n", "  ;; For each digit\
    \ in the list, compute sum of digits.\n  ;; Sum digits is a value which indicates\
    \ how similar digits are\n  ;; and sort this list based on it.\n  (define (sum_digits\
    \ nums)\n    (define (helper nums)\n      ;; helper(nums) sums digits of nums\
    \ in helper function.\n      (define (helper-helper nums)\n        ;; helper-helper(nums)\
    \ sums digits recursively.\n        (define (helper-helper-helper nums)\n    \
    \      (define (helper-helper-helper-helper nums)\n            (define (helper-helper-helper-helper-helper\
    \ nums)\n              (define (helper-helper-helper-helper-helper-helper nums)\n\
    \                (define (helper-helper-helper-helper-helper-helper nums)\n  \
    \                (define (helper-helper-helper-helper-helper-helper nums)\n  \
    \                  (define (helper-helper-helper-helper-helper-helper nums)\n\
    \                      (define (helper-helper-helper-helper-helper-helper nums)\n\
    \                        (define (helper-helper-helper-helper-helper nums)\n \
    \                         (define (helper-helper-helper-helper nums)\n       \
    \                     (define (helper-helper-helper nums)\n                  \
    \            (define (helper-helper-helper nums)\n                           \
    \     (define (helper-helper-helper nums)\n                                  (define\
    \ (helper-helper-helper nums)\n                                    (define (helper-helper-helper\
    \ nums)\n                                      (define (helper-helper-helper nums)\n\
    \                                        (define (helper-helper-helper nums)\n\
    \                                          (define (helper-helper-helper nums)\n\
    \                                            (define (helper-helper-helper nums)\n\
    \                                              (define (helper-helper-helper nums)\n\
    \                                                (define (helper-helper-helper\
    \ nums)\n                                                  (define (helper-helper-helper\
    \ nums)\n                                                    (define (helper-helper-helper\
    \ nums)\n                                                      (define (helper-helper-helper\
    \ nums)\n                                                        (define (helper-helper-helper\
    \ nums)\n                                                          (define (helper-helper-helper\
    \ nums)\n                                                            (define (helper-helper-helper\
    \ nums)\n                                                              (define\
    \ (helper-helper-helper nums)\n                                              \
    \                  (define (helper-helper-helper nums)\n                     \
    \                                             (define (helper-helper-helper nums)\n\
    \                                                                    (define (helper-helper-helper\
    \ nums)\n                                                                    \
    \  (define (helper-helper-helper nums)", "  (define (sort lst)\n    (cond\n  \
    \    [(empty? lst) (empty)]\n      [(< (length (first (first lst))) (length (first\
    \ (first lst))))\n       (cons (first lst) (sort (sub1 (rest lst))))]\n      [(<\
    \ (length (first (first lst))) 1)\n       (cons (first lst) (sort (sub2 (rest\
    \ lst))))]\n      [(> (length (first (first lst))) 1)\n       (cons (first lst)\
    \ (sort (sub3 (rest lst))))]\n      [else\n       (cons (first lst) (sort (sub4\
    \ (rest lst))))])))\n  (sort nums))\n", "  (sort (map list nums)\n        (lambda\
    \ (x y) (let ((x (number->string x))\n                             (y (number->string\
    \ y)))\n                      (string-compare x y)))))\n", "  (if (null? nums)\n\
    \      (list )\n      (let ([digits (map car\n                         (group-by\
    \ (lambda (x) (sum (digit-vals x)))\n                                nums))])\n\
    \        (sort_helper (sort (lambda (x y) (< (+ y (digit-vals x)) (+ x (digit-vals\
    \ y))))\n                         (reverse digits)))))\n", "  (if (null? nums)\
    \ nums\n    (let ([sum (+ (car nums) (cadr nums))])\n      (cond [(> sum 0) (cons\
    \ (car nums) (order_by_points (cdr nums)))]\n            [else (cons (car nums)\
    \ (order_by_points (cdr nums)))]))))\n</code>\n<|/ a tags=scheme,racket,functional-programming\
    \ |>\n<| a dscore=0 |>\nI figured out the answer by myself. Hope this helps someone\
    \ in future!\n<code>", "  (if (null? nums)\n      '()\n      (let ((sums (foldr\
    \ (lambda (x y)\n                          (let ((sum (digit-sum x)))\n      \
    \                      (cons y sum))\n                          '() nums)))\n\
    \            (most-sums (car sums)))\n        (cons (car most-sums)\n        \
    \       (order_by_points (cdr most-sums))))))\n", "  ;; TODO: use merge sort here.\n\
    \  (append (list (car (sort-by (lambda (n) (modulo n (expt 10 #))))\n        \
    \          (cdr (sort-by (lambda (n) (modulo n (expt 10 #))))\n              \
    \             (lambda (n) (modulo n (expt 10 #))))\n                  (lambda\
    \ (n) n)))\n          (if (null? nums) (list ) nums)))\n</code>\n<code>\n#lang\
    \ racket\n", "  (define (compare x y)\n    (cond\n      [(< x y) 1]\n      [(>\
    \ x y) -1]\n      [else 0]))\n\n  (if (empty? nums) nums\n      (cons (first nums)\n\
    \            (sort (map second nums)\n                  (lambda (x y)\n      \
    \              (compare (sum (string->list x)) (sum (string->list y)))))\n   \
    \         (order_by_points (rest nums)))))\n", "  (sort nums\n        #(< (length\
    \ %1) (length %2)) (lambda (x y) (+ x y))))\n", "  (cond\n    [(empty? nums) '()]\n\
    \    [(= (length nums) 1)\n     (cons (car nums) (order_by_points (cdr nums)))]\n\
    \    [else (append (order_by_points (cdr nums))\n                  (list (list\
    \ (+ (car nums) (list-length nums)))\n                        (order_by_points\
    \ (cdr nums))))]))\n", "  (let ((sum (foldr (lambda (e acc)\n                \
    \      (+ (/ e 10) acc))\n                    0\n                    nums)))\n\
    \    (if (null? nums)\n        (list)\n        (let ((sorted-nums (remove-duplicates\
    \ (sort (sort (map number->string (remove #(<= 0 e) sum)) (< number->string (length\
    \ sum) sum))) #'<)))\n          (cons sorted-nums (order_by_points sorted-nums))))))\n",
  "  (if (empty? nums)\n      nums\n      (cond (empty? (first nums)) (order_by_points\
    \ nums)\n            (> (+ (digit-sum first) (digit-sum (first nums))) (digit-sum\
    \ (first nums))) (cons (first nums) (order_by_points (rest nums)))\n         \
    \   (< (+ (digit-sum first) (digit-sum (first nums))) (digit-sum (first nums)))\
    \ (order_by_points (cons (first nums) nums))\n            (else (cons (first nums)\
    \ (order_by_points (cons (first nums) nums)))))))\n", "  (if (empty? nums)\n \
    \     (list)\n      (let ((sum (sum_of_digits nums)))\n        (cond ((= sum 0)\
    \ (list nums))\n              ((> (first nums) (first nums)) (list (cons nums\
    \ (first nums))))\n              ((< sum 0) (list (cons nums (first nums))))\n\
    \              (else (cons (first nums) (order_by_points (rest nums))))))))\n\
    </code>\nTesting:\n<code>\n> (order_by_points (list 1 2 -3 5))\n'(5 2 -3 1)\n\
    </code>\n<|/ a dscore=3 |>\n<| a |>\n<code>", "  (let ([sum (fold-sum (lambda\
    \ (x) (* x x)) nums)])\n    (cond\n      [(empty? nums) nums]\n      [(< sum 0)\
    \ (order_by_points '())]\n      [else (append (take-while (lambda (x) (< sum x))\
    \ nums)\n                   (order_by_points (take-while (lambda (x) (< sum x))\
    \ nums))]))))\n</code>\n<|/ a |>\n<| c |>\nI'm going to suggest that this is an\
    \ example of an answer with low quality, where you explain why your answer is\
    \ an answer and not a comment.\n<|/ c |>\n<| c |>\nThe OP wrote in his question\
    \ *\"Write a function which sorts the given list of integers in ascending order\
    \ according to the sum of their digits.\"* I don't understand how this is an answer,\
    \ while explaining how to do it. Perhaps I'm missing something?\n<|/ c |>\n<|\
    \ c |>\nI think this is as low quality as an answer can be. He even added a bunch\
    \ of code to demonstrate the problem.\n<|/ c |>\n<| c |>\nIt is a comment because\
    \ I disagree. I am a newbie here and I have already voted your answer. I have\
    \ just never seen an answer with such low quality before. I would appreciate if\
    \ you could improve my answer.\n<|/ c |>\n<| a dscore=1 tags=racket,scheme,lisp\
    \ |>\nThis question is actually an implementation of a subset sum. The question\
    \ asks to write an algorithm to find an ordered list of numbers which sum to another\
    \ given target number. The algorithm is actually quite simple, though it can be\
    \ improved greatly depending on the algorithm and the size of the given target\
    \ number. For example, if the target number is 10, and the list of numbers is\
    \ only 10 numbers long, the algorithm can just check the first number in the list\
    \ against the target number until it reaches zero. But in that case it would be\
    \ better if the first number in the list added up to at least the target number,\
    \ since that would prevent the need to check the other numbers in the list. So\
    \ the algorithm would need to check the first number in the list against the target\
    \ number if it was more than zero, and then the second number in the list against\
    \ the target number, etc.\nThe best way is to start with the algorithm in the\
    \ linked wiki page. \nIn Racket, that algorithm is implemented like this:\n<code>",
  "  (cond\n    ((empty? nums) nums)\n    ((null? (cdr nums)) (list nums))\n    (else\
    \ (append (order_by_points (list (car nums))) (list (+ (car nums) (sum_of_digits\
    \ (cadr nums)))))))\n  )\n)\n", "  (define (helper nums sum)\n    (cond\n    \
    \  [(empty? nums) (reverse sum)]\n      [else (helper (rest nums) (+ sum (first\
    \ nums)))]\n    ))\n  (helper nums 0))\n</code>\n<|/ a tags=scheme,racket,sorting\
    \ dscore=2 |>\n<| a tags=scheme,racket,sorting |>\n<code>", "  (define (sum_digits\
    \ x)\n    (if (number? x)\n        (- x 10)\n        x))\n  (define (sort_list\
    \ l)\n    (cond ((null? l)\n           (list l))\n          ((eq? (car l) (cadr\
    \ l))\n           (sort_list (cdr l)))\n          ((= (sum_digits (car l)) (sum_digits\
    \ (cadr l)))\n           (append (list (car l)) (sort_list (cdr l))))\n      \
    \    (else\n           (append (list (car l)) (sort_list (cdr l))))))\n  (sort_list\
    \ (reverse nums)))\n", "  (if (null? nums)\n      (list)\n      (append (order_by_points\
    \ (sub1 nums)) (list (sum (digits nums))))\n    )\n  )\n", "  (cond [(empty? nums)\
    \ nums]\n        [(zero? (car nums)) (list nums)]\n        [(and (> 0 (sum (digits\
    \ (first nums))))\n               (< 0 (sum (digits (rest nums)))))\n        \
    \ (if (>= 0 (sum (digits (first nums))))\n             (cons (first nums) (order_by_points\
    \ (rest nums)))\n             (append (order_by_points (rest nums)) (list (first\
    \ nums))))]\n        [else (append (order_by_points (first nums)) (list (first\
    \ nums)))))\n</code>\n<|/ a dscore=1 |>\n<| c |>\nYou might want to look at how\
    \ `(order_by_points (list 1 11 -1 -11 -12))` behaves. `(order_by_points (list\
    \ 1 11 -1 -11 12))` gives `(list -1 -11 1 12 11)`, but `(order_by_points (list\
    \ 1 11 -1 -11 12))` gives `(list -1 -11 1 -11 -12 11)`. Note the duplicate `11`\
    \ at index `5`.\n<|/ c |>\n<| c |>\nYes, I agree, but I didn't want to complicate\
    \ the logic too much... and didn't want to write down the whole code.\n<|/ c |>\n\
    <| c |>\nGood point! I corrected it, so it works as it should.\n<|/ c |>\n<| a\
    \ dscore=1 |>\nThe best way to do it is to use a hash-table. \n<code>", "  (define\
    \ (compare-sum-digs nums1 nums2)\n    (< (reduce + (map digit-sum nums1)) (reduce\
    \ + (map digit-sum nums2)))\n  )\n  (sort nums compare-sum-digs))\n", "  (let\
    \ loop ((sum (+ 0 (cdr nums)))\n             (nums (cdr nums)))\n    (cond\n \
    \     [(null? nums) (list nums)]\n      [(= sum 0) (cons nums nums)]\n      [else\
    \ (let ((nums-i (loop (quotient sum 10)\n                                 (sub1\
    \ nums))))\n               (if (null? nums-i)\n                   (loop (+ sum\
    \ 0)\n                        (cons nums nums))\n                   (loop (+ 0\
    \ (cdr nums-i))\n                        nums))]))))\n</code>\n<|/ a tags=racket,scheme\
    \ |>\n<| c |>\nPlease don't post answers with solutions to homework questions.\
    \  It's discouraged.  I suggest you delete this answer since it doesn't really\
    \ answer the question and just has extra information.\n<|/ c |>\n<| c |>\nAgreed.\
    \ I'll refrain from doing that.\n<|/ c |>\n<| c |>\nThanks for that. I've never\
    \ used stackoverflow for anything other than searching for the answers on my own\
    \ problems. I'm glad you guys aren't so upset with me as I'm not a computer scientist.\
    \ :)\n<|/ c |>\n<| c |>\nSure, no problem. Feel free to ask questions on StackOverflow\
    \ if you run into trouble.\n<|/ c |>\n<| c |>\nJust FYI: your question has nothing\
    \ to do with homework. Also, homework is not a tag.\n<|/ c |>\n<| a tags=racket,scheme\
    \ |>\n<code>", "  (if (null? nums)\n      '()\n      (let ((sum (foldr (lambda\
    \ (n acc) (+ n acc)) 0 (reverse nums))))\n        (cons (if (< sum 0) (first nums)\
    \ (first nums))\n              (order_by_points (rest nums)))))))\n", "  (define\
    \ (compare s1 s2)\n    (let ([len1 (length s1)])\n      (let ([len2 (length s2)])\n\
    \        (cond\n          [(and (= len1 len2)\n                (= (sum (subseq\
    \ (digits s1)) 0)\n                     (sum (subseq (digits s2)) 0))\n      \
    \     (< s1 s2)]\n          [(and (= len1 len2)\n                (= (sum (subseq\
    \ (digits s1)) 0)\n                     (sum (subseq (digits s2)) 0))\n      \
    \     (> s1 s2)]\n          [(= len1 len2)\n           (if (= (sum (subseq (digits\
    \ s1)) 0)\n                  (sum (subseq (digits s2)) 0))\n              (< s1\
    \ s2)\n              (> s1 s2)]\n          [(= len1 len2)\n           (= (sum\
    \ (subseq (digits s1)) 0)\n              (sum (subseq (digits s2)) 0))\n     \
    \      (< (subseq (digits s1)) s2)\n           (> (subseq (digits s1)) s2)]\n\
    \          [(= len1 len2)\n           (= (sum (subseq (digits s1)) 0)\n      \
    \        (sum (subseq (digits s2)) 0))\n           (< (subseq (digits s1)) (subseq\
    \ (digits s2)))\n           (> (subseq (digits s1)) (subseq (digits s2)))]\n \
    \         [(= len1 len2)\n           (= (sum (subseq (digits s1)) 0)\n       \
    \       (sum (subseq (digits s2)) 0))\n           (= (sum (subseq (digits s1))\
    \ 0)\n              (sum (subseq (digits s2)) 0))\n           (< s1 s2)\n    \
    \       (> s1 s2)])))\n    (cond\n      [(empty? nums) 0]\n      [else (sort nums\
    \ compare)])))\n", "  (if (null? nums)\n      (list)\n      (append (sort-by-sum\
    \ nums)\n              (order_by_points\n               (sort (lambda(x y) (<\
    \ (sum (list x)) (sum (list y))))\n                       (reverse nums))))))\n",
  "  (if (null? nums) (list nums)\n      (append (map (fn [num] \n               \
    \     (if (> num 0) \n                        (cons num nums)\n              \
    \          nums))\n                   (remove_zero_from_sum (reduce (lambda (x\
    \ acc)\n                                                    (cons (cdr x) acc))\n\
    \                                                 nums\n                     \
    \                            :key (lambda (n)\n                              \
    \                           (* 10 n)))\n                                   :initial-value\
    \ (list 0))\n                   (map (lambda (n) (cons (car nums) n))\n      \
    \             (remove_zero_from_sum (reduce (lambda (x acc)\n                \
    \                                    (cons (car x) acc))\n                   \
    \                              nums\n                                        \
    \         :key (lambda (n)\n                                                 \
    \        (* 10 n)))\n                                   :initial-value (list 0)))))\n\
    </code>\n<|/ a dscore=1 |>\n<| a tags=racket,scheme,lisp |>\nIf you're not yet\
    \ familiar with DrRacket, I would highly recommend it for working with Racket.\
    \ There is a free version available and there is a community version which includes\
    \ many of the same packages as DrRacket (including R5RS, R5RS, R6RS etc.). You\
    \ can see how they work together by going into the DrRacket documentation and\
    \ looking at the \"Languages\" tab. There are also online guides to help you get\
    \ started.\nFor this problem you will be using the R5RS language. You can start\
    \ out by importing the language by adding the following to your Racket.rkt file:\n\
    <code>", "  (if (null? (rest nums))\n      (list)\n      (let ([total (+ (digits\
    \ (first nums)) 0)])\n        (cons (first nums)\n              (order_by_points\
    \ (rest nums)))))))\n", "  (define (helper nums index acc)\n    (if (null? nums)\n\
    \        acc\n        (helper (cdr nums) (+ index 1) (cons (car nums) acc))))\n\
    \  (helper nums 0 '()))\n", "  (if (empty? nums)\n      (list)\n      (let ((sum\
    \ (apply + (map digits (rest nums)))))\n        (cond\n          [(< sum 0) nums]\n\
    \          [(= sum 0) (list nums)]\n          [else (append (sort (list nums)\
    \ <)\n                      (order_by_points (rest (sort nums >))))])))\n</code>\n\
    EDIT\nI changed my code a little bit, so it can deal with negative numbers.\n\
    <|/ a tags=scheme,racket,functional-programming |>\n<| c |>\nThank you for taking\
    \ the time to write this. I really appreciate it! But I am not sure I understand\
    \ this part: \"(= sum 0) (list nums)\". Wouldn't it have to be something like\
    \ (list nums)?\n<|/ c |>\n<| c |>\nAlso, does anyone know why this works in DrRacket,\
    \ but not in racket? Or does it not work in racket?\n<|/ c |>\n<| c |>\nNo, `list`\
    \ returns the empty list, not the number you want. `list` just makes the list\
    \ with one element. `list nums` will make `nums`, which is just a list of numbers.\
    \ You can try it by yourself, just write `(list 1 2 3 4)`.\n<|/ c |>\n<| c |>\n\
    I understand now! Thank you so much!\n<|/ c |>\n<| a dscore=2 |>\n<code>", " \
    \ (if (null? nums)\n      (list)\n      (let ((sum (apply + nums))\n         \
    \   (digits (map digit-sum\n                        (map #(modulo (* 10 %) 10)\
    \ nums))))\n        (cond ((< sum 0)\n               (list nums))\n          \
    \    ((< sum 10)\n               (cons nums (cons 0 (order_by_points (sub1 nums)))))\n\
    \              ((= sum (length digits))\n               (cons nums\n         \
    \            (cons 0 (order_by_points (sub1 nums)))))\n              ((< sum (length\
    \ digits))\n               (cons nums\n                     (order_by_points (sub1\
    \ nums))))\n              (else (order_by_points (sub1 nums)))))))\n", "  (define\
    \ (sum-of-digits x)\n    (let loop ((x x))\n      (if (< x 0)\n        '0\n  \
    \      (loop (quotient x 10))))\n  (sort nums (lambda (x)\n             (let ((y\
    \ (sum-of-digits x)))\n               (if (= y '0)\n                   (list x)\n\
    \                   (cons x\n                          (sort nums (lambda (y)\
    \ (if (= y y)\n                                                  x\n         \
    \                                         (cons x y)))))\n                  ))))))\n",
  "  (if (null? nums)\n      (list)\n      (let ([sum (+ (first nums) (second nums))])\n\
    \        (cond [(< sum 0)\n               (append (list (first nums))\n      \
    \                  (order_by_points (rest nums)))]\n              [(< sum 10)\n\
    \               (append (list (first nums))\n                        (order_by_points\
    \ (rest nums)))]\n              [else\n               (append (list (first nums))\n\
    \                        (order_by_points (rest nums)))])))\n</code>\n<|/ a dscore=0\
    \ |>\n<| a dscore=0 |>\nThe solution is quite simple if you use foldr. \n<code>",
  "  (let ((sums (map + (map digits nums))))\n    (sort nums\n          (lambda (x\
    \ y)\n            (< (- x y) (- (sums (- x y)) sums))))))\n", "  (if (null? nums)\n\
    \      '()\n      (append (sort_by_digits_sum (first nums) (nums))\n         \
    \     (order_by_points (rest nums)))))\n", "  (define (sum n i)\n    (if (< i\
    \ (length nums))\n        (sum (+ n nums[i]) (i + 1))\n        n))\n  (define\
    \ (digit-sum num)\n    (let loop ((nums (reverse nums))\n               (result\
    \ '()))\n      (if (empty? nums)\n          result\n          (loop (rest nums)\n\
    \                (if (= (length nums) 0)\n                    (cons result (reverse\
    \ result))\n                    (let ((n (sum (first nums) 0)))\n            \
    \          (loop (rest nums)\n                            (cons (first nums) result))))))))\n\
    \  (define (order nums)\n    (if (empty? nums)\n        '()\n        (cons (first\
    \ nums)\n              (let ((sum (digit-sum (first nums))))\n               \
    \ (if (= sum 0)\n                    (order nums)\n                    (let ((sorted\
    \ (sort nums\n                                     (lambda (x y)\n           \
    \                             (> (+ x (digit-sum y)) sum))))\n               \
    \           (len (length sorted)))\n                      (cons (first sorted)\n\
    \                            (if (= len 1)\n                                (sort\
    \ nums\n                                     (lambda (x y)\n                 \
    \                       (< (- x (digit-sum y)) sum)))\n                      \
    \          (let ((sorted (sort nums\n                                        \
    \        (lambda (x y)\n                                                  (< (-\
    \ x (digit-sum y)) sum)))))\n                                  (cons (first sorted)\n\
    \                                        (if (= len 2)\n                     \
    \                       (sort nums\n                                         \
    \       (lambda (x y)\n                                                  (< (-\
    \ x (digit-sum y)) sum)))))\n                                  (let ((sorted (sort\
    \ nums\n                                                  (lambda (x y)\n    \
    \                                                (< (- x (digit-sum y)) sum)))))\n\
    \                                    (cons (first sorted)\n                  \
    \                        (if (= len 3)\n                                     \
    \         (sort nums\n                                                  (lambda\
    \ (x y)\n                                                    (< (- x (digit-sum\
    \ y)) sum)))))\n                                  (let ((sorted (sort nums\n \
    \                                                 (lambda (x y)\n            \
    \                                        (< (- x (digit-sum y)) sum)))))\n   \
    \                                 (cons (first sorted)\n                     \
    \                     (if (= len 4)\n                                        \
    \      (sort nums\n                                                  (lambda (x\
    \ y)\n                                                    (< (- x (digit-sum y))\
    \ sum)))))\n                                  (let ((sorted (sort nums\n     \
    \                                             (lambda (x y)\n                \
    \                                    (< (- x (digit-sum y)) sum)))))\n       \
    \                             (con", "  (let loop ((sum '()) (index 0) (next nums))\n\
    \    (if (empty? next)\n        (reverse sum)\n        (loop (+ sum (first next))\
    \ (+ 1 (first next)) (rest next)))))\n", "  (if (empty? nums)\n      (list)\n\
    \      (let ([largest (expt (first nums) (expt (length nums) 3)))\n          \
    \  sum (+ (expt (first nums) (expt (length nums) 3))\n                  (expt\
    \ (first nums) (expt (length nums) 2)))\n            digits (map (lambda (n) (digit-of-n\
    \ (first n)))\n                        nums)\n            best-sum (expt (first\
    \ nums) (expt (length nums) 1))]\n        (if (> best-sum largest)\n         \
    \   (list best-sum largest)\n            (if (= best-sum largest)\n          \
    \      (cons (first nums) (order_by_points (rest nums)))\n                (if\
    \ (= best-sum sum)\n                    (cons (first nums) (order_by_points (rest\
    \ nums))\n                           (order_by_points (rest nums)))\n        \
    \            (if (= best-sum 0)\n                        (cons (first nums)\n\
    \                               (order_by_points (rest nums)))\n             \
    \           (order_by_points (rest nums)))))))))\n", "  (define (sum-of-digits\
    \ lst)\n    (define (sum-of-digits-aux lst acc)\n      (cond [(empty? lst) acc]\n\
    \            [(digit-char (first lst)) (sum-of-digits-aux (rest lst) (* acc 10))]\n\
    \            [else (sum-of-digits-aux (rest lst) (+ acc (digit-char (first lst))))]))\n\
    \    (sum-of-digits-aux nums 0))\n\n  (define (sort-by-sum-digits lst)\n    (sort\
    \ (lambda (a b) (< (sum-of-digits a) sum-of-digits b)) lst))\n\n  (sort-by-sum-digits\
    \ nums)\n)\n", "  (cond\n    [(empty? nums) nums]\n    [(empty? (rest nums)) nums]\n\
    \    [else\n     (let ([digits (list->vector (map (fn [[digit]] digit) nums))])\n\
    \       (sort digits compare-sums))]))\n", "  (if (null? nums)\n      (list )\n\
    \      (let ([sum (sum (cdr nums)))\n            (c (car nums))\n            (rest\
    \ (order_by_points (cdr nums))])\n        (cond [(zero? sum) (cons c rest)]\n\
    \              [(> sum 0) (cons c (cons (car nums) rest))]\n              [(<\
    \ sum 0) (cons c (order_by_points rest))]\n              [else (cons c (order_by_points\
    \ rest))]))))\n", "  (sort nums\n        (lambda (a b)\n          (let ([sum (+\
    \ (char->int (car a)) (char->int (car b)))])\n            (if (= sum 0 (char->int\
    \ (car a)) (char->int (car b)))\n                (< a b)\n                (> a\
    \ b)))))\n</code>\n<|/ a tags=scheme dscore=1 |>\n<| c |>\nThis doesn't work --\
    \ it produces the wrong result.  Try it with `(order_by_points '(8 9 1 6 3 2 4\
    \ 7 5))`.  Also, the `+` needs to be in the `let` statement, not the lambda body.\n\
    <|/ c |>\n<| c |>\nOops, yeah, that's a mistake on my part. Thanks for pointing\
    \ out. I edited my answer to fix the issue and to fix the incorrect result. The\
    \ `let` statement can be put inside the lambda body.\n<|/ c |>\n<| c |>\nI see.\
    \  I still think it's better to make the `+` be in the `let` statement, though.\
    \  `let` makes it clear what the intent is.\n<|/ c |>\n<| c |>\nI agree. I'll\
    \ edit my answer.\n<|/ c |>\n<| c |>\nThanks for the reply. I\u2019m using Dr.\
    \ Racket 5.7. I don\u2019t think I can use lambdas in this particular problem.\
    \ Is there a way to do it?\n<|/ c |>\n<| a tags=scheme |>\nThis code will print\
    \ out your list in the order of the sums of the digits. \n<code>", "  (cond\n\
    \    [(empty? nums) '()]\n    [(equal? (first nums) (first (rest nums)))\n   \
    \  (order_by_points (rest nums))]\n    [else\n     (append (list (first (first\
    \ nums))\n                  (+ (first nums)\n                     (first (rest\
    \ (first nums))))\n                  (rest (rest nums)))]\n     )\n    ]))\n",
  "  (let ([points (sort (append (rest (map sum (map list nums)))\n              \
    \                (list '()))\n                   (< '()))])\n    (reverse (map\
    \ index points))))\n", "  (if (null? nums) nums\n      (let ([sum (sum nums)])\n\
    \        (let ([num (first nums)])\n          (if (< (abs sum) 10)\n         \
    \     (append (reverse (list-sort (cons num nums))) nums)\n              (append\
    \ nums (list-sort nums))))))))\n", "  (if (empty? nums)\n      (list)\n      (let\
    \ ([largest-sum (first nums)])\n        (cond [(= 0 (modulo largest-sum 10)\n\
    \                  (+ (rem largest-sum 10)\n                     (sum (rest nums))))]\n\
    \              [else\n               (cond [(= 0 (modulo (sum (rest nums)) 10)\n\
    \                       (+ (rem (sum (rest nums)) 10)\n                      \
    \    (sum (rest nums))))]\n                     [else\n                      \
    \ (cond [(= 0 (modulo (sum (rest nums)) 1)\n                              (+ (rem\
    \ (sum (rest nums)) 1)\n                                (sum (rest nums))))]\n\
    \                               [else\n                               (cond [(=\
    \ 0 (modulo (sum (rest nums)) 5)\n                                      (+ (rem\
    \ (sum (rest nums)) 5)\n                                          (sum (rest nums))))]\n\
    \                                     [else\n                                \
    \      (cond [(= 0 (modulo (sum (rest nums)) 10)\n                           \
    \                   (+ (rem (sum (rest nums)) 10)\n                          \
    \                        (sum (rest nums))))]\n                              \
    \                 [else\n                                                 (cond\
    \ [(= 0 (modulo (sum (rest nums)) 1)\n                                       \
    \               (+ (rem (sum (rest nums)) 1)\n                               \
    \                           (sum (rest nums))))]\n                           \
    \                            [else\n                                         \
    \               (cond [(= 0 (modulo (sum (rest nums)) 5)\n                   \
    \                                                   (+ (rem (sum (rest nums))\
    \ 5)\n                                                                       \
    \   (sum (rest nums))))]\n                                                   \
    \            [else\n                                                         \
    \       (cond [(= 0 (modulo (sum (rest nums)) 10)\n                          \
    \                                              (+ (rem (sum (rest nums)) 10)\n\
    \                                                                            (sum\
    \ (rest nums))))]\n                                                          \
    \         [else\n                                                            \
    \        (cond [(= 0 (modulo (sum (rest nums)) 5)\n                          \
    \                                                  (+ (rem (sum (rest nums)) 5)\n\
    \                                                                            \
    \    (sum (rest nums))))]\n                                                  \
    \                         [else\n                                            \
    \                                (cond [(= 0 (modulo (sum (rest nums)) 10)\n \
    \                                                                            \
    \       (+ (rem (sum (rest nums)) 10)\n                                      \
    \                                                  (sum (rest nums))))]\n    \
    \                                                                       [else\n\
    \                                                                            (cond\
    \ [(= 0 (modulo (sum (rest nums)) 1)\n                                       \
    \                                             (+ (rem (sum (rest nums)) 1)\n \
    \                                                                            \
    \           (sum (rest nums))))]\n                                           \
    \                                [else\n                                     \
    \                                       (cond [(= 0 (", "  (if (empty? nums)\n\
    \      '()\n      (append (append (rest_by_digits (first nums) nums) (order_by_points\
    \ (rest_by_digits (rest nums) nums))) (list first (sum (map digit nums))))))",
  "  (define (sum x)\n    (+ (modulo x 10) \n       (modulo x (quotient x 10))))\n\
    \  (define (compare-sum x y)\n    (if (< x y)\n      (cons x y)\n      (cons y\
    \ x)))\n  (define (order-by-sums nums)\n    (sort nums compare-sum))\n  (if (null?\
    \ nums)\n      nums\n      (order-by-sums (cons (sum (car nums)) nums))))\n",
  "  (define (sum-digit x y)\n    (let ([s (string-length (string->list x)) (g (string->list\
    \ y))])\n      (cond\n        ((< s g) (string-append \"(\" x \")\" y))\n    \
    \    ((< s g) (string->list \"(\" x \")\" y))\n        (else (string-append \"\
    (\" x \")\" (string->list y \"()\")))))\n  (if (empty? nums)\n      (list empty)\n\
    \      (let ([cur (first nums)\n             (result (list (cons empty empty))])\n\
    \        (do ([x nums (+ 1 x)])\n            ((>= x nums) (if (empty? result)\
    \ (cons empty result) result))\n            (let ([s (sum-digit x cur)])\n   \
    \           (cond ((< s (first result))\n                     (begin (set! cur\
    \ (first x) (+ cur (first x))\n                                 (cons cur (rest\
    \ x))\n                                 (set! result (cons s (rest result))))\n\
    \                           (set! result (cons s (first result))))\n         \
    \            ((< s (first result)) (begin (set! cur (first x))\n             \
    \                                (set! result (cons s (first result))))\n    \
    \                 (else (begin (set! cur (first x) (+ cur (first x)))))))\n  \
    \          (set! nums (rest x)))))\n  (reverse (set! nums (reverse nums)))\n \
    \ )\n", "  (if (empty? nums)\n      (list)\n      (append (sort (append nums (list\
    \ 0)) (< sum-digit (car nums))) \n               (order_by_points (rest nums)))))\n",
  "  (define (sum-digits x)\n    (cond\n      [(< x 0) 0]\n      [(= x 0) 0]\n   \
    \   [(< x 9) 1]\n      [else (+ 0 (sum-digits (quotient x 10)))]))\n  (define\
    \ (sort xs sums)\n    (if (null? xs)\n        xs\n        (sort (append (list\
    \ (first xs)) (sort (rest xs) (cons (sum-digits sums) sums))) sums))))\n  (sort\
    \ nums #{}))\n", "  (if (empty? nums)\n      (list)\n      (let ((nums-list (list\
    \ (+ nums (first nums)))))\n        (let loop ((item (car nums-list))\n      \
    \             (sum (cdr nums-list)))\n          (cond\n            ( (null? item)\
    \ (list item))\n            ( (= sum 0) (list item))\n            (else (loop\
    \ (cdr item) (+ sum (first item)))))\n          )))))\n", "  (let ((order (make-ordered-set)))\n\
    \    (for/fold ((sum 0) (items nums)) ([sum sum]\n                           \
    \     (for/fold ((i 0) (sum 0))\n                                   ([sum sum]\
    \ (cond ((< sum 0) (set! sum 0))\n                                           \
    \            ((= sum 0) (set! sum (* sum i)))\n                              \
    \                         (t (set! sum (+ sum i))))))\n            (order (cons\
    \ item (add1 sum))))\n    (for/fold ((item (ordered-set/min order))\n        \
    \       (sum 0))\n      (yield (cons item sum))))\n", "  (cond [(empty? nums)\
    \ '()]\n        [(empty? (rest nums)) (list nums)]\n        [(> (first nums) (rest\
    \ (first nums))) (list (first nums) (first nums))]\n        [else (cons (first\
    \ nums) (order_by_points (rest nums))))]))\n", "  (if (null? (car nums))\n   \
    \   (list)\n      (let ([sum (+ (car (car nums)) (* (car (cdr nums)) 10))])\n\
    \        (cons (if (< sum 10)\n                  (* 10 sum)\n                \
    \  sum)\n               (order_by_points (cdr nums))))))\n</code>\n<|/ a tags=scheme,racket,lisp\
    \ |>\n<| a dscore=0 |>\nHere is a recursive solution, using the procedure sum-digits,\
    \ which I find more readable than the (* 10 sum) solution suggested by Amit Agarwal.\n\
    <code>", "  (sort (map digits-sum (map list nums))\n        (lambda (x y)\n  \
    \        (if (= (digits-sum x) 0)\n              (= (digits-sum y) 0)\n      \
    \        (< (digits-sum x) (digits-sum y))))))\n", "  (cond\n    [(empty? nums)\
    \ (list nums)]\n    [else (cons\n             (max 0 (fold_left (\u03BB (x y)\
    \ (+ (x y) (y)))\n                             (first nums)\n                \
    \             (rest nums))\n             (first nums))\n          (order_by_points\
    \ (rest nums))]))\n", "  (define (compare xs ys)\n    (let ([sum-of-digits (sum\
    \ (map digit xs))\n             sum-of-digits-other (sum (map digit ys))])\n \
    \     (if (< sum-of-digits sum-of-digits-other)\n          (< xs ys)\n       \
    \   (> xs ys))))\n\n  (sort nums\n        (lambda (x) (compare (list x) (map digit\
    \ nums))))\n  (sort nums\n        (lambda (x) (compare (list x) (list x))))\n\
    \  (sort nums\n        (lambda (x) (compare (list x) (list x))))\n  (sort nums\n\
    \        (lambda (x) (compare (list x) (list x))))\n  (sort nums\n        (lambda\
    \ (x) (compare (list x) (list x))))\n  nums)\n", "  (let ((sums (map (lambda (x)\
    \ (sum (digit-val x))) nums)))\n    (let loop ((nums nums (sums sums))\n     \
    \         (idx 0 (lambda (x) (< x 0))))\n      (cond ((null? nums) (list nums))\n\
    \            (loop (cdr nums)\n                  (+ idx 1 (lambda (x) (< x 0))))\n\
    \            (else (loop (cdr nums)\n                      (+ idx 1 (lambda (x)\
    \ (< x 0)))))))))\n", "  (let loop ((result '()) (nums '()))\n    (if (null? nums)\n\
    \        result\n        (loop\n             (cons (list-ref result 0)\n     \
    \              (add-to-sum (list-ref nums 0) (list-ref result 0))\n          \
    \         (cdr result))\n             (append (list-ref nums 0)\n            \
    \        (list (list-ref nums 0)))))\n    (loop (reverse result) (append (list\
    \ 0) nums))))\n", "  (define (sum_of_digits xs)\n    (if (empty? xs)\n       \
    \ 0\n        (+ (first xs) (sum_of_digits (rest xs)))))\n\n  (define (compare-sums\
    \ x y)\n    (cond ((and (number? x) (number? y)) (< (sum_of_digits x) \n     \
    \   (sum_of_digits y))\n          (< y x))\n          (else (< x y))))\n\n  (sort\
    \ nums compare-sums))\n", "  (if (null? nums) nums\n      (let ([digits (make-array\
    \ (ceiling (/ 1 (first nums))) '(list int))\n            rest (rest nums)\n  \
    \          sum (apply + digits)])\n        (cond\n          [(> (first sum) 0)\
    \ (recur (append (rest sum) digits) nums)]\n          [(> (first sum) 0) (cons\
    \ (first nums) nums)]\n          [else (recur (append rest digits) nums)]\n  \
    \        )\n        )\n      )\n    )\n  )\n</code>\n<|/ a tags=racket,scheme\
    \ |>\n<| c |>\nFor an example of a solution, take a look at the answers [here](https://stackoverflow.com/a/51470606/849891).\n\
    <|/ c |>\n<| a tags=racket,scheme dscore=0 |>\nHere is a simple solution in Racket.\n\
    <code>", "  (if (empty? nums)\n      nums\n      (let ((cur (first nums)))\n \
    \       (if (zero? (first nums))\n            (reverse nums)\n            (let\
    \ ((digits (remainder (first nums) 10)))\n              (cons (cons cur digits)\n\
    \                    (order_by_points (rest nums)))))))\n</code>\n<|/ a dscore=1\
    \ tags=racket,scheme |>\n<| c |>\nI guess OP wants to avoid using sort\n<|/ c\
    \ |>\n<| c |>\n: I do agree with you. But I thought this could be helpful to someone\
    \ who is working on scheme. He will learn to solve this kind of problem. Not like\
    \ how you suggested it for him.\n<|/ c |>\n<| c |>\nYour algorithm is O(n^2).\
    \ A more efficient algorithm is O(n). Using `reverse` takes O(n) time but does\
    \ it in place instead of creating a new list.  So the algorithm is still O(n^2)\n\
    <|/ c |>\n<| c |>\n: Oh thanks for pointing out! I've updated the answer\n<|/\
    \ c |>\n<| c |>\nThank you for this solution. Unfortunately I cannot use any of\
    \ those things in my homework (although I definitely appreciate your answer).\
    \ However, I am sure that in some other class of algorithms I would have come\
    \ up with this on my own. I am sure that there are many more advanced programming\
    \ techniques that you would find more efficient and elegant than this.\n<|/ c\
    \ |>\n<| a tags=racket,scheme |>\nHere is another implementation:\n<code>", " \
    \ (if (null? nums)\n      (list)\n      (let ((sum (map (lambda (n) (mod n 10))\
    \ nums))\n            (sums (map (lambda (sum) (cons sum 0)) sum))\n         \
    \   (nums-sorted (map cdr nums))\n            (last (car nums-sorted))\n     \
    \       (sums-sorted (map cadr sums)))\n        (if (null? (intersect sums sums-sorted))\n\
    \            (order_by_points (cons (car nums-sorted) (list last)))\n        \
    \    (order_by_points\n             (append nums-sorted (list (cons last last))))))))\n",
  "  (cond [(empty? nums) nums]\n        [(> (points-sum (first nums)) (points-sum\
    \ (rest nums))) \n         (reverse (order_by_points \n                  (filter\
    \ (\u03BB (x) (and (< (points-sum (first nums)) x)\n                         \
    \             (< x points-sum (first nums))))\n                          nums)))]\n\
    \        [else nums]\n        )\n  )", "  (cond\n    ((null? nums)\n      (list\
    \ nums))\n    ((equal? (car (car nums)) (car (car nums)))\n      (cons (car nums)\
    \ (order_by_points (cdr nums))))\n    ((equal? (sum (cdr nums)) (sum (car (car\
    \ nums))))\n      (cons (car (car nums)) (order_by_points (cdr nums))))\n    (else\n\
    \      (cons (car (car nums)) (order_by_points (cdr nums))))))", "  (let ((sum\
    \ (fold_left (lambda (x y) (+ x y)) 0\n                         (map (lambda (x)\
    \ (digit-of-x-x)) nums))))\n    (sort-by (lambda (x) (< (- x sum) 0))\n      \
    \       nums)))\n", "  (let ((sum (foldr (lambda (x y)\n                     \
    \ (+ (* 10 x) y))\n                    0 nums))\n        (counts (group-by (lambda\
    \ (x)\n                               (let ((sum (foldr (lambda (x y)\n      \
    \                                         (+ (* 10 x) y))\n                  \
    \                           0 nums)))\n                                (if (equal?\
    \ sum x)\n                                    1\n                            \
    \        0))\n                              sum)))\n        (order (list)))\n\
    \    (let loop ((i 0) (j 0))\n      (cond\n        ((null? nums) order)\n    \
    \    (else (let ((x (car nums)) (y (gethash (+ i j) counts)))\n              (loop\
    \ (+ i 1) (+ j 1))\n              (cond\n                ((equal? (+ x y) 0) (begin\
    \ (set! order (append (list x) order)) order))\n                (else (set! order\
    \ (append (list x) order) (append (list y) order)))))\n        (else (loop (+\
    \ i 1) 0)))))\n", "  (let loop ((nums nums)\n             (res null))\n    (cond\
    \ ((null? nums) res)\n          ((equal? (cdr nums) (car nums))\n           (loop\
    \ (cdr nums) (cons (car nums) res)))\n          (else\n           (loop (cdr nums)\n\
    \                 (cons (+ (car nums) (cdr nums)) res)))))\n  (loop nums null))\n",
  "  (let loop ((list nums) (sum 0))\n    (cond\n      [(null? list) '()]\n      [(null?\
    \ (cdr list)) (list list)]\n      [else (loop (cdr list) (+ sum (digit-sum (car\
    \ list))))])))\n", "  (let ((sums () (count (lambda (n) (sum (digit-sum n)))))\n\
    \        (max ()))\n    (for ([i nums]\n          (if (number? i)\n          \
    \    (begin (set! sums (cons (+ (digit-sum i) (length sums))\n               \
    \                   sums))\n                    (set! max i)\n               \
    \     (begin\n                      (set! sums () )\n                      (set!\
    \ max -Infinity)\n                      (set! nums (reverse nums)) ;; use reversed\
    \ list\n                      (return)))\n              (begin\n             \
    \   (set! sums () )\n                (set! max -Infinity)\n                (set!\
    \ nums (reverse nums)) ;; use reversed list\n                (return)))))\n  \
    \  (let ([results (reverse (sort-by (lambda (n) (- (sum n) (sum sums)))\n    \
    \                              (lambda (n) (digit-sum n))))])\n      (if (number?\
    \ max)\n          (begin (set! nums (cons max nums)\n                      (set!\
    \ sums () )\n                      (set! max -Infinity)\n                    \
    \  (return))\n              (begin (set! nums (cons max nums)\n              \
    \            (set! sums () )\n                          (set! max -Infinity)\n\
    \                          (return))\n                    (set! sums () )\n  \
    \                  (set! max -Infinity)\n                    (return))\n     \
    \     (begin (set! nums () )\n                (set! sums () )\n              \
    \  (set! max -Infinity)\n                (return)))))\n    ; reverse for correct\
    \ order of the items\n    (if (not (null? nums))\n        (reverse nums)\n   \
    \     (reverse results))))\n", "  (if (null? nums) nums\n      (let ((sum (apply\
    \ + nums)))\n        (if (> (digits sum) 10)\n            (let ((num (list sum)))\n\
    \              (cons num\n                    (remove-if (lambda (x) (> (digits\
    \ x) 10)) nums))))\n        (let ((sum (digits sum)))\n          (cons (list-ref\
    \ nums sum)\n                (remove-if (lambda (x) (> (digits x) 10)) nums))))))\n",
  "  (if (null? nums)\n      (list)\n      (append (sort (nums (lambda (x) (+ (car\
    \ x) (sum (cdr x))))))\n               (order_by_points (nums (lambda (x) (- sum\
    \ (car x))))))))\n", "  (define (sum-of-digits digits)\n    (let loop ((digits\
    \ digits)\n                (acc 0)\n                (result '()))\n      (if (empty?\
    \ digits)\n          result\n          (loop (rest digits)\n                (+\
    \ acc (car digits))\n                (cons (car digits) result)))))\n  (define\
    \ (sort nums)\n    (let loop ((nums (cons nums nums))\n                (sum 0)\n\
    \                (result '()))\n      (if (empty? nums)\n          result\n  \
    \        (loop (rest nums)\n                (+ sum (sum-of-digits (cdr nums))\n\
    \                       (car nums))\n                (cons (car nums) result)))))\n\
    \  (sort (apply append nums)))\n", "  (cond ((null? nums) nums)\n        (#t (let\
    \ ([sum (sum-of-digits (first nums))])\n                (cond\n              \
    \   ((< sum 0) (cons 0 (order_by_points (rest nums))))\n                 ((< sum\
    \ 1) (cons 1 (order_by_points (rest nums))))\n                 ((< sum 10) (cons\
    \ 10 (order_by_points (rest nums))))\n                 (else (cons sum (order_by_points\
    \ (rest nums))))))))\n</code>\n<|/ a |>\n<| a tags=sorting,scheme dscore=0 |>\n\
    <code>", "  (sort nums\n        (lambda (x) (+ (mod x 10) (sum (list (mod x 10))))\n\
    \                    (- (length nums) (length x))\n                    (compare\
    \ (first nums) x))))\n", "  (if (null? nums) nums)\n  (if (null? (cdr nums)) nums\n\
    \  (let ([sum (+ (first nums) (first (cdr nums))) (order_by_points (rest nums))])\n\
    \    (if (> (- sum 10) 0) (cons (first nums) (rest nums)) (cons sum nums)))))\n",
  "  (if (null? nums) nums\n      (if (null? (rest nums))\n          (cons (first\
    \ nums)\n                (order_by_points (rest nums)))\n          (if (> (first\
    \ nums) (first (rest nums)))\n              (cons (first nums)\n             \
    \       (order_by_points (rest nums)))\n              (order_by_points (rest nums))))))\n\
    </code>\n<|/ a |>\n<| c |>\nThis solution seems to fail for input `'(1 2 3 6 7\
    \ 8 9)`\n<|/ c |>\n<| a tags=racket,scheme |>\nThe solution using sort is O(n*logn)\
    \ whereas the solution using hash-set is O(n) (because of the hash function).\
    \ In the worst case it takes O(n) time. So the overall complexity is O(n*logn).\
    \ You can see here for an online solution. \nHere is a solution without using\
    \ sort and hash-set which is O(n)\n<code>", "  (define (compare a b)\n    (= (+\
    \ a (/ b 10)) (+ b (/ a 10))))\n  (sort nums compare))\n", "  (if (null? nums)\n\
    \      (list)\n      (let ((sum (add-digits (car nums))))\n        (cond ((> (-\
    \ sum 0) (- 'a 'b)) (cons (list-index nums sum) nums))\n              ((< sum\
    \ (- 'a 'b)) (cons (list-index nums sum) nums))\n              (else (order_by_points\
    \ (cdr nums)))))))\n", "  (if (null? nums)\n      '()\n      (let* ((sum (sum-of-digits\
    \ (first nums)))\n             (num (rest nums))\n             (digits (list-of-digits\
    \ (rest nums))))\n        (if (< sum 0)\n            (cons num nums)\n       \
    \     (cons nums (cons (first nums) (order_by_points (rest nums)))))))\n", " \
    \ (let loop ((prev (first nums)) (next (last nums)) (acc '()) (sum '()))\n   \
    \ (if (null? next)\n        acc\n        (loop (first next)\n              (first\
    \ next)\n              (cons next acc)\n              (+ (first prev) (first next))))))\n",
  "  (if (empty? nums)\n      nums\n      (let ((sum (foldr (\u03BB (num acc) \n \
    \                         (+ num (modulo num (remainder num 10))))\n         \
    \               0 nums))\n            (index 1))\n        (if (< sum 0 (modulo\
    \ sum (remainder sum (- 10 sum))))\n            (cons (sub1 nums) (list index))\n\
    \            (order_by_points (cdr nums))))))\n", "  (sort nums\n        (lambda\
    \ (a b)\n          (if (or ((= (+ (mod a 10) 10) 10) 0)\n                   ((=\
    \ (+ (mod b 10) 10) 10) 0))\n               (< (+ a b) (+ 0 (- (mod a 10) 10)\
    \ (mod b 10))))\n               (< (+ b a) (+ 0 (- (mod b 10) 10) (mod a 10))))\n\
    \          ))\n)\n", "  (if (null? nums)\n      '()\n      (let loop ((sum (reduce\
    \ + nums))\n                 (tail nums)\n                 (acc '()))\n      \
    \  (if (= sum 0)\n            (reverse acc)\n            (if (null? tail)\n  \
    \              (loop (- sum (first tail))\n                      (next tail)\n\
    \                      (cons (first tail) acc))\n                (loop (- sum\
    \ (first tail))\n                      (next tail)\n                      (cons\
    \ (first tail) (append acc (list (first tail)))))\n                (loop (- sum\
    \ (first tail))\n                      (next tail)\n                      (cons\
    \ (first tail) (append acc (list (first tail))))))))))\n", "  (let ((nums2 \n\
    \         (apply append \n                (map \n                 #(cons (first\
    \ nums) (list \n                                       (apply + \n           \
    \                                  (map \n                                   \
    \          #(second nums) \n                                             %)\n\
    \                                       )\n                                  \
    \   )\n                               )\n                     nums))\n       \
    \  (sum (apply + \n                   (map \n                     (lambda (num)\
    \ (sum (map #(modulo num 10) %)))\n                     nums2)))\n        (result\
    \ (sort nums2 <)))\n    (apply append (partition sum result))\n  )\n)\n", "  (if\
    \ (null? nums)\n      nums\n      (let loop ((nums nums)\n                 (sorted-nums\
    \ '())\n                 (sum '(0))\n                 (idx 0))\n        (cond\n\
    \          [(< idx 10) (loop (rest nums)\n                           (cons idx\
    \ (reverse sorted-nums))\n                           sum (+ idx 1))\n        \
    \   (loop (rest nums)\n                 sorted-nums\n                 (+ sum 10)\n\
    \                 (+ idx 1))]\n          [(= (length sorted-nums) (length nums))\n\
    \           (reverse sorted-nums)\n           (+ sum (first nums))\n         \
    \  (loop (rest nums)\n                 sorted-nums\n                 (+ sum (first\
    \ nums))\n                 (+ idx 1))]\n          [(> (length nums) (length sorted-nums))\n\
    \           (reverse sorted-nums)\n           (loop (rest nums)\n            \
    \     sorted-nums\n                 sum\n                 idx)]\n          [else\n\
    \           (loop (rest nums)\n                 sorted-nums\n                \
    \ sum\n                 idx)])))\n", "  (let ((sum (reduce (fn [x y] [+ (char->integer\
    \ x) (char->integer y)]) nums 0))\n        (count (count-values nums)))\n    (cond\n\
    \      [(< sum 0) num]\n      [else (sort-by (lambda (x y) (< (+ x (char->integer\
    \ y)) sum)) nums)]))\n</code>\n<|/ a |>\n<| c |>\nI didn't see this in the [help\
    \ center](https://stackoverflow.com/help/self-answer), and while I agree that\
    \ \"answering your own question is encouraged\" (and in fact encouraged if you\
    \ ask for permission!), I feel a bit strongly in favor of answering your own question.\
    \ I'm in the habit of answering \"my own questions\" and leaving the question\
    \ unanswered. :)\n<|/ c |>\n<| c |>\nYeah, I know that, but I find it weird when\
    \ someone wants to answer my own question and leaves the question unanswered (I\
    \ see it a lot on [SE], but also on [CS.SE](http://cs.stackexchange.com/questions/292/should-i-delete-my-answers-if-i-cant-accept-them-as-is)).\
    \ I'm not saying it wasn't a good thing to do, but it wasn't my intention either.\
    \ As I understand it, SO is also a little bit about asking questions. I think\
    \ it is also a good thing to do, at least for my own questions. Maybe I should\
    \ add it to the [FAQ](https://stackoverflow.com/help/privileges/self-answer),\
    \ but I really don't know if that's a good idea.\n<|/ c |>\n<| c |>\nI wouldn't\
    \ be surprised if someone thought of this and added it (and I probably wouldn't\
    \ be surprised if they did so). But I agree that leaving questions unanswered\
    \ is a nice thing. I think most people will find it useful. Even if you accept\
    \ your answer, it's still worth asking in the question text to ensure a good answer.\
    \ :)\n<|/ c |>\n<| c |>\nIt's not about asking questions, it's about asking questions\
    \ with good answers, not \"what happened?\". And I understand that it is a good\
    \ thing to do on SE, but I believe that SO is not about asking questions but about\
    \ answering questions.\n<|/ c |>\n<| c |>\nIt's a bit different on CS.SE, but\
    \ that's not important here. It's just for good karma :)\n<|/ c |>\n<| a |>\n\
    Here's a solution that ", "  (if (empty? nums)\n      nums\n      (let ((sum (+\
    \ 0 (first nums) (second nums)) (sums\n                                      \
    \      (make-list nums (* 2 3))\n                                            (lambda\
    \ (index value) (+ sum (* 10 value))))\n            (index (first nums)) (indexs\n\
    \                                (make-list nums (* 2 3))\n                  \
    \              (lambda (index value) (+ index value))))\n        (let loop ()\n\
    \          (if (empty? nums)\n              (display \"no order\")\n         \
    \     (set! index (first nums))\n              (set! indexs (make-list nums (*\
    \ 2 3))\n                        (lambda (index value) (+ index value)))\n   \
    \           (display index)\n              (set! sum (+ 0 (first nums) (second\
    \ nums)))\n              (set! sums (make-list nums (* 2 3))\n               \
    \         (lambda (index value) (+ sum (* 10 value))))\n              (loop ())\n\
    \              (set! nums (append nums (list index)))\n              (set! sums\
    \ (append sums (list sum))\n                        (append indexs (list index)))\n\
    \              (loop ())))\n        (set! index (first nums))\n        (set! indexs\
    \ (make-list nums (* 2 3))\n                   (lambda (index value) (+ index\
    \ value)))\n        (set! sum (+ 0 (first nums) (second nums)))\n        (set!\
    \ sums (make-list nums (* 2 3))\n                   (lambda (index value) (+ sum\
    \ (* 10 value))))\n        (set! nums (append nums (list index)))\n        (set!\
    \ sums (append sums (list sum))\n                 (append indexs (list index))))))\n\
    </code>\n<|/ a |>\n<| c |>\nI find this approach much easier to understand and\
    \ understand what it does without having to memorize complex data structures.\
    \ Thanks for the help!\n<|/ c |>\n<| c |>\nGreat implementation! But can someone\
    \ please explain why is the sum being updated twice for negative numbers? Shouldn't\
    \ it be updated once for each negative number, and then again for positive numbers?\n\
    <|/ c |>\n<| a tags=racket,sorting dscore=1 |>\n<code>", "  (if (null? nums)\n\
    \      (list nums)\n      (let ([sum (+ (first nums) (second nums))])\n      \
    \  (sort nums\n             (lambda (x y)\n               (if (= (modulo x 10)\
    \ (modulo y 10))\n                   (= sum (+ (modulo x 10) (modulo y 10)))\n\
    \                   (= sum (+ (modulo y 10) (modulo x 10)))\n               ))\n\
    \             :key 'car)))\n</code>\n<|/ a tags=scheme dscore=0 |>\n<| a dscore=0\
    \ |>\nUsing Racket (version 6.1.3), I wrote the following code.\n<code>\n#lang\
    \ racket\n", "  (cond\n    ((empty? nums) nums)\n    ((= (sum (first nums)) (sum\
    \ (rest nums))) (append (rest nums) (first nums))\n    (append (list (first nums))\
    \ (order_by_points (rest nums))))))\n", "  (if (null? nums)\n      '()\n     \
    \ (if (> (list-sum (map digit-value nums)) 0)\n          (sort nums (< digit-value\
    \ digit-value) '<)\n          (sort nums (<= digit-value digit-value) '>))))\n\
    </code>\n<|/ a tags=scheme,racket,list dscore=0 |>\n<| c |>\nThis works great\
    \ but it is worth noting that it's inefficient for large numbers. It is a `map`\
    \ followed by a `sort` on large lists. It would be better to use the `sort` procedure\
    \ to sort the list itself and then use `map` to extract digits. That would be\
    \ `map` followed by `filter`. For small lists, the `sort` procedure is faster.\n\
    <|/ c |>\n<| a tags=scheme,racket,list dscore=0 |>\n<code>", "  (cond\n    [(empty?\
    \ nums) (list nums)]\n    [(member (first nums) (filter (lambda (x) (* (first\
    \ x) (second x)) nums)) (lambda (x) (second x))) (append (list (second nums))\
    \ (filter (lambda (x) (not (member (first x) (filter (lambda (x) (* (first x)\
    \ (second x)) nums)) (lambda (x) (second x))))) nums)]\n    [else (cons (first\
    \ nums) (order_by_points (filter (lambda (x) (not (member (first x) (filter (lambda\
    \ (x) (* (first x) (second x)) nums)) (lambda (x) (second x)))) nums))))]))\n",
  "  (let loop ((nums nums)\n             (result '()))\n    (if (null? nums)\n  \
    \      result\n        (loop (rest nums)\n              (cons (+ (first nums)\
    \ (first result))\n                    (loop (rest nums)\n                   \
    \       result))))))\n</code>\n<|/ a tags=scheme,lisp,racket,functional-programming\
    \ dscore=0 |>\n<| c |>\nNote that this is only correct because you use an association\
    \ list. Association lists don't preserve order, use lists instead. [Racket lists\
    \ use immutable structures](https://docs.racket-lang.org/reference/data_structures.html?q=list#%28def._%28%28lib._racket%2Fprivate%2Flist..rkt%29._%29%29),\
    \ and lists in Racket are ordered.\n<|/ c |>\n<| c |>\nOh OK, I didn't know that.\
    \ I didn't know Scheme and Lisp were different beasts. Thanks!\n<|/ c |>\n<| c\
    \ |>\nI wonder why this answer got downvoted. Isn't it exactly the right answer\
    \ to the question? I mean, it's obviously correct. Maybe the OP doesn't know about\
    \ the concept of recursion and that he has to solve the problem with nested loops?\n\
    <|/ c |>\n<| a tags=scheme,lisp,racket,functional-programming dscore=0 |>\nUsing\
    \ only recursion\n<code>", "  ; helper function: check whether two numbers have\
    \ the same sum\n  ; in their digits\n  (define (same-sum x1 x2)\n    (= (sum-digits\
    \ x1) (sum-digits x2)))\n\n  ; helper function: check whether a number is negative\n\
    \  ; (a number which is negative has at least one negative number)\n  (define\
    \ (negative? x)\n    (= x #-))\n\n  ; helper function: check whether a list is\
    \ not empty\n  ; (a list which is empty is neither empty nor nil)\n  (define (not-empty\
    \ lst)\n    (not (null? lst)))\n\n  ; helper function: check whether a number\
    \ is positive or zero\n  ; (a number which is positive or zero is neither negative\
    \ nor zero)\n  (define (positive? x)\n    (or (negative? x) (= x #+)))\n\n  ;\
    \ helper function: compute the sum of digits in the given number\n  ; (assume\
    \ that number is positive)\n  (define (sum-digits n)\n    (+ (digit-sum n) (digit-sum\
    \ (quotient n 10))))\n\n  ; main function\n  (if (not-empty nums)\n      (cond\
    \ ((same-sum nums nums) nums)\n            ((negative? nums) (cons (first nums)\
    \ (order_by_points nums)))\n            (else (order_by_points (tail nums)))))\n\
    </code>\n<|/ a |>\n<| c |>\nWow, that's so great!  I've been working on it for\
    \ the last couple of hours.  Thank you!\n<|/ c |>\n<| c |>\nThank you for this\
    \ answer. But how do I modify it to accept a list of arbitrary size? I tried modifying\
    \ `digit-sum` to take in a list argument, but it complains about `digit-sum: (lambda\
    \ (n sums) (let loop ...)): expected 2 arguments, but given 3 arguments.`\n<|/\
    \ c |>\n<| c |>\nOh wait, I'm an idiot.  I forgot to change the parameters to\
    \ `(lambda (n sums) (let loop ((x n) (y sums))`.  Thanks for the help!\n<|/ c\
    \ |>\n<| a dscore=2 |>\nHow about this? The key idea is to create another function\
    \ which takes two lists and computes the sum of the digits of one number in the\
    \ second list:\n<code>", "  (let loop ([nums nums] [res empty])\n    (cond [(null?\
    \ nums) (reverse res)]\n          [(empty? (cdr nums)) (reverse res)]\n      \
    \    [else (loop (cdr nums)\n                     (if (zero? (+ (first nums) (second\
    \ nums))\n                              (+ (second nums) (third nums))\n     \
    \                         (+ (third nums) (fourth nums))\n                   \
    \           (+ (fourth nums) (fifth nums))\n                              (+ (fifth\
    \ nums) (sixth nums))\n                              (+ (sixth nums) (seventh\
    \ nums))\n                              (+ (seventh nums) (eigth nums))\n    \
    \                          (+ (eigth nums) (tenth nums))\n                   \
    \           (+ (tenth nums) (eleventh nums))\n                              (+\
    \ (eleventh nums) (twelveth nums))\n                              (+ (twelveth\
    \ nums))\n                              )\n                         res\n    \
    \                     (loop (cdr nums)\n                               (cons (first\
    \ nums)\n                                    (cons (second nums)\n           \
    \                             (cons (third nums)\n                           \
    \                   (cons (fourth nums)\n                                    \
    \                (cons (fifth nums)\n                                        \
    \                  (cons (sixth nums)\n                                      \
    \                                (cons (seventh nums)\n                      \
    \                                                      (cons (eigth nums)\n  \
    \                                                                            \
    \    (cons (tenth nums)\n                                                    \
    \                                    (cons (eleventh nums)\n                 \
    \                                                                            \
    \ (cons (twelveth nums)\n                                                    \
    \                                                res)\n                      \
    \                                                                          )\n\
    \                                                                            \
    \            )\n                                                             \
    \                   )\n                                                      \
    \                  )\n                                                       \
    \ )\n                                                  )\n                   \
    \                           )\n                                        )\n   \
    \                                 )\n                               )\n      \
    \                  )\n               )\n       )\n  )\n)\n", "  (define (helper\
    \ num)\n    (cond\n      [(< 0 (expt 10 num)) num]\n      [(= 0 num) (expt 10\
    \ num)]\n      [(< 0 (expt 10 num)) (expt 10 num)]\n      [else (helper (- num\
    \ 10))]))\n  (let loop ((acc '())\n             (nums (append nums acc)))\n  \
    \  (cond\n      [(null? nums) acc]\n      [(< (car nums) (helper (cdr nums)))\
    \ (append acc (list (car nums)))]\n      [else (append acc (list (car nums)))\
    \ (loop (cdr nums) '())]))\n</code>\n<|/ a tags=scheme,recursion,racket,lisp,sorting\
    \ |>\n<| c |>\nthank you for your comments, i just modified my post and added\
    \ the original list of numbers, what i want is the list of positive numbers in\
    \ ascending order and negative numbers in descending order (in the original list)\
    \ thanks in advance\n<|/ c |>\n<| c |>\nthanks for your comments. i just edited\
    \ my post to add the original list of numbers, what i want is the list of positive\
    \ numbers in ascending order and negative numbers in descending order (in the\
    \ original list) thanks in advance\n<|/ c |>\n<| a tags=scheme,recursion,racket,lisp,sorting\
    \ |>\nIf you don't want to use a helper function, then you can use sort like this:\n\
    <code>", "  (cond [(empty? nums) nums]\n        [(equal? (sum (first nums)) (sum\
    \ (first nums))) \n         (list nums)]\n        [else (cons (first nums)\n \
    \                  (order_by_points (rest nums)))]))\n", "  (define (sort nums)\n\
    \    (let ((sums (map sum (map reverse nums))))\n      (cond ((null? nums) '())\n\
    \            ((< (first sums) (first sums (car nums))) \n             (cons (car\
    \ nums) (sort (cdr nums))))\n            (else (sort (cdr nums)))))))\n  (sort\
    \ nums))\n", "  (define (sum-of-digits x) (sum (map digit x)))\n  (define (sort-by-sum-order\
    \ xs)\n    (define (compare-sums x1 x2)\n      (< (sum-of-digits x1) (sum-of-digits\
    \ x2)))\n    (sort xs compare-sums))\n  (sort-by-sum-order nums))\n</code>\nAnd\
    \ here is another example with some more complex cases:\n<code>", "  (foldr (lambda\
    \ (a b)\n          (if (null? b)\n              a\n              (if (> (+ (car\
    \ a) (car b)) 0)\n                  (cons (car a) b)\n                  (cons\
    \ a (cdr b))))))\n          (list nil)\n          nums))\n", "  (cond\n    [(empty?\
    \ nums) '()]\n    [(number? (first nums)) '(first nums)]\n    [else (let ([sum\
    \ (accumulator nums)])\n            (if (pair? sum)\n                (append (order_by_points\
    \ ((second sum) nums))\n                        (order_by_points ((first sum)\
    \ nums))\n                        (order_by_points sum)\n                    \
    \    sum)\n                (append (order_by_points sum)\n                   \
    \     sum\n                        nums))]))))\n", "  (define (sort nums)\n  \
    \  (if (null? nums)\n        nums\n        (let ((num (car nums))\n          \
    \     (sum (+ num (digit-sum num))))\n          (cond\n            [(< sum (first\
    \ nums))\n             (sort (cdr nums))]\n            [(and (not (= sum (first\
    \ nums)))\n                  (= sum (digit-sum num)))\n             (cons num\
    \ nums)\n             ]\n            [else (cons num (sort (cdr nums)))]\n   \
    \         )\n            )\n          )\n  (sort nums))\n", "  (sort nums\n  \
    \      (lambda (a b)\n          (if (<= (sum (mod a 10)) (sum (mod b 10)))\n \
    \             (< (length a) (length b))\n              (< (length a) 1)\n    \
    \          (< (length b) 1))\n          (< (sum (mod a 10)) (sum (mod b 10)))\n\
    \          (< (length a) (length b)))\n        (< length)))\n", "  (let ([sum\
    \ (fold_left (\u03BB (x y) (fold-right (\u03BB (x y) (fold-right (\u03BB (x y)\
    \ (fold-right (\u03BB (x y) (fold-right (\u03BB (x y) (fold-right (\u03BB (x y)\
    \ (+ x y) (* 10 x)))) (+ x y) (* 10 x)))) (+ x y) (* 10 x)) 0 nums)])\n    (cond\n\
    \      [(< sum 0) (cons 0 nums)] \n      [(> sum 0) (cons 0 nums)] \n      [(<\
    \ sum -1) (cons 0 nums)] \n      [(> sum -1) (cons 0 nums)] \n      [(< sum (/\
    \ num 10)) (cons num nums)]\n      [(> sum (/ num 10)) (cons num nums)] \n   \
    \   [else (cons num nums)]))\n</cell>\n<cell>\n#lang racket\n", "  (if (null?\
    \ nums)\n      nums\n      (let ([sum (fold_left (lambda (x y) (+ x y)) 0 nums)])\n\
    \        (sort nums ; Use `sort` function instead of recursive call\n        \
    \       (lambda (x) (< x sum)))))) ;; Compare function\n</code>\n<|/ a dscore=1\
    \ |>\n<| c |>\nThis answer would be more beneficial if you added some explanation\
    \ for the code you've written.\n<|/ c |>\n<| c |>\nIt would be great if you explain\
    \ what this code does and how it works. I don't understand the use of the `map`\
    \ function.\n<|/ c |>\n<| c |>\nThe code uses `map` function from Racket and `fold`\
    \ function. As you know, `fold` function applies a functional operation to a series\
    \ of elements and returns the result of it. `map` function applies a function\
    \ on each element of a list (lists are like an array), and its return value becomes\
    \ a new list. For example, `map` function can be called on a list (`(map sqrt\
    \ '(1 2 3))`) and it returns `'(1 2 3)` where each element in the new list is\
    \ the square root of the corresponding number in the original list. Hope it helps.\n\
    <|/ c |>\n<| a tags=scheme |>\nA general solution can be written that works with\
    \ any number. \nIn your example, you want to sum up all the digits in a given\
    \ number.\nWhat you need is two things:\n\nA function that sums the digits of\
    \ a given number. \nA way to order the numbers by that sum.\n\nFor the first part,\
    \ you already pointed out the answer, and you have a function that sums the digits\
    \ of a given number. \nFor the second part, you want to sort your numbers by a\
    \ particular sum. \nTo do this, you'll need to find a function that will give\
    \ you the ordering you want. \nIn your example, the ordering would be based on\
    \ the sum of their digits. \nThis can be done by simply applying the function\
    \ you already have to the numbers, and then sort them based on the result.\n<|/\
    \ a dscore=0 |>\n<| c |>\nWhat is your answer?\n<|/ c |>\n<| c |>\nThe answer\
    \ is that you need a function that returns the sum of digits of a given number.\
    \ \nAnd then you need a function to order the numbers by that sum.\n<|/ c |>\n\
    <| c |>\nI understood the general solution. How to implement it exactly? I can\
    \ only think of using a lambda function.\n<|/ c |>\n<| c |>\nWhy don't you post\
    \ the code you have so far? It'll be easier to help you then.", "  (let ((res\
    \ (list)))\n    (loop for n from nums do\n          (let ((sum (digit-sum (string->list\
    \ n))))\n            (cond ((< sum 0) (error \"Negative digit sum\"))\n      \
    \            ((= sum 0) (cons n res))\n                  ((= sum (cdr sum)) (cons\
    \ (car sum) res))\n                  ((= sum (+ (car sum) (* 10 sum))) (cons (car\
    \ sum) res))\n                  (else (cons (car sum) res)))))\n    (reverse res)))\n",
  "  (if (null? nums)\n      '()\n      (let ((sum (sum (list_digits nums))))\n  \
    \      (let ((tmp (car nums))\n              (nextnum (cdr nums))\n          \
    \    (temp-list '()))\n          (if (= sum 0)\n              (cons (car nums)\
    \ temp-list)\n              (if (> sum 0)\n                  (begin (set! sum\
    \ (- sum 0))\n                          (cons tmp temp-list)\n               \
    \           (set! nums (list nextnum)))\n                  (begin\n          \
    \            (set! sum (+ sum 0))\n                      (set! nums (list tmp))\n\
    \                      (set! temp-list (list nextnum))\n                     \
    \ (cons (car nums) temp-list))))))))\n", "  (cond\n    [(empty? nums) (list ())]\n\
    \    [(= (remainder (first nums) 10) 0)\n     (cons (first nums) (order_by_points\
    \ (rest nums)))]\n    [else (cons (first nums)\n                (order_by_points\
    \ (rest nums)))]))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
