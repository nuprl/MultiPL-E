name: HumanEval_9_rolling_max
language: rkt
prompt: "#lang racket\n\n;; From a given list of integers, generate a list of rolling\
  \ maximum element found until given moment\n;; in the sequence.\n;; >>> (rolling_max\
  \ (list 1 2 3 2 3 4 2))\n;; (list 1 2 3 3 3 4 4)\n(define (rolling_max numbers)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate rolling_max))\n\
  \    (check-equal? (candidate (list )) (list ))\n    (check-equal? (candidate (list\
  \ 1 2 3 4)) (list 1 2 3 4))\n    (check-equal? (candidate (list 4 3 2 1)) (list\
  \ 4 4 4 4))\n    (check-equal? (candidate (list 3 2 3 100 3)) (list 3 3 3 100 100))\n\
  ))\n\n(test-humaneval)"
completions: ["  (if (empty? numbers)\n      (list 'empty)\n      (let ((max (first\
    \ numbers))\n            (current-max max))\n        (if (empty? (rest numbers))\n\
    \            (list current-max)\n            (let ((more (rest numbers)))\n  \
    \            (if (>= max more)\n                  (list current-max)\n       \
    \           (let ((other-max (first more)))\n                    (if (> other\
    \ current-max)\n                        (list current-max)\n                 \
    \       (let ((more (rest more)))\n                          (if (>= max more)\n\
    \                              (list current-max)\n                          \
    \    (rolling_max (rest more))))))\n                    (rolling_max (rest more))))))))\n",
  "  (let ((result '()))\n    (loop for i from 0\n         until (or (<= i 10)\n \
    \                   (= i (length numbers)))\n         do (let ((max (car numbers)))\n\
    \               (set-car! result max)\n               (set-cdr! numbers (cdr numbers))))\n\
    \    result))\n", "  (if (empty? numbers) numbers ; if the list is empty or only\
    \ one element then return as is\n      (let loop ((numbers (rest numbers)) (max-rolling\
    \ (first numbers)) (max-so-far max-rolling))\n        (cond ((< max-so-far max-rolling)\
    \ max-so-far max-rolling)\n              ((> max-so-far max-rolling) max-so-far\
    \ max-rolling))\n            (else (loop (rest numbers) (max max-rolling max-so-far)\
    \ (max max-so-far max-rolling))))))\n", "  (if (null? numbers)\n      nil\n  \
    \    (let ([head (car numbers)])\n        (if (> head (car numbers))\n       \
    \     (list head)\n            (rolling_max (cdr numbers)))))))\n", "  (let loop\
    \ ((rolling-max #f) (remaining numbers))\n    (if (null? remaining)\n        rolling-max\n\
    \        (loop (if (< rolling-max remaining)\n                  (cons rolling-max\
    \ remaining)\n                  rolling-max)\n               (rest remaining)))))\n",
  "  (let loop ((number numbers)\n             (max-rolling '())\n             (max-index\
    \ '()))\n    (cond\n      [(empty? number) max-index]\n      [(<= number (car\
    \ max-rolling)) max-index]\n      [(< number (car max-rolling)) (loop (cdr number)\
    \ (cdr max-rolling) (max max-index number))]\n      [else (loop (cdr number) (cdr\
    \ max-rolling) (max max-index number))]\n      )\n    ))", "  (cond\n    [(empty?\
    \ numbers) (empty?)] \n    [(empty? numbers) (list empty?)] \n    [(> (car numbers)\
    \ (tail numbers)) (list (car numbers) (car numbers))]\n    [else (cons (car numbers)\
    \ (rolling_max (cdr numbers)))]))\n", "  (cond ((null? numbers) '())\n       \
    \ ((< (car numbers) (rolling_max (cdr numbers))) (car numbers))\n        (else\n\
    \         (append (rolling_max (cdr numbers)) (list numbers)))))\n", "  (if (null?\
    \ numbers)\n      nil\n      (let ((head-number (car numbers))\n            (tail-numbers\
    \ (cdr numbers)))\n        (if (= head-number 0)\n            (reverse tail-numbers)\n\
    \            (let ((new-head-number (- head-number (first tail-numbers))))\n \
    \             (if (<= head-number new-head-number)\n                  (cons head-number\n\
    \                         (cons (first tail-numbers)\n                       \
    \       (rolling_max (rest tail-numbers))))\n                  (cons new-head-number\n\
    \                         (cons (first tail-numbers)\n                       \
    \       (rolling_max (rest tail-numbers)))))))\n        )))\n", "  (define (rolling_max_helper\
    \ start n)\n    (cond\n      [(= n 0) (cons start numbers)]\n      [(number? (cdr\
    \ n)) (cons (car n) (rolling_max_helper (car n) (cdr n)))]\n      [else (rolling_max_helper\
    \ (car n) (sub1 n))]\n    ))\n\n  (rolling_max_helper nil (length numbers)))\n",
  "  (define rolling_max_helper\n    (lambda (current-max current-sum)\n      (let\
    \ loop ((current-max current-max) (current-sum current-sum))\n        (cond ((null?\
    \ numbers) (cons current-max current-sum))\n              ((> current-max current-sum)\
    \ (loop (car numbers) current-sum))\n              (else (loop (cdr numbers) (+\
    \ current-sum current-max)))))))\n  (rolling_max_helper 0 0))\n", "  (let* ((rolling-max-start\
    \ (max 0 (car numbers)))\n         (rolling-max-end (car (cdr numbers)))\n   \
    \      (rolling-max-result '()))\n    (cond\n      [(number? rolling-max-start\
    \ rolling-max-end)\n       (cons rolling-max-start rolling-max-result)]\n    \
    \  [(< rolling-max-start rolling-max-end)\n       (append (list rolling-max-start)\
    \ (rolling_max (cdr numbers)))]\n      [else (append (list rolling-max-start)\
    \ (rolling-max-result) (rolling-max-end)\n                 rolling-max-result)])))\n",
  "  (if (empty? numbers)\n      (list empty)\n      (let ([tail (tail numbers)])\n\
    \        (cons (max (first tail)) (rolling_max (rest tail)))))) ;; #lang racket\n",
  "  (let loop ((result '())\n             (current-max 0)\n             (current-number\
    \ numbers)\n             (max-index '()))\n    (if (null? current-number)\n  \
    \      result\n        (loop (cons (car current-number) result)\n            \
    \  (car current-number)\n              (cons (car current-number) max-index)\n\
    \              (if (> (car current-number) current-max)\n                  (cons\
    \ (car current-number) result)\n                  (cons (car current-number) (cons\
    \ (car current-number) max-index)))))\n    result))\n", "  (define (current max)\n\
    \    (let ([mmax (first numbers)])\n      (cond ((null? numbers) max)\n      \
    \      ((<= mmax (first numbers)) \n             (current (first numbers) max))\n\
    \            (else (current (first numbers) max))))\n  (let ([max numbers])\n\
    \    (cond ((null? numbers) '())\n          ((= max (first numbers)) (current\
    \ max))\n          (else (current (first numbers) max)))))\n", "  (let loop ((numbers\
    \ numbers)\n             (result '()))\n    (cond\n      ((null? numbers) result)\n\
    \      ((<= (length result) (length (cdr numbers))) result)\n      (else (loop\
    \ (cdr numbers)\n                 (cons (max (car numbers) (first result))\n \
    \                      result))))))\n</code>\n<|/ a dscore=1 |>\n<| a |>\nIn Racket\
    \ there are functions to do that for you:\n<code>\n> (define (rolling_max lst)\n\
    \    (if (null? lst)\n        '()\n        (let loop ((head (car lst))\n     \
    \              (tail (cdr lst))\n                   (acc '()))\n          (if\
    \ (null? tail)\n              acc\n              (loop (car tail)\n          \
    \          (cons (car head) acc)\n                    (cons (car head) acc))))))\n\
    \n> (rolling-max (list 1 2 3 2 3 4 2))", "  (if (null? numbers)\n      '()\n \
    \     (cons (max (first numbers)) (rolling_max (rest numbers)))))\n", "  (cond\
    \ ((empty? numbers) numbers)\n        ((null? (rest numbers)) (rest numbers))\n\
    \        (else\n         (define max-number-idx (rest numbers)\n             \
    \     (if (null? (rest numbers)) (rest numbers)\n                      (let ((max-number\n\
    \                             (car numbers))\n                          (numbers\
    \ (cdr numbers))\n                          (current-number\n                \
    \             (car numbers))\n                          (max-idx (rest max-number-idx))\n\
    \                          (new-numbers (list)))\n                        (cond\
    \ ((< current-number max-number)\n                              (let ((new-idx\
    \ (+ max-idx (length max-number-idx))))\n                                 (list-append\
    \ new-numbers (list max-number))\n                                 (list-append\
    \ new-idx (list new-idx))\n                                 (list-append new-numbers\
    \ (list current-number))\n                                 (rolling_max (list-copy\
    \ new-numbers))\n                                 (rolling_max (list-copy new-idx))))\n\
    \                              (else (rolling_max (list-copy new-numbers)))))))))))",
  "  (if (empty? numbers) '()\n      (if (< (car numbers) (max (rolling_max (cdr numbers))))\n\
    \          (cons (car numbers) (rolling_max (cdr numbers)))\n          (rolling_max\
    \ (cdr numbers)))))\n", "  (let loop ([numbers numbers] [[-1 -1] [-1 0] [0 -1]\
    \ [1 -1] [1 0]])\n    (if (null? numbers)\n        [-1 -1]\n        (let ([head\
    \ (first numbers)] [tail (rest numbers)])\n          (if (> head tail)\n     \
    \         [head tail]\n              (let ([new-head (loop (rest tail)\n     \
    \                              [(if (> head tail) head tail)\n               \
    \                      (if (< head tail) head tail)\n                        \
    \             tail]\n                                    [(if (< head tail) head\
    \ tail)\n                                     (if (> head tail) head tail)\n \
    \                                    tail])]\n                (if (< head tail)\n\
    \                    [head new-head]\n                    (loop (rest tail)\n\
    \                           (if (< head tail) [head tail] [head new-head])\n \
    \                          (if (> head tail) [head tail] [head new-head])))])))])))\n",
  "  (cond [(empty? numbers) empty]\n        [(empty? (rest numbers)) (first numbers)]\n\
    \        [else (max (first numbers) (rolling_max (rest numbers))))))\n", "  (if\
    \ (null? numbers)\n      '()\n      (let ((max-rolling (first numbers))\n    \
    \        (max-until-rolling (first numbers)))\n        (cond ((> (car numbers)\
    \ max-rolling) (cons max-until-rolling (rolling_max (cdr numbers))))\n       \
    \       ((<= max-until-rolling max-rolling) (cons max-until-rolling (rolling_max\
    \ (cdr numbers))))\n              (else (cons max-until-rolling (rolling_max (cdr\
    \ numbers)))))))\n", "  (let loop ((result '())\n             (numbers (append\
    \ numbers result))\n             (tail (rest numbers)))\n    (cond\n      ((null?\
    \ tail) result)\n      ((< (car tail) (car numbers)) (loop (append result (car\
    \ tail)) numbers tail))\n      (else (loop (append result (car tail)) (cdr numbers)\
    \ tail)))))\n", "  (cond [(empty? numbers) '()]\n        [(= (length numbers)\
    \ 1) (first numbers)]\n        [else (max_rolling_max (tail numbers)\n       \
    \                       (first_rolling_max (first numbers))\n                \
    \              (last_rolling_max (last numbers))\n                           \
    \   (+ 1 numbers))]))\n", "  (cond [(empty? numbers) '()]\n        [(zero? first)\
    \ numbers]\n        [(< (first numbers) (first result)) (cons first result)]\n\
    \        [else (rolling_max (rest numbers))]))\n", "  (let loop ((numbers numbers)\n\
    \             (max-found (first numbers))\n             (max-found (max max-found\
    \ (first numbers))))\n    (if (null? numbers)\n        (list max-found)\n    \
    \    (loop (rest numbers)\n               (max max-found (first numbers))))))\n",
  "  (let loop ((numbers numbers)\n             (result '()))\n    (cond\n      [(empty?\
    \ numbers) result]\n      [else (loop (rest numbers)\n                   (cons\
    \ (max (first numbers) result) result))]))\n  result)\n", "  (if (null? numbers)\n\
    \      '()\n      (append (max_by (lambda (x) (<= x numbers))\n              \
    \        (tail numbers))\n              (rolling_max (cdr numbers)))))\n", " \
    \ (define (max-at-points points moment)\n    (define (max-at-points-helper points)\n\
    \      (cond [(< moment (first points)) (max-at-points-helper (rest points))]\n\
    \            [else (if (> (first points) moment) (first points)\n            \
    \          (if (> (first points) (first points)) (first points)\n            \
    \            (first points))\n                      (max-at-points-helper points))])))\n\
    \    (max-at-points-helper numbers))\n  (define (rolling_max-step current points)\
    \ (max-at-points points current))\n  (define (rolling_max-reduce current)\n  \
    \  (if (null? (rest current))\n        current\n        (cons (first current)\n\
    \              (rolling_max-reduce (cons (rest current) (first current))))))\n\
    \  (let loop ((current (first numbers)) (points '()) (moment (first points))\n\
    \             (max-point '()))\n    (if (null? current)\n        (cons max-point\
    \ (loop (rest numbers) '() moment max-point))\n        (loop (rest current) (cons\
    \ (first current) points)\n               (second current) (first max-point)))))",
  "  (define (rolling-max-helper numbers end-pos result)\n    (cond [(null? numbers)\
    \ result]\n          [(> end-pos (length numbers)) (rolling-max-helper numbers\
    \ (add1 end-pos) (cons (car numbers) result))]\n          [else (rolling-max-helper\
    \ (cdr numbers) end-pos (cons (car numbers) result))]\n          ))\n  (define\
    \ (rolling-max-aux numbers end-pos result)\n    (rolling-max-helper numbers (add1\
    \ end-pos) result))\n  (rolling-max-aux numbers (length numbers) '()))\n", " \
    \ (let loop ((result '())\n             (max-so-far max))\n    (if (null? numbers)\n\
    \        result\n        (loop (cons (car numbers)\n                  result)\n\
    \              (max numbers (car numbers)))))))\n", "  (define (rolling_max numbers\
    \ acc)\n    (cond\n      ((null? numbers) acc)\n      ((null? (cdr numbers)) (car\
    \ acc))\n      (else\n       (let ((n (car numbers))\n             (m (car (cdr\
    \ numbers))))\n         (if (< n m)\n            (rolling_max (cdr numbers) (cons\
    \ n (cons m acc)))\n            (rolling_max (cdr numbers) (cons m acc)))))\n\
    \      (else (rolling_max (cdr numbers) acc))))\n  (rolling_max numbers nil))\n",
  "  (define (rolling_max_aux current max)\n    (cond ((null? current) (list max))\n\
    \          ((equal? max (car current)) (rolling_max_aux (cdr current) (max)))\n\
    \          (else (rolling_max_aux (cdr current) (max car current)))))\n  (rolling_max_aux\
    \ (cdr numbers) (car numbers)))\n", "  (let loop ((numbers (reverse numbers))\n\
    \             (current-max numbers (car numbers)))\n    (cond\n      [(null? numbers)\
    \ (list current-max)]\n      [(> (car numbers) current-max) (loop (cdr numbers)\
    \ current-max)]\n      [(< current-max (car numbers)) (loop (cdr numbers) (car\
    \ numbers))]\n      [else (loop (cdr numbers) current-max)])))\n", "  (cond\n\
    \    [(empty? numbers)\n     (error \"Input list is empty.\")]\n    [(= 1 (length\
    \ numbers))\n     (append (first numbers) (second numbers))]\n    [(>= 1 (length\
    \ numbers))\n     (append (first numbers) (rolling_max (rest numbers))))]))\n",
  "  (if (null? numbers)\n      (list '??)\n      (let ((max (car numbers)))\n   \
    \     (if (> max 0)\n            (cons (rolling_max (cdr numbers)) (list (car\
    \ numbers) max))\n            (rolling_max (cdr numbers)))))))\n", "  (if (null?\
    \ numbers) numbers\n      (let ([x (car numbers)])\n        (cons x\n        \
    \       (let ([y (rolling_max (cdr numbers))])\n                 (cons x (max\
    \ x y))))))\n", "  (cond\n    [(empty? numbers) empty]\n    [(cons? numbers) (cons\
    \ (car numbers) (rolling_max (cdr numbers)))]\n    [else (rolling_max (cons (car\
    \ numbers) (rolling_max (cdr numbers))))]))\n", "  (cond\n    [(empty? numbers)\
    \ empty]\n    [(= (length numbers) 1) numbers]\n    [else (append\n          \
    \   (rolling_max (cdr numbers))\n             (list (max numbers (first numbers))))]))\n",
  "  (if (null? numbers)\n      '()\n      (let loop ((max-so-far max)\n         \
    \        (numbers (rest numbers))\n                 (current (first numbers))\n\
    \                 (index (length numbers)))\n        (cond (<= current max-so-far)\n\
    \              (if (null? numbers)\n                  '()\n                  (loop\
    \ (max max current)\n                         (rest numbers)\n               \
    \          current\n                         (+ index 1)))\n              (= (first\
    \ numbers) current)\n              (loop (max max current)\n                 \
    \  numbers\n                   current\n                   (+ index 1)))))) ;\
    \ cond.\n", "  (let loop ([list '()\n                 max (first numbers)]\n \
    \            [current (first numbers)\n              result '()])\n    (if (null?\
    \ numbers)\n        result\n        (loop\n             (rest numbers)\n     \
    \        (rest current)\n             (if (> (first current) max)\n          \
    \       (cons current result)\n                 result))))))\n", "  (let loop\
    \ ((max-found (first numbers)) (found (first numbers)))\n    (if (null? numbers)\n\
    \        (list max-found)\n        (loop (max max-found found) (first numbers)))))\n",
  "  (let loop ((max_so_far (first numbers))\n             (numbers (rest numbers))\n\
    \             (result '()))\n    (if (empty? numbers)\n        result\n      \
    \  (loop (max max_so_far first numbers)\n              (cons first numbers)\n\
    \              (cons (max max_so_far first numbers) result)))))\n", "  (let* ((acc\
    \ (max numbers))\n         (result (append numbers [acc]))\n         (tail (cdr\
    \ result))\n         (head (car tail))\n         (next-tail (rolling_max (cdr\
    \ tail))))\n    (cond [(> (car tail) head) (cons head next-tail)]))) \n", "  (cond\n\
    \    ((null? numbers) (list numbers))\n    ((null? (cdr numbers)) (car numbers))\n\
    \    ((<= (car numbers) (rolling_max (cdr numbers))) (cons (car numbers) (rolling_max\
    \ (cdr numbers))))\n    (else (rolling_max (cdr numbers)))))\n", "  (let loop\
    \ ((current-max numbers)\n             (acc '()))\n    (if (null? current-max)\n\
    \        acc\n        (loop (rest current-max\n                   (cons (max acc\
    \ (car current-max))\n                         acc))\n              (cons (car\
    \ current-max) acc))))))\n", "  (if (empty? numbers)\n      '()\n      (let ([max\
    \ (car numbers)])\n        (if (> (car numbers) max)\n            (let ([new (max\
    \ numbers)])\n              (cons new new))\n            (let ([new (rolling_max\
    \ (cdr numbers))])\n              (cons new new))))))\n", "  (cond\n    [(empty?\
    \ numbers) '()]\n    [else (max @(map (lambda (i) (cons (first numbers) i)) (rest\
    \ numbers)) (rest numbers))]))\n", "  (if (empty? numbers)\n      '()\n      (cons\
    \ (max numbers) (rolling_max (rest numbers)))))\n", "  (if (empty? numbers)\n\
    \      '()\n      (append\n       (list\n        (max (car numbers)\n        \
    \     (rolling_max (cdr numbers))))\n       (rolling_max (cdr numbers)))))\n",
  "  (cond [(empty? numbers) empty]\n        [(> (last numbers) (first numbers)) (cons\
    \ (first numbers) (rolling_max (rest numbers)))]\n        [else (rolling_max (rest\
    \ numbers))]))\n", "  (let loop ((numbers (reverse numbers)) \n             (result\
    \ empty))\n    (cond\n      [(empty? numbers)\n       result]\n      [(> (first\
    \ numbers) (first result)) result]\n      [else (loop (rest numbers)\n       \
    \           (cons (first numbers)\n                        result))])))\n", " \
    \ (let ([start (length numbers)])\n    (let ([result (list* numbers '())]\n  \
    \        [max_so_far (first numbers)]\n          [max_count 1])\n      (if (>=\
    \ start 0)\n          (let ([i (- start 1)])\n            (if (< i max_count)\n\
    \                (begin\n                  (set! result (cons (first numbers)\
    \ result))\n                  (set! max_so_far (max max_so_far i))\n         \
    \         (set! max_count (+ max_count 1))\n                  (rolling_max (subseq\
    \ numbers i (length numbers)))\n                  (cons max_so_far result)\n \
    \                 (set! result (cons (first numbers) result))\n              \
    \    (set! max_so_far (max max_so_far i))\n                  (set! max_count (+\
    \ max_count 1))\n                  (rolling_max (subseq numbers (+ i 1) (length\
    \ numbers)))\n                )\n              (begin\n                (set! result\
    \ (cons (first numbers) result))\n                (set! max_so_far (max max_so_far\
    \ i))\n                (set! max_count (+ max_count 1))\n                (rolling_max\
    \ (subseq numbers 1 (- i 1)))\n                (cons max_so_far result)\n    \
    \            (set! result (cons (first numbers) result))\n                (set!\
    \ max_so_far (max max_so_far i))\n                (set! max_count (+ max_count\
    \ 1))\n                (rolling_max (subseq numbers (+ i 1) (length numbers)))\n\
    \              )\n            )\n          (begin\n            (set! result (cons\
    \ (first numbers) result))\n            (set! max_so_far (max max_so_far i))\n\
    \            (set! max_count (+ max_count 1))\n            (rolling_max (subseq\
    \ numbers 1 (- start 1)))\n            (cons max_so_far result)\n            (set!\
    \ result (cons (first numbers) result))\n            (set! max_so_far (max max_so_far\
    \ i))\n            (set! max_count (+ max_count 1))\n            (rolling_max\
    \ (subseq numbers (+ i 1) (length numbers)))\n          )\n        )\n      result\n\
    \    )\n  )\n)\n", "  (if (null? numbers)\n      '()\n      (let ((max-so-far\
    \ (car numbers)))\n        (if (< max-so-far max-so-far)\n            (cons max-so-far\
    \ numbers)\n            (rolling_max (cdr numbers))))))\n", "  (cond [(empty?\
    \ numbers) empty]\n        [(cons? numbers) (cons (car numbers) (rolling_max (cdr\
    \ numbers)))]\n        [else (rolling_max (cdr numbers))]))\n", "  (if (null?\
    \ numbers)\n      '()\n      (append\n       (map maximum (subsequences numbers))\n\
    \       (rolling_max (subsequences (rest numbers))))))\n", "  (let loop ((numbers\
    \ '()) (result '()))\n    (if (null? numbers)\n        result\n        (loop (rest\
    \ numbers)\n              (cons (max (first numbers)) (cons numbers result))))))\
    \ \n", "  (let ((max-lists '()))\n    (loop for i below numbers (+ i 1) (set!\
    \ max-lists (cons i max-lists))\n          while max-lists))\n</code>\n<|/ a |>\n\
    <| a |>\nA simple way is to use tail recursion (tail recursion is when recursive\
    \ calls are in the same function as where the recursive call is).\nTail recursion\
    \ doesn't require any new bindings (and they don't have to be named bindings--that's\
    \ just the default in Scheme).\n<code>", "  (if (null? numbers)\n      '()\n \
    \     (append\n       (map (lambda (x) (max-elt numbers x))\n            (take-while-predicate\
    \ (lambda (n) (< n x)) (drop-while numbers (rest numbers))))\n       (rolling_max\
    \ (rest numbers)))))\n", "  (cond [(null? (rest numbers)) #f]\n        [(> (first\
    \ numbers) (first max)) max]\n        [else (cons (first max) (rolling_max (rest\
    \ numbers))) ]))\n", "  (let loop ((max #f) (numbers numbers)\n             (index\
    \ 0))\n    (cond\n      [(null? numbers) (list max)]\n      [(< (car numbers)\
    \ max) (loop (car numbers) (cdr numbers) (+ index 1))]\n      [(= index 1) (loop\
    \ (car numbers) (cdr numbers) (+ index 1))]\n      [else (loop (car numbers) (cdr\
    \ numbers) (+ index 1))]\n      )))\n", "  (letrec ((max_helper\n            (lambda\
    \ (max_list current_max current_max)\n              (cond\n                [(empty?\
    \ max_list) (list current_max)]\n                [else (if (>= (first max_list)\
    \ current_max)\n                        (max_helper (rest max_list)\n        \
    \                            (first max_list))\n                        max_helper\
    \ (rest max_list) (first max_list))])))))\n    (max_helper numbers 0 (first numbers))))\n",
  "  (if (empty? numbers)\n      '()\n      (let loop ((max-so-far (first numbers))\
    \ (numbers (rest numbers)) (result '()))\n        (cond ((> max-so-far (first\
    \ numbers)) (loop (first numbers) numbers (append result (list (first numbers)))))\n\
    \               ((empty? numbers) (loop (first numbers) numbers (append result\
    \ (list (first numbers)))))\n               (else (loop (first numbers) numbers\
    \ (append result (list (first numbers)))))))))\n", "  (let ([max-accumulator (first\
    \ (reverse numbers))])\n    (if (null? numbers)\n        (list max-accumulator)\n\
    \        (let ([number (first numbers)])\n          (if (null? (rest numbers))\n\
    \              (list max-accumulator)\n              (let ([number (first (rest\
    \ numbers))])\n                (if (> number max-accumulator)\n              \
    \      (cons (max max-accumulator number) max-accumulator)\n                 \
    \   (cons number max-accumulator))))))))\n", "  (if (empty? numbers)\n      '()\n\
    \      (let ((max (first numbers))\n            (index (- 1 (length numbers)))\n\
    \            (rolling-max (subseq numbers index -1)))\n        (cond ((> max rolling-max)\
    \ rolling-max)\n              (else (cons max rolling-max)))))\n", "  (if (null?\
    \ numbers)\n      '()\n      (let loop ((max (first numbers)) (tail (rest numbers)))\n\
    \        (if (null? tail)\n            (cons max max)\n            (loop (max\
    \ max (first tail)) (rest tail)))))) ;;#lang racket\n", "  (if (null? numbers)\n\
    \      '()\n      (cons (max (car numbers)) (rolling_max (cdr numbers)))))\n",
  "  (let ((max (car numbers))\n        (cdr numbers))\n    (if (null? numbers)\n\
    \        max\n        (let ((next (rolling_max (cdr numbers))))\n          (if\
    \ (> (max next) next)\n              (cons next max)\n              (cons next\
    \ next)))))) ;;#lang racket\n", "  (let loop ((n numbers) (m (first n)) (max-rolling\
    \ m))\n    (cond ((null? n) '())\n          ((< m (first n)) (loop n (first n)\
    \ (+ m (first n))))\n          ((< m (first n)) (loop n (+ m (first n)) (max m\
    \ (first n))))\n          (else (cons m (loop n (+ m (first n)) m)))))) ; #lang\
    \ racket\n", "  (cond [(empty? numbers) numbers]\n        [(< (car numbers) (car\
    \ (cdr numbers)))\n         (cons (car numbers) (rolling_max (cdr numbers)))]\n\
    \        [else (rolling_max (cdr numbers))]))\n", "  (define (helper numbers current-max)\n\
    \    (cond [(empty? numbers) '()]\n          [(= (remainder current-max numbers)\
    \ (first numbers)) current-max]\n          [else (helper (rest numbers) (first\
    \ numbers))]))\n  (helper numbers 0))\n", "  (let loop ((numbers numbers) (max\
    \ #f))\n    (if (null? numbers)\n        (list max)\n        (let ((n (car numbers))\n\
    \              (max-i (car numbers))\n              (cur-max-i (car numbers)))\n\
    \          (loop (cdr numbers)\n                (if (< max-i n)\n            \
    \        (cond ((< n max-i)\n                           (loop (cdr numbers) n))\n\
    \                          (#t cur-max-i))\n                    (loop numbers\
    \ (cons max-i cur-max-i))))))))\n", "  (let loop ((number numbers)\n         \
    \    (max-list #f)\n             (max-list #f))\n    (cond ((null? numbers)\n\
    \           max-list)\n          ((<= (length numbers) 1)\n           (if (> (car\
    \ numbers) (caar max-list))\n               (set-cdr! max-list (car numbers))\n\
    \               (loop (cdr numbers)\n                     (set-cdr! max-list (cdr\
    \ max-list)))\n               (loop (cdr numbers)\n                     (set-cdr!\
    \ max-list (cdr max-list))))\n          (else\n           (loop (cdr numbers)\n\
    \                 (set-cdr! max-list (max max-list (car numbers)))))\n       \
    \   (t (loop (cdr numbers)\n                 (max max-list (caar max-list))\n\
    \                 (set-cdr! max-list (car numbers))))))\n", "  (cond\n    ((null?\
    \ numbers) '())\n    ((< (car numbers) (max-so-far numbers)) (car numbers))\n\
    \    (else\n     (cons (car numbers)\n           (rolling_max (rest numbers)))))))\n",
  "  (define (rolling_max-aux accum n)\n    (cond\n      [(null? n) (cons accum nil)]\n\
    \      [(not (pair? (car n)))\n       (if (>= accum n) (cons accum nil)\n    \
    \        (rolling_max-aux (max accum (car n)) (cdr n)))]\n      [(not (pair? (car\
    \ n)))\n       (if (>= accum n) (cons accum nil)\n            (rolling_max-aux\
    \ accum n))]\n      [(pair? (car n))\n       (rolling_max-aux (max accum (car\
    \ n)) (cdr n))]))\n  (let loop ((n numbers) (acc '()))\n    (if (null? n)\n  \
    \      (reverse acc)\n        (loop (cdr n) (cons (car n) acc)))))", "  (define\
    \ (roll-max-helper\n           (numbers list)\n           (if (null? numbers)\n\
    \               list\n               (if (> 1 (cdr numbers))\n               \
    \    (cons (car numbers) (roll-max-helper (cdr numbers) list))\n             \
    \      (roll-max-helper (cdr numbers) list))))\n  (roll-max-helper numbers null))\n",
  "  (cond ((empty? numbers) numbers)\n        ((null? numbers) '())\n        ((null?\
    \ (rest numbers)) (first numbers))\n        (else (cons\n                (first\
    \ numbers)\n                (rolling_max (rest numbers))))))\n", "  (if (empty?\
    \ numbers)\n      '()\n      (let ([window (sub1 (last numbers))])\n        (cons\
    \ (max (first numbers)) (rolling_max (rest numbers))))))\n", "  (let loop ((max-so-far\
    \ #f) (max-so-far-index 0) (max-so-far-list '()))\n    (if (empty? numbers)\n\
    \        (list max-so-far)\n        (loop (max max-so-far numbers) (+ max-so-far-index\
    \ 1) (cons max-so-far max-so-far-list)))))\n", "  (define (helper max so_far)\n\
    \    (cond\n      [(empty? so_far) (max)]\n      [else (helper (max so_far (first\
    \ so_far)) (first so_far))]))\n  (helper '() numbers))\n", "  (if (null? numbers)\n\
    \      null\n      (cond ((> (car numbers) (cadr numbers)) (list numbers))\n \
    \           ((> (car numbers) (caddr numbers)) (list (car numbers) (caddr numbers)))\n\
    \            (else (list (car numbers) (rolling_max (cdr numbers)))))))\n", " \
    \ (if (null? numbers) numbers)\n  (let ((max (first numbers)))\n    (if (null?\
    \ numbers) numbers\n    (let ((next (second numbers))\n          (rest (rest numbers))\n\
    \          (tail (rolling_max (rest numbers))))\n      (if (<= max next)\n   \
    \       (cons next tail)\n          (cons (first numbers) tail)))))))\n", "  (cond\
    \ ((null? numbers) (list 0))\n        ((< (car numbers) (tail numbers))\n    \
    \     (cons (car numbers) (rolling_max (cdr numbers))))\n        (else\n     \
    \    (rolling_max (cdr numbers)))))\n", "  (cond [(empty? numbers) nil]\n    \
    \    [(> (first numbers) (first numbers)) (rolling_max (rest numbers))]\n    \
    \    [else (cons (first numbers) (rolling_max (rest numbers)))]))\n", "  (define\
    \ (rolling_max_loop n result)\n    (if (< n 0) \n        result\n        (rolling_max_loop\
    \ (- n 1) (max result n))))\n  (define (rolling_max_aux (result n numbers)\n \
    \   (cond ((= n 0) result)\n          ((> n 0) (rolling_max_aux (rolling_max_loop\
    \ n result) n (rest numbers))))\n  (rolling_max_aux (list number number) 0 (reverse\
    \ numbers)))\n)\n", "  (let loop ((numbers numbers)\n             (max-list '())\n\
    \             (max-number 0))\n    (cond\n      [(empty? numbers) max-list]\n\
    \      [else (loop (rest numbers)\n                    (cons max-number\n    \
    \                       (loop (rest numbers)\n                               \
    \   (cons max-number\n                                        max-list))\n   \
    \                 max-number))])))\n", "  (let loop ((numbers numbers) (max_list\
    \ '()))\n    (if (null? numbers)\n        max_list\n        (loop (cdr numbers)\
    \ (if (> (car numbers) (first max_list)) (cons (car numbers) max_list) max_list))))\n",
  "  (cond\n    [(empty? numbers) numbers]\n    [else (cons (max 1 (car numbers))\
    \ (rolling_max (cdr numbers))) ]))\n", "  (let loop ((acc '()) (numbers numbers))\n\
    \    (if (null? numbers)\n        acc\n        (loop (append acc (max (car numbers)\
    \ acc)) (cdr numbers)))))\n", "  (let ((max-element (first numbers)))\n    (cond\
    \ ((empty? numbers) max-element)\n          ((>= max-element (first (rest numbers)))\n\
    \           (rolling_max (rest numbers)))\n          (else (cons (first numbers)\n\
    \                       (rolling_max (rest numbers)))))))\n</code>\n<|/ a tags=max,scheme,racket,list\
    \ |>\n<| a tags=max,scheme,racket,list dscore=1 |>\nThis is a simple way of doing\
    \ it:\n<code>", "  (let* ((number-count-up 0)\n         (result '()))\n    (if\
    \ (null? numbers)\n        result\n        (loop for num in numbers until number-count-up\n\
    \              collect (max num\n                          (set! number-count-up\
    \ number-count-up + 1)\n                          result)))))\n", "  (if (null?\
    \ numbers)\n      (list empty)\n      (let ((max (first numbers))\n          \
    \  (rolling (list)))\n        (append rolling (list (max (rest numbers))))\n \
    \       (if (= (length rolling) 9)\n            (append (list rolling)\n     \
    \               (list max))\n            (rolling_max (rest rolling))\n      \
    \    )\n        )\n      )\n    )\n  )\n</code>\n<|/ a dscore=1 |>\n<| c |>\n\
    Could you please explain a bit more on what this code is doing? I'm having trouble\
    \ understanding how exactly it works. Thanks\n<|/ c |>\n<| c |>\n: I did some\
    \ editing, hope it helps :)\n<|/ c |>\n<| a tags=scheme,racket |>\nA recursive\
    \ solution might be better for this problem. Let's say that the list of numbers\
    \ you want to find rolling maxima is given by the parameter numbers. We would\
    \ like to have a function maxima that would produce a list of maxima for the input\
    \ list of numbers. \nWe could implement it like this:\n<code>", "  (define (helper\
    \ n acc)\n    (if (> n 0)\n        (helper (- n 1) (max acc (- n 1))))\n    acc))\n\
    \n  (if (empty? numbers)\n      numbers\n      (helper (car numbers) (first numbers))))\n",
  "  (let* ((sum (apply + numbers))\n         (max numbers))\n    (if (zero? sum)\n\
    \        max\n        (let ((i (floor sum)))\n          (if (<= max numbers)\n\
    \              (rolling_max (sub1 numbers))\n              (cons max numbers))))))\n",
  "  (define (accumulate accum max)\n    (cond ((null? accum) (list max))\n      \
    \    ((> (car accum) max) (cdr accum))\n          (else (cons (car accum) (accumulate\
    \ (cdr accum) max)))))\n  (accumulate (list '()) (car numbers))\n)\n", "  (cond\
    \ [(null? numbers)\n         null]\n        [(null? (cdr numbers))\n         (car\
    \ numbers)]\n        [else\n         (let [first (car numbers)\n             \
    \  max (car numbers)\n               rest (cdr numbers)\n               max1 (rolling_max\
    \ (filter (lambda (x) (not (= x max)) rest))) \n               max2 (rolling_max\
    \ (filter (lambda (x) (= x max)) rest))]\n           (if (= first max2)\n    \
    \           (cons max max1)\n               (cons max max2)))]))\n", "  (cond\
    \ ((null? numbers) '())\n        ((null? (cdr numbers)) (cons (car numbers) '()))\n\
    \        (else (cons\n                 (max (car numbers)\n                  \
    \     (rolling_max (cdr numbers)))))))\n", "  (if (null? numbers) '()\n    (let\
    \ ((max (first numbers))\n          (tail (rest numbers)))\n      (if (<= max\
    \ tail)\n          (list max)\n          (cons (rolling_max (cons max tail))\n\
    \                (rolling_max (cdr tail)))))))\n", "  (define (helper start end\
    \ accum max_end)\n    (if (= end max_end)\n        accum\n        (helper (+ start\
    \ 1) end (cons end accum) (+ max_end 1)))\n    (helper start (- end 1) '() (-\
    \ end 1)))\n  (define (rolling_max_aux start end accum max_end accum_new)\n  \
    \  (if (= end max_end)\n        (cons accum_new accum)\n        (rolling_max_aux\
    \ (+ start 1) end (cons end accum) (+ max_end 1) (cons end accum_new))))\n  (helper\
    \ 0 end '() (length numbers)))\n</code>\nAnd then:\n<code>", "  (define (rolling_max_rec\
    \ rolling numbers)\n    (if (null? numbers)\n        (reverse rolling)\n     \
    \   (rolling_max_rec\n         (append rolling (car numbers)) (remove-if (lambda\
    \ (x) (> x max)) numbers))))\n  (define max #f)\n  (define rolling (list* max\
    \ numbers))\n  (rolling_max_rec rolling numbers))\n</cell>\n<cell>\n#lang racket\n",
  "  (if (null? numbers)\n      '()\n      (let loop ((numbers numbers)\n        \
    \         (result '()))\n        (if (null? (rest numbers))\n            result\n\
    \            (loop (rest numbers)\n                  (cons (car numbers) result)))))\n",
  "  (define (rolling_max_aux (max-number acc i rolling_list accs)\n             \
    \           (if (null? rolling_list)\n                            (cons max-number\
    \ (cons (car accs) acc))\n                            (let ((next-number (car\
    \ rolling_list)))\n                              (if (> next-number max-number)\n\
    \                                  (rolling_max_aux (car rolling_list) (cdr acc)\
    \ (cdr rolling_list)\n                                                     (cons\
    \ (car rolling_list) acc)))\n                                  (rolling_max_aux\
    \ (car rolling_list) (cdr acc) (cdr rolling_list)\n                          \
    \                           (cons next-number (cons (car accs) acc)))))))\n  (rolling_max_aux\
    \ numbers null numbers nil))\n", "  (cond\n    [(empty? numbers) (cons (car numbers)\
    \ empty)]\n    [(equal? (car numbers) (last (cdr numbers)))\n     (list (car numbers))\n\
    \     (rolling_max (cdr numbers))]\n    [else (max (car numbers)\n           \
    \    (rolling_max (cdr numbers))\n               numbers)])\n  )\n", "  (let ([rolling\
    \ (make-array (array-dimensions numbers) #f (array-bounds numbers))])\n    (loop\n\
    \       [i 0]\n       (when (< (array-ref numbers i)\n              (min (array-ref\
    \ rolling i)))\n         (set! rolling (rest rolling) (rest numbers) (rest i))\n\
    \         (incf i))\n      (loop\n         [i 0]\n         (when (< (array-ref\
    \ numbers i)\n                  (min (array-ref rolling i)))\n           (set!\
    \ rolling (rest rolling) (rest numbers) (rest i))\n           (incf i))\n    \
    \   (append (rest rolling) (rest numbers)))))\n", "  (let loop [max-so-far 0]\n\
    \    (if (empty? numbers) max-so-far\n      (loop (if (> (car numbers) max-so-far)\
    \ max-so-far (car numbers)) (cdr numbers)))))\n</cell>\n<cell>\n#lang racket\n",
  "  (define (rolling number max)\n    (if (= number 0)\n        (list max)\n    \
    \    (let ((next (rolling (- number 1) max)))\n          (if (>= next max)\n \
    \             (list max)\n              (cons next (rolling number (car max)))))))\n\
    \  (let loop ((max numbers) (list numbers))\n    (if (null? max)\n        list\n\
    \        (let ((head (first max)))\n          (if (= head 0)\n              (loop\
    \ list (rolling head max))\n              (loop list (rolling (cdr head) max))))))\
    \ ; tail recursive\n</code>\n<|/ a dscore=0 |>\n<| a tags=algorithm,racket,recursion,lisp\
    \ |>\nI guess we can use foldr to solve this problem. For example, here is how\
    \ it might look in Racket code:\n<code>", "  (cond ((null? numbers) '())\n   \
    \     (else (cons (maximum (sub1 (rest numbers)) (rolling_max (rest numbers)))\n\
    \                    (rolling_max (rest numbers))))))", "  (define (roll-max previous\
    \ current)\n    (if (null? current)\n        (cons current previous)\n       \
    \ (roll-max (cons current (max previous current)) (cdr current))))\n  (roll-max\
    \ '() numbers))\n", "  (cond [(empty? numbers) (error 'rolling_max \"empty list\"\
    )]\n        [(null? (rest numbers)) (error 'rolling_max \"empty list\")]\n   \
    \     [(null? (car numbers)) (error 'rolling_max \"empty list\")]\n        [else\n\
    \         (if (> (car numbers) (reduce (lambda (x y)\n                       \
    \                    (if (< (car numbers) y)\n                               \
    \            x\n                                           y))\n             \
    \                    (car numbers)\n                                 #0\n    \
    \                             (reduce (lambda (x y)\n                        \
    \                    (if (> (car numbers) y)\n                               \
    \             x\n                                            y))\n           \
    \                             (car numbers)\n                                \
    \        (car numbers)\n                                        numbers))\n  \
    \                 (rolling_max (cdr numbers))]\n        ))]))\n", "  (if (null?\
    \ numbers)\n      '()\n      (cons (max (first numbers)) (rolling_max (rest numbers)))))\n",
  "  (let ((max-so-far #f))\n    (labels ((roll (max current-max)\n              \
    \ (cond\n                [(empty? numbers) (if (= max current-max) max current-max)]\n\
    \                [else (cond [(> current-max max) (cons max current-max)]\n  \
    \                           [else (roll (cdr max) (car numbers))])))]\n      \
    \     ))\n      (roll max-so-far #f numbers))))\n", "  (if (null? numbers)\n \
    \     '()\n      (cons (maximum (cdr numbers)) (cddr numbers))))\n", "  (define\
    \ (rolling_max-helper list max_so_far)\n    (if (null? list)\n        max_so_far\n\
    \        (rolling_max-helper (cdr list) (if (<= (last list) max_so_far)\n    \
    \                                      (last list)\n                         \
    \                 max_so_far))))\n  (rolling_max-helper numbers 0))\n", "  (cond\n\
    \    [(empty? numbers) empty]\n    [(> (first numbers) (first results)) (cons\
    \ (first numbers) results)]\n    [else (rolling_max (rest numbers))]))\n", " \
    \ (let loop ((i 0) (max 0))\n    (if (null? numbers)\n        max\n        (if\
    \ (>= i 4)\n            (cons max numbers)\n            (loop (add1 i) (max numbers\
    \ (modulo max numbers)))))))\n", "  (if (null? numbers)\n      '()\n      (let\
    \ ((current (first numbers)))\n        (if (null? (rest numbers))\n          \
    \  (list current)\n            (let ((next-max (cdr numbers)))\n             \
    \ (if (> current next-max)\n                  (list current)\n               \
    \   (list (max current next-max))))))))\n", "  (let ((max-elements (reverse (drop\
    \ (length numbers) numbers))))\n    (if (null? max-elements)\n        '()\n  \
    \      (append (take-while #(<= (first %) max-elements) max-elements)\n      \
    \          (rolling_max (drop (length numbers) numbers))))\n  )\n)\n</code>\n\
    <|/ a tags=scheme |>\n<| c |>\nThank you for taking the time to write this out.\
    \ The recursive version is much cleaner.\n<|/ c |>\n<| a |>\nA recursive tail\
    \ recursion version using map and foldr:\n<code>", "  (define (rolling_max-helper\
    \ n acc)\n    (if (= n 0) (cons max acc) (rolling_max-helper (- n 1) (cons (max\
    \ n) acc))))\n  (rolling_max-helper 1 (list 0)))\n</cell>\n<cell>\n#lang racket\n",
  "  (let ((max #f)\n        (count 0))\n    (for-each (lambda (n)\n             \
    \   (if (< n max)\n                    (set! count (1+ count)\n              \
    \              (if (> max n) max (cons n max)))\n                    (set! count\
    \ (1+ count)\n                            (if (> max n) max n)))))\n    (reverse\
    \ (drop (- count 1) numbers))))\n", "  (if (null? numbers)\n      '()\n      (let\
    \ ([head (first numbers)]\n            [tail (rest numbers)])\n        (if (null?\
    \ (rest tail))\n            (cons head tail)\n            (let ([result (rolling_max\
    \ (cdr tail))]\n                  [current-max (cons head result)]\n         \
    \         [maximum (cdr current-max)])\n              (cond [(> head maximum)\
    \ (cons head current-max)]\n                    [else (cons head current-max)]))))))\n",
  "  (define (rolling-max-helper numbers acc curr)\n    (cond [(empty? numbers)\n\
    \           acc]\n          [(= curr (first numbers))\n           (rolling-max-helper\
    \ (rest numbers)\n                            (cons curr (max acc (first numbers)))\
    \ (rest numbers))]\n          [else\n           (rolling-max-helper (rest numbers)\n\
    \                            (cons curr (max acc (first numbers))) (first numbers))]))\n\
    \  (rolling-max-helper numbers nil numbers))\n", "  (if (null? numbers)\n    \
    \  '()\n      (let ([m0 (car numbers)])\n        (if (or (>= m0 m) (number? m))\n\
    \            (cons m0 (rolling_max (cdr numbers))) ; maximum of the rest until\
    \ now\n            (cons m0 (rolling_max (cdr numbers)))))))\n", "  (if (empty?\
    \ numbers)\n      empty\n      (append (max (first numbers)) (rolling_max (rest\
    \ numbers)))))\n", "  (cond [(empty? numbers) empty]\n        [(number? (car numbers))\
    \ (cons (car numbers) (rolling_max (cdr numbers)))]\n        [else (rolling_max\
    \ (cdr numbers))]))\n", "  (define (rolling-max current-max current-index (max-list\
    \ max-lists max))\n    (cond\n      [(null? numbers)\n       (list current-max\
    \ current-index)]\n      [(< current-index max-index)\n       (rolling-max (append\
    \ current-max (max (rest numbers) max-list))\n                  (+ current-index\
    \ 1)\n                  (max max-list max))\n       ]\n      [else (rolling-max\
    \ (append current-max (max (rest numbers) max-list))\n                       \
    \  (+ current-index 1)\n                         max-list)]))\n  (define (max-list\
    \ max-lists max-list)\n    (cond\n      [(null? max-lists)\n       max-list]\n\
    \      [(> current-index max-index)\n       (max (max-list (rest max-lists) max-list))]))\n\
    \  (define max-index 0)\n  (define max-lists ())\n  (rolling-max 0 0 numbers))",
  "  (cond\n    ((empty? numbers) '())\n    ((equal? (first numbers) (first (first\
    \ (first numbers))))\n     (cons (first (first (first numbers))) (rolling_max\
    \ (rest numbers))))\n    (else\n     (if (> (first numbers) (first (first (first\
    \ numbers)))) (rolling_max (rest numbers)))\n     (cons (first numbers) (rolling_max\
    \ (rest numbers))))))) \n", "  (let* ((n (car numbers))\n         (m (cadr numbers))\n\
    \         (max-list (list (car numbers)\n                          (cons (car\
    \ numbers)\n                              (cons (car numbers)\n              \
    \                      (rolling_max (cdr numbers))))))\n         (max-list (list\
    \ (car numbers)\n                          (cons (car numbers)\n             \
    \                 (cons (car numbers)\n                                    (rolling_max\
    \ (cdr numbers))))))\n         (max-list (list (car numbers)\n               \
    \           (cons (car numbers)\n                              (cons (car numbers)\n\
    \                                    (rolling_max (cdr numbers))))))\n       \
    \  (max-list (list (car numbers)\n                          (cons (car numbers)\n\
    \                              (cons (car numbers)\n                         \
    \           (rolling_max (cdr numbers))))))\n         (max-list (list (car numbers)\n\
    \                          (cons (car numbers)\n                             \
    \ (cons (car numbers)\n                                    (rolling_max (cdr numbers))))))\n\
    \         (max-list (list (car numbers)\n                          (cons (car\
    \ numbers)\n                              (cons (car numbers)\n              \
    \                      (rolling_max (cdr numbers))))))\n         (max-list (list\
    \ (car numbers)\n                          (cons (car numbers)\n             \
    \                 (cons (car numbers)\n                                    (rolling_max\
    \ (cdr numbers))))))\n         (max-list (list (car numbers)\n               \
    \           (cons (car numbers)\n                              (cons (car numbers)\n\
    \                                    (rolling_max (cdr numbers))))))\n       \
    \  (max-list (list (car numbers)\n                          (cons (car numbers)\n\
    \                              (cons (car numbers)\n                         \
    \           (rolling_max (cdr numbers))))))\n         (max-list (list (car numbers)\n\
    \                          (cons (car numbers)\n                             \
    \ (cons (car numbers)\n                                    (rolling_max (cdr numbers))))))\n\
    \         (max-list (list (car numbers)\n                          (cons (car\
    \ numbers)\n                              (cons (car numbers)\n              \
    \                      (rolling_max (cdr numbers))))))\n         (max-list (list\
    \ (car numbers)\n                          (cons (car numbers)\n             \
    \                 (cons (car numbers)\n                                    (rolling_max\
    \ (cdr numbers))))))\n         (max-list (list (car numbers)\n               \
    \           (cons (car numbers)\n                              (cons (car numbers)",
  "  (define (loop numbers acc)\n    (cond\n      [(empty? numbers) (append acc (list\
    \ maximum (first numbers))))]\n      [else (loop (rest numbers) (cons (maximum\
    \ (first numbers)) (acc)))]))\n  (loop numbers empty))\n", "  (if (null? numbers)\n\
    \      '()\n      (let ((largest (car numbers))\n            (current (car numbers))\n\
    \            (max (car numbers)))\n        (if (= largest current)\n         \
    \   (list (max current))\n            (list (max current)\n                  \
    \ (rolling_max (cdr numbers)))))))\n", "  (if (null? numbers)\n      '()\n   \
    \   (let loop ((numbers (rest numbers)) (result '()))\n        (cond ((null? numbers)\
    \ result)\n              ((>= (first numbers) result) (first numbers))\n     \
    \         (else (loop (rest numbers) (cons (first numbers) result)))))))\n", " \
    \ (if (empty? numbers)\n      '()\n      (max (rest numbers)\n           (rolling_max\
    \ (rest numbers)))))\n", "  (define (iter accum num accum_min)\n    (if (null?\
    \ num) \n        (reverse accum)\n        (iter (cons num (car accum)) (cdr num)\
    \ (if (>= accum_min (car accum)) accum_min (car accum))))\n  (iter nil numbers\
    \ numbers))\n", "  (define (rolling-max number max-so-far list)\n    (if (null?\
    \ list)\n        max-so-far\n        (let ((next-number (car list)))\n       \
    \   (if (> next-number number)\n              (rolling-max number next-number\
    \ list)\n              (rolling-max next-number (max number max-so-far (car list))\
    \ (cons (car list) (cons number max-so-far)))))) \n  (rolling-max 0 (car numbers)\
    \ numbers))\n", "  (define (rolling_max-iter rolling_max-prev rolling_max-current\
    \ count)\n    (cond\n      [(null? rolling_max-current) rolling_max-prev]\n  \
    \    [(< count (length numbers))\n       (rolling_max-iter\n        (conj rolling_max-prev\
    \ rolling_max-current)\n        (rest rolling_max-current)\n        (- count 1))]\n\
    \      [(> count (length numbers))\n       (rest rolling_max-current)]\n     \
    \ [else (conj rolling_max-current rolling_max-prev)]\n     ))\n  (rolling_max-iter\
    \ '() numbers 1 0))\n", "  (cond [(empty? numbers) empty]\n        [(> (car numbers)\
    \ (first numbers)) (cons (car numbers) (rolling_max (rest numbers)))]\n      \
    \  [else (rolling_max (cdr numbers))]))\n", "  (cond [(null? numbers)\n      \
    \   numbers]\n        [(and (number? (car numbers))\n               (> (car numbers)\
    \ (rolling_max (cdr numbers))))\n         (cons (car numbers) (rolling_max (cdr\
    \ numbers)))]\n        [else\n         (rolling_max (cdr numbers))]))", "  (let\
    \ loop ([nums numbers sum 0]\n             [max null]\n             [max-so-far\
    \ null])\n    (cond [(empty? nums) max-so-far]\n          [(= sum (car nums))\
    \ (loop nums max max-so-far)]\n          [else (loop (cdr nums) (cons (car nums)\
    \ max) (car nums))]\n          )))\n", "  (cond [(empty? numbers) (empty? (cdr\
    \ numbers))]\n        [(empty? (car numbers)) (cons (car numbers) empty)]\n  \
    \      [else (let ([max_found (maximum (cdr numbers))])\n               (cons\
    \ (car numbers)\n                    (rolling_max (append (cdr numbers)\n    \
    \                                  (list (cons (car numbers) max_found))))))]))\n",
  "  (cond [(null? numbers) (list numbers)]\n        [(numbers (car numbers)) (cons\
    \ (max numbers) (rolling_max (rest numbers)))]))\n", "  (if (empty? numbers)\n\
    \      '()\n      (append (max (first numbers)) (rolling_max (subseq numbers 1\
    \ end)))))\n", "  (let loop ((rolling #f)\n             (maxes #f)\n         \
    \    (numbers numbers))\n    (if (null? numbers)\n        (reverse maxes)\n  \
    \      (let ((n (car numbers)))\n          (if (= rolling n)\n              (loop\
    \ n (cons (max rolling n) maxes)\n                    (dec numbers))\n       \
    \       (loop (+ rolling 1) (cons n maxes) (dec numbers))))))\n", "  (let loop\
    \ ((max-sum-so-far 0) (numbers (list numbers))\n             (num (first numbers))\
    \ (nums (rest numbers))\n             (sums null))\n    (cond\n      [(null? nums)\
    \ (cons (car numbers) sums)]\n      [(< (car nums) num) (loop (+ max-sum-so-far\
    \ (car nums))\n                               numbers (cdr nums) sums)]\n    \
    \  [else (loop (+ max-sum-so-far (car num)) (cdr nums)\n                 nums\
    \ (cons (car num) (cons num sums)))]\n    )\n  ))\n", "  (let loop ((numbers numbers)\n\
    \             (max-list '())\n             (current 0))\n    (cond\n      ((empty?\
    \ numbers) max-list)\n      (else (loop (rest numbers)\n                  (cond\
    \ ((> current (car numbers)) (cons (car numbers) max-list))\n                \
    \        (else (loop (rest numbers)\n                                  (cons (car\
    \ numbers) max-list)\n                                  (+ current 1)))\n    \
    \                    (end (+ current 1))))))))\n", "  (let loop ((accumulator\
    \ 0)\n             (numbers '()))\n    (cond ((null? numbers)\n           (if\
    \ (< accumulator accumulator)\n              accumulator\n              (cons\
    \ accumulator numbers)))\n          ((< numbers (car numbers))\n           (loop\
    \ (car numbers)\n                 (cdr numbers)))\n          (else\n         \
    \  (loop (+ (car numbers) accumulator)\n                 (cdr numbers))))))\n",
  "  (define (helper numbers result sum)\n    (cond\n      [(empty? numbers) result]\n\
    \      [(> sum number) (helper numbers (cons result sum) sum)]\n      [else (helper\
    \ numbers (cons (first numbers) result) (+ sum (first numbers)))]))\n  (helper\
    \ (reverse numbers) '() 0))\n", "  (cond [(null? (rest numbers)) 0]\n        [else\
    \ (max (apply max numbers) (rolling_max (rest numbers))))]))\n", "  (let\n   \
    \ ([max #f]\n     (loop\n       (set! max (first numbers))\n       (set! numbers\
    \ (rest numbers))\n       (if (< max numbers)\n           (cons max numbers)\n\
    \           (loop\n             (set! max (first numbers))\n             (set!\
    \ numbers (rest numbers))))))))\n", "  (cond [(empty? numbers) empty]\n      \
    \  [(null? (rest numbers)) empty]\n        [else (cons (max (first numbers) (rolling_max\
    \ (rest numbers))) empty)]))\n", "  (let loop ((numbers (reverse numbers))\n \
    \            (max-so-far 0)\n             (max 0))\n    (cond\n      [(null? numbers)\
    \ (list max)]\n      [(<= (first numbers) max-so-far) max]\n      [else (loop\
    \ (rest numbers)\n                  (if (< (first numbers) max-so-far)\n     \
    \                 max-so-far\n                      (first numbers))\n       \
    \           (if (> (first numbers) max-so-far)\n                      max-so-far\n\
    \                      (first numbers))))]))\n", "  (define (rolling_max_helper\
    \ n current)\n    (if (< n max)\n        (if (< (+ current (first list)) max)\n\
    \            current\n          (rolling_max_helper (+ n 1) (+ current (first\
    \ list)))\n        )\n        (if (< (first list) (first list))\n            (append\
    \ current (first list))\n          (list current)\n        )\n      )\n    (rolling_max_helper\
    \ 1 0))\n  (define (rolling_max numbers)\n    (define (rolling_max_helper n current)\n\
    \      (if (< n max)\n        (if (< (+ current (first list)) max)\n         \
    \ current\n          (rolling_max_helper (+ n 1) (+ current (first list)))\n \
    \       )\n        (if (< (first list) (first list))\n          (append current\
    \ (first list))\n          (list current)\n        )\n      )\n    (rolling_max_helper\
    \ 1 0))\n  (if (null? numbers)\n      '()\n      (append (rolling_max_helper 1\
    \ (first numbers)) (rolling_max (rest numbers)))))\n", "  (let loop ((n numbers)\
    \ (m (first n)))\n    (if (null? n)\n        (list m)\n        (loop (rest n)\
    \ (max (first n) (first m))))))\n", "  (define (helper numbers)\n    (if (null?\
    \ numbers)\n        '()\n        (let ((head (car numbers))\n              (tail\
    \ (cdr numbers))\n              (max (car tail)))\n          (cons (if (> (car\
    \ numbers) max)\n                    (car numbers)\n                    max)\n\
    \                (helper (cdr numbers))))))\n  (helper numbers))\n", "  (if (null?\
    \ numbers)\n      '()\n      (append (rolling_max_helper (car numbers) (list (car\
    \ numbers)) (list (cdr numbers))) \n              (rolling_max (cdr numbers)))))\n",
  "  (cond ((null? numbers) '())\n        (else (max (car numbers) (rolling_max (cdr\
    \ numbers))))))\n", "  (let loop ((max-so-far nil) (remaining-list numbers))\n\
    \    (cond [(empty? remaining-list) max-so-far]\n          [(>= (first remaining-list)\
    \ max-so-far) (first remaining-list)]\n          [else (loop (first max-so-far)\
    \ (cons (first remaining-list) remaining-list))]))", "  (if (null? numbers)\n\
    \      '()\n      (let ((roll (reverse (rolling_max (rest numbers)))))\n     \
    \   (append (cond ((= 0 (length roll)) (reverse roll))\n                     ((null?\
    \ (car roll)) (car roll))\n                     (else (cons (max (car roll) (max\
    \ roll)))\n                            roll)))))) ; #lang racket\n", "  (let loop\
    \ ((numbers (reverse numbers)) (max-so-far #f)\n             (acc #t) (max-index\
    \ (length numbers)))\n    (if (null? numbers) acc\n      (loop (rest numbers)\n\
    \            (if (> max-so-far numbers)\n              max-so-far\n          \
    \    (if (< max-index 0)\n                  max-index\n                  (if (>=\
    \ max-index max-index)\n                      0\n                      (+ 1 (loop\
    \ (rest numbers) max-index (+ max-index 1)))\n                  )\n          \
    \    )\n           )\n      max-index\n      )\n    )\n  )\n</code>\n<|/ a |>\n\
    <| c |>\nThank you. Good idea. However I do not want to use lists. I need it in\
    \ pure functional style. Is there any other way? Like an auxiliary function?\n\
    <|/ c |>\n<| c |>\nThis was a great answer. My only suggestion is to use `letrec`\
    \ instead of `let`, which makes code more readable and easier to follow. Also,\
    \ there is no need for parentheses around the body of the `letrec`, it is enough\
    \ to write `(let loop ((numbers (rest numbers)) (max-so-far #f) (acc #t) (max-index\
    \ (length numbers)))...` and the `...` must be indented with a tab character.\n\
    <|/ c |>\n<| c |>\n: I agree. Also I find this style easier to write and read\
    \ than `(let ... (let ... (let ...))`, but that's just a matter of personal taste.\n\
    <|/ c |>\n<| c |>\nYes, I find it easier to read, too. But I still prefer `letrec`\
    \ over (nested) `let` statements, because they make it easier to refactor the\
    \ code to remove a nested function and replace it with a local `let` statement.\n\
    <|/ c |>\n<| c |>\n: I was thinking of using `letrec` but could not figure out\
    \ how to keep track of the `max-index`, so I added an explicit `#t`. Thanks for\
    \ the reminder.\n<|/ c |>\n<| a |>\nIn Racket, there's a very convenient function\
    \ named scanl that is intended to do exactly this:\n<code>", "  (cond [(null?\
    \ numbers) (list 0)]\n        [(cons? numbers) (rolling_max (rest numbers))]\n\
    \        [else (cons (max numbers (car numbers)) (rolling_max (rest numbers)))]))\n",
  "  (if (null? numbers)\n      '()\n      (let ([result (last numbers)])\n      \
    \  (if (equal? result 0)\n            (list 0)\n            (if (null? (rest numbers))\n\
    \                (list result)\n                (let ([new_result (max result\
    \ (first numbers))])\n                  (cons new_result (rolling_max (rest numbers))))))))\
    \ )\n", "  (if (null? numbers)\n      '()\n      (let ([max (car numbers)])\n\
    \        (rolling_max (cdr numbers) max))))\n", "  (let loop ((max-so-far #f)\
    \ (numbers numbers))\n    (cond ((null? numbers) numbers)\n          ((< max-so-far\
    \ #t) (cons (car numbers) (loop (cdr max-so-far) (cdr numbers))))\n          (else\
    \ (loop (cons (car numbers) max-so-far) (cdr numbers))))))\n", "  (if (empty?\
    \ numbers)\n      (list empty)\n      (let ((max-so-far (car numbers))\n     \
    \       (max-so-far-prev (car numbers))\n            (rolling-max-count 0))\n\
    \        (if (>= max-so-far max-so-far-prev)\n            (cons (car numbers)\
    \ (rolling-max-count (+ rolling-max-count 1)))\n            (let ((max-so-far-prev\
    \ (car numbers))\n                  (max-so-far (car numbers))\n             \
    \     (rolling-max-count 0))\n              (if (>= max-so-far max-so-far-prev)\n\
    \                  (cons (car numbers) (rolling-max-count (+ rolling-max-count\
    \ 1)))\n                  (rolling_max (cdr numbers))))))))", "  (define (rolling-max\
    \ max numbers)\n    (cond\n      [(empty? numbers) max]\n      [(> max numbers)\n\
    \       (rolling-max (car max) (cdr numbers))]\n      [else (rolling-max (car\
    \ max) numbers)]))\n  (rolling-max (car numbers) numbers))\n", "  (define (loop\
    \ numbers result)\n    (cond [(null? numbers) result]\n          [(<= (car numbers)\
    \ (car (last result))) (loop (cdr numbers) (cons (car (last result)) result))]\n\
    \          [else (loop (cdr numbers) result)]))\n  (loop (reverse numbers) '()))\n",
  "  (let loop ((numbers numbers)\n             (result '())\n             (index\
    \ 0)\n             (max '()))\n    (if (null? numbers)\n        result\n     \
    \   (let ((x (car numbers)))\n          (loop (cdr numbers)\n                (cons\
    \ (if (> (car numbers) max) max x) (cons x result))\n                (+ index\
    \ 1)\n                (if (> index 10) max '())))))))\n", "  (let loop ((numbers\
    \ numbers) (max #f) (cur 0))\n    (if (empty? numbers)\n        (list max)\n \
    \       (loop (rest numbers) max (+ (first numbers) cur)))))\n", "  (if (null?\
    \ numbers)\n      '()\n      (cons (max (rest numbers)) (rolling_max (rest numbers)))))\n",
  "  (let loop ((numbers numbers)\n             (max 0))\n    (if (null? numbers)\n\
    \        (cons max numbers)\n        (loop (cdr numbers)\n              (max (car\
    \ numbers)))))))\n", "  (if (empty? numbers)\n      '()\n      (append (max_in_slice\
    \ numbers)\n              (rolling_max (rest numbers)))))\n", "  (if (null? numbers)\n\
    \      (list numbers)\n      (let ([max (first numbers)])\n        (let ([nums\
    \ (rest numbers)])\n          (if (> (length nums) 1)\n              (rolling_max\
    \ (append (list max) (list nums))))\n          (if (> (length nums) 0)\n     \
    \         (append (list max) (rolling_max (append (list nums) (list max))))\n\
    \              (rolling_max (append (list max) (list nums))))))))\n</code>\n<|/\
    \ a dscore=0 |>\n<| c |>\nHi Nathan, thank you for answering. \nCould you please\
    \ explain the meaning of `(append (list max) (list nums))`? I mean, what does\
    \ `(list max)` do?\n<|/ c |>\n<| c |>\n`(append (list max) (list nums))` append\
    \ the maximum element and the list of numbers to the list of elements and `(list\
    \ max)` will create a list with just one element.\n<|/ c |>\n<| c |>\nBut when\
    \ I remove the `(list max)` part, I still get the same output?\n<|/ c |>\n<| c\
    \ |>\nI edited my answer to show an example without the `list max` part.\n<|/\
    \ c |>\n<| c |>\nHi Nathan, thank you for your explanation. \nWould you please\
    \ tell me why `(list max)` creates a list of one element?\n<|/ c |>\n<| a tags=racket,algorithm,scheme\
    \ |>\nIt is a little different from the other answers, but I think it gives the\
    \ correct answer for any list size n.\n<code>", "  (if (null? numbers) (list 0)\n\
    \      (if (null? (cdr numbers)) (list 0)\n          (let ((a (head numbers))\n\
    \                (b (rolling_max (cdr numbers))))\n            (if (> (car b)\
    \ a) a b))))) ;; (if (> (car b) a) a b))))\n", "  (cond\n    [(empty? numbers)\
    \ empty]\n    [(> head (maximum! numbers)) head]\n    [else (append! \n      \
    \        (maximum! numbers) \n              (rolling_max (rest numbers))))]))\n",
  "  (if (null? (cdr numbers))\n      (list (car numbers))\n      (let ((max (car\
    \ numbers)))\n        (if (> (car numbers) max)\n            (cons max numbers)\n\
    \            (cons max rolling_max (cdr numbers))))))\n", "  (cond\n    ((empty?\
    \ numbers) '())\n    ((= (length numbers) 1) numbers)\n    ((> (car numbers) (rolling_max\
    \ (cdr numbers)))\n     (rolling_max (cdr numbers)))\n    (else\n     (cons (car\
    \ numbers)\n           (rolling_max (cdr numbers))))))\n", "  (cond\n    [(empty?\
    \ numbers) 'empty]\n    [(> (first numbers) (first numbers)) (cons (first numbers)\
    \ (rolling_max (rest numbers)))]\n    [else (rolling_max (rest numbers))]))\n",
  "  (if (null? numbers)\n      '()\n      (cons (max (car numbers) (rolling_max (cdr\
    \ numbers))) numbers)))\n", "  (if (null? numbers)\n      '()\n      (let loop\
    \ ((remainders numbers)\n                 (max-so-far '())\n                 (max-so-far\
    \ max-so-far)\n                 (remainder-index 0))\n        (if (null? remainders)\n\
    \            (cons max-so-far max-so-far)\n            (loop (rest remainders)\n\
    \                  (cons max-so-far (car remainders))\n                  (+ remainder-index\
    \ (car remainders))\n                  (if (> (car remainders) max-so-far)\n \
    \                     remainder-index\n                      0)))\n        )))\n",
  "  (define (rolling start end acc)\n    (if (< start end)\n        (let ((val (numbers\
    \ (+ start end))))\n          (if (null? val)\n              acc\n           \
    \   (rolling (+ start 1) (+ end 1) (cons val (if (> end (length numbers)\n   \
    \                                               (cons val '())\n             \
    \                                     acc))))))\n    (reverse acc))\n\n  (rolling\
    \ 0 0 (reverse numbers)))\n", "  (cond [(null? numbers)\n         '()]\n     \
    \   [(<= (length numbers) 1)\n         (append (list-ref numbers 0)\n        \
    \         (rolling_max (subseq numbers 1)))]\n        [else\n         (if (> (list-ref\
    \ numbers 0) (list-ref numbers 1))\n             (append (list-ref numbers 0)\n\
    \                     (rolling_max (subseq numbers 1)))\n             (rolling_max\
    \ (subseq numbers 1)))]))\n", "  (let loop ((max-list '())\n             (current-number\
    \ (car numbers))\n             (index 1))\n    (if (< index length-of-list)\n\
    \        (loop (cons current-number (cdr max-list))\n              (if (>= current-number\
    \ (car max-list))\n                  (car max-list)\n                  (current-number))\n\
    \              (incf index))\n        (cons current-number (cdr max-list)))))\n\
    </code>\nAnd here is the sample function from Dr.Racket:\n<code>", "  (if (empty?\
    \ numbers)\n      '()\n      (cons (max numbers)\n            (rolling_max (rest\
    \ numbers)))))\n", "  (cond [(empty? numbers) (list -1)]\n        [(equal? (first\
    \ numbers) (first numbers)) (list (first numbers))]\n        [(< (first numbers)\
    \ (first numbers)) (rolling_max (rest numbers))]\n        [else (list (first numbers)\
    \ (first numbers) (first numbers))]))\n", "  (if (null? numbers)\n      '()\n\
    \      (append\n       (apply append\n            (map (lambda (n)\n         \
    \          (max-list n (rest numbers))))\n              numbers)))", "  (letrec\
    \ ((accumulating (lambda (numbers &optional (max '()))\n                     \
    \ (if (null? numbers)\n                          (list max)\n                \
    \          (let ((element (first numbers)))\n                            (cond\
    \ (> (+ element max) max) (cons max numbers)\n                               \
    \   :else (accumulating (rest numbers) max))))))\n    (accumulating numbers '()))) ",
  "  (cond\n    [(empty? numbers)\n     (error \"rolling_max: cannot rolling_max an\
    \ empty list\")\n     (list numbers]\n    [(null? (rest numbers))\n     (list\
    \ numbers]\n    [else\n     (let ([maximum (car numbers)])\n       (append (rolling_max\
    \ (rest numbers)) (list maximum))]))))\n", "  (letrec ((i 0))\n    (if (= i 0)\n\
    \        (list -1)\n        (let ((curr (car numbers)))\n          (cond ((> curr\
    \ i) (list curr))\n                ((< curr i) (list (car numbers))\n        \
    \                (rolling_max (cdr numbers))))))))\n", "  (cond\n    ((null? numbers)\
    \ '())\n    ((= (length numbers) 1) numbers)\n    ((= (first numbers) (last numbers))\
    \ (rolling_max (rest numbers)))\n    ((> (first numbers) (first numbers)) (rolling_max\
    \ (rest numbers)))\n    ((< (first numbers) (first numbers)) (rolling_max (rest\
    \ numbers)))))\n", "  (let ((rolling_max (list numbers)))\n    (let loop ((rolling_max\
    \ rolling_max) (remaining numbers))\n      (if (null? remaining)\n          rolling_max\n\
    \          (loop (cons (max (car remaining)) rolling_max) (cdr remaining)))))\n\
    \  rolling_max)\n</cell>\n<cell>", "  (cond\n    ((empty? numbers) '())\n    ((>\
    \ numbers (first numbers)) \n     (rolling_max (rest numbers)))\n    (else (cons\
    \ (first numbers) (rolling_max (rest numbers))))))\n", "  (cond ((null? numbers)\
    \ '())\n        ((null? (rest numbers)) numbers)\n        (else (rolling_max (tail\
    \ numbers)\n                      (max (first numbers)\n                     \
    \      (max numbers))))))\n", "  (define (rolling numbers k result)\n    (cond\n\
    \      [(= k 0) result]\n      [else (let ([max (first numbers)])\n          \
    \     (rolling (tail numbers) (k - 1) (cond [(> max result) (max result)] else\
    \ result)))]))\n  (rolling numbers #f #f))\n", "  (cond ((null? numbers) '())\n\
    \        ((null? (cdr numbers)) (car numbers))\n        (else (let ((max (car\
    \ numbers)))\n                   (if (< (car numbers) max)\n                 \
    \      (cons max (rolling_max (cdr numbers))) \n                       (cons max\
    \ (rolling_max (cdr numbers)))))))) ; <<<\n", "  (define (helper numbers count)\n\
    \    (if (= count 0)\n        numbers\n        (helper (cdr numbers) (sub1 count))\n\
    \        )\n      )\n  (helper numbers 0))\n", "  (let ((max-num (first numbers))\n\
    \        (max-list (rest numbers)))\n    (cond [(null? max-num) max-num]\n   \
    \       [else (cons max-num (rolling_max (remove (lambda (x) (> x max-num)) max-list)))]\n\
    )))\n", "  (if (empty? numbers)\n      '()\n      (let ((max-so-far (first numbers)))\n\
    \        (if (empty? (rest numbers))\n            (list max-so-far)\n        \
    \    (let ((others (rest numbers))\n                  (max-others (rolling_max\
    \ others))\n                  (max (first max-others)))\n              (cons max\
    \ max-others))))))\n</cell>\n<code language=ocaml-jupyter>", "  (define (rolling_max-helper\
    \ nums min max found)\n    (cond ((null? nums) (list found))\n          ((< max\
    \ nums) (rolling_max-helper (rest nums) num (cdr nums) (cons (car nums) found)))\n\
    \          ((< nums min) (rolling_max-helper (rest nums) min max (cons (car nums)\
    \ found)))\n          (else (rolling_max-helper (rest nums) num (cdr nums) found))))\n\
    \  (rolling_max-helper numbers 0 numbers (list 0)))\n", "  (let loop ((numbers\
    \ numbers)\n             (result '()))\n    (if (null? numbers)\n        result\n\
    \        (loop (cdr numbers)\n              (cons (car numbers)\n            \
    \        (cons (max (car numbers) (cdr numbers)) result))))))\n", "  (let loop\
    \ ((result #f)\n             (numbers '(#f (list #f (list #f (list #f (list #f\
    \ #f)))))) \n             (i 0) \n             (n (car numbers)))\n    (cond ((=\
    \ i n) (if (null? result) (list #f) result))\n          ((< (car numbers) result)\
    \ (loop (car numbers) (+ i 1) (cdr numbers)))\n          ((> (car numbers) result)\
    \ (loop result (+ i 1) (cdr numbers)))\n          (else (loop (car numbers) i\
    \ (cdr numbers))))\n    (reverse result)))\n", "  (if (null? numbers) '() (cons\n\
    \                      (max (first numbers) (rolling_max (rest numbers)))\n  \
    \                    (rolling_max (rest numbers)))))\n", "  (if (null? numbers)\n\
    \      '()\n      (append (map (lambda (num)\n                    (cond ((> num\
    \ 0) (if (> (cdr numbers) num) num 0))\n                          (else num)))\n\
    \                   (cdr numbers))\n              (rolling_max (cdr numbers)))))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
