name: HumanEval_102_choose_num
language: rkt
prompt: "#lang racket\n\n;; This function takes two positive numbers x and y and returns\
  \ the\n;; biggest even integer number that is in the range [x, y] inclusive. If\
  \ \n;; there's no such number, then the function should return -1.\n;; For example:\n\
  ;; >>> (choose_num 12 15)\n;; 14\n;; >>> (choose_num 13 12)\n;; -1\n(define (choose_num\
  \ x y)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate choose_num))\n\
  \    (check-equal? (candidate 12 15) 14)\n    (check-equal? (candidate 13 12) -1)\n\
  \    (check-equal? (candidate 33 12354) 12354)\n    (check-equal? (candidate 5234\
  \ 5233) -1)\n    (check-equal? (candidate 6 29) 28)\n    (check-equal? (candidate\
  \ 27 10) -1)\n    (check-equal? (candidate 7 7) -1)\n    (check-equal? (candidate\
  \ 546 546) 546)\n))\n\n(test-humaneval)"
completions: ["  (if (<x y) (max-even-number (+ x y 2) (- x y)) -1))\n", "  (cond\
    \ [(< (expt x 2) (expt y 2))\n         (expt (expt x 2) (expt y 2))]\n       \
    \ [(= x y)\n         -1]\n        [else\n         (expt (expt x 2) (expt y 2))]))\n",
  "  (if (and (number? x) (number? y))\n      (if (= x y)\n          (modulo x 2)\n\
    \          (modulo y 2))\n      (if (= x 2)\n          (modulo x 4)\n        \
    \  (modulo y 4))\n      (if (= x 3)\n          (modulo x 6)\n          (modulo\
    \ y 6))\n      (if (= x 4)\n          (modulo x 8)\n          (modulo y 8))\n\
    \      (if (= x 5)\n          (modulo x 10)\n          (modulo y 10))\n      (if\
    \ (= x 6)\n          (modulo x 12)\n          (modulo y 12))\n      (if (= x 7)\n\
    \          (modulo x 14)\n          (modulo y 14))\n      (if (= x 8)\n      \
    \    (modulo x 16)\n          (modulo y 16))\n      (if (= x 9)\n          (modulo\
    \ x 18)\n          (modulo y 18))\n      (if (= x 10)\n          (modulo x 20)\n\
    \          (modulo y 20))\n      (if (= x 11)\n          (modulo x 22)\n     \
    \     (modulo y 22))\n      (if (= x 12)\n          (modulo x 24)\n          (modulo\
    \ y 24))\n      (if (= x 13)\n          (modulo x 26)\n          (modulo y 26))\n\
    \      (if (= x 14)\n          (modulo x 28)\n          (modulo y 28))\n     \
    \ (if (= x 15)\n          (modulo x 30)\n          (modulo y 30))\n      (if (=\
    \ x 16)\n          (modulo x 32)\n          (modulo y 32))\n      (if (= x 17)\n\
    \          (modulo x 34)\n          (modulo y 34))\n      (if (= x 18)\n     \
    \     (modulo x 36)\n          (modulo y 36))\n      (if (= x 19)\n          (modulo\
    \ x 38)\n          (modulo y 38))\n      (if (= x 20)\n          (modulo x 40)\n\
    \          (modulo y 40))\n      (if (= x 21)\n          (modulo x 42)\n     \
    \     (modulo y 42))\n      (if (= x 22)\n          (modulo x 44)\n          (modulo\
    \ y 44))\n      (if (= x 23)\n          (modulo x 46)\n          (modulo y 46))\n\
    \      (if (= x 24)\n          (modulo x 48)\n          ", "  (cond ((or (< x\
    \ y) \n              (< y x))\n         -1)\n        ((even? y)\n         (min\
    \ x (max y x)))\n        (else (min x (choose_num (+ x 1) y))))) ; Recursion\n",
  "  (cond ((> x y) -1)\n        ((even? x) (even? (- x y)))\n        (else (choose_num\
    \ (- x y) y))))", "  (cond\n    [(zero? x) -1]\n    [(zero? y) -1]\n    [(even?\
    \ (modulo x y)) (cond \n                          [(even? (modulo x y)) (choose_num\
    \ x y)]\n                          [else (cond \n                            \
    \       [(> (modulo x y) 0) (choose_num x y)]\n                              \
    \     [else (choose_num y x)])])]\n    [else (choose_num x (- y 1))]))\n</code>\n\
    This works perfectly on Racket - it even prints the correct answer when given\
    \ two out of bounds numbers.\nBut now it's my turn to turn to see what happens\
    \ in JavaScript and Haskell. After reading about JS numbers and floating point,\
    \ I decided that I should first write a small Haskell program to print out all\
    \ the numbers from 1 to 1000 and then compare the outputs from my Haskell program\
    \ and JS program. \nSo I wrote my Haskell program (prints out the numbers from\
    \ 1 to 1000 inclusive):\n<code>\nmodule Main (main) where\n\nmain :: IO ()\nmain\
    \ = print . map show $ [1..1000]\n</code>\nAfter compiling it with ghc -o choose_num\
    \ -O2 choose_num.hs, I ran the JS program:\n<code>\nfor (var i = 1; i <= 1000;\
    \ i++) {\n  console.log(i);\n}\n</code>\nBut it only prints out a bunch of dots.\
    \ \nSo I decided to try it with Haskell:\n<code>\nimport Prelude hiding (map)\n\
    \nmain :: IO ()\nmain = print . map show $ [1..1000]\n</code>\nAgain, after compiling\
    \ it with ghc -o choose_num -O2 choose_num.hs, I ran the JS program:\n<code>\n\
    for (var i = 1; i <= 1000; i++) {\n  console.log(i);\n}\n</code>\nBut it still\
    \ only printed out dots. \nSo I decided to try it in JavaScript:\n<code>\nfor\
    \ (var i = 1; i <= 1000; i++) {\n  console.log(i);\n}\n</code>\nBut it printed\
    \ out all the numbers, so I checked the Haskell program and found out that it\
    \ only printed out dots. So I thought to test it again with Haskell:\n<code>\n\
    module Main (main) where\n\nmain :: IO ()\nmain = print . map show $ [1..1000]\n\
    </code>\nAnd it worked!\nSo what am I doing wrong with Haskell? What am I not\
    \ seeing? Why are the numbers not being printed out when I run it in Haskell?\n\
    <|/", "  (cond [(< x y)  -1]\n        [(= x y) x]\n        [(even? x) (max (+\
    \ (* 2 x) (* 2 y)) (choose_num (+ x 1) y))]))\n", "  (let ((minx (min x y)) \n\
    \        (maxx (max x y)))\n    (cond ((> minx maxx) -1)\n          ((= minx maxx)\
    \ (if (even? (expt x 2)) (expt x 2) x))\n          (else (choose_num (expt minx\
    \ 2) maxx))))\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\nThis problem is related\
    \ to number theory. There are two ways to solve this problem: using a formula\
    \ (like choose_num) or using a computer algebra system (like Z3, Mathematica,\
    \ etc.).\nFormula\nA formula, like choose_num, is pretty simple. Let us denote\
    \ our initial numbers as A and B, where A <= B. Let us denote the desired numbers\
    \ as X and Y. Here are some definitions about the ranges of A and B (from Wikipedia):\n\
    \nA natural number greater than or equal to zero\nA natural number less than or\
    \ equal to zero\nA natural number greater than or equal to half the natural number\
    \ less than or equal to zero\nA natural number less than or equal to half the\
    \ natural number less than or equal to zero\nA positive integer greater than or\
    \ equal to zero\nA positive integer less than or equal to zero\nA positive integer\
    \ greater than or equal to half the positive integer less than or equal to zero\n\
    A positive integer less than or equal to half the positive integer less than or\
    \ equal to zero\nA natural number less than or equal to half the natural number\
    \ less than or equal to zero\nA natural number less than or equal to half the\
    \ natural number less than or equal to zero\nA positive integer less than or equal\
    \ to zero\nA positive integer less than or equal to zero\nA positive integer greater\
    \ than or equal to half the positive integer less than or equal to zero\nA positive\
    \ integer greater than or equal to half the positive integer less than or equal\
    \ to zero\nA natural number less than or equal to half the natural number less\
    \ than or equal to zero\nA natural number less than or equal to half the natural\
    \ number less than or equal to zero\nA positive integer less than or equal to\
    \ zero\nA positive integer less than or equal to zero\nA positive integer greater\
    \ than or equal to half the positive integer less than or equal to zero\nA positive\
    \ integer greater than or equal to half the positive integer less than or equal\
    \ to zero\nA natural number greater than or equal to half the natural number less\
    \ than or equal to zero\nA natural number greater than or equal to half the natural\
    \ number less than or equal to zero\nA positive integer greater than or equal\
    \ to zero\nA positive integer greater than or equal to zero\nA positive integer\
    \ greater than or equal to half the positive integer less than or equal to zero\n\
    A positive integer greater than or equal to half the positive integer less than\
    \ or equal to zero\nA natural number greater than or ", "  (cond\n    [(zero?\
    \ y)\n     (if (= (modulo x 2) 0)\n         (- x)\n         -1)]\n    [(zero?\
    \ x)\n     (if (= (modulo y 2) 0)\n         (- y)\n         -1)]\n    [else\n\
    \     (if (and (<= x y) \n             (< x y))\n         (modulo x 2)\n     \
    \    (modulo y 2))]\n    [else\n     (if (and (<= y x) \n             (< y x))\n\
    \         (modulo y 2)\n         (modulo x 2))]\n    [else -1]))\n", "  (cond\
    \ [(< x y) (error \"Cannot choose number out of range [\" x \",\" y \"]\")]\n\
    \        [(even? (mod (+ x y) 2))\n         (cond [(equal? (mod (+ x y) 2) 0)\
    \ (- x 1)]\n               [(equal? (mod (+ x y) 2) 1) (- x 2)]\n            \
    \   [(equal? (mod (+ x y) 2) 2) (- x 3)]\n               [else (- x 4)]))]\n \
    \       [else -1]))\n", "  (cond\n    [(or (= x y) 0)\n     -1]\n    [(and (even?\
    \ (- x y)) (even? (+ x y)))\n     (* x (/ x 2))]\n    [else\n     (max x y)]))\n\
    </code>\n<|/ a tags=racket,scheme |>\n<| c |>\nAh yes, the second example is more\
    \ like it. I was trying to avoid the recursion. Good solution though!\n<|/ c |>\n\
    <| c |>\nI agree, my second example is much easier to read!  You might also want\
    \ to have a look at [this answer](http://stackoverflow.com/questions/15598257/the-list-of-all-the-numbers-between-two-values-in-racket/15598561#15598561).\n\
    <|/ c |>\n<| a tags=racket,scheme dscore=0 |>\n<code>", "  (cond\n    [(> x y)\
    \ -1]\n    [(and (>= x 0) (< y 0)) 0]\n    [(< y 0) (+ x 0)]\n    [else (max (floor\
    \ (/ (- x y) 2) 2) (floor y 0))]))\n", "  (if (or (= x y) (- (+ x y) x))\n   \
    \   (- x)\n      (if (= (modulo x 2) 0)\n          (/ x 2)\n          (/ x 2)))\n\
    \  -1)\n", "  (cond\n    [(<= x y) x]\n    [(= (even? x) y) (even? x)]\n    [else\
    \ (choose x y)]\n  )\n)\n", "  (cond\n    ((< x y) -1)\n    ((= x y) 0)\n    ((even?\
    \ x) (min (even? x) (max x y)))\n    (else (choose_num (min x y) (max x y))))\n\
    )\n", "  (cond [(< x y) -1]\n        [else (let ([num (floor x)]\n           \
    \          [y (floor y)]\n                     [small (+ x y)])\n            \
    \  (cond\n               [(= num 0)\n                (cond\n                 [(=\
    \ x y)\n                  (begin\n                   (set! x (+ x num))\n    \
    \               (set! y (+ y num))\n                   (cond\n               \
    \     [else\n                     (begin (set! x small) (set! y small) num)]\n\
    \                   )]))]\n               [(= (mod num 2) 0)\n               \
    \ (cond\n                 [(= x y)\n                  (begin\n               \
    \    (set! x (+ x num))\n                   (set! y (+ y num))\n             \
    \      (cond\n                    [else\n                     (begin (set! x small)\
    \ (set! y small) num)]\n                   )]))]\n               [(< x y)\n  \
    \              (begin (set! x small) (set! y small) num)]\n               [else\n\
    \                (begin (set! x small) (set! y small) num)]))])]))\n", "  (cond\n\
    \    [(and (integer? x) (integer? y)) (max x y)]\n    [(and (integer? x) (odd?\
    \ y)) (max x y-1)] \n    [(and (odd? x) (integer? y)) (max x-1 y)]\n    [(and\
    \ (odd? x) (odd? y)) (max x-1 y-1)] \n    [#t (error \"Unknown case\")]))\n",
  "  (cond ((>= x y) -1)\n        ((even? y) y)\n        ((even? (- x y)) (- x y))\n\
    \        (else (+ x y))))\n", "  (cond [(= y x) (+ x y)]\n        [(= (mod x y)\
    \ 0)\n         (min x y)]\n        [else -1]))\n", "  (cond\n    [(or (>= x y)\
    \ (->= y x)) -1]\n    [(= x y) x])\n  )\n", "  (cond\n    [(<= x y) -1]\n    [(even?\
    \ (* x y))\n     (if (even? (+ x y))\n         (/ x y)\n         (+ x y))]\n \
    \   [else\n     (if (even? (+ x y))\n         (/ x y)\n         (+ x y))]\n  \
    \  [else\n     (if (even? (+ x y))\n         (/ x y)\n         (+ x y))]))\n",
  "  (cond [(> x y) (-1) (modulo x 2)]\n        [(zero? x) (-1) (modulo x 2)]\n  \
    \      [(zero? y) (-1) (modulo y 2)]\n        [(< x y) (-1) (modulo y 2)]\n  \
    \      [else (modulo x 2)]))\n", "  (cond [(< (abs (- x y)) (abs x))\n       \
    \  (- x 1)]\n        [(< y (abs (- x y)))\n         (- y 1)]\n        [else\n\
    \         (min (quotient x 2)\n               (quotient y 2))]))\n", "  (cond\
    \ [(or (= x y) (- (+ x y) (/ x 2)))\n         (if (= x y)\n             (+ x y)\n\
    \             (- x y))\n         ]\n        [else\n         (if (< x y)\n    \
    \         (if (= (* x 2) (* y 2))\n                 (* x 2)\n                \
    \ (if (= (* y 2) (* x 2))\n                     (* x 2)\n                    \
    \ (if (= (* x 3) (* y 2))\n                         (* x 3)\n                \
    \         (if (= (* y 3) (* x 3))\n                             (* y 3)\n    \
    \                         -1))))\n             (if (= (* x 2) (* y 3))\n     \
    \            (* x 2)\n                 (if (= (* y 2) (* x 3))\n             \
    \        (* x 3)\n                     (if (= (* x 3) (* y 3))\n             \
    \            (* y 3)\n                         -1))))\n         ]\n        )\n\
    \  )\n)", "  (cond [(= x y)  x]\n        [(even? (remainder x y))  (choose_num\
    \ (+ x y) y)]\n        [else  -1]))\n", "  (cond [(or (< x y) x) (-1))]\n    \
    \    [(even? x) (* x 2)\n         (odd? x) (+ x 2)\n         #t]))\n", "  (cond\
    \ [(= x y) -1]\n        [(and (integer? (rem x 2)) (integer? (rem y 2)))\n   \
    \      (expt (expt x 2) (expt y 2))]\n        [(and (integer? (rem x 3)) (integer?\
    \ (rem y 3)))\n         (expt (expt x 3) (expt y 3))]\n        [else (error \"\
    Choose-num only works with integers!\")]))", "  (cond [(= x y)               \
    \    (- 1)]\n        [(even? (modulo x 2) (modulo y 2))\n         (max (modulo\
    \ x 2) (modulo y 2))]\n        [else                         (choose_num x (-\
    \ y))]))\n", "  (cond [(< x y) -1 (< y x) -1]\n        [(< x y) y (choose_num\
    \ (+ x 1) y)]\n        [else (choose_num (+ x 1) (+ y 1))]))\n", "  (if (< (+\
    \ x y) y) -1\n      (if (> (+ x y) y) y\n          (let ((x (quotient x 2))\n\
    \                (y (quotient y 2)))\n            (if (even? x)\n            \
    \    (if (even? y)\n                    (if (even? (+ x y))\n                \
    \        (+ x y)\n                      (if (even? (+ y x))\n                \
    \          (+ y x)\n                        (+ (+ x y) y))\n                 \
    \ (if (even? (+ y x))\n                      (+ y x)\n                    (if\
    \ (even? (+ x y))\n                        (+ x y)\n                      (if\
    \ (even? (+ x y))\n                          (+ x y)\n                       \
    \ (if (even? (+ x y))\n                            (+ x y)\n                 \
    \         -1))))))))\n", "  (cond ((or (<= x y)\n             (= x y))\n     \
    \    x)\n        ((odd? (modulo x y))\n         (choose_num (+ x 1) y))\n    \
    \    (else\n         (choose_num (+ x 1) y))))\n", "  (cond [(= x y) x]\n    \
    \    [(= x 0) -1]\n        [(= y 0) -1]\n        [(< x y) -1]\n        [else (max\
    \ (- x y)\n                  (/ x (+ x y)))]))\n", "  (cond\n    [(and (>= x y)\
    \ \n           (even? x))\n     (max x y)]\n    [(and (>= x y)\n           (even?\
    \ y))\n     (max x y)])\n  )\n", "  (cond ((< x y)\n         (if (even? (modulo\
    \ x y))\n             (modulo x y)))\n        (else (if (even? (modulo y x))\n\
    \                  (modulo y x))\n                -1)))\n", "  (cond [(>= x y)\
    \ -1]\n        [else (cond [(= (modulo x 2) 0)\n                     (= (modulo\
    \ y 2) 0)\n                     (= (modulo (+ x y) 2) 0)\n                   \
    \  (= (modulo (+ x y) 3) 0)]\n                   [else (max (+ x y) (remainder\
    \ (- x y) 2))]))])\n", "  (cond\n    [(or (= x y) (= y 0)) -1]\n    [else (if\
    \ (even? (modulo x 2)) (modulo x 2)\n              (if (even? (modulo y 2)) (modulo\
    \ y 2)))]))\n", "  (cond ((< x y) (-1))\n        (#t (let ((x (mod x 2)))\n  \
    \             (if (even? x)\n                   (+ x y)\n                   (choose_num\
    \ x (+ y 1))))))))\n", "  (if (= x y)\n      -1\n      (if (even? (- x y))\n \
    \         (- x y)\n          (- y x))\n      )\n    )\n  )\n", "  (cond\n    [(<\
    \ x y) -1]\n    [(< y 0) -1]\n    [(and (even? (* x y)) (even? (- x y)))\n   \
    \  (/ x y)]\n    [else (max (+ x y) -1)]))", "  (if (> x y)\n      -1\n      (cond\
    \ ((even? x)\n             (cond ((> x y) x)\n                   (else y))\n \
    \             ((even? y)\n             (cond ((> x y) y)\n                   (else\
    \ x)))\n              (else\n             (max (max (max (max x y) y)) (max (max\
    \ y x)))))))\n</code>\n<|/ a tags=racket,scheme dscore=1 |>\n<| c |>\nCan you\
    \ explain why you chose a cond for max instead of just using min and max?\n<|/\
    \ c |>\n<| c |>\nBecause the problem definition said so, and because I think min/max\
    \ are simpler. Imagine that the numbers are in an array and there are two elements.\
    \ Then min and max would work much better. Another way to look at it is that min\
    \ would always return the smallest number and the max would always return the\
    \ largest number. Choosing a concrete implementation is more important than whether\
    \ you choose max/min or min/max because if your numbers don't fit into memory/CPU\
    \ cache then min/max won't work anyways.\n<|/ c |>\n<| c |>\nI see. I guess I\
    \ just thought they would be equivalent since you're not using the number you're\
    \ looking at in your conditional. But I guess its more about what to do when your\
    \ number is less than x or greater than y. Thanks again.\n<|/ c |>\n<| c |>\n\
    The \"problem\" says that there is no such number in the range. So the problem\
    \ definition says that you must find the \"smallest\" number which is >= x and\
    \ <= y. Since your function must return -1 if there is no such number, the smallest\
    \ number is >= x so you use max. Your function will always return the same value\
    \ no matter what numbers you're putting into the function, so you don't need min/max.\n\
    <|/ c |>\n<| c |>\nSorry, I actually meant min and max instead of min/max which\
    \ I misread and I should have said (min x y). My mistake. Thanks for the explanation.\n\
    <|/ c |>\n<| a dscore=1 tags=racket,scheme |>\nThe way I would go about it is\
    \ to define a helper function which checks whether or not the arguments are in\
    \ the range [a,b]. It does this by checking whether a > b and b <= a and throwing\
    \ an error. This function can be named isInRange. You then need to write a cond\
    \ that handles all the possible cases. To keep things simple, I'll just check\
    \ if the two arguments are in the range first, then return the max of them. If\
    \ the two arguments are out of range, then we know they must be even.\n<code>",
  "  (cond\n    [(zero? x) (if (zero? y) -1 -1)]\n    [(zero? y) (if (zero? x) -1\
    \ -1)]\n    [(even? (/ x 2)) (if (zero? y) -1 -1)]\n    [(even? (/ y 2)) (if (zero?\
    \ x) -1 -1)]\n    [else (if (even? (/ x 2)) (if (even? (/ y 2)) (+ (/ x 2) (/\
    \ y 2)) -1\n                             (if (even? (/ x 2)) -1 -1))]))))\n</code>\n\
    <|/ a |>\n<| c |>\nYou might add some explanation to your answer.\n<|/ c |>\n\
    <| c |>\nHi, I added comments on each line. Thanks!\n<|/ c |>\n<| a dscore=1 |>\n\
    This was a homework question and I guess I'm feeling too cheesy for not giving\
    \ out the answer but nonetheless:\nThe code below uses only basic arithmetic.\
    \ No loops, no recursive functions.\n<code>", "  (cond\n    ((> (- x y) 0) -1)\n\
    \    ((= x y) (if (even? (- x y)) (- x y) (+ x y)))\n    (else (choose_num (+\
    \ x 1) y))))\n", "  (cond\n    [(> (remainder x 2) 0)   ; x is odd\n     (cond\
    \ \n       [(even? (remainder x 2))\n        (choose_num (+ x 1) y)]\n       [else\
    \ (choose_num (+ x 1) y)])]\n    [(= x y)\n     (* x x)]\n    [else -1]))\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nA simpler solution would be to use the modulo operator\
    \ in place of quotient and remainder, which will eliminate the need for the conds.\
    \ However, this solution avoids all the conditionals entirely, so it's a bit more\
    \ terse.\n<|/ c |>\n<| a tags=lisp,common-lisp |>\n<code>", "  (cond\n    ((and\
    \ (< x y) 0) -1)\n    ((and (= x y) 0) -1)\n    ((= (mod x 2) 0) (max (+ x y)\
    \ -1))\n    ((= (mod x 2) 1) (max (+ x y) 0))\n    ((= (mod x 2) -1) (max (+ x\
    \ y) 1))\n    (else (max (+ x y) -1))))\n", "  (cond\n    ((> x y)\n     -1)\n\
    \    ((even? y)\n     y)\n    ((even? x)\n     (choose_num x (floor (/ x 2)))\n\
    \     (choose_num (+ x 1) y))\n    (else\n     (choose_num (+ x 1) y))))\n", " \
    \ (cond [(> x y)\n         (-1)]\n        [(= (rem x 2) 0)\n         (+ x (rem\
    \ y 2))]\n        [else\n         (+ x (choose_num (rem x 2) (rem y 2)))]))\n",
  "  (cond ((or (< x y) (- (length x) (length y)))\n         (- -1 -1))\n        ((=\
    \ (modulo x 2) 0)\n         (- 1 (modulo y 2)))\n        ((= (modulo x 2) 1)\n\
    \         (choose_num (+ x 2) y))\n        (else\n         (choose_num (+ x 1)\
    \ (+ y 1)))))\n</code>\n<|/ a tags=racket,sieve |>\n<| c |>\nNice solution! I\
    \ guess the efficiency is quadratic though. How do you solve this more efficiently?\n\
    <|/ c |>\n<| a |>\nHere's a solution using Racket's higher order functions:\n\
    <code>\n#lang racket", "  (cond [(= x y)\n         (if (even? x)\n           \
    \  (- x (- x y)) (- x))\n         -1)]\n        [else\n         (if (even? (-\
    \ x y))\n             (- x (- x y)) (- x))]))\n", "  (cond\n    ((> x y) -1)\n\
    \    ((= x y) x)\n    ((even? x) (min (+ x 1) y))\n    (else (choose_num (+ x\
    \ 1) y))))\n", "  (cond [(= x y) (if (even? (+ x y)) x y)]\n        [(>= x y)\
    \ (if (even? (+ x y)) y x)]\n        [else (- x 1)]))\n", "  (cond\n    ((>= x\
    \ y) -1)\n    ((even? (* x x))\n     (let ((z (* x y)))\n       (cond\n      \
    \   ((even? (mod z 2)) (/ x 2))\n         (else z))))\n    (else (max x y))))\n",
  "  (cond ((< x y) -1)\n        ((even? (modulo x 2)) (modulo x 2))\n        ((even?\
    \ (modulo y 2)) (modulo y 2))\n        (else (choose_num (+ x 1) (+ y 1)))))\n",
  "  (cond ((or (< x y) (> x y)) -1)\n        ((= (modulo x 2) 0) (+ x y))\n     \
    \   (else -1)))\n", "  (if (= x y)\n      (cond ((and (even? x) (even? y))\n \
    \            (max (+ x y) x))\n            (else -1))\n      (choose_num (- x\
    \ 1) y)))\n</code>\n<|/ a dscore=0 |>\n<| a |>\nHere's another answer, for Racket\
    \ Scheme users with R6RS or R6RS Scheme (where #lang racket is available):\n<code>",
  "  (if (>= x y)\n      -1\n      (if (even? x)\n          (if (>= y x)\n       \
    \       x\n              (if (>= y y)\n                  y\n                 \
    \ (if (= x y)\n                      (error \"The two numbers do not divide evenly.\"\
    ))))\n          (if (= x y)\n              (error \"The two numbers do not divide\
    \ evenly.\"))))))\n</code>\n<|/ a tags=scheme,racket |>\n<| a |>\nMy two cents,\
    \ an implementation using lazy-integer-citerator:\n<code>", "  (cond [(zero? x)\n\
    \         -1]\n        [(zero? y)\n         -1]\n        [(odd? x) (if (even?\
    \ y) x y)]\n        [(even? x) (if (odd? y) x y)]\n        [else (max (choose_num\
    \ x (- x y)) (choose_num (- y x) (- x y)))]))\n", "  (cond\n    ((> x y) (-1))\n\
    \    ((= x y) (expt x 2))\n    ((even? x) (expt x 2))\n    ((even? y) (expt y\
    \ 2))\n    ((= (expt x 2) (expt y 2)) (expt (expt x 2) 2))\n    (else (expt (expt\
    \ x 2) 2))))\n", "  (cond ((or (<= x y) (= x y)) -1)\n        ((= (modulo x 2)\
    \ 0) (* x 3))\n        ((= (modulo y 2) 0) (* y 3))\n        ((= x y) 0)\n   \
    \     ((= y y) 0)\n        (else (max x y))))\n", "  (cond\n    [(= x y) x]\n\
    \    [(= (mod x 2) 0) (/ x 2)\n     (choose_num (/ x 2) (/ y 2))]\n    [else (cond\
    \ [(= (mod x 2) 0) (+ x y)]\n               [(not (= (mod x 2) 0)) (-1)])]))\n",
  "  (cond\n    [(< x y) -1]\n    [(< y 0) -1]\n    [(< x y) x]\n    [(< y 0) y]))\n",
  "  (if (< x y)\n      (cond ((and (= x y) (even? x))\n             x)\n        \
    \    ((and (= x y) (even? y))\n             y)\n            (else\n          \
    \   (let ((temp (choose_num x (- y 1))))\n               (cond ((= temp 0) -1)\n\
    \                     ((= temp y) temp) \n                     ((even? (remainder\
    \ x temp)) temp)\n                     (else -1))))))\n", "  (let ((res (if (>\
    \ x y)\n                (if (= (mod x 2) 0)\n                    (if (= x y)\n\
    \                        (/ x 2)\n                      (if (= y x)\n        \
    \                  (/ x 1)\n                        (/ x 2)))\n              \
    \      (if (= x y)\n                        (/ x 1)\n                      (/\
    \ x 2)))\n                (/ x 2))))\n    (if (= (rem1 res) 0)\n        (if (=\
    \ x y)\n            (/ x 2)\n          (/ x 1))\n      res)))\n", "  (cond [(and\
    \ (integer? x) (integer? y))\n         (max x y)]\n        [(and (integer? x)\
    \ (not (integer? y)))\n         x]\n        [(and (not (integer? x)) (integer?\
    \ y))\n         y]\n        [(and (not (integer? x)) (not (integer? y)))\n   \
    \      (min x y)]\n        [else\n         -1\n         ]))\n", "  (cond [(= x\
    \ y)            ; x must be less than or equal to y\n         x              \
    \         ; Return the value of x itself, if x\n         ]\n        [(even? (remainder\
    \ x y))  ; x must be an even number and y must be \n                         \
    \       ;; greater than or equal to x\n         (recur (+ x 1) (+ y 1))]; otherwise\
    \ recur on x + 1 and y\n        [else                   ; x must be an odd number\n\
    \         (if (> (remainder y x) y)\n           (recur (+ x 1) y)\n          \
    \ (recur x (+ y 1))]))) \n", "  (cond ((< x y) -1)\n        ((even? y) (cond ((<\
    \ y x) x)\n                          (else y)))\n        (else (choose_num (+\
    \ x 1) y))))\n", "  (cond ((> (+ x y) y) -1)\n        ((even? x) (+ x y))\n  \
    \      (else (choose_num (+ x y) y))))\n", "  (cond ((> x y) (error (format \"\
    choose_num: x must be less than y\")))\n        ((< x 0) (error (format \"choose_num:\
    \ x must be greater than 0\")))\n        ((< y 0) (error (format \"choose_num:\
    \ y must be greater than 0\")))\n        (else (if (even? (expt x 2))\n      \
    \            (if (>= y 0)\n                      (expt (+ x y) 2)\n          \
    \            (expt y 2))\n                  -1))))\n", "  (cond [(< x y) (error\
    \ \"[choose_num] x must be higher than y!\")\n         (and (even? (modulo x y))\n\
    \              (even? (modulo y x)))\n         (modulo x y)]\n        [(< x y)\
    \ (error \"[choose_num] x must be higher than y!\")\n         (= x y) (error \"\
    [choose_num] x and y can't be equal!\")\n         (= (modulo x y) 0)\n       \
    \  (even? (modulo x y))\n         (even? (modulo y x))\n         (+ x y)]\n  \
    \      [(= x y) (error \"[choose_num] x and y can't be equal!\")\n         (even?\
    \ (modulo x y))\n         (even? (modulo y x))\n         (- x y)]\n        [(even?\
    \ (modulo x y))\n         (even? (modulo y x))\n         (= (modulo x y) 0)\n\
    \         (even? (modulo x y))\n         (even? (modulo y x))\n         (- x y)]\n\
    \        [(even? (modulo x y))\n         (even? (modulo y x))\n         (even?\
    \ (modulo x y))\n         (even? (modulo y x))\n         (+ x y)]\n        [else\
    \ (error \"[choose_num] There's no even number in range [x, y]!\")]))\n", "  (if\
    \ (= y x)\n      -1\n      (floor (/ (+ (* x y) y) 2) (floor y 2))))\n", "  (if\
    \ (or (< x y) (- (- y x) (* 2 (abs x))) (- (- x y) (* 2 (abs y)))) -1 \n    (cond\
    \ ((<= x y)  (- x y)) \n          ((< y x)  (- y x))\n          (t (max (abs x)\
    \ (abs y))) )))\n", "  (cond [(< x y) -1]\n        [(< y x) -1]\n        [(even?\
    \ x) x]\n        [(even? y) y]\n        [else (choose_num (+ x 2) (+ y 2))]))\n",
  "  (cond ((< x y) (-1))\n        ((= x y) x)\n        ((even? (modulo x 2)) (cons\
    \ x (choose_num (+ x 2) y)))\n        (else (choose_num (+ x 1) y))))\n", "  (cond\
    \ [(< x y) -1]\n        [(even? x) (+ x 2)]\n        [(even? y) (+ y 2)]\n   \
    \     [else (cond [(even? (choose_num x (- y 1))) (+ x 2)]\n                 \
    \ [(even? (choose_num y (- x 1))) (+ y 2)])]))\n", "  (cond ((= x y) -1)\n   \
    \     ((= (mod x 2) (mod y 2)) -1)\n        (else x)))\n", "  (cond ((= x y) -1)\n\
    \        ((even? x) (even? (+ x y)))\n        (else (choose_num (+ x y) y))))\n",
  "  (cond [(= x y) x]\n        [(even? x) (* x 2)]\n        [(even? y) -1]))\n",
  "  (cond ((= x y) -1)\n        ((even? x) (+ x y))\n        (else (choose_num (+\
    \ x 2) y))))\n", "  (cond ((= x y) (if (even? x) (+ x y) (- x y)))\n        ((even?\
    \ x) (if (> y x) x y))\n        (else -1)))\n", "  (cond ((= y x) -1)\n      \
    \  ((even? (modulo x y)) (choose_num (quotient x y) y))\n        (else (choose_num\
    \ (quotient x y) y))))\n", "  (cond\n    [(= y 0) -1]\n    [(and (<= x y)\n  \
    \        (odd? (car x)))\n      (if (even? (car x))\n          (choose_num (car\
    \ x) (- y 1))\n          (choose_num (car x) (- y 1)))]\n    [else (if (even?\
    \ (car x))\n              (choose_num (car x) (- y 1))\n              (choose_num\
    \ (car x) (- y 1)))]))\n", "  (if (or (< x y) (- (expt x 2) (- (expt y 2))))\n\
    \      (- x)\n      (max x y)))\n", "  (cond\n    ((> x y) -1)\n    ((= x y) (+\
    \ x y)))\n  )\n)\n", "  (cond ((>= x y) (-1))\n        ((even? x) (even? y) (+\
    \ x y))\n        (else (- x (+ x y)))))\n", "  (cond [(< x y) -1]\n        [(=\
    \ x y) x]\n        [(even? x) x]\n        [else (max x (choose_num (+ x 1) y))]))\n",
  "  (cond [(= x y)\n         x]\n        [(= (mod x 2) 0)\n         (* x 2)]\n  \
    \      [(= (mod x 2) 1)\n         (* x 3)]))\n", "  (if (or (zero? x) (zero? y))\n\
    \      (- -1)\n      (let ((b (floor x)))\n        (if (< b y)\n            (let\
    \ ((n (floor (- x y))))\n              (if (even? n)\n                  n\n  \
    \                (if (> n y)\n                      -1\n                     \
    \ (if (< n b)\n                          (* b y)\n                          -1))))\n\
    \            (* b y)))\n      -1\n      )))\n", "  (cond ((>= x y) -1)\n     \
    \   ((even? x) (+ x y))\n        (else (choose_num (+ x 1) y))))\n", "  (let ([min\
    \ (min x y)]\n        [max (max x y)]\n        [even-num (quotient min 2)])\n\
    \    (cond [(< min max) -1]\n          [(= even-num 0)\n           (sub (- even-num\
    \ (quotient max 2)) even-num)]\n          [(= even-num 1)\n           (- even-num\
    \ (quotient max 2))]\n          [else even-num])))\n", "  (cond\n    [(> x y)\n\
    \     (cond\n       [(even? (+ x y))\n        (+ x y)]\n       [else\n       \
    \ -1])]\n    [(even? (+ x y))\n     (+ x y)]\n    [else\n     -1]))\n", "  (if\
    \ (even? y)\n      (max x y)\n      -1))\n", "  (cond [(> x y) -1]\n        [(even?\
    \ x) (max (min x y) x)]\n        [else (choose_num (+ x 1) y)]))\n", "  (cond\
    \ ((> x y) -1)\n        ((even? (rem x 2)) x)\n        (else (choose_num (+ x\
    \ 1) y))))\n", "  (cond ((and (integer? x) \n               (> x y)) \n      \
    \   x)\n        ((and (integer? y) \n               (> y x)) \n         y)\n \
    \       (else -1)))\n", "  (cond ((>= x y) (-1))\n        ((even? x) (even? (-\
    \ x y))\n        ((even? y) x (even? (- y x))))))\n", "  (cond ((< (abs (- x y))\
    \ 2)\n         x)\n        (else \n         (cond ((< x y)\n                (set!\
    \ x (+ x y))\n                (set! y (- x y)))\n               (else \n     \
    \           (set! x (- x y)\n                        y (- x y))\n            \
    \    (set! x (+ x y))\n                (set! y (- x y)))))))\n", "  (cond [(and\
    \ (> x y)\n               (< x 0))\n         -1]\n        [(= y 0)\n         -1]\n\
    \        [(even? (modulo x y))\n         (modulo x y)]\n        [else\n      \
    \   (choose_num (+ x 1) (- y 1))]))\n", "  (cond\n    [(and (<= x y) \n      \
    \     (not (even? (- x y))))\n     x]\n    [(and (<= y x) \n           (not (even?\
    \ (- y x))))\n     y]\n    [else -1]))\n", "  (cond ((and (< x y) (not (even?\
    \ x))) (- y x))\n        (else (if (= x y)\n                  (- y x)\n      \
    \            (- y (- (- x y) (- x y))))))))", "  (cond ((< x y) -1)\n        ((even?\
    \ x) (if (< x y) x (+ y 1)))\n        (else (if (< x y) x (choose_num x (- y 1))))))\n",
  "  (cond [(>= x y) -1]\n        [(even? x) (max x y)]\n        [else (choose_num\
    \ (+ x 1) y)]))\n", "  (let ((xm (modulo x 2)))\n    (cond\n      [(= x y)   \
    \       x]\n      [(= xm 0)         y]\n      [(= xm 1)         (+ x y)]\n   \
    \   [(= xm -1)        (+ y x)]\n      [else             (+ x y)]))) \n", "  (cond\n\
    \    [(= x y) y]\n    [(= x 0) -1]\n    [(and (even? (- x 1))\n         (even?\
    \ (- y 1)))\n      (- x (- y 1))]\n    [else (- x (- y 1))]))\n", "  (cond\n \
    \   ((< (+ x y) y) -1)\n    ((eq? (mod-2 x) (mod-2 y)) (mod-2 x))\n    ((< (mod-2\
    \ x) (mod-2 y)) (mod-2 x))\n    ((eq? (mod-2 x) (mod-2 y)) (mod-2 x))\n    ((>\
    \ (+ x y) y) -1)\n    ((eq? (mod-2 x) (mod-2 y)) (mod-2 x))\n    ((> (mod-2 x)\
    \ (mod-2 y)) (mod-2 x))\n    ((eq? (mod-2 x) (mod-2 y)) (mod-2 x))\n    ((> (+\
    \ x y) y) -1)\n    ((eq? (mod-2 x) (mod-2 y)) (mod-2 x))\n    ((eq? (mod-2 x)\
    \ (mod-2 y)) (mod-2 x))\n    ((eq? (mod-2 x) (mod-2 y)) (mod-2 x))\n    ((eq?\
    \ (mod-2 x) (mod-2 y)) (mod-2 x))\n    ((eq? (mod-2 x) (mod-2 y)) (mod-2 x))\n\
    \    ((eq? (mod-2 x) (mod-2 y)) (mod-2 x))\n    ((eq? (mod-2 x) (mod-2 y)) (mod-2\
    \ x))\n    ((eq? (mod-2 x) (mod-2 y)) (mod-2 x))\n    ((eq? (mod-2 x) (mod-2 y))\
    \ (mod-2 x))\n    ((eq? (mod-2 x) (mod-2 y)) (mod-2 x))\n    ((eq? (mod-2 x) (mod-2\
    \ y)) (mod-2 x))\n    ((eq? (mod-2 x) (mod-2 y)) (mod-2 x))\n    ((eq? (mod-2\
    \ x) (mod-2 y)) (mod-2 x))\n    ((eq? (mod-2 x) (mod-2 y)) (mod-2 x))\n    ((eq?\
    \ (mod-2 x) (mod-2 y)) (mod-2 x))\n    ((eq? (mod-2 x) (mod-2 y)) (mod-2 x))\n\
    \    ((eq? (mod-2 x) (mod-2 y)) (mod-2 x))\n    ((eq? (mod-2 x) (mod-2 y)) (mod-2\
    \ x))\n    ((eq? (mod-2 x) (mod-2 y)) (mod-2 x))\n    ((eq? (mod-2 x) (mod-2 y",
  "  (cond\n    [(>= x y) -1]\n    [(even? (modulo x 2)) (even? (modulo x 2)) (modulo\
    \ x 2)]\n    [else (modulo x 2)]))\n", "  (if (or (< x y) (- (length nums) y))\n\
    \      -1\n      (let ([nums (append nums [x y])])\n        (if (or (= x (mod\
    \ y 2))\n                (= y (mod x 2)))\n            (- (length nums) 1)\n \
    \           (let ([m1 (first nums)\n                   m2 (second nums)])\n  \
    \            (cond\n                [(= m1 m2)\n                 (+ m1 m2)\n \
    \               ]\n                [else (choose_num (quotient m1 m2)\n      \
    \                         quotient m2\n                               )\n    \
    \            ]\n              )\n            )\n        )\n      )\n    )\n  )\n",
  "  (cond ((> x y) -1)\n        ((even? (modulo x 2)) x)\n        (else (choose_num\
    \ (+ x 1) y))))\n", "  (cond\n    [(even? x) (cons x y)] \n    [(even? y) (cons\
    \ x y)] \n    [(< x y) -1]\n    [(< y x) -1]\n    [else (cons x y)]\n  ))", " \
    \ (cond ((> x y) -1)\n        ((even? (remainder x y)) (remainder x y))\n    \
    \    (t (choose_num (+ x 1) (+ y 1)))))\n", "  (cond\n    ((and (number? x) (number?\
    \ y)) \n     (if (= (modulo x y) 0) x y))\n    ((or (number? x) (number? y)) -1)\n\
    \    (else (error \"Both numbers must be positive numbers\"))))\n</code>\n<|/\
    \ a dscore=2 tags=racket,scheme |>\n<| c |>\nNice solution, however it fails to\
    \ handle negative numbers. I would change the condition to: (= (modulo x y) 0)\n\
    <|/ c |>\n<| c |>\n-AngelaMonica good catch, I'll add a disclaimer on the answer.\n\
    <|/ c |>\n<| c |>\nHi all. I'm new to racket and this solution is great for me.\
    \ I'm trying to understand the code. Where can I read more about it? I tried to\
    \ google but I couldn't find an explanation. Thanks!\n<|/ c |>\n<| a dscore=2\
    \ |>\nStill not sure if this is the most efficient solution but this works. I\
    \ tested this with Racket 8.2.\n<code>", "  (cond ((< x y) -1)\n        ((even?\
    \ x) (+ x y))\n        (else (choose_num (+ x y) y))))\n", "  (cond ((< x y) (-1))\n\
    \        ((even? x) (max ((- x) y) (- y)))\n        ((even? y) (max ((- y) x)\
    \ (- x)))\n        (else (max (choose_num (- x) y) (choose_num (- y) x))))\n",
  "  (cond ((or (>= x y)\n             (even? x))\n         (if (= x y)\n        \
    \     x\n             (- y (+ x (/ 2 x))))\n         (if (even? y)\n         \
    \    (- y x)\n             -1)))\n", "  (cond\n    [(< x y) (if (= (even? x) 0)\
    \ (- x) -1)]\n    [else (if (= (even? y) 0) (- y) -1)]\n    [else (+ (floor (/\
    \ (- x y) (* 2 x)) 2))]))\n", "  (cond\n    ((>= x y) (* -1 -1))\n    ((= (+ x\
    \ y) 0) (* -1 -1))\n    ((odd? (+ x y))\n     (let ((x (+ x y)))\n       (cond\n\
    \         ((odd? (+ x y)) x)\n         (else (choose_num (+ x y) y)))))\n    ((even?\
    \ (+ x y))\n     (cond\n       ((odd? (+ x y)) x)\n       ((even? (+ x y)) (choose_num\
    \ x (+ x y)))))))\n", "  (cond ((or (< x y) (- (- x y) y))\n         (if (even?\
    \ (- x y))\n             (- x (- x y))\n             -1))\n        (else\n   \
    \      (if (even? (- y x))\n             (- y (- x y))\n             -1))))\n",
  "  (cond ((or (= x y) (- (- x y) y) (- (- y x) x))\n         (if (< x y) -1 x))\n\
    \        ((and (= x y)\n              (= (modulo x 2) 1))\n         (if (< y x)\
    \ -1 y))\n        (else\n         (if (and (< x y) (= (modulo x 2) 1))\n     \
    \        (- x)\n             (- y))))\n</code>\nThis was written in Racket, so\
    \ the solutions aren't as pretty, but you can convert them to Lisp as you see\
    \ fit.\n<|/ a tags=scheme,racket |>\n<| a |>\nHere is another way to solve the\
    \ problem\n<code>", "  (if (< x y) \n      (* 2 y)\n      (if (< x 2)\n      \
    \    (* y 2)\n          -1)))\n", "  (if (>= x y)\n      (if (= (remainder x 2)\
    \ 0)\n          (remainder x 2)\n          (-1))\n      (if (= (remainder y 2)\
    \ 0)\n          (remainder y 2)\n          (-1))))\n", "  (if (or (< x y)\n  \
    \        (= x y))\n      -1\n      (if (= (modulo x 2)\n            (modulo y\
    \ 2))\n          x\n          (if (= (modulo x 2)\n                 (modulo y\
    \ 2))\n              -1\n              (if (= (modulo y 2)\n                 \
    \    (modulo x 2))\n                   -1\n                  (if (= (modulo x\
    \ 2)\n                          (modulo y 2))\n                    -1\n      \
    \              (if (= (modulo y 2)\n                          (modulo x 2))\n\
    \                    -1\n                    (if (= (modulo x 2)\n           \
    \               (modulo y 2))\n                    -1\n                    (if\
    \ (= (modulo y 2)\n                          (modulo x 2))\n                 \
    \   -1\n                    (if (= (modulo x 2)\n                          (modulo\
    \ y 2))\n                    -1\n                    (if (= (modulo y 2)\n   \
    \                       (modulo x 2))\n                    -1\n              \
    \      (if (= (modulo x 2)\n                          (modulo y 2))\n        \
    \            -1\n                    (if (= (modulo y 2)\n                   \
    \       (modulo x 2))\n                    -1\n                    (if (= (modulo\
    \ x 2)\n                          (modulo y 2))\n                    -1\n    \
    \                (if (= (modulo y 2)\n                          (modulo x 2))\n\
    \                    -1\n                    (if (= (modulo x 2)\n           \
    \               (modulo y 2))\n                    -1\n                    (if\
    \ (= (modulo y 2)\n                          (modulo x 2))\n                 \
    \   -1\n                    (if (= (modulo x 2)\n                          (modulo\
    \ y 2))\n                    -1\n                    (if (= (modulo y 2)\n   \
    \                       (modulo x 2))\n                    -1\n              \
    \      (if (= (modulo x 2)\n                          (modulo y 2))\n        \
    \            -1\n                    (if (= (modulo y 2)\n                   \
    \       (modulo x 2))\n                    -1\n                    (if (= (modulo\
    \ x 2)\n                          (modulo y 2))\n                    -1\n    \
    \                (if (= (modulo y 2)\n                          (modulo x 2))\n\
    \                    -1\n                    (if (= (modulo x 2)\n           \
    \               (modulo y 2))\n                    -1\n                    (if\
    \ (= (modulo y 2)\n                          (modulo x 2))\n                 \
    \   -1\n                    (if (= (modulo x 2)\n                          (modulo\
    \ y 2))\n                    -1\n                    (if (= (modulo y 2)\n   \
    \                       (modulo x 2))\n                    -1\n              \
    \      (if (= (modulo x 2)\n                          (modulo y 2))\n        \
    \            -1\n                    (if (", "  (cond [(>= x y) -1]\n        [(=\
    \ (mod x 2) 0) (+ (- x y) y)]\n        [else (+ x y)]))\n", "  (let loop ([n y]\
    \ [m x] [min (floor (/ (- n y) 2))] [max y])\n    (cond\n      [(= n 1) min]\n\
    \      [(= m 0) max]\n      [else (loop (- n m) (- n m) (min (+ m (floor (/ (-\
    \ n m) 2))) min) (max max))]))) ; nm <= max\n", "  (cond\n    ((and (> x y) (<\
    \ x 0)) (-1 (modulo (- (floor x 2) (- (floor x y) 2)) 2)))\n    ((and (> y x)\
    \ (< y 0)) (-1 (modulo (- (floor y 2) (- (floor x y) 2)) 2)))\n    ((and (> x\
    \ y) (< x y)) (-1 (modulo (- (floor (floor x 2) (- (floor x y) 2)) 2) 2)))\n \
    \   ((and (> y x) (< y x)) (-1 (modulo (- (floor (floor y 2) (- (floor x y) 2))\
    \ 2) 2)))\n    (else (modulo (- (floor x 2) (- (floor x y) 2)) 2)))\n  )\n", " \
    \ (cond\n    [(and (positive? x) (positive? y)) \n      ;; If the numbers aren't\
    \ both positive, return -1 immediately.\n      (if (> x y)\n          -1\n   \
    \       ;; If they're equal, just return the biggest of the two.\n          (if\
    \ (>= (- x) (- y))\n              x\n              (- y)))]\n    [else\n     \
    \ ;; If x is negative, then return the smallest even number\n      ;; that is\
    \ a multiple of y.\n      (if (negative? x)\n          (even? y)\n          (-\
    \ y))]\n    [else\n      ;; If y is negative, then return the smallest even number\n\
    \      ;; that is a multiple of x.\n      (if (negative? y)\n          (even?\
    \ x)\n          (x-or-y x))]))\n", "  (if (or (<= x y) (- (- x y) 2))\n      -1\n\
    \      (even-odd? x y)))\n", "  (cond\n    ((= x y) y)\n    ((= x 0) 1)\n    ((<\
    \ x y) \n      (if (even? (modulo x 2)) x -1)))\n    (else -1)))\n", "  (cond\
    \ ((= x y) (* -1 x))\n        ((= x y) (* y y))\n        ((= x y) (* x y))\n \
    \       (else -1)))\n", "  (if (or (= x y) (= x 0))\n      -1\n      (if (even?\
    \ (* x y))\n          (even? (* x y))\n          (if (<= x y)\n              (even?\
    \ (+ x y))\n              (choose_num (+ x 1) (+ y 1))))))\n", "  (cond [(< x\
    \ y) -1]\n        [(= x y) x]\n        [else (+ x (choose_num (+ x 1) y))]\n \
    \       ))\n", "  (if (> x y)\n      (if (= (modulo x 2) 0)\n          x\n   \
    \       (choose_num (quotient x 2) y)))\n  (if (> y x)\n      -1\n      (if (=\
    \ (modulo y 2) 0)\n          y\n          (choose_num (quotient y 2) x))))\n",
  "  (cond\n    [(or (< x y) (-< x y)) -1]\n    [(or (< y x) (-< y x)) -1]\n    [else\n\
    \     (if (and (odd? x) (odd? y)) (- x) (-y))]))\n", "  (cond\n    ((< x y) -1)\n\
    \    ((= x y) (/ x 2))\n    ((even? (modulo x 2))\n     (even? (modulo x y))\n\
    \     (even? (/ x 2))\n     (even? (/ x y)))\n    (else (choose_num (+ x 1) y))))\n",
  "  (cond\n    [(>= x y) y]\n    [(= x 0) -1]\n    [(even? (modulo x 2))\n     (if\
    \ (< y x)\n         (* y 2)\n         (* x 2))]\n    [else (choose_num (sub1 x)\
    \ (sub1 y))]))\n", "  (cond ((< x y) (-1))\n        ((even? (modulo x 2)) (cons\
    \ (modulo x 2) (choose_num (+ x 1) y)))\n        (else (choose_num (+ x 1) y))))\n",
  "  (cond ((= y x) (if (even? x) (/ x 2) -1))\n        (else (if (>= x y) (+ (- x)\
    \ 1) (if (< x y) -1 0)))))\n", "  (cond\n    ((< (- x y) 0) -1)\n    ((even? x)\
    \ (* 2 x))\n    ((even? y) (- (* 2 y) x))\n    (else (choose_num (+ x 1) y))))\n",
  "  (if (= y x)\n      -1\n      (if (= (modulo x 2) 0)\n          (modulo x 2)\n\
    \          (max (quotient x 2) (quotient y 2)))))\n", "  (cond\n    [(and (>=\
    \ x y) \n          (even? x)) x]\n    [(and (>= y x) \n          (even? y)) y]\n\
    \    [else -1]))\n", "  (cond ((or (< x y) (- (- x y) y) (- (- y x) x)) -1)\n\
    \        (else (cond ((= (modulo x 2) (modulo y 2)) (+ x y)) \n              \
    \    ((= (modulo y 2) (modulo x 2)) (+ y x))\n                  (else (cond ((<\
    \ x y) (choose_num (+ x 1) y)) \n                            ((< y x) (choose_num\
    \ (+ y 1) x))\n                            ((< x y) (choose_num (+ x 1) y))\n\
    \                            ((< y x) (choose_num (+ y 1) x))\n              \
    \              ((= (modulo x 2) (modulo y 2)) (+ x y))\n                     \
    \       ((= (modulo y 2) (modulo x 2)) (+ y x))\n                            ((=\
    \ (modulo x 2) (modulo y 2)) (+ x y))\n                            ((= (modulo\
    \ y 2) (modulo x 2)) (+ x y))))))\n", "  (cond [(< x y) -1]\n        [else (cond\
    \ [(= (floor (/ (* x y) 2)) 0) -1]\n                  [else (+ x (floor x))]))]))\n",
  "  (cond\n    ((< (- x y) y) -1)\n    ((= (mod x y) 0) 0)\n    ((= (mod x y) 1)\n\
    \     (if (< (+ x y) y) -1)\n       (if (< x y) x)\n       (if (< x y) y)))))\n",
  "  (cond [(< x y) -1]\n        [(even? x) x]\n        [(even? y) y]\n        [else\
    \ (choose_num (+ x 2) (+ y 1))]))\n", "  (cond [(and (positive? x) \n        \
    \       (positive? y))\n         (if (even? x)\n             (quotient x y)\n\
    \             -1)\n         ]\n        [else (choose_num (+ x 1) y)]))\n", " \
    \ (cond ((and (<= x y) (not (= x y)))\n         (if (= (modulo x 2) 0) (- x y)\
    \ -1))\n        (else\n         (if (= (modulo y 2) 0)\n             (- y x)\n\
    \             -1))))\n</code>\n<|/ a tags=lisp,racket,scheme |>\n<| c |>\nthank\
    \ you, very interesting way to solve this problem. I've been trying to get this\
    \ solved for a few hours now but no luck until now.\n<|/ c |>\n<| a dscore=0 |>\n\
    You want to find the smallest even number between x and y, right? Then the problem\
    \ is as follows: \n<code>", "  (cond\n    [(> x y) (error (cons \"x must not be\
    \ greater than y\" x y))] \n    [(even? (modulo x 2)) (cons x (choose_num (+ x\
    \ 2) y))]\n    [else (error (cons \"x must be positive and smaller than y\" x\
    \ y))]))\n", "  (cond ((< x y) -1)\n        ((even? x) x)\n        (else (choose_num\
    \ (+ x 1) y))))\n", "  (cond\n    [(< x y) -1]\n    [(< (quotient x y) 2)\n  \
    \   (choose_num (quotient x y) y)\n     ]\n    [else x]\n   ))\n", "  (cond [(<\
    \ x y) -1]\n        [(even? x (modulo y x 2))\n         (modulo y x 2)]\n    \
    \    [else (choose_num (+ x 1) y)]))\n", "  (cond\n    ((and (not (< x y)) (not\
    \ (< y 0))) (- y 1))\n    ((and (not (= x y)) (not (= y 0))) -1)\n    ((and (<=\
    \ x 0) (< y 0)) (- x 1))\n    ((and (<= y 0) (< x 0)) (- y 1))\n    ((and (< x\
    \ 0) (< y 0)) (- x 1))\n    ((and (< y 0) (< x 0)) (- y 1))\n    ((= (mod x y)\
    \ 0) (- y 1))\n    (else (- x 1))\n  )\n)", "  (cond ((or (= x y) \n         \
    \    (= x 0))\n         -1)\n        ((even? x)\n         (cond ((> x y) -1)\n\
    \              ((= x y) x)\n              (else (choose_num (+ x 1) y)))\n   \
    \     ((even? y)\n         (cond ((< y x) -1)\n              ((= y x) y)\n   \
    \           (else (choose_num (+ x 1) y)))\n        (else\n         (cond ((<\
    \ x y) -1)\n              ((= x y) x)\n              (else (choose_num (+ x 1)\
    \ y))))))\n", "  (cond [(= x y) (* y y)] \n        [(even? x) (* x x)]\n     \
    \   [else -1]))\n", "  (cond [(zero? (- x y)) -1]\n        [(even? (- x y)) (-\
    \ x y)]\n        [else (- x y)]))\n", "  (cond ((<= x y) -1)\n        ((even?\
    \ x) (even? y))\n        (else (add1 x) (add1 y))\n        (else -1)))\n", " \
    \ (cond ((<= x y) -1)\n        ((even? x) (even? y))\n        (else (max (floor\
    \ (/ x y)) (floor (/ y x)))))\n  )\n", "  (let loop ((x x) (y y))\n    (if (=\
    \ x y)\n        x\n        (if (even? x)\n            (* x 2)\n            (loop\
    \ (+ x 1) (- x 1))))))\n", "  (cond\n    [(<= x y) y]\n    [else (if (even? (modulo\
    \ x y))\n               (modulo x y)\n               (choose_num (+ x 1) y))]))\n",
  "  (cond [(= x y) -1]\n        [(and (even? x) \n               (even? (- x y)))\n\
    \         (max (+ (min x y) \n                 (- x y))\n               (- x y))]\n\
    \        [else (choose_num (+ x 1) y)]))\n", "  (if (> (abs x) (- (abs y) 1))\
    \ -1\n      (* x (/ (abs x) 2))))\n", "  (cond\n    [(> x y) -1]\n    [(= (modulo\
    \ x y) 0) (if (even? (modulo x y)) (modulo x y) -1)]\n    [else (cons (modulo\
    \ x y) -1)]))\n", "  (cond [(= x y) x]\n        [(even? (* x y)) (* x y)]\n  \
    \      [else -1]))\n", "  (cond [(< x y) x]\n        [(and (< y x)\n         \
    \      (= (modulo x y) 0))\n         (+ x 1)]\n        [else\n         (- y 1)]))\n",
  "  (cond ((<= x y) -1)\n        ((even? x) x)\n        (else (choose_num (+ x 1)\
    \ y))))\n</code>\nNow that we have the code for the function above it's time to\
    \ try to implement the function you just wrote: choose_num. Let's start with the\
    \ base case:\n<code>", "  (if (or (< x y) (-? x y))\n      -1\n      (let ((x\
    \ (- x 2))) (if (< y x) (* x 2) x)))\n  ", "  (cond\n    [(and (integer? x) (integer?\
    \ y)) (cond [(even? (- x y)) x] [else y])]\n    [else -1]\n    )\n  )\n</code>\n\
    And this is how you can use it:\n<code>", "  (cond\n    [(= x y) x]\n    [(and\
    \ (even? (- x y)) (< x y)) x]\n    [else (- x y)]))\n", "  (if (or (< x y) \n\t\
    \   (< y x))\n      -1\n      (if (even? (modulo x 2))\n\t   (modulo x 2)\n\t\
    \   (modulo x 2)))\n  (choose_num y x))\n", "  (cond [(= x y) x]\n        [(=\
    \ (modulo x 2) 0) (if (< x y) (- x (+ y 1)) -1)]\n        [else (- x)]))\n", " \
    \ (cond\n    ((null? x) #f)\n    ((even? x) (cons x (choose_num (rest x) y)))\n\
    \    (else (choose_num (rest x) y))))\n", "  (cond ((< x y) -1)\n        ((even?\
    \ x) x)\n        ((< y (- x (+ x y))) -1)))\n", "  (cond [(< x y) -1]\n      \
    \  [else (max 0 (expt (- x y) 2))]))\n", "  (cond [(= x y) -1]\n        [(even?\
    \ x) (max (- x y) 2)]\n        [else (max (- x y) 2)]))\n", "  (cond\n    [(<\
    \ x y) -1]\n    [(and (even? (- x y)) (> x y)) (- x y)]\n    [else (max x y)]))\n",
  "  (cond\n    [(and (>= x y) (- (quotient x y) (quotient y 2)))\n     (quotient\
    \ x y)]\n    [(and (>= x y) (< y 2))\n     (- x y)]\n    [(and (< x 2) (< y 2))\n\
    \     (- x y)]\n    [(and (< x 2) (>= y 2))\n     (- x y)]))\n", "  (cond\n  \
    \  ((< x y) -1)\n    ((even? (/ x 2)) x)\n    (else (choose_num (+ x 1) y))))\n",
  "  (cond\n    ((= x y) -1)\n    ((even? (+ 2 y)) (cons x y))\n    (else (choose_num\
    \ (+ x 1) (+ y 1)))))\n", "  (cond [(< x y) -1]\n        [(and (integer? (/ x\
    \ 2)) (< x y))\n         (* x 2)\n         x]\n        [(and (integer? (/ y 2))\
    \ (< y y))\n         (* y 2)\n         y]\n        [else\n         (max (+ (/\
    \ x 2) (/ y 2))\n              (max (+ (/ y 2) (/ x 2))\n                    \
    \ (+ x y)))]))", "  (cond [(< (- x y) 0)\n         (-1)]\n        [(even? (modulo\
    \ x 2))\n         ((+ x (modulo x 2)) x)]\n        [else (choose_num (+ x 1) y)]))\n",
  "  (cond ((> x y) -1)\n        ((even? x) x)\n        ((even? y) y)\n        (else\
    \ (choose_num (+ x 2) (+ y 2)))))\n</cell>\n<cell>\n#lang racket\n", "  (cond\n\
    \    ((< x y) -1)\n    ((= x y) x)\n    ((= x y) y)\n    (else (max 0 (add1 (modulo\
    \ (sub1 y) x))))))\n</cell>\n<code language=racket-language>", "  (cond ((and\
    \ (>= x y) (< x y)) (- y))\n        (else x)))\n", "  (cond [(= (+ x y) 0)\n \
    \        -1]\n        [(= (mod x 2) 0)\n         (if (= (mod y 2) 0)\n       \
    \      (if (>= (+ x y) y)\n                 (* 2 y)\n                 (* y 2))\n\
    \             (* 2 x))\n         (* 2 x)]\n        [(= (mod y 2) 0)\n        \
    \ (if (>= (+ x y) y)\n             (* 2 x)\n             (* x 2))\n         (*\
    \ 2 y)]))\n", "  (cond\n    ((= x y) -1)\n    ((= x 0) 0)\n    ((= y 0) 0)\n \
    \   (else (max (even? x) (y) (even? y)))))\n", "  (if (or (> x y) (- (length x)\
    \ (length y))) (sub1 (- x y))\n    (let ((smallest (min x y)))\n      (if (zero?\
    \ smallest) -1\n        (if (even? (- smallest x y)) smallest\n          (choose_num\
    \ (- smallest x y) y))))))\n", "  (if (< (car lst) (cdr lst))\n      (append (car\
    \ lst) (choose_num (car lst) y))\n      (if (< (car lst) (cdr lst)) -1 (car lst))))\n",
  "  (if (< x y)\n      (max x y)\n      (if (even? y)\n          y\n          -1)))\n",
  "  (cond\n    [(= x y) -1]\n    [(= x 0) -1]\n    [(= y 0) -1]\n    [else (cond\
    \ \n            [(even? (remainder x 2)) x (recur (quotient x 2) y)]\n       \
    \     [(even? (remainder y 2)) y (cond \n                            [(even? (remainder\
    \ x 2)) (cons x (choose_num (quotient x 2) y)) (recur (quotient x 2) (quotient\
    \ y 2))]\n                            [(even? (remainder y 2)) (cons y (choose_num\
    \ (quotient y 2) x)) (recur (quotient y 2) (quotient x 2))])]\n            )]))\n",
  "  (cond\n    [(> (modulo x y) 0)\n     (if (even? x)\n         (+ (floor x) (floor\
    \ y)) (floor y))]\n    [(> (modulo y x) 0)\n     (if (even? y)\n         (+ (floor\
    \ y) (floor x)) (floor x))]\n    [else -1 (floor x) (floor y)]))\n", "  (cond\
    \ ((or (< x y) (< y x)) -1)\n        ((even? x) x)\n        (else (choose_num\
    \ (+ x 1) y))))\n", "  (if (= x y)\n      x\n      (if (= (modulo x 2) 0) \n \
    \         (- y)\n          (- x))\n      ))\n", "  (cond ((< x y) -1)\n      \
    \  ((even? x) (cons x y))\n        (else (choose_num (+ x 1) y))))\n", "  (if\
    \ (>= x y)\n      (if (and (number? x) (number? y))\n          (max (floor (+\
    \ x y))\n              (floor (+ y x)))\n          -1)\n      (if (and (number?\
    \ x) (number? y))\n          (max (floor (+ x y))\n              (floor (- x y)))\n\
    \          -1)))\n</code>\nI hope this will help, cheers!\n<|/ a |>\n<| c |>\n\
    Why not `(define (choose_num x y) (max (floor (+ x y)) (floor (- x y))))`?\n<|/\
    \ c |>\n<| c |>\nI guess in that case you don't need to check `x > y` because\
    \ if it's true `(max (floor (+ x y)) (floor (- x y)))` will always be bigger than\
    \ -1? Or am I wrong?\n<|/ c |>\n<| c |>\nThe `max` function doesn't check the\
    \ argument for being negative.\n<|/ c |>\n<| c |>\nI got that, but in my code\
    \ the biggest even number is returned in the case that x is bigger than y\n<|/\
    \ c |>\n<| c |>\nI know, but then `max` is called on positive and negative values\
    \ so the result will be the same.\n<|/ c |>\n<| a tags=racket,bignum,biginteger,functional-programming,scheme\
    \ |>\nHere is a simpler implementation of choose_num:\n<code>", "  (cond [(= x\
    \ y) -1\n         (= (even? (modulo-by-two? x y)) 1)\n         (even? x) x]\n\
    \        [else (choose_num (+ x 1) y)]))\n", "  (cond\n    ((= x y) (- x))\n \
    \   ((= x 0) (- x))\n    ((= y 0) (- y))\n    ((even? (- x y)) (- x))\n    ((odd?\
    \ (- x y)) (- y))\n    ((even? (- y x)) (- y))\n    ((odd? (- y x)) (- x))\n \
    \   ((even? (- x y)) (- x))\n    ((even? (- y x)) (- x))\n    ((odd? (- x y))\
    \ (- y))\n    ((odd? (- y x)) (- y))\n    ((even? (- x y)) (- x))\n    ((even?\
    \ (- y x)) (- x))\n    ((odd? (- x y)) (- y))\n    ((odd? (- y x)) (- y))\n  \
    \  ((even? (- x y)) (- x))\n    ((even? (- y x)) (- x))\n    ((odd? (- x y)) (-\
    \ y))\n    ((odd? (- y x)) (- y))\n    ((even? (- x y)) (- x))\n    ((even? (-\
    \ y x)) (- x))\n    ((odd? (- x y)) (- y))\n    ((odd? (- y x)) (- y)))\n  )\n\
    )\n", "  (if (< x y)\n      (* 2 choose_num (+ x y) y)\n      (- x y)))\n", " \
    \ (cond\n    ((zero? x) (if (zero? y) (error \"There is no even number between\
    \ x and y.\" -1)\n                   (error \"There is no even number between\
    \ x and y.\" -1)))\n    ((zero? y) (if (zero? x) (error \"There is no even number\
    \ between x and y.\" -1)\n                   (error \"There is no even number\
    \ between x and y.\" -1)))\n    ((= (modulo x 2) 0) (if (zero? y) (error \"There\
    \ is no even number between x and y.\" -1)\n                   (error \"There\
    \ is no even number between x and y.\" -1)))\n    ((= (modulo x 2) 0) (if (zero?\
    \ x) (error \"There is no even number between x and y.\" -1)\n               \
    \    (error \"There is no even number between x and y.\" -1)))\n    ((= (modulo\
    \ x 2) 0) (if (zero? y) (error \"There is no even number between x and y.\" -1)\n\
    \                   (error \"There is no even number between x and y.\" -1)))\n\
    \    ((= (modulo y 2) 0) (if (zero? x) (error \"There is no even number between\
    \ x and y.\" -1)\n                   (error \"There is no even number between\
    \ x and y.\" -1)))\n    ((= (modulo y 2) 0) (if (zero? y) (error \"There is no\
    \ even number between x and y.\" -1)\n                   (error \"There is no\
    \ even number between x and y.\" -1)))\n    (else (if (< y x) \n             \
    \  (if (= (modulo x 2) 0) \n                   (error \"There is no even number\
    \ between x and y.\" -1)\n                   (error \"There is no even number\
    \ between x and y.\" -1))\n               (if (= (modulo y 2) 0) \n          \
    \         (error \"There is no even number between x and y.\" -1)\n          \
    \         (error \"There is no even number between x and y.\" -1))))))\n</code>\n\
    <|/ a dscore=1 |>\n<| a dscore=0 tags=racket,lisp |>\nFor anyone who is looking\
    \ for a way to test whether an number is even, here is one that just checks the\
    \ mod of 2\n<code>", "  (cond ((and (<= x y) (- (quotient x y)) (< x y)) x)\n\
    \        ((and (= x y) (not (zero? x)))\n         x)\n        (else -1)))\n",
  "  (cond [(or (< x y)\n               (= x 0))\n         -1]\n        [(or (< y\
    \ x)\n               (= y 0))\n         (if (even? (- x y))\n             (- x\
    \ y)\n             (choose_num (- x y) (- y x)))]\n        [else\n         (if\
    \ (even? (- y x))\n             (- x y)\n             (choose_num (- x y) (- y\
    \ x)))]))\n", "  (cond\n    [(= x y) x]\n    [(even? (/ x 2)) (+ x 2)]\n    [else\
    \ -1]))\n", "  (cond ((> x y) -1)\n        ((even? x) (even? y)) (\n         \
    \   (if (>= x y) x y)))\n        ((odd? x) -1)))\n</code>\n<|/ a tags=lisp,functional-programming\
    \ |>\n<| a |>\nHere is one possible solution that uses the filter function.\n\
    <code>", "  (if (even? x)\n      (max (min x y) -1)\n      (min x y)))\n", " \
    \ (cond\n    [(<= x y) -1]\n    [(= x 0) 0]\n    [(even? x) x]\n    [else (+ x\
    \ (choose_num (- x 2) y))]))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
