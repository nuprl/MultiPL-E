name: HumanEval_154_cycpattern_check
language: rkt
prompt: "#lang racket\n\n;; You are given 2 words. You need to return #t if the second\
  \ word or any of its rotations is a substring in the first word\n;; >>> (cycpattern_check\
  \ \"abcd\" \"abd\")\n;; #f\n;; >>> (cycpattern_check \"hello\" \"ell\")\n;; #t\n\
  ;; >>> (cycpattern_check \"whassup\" \"psus\")\n;; #f\n;; >>> (cycpattern_check\
  \ \"abab\" \"baa\")\n;; #t\n;; >>> (cycpattern_check \"efef\" \"eeff\")\n;; #f\n\
  ;; >>> (cycpattern_check \"himenss\" \"simen\")\n;; #t\n(define (cycpattern_check\
  \ a b)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate cycpattern_check))\n\
  \    (check-equal? (candidate \"xyzw\" \"xyw\") #f)\n    (check-equal? (candidate\
  \ \"yello\" \"ell\") #t)\n    (check-equal? (candidate \"whattup\" \"ptut\") #f)\n\
  \    (check-equal? (candidate \"efef\" \"fee\") #t)\n    (check-equal? (candidate\
  \ \"abab\" \"aabb\") #f)\n    (check-equal? (candidate \"winemtt\" \"tinem\") #t)\n\
  ))\n\n(test-humaneval)"
completions: ["  (cond [(string=? a b) #t]\n        [(cons? a) (or (cycpattern_check\
    \ (first a) (last a)) (cycpattern_check (first b) (last b)))]\n        [else #f]))\n",
  "  (cond ((null? b)\n         (null? a))\n        ((equal? #\\( b (string-length\
    \ a)))\n         (eq? (char-at (string-length a) 0)\n              #\\( a (string-length\
    \ b))))\n        (else #t)))\n</code>\n<|/ a tags=racket,pattern-matching |>\n\
    <| c |>\nThat code is very nice, but I am having trouble compiling it.  I added\
    \ #!racket at the beginning of the program, but when I try running it I get the\
    \ following error: ```Error: module: \u2018racket/lang/typed/bytes/char-seq\u2019\
    \ does not contain any definition for \u2018bytes\u2019, undefined\n  modules/cycpattern.rkt:18:11:\
    \ module: undefined\n  modules/cycpattern.rkt:18:11: module: undefined```\n<|/\
    \ c |>\n<| c |>\nSorry, I should have been more specific in my description.  This\
    \ is for an assignment where I have to use #!racket and I am required to write\
    \ the code I showed above in #lang racket.  Thanks.\n<|/ c |>\n<| c |>\nI tested\
    \ the code with the `#!racket` at the top of the program, and I still get the\
    \ error.  Any ideas?\n<|/ c |>\n<| c |>\nI see it now, I was using #!racket/c\
    \ instead of #!racket.  It compiles now, thanks!\n<|/ c |>\n<| a dscore=1 |>\n\
    This problem can be solved using two sets of patterns, one for each of the words.\
    \ Since there are 26 characters in the alphabet, we can use 26 patterns. \n<code>",
  "  (cond\n    ((empty? b) #f)\n    ((equal? (string-ref a 0)\n              (string-ref\
    \ b 0))\n     (string-ref b 0)\n     (string-ref b 0)\n     (string-ref b 0)\n\
    \     (string-ref b 0)\n     (string-ref b 0)\n     (string-ref b 0)\n     (string-ref\
    \ b 0)\n     (string-ref b 0)\n     (string-ref b 0)\n     (string-ref b 0)\n\
    \     (string-ref b 0)\n     (string-ref b 0)\n     (string-ref b 0)\n     (string-ref\
    \ b 0)\n     (string-ref b 0)\n     (string-ref b 0)\n     (string-ref b 0)\n\
    \     (string-ref b 0)\n     (string-ref b 0)\n     (string-ref b 0)\n     (string-ref\
    \ b 0)\n     (string-ref b 0)\n     (string-ref b 0)\n     (string-ref b 0)\n\
    \     (string-ref b 0)\n     (string-ref b 0)\n     (string-ref b 0)\n     (string-ref\
    \ b 0)\n     (string-ref b 0)\n     (string-ref b 0)\n     (string-ref b 0)\n\
    \     (string-ref b 0)\n     (string-ref b 0)\n     (string-ref b 0)\n     (string-ref\
    \ b 0)\n     (string-ref b 0)\n     (string-ref b 0)\n     (string-ref b 0)\n\
    \     (string-ref b 0)\n     (string-ref b 0)\n     (string-ref b 0)\n     (string-ref\
    \ b 0)\n     (string-ref b 0)\n     (string-ref b 0)\n     (string-ref b 0)\n\
    \     (string-ref b 0)\n     (string-ref b 0)\n     (string-ref b 0)\n     (string-ref\
    \ b 0)\n     (string-ref b 0)\n     (string-ref b 0)\n     (string-ref b 0)\n\
    \     (string-ref b 0)\n     (string-ref b 0)\n     (string-ref b 0)\n     (string-ref\
    \ b 0)\n     (string-ref b 0)\n     (string-ref b 0)\n     (string-ref b 0)\n\
    \     (string-ref b 0)\n     (string-ref b 0)\n     (string-ref b 0)\n     (string-ref\
    \ b 0)\n     (string-ref b 0)\n     (string-ref b 0)\n     (string-ref b 0)\n\
    \     (string-ref b 0)\n     (string-ref b 0)\n     (string-ref b 0)\n     (string-ref\
    \ b 0)\n     (string-ref b 0)\n     (string-ref b 0)\n     (string-ref b 0)\n\
    \     (string-ref b 0)\n     (string-ref b 0)\n     (string-ref b 0)\n     (string-ref\
    \ b 0)\n     (string-ref b 0)\n     (string-ref b 0)\n     (string-ref b 0)\n\
    \     (string-ref b 0)\n     (", "  (or (string=? (string-ref a 0) (string-ref\
    \ b 0))\n      (loop for i from (length a - 1) downto 0\n            until (or\
    \ (string=? (string-ref a i) (string-ref b i))\n                    (or (string=?\
    \ (string-ref b i) (string-ref a i))\n                        (string=? (string-ref\
    \ a i) (substring b i))))))\n", "  (or (equal a b)\n      (substring a b #f)\n\
    \      (substring (substring a 0 #f)\n                   (substring (substring\
    \ a #f #f)\n                            #f #f)\n                   (substring\
    \ (substring a #f #f)\n                            (substring b 0 #f)\n      \
    \                      #f)\n                   (substring (substring a #f #f)\n\
    \                            (substring b (substring a 0 #f) #f)\n           \
    \                 #f)\n                   (substring (substring a #f #f)\n   \
    \                         (substring b #f #f)\n                            (substring\
    \ b #f #f)\n                            #f)\n                   (substring (substring\
    \ a #f #f)\n                            (substring b #f #f)\n                \
    \            (substring b (substring a 0 #f) #f)\n                           \
    \ #f)\n                   (substring (substring a #f #f)\n                   \
    \         (substring b #f #f)\n                            (substring b #f #f)\n\
    \                            (substring b #f #f)\n                           \
    \ #f)\n                   (substring (substring a #f #f)\n                   \
    \         (substring b #f #f)\n                            (substring b #f #f)\n\
    \                            (substring b #f #f)\n                           \
    \ (substring b #f #f)\n                            (substring b #f #f)\n     \
    \                       #f)\n                   (substring (substring a #f #f)\n\
    \                            (substring b #f #f)\n                           \
    \ (substring b #f #f)\n                            (substring b #f #f)\n     \
    \                       (substring b #f #f)\n                            (substring\
    \ b #f #f)\n                            (substring b #f #f)\n                \
    \            #f)\n                   (substring (substring a #f #f)\n        \
    \                    (substring b #f #f)\n                            (substring\
    \ b #f #f)\n                            (substring b #f #f)\n                \
    \            (substring b #f #f)\n                            (substring b #f\
    \ #f)\n                            (substring b #f #f)\n                     \
    \       (substring b #f #f)\n                            (substring b #f #f)\n\
    \                            (substring b #f #f)\n                           \
    \ (substring b #f #f)\n                            (substring b #f #f)\n     \
    \                       (substring b #f #f)\n                            (substring\
    \ b #f #f)\n                            #f)\n                   (sub", "  (cond\n\
    \    [(empty? b) #f]\n    [(equal? (first b) (first a)) #t]\n    [(equal? (first\
    \ b) (first (cycle\n                               (subseq b 1 -1)))) #t]\n  \
    \  [else\n     (or (cycpattern_check (subseq b 1 -1)) (or (cycpattern_check (subseq\
    \ b -1) (subseq b 0 (length (rest b)))))]\n    ))\n", "  (define (check x y)\n\
    \    (cond\n      [(ord x #\\a) (ord y #\\b)]\n      [(ord x #\\e) (ord y #\\\
    f)]))\n  (cond\n    [(or (string-equal a x) (string-equal b y))\n     (string-equal\
    \ a y)]\n    [(or (string-equal a b) (string-equal b x))\n     (string-equal a\
    \ x)]\n    [else #f]))\n</code>\n<|/ a tags=racket,pattern-matching,scheme |>\n\
    <| c |>\nThanks for the answer, it's much appreciated!\n<|/ c |>\n<| c |>\nThis\
    \ is so cool! It would take me hours to write this by hand, so I used the built-in\
    \ `string-equal` function instead (`string-equal? a x`), as in: `(or (string-equal?\
    \ a x) (string-equal? b y))`. Also, `string-equal?` returns #t if both arguments\
    \ are equal, so I changed that too.\n<|/ c |>\n<| c |>\nAlso, I just noticed that\
    \ you only need the `check` function if you're only checking one pair of letters.\
    \ You don't need to do that if you were checking more than just the first pair.\n\
    <|/ c |>\n<| c |>\nOh yeah, thanks. I changed that too. I forgot `or` was a macro\
    \ that only works with booleans. `or` doesn't work on strings because it's for\
    \ booleans.\n<|/ c |>\n<| c |>\nAh, I see. Yeah, that's good to know. It would\
    \ definitely save a lot of time to use `string-equal?`.\n<|/ c |>\n<| a dscore=1\
    \ tags=racket,pattern-matching,scheme |>\nI do not have a Scheme implementation\
    \ to test, but I believe that your problem can be solved using regular expressions,\
    \ specifically the regexp-match function.\nThe function regexp-match, which can\
    \ be found in the Racket Standard Library is described as \n\nTests whether a\
    \ string matches a regular expression.\n\nThe documentation states:\n\nA regular\
    \ expression is a sequence of characters that are enclosed in two backslashes\
    \ (\"\\\"), called a back-reference and whose meaning is dependent on the implementation\
    \ and system. An expression containing a back-reference is said to refer to one\
    \ or more subexpressions within the regular expression. A regular expression is\
    \ anchored at the front of the string (i.e., after the \"^\" character), by using\
    \ the special characters \"^\", \"$\", and \".\".\n\nThe function regexp-match\
    \ returns #t if the string matches the regular expression, and otherwise returns\
    \ #f.\nYou can find additional ", "  (or (string-contains b (string-rotate a (string-length\
    \ b))) #f))\n", "  (cond ((empty? b) #f)\n        ((member (caar b) a) (cond ((empty?\
    \ a) #t)\n                                 ((cycpattern_check (car a) (cdar a))\
    \ (cdr b)))\n        (else (cycpattern_check (cdr a) (cdar b)))))\n", "  (cond\n\
    \    [(string-length a) (string-length b)] #t\n    [(equal? a b) #t]\n    [(string-contains-substring\
    \ b a) #t]\n    [else #f]))\n", "  (or (substring b (substring a 0 0))\n     \
    \ (substring-rotated b (substring a 0 0))\n      (substring-rotated b (substring\
    \ a 0 1))\n      (substring-rotated b (substring a 0 2))\n      (substring-rotated\
    \ b (substring a 0 3))\n      (substring-rotated b (substring a 0 4))\n      (substring-rotated\
    \ b (substring a 0 5))\n      (substring-rotated b (substring a 0 6))\n      (substring-rotated\
    \ b (substring a 0 7))\n      (substring-rotated b (substring a 0 8))\n      (substring-rotated\
    \ b (substring a 0 9))))\n", "  (or (string= (make-string (length a) (string-length\
    \ b))\n             (substring b (string-length a)))\n      (or (string= b (string-append\
    \ a b))\n          (string-contains\n           (string-append a b)\n        \
    \   (string-append b a)))\n      (or\n       (string= b (string-append a (butlast\
    \ (substring a 0 (string-length a))))))\n      (or\n       (string= b (string-append\
    \ a (butlast (substring a 1 (string-length a))))))\n      (or (string= b (string-append\
    \ a (butlast (substring a (- 2 (string-length a))))))))\n</cell>\n<text>\nProblem\
    \ 3: Palindromic permutations\n\n</text>\n<code language=lisp-chemistry-app>\n\
    #lang racket\n", "  (or (string=? (substring a 0 a) b)\n      (or (string=? (substring\
    \ a (a-length a)) b)\n          (or (string=? (substring b 0 (b-length b)) a)\n\
    \               (string=? (substring b 0 (b-length b))\n                     \
    \      (substring a 0 (a-length a)))))) ; check for \"substring ab in ba\"\n</cell>\n\
    <cell>\n#lang racket\n", "  (or (string=? (string-ref b 0) (a-string=? (string-ref\
    \ a 0) b)) (string=? (string-ref b 1) (a-string=? (string-ref a 1) b))))\n</code>\n\
    <|/ a dscore=0 |>\n<| a tags=pattern-matching,racket,string,algorithm |>\nHere\
    \ is a simple solution:\n<code>", "  (or (string= b a)\n      (or (string= (b-rotated\
    \ a) b)\n          (string= (b-rotated b) a))))\n</code>\n<|/ a dscore=1 |>\n\
    <| c |>\nThank you for your answer. I think your solution doesn't satisfy the\
    \ requirement of the function and that is the reason I got my down votes. However,\
    \ I appreciate your time and your answer which is really cool and worthy to read\
    \ and use :-) Thank you.\n<|/ c |>\n<| a |>\nHere is a solution that checks that\
    \ all patterns are in first word (no interleaving).\n<code>", "  (cond ((or (null?\
    \ a) (null? b))\n         #f)\n        ((equal? (string-ref a 0) (string-ref b\
    \ 0))\n         #f)\n        ((equal? (string-ref a 0) (string-ref b -1))\n  \
    \       #f)\n        ((equal? (string-ref a 0) (string-ref b 1))\n         #f)\n\
    \        ((equal? (string-ref a 0) (string-ref b 2))\n         #f)\n        ((equal?\
    \ (string-ref a 0) (string-ref b 3))\n         #t)\n        ((equal? (string-ref\
    \ a 0) (string-ref b 4))\n         #t)\n        ((equal? (string-ref a 0) (string-ref\
    \ b 5))\n         #t)\n        ((equal? (string-ref a 0) (string-ref b 6))\n \
    \        #t)\n        ((equal? (string-ref a 0) (string-ref b 7))\n         #t)\n\
    \        ((equal? (string-ref a 0) (string-ref b 8))\n         #t)\n        ((equal?\
    \ (string-ref a 0) (string-ref b 9))\n         #t)\n        ((equal? (string-ref\
    \ a 0) (string-ref b 10))\n         #t)\n        ((equal? (string-ref a 0) (string-ref\
    \ b 11))\n         #t)\n        ((equal? (string-ref a 0) (string-ref b 12))\n\
    \         #t)\n        ((equal? (string-ref a 0) (string-ref b 13))\n        \
    \ #t)\n        ((equal? (string-ref a 0) (string-ref b 14))\n         #t)\n  \
    \      ((equal? (string-ref a 0) (string-ref b 15))\n         #t)\n        ((equal?\
    \ (string-ref a 0) (string-ref b 16))\n         #t)\n        ((equal? (string-ref\
    \ a 0) (string-ref b 17))\n         #t)\n        ((equal? (string-ref a 0) (string-ref\
    \ b 18))\n         #t)\n        ((equal? (string-ref a 0) (string-ref b 19))\n\
    \         #t)\n        ((equal? (string-ref a 0) (string-ref b 20))\n        \
    \ #t)\n        ((equal? (string-ref a 0) (string-ref b 21))\n         #t)\n  \
    \      ((equal? (string-ref a 0) (string-ref b 22))\n         #t)\n        ((equal?\
    \ (string-ref a 0) (string-ref b 23))\n         #t)\n        ((equal? (string-ref\
    \ a 0) (string-ref b 24))\n         #t)\n        ((equal? (string-ref a 0) (string-ref\
    \ b 25))", "  (cond\n    [(equal? b '()) (boolean?)]\n    [(equal? a (string-ref\
    \ b 0)) (boolean?)]\n    [(equal? (string=? a b) (boolean?)) #f]\n    [else (equal?\
    \ (string=? (string-ref a 0) (string-ref b 0)) #f)]\n  )\n)\n", "  (cond [(equal?\
    \ a b) #t]\n        [(equal? (string-length a) (string-length b)) #t]\n      \
    \  [(string-contains-substring b (substr b 0 string-length (substr b 0 string-length\
    \ a)))\n         (cycpattern_check a (string-append (substr b 0 string-length\
    \ (substr b 0 string-length a)) (substr a 0 string-length (substr a 0 string-length\
    \ b))))]\n        [else #f]))\n</cell>\n<text>\nCyclomatic Complexity\nThe Cyclomatic\
    \ Complexity is a measure of the number of linearly independent paths through\
    \ a piece of code. More precisely, it is the number\nof linearly independent paths\
    \ starting from the first to the last path through the code. Cyclomatic Complexity\
    \ is defined as:\n\n$${\\displaystyle C{\\text{Cyclomatic}} =  \\sum \\limits_{i=1}^n\
    \ \\left| i \\right| }$$\n\n\n</text>\n<cell>\n#lang racket\n", "  (or (substring\
    \ a b)\n      (or (substring a (length b) b)\n          (substring b (length a)\
    \ a))))", "  (or (string=? (substring b 0 (string-length a)) a)\n      (string=?\
    \ (substring b (string-length a) (string-length a))\n               (substring\
    \ a 0 (string-length a))))\n)\n", "  (or (mem/starts-with? b a)\n      (mem/contains?\
    \ a b)))\n", "  (or (string=? b a)\n      (string-set=? a b #t)))\n", "  (cond\n\
    \    [(empty? a) #f]\n    [(empty? b) #t]\n    [(equal? (first a) (first b)) #t]\n\
    \    [else (or (cycpattern_check (rest a) b)\n              (cycpattern_check\
    \ (first b) (first a))))]))\n", "  (let ((head (car (string-split a #\\)))\n \
    \       (tail (cadr (string-split b #\\))))\n    (if (and (char-equal tail head)\
    \ (null? tail))\n        #f\n        (or (char-equal (cdr head) (car tail))\n\
    \            (member tail (string-split a #\\))\n            (member head (car\
    \ (string-split b #\\)))))))\n</code>\n<|/ a dscore=2 |>\n<| c |>\nthanks. I did\
    \ not think of using the string for substring checking, but that is a good idea.\
    \ I'm sorry that I failed to mention that I have to use recursion\n<|/ c |>\n\
    <| c |>\nAh. Okay, I added a second version that uses the list for checking substring\
    \ as well.\n<|/ c |>\n<| c |>\nI added another version which checks if the rotated\
    \ word is a substring of the original word using recursion.\n<|/ c |>\n<| a tags=racket,lisp\
    \ |>\nI think it's better to have a list of strings and then simply check if the\
    \ second one is a substring of the first one by using (member second list).\n\
    <code>", "  (cond\n    ((null? b) #f)\n    ((string=? (string-ref a 0) (string-ref\
    \ b 0)) true)\n    ((string=? (string-ref a 0) (string-ref b 1)) false)\n    ((string=?\
    \ (string-ref a 0) (string-ref b 2)) false)\n    ((string=? (string-ref a 0) (string-ref\
    \ b 3)) false)\n    ((string=? (string-ref a 1) (string-ref b 0)) false)\n   \
    \ ((string=? (string-ref a 1) (string-ref b 1)) true)\n    ((string=? (string-ref\
    \ a 1) (string-ref b 2)) false)\n    ((string=? (string-ref a 1) (string-ref b\
    \ 3)) false)\n    ((string=? (string-ref a 2) (string-ref b 0)) false)\n    ((string=?\
    \ (string-ref a 2) (string-ref b 1)) true)\n    ((string=? (string-ref a 2) (string-ref\
    \ b 2)) false)\n    ((string=? (string-ref a 2) (string-ref b 3)) false)\n   \
    \ ((string=? (string-ref a 3) (string-ref b 0)) true)\n    ((string=? (string-ref\
    \ a 3) (string-ref b 1)) false)\n    ((string=? (string-ref a 3) (string-ref b\
    \ 2)) true)\n    ((string=? (string-ref a 3) (string-ref b 3)) true)\n    ((string=?\
    \ (string-ref a 4) (string-ref b 0)) true)\n    ((string=? (string-ref a 4) (string-ref\
    \ b 1)) false)\n    ((string=? (string-ref a 4) (string-ref b 2)) false)\n   \
    \ ((string=? (string-ref a 4) (string-ref b 3)) true)\n    ((string=? (string-ref\
    \ a 5) (string-ref b 0)) true)\n    ((string=? (string-ref a 5) (string-ref b\
    \ 1)) false)\n    ((string=? (string-ref a 5) (string-ref b 2)) false)\n    ((string=?\
    \ (string-ref a 5) (string-ref b 3)) true)\n    ((string=? (string-ref a 6) (string-ref\
    \ b 0)) true)\n    ((string=? (string-ref a 6) (string-ref b 1)) false)\n    ((string=?\
    \ (string-ref a 6) (string-ref b 2)) false)\n    ((string=? (string-ref a 6) (string-ref\
    \ b 3)) true)\n    ((string=? (string-ref a 7) (string-ref b 0)) true)\n    ((string=?\
    \ (string-ref a 7) (string-ref b 1)) false)\n    ((string=? (string-ref a 7) (string-ref\
    \ b 2)) true)\n    ((string=? (string-", "  (= (substring b 0 (string-length a))\
    \ (substring a 0 (string-length b)))\n  )", "  (or (string=? a b) #t\n      (and\
    \ (string=? b a) #t\n           (or (string=? a (cycpattern_rotate b 0 )) #t\n\
    \               (or (string=? b (cycpattern_rotate a 1 )) #t\n               \
    \    (or (string=? a (cycpattern_rotate (b (length a)) (- n 1)) #t\n         \
    \              (or (string=? b (cycpattern_rotate (a) (- n 1)) #t\n          \
    \                 (string=? (cycpattern_rotate a n) b)))))) ))\n", "  (if (< (string-length\
    \ a) (string-length b))\n      (cond [(string=? (substring a 0 (string-length\
    \ b)) (string-reverse b)) #t]\n            [else #f]))\n", "  (cond (or (string-match\
    \ (cycpattern_rotate b) a)\n             (string-match (cycpattern_rotate a) b))\n\
    \        #t\n        (cycpattern_check (cycpattern_rotate a) (b rotation)))\n\
    \    )\n", "  (= (cycpattern_find_all a b) (cycpattern_find_all b a)))\n", " \
    \ (or (member (string-ref a 1) b)\n      (member (string-ref a 1) (substring b\
    \ 0 (string-length a 0)))))\n", "  (cond [(empty? a) (= b (first a))] [(sub? (substring\
    \ a 0) (substring b 0)) (cycpattern_check (rest a) (b (rest b)))]\n        [(empty?\
    \ b) (= a (first b))] [(sub? (substring a 0) (substring b 0)) (cycpattern_check\
    \ (b (rest a)) (rest (rest b)))]\n        [else #f]))\n", "  (if (equal? b (cycpattern_check\
    \ a (rest b))) #t (equal? (cdr (cycpattern_check a (list (first b))) a))))\n",
  "  (or (string=? (string-ref a 0) (string-ref b 0))\n      (string-equal? (string-ref\
    \ a 1)\n                     (string-ref b 0)))) ;; #lang racket\n", "  (or (string=?\
    \ a b) (string-subset? a b)))\n", "  (cond ((equal? b (substring a 0 0))\n   \
    \      #t)\n        (else (or (eq? (substring b 0 0) (cycpattern_check b (substring\
    \ a 0 0))) (cycpattern_check (substring a 0 0) b))))) \n", "  (cond (empty? b)\
    \ #f)\n  (or (char-subset? (string-downcase a) (string-downcase b)) \n      (cycpattern_check\
    \ (substring b 0 (- (length b) 1))\n                        (substring a 0 (-\
    \ (length a) 1)))))\n", "  (if (string=? (string b) (a))\n      (#t (cycpattern_check\
    \ (string a) b))\n      (#f (cycpattern_check a (b (string b))))))\n", "  (or\
    \ (string=? (string-ref a 0) (string-ref b 0))\n      (string-match (string-ref\
    \ a 0) (string-ref b 0) t)))\n", "  (cond [(empty? a) #f]\n        [(empty? b)\
    \ #f]\n        [(substring b 0 a) (equal? a b)]\n        [else (substring b 0\
    \ (substring a 0 a) (substring b 0 (substring a 0 b)))]))\n", "  (cond ((or (string=?\
    \ a b) (string-match-p a b)) #t)\n        ((string=? (string-ref b (string-index\
    \ b 0))\n                  (string-ref a 0 (string-length a)))\n         #t)\n\
    \        (else #f)))\n", "  (fold-right (lambda (x y)\n                (or (string-match\
    \ x y)\n                    (string-match y x)))\n              false\n      \
    \        a))\n</code>\n<|/ a dscore=1 tags=racket,substring,pattern-matching |>\n\
    <| c |>\nThanks for answering my question. I'm sorry if my question was too simple\
    \ and stupid (I'm new to scheme and programming in general). Can you suggest some\
    \ reading material so I can improve my question in future? Also, your answer is\
    \ very helpful and thank you for it. I think my question is a little different\
    \ from what you've answered, because I'm trying to implement it using built-in\
    \ functions/procedures.\n<|/ c |>\n<| c |>\n[Wikipedia](https://en.wikipedia.org/wiki/String-searching_algorithm)\
    \ is a good place to start. I would advise reading through the [Racket documentation](https://docs.racket-lang.org/r5rs/r5rs-std/index.html)\
    \ especially the sections [Strings and Characters](https://docs.racket-lang.org/r5rs/r5rs-std/string.html)\
    \ and [Patterns](https://docs.racket-lang.org/r5rs/r5rs-std/patterns.html). I\
    \ will keep an eye on the questions for more questions :-)\n<|/ c |>\n<| c |>\n\
    Thanks for your help. I got it working and it works fine for checking the presence\
    \ of the substring inside another substring. How do i extend it to find substring\
    \ that matches the first substring in all its rotation? For example how would\
    \ i implement \"abd\" pattern to find strings like \"abcd\", \"abbb\", \"abba\"\
    , \"abac\", etc. I will try to read docs and come back here if any questions.\
    \ Thanks again.\n<|/ c |>\n<| c |>\nThe code I've written returns `true` when\
    \ `a` and `b` contain the same letters in any order. I'm still working on it though\
    \ so if you have any more questions feel free to ask me or post a new question.\n\
    <|/ c |>\n<| c |>\nI've updated my answer and added a new version of `cycpattern_check`\
    \ that takes a second argument that controls whether the matching should be case\
    \ insensitive.\n<|/ c |>\n<| a |>\nA solution that uses recursion to find the\
    \ matching positions in the first word. Not that this is how I would implement\
    \ it, but it works and is quite similar to your implementation with fold-right:\n\
    <code>\n#lang racket\n", "  (cond\n    ((empty? a) #f)\n    ((empty? b) #f)\n\
    \    ((substring? (car a) b)\n     (let ((tail (cdr a)))\n       (cond\n     \
    \    ((substring? (car tail) b) #t)\n         (else #f)))))\n  ((substring? (car\
    \ a) b)\n   (let ((head (cdr a)))\n    (cond\n      ((substring? (car head) b)\
    \ #t)\n      (else #f)))))\n</code>\n<|/ a tags=racket,substring |>\n<| c |>\n\
    I am not so sure I understand what your code is doing but it looks like it's doing\
    \ a lot of unnecessary work since you are rebuilding the original list with every\
    \ iteration. This is going to be O(n^2) because you're rebuilding the entire list\
    \ no matter what.  Also, if I understand correctly, you only need to check each\
    \ element once per word since you only check each element once, then move onto\
    \ the next element.  However, if this is done then it would also be O(n^2) because\
    \ you have to compare every element with every other element for each word.  Am\
    \ I correct or am I missing something?\n<|/ c |>\n<| c |>\nYou have a point, I\
    \ think I confused myself and didn't notice the duplicate, I have added a more\
    \ efficient solution now.\n<|/ c |>\n<| a |>\nHere's another solution:\n<code>",
  "  (or (string=? b (string->list a)) (cycpattern_check (string->list b) a)))\n",
  "  (cycpattern_check_aux (length a) (length b) a b))\n", "  (match a\n    [(empty)\
    \ false]\n    [else (or (match b\n                  [(empty) false]\n        \
    \          [(empty) (empty)]\n                  [(cons\n                    (match-beginning\
    \ (cycpattern_head a) (cycpattern_head b))\n                    (cycpattern_tail\
    \ (cycpattern_tail (cycpattern_head a) (cycpattern_tail (cycpattern_head b))))\n\
    \                    [else false]))]))\n", "  (or\n   (or (string-equal? a (string-join\
    \ (b . #\\a))) #f) (or\n    (string-equal? (string-rotate b a #\\a) #f) #t)))\n",
  "  (cond ((empty? b) '#t)\n        ((string-contains b a)\n         (if (empty?\
    \ a) '#t\n              (cond ((equal? (string-tail a 0) (string-head b 0))\n\
    \                     (equal? (string-tail a 1) (string-head b 1))\n         \
    \            (equal? (string-tail a 2) (string-head b 2))\n                  \
    \   (equal? (string-tail a 3) (string-head b 3)))\n                    (else (cycpattern_check\
    \ (string-tail a 0) (string-tail b 0))))))\n        (else (cycpattern_check a\
    \ (string-tail b 0)))))\n", "  (or (string=? (cycpattern_check b a) #t)\n    \
    \  (string-subset-p (cycpattern_check b a) #t)))\n", "  (ormap (\u03BB (x) (cycpattern_check\
    \ x (append a x))) b '()))\n", "  (cond\n    [(empty? a) #f]\n    [(empty? b)\
    \ #f]\n    [(member (car a) b) #t]\n    [(cycpattern_check (rotate (car a) (car\
    \ b)) b) #t]\n    [else (cycpattern_check (rotate b a) #f)]))\n", "  (cond ((null?\
    \ b)\n         #f)\n        ((symbol? (car b))\n         (or (string=? (car a)\
    \ (car (cdr b)))\n             (cycpattern_check (cdr a) (cdr b))))\n        (else\n\
    \         (string=? (car a) (car (cdr b))) (cycpattern_check (cdr a) (cdr b)))))\n",
  "  (cond\n    [(or (string=? a b) (substring a b))\n     #t]\n    [else \n     (andmap\
    \ (lambda (cycpattern)\n       (ormap (lambda (word)\n              (or (string=?\
    \ word cypattern) (substring word cypattern)))\n            (lambda (word)\n \
    \             (cond\n                [(string=? word a)\n                 #t]\n\
    \                [else #f])))\n             (cycle (substring a 1 -1))\n     \
    \        (cycle (substring b 1 -1)))]))]))\n</code>\n<|/ a tags=racket,string\
    \ |>\n<| c |>\nYour solution is nice, but unfortunately is not \"correct\" because\
    \ it gives false positives when there are more than one rotated substring in a\
    \ word. For example: \"abab\" is a valid substring in \"baa\" but is false positive.\n\
    <|/ c |>\n<| c |>\n: I've fixed the false positives problem.\n<|/ c |>\n<| a |>\n\
    Here is another approach using a hash. I'm not a Racket expert, so this might\
    \ not be the best solution, but you can get the idea.\nThe idea is to have a hash\
    \ table of \"substrings\" where each key in the hash table is a list of words\
    \ that can form a substring of the given word, and where each value of the hash\
    \ table is a list of all possible words that can form a substring of the given\
    \ word. The procedure takes a word and a substring and returns all words that\
    \ can be formed by taking a prefix of the given word and concatenating it with\
    \ the given substring. For each word, the procedure checks to see if it is a substring\
    \ of the given word. If it is, then it gets added to the hash table. The procedure\
    \ then goes through all the values in the hash table, checking if each of those\
    \ words is a substring of the given word. If it is, then it is added to the hash\
    \ table as a value for this key. Once all the values in the hash table have been\
    \ checked, then you can check whether or not the word you are given is a substring\
    \ of the word.\n<code>", "  (or (member (char->int (car (string->list (string-append\
    \ a (list-ref b 0))))\n                   (string->list (string-append a (list-ref\
    \ b 1))))\n       (member (char->int (car (string->list (string-append a (list-ref\
    \ b 1))))\n                   (string->list (string-append a (list-ref b 0))))\n\
    \       (member (char->int (car (string->list (string-append a (list-ref b 1))))\n\
    \                   (string->list (string-append a (list-ref b 0))))\n       (member\
    \ (char->int (car (string->list (string-append a (list-ref b 1))))\n         \
    \          (string->list (string-append a (list-ref b 0))))\n       (member (char->int\
    \ (car (string->list (string-append a (list-ref b 0))))\n                   (string->list\
    \ (string-append a (list-ref b 1))))\n       (member (char->int (car (string->list\
    \ (string-append a (list-ref b 0))))\n                   (string->list (string-append\
    \ a (list-ref b 1))))\n       (member (char->int (car (string->list (string-append\
    \ a (list-ref b 0))))\n                   (string->list (string-append a (list-ref\
    \ b 1))))\n       (member (char->int (car (string->list (string-append a (list-ref\
    \ b 1))))\n                   (string->list (string-append a (list-ref b 0))))\n\
    \       (member (char->int (car (string->list (string-append a (list-ref b 1))))\n\
    \                   (string->list (string-append a (list-ref b 0))))\n       (member\
    \ (char->int (car (string->list (string-append a (list-ref b 1))))\n         \
    \          (string->list (string-append a (list-ref b 0))))\n       (member (char->int\
    \ (car (string->list (string-append a (list-ref b 0))))\n                   (string->list\
    \ (string-append a (list-ref b 1))))\n       (member (char->int (car (string->list\
    \ (string-append a (list-ref b 0))))\n                   (string->list (string-append\
    \ a (list-ref b 1))))\n       (member (char->int (car (string->list (string-append\
    \ a (list-ref b 0))))\n                   (string->list (string-append a (list-ref\
    \ b 1))))\n       (member (char->int (car (string->list (string-append a (list-ref\
    \ b 1))))\n                   (string->list (string-append a (list-ref b 0))))\n\
    \       (member (char->int (car (string->list (string-append a (list-ref b 1))))\n",
  "  (regexp-match\n   (string->symbol a)\n   (regexp-opt b)))\n", "  (or (equal?\
    \ b (substring a 0 (string-length a)) #f) (cycpattern_check (substring a (string-length\
    \ a)) b)))\n", "  (or (string-match-p a b)\n      (let ((head (cycpattern_head\
    \ a b)))\n        (and (not (string-match-p head b))\n             (not (string-match-p\
    \ head a :start1 head)))))) ;; :start1 because we are looking backwards\n", " \
    \ (cond\n    [(empty? a) #f]\n    [(empty? b) #f]\n    [(equal? (substring a 0\
    \ 1) (substring b 0 1))\n     (cond\n       [(empty? (substring b 1 a)) #t]\n\
    \       [else\n        (cond\n         [(empty? (substring a 1 b)) #t]\n     \
    \    [else\n          (cond\n            [(empty? (substring a 1 b)) #f]\n   \
    \         [(empty? (substring b 1 a)) #t]\n            [else (eq? (substring a\
    \ 1 b) (substring b 1 a)) #t])]))]\n    [(equal? (substring a 1 2) (substring\
    \ b 1 2))\n     (cond\n       [(empty? (substring b 2 a)) #t]\n       [else\n\
    \        (cond\n         [(empty? (substring a 2 b)) #t]\n         [else\n   \
    \       (cond\n            [(empty? (substring a 2 b)) #f]\n            [(empty?\
    \ (substring b 2 a)) #t]\n            [else (eq? (substring a 2 b) (substring\
    \ b 2 a)) #t])]))]\n    [(equal? (substring a 2 3) (substring b 2 3))\n     (cond\n\
    \       [(empty? (substring b 3 a)) #t]\n       [else\n        (cond\n       \
    \  [(empty? (substring a 3 b)) #t]\n         [else\n          (cond\n        \
    \    [(empty? (substring a 3 b)) #f]\n            [(empty? (substring b 3 a))\
    \ #t]\n            [else (eq? (substring a 3 b) (substring b 3 a)) #t])]))]\n\
    \    [(equal? (substring a 3 4) (substring b 3 4))\n     (cond\n       [(empty?\
    \ (substring b 4 a)) #t]\n       [else\n        (cond\n         [(empty? (substring\
    \ a 4 b)) #t]\n         [else\n          (cond\n            [(empty? (substring\
    \ a 4 b)) #f]\n            [(empty? (substring b 4 a)) #t]\n            [else\
    \ (eq? (substring a 4 b) (substring b 4 a)) #t])]))]\n    [(equal? (substring\
    \ a 4 5) (substring b 4 5))\n     (cond\n       [(empty? (substring b 5 a)) #t]\n\
    \       [else\n        (cond", "  (match b\n    (([a-b]* #t)\n     (match (split-at\
    \ b a)\n           (([a-b-c]* #f)\n            (match (split-at a-b-c a-b)\n \
    \                  (([a-b-c-d]* #f)\n                    (([a-b-c-d-e]* #t)\n\
    \                     (match (split-at a-b-c-d-e a-b-c-d)\n                  \
    \         (([a-b-c-d-e-f]* #f)\n                            (([a-b-c-d-e-f-g]*\
    \ #t)\n                             (match (split-at a-b-c-d-e-f-g a-b-c-d-e-f)\n\
    \                                     (([a-b-c-d-e-f-g-h]* #f)\n             \
    \                        (([a-b-c-d-e-f-g-h-i]* #t)\n                        \
    \             (match (split-at a-b-c-d-e-f-g-h-i a-b-c-d-e-f-g)\n            \
    \                               (([a-b-c-d-e-f-g-h-i-j]* #f)\n               \
    \                            (([a-b-c-d-e-f-g-h-i-j]* #t)\n                  \
    \                         (match (split-at a-b-c-d-e-f-g-h-i-j a-b-c-d-e-f-g)\n\
    \                                                 (([a-b-c-d-e-f-g-h-i-j-k]* #f)\n\
    \                                                 (([a-b-c-d-e-f-g-h-i-k-j]* #t)\n\
    \                                                 (match (split-at a-b-c-d-e-f-g-h-i-k-j\
    \ a-b-c-d-e-f-g)\n                                                       (([a-b-c-d-e-f-g-h-i-k-j-l]*\
    \ #f)\n                                                       (([a-b-c-d-e-f-g-h-i-k-j-l-i]*\
    \ #t)\n                                                       (match (split-at\
    \ a-b-c-d-e-f-g-h-i-k-j-l-i a-b-c-d-e-f-g)\n                                 \
    \                            (([a-b-c-d-e-f-g-h-i-k-j-l-i-m]* #f)\n          \
    \                                                   (([a-b-c-d-e-f-g-h-i-k-j-l-i-m-n]*\
    \ #t)\n                                                             (match (split-at\
    \ a-b-c-d-e-f-g-h-i-k-j-l-i-m-n a-b-c-d-e-f-g)\n                             \
    \                                      (([a-b-c-d-e-f-g-h-i-k-j-l-i-m-n-o]* #f)\n\
    \                                                                   (([a-b-c-d-e-f-g-h-i-k-j",
  "  (or (string=? (substring-of b a) a)\n      (let ((b (reverse b)))\n        (or\
    \ (string=? (substring-of b a) a)\n            (or (string=? (substring-of b a)\
    \ (reverse a))\n                (substring-of b a)\n                (substring-of\
    \ b (string-length a)))))))\n", "  (or\n   (subseq? a b)\n   (subseq?-rotations\
    \ a b)\n   (substring? a b)\n   (substring?-rotations a b)))\n", "  (or (equal\
    \ b \"\")\n      (equal (subseq b 0) a)\n      (equal (subseq b (length (cdr b)))\n\
    \             (subseq b 0 (length (cdr b))))))\n", "  (cond [(string=? a b) #t]\n\
    \        [else (and (equal? (substring a 0) (substring b 0)) (cycpattern_check\
    \ (substring b 1) (substring a 1)))]))\n", "  (cond ((empty? b) true)\n      \
    \  ((string=? (first b) a) (empty? b))\n        (else (not (substring a (rest\
    \ b)) (cycpattern_check (rest a) b))))\n", "  (cond ((null? a) #f)\n        ((null?\
    \ b) #f)\n        (else (and\n                 (or\n                   (and\n\
    \                     (string-contains-substring (cycle_check a 0) b)\n      \
    \               (string-contains-substring (cycle_check a 1) b))\n           \
    \        (and\n                     (string-contains-substring (cycle_check a\
    \ -1) b)\n                     (string-contains-substring (cycle_check a -2) b)))))))\n",
  "  (or (string= (substr a 0 (string-length a)) b)\n      (string= (substr b (- string-length\
    \ a) (string-length b))\n               (substr a (- string-length b) (- string-length\
    \ a)))))\n", "  (cond\n    [(empty? b) #f]\n    [(equal? (first a) (cycpattern_check\
    \ (rest b) a))\n     (if (member (first b) a)\n         (cycpattern_check (rest\
    \ b) (rest a))\n         #f)]\n    [else #t]\n    ))\n", "  (cond ((null? a) #f)\n\
    \        ((equal? (caar a) b)\n         (cdar a))\n        (else (cond ((contains?\
    \ (cdar a) b) #t)\n                   (else (cycpattern_check (cdr a) b))))))\n",
  "  (cond\n    [(or (string=? a b) (string-match a b)) #t]\n    [else (let ((rots\
    \ (list-rotations a)))\n            (map (lambda (rotation)\n                \
    \   (cond (string=? a (cycpattern_rotate a rotation))\n                      \
    \   #t\n                         [else #f])) rots)])))\n", "  (cond\n    [(empty?\
    \ a) #t]\n    [(empty? b) #t]\n    [(equal? (first a) (reverse (first b))) #t]\n\
    \    [(equal? (first b) (reverse (first a))) #t]\n    [else (set! b (append (reverse\
    \ (first b)) (reverse (first a)))\n            (set! a (append (reverse (first\
    \ a)) (reverse (first b))))\n            (cycpattern_check a b)]))\n", "  (cond\
    \ [(string-subset? b a)\n         #t]\n        [else\n         (let ((x (substring\
    \ a 0 string-length a)))\n           (cond [(string-subset? (substring b 0 string-length\
    \ b)\n                              x)\n                    #t]\n            \
    \     [else\n                    (let ((y (substring b 0 string-length b)))\n\
    \                      (cond [(string-subset? (substring a 0 string-length a)\n\
    \                                           y)\n                             (string-subset?\
    \ (substring a 0 string-length a)\n                                          \
    \   (string-append x y))\n                             (string-subset? (substring\
    \ b 0 string-length b)\n                                             (string-append\
    \ x y))\n                             (string-subset? (substring b 0 string-length\
    \ b)\n                                             (string-append y x))\n    \
    \                         (string-subset? (substring a 0 string-length a)\n  \
    \                                           (string-append y x))\n           \
    \                  (string-subset? (substring a 0 string-length a)\n         \
    \                                    (string-append y x) (string-append x y))\n\
    \                             (string-subset? (substring b 0 string-length b)\n\
    \                                             (string-append y x) (string-append\
    \ x y))\n                             (string-subset? (substring b 0 string-length\
    \ b)\n                                             (string-append y x) (string-append\
    \ y x))\n                             (string-subset? (substring a 0 string-length\
    \ a)\n                                             (string-append y x) (string-append\
    \ x y))\n                             (string-subset? (substring a 0 string-length\
    \ a)\n                                             (string-append y x) (string-append\
    \ y x))\n                             (string-subset? (substring b 0 string-length\
    \ b)\n                                             (string-append y x) (string-append\
    \ x y))\n                             (string-subset? (substring b 0 string-length\
    \ b)\n                                             (string-append y x) (string-append\
    \ y x))\n                             (string-subset? (substring a 0 string-length\
    \ a)\n                                             (string-append y x) (string-append\
    \ x y))\n                             (string-subset? (substring a 0 string-length\
    \ a)\n                                             (string-append y x) (string-append\
    \ y x))\n                             (string-subset? (substring b 0 string-length\
    \ b)\n                                             (string-append y x) (string-append\
    \ x y))\n                             (string-subset? (substring b 0 string-length\
    \ b)\n                                             (string-append y x) (string-append\
    \ y x))\n                             (string-subset? (substring a 0 string-length\
    \ a)\n                                             (string-append y x) (string-append\
    \ x y))\n                             (string-subset? (substring a 0 string-length\
    \ a)\n                                             (string-append y x) (string-append\
    \ y x))\n                             (string-subset? (substring b 0 string-length\
    \ b)\n                                             (string-append ", "  (define\
    \ (helper)\n    (cond ((or (string-empty? a)\n              (string-empty? b))\n\
    \           #f) \n          ((substring (car a) (car b))\n           (helper))\n\
    \          ((helper))\n          (else #f)))\n  (helper b))\n", "  (or (equal?\
    \ (string_length a) (string_length b))\n      (or (equal? (string_length a) 0)\n\
    \          (equal? (string_length b) 0))\n      (or (equal? (string-pattern a)\
    \ (string-pattern b))\n          (equal? (string-pattern a) (string-pattern (string-rotate\
    \ b)))\n          (equal? (string-pattern b) (string-pattern (string-rotate a\
    \ ))))))\n", "  (or (= (car (string-split a \"\")) (car (string-split b \"\")))\
    \ (\n    (and (or (= (string-length (string-split b \"\")) (string-length (string-split\
    \ a \"\")))\n            (string= a b))\n     (= (string-length (string-split\
    \ a \"\")) (string-length (string-split b \"\")))\n     (= (string-split b \"\"\
    ) (substring a 0 (string-length (string-split a \"\"))))))))\n", "  (or (string-include?\
    \ a b)\n      (< (length a) length)\n      (< (length b) length)\n      (<= (length\
    \ a) (length b)))\n)\n</code>\n<|/ a |>\n<| c |>\nThe question asks for \"substring\"\
    , not \"character\". `string-include?` returns true when the two strings have\
    \ a substring that is in the other string. `string-equal?` checks whether the\
    \ two strings are equal.\n<|/ c |>\n<| a dscore=0 |>\nI have solved this problem\
    \ using the following approach:\n<code>", "  (cond ((null? b) 'f)\n        ((equal?\
    \ (string-ref a 0) (string-ref b 0))\n         (equal a b))\n        (else (not\
    \ (cycpattern_check (string-ref a 0)\n                                   (string-ref\
    \ b 0))))))\n", "  (or (string=? b a)\n      (or (string=? (append (rotate_right\
    \ a 1 a) b) a)\n          (or (string=? (append (rotate_right a 1 b) a) b)\n \
    \             (or (string=? (append (rotate_right b 1 a) b) a)\n             \
    \     (or (string=? (append (rotate_right b 1 b) a) b)\n                     \
    \ (or (string=? (rotate_right b 2 a) b)\n                          (or (string=?\
    \ (rotate_right b 2 b) a)\n                              (or (string=? (rotate_right\
    \ b 3 a) b)\n                                  (or (string=? (rotate_right b 3\
    \ b) a)\n                                      (or (string=? (rotate_right b 4\
    \ a) b)\n                                          (or (string=? (rotate_right\
    \ b 4 b) a)\n                                              (or (string=? (rotate_right\
    \ b 5 a) b)\n                                                  (or (string=? (rotate_right\
    \ b 5 b) a)\n                                                      #f)))))))))))))))\n",
  "  (define (check b a)\n    (cond [(empty? b) true]\n          [(substring a (car\
    \ b)) (or (check (cdr b) a) (check (cdr (cdr b)) a))] \n          [else false]))\n\
    \  (check (substring b (length a)) a))\n", "  (or (string-contains-itself a b)\n\
    \      (string-contains-itself (list->string b) a)))\n", "  (cond\n    [(null?\
    \ a) #f]\n    [(null? b) #t]\n    [(eqv? (string-downcase (substring a 0 1)) (string-downcase\
    \ (substring b 0 1)))\n     (string-downcase (substring a 1 0))]\n    [else (cycpattern_check\
    \ (substring b 0 1) (substring a 0 1))]))\n", "  (cond ((string=? a b) #t)\n \
    \       ((string=? (substring-no-rotate a b) #t) #t)\n        (else #f)))\n",
  "  (or (equal? a b) (cycpattern_check_aux (list a) (list b) (cycpattern_check_aux_recur\
    \ b a))))\n", "  (define (rotate_1 a b)\n    (define (rotate_2 a b)\n      (define\
    \ (rotate_3 a b)\n        (define (rotate_4 a b)\n          (define (rotate_5\
    \ (a b c))\n            (cond [(equal? (mod (b c) a) 0)\n                   #t]\n\
    \                  [else #f]))\n        (rotate_5 (a b c) b c))\n      (rotate_4\
    \ (a b c) b c))\n    (rotate_3 (a b c) b c))\n  (rotate_2 (a b c) b c))\n  (equal?\
    \ ((length b) (- (length a) (length b)))\n          (length (string-match a b))))\n\
    </code>\n<|/ a dscore=2 |>\n<| c |>\nI like this answer, but can you clarify what\
    \ you mean by \"rotations is a substring in the first word\"? In your examples,\
    \ \"abab\" is a substring of the second word \"baa\" but \"efef\" and \"eeff\"\
    \ are not substrings of the first word, and you seem to think that \"efef\" and\
    \ \"eeff\" are substrings of the first word and that \"efef\" is a substring of\
    \ the second word \"eeff\" but that does not seem to be the case. I think perhaps\
    \ you are not fully understanding how Cyclic Game Patterns work...\n<|/ c |>\n\
    <| c |>\nI think I understand now.  I modified the code to handle the special\
    \ case of zero rotations being allowed.\n<|/ c |>\n<| a dscore=0 tags=racket,string,substring,scheme\
    \ |>\nThis solution uses \"substring?\" from \"string\", and uses \"subsequence?\"\
    \ from \"string/x\".\n<code>", "  (cond ((or (empty? a) (empty? b))\n        \
    \ #t)\n        (else (or (equal? (substring a 0 end) b)\n                  (cycpattern_check\
    \ (substring a end (- (length a) end)) b))))\n", "  (cond\n    [(string-equal?\
    \ b \"\") #t]\n    [(string-equal? b a) #f]\n    [(member b (string->list (substring-probe\
    \ a)))\n     (cond \n       [(member b (string->list (substring-probe (substring\
    \ a 0 (string-length a))))) #t]\n       [else #f])]\n    [else #f]))\n", "  (ormap\
    \ (\u03BB (c)\n           (member (substring a (cycpattern_match_start a c) (length\
    \ c)) b))\n         (\u03BB (c)\n           (member (substring b (cycpattern_match_start\
    \ b c) (length c)) a))\n         (\u03BB (c)\n           (member (substring a\
    \ (cycpattern_match_start b c) (length c)) b))\n         (\u03BB (c)\n       \
    \    (member (substring b (cycpattern_match_start a c) (length c)) a))\n     \
    \    (\u03BB (c)\n           (member (substring b (cycpattern_match_start b c)\
    \ (length c)) a))))\n", "  (cond ((null? a) #f)\n        ((null? b) #f)\n    \
    \    (else (substring (equal? (cycseq (substring a (cycseq (cdr a) 1)) b) (cycseq\
    \ (cdr b) 1)) (cycseq (cdr a) 1)))))\n", "  (and (let ((re (regexp-opt (list \"\
    ^\" a \"$\"))))\n          (or (string=? b (substring a 0 (- (string-length a)\
    \ (string-length b))) 0)\n              (string-contains? b re) (string=? (substring\
    \ a 0 (+ (string-length a) (string-length b))) (substring a 0 (- (string-length\
    \ a) (string-length b)))))))\n", "  (if (equal? (string-length b) 0)\n      #t\n\
    \      (or (equal? (string-index a b) #f)\n          (equal? (string-index (string-reverse\
    \ b) a) #t))))\n", "  (define (cyccheck x y)\n    (string=? x y))\n\n  (cond\n\
    \    [(or (string=? a b) #t)\n     (string=? b a)\n     (car a)\n     (car b)\n\
    \     (cyccheck a b)\n     (cyccheck (substring a 0 length (reverse (cdr a)))\
    \ (substring b 0 length (reverse (cdr b))))]\n    [(and (string=? a b) #t)\n \
    \    (string=? b a)\n     (cdr a)\n     (cdr b)\n     (cyccheck a b)\n     (cyccheck\
    \ (substring a 0 length (reverse (cdr a))) (substring b 0 length (reverse (cdr\
    \ b))))]\n    [else\n     (#f)]))\n", "  (or (string-equal? a b)\n      (string-subset?\
    \ a b)))\n", "  (cond ((null? a) false)\n        ((null? b) true)\n        ((string-equal?\
    \ (string-ref b 0) (string-ref a 0)) true)\n        ((string-equal? (string-ref\
    \ a 0) (string-ref b 0)) true)\n        (else (or (cycpattern_check (list-ref\
    \ a 0) (string-append (list-ref b 0) (list-ref a 1))) \n                  (cycpattern_check\
    \ (list-ref b 0) (string-append (list-ref a 1) (list-ref b 1))))))", "  (cond\
    \ ((equal? a b) #t)\n        ((null? a) #f)\n        ((null? b) #f)\n        (else\
    \ (or (cycpattern_check (substring a 0 end) b) (or (cycpattern_check (substring\
    \ a end 0) b) (cycpattern_check (substring b 0 end) (substring b end 0))))))\n",
  "  (define (cycpattern_check_aux a b i)\n    (if (null? b)\n        #f\n       \
    \ (cond ((or (equal? a (substring b 0 (- (length a) i))) (equal? (substring a\
    \ 0 (- (length a) i)) (substring b 0 (- (length b) i)))) #t)\n            ((equal?\
    \ a (substring b i (+ (length a) 1))) #t)\n            (else\n             (cycpattern_check_aux\
    \ a (substring b i (+ (length a) 1)) (i)))))\n  (cycpattern_check_aux a b 0))\n",
  "  (cond ((empty? a) (empty? b)) ; both empty\n        (else (cond ((equal? (first\
    \ (rest a)) (first (rest b))) ; word is equal \n                     (equal? (first\
    \ (rest b)) (first (rest a))) ; word rotated\n                     (else (equal?\
    \ (first (rest b)) (first (rest a)) ; word not rotated\n                     \
    \               (cycpattern_check (substring (first (rest b)) 1) \n          \
    \                                        (substring (first (rest a)) 1)))))) ;\
    \ word rotated\n                    ))))\n", "  (or (string=? a b) (string=? (string-repeat\
    \ b a) (string-repeat b a)))) ; #lang racket\n", "  (let* ((a a)\n         (b\
    \ b)\n         (a-c (string-length a))\n         (b-c (string-length b))\n   \
    \      (a-r (string-to-list a))\n         (b-r (string-to-list b)))\n    (cond\
    \ ((or (= a-c 0) (= b-c 0))\n           (string-equal a b))\n          ((or (=\
    \ a-c 0) (= b-c 0))\n           (string-subset-p a b))\n          ((or (< a-c\
    \ b-c) (< b-c a-c))\n           (string-subset-p b a))\n          ((or (< a-c\
    \ b-c) (< b-c a-c))\n           (string-subset-p a b))\n          ((or (< a-c\
    \ b-c) (< b-c a-c))\n           (string-subset-p b a))\n          ((or (< a-c\
    \ b-c) (< b-c a-c))\n           (string-subset-p a b))\n          (else\n    \
    \       (< (string-index a a-r) (string-index b b-r)))\n          (else\n    \
    \       (< (string-index a a-r) (string-index b b-r))))))\n", "  (let ((len (string-length\
    \ a 1))\n        (mid (modulo len 2) b))\n    (cond\n      [(< a b)\n       (string=?\
    \ a b)]\n      [(<= len 0 (string=? a b))\n       (string=? b a)]\n      [(< len\
    \ 0 (string=? (string-reverse a) (string-reverse b)))\n       (string=? (string-reverse\
    \ b) (string-reverse a))]\n      [else (= len (string-length a 1) (string-length\
    \ b 1))\n           (string=? a b)]\n      )))\n</code>\n<|/ a dscore=0 |>\n<|\
    \ c |>\nI'm sure there are better ways to do this, maybe using `map` or a similar\
    \ recursive procedure to compare each of the two strings character by character.\
    \ That's what I was thinking myself as well.\n<|/ c |>\n<| c |>\nI have edited\
    \ the code. I'm sure there are a bunch of ways to do it, but this seemed like\
    \ the simplest.\n<|/ c |>\n<| c |>\nI edited the question to show what happens\
    \ when a substring in the first word is found as a suffix or prefix of the second\
    \ word. I also added a test case to show that it doesn't match the case.\n<|/\
    \ c |>\n<| c |>\nThanks very much for your help. I appreciate it.\n<|/ c |>\n\
    <| a |>\nThis implementation uses only recursive procedures and does not use any\
    \ string functions except the length function.\n<code>", "  ((or (string=? a b)\n\
    \       (string=? (string-reverse a) (string-reverse b)))\n   #f))\n", "  (bmatch\
    \ (regex a (list #\\A (list #\\B))) #:submatch (equal? (substring b 1) (substring\
    \ a 1))))\n</code>\n<|/ a dscore=4 tags=string,racket,regex,pattern-matching |>\n\
    <| c |>\nI'm sorry I missed your comment before I read it. The `mch` solution\
    \ is very impressive!\n<|/ c |>\n<| c |>\nThank you for the explanation of the\
    \ regex pattern. Very helpful.\n<|/ c |>\n<| c |>\n: Thanks for the comments --\
    \ I added some more explanation to the answer.\n<|/ c |>\n<| a |>\nOne thing I\
    \ didn't see in this other answer: It doesn't seem to support regular expressions.\
    \ That's because the regular expression package for Racket doesn't support regular\
    \ expressions (it supports string patterns, not regex patterns). However, the\
    \ regex package in Racket does have regex patterns, so you could use that.\nHere's\
    \ an example program that uses regex:\n<code>\n#lang racket\n", "  (cond ((or\
    \ (empty? a) (empty? b)) #f) \n        ((or (string=? a b) (string=? (substring\
    \ b 0) (substring a 0))) \n         (or (string=? (substring b -1) (substring\
    \ a -1)) \n             (string=? (substring b 0) (substring a 0))\n         \
    \    (string=? (substring b -1) (substring a -1)))\n        ((equal? a b) (substring\
    \ a 0)\n           (equal? (substring b 0) (substring a 0)) #t\n           (equal?\
    \ (substring b -1) (substring a -1) #f)))\n  )\n</code>\nAnd if you're using racket\
    \ (or your other programming language) you may be able to do something with the\
    \ built-in string functions. In Python this would look something like:\n<code>\n\
    >>> \"abc\" in \"abcd\"\nTrue\n>>> \"abcd\" in \"abc\"\nFalse\n</code>\nBut it\
    \ seems like in your particular case a recursive function would be much simpler\
    \ and easier to read. Here's a solution with that approach:\n<code>", "  (let\
    \ ([m (cycpattern_match a b)])\n    (if (or (= m '#f)\n            (= m '#t))\n\
    \        m\n        (error \"Wrong pattern: \" (string->list b) \" should be \"\
    \ (string->list a))))\n  )\n", "  (cond\n    [(empty? a) #f]\n    [(empty? b)\
    \ #f]\n    [(substring b (length a) (substring a 0 0))]\n    [(substring a 0 0\
    \ (length b))] \n    [(substring a 0 (length b) (length a))] \n    [(substring\
    \ a 0 (length b) 0) #t] \n    [(substring b 0 (length a) (length a)) #t] \n  \
    \  [(substring b 0 (length a) 0) #t] \n    [(substring b (length a) (length a)\
    \ (length b)) #t]\n    [else #f]))\n", "  (cond ((null? b)\n         #f) \n  \
    \      ((not (member (string-ref a 0) (string-ref b 0)))\n         #t)\n     \
    \   (else (cycpattern_check (string-tail a 1)\n                             (string-tail\
    \ b 1)))))\n", "  (if (or (equal a (string-append (substring b 0) (substring a\
    \ 0)))\n\t  (equal a (string-append (substring b 0) (substring a 1)))\n\t  (equal\
    \ a (string-append (substring b 1) (substring a 0)))\n\t  (equal a (string-append\
    \ (substring b 1) (substring a 1)))\n\t  (equal a (string-append (substring b\
    \ 2) (substring a 0)))\n\t  (equal a (string-append (substring b 2) (substring\
    \ a 1))))\n\t  #t\n\t  #f))\n", "  (let loop ((n 0)\n             (i 0)\n    \
    \         (l 0))\n    (cond ((eq? a b) (eq? b \"\"))\n          ((eq? b \"\")\
    \ (eq? a \"\"))\n          ((= n l) (eq? b a))\n          ((eq? b a) (eq? a b))\n\
    \          ((string=? b a) (eq? b a))\n          ((string=? (string-ref b i) (string-ref\
    \ a i)) (loop (+ n 1) (+ i 1) (+ l 1)))\n          ((eq? (string-ref b i) '#\\\
    y) (loop (+ n 1) (+ i 1) (+ l 1)))\n          ((eq? (string-ref b i) '#\\y) (loop\
    \ (+ n 1) (+ i 1) (+ l 1)))\n          ((eq? (string-ref b i) '#\\y) (loop (+\
    \ n 1) (+ i 1) (+ l 1)))\n          ((eq? (string-ref b i) '#\\y) (loop (+ n 1)\
    \ (+ i 1) (+ l 1)))\n          ((eq? (string-ref b i) '#\\y) (loop (+ n 1) (+\
    \ i 1) (+ l 1)))\n          ((eq? (string-ref b i) '#\\y) (loop (+ n 1) (+ i 1)\
    \ (+ l 1)))\n          ((eq? (string-ref b i) '#\\y) (loop (+ n 1) (+ i 1) (+\
    \ l 1)))\n          ((eq? (string-ref b i) '#\\y) (loop (+ n 1) (+ i 1) (+ l 1)))\n\
    \          ((eq? (string-ref b i) '#\\y) (loop (+ n 1) (+ i 1) (+ l 1)))\n   \
    \       ((eq? (string-ref b i) '#\\y) (loop (+ n 1) (+ i 1) (+ l 1)))\n      \
    \    ((eq? (string-ref b i) '#\\y) (loop (+ n 1) (+ i 1) (+ l 1)))\n         \
    \ ((eq? (string-ref b i) '#\\y) (loop (+ n 1) (+ i 1) (+ l 1)))\n          ((eq?\
    \ (string-ref b i) '#\\y) (loop (+ n 1) (+ i 1) (+ l 1)))\n          ((eq? (string-ref\
    \ b i) '#\\y) (loop (+ n 1) (+ i 1) (+ l 1)))\n          ((eq? (string-ref b i)\
    \ '#\\y) (loop (+ n 1) (+ i 1) (+ l 1)))", "  (cond [(empty? a) #t]\n        [(empty?\
    \ b) #f]\n        [(eqv? (car a) (car b)) #t]\n        [else (or (cycpattern_check\
    \ (cdr a) (cdr b)) (cycpattern_check a (cdr b)))]))\n", "  (cond ((string=? a\
    \ b)            #t)\n        ((or (string=? (string-rotate b 1) a)\n         \
    \    (string=? (string-rotate b 2) a)\n             (string=? (string-rotate b\
    \ 3) a)\n             (string=? (string-rotate b 4) a))\n         (string=? a\
    \ b))\n        (else #f)))\n", "  (cond [(or (string-char-at (string-length a)\
    \ 0) (string-char-at (string-length a) (string-length b))) (check-char b a)\n\
    \        (string-equal? a b) (check-string b a)\n        (else #f)]\n        [else\
    \ #t]))\n", "  (or (char=? b '()) \n      (char=? (first a) (first b)) \n    \
    \  (char=? (last a) (last b)) \n      (char=? (first b) (first a)) \n      (char=?\
    \ (last b) (last a))\n      (char=? (first b) (last a))\n      (char=? (last b)\
    \ (first a))))\n", "  (cond [(string-equal? (substring b 0 (string-length a))\
    \ a)\n         #f]\n        [(or (string-equal? (substring a 0 (string-length\
    \ b)) b)\n              (string-equal? (substring a 0 (string-length b)) (substring\
    \ b 0 (string-length b))))\n         #t]\n        [else #f]))\n", "  (or (string=?\
    \ (find a (string-append b b)) b)\n      (or (string=? (find b (string-append\
    \ a a)) a)\n          (string-equal? a b))))\n", "  (or (substring (substring\
    \ b 0)\n               (substring a 0)\n               (substring b (length a)))\n\
    \      (or (substring (substring a 0)\n                      (substring b (length\
    \ a)))\n          (substring (substring a (length b)) (substring b (length a)))))\n",
  "  (or (and (substring b 0 2) (substring a 0 2)) #t\n      (and (substring b 0 1)\
    \ (substring a 0 1)) #t\n      (and (substring b 0 1) (substring a 0 0)) #f\n\
    \      (and (substring b 0 2) (substring a 0 0)) #f\n      (and (substring b 0\
    \ 2) (substring a 0 1)) #f\n      (and (substring b 0 1) (substring a 0 2)) #f\n\
    \      (and (substring b 0 2) (substring a 0 2)) #f\n      (and (substring b 0\
    \ 2) (substring a 0 1)) #f\n      (and (substring b 0 1) (substring a 0 1)) #f\n\
    \      (and (substring b 0 1) (substring a 0 0)) #f\n      (and (substring b 0\
    \ 1) (substring a 0 2)) #f\n      (and (substring b 0 2) (substring a 0 0)) #f\n\
    \      (and (substring b 0 2) (substring a 0 1)) #f\n      (and (substring b 0\
    \ 2) (substring a 0 2)) #f\n      (and (substring b 0 1) (substring a 0 1)) #f\n\
    \      (and (substring b 0 2) (substring a 0 0)) #f\n      (and (substring b 0\
    \ 2) (substring a 0 1)) #f\n      (and (substring b 0 2) (substring a 0 2)) #f\n\
    \      (and (substring b 0 1) (substring a 0 0)) #f\n      (and (substring b 0\
    \ 2) (substring a 0 0)) #f\n      (and (substring b 0 2) (substring a 0 1)) #f\n\
    \      (and (substring b 0 2) (substring a 0 2)) #f\n      (and (substring b 0\
    \ 1) (substring a 0 0)) #f\n      (and (substring b 0 2) (substring a 0 0)) #f\n\
    \      (and (substring b 0 2) (substring a 0 1)) #f\n      (and (substring b 0\
    \ 2) (substring a 0 2)) #f\n      (and (substring b 0 1) (substring a 0 0)) #f\n\
    \      (and (substring b 0 2) (substring a 0 0)) #f\n      (and (substring b 0\
    \ 2) (substring a 0 1)) #f\n      (and (substring b 0 2) (substring a 0 2)) #f\n\
    \      (and (substring b 0 1) (substring a 0 0)) #f\n      (and (substring b 0\
    \ 2) (substring a 0 0)) #f", "  (cond [(string=? a b) #t]\n        [(string=?\
    \ (string-rotate a) (string-rotate b)) #t]\n        [else #f]))\n", "  (cond [(empty?\
    \ a) #f]\n        [(empty? b) #f]\n        [(string=? (substring a 0 b) (substring\
    \ b 0 a)) #t]\n        [else (cycpattern_check (substring a 0 b) (substring b\
    \ 0 a))]))\n", "  (equal (string-length a string-length b) (string-length a)))\n",
  '  (= (length a) (length b)))', "  (cond\n    ((empty? b) #f)\n    ((equal? (substring\
    \ a 0) (substring b 0)) #t)\n    ((equal? (substring a 1) (substring b 1)) #t)\n\
    \    ((equal? (substring a 0) (substring b 0)) #t)\n    ((equal? (substring a\
    \ 1) (substring b 1)) #f)))\n</cell>\n<cell>\n#lang racket\n", "  (or (equal?\
    \ (subseq a (length b)) b)\n      (member (subseq a (length b)) b)))\n", "  (or\
    \ (= (string-length a) (string-length b))\n      (let* ((a-chars (string->list\
    \ a))\n             (b-chars (string->list b))\n             (a (list->string\
    \ a-chars))\n             (b (list->string b-chars)))\n        (= (string-ref\
    \ (substring a 0 (string-length a))\n                      (string-ref (substring\
    \ b 0 (string-length b)))\n                      (string-ref (substring b 0 (string-length\
    \ b))))\n        (string-prefix-p a b))\n    (not (string-prefix-p a b))))\n",
  "  (cond (string=? a b)\n        #f\n        (string=? (substring (word a) 0 1)\
    \ (substring (word b) 0 1))\n        (cycpattern_check (word a) (substring (word\
    \ a) 1 length (word a)))\n        (cycpattern_check (substring (word b) 0 1) (word\
    \ b)))\n)\n", "  (cond\n    [(or (string=? a b) #t) (bool=? #t #f)\n     \n  \
    \  [(or (string=? b \"#t\") (string=? (string-reverse b) a)\n          (string=?\
    \ (string-reverse a) b)\n          (string=? (string-reverse b) (string-reverse\
    \ a)) #t)\n      (cond\n        [(string=? (string-reverse b) a) #t]\n       \
    \ [(string=? (string-reverse a) b) #t]\n        [(string=? (string-reverse b)\
    \ (string-reverse a) #t)]\n        [(string=? (string-reverse a) b) #t])]\n  \
    \    \n    [(or (string=? b \"#f\") (string=? (string-reverse b) a) #f)\n    \
    \ (cond\n       [(string=? (string-reverse b) a) #t]\n       [(string=? (string-reverse\
    \ a) b) #t]\n       [(string=? (string-reverse b) (string-reverse a) #t)]\n  \
    \     [(string=? (string-reverse a) b) #t])]\n\n    [(or (string=? b \"#f\") (string=?\
    \ (string-reverse b) (string-reverse a))) #t]\n    [(or (string=? b \"#t\") (string=?\
    \ (string-reverse b) (string-reverse a)) #f) #f]\n    [else #f]])\n  )\n", " \
    \ (or (eqv (string-length a) 0)\n      (eqv (string-length b) 0)\n      (or (member\
    \ (substring b 0 (string-length a))\n                   (substring a 0 (string-length\
    \ a))\n                  )\n          (member (substring b (string-length a) (-\
    \ string-length a))\n                   (substring a (string-length a) (- string-length\
    \ a))\n                  )\n          )\n      )\n  )\n", "  (cond ((and (list?\
    \ a) (string? a)) (cycpattern_check_lists b a))\n        (else (cycpattern_check_strings\
    \ b a))))\n", "  (or (equal? (car a) (car b))\n      (or (equal? (cdr a) (car\
    \ b))\n          (or (equal? (cdr a) (cdr b))\n              (equal? (cdr a) (substring\
    \ (cdr a) 0 1))))))\n", "  (or (string=? (string-ref a 0) (string-ref b 0))\n\
    \      (string=? (string-ref b 0) (string-ref a 0)))) ;; <-- This fixes the problem\n",
  "  (cond\n    [(empty? b) #f]\n    [(empty? a) #f]\n    [(equal? (car a) (car b))\
    \ #f]\n    [else (or (cycpattern_check (cdr a) b)\n               (or (cycpattern_check\
    \ (cdr (cdr a)) b)\n                   (cycpattern_check (cdr (cdr (cdr a))) b))))])\n",
  "  (cond\n    [(empty? a) #f]\n    [(empty? b) #f]\n    [(equal? (substr_upto (substr\
    \ b 1 1) a) (substr_upto (substr b 0 1)) a) #t]\n    [else (cycpattern_check (substr\
    \ b 0 1) a)]))\n", "  (cond ((or (eq? a b) #f)\n         #f)\n        ((string-match\
    \ (string-tail a) (string-tail b) #t #f)\n         (cycpattern_check (string-tail\
    \ a) b))\n        (else\n         (string-match (string-tail b) (string-tail a)\
    \ #f #f)\n         (cycpattern_check a (string-tail b)))\n  )\n", "  (or (equal?\
    \ (substring b 0 a) (substring a 0 b)) (cycpattern_check (substring b 0 a) (substring\
    \ a 0 b))))\n", "  (if (or (string-match a b)\n          (string-match (string-append\
    \ a b) (string-append a (b copy)))\n          (string-match (string-append a (b\
    \ copy)) b))\n      #t\n      #f))\n", "  (cond ((or (string-equal? a \"\")\n\
    \            (string-equal? b \"\"))\n         #f\n         (string-equal? (substring\
    \ a 0 (string-length a))\n                       (substring b 0 (string-length\
    \ b)))\n         #t)\n        ((or (string-equal? a \"\")\n            (string-equal?\
    \ b \"\"))\n         #f\n         (string-equal? (substring b 0 (string-length\
    \ b))\n                       (substring a 0 (string-length a)))\n         #t)\n\
    \        ((or (string-equal? a \"\")\n            (string-equal? b \"\"))\n  \
    \       #f\n         (equal? (substring b 0 (string-length b))\n             \
    \    (substring a 0 (string-length a)))\n         #t)\n        ((or (string-equal?\
    \ a \"\")\n            (string-equal? b \"\"))\n         #f\n         (equal?\
    \ (substring a 0 (string-length a))\n                 (substring b 0 (string-length\
    \ b)))\n         #t)\n        ((or (string-equal? a \"\")\n            (string-equal?\
    \ b \"\"))\n         #f\n         (equal? (substring a 0 (string-length a))\n\
    \                 (substring a 0 (string-length a)))\n         #t)\n        ((or\
    \ (string-equal? a \"\")\n            (string-equal? b \"\"))\n         #f\n \
    \        (equal? (substring a 0 (string-length a))\n                 (substring\
    \ b 0 (string-length a)))\n         #t)\n        (else #f)))\n", "  (or (string=?\
    \ (rotate b a)\n                  (rotate a b))\n      (let ((o1 (rotate a (b-str\
    \ b))))\n        (or (string=? (rotate a o1)\n                      (rotate b\
    \ o1))\n            (string=? (rotate b o1)\n                      (rotate a o1))))))\n",
  "  (if (or (substring a 0 (string-length a))\n          (substring b (string-length\
    \ a) (string-length b)))\n      (let ((a (substring a 0 (string-length a))))\n\
    \        (or (substring b 0 (string-length b))\n            (substring a (string-length\
    \ a) (string-length b))))\n      #f))\n", "  (cond [(or (not (substring b a))\n\
    \             (equal? (substring b a) b))\n         #f]\n        [else\n     \
    \    (cond [(equal? (substring b a) (substring b a))\n                #t]\n  \
    \             [else\n                #f]))\n</code>\n<|/ a dscore=2 |>\n<| c |>\n\
    thanks for the comment! I appreciate that. BTW, the question asked for substring,\
    \ not subset.\n<|/ c |>\n<| a tags=racket,string |>\nThe simplest way is probably\
    \ to build a lookup table where you can look up whether or not a word is a substring\
    \ of another. You could do that by turning the string into an array of characters\
    \ and then using a hash table to do the lookup.\n<code>", "  (cond\n    [(string-equal\
    \ b \"\")              #t]\n    [(string-contains-word? a b)      #t]\n    [else\
    \                         (cycle-instruction b a)]\n  ))\n", "  (or (string-contains-substring\
    \ b a) (string-contains-substring (make-rotated a) b)))\n", "  (cond\n    [(or\
    \ (string-match a (string-reverse b)) (string-match a b)) #t]\n    [else #f]))\n",
  "  (or\n   (member a b)\n   (memb (subseq b 0) a)))\n</code>\n<|/ a |>\n<| c |>\n\
    I guess my mistake was trying to implement this as I started thinking I wanted\
    \ a boolean function that returns true or false, not a function that returns a\
    \ boolean value.\n<|/ c |>\n<| c |>\n\"boolean function\" as in \"an operation\
    \ that returns a boolean value\", right? So \"memb\" returns `#f` if the first\
    \ word doesn't contain the second? I don't think that's what he wanted either.\n\
    <|/ c |>\n<| c |>\n\"memb\" returns #f if the first word doesn't contain the second,\
    \ which is what he wants, because he wants to check if the first word is a substring\
    \ of the second word. I think the question was a little ambiguous and I thought\
    \ he meant \"substring\" when he said \"substring\" in the comment above.\n<|/\
    \ c |>\n<| c |>\nHe might just be thinking of \"substring\" as more of a \"substring\"\
    \ than a \"substring\" as in a regex match. But it turns out he also wants \"\
    substring\" to mean \"a substring that starts at the beginning of the string and\
    \ ends at the end of the string\", which is what `subseq` does - it finds the\
    \ first occurrence of a substring that occurs somewhere in the string. I'm really\
    \ not sure why he wants to check for substrings though (maybe he wants to see\
    \ if every word in the second string is in first string?).\n<|/ c |>\n<| c |>\n\
    , you are correct, I meant substring as in \"a string that is contained somewhere\
    \ in the first string\". I need to clarify my original post.\n<|/ c |>\n<| a tags=racket,substring\
    \ |>\nI suspect that your question is not what you intended, but it might be useful\
    \ to see how this might work in terms of regular expressions:\n<code>", "  (cond\
    \ ((null? a) (null? b))\n        ((string-equal? (substring-of b a) a) t)\n  \
    \      (else (substring b 0 (- (length a) (length b))\n                      \
    \ (cycpattern_check (substring a 0 1) (substring b (- (length a) (length b))))))))\n\
    </code>\n<|/ a dscore=1 |>\n<| c |>\nWhy do you think OP is looking for substring\
    \ in a string - why not check for prefix and postfix also? And what is your solution?\
    \ Please do not answer this type of questions.\n<|/ c |>\n<| c |>\nOkay, I thought\
    \ OP was looking for substring in the string too. My mistake.\n<|/ c |>\n<| c\
    \ |>\n`substring b 0 (- (length a) (length b))` should be `(substring b 0 (- (length\
    \ a) (length b)))` else you get a `subscript-out-of-range` error.\n<|/ c |>\n\
    <| a |>\nOk, I've had a go at trying to implement your solution using a recursive\
    \ approach:\n<code>", "  (cond\n    [(empty? b) #t]\n    [(empty? a) #f]\n   \
    \ [(member (caar b) a)\n     (caddr b 0)]\n    [else\n     (begin (cycpattern_check\
    \ (cdr b) a)\n            (eqv? (caddr b 0) (cddr b 0))\n            (member (car\
    \ b) a))]))\n", "  (cond ((or (string=? a b) #t) true)\n        (else (string=?\
    \ (rotate a) (rotate b)) true)\n        (else (cycpattern_check (rotate a) (rotate\
    \ b))))\n)\n", "  (cond\n    [(or (equal? (string-length a) (string-length b))\n\
    \         (equal? (string-length b) (string-length a))\n         (equal? a b))\n\
    \     (or (equal? (string-length a) (string-length b))\n         (equal? (string-length\
    \ b) (string-length a))\n         (equal? b a))\n     (equal? (string-contains\
    \ b a)\n            #t)\n     (equal? (string-contains b a)\n            #f)]\n\
    \    [(equal? (string-contains b a)\n            #f)\n     (equal? (string-contains\
    \ b a)\n            #t)\n     (equal? (string-contains b a)\n            #f)]\n\
    \    [(equal? (string-contains b a)\n            #f)\n     (equal? (string-contains\
    \ b a)\n            #f)\n     (equal? (string-contains b a)\n            #t)\n\
    \     (equal? (string-contains b a)\n            #t)]\n    [else (equal? (string-contains\
    \ b a)\n                #f)]))\n", "  (cond\n    ((equal? (string-length a) (string-length\
    \ b)) #t)\n    ((equal? (string-length a) (string-length b)) #t)\n    ((equal?\
    \ (string-length a) (string-length b)) #t)\n    ((equal? (string-length a) (string-length\
    \ b)) #t)\n    ((equal? (string-length a) (string-length b)) #t)\n    ((equal?\
    \ (string-length a) (string-length b)) #t)\n    ((equal? (string-length a) (string-length\
    \ b)) #t)\n    ((equal? (string-length a) (string-length b)) #t)\n    ((equal?\
    \ (string-length a) (string-length b)) #t)\n    ((equal? (string-length a) (string-length\
    \ b)) #t)\n    ((equal? (string-length a) (string-length b)) #t)\n    ((equal?\
    \ (string-length a) (string-length b)) #t)\n    ((equal? (string-length a) (string-length\
    \ b)) #t)\n    ((equal? (string-length a) (string-length b)) #t)\n    ((equal?\
    \ (string-length a) (string-length b)) #t)\n    ((equal? (string-length a) (string-length\
    \ b)) #t)\n    ((equal? (string-length a) (string-length b)) #t)\n    ((equal?\
    \ (string-length a) (string-length b)) #t)\n    ((equal? (string-length a) (string-length\
    \ b)) #t)\n    ((equal? (string-length a) (string-length b)) #t)\n    ((equal?\
    \ (string-length a) (string-length b)) #t)\n    ((equal? (string-length a) (string-length\
    \ b)) #t)\n    ((equal? (string-length a) (string-length b)) #t)\n    ((equal?\
    \ (string-length a) (string-length b)) #t)\n    ((equal? (string-length a) (string-length\
    \ b)) #t)\n    ((equal? (string-length a) (string-length b)) #t)\n    ((equal?\
    \ (string-length a) (string-length b)) #t)\n    ((equal? (string-length a) (string-length\
    \ b)) #t)\n    ((equal? (string-length a) (string-length b)) #t)\n    ((equal?\
    \ (string-length a) (string-length b)) #t)\n    ((equal? (string-length a) (string-length\
    \ b)) #t)\n    ((equal? (string-length a) (string-length b)) #t)\n    ((equal?\
    \ (string-length a) (string-length b)) #t)\n    ((equal? (string-length a) (string-length\
    \ b)) #t)", "  (if (or (not (member (first a) b)) (not (member (first b) a)))\n\
    \      #f\n      #t))\n", "  (or (equal? (string-length a) (string-length b))\n\
    \      (equal? (string-reverse a) (string-reverse b))))\n", "  (or (string=? (substring\
    \ a 0 3) (string-append \"#\" (b (substring a 0 3))))\n      (string=? (substring\
    \ a 0 2) (string-append \"#\" (b (substring a 0 2))))))\n", "  (or (eq? a b)\n\
    \      (memq a (substring b 0 a) (substring b a))))\n", "  (cond\n    [(string=?\
    \ b \"\") #f]\n    [(or (string=? (substring a 0 b) b) (substring a 0 b)\n   \
    \      (string=? (substring a (b (length a 1))) b))\n      #t]\n    [else #f]))\n\
    </code>\n<|/ a dscore=2 |>\n<| c |>\nWhat if I need a case insensitive version\
    \ of this?\n<|/ c |>\n<| c |>\njust change the `equal?` to `string-equal?`\n<|/\
    \ c |>\n<| c |>\nI've already tried that and it is saying 'string-equal?' is not\
    \ a function of object 'substring.\n<|/ c |>\n<| c |>\nYou have to add the `string`\
    \ type to that function: `(string=? (substring a 0 b) b)`\n<|/ c |>\n<| c |>\n\
    If it's not a function of substring, how do I get the substring length? What should\
    \ I be doing to accomplish this?\n<|/ c |>\n<| a dscore=2 tags=racket,scheme |>\n\
    <code>", "  (if (string-length b < string-length a)\n      #f\n      (or (string-inclusion?\
    \ b a) \n          (cycpattern_check b a-rot)))))\n", "  (cond\n    [(equal? (substring\
    \ a 0) (substring b 0))\n     (equal? (substring b 0) (substring a 0))]\n    [(equal?\
    \ (length a) (length b))\n     (equal? (string-compare (substring a 0) (substring\
    \ b 0))\n             (string-compare (substring b 0) (substring a 0)))]\n   \
    \ [(equal? (length a) (length b))\n     (equal? (string-compare (substring a 0)\
    \ (substring b 0))\n             (string-compare (substring b 0) (substring a\
    \ 0))\n             (string-compare (substring a 0) (substring b 0)))]\n    [else\n\
    \     (equal? (string-compare (substring a 0) (substring b 0))\n             (string-compare\
    \ (substring b 0) (substring a 0))\n             (string-compare (substring a\
    \ 0) (substring b 0))\n             (string-compare (substring a 0) (substring\
    \ b 0)))]\n  ))", "  (cond\n    [(string=? (string-length a) (string-length b))\
    \ #t]\n    [(string=? (string-length a) (string-length b) (string-index a 0 (string-index\
    \ b (string-length b))))\n     #t]\n    [(string=? (string-length a) (string-length\
    \ b) (string-index a 0 (string-index b 0 (string-length b))))\n     #t]\n    [(string=?\
    \ (string-length a) (string-length b) (string-index a 0 (string-index b (string-length\
    \ b) (string-index b 0 (string-length b))))\n     #t]\n    [(string=? (string-length\
    \ a) (string-length b) (string-index a 0 (string-index b (string-length b) (string-index\
    \ b (string-length b) (string-index b 0 (string-length b))))\n     #t]\n    [(string=?\
    \ (string-length a) (string-length b) (string-index a 0 (string-index b (string-length\
    \ b) (string-index b (string-length b) (string-index b (string-length b) (string-index\
    \ b 0 (string-length b))))))\n     #t]\n    [(member b (string-ref a 0))\n   \
    \  #t]\n    [(member b (string-ref a (- 1 (string-length a))))\n     #t]\n   \
    \ [(member b (string-ref a (- 1 (string-length a) (string-index a (- 1 (string-length\
    \ a) 0))))\n     #t]\n    [(member b (string-ref a (- 1 (string-length a) (string-index\
    \ a (- 1 (string-length a) (string-index a (- 1 (string-length a) 0))))\n    \
    \ #t]\n    [(member b (string-ref a (- 1 (string-length a) (string-index a (-\
    \ 1 (string-length a) (string-index a (- 1 (string-length a) (string-index a (-\
    \ 1 (string-length a) 0))))\n     #t]\n    [(member b (string-ref a (- 1 (string-length\
    \ a) (string-index a (- 1 (string-length a) (string-index a (- 1 (string-length\
    \ a) (string-index a (- 1 (string-length a) (string-index a (- 1 (string-length\
    \ a) (string-index a (- 1 (string-length a) 0))))\n     #t]\n    [(member b (string-ref\
    \ a (- 1 (string-length a) (string-index a (- 1 (string-length a) (string-index\
    \ a (- 1 (string-length a) (string-index a (- 1 (string-length a) (string-index\
    \ a (- 1 (string-length a) (string-index a (- 1 (string-length a) (string-index\
    \ a (- 1 (string-length a) 0))))\n     ", "  (or (eq? (string-index a b) (string-index\
    \ b a))\n      (= (string-index b (substring a (string-index a 0 0)) (string-index\
    \ (substring a 0 0) b)) (string-index (substring a 0 b) (string-index a b)))))\
    \ ; substring b\n</code>\n<|/ a tags=string,racket,scheme |>\n<| c |>\nIt's an\
    \ exercise from HtDP in SICP. Thank you for your answer\n<|/ c |>\n<| c |>\nI\
    \ tried to do it with your function, I changed a little bit, because I didn't\
    \ understand the `(define (cycpattern_check a b)\n  (or (eq? (string-index a b)\
    \ (string-index b a))\n      (= (string-index b (substring a (string-index a 0\
    \ 0)) (string-index (substring a 0 0) b)) (string-index (substring a 0 b) (string-index\
    \ a b))))` line. Thank you!\n<|/ c |>\n<| c |>\nThis answer does not work in Racket\
    \ - I got the following error: expected a constant expression, but found an expression\
    \ in an assignment: `'()\n<|/ c |>\n<| c |>\nIt doesn't work for me... Racket\
    \ 5.3.5, Scheme R5RS http://docs.racket-lang.org/srfi/srfi-25/srfi-25.html\n<|/\
    \ c |>\n<| a |>\nThe problem is that, in the second line, you compare 'abc' and\
    \ 'abd', which are different strings:\n<code>\n> (string-index 'abc 'abd)\n0\n\
    </code>\nSo that means, in the second line in the last line, you get an error:\n\
    <code>\n> (define (cycpattern_check a b)\n  (or (eq? (string-index a b) (string-index\
    \ b a))\n      (= (string-index b (substring a (string-index a 0 0)) (string-index\
    \ (substring a 0 0) b)) (string-index (substring a 0 b) (string-index a b)))))\n\
    > (cycpattern_check 'abc 'abd)", "  (cond ((or (string-match a b) (substring-match\
    \ a b)) #t)\n        (else #f)))\n", "  (= (length a) (length b))\n  (or (equal?\
    \ (substring a 0 (length a)) b) (equal? (substring b (length a) 0) a)))\n", " \
    \ (cond [(or (string=? a b)\n            (string=? b (string-append a b)))\n \
    \        #t]\n        [else (any? (string=? (string-reverse a) b)\n          \
    \       (string=? (string-reverse b)\n                            (string-append\
    \ (substring a 0 1)\n                                         (substring b 0 1))))]))\n",
  "  (or (string-equal? (substring a 0 (string-length b)) b)\n      (substring-equal?\
    \ (substring b (string-length a)) a)))\n", "  (or (cycpattern_check_rot1 a b)\n\
    \      (cycpattern_check_rot2 a b)))\n", "  (cond ((or (string-match a \"\") #t)\
    \ (string-match b \"\"))\n        ((or (string-match a b) #t) (string-match a\
    \ b))\n        (else #t)))\n", "  (cond ((string-match a b) #t)\n        ((string=?\
    \ (string->list a) (string->list b)) #t)\n        (else #f)))\n\n", "  (or (string-subset?\
    \ a b)\n      (string-subset? b a)\n      (string-subset? (string-reverse a) (string-reverse\
    \ b))))\n", "  (if (string=? b (string-append a b))\n      (substring-match-p\
    \ a b)\n      (let ((b (substring b (string-length a))))\n        (if (string=?\
    \ b (string-append a b))\n            (substring-match-p a b)\n            (cycpattern_check\
    \ a b)))))\n", "  (let ([a (cycpattern_check a (achar)) b (cycpattern_check b\
    \ (achar))]\n        [a-rotated1 (append (cycpattern_rotate a (length a)) (cycpattern_rotate\
    \ (substring a 0 (length a)) (length a)))]\n        [b-rotated1 (append (cycpattern_rotate\
    \ b (length b)) (cycpattern_rotate (substring b 0 (length b)) (length b)))]\n\
    \        [a-rotated2 (append (cycpattern_rotate a-rotated1 (length a-rotated1))\
    \ (cycpattern_rotate (substring a-rotated1 0 (length a-rotated1)) (length a-rotated1)))]\n\
    \        [b-rotated2 (append (cycpattern_rotate b-rotated1 (length b-rotated1))\
    \ (cycpattern_rotate (substring b-rotated1 0 (length b-rotated1)) (length b-rotated1)))]\n\
    \        [a-rotated3 (append (cycpattern_rotate a-rotated2 (length a-rotated2))\
    \ (cycpattern_rotate (substring a-rotated2 0 (length a-rotated2)) (length a-rotated2)))]\n\
    \        [b-rotated3 (append (cycpattern_rotate b-rotated2 (length b-rotated2))\
    \ (cycpattern_rotate (substring b-rotated2 0 (length b-rotated2)) (length b-rotated2)))]\n\
    \        [a-rotated4 (append (cycpattern_rotate a-rotated3 (length a-rotated3))\
    \ (cycpattern_rotate (substring a-rotated3 0 (length a-rotated3)) (length a-rotated3)))]\n\
    \        [b-rotated4 (append (cycpattern_rotate b-rotated3 (length b-rotated3))\
    \ (cycpattern_rotate (substring b-rotated3 0 (length b-rotated3)) (length b-rotated3)))]\n\
    \        [a-rotated5 (append (cycpattern_rotate a-rotated4 (length a-rotated4))\
    \ (cycpattern_rotate (substring a-rotated4 0 (length a-rotated4)) (length a-rotated4)))]\n\
    \        [b-rotated5 (append (cycpattern_rotate b-rotated4 (length b-rotated4))\
    \ (cycpattern_rotate (substring b-rotated4 0 (length b-rotated4)) (length b-rotated4)))]\n\
    \        [a-rotated6 (append (cycpattern_rotate a-rotated5 (length a-rotated5))\
    \ (cycpattern_rotate (substring a-", "  (cond\n    [(equal? (string-match a b)\
    \ #t) (eq? a b)] \n    [(equal? (string-match a b) #f) (equal? (string-match a\
    \ (b rotated)) #t)]\n    [else #f]))\n", "  (cond [(or (eq? a b) (eq? b (substring\
    \ a 0 0))) true]\n        [(eq? a b) false]\n        [(eq? (substring a 0 0) (substring\
    \ b 0 0)) (substring a 0 0) (cycpattern_check (substring a 0 0) b)]\n        [else\
    \ (cycpattern_check (substring a 0 0) (substring b 0 0))]))\n", "  (or ((and (substring\
    \ b (length a)) (substring a 0))\n      (and (substring a 0)\n           (substring\
    \ b (length a)))\n      (and (substring a 0)\n           (substring b (length\
    \ a) (+ 1 0)))\n      (and (substring a 0)\n           (substring b (length a)\
    \ (+ 1 1)))\n      (and (substring a 0)\n           (substring b (length a) (+\
    \ 1 2)))\n      (and (substring a 0)\n           (substring b (length a) (+ 1\
    \ 3)))\n      (and (substring a 0)\n           (substring b (length a) (+ 1 4)))\n\
    \      (and (substring a 0)\n           (substring b (length a) (+ 1 5)))\n  \
    \    (and (substring a 0)\n           (substring b (length a) (+ 1 6)))\n    \
    \  (and (substring a 0)\n           (substring b (length a) (+ 1 7)))\n      (and\
    \ (substring a 0)\n           (substring b (length a) (+ 1 8)))\n      (and (substring\
    \ a 0)\n           (substring b (length a) (+ 1 9)))\n      (and (substring a\
    \ 0)\n           (substring b (length a) (+ 1 10))))\n      ((and (substring b\
    \ (length a) (+ 1 0))\n           (substring a 0))\n      (and (substring a 0)\n\
    \           (substring b (length a) (+ 1 1)))\n      (and (substring a 0)\n  \
    \         (substring b (length a) (+ 1 2)))\n      (and (substring a 0)\n    \
    \       (substring b (length a) (+ 1 3)))\n      (and (substring a 0)\n      \
    \     (substring b (length a) (+ 1 4)))\n      (and (substring a 0)\n        \
    \   (substring b (length a) (+ 1 5)))\n      (and (substring a 0)\n          \
    \ (substring b (length a) (+ 1 6)))\n      (and (substring a 0)\n           (substring\
    \ b (length a) (+ 1 7)))\n      (and (substring a 0)\n           (substring b\
    \ (length a) (+ 1 8)))\n      (and (substring a 0)\n           (substring b (length\
    \ a) (+ 1 9)))\n      (and (substring a 0)\n           (substring b (length a)\
    \ (+ 1 10))))))\n", "  (cond\n    ((empty? a) #f)\n    ((empty? b) #f)\n    ((string=\
    \ (substring a 0 (length a))\n              (substring b 0 (length b))) #t)\n\
    \    (else #f)))\n", "  (cond ((or (string=? a \"\") (string=? b \"\")) #f) ;\
    \ don't check for empty strings\n        ((string=? a \"#t\") (= (cycpattern_check\
    \ (substring b 0 2) (substring a 0 2)) #t))\n        ((string=? a \"#f\") (= (cycpattern_check\
    \ (substring b 0 2) (substring a 0 2)) #f))\n        ((string=? b \"#t\") (= (cycpattern_check\
    \ (substring a 0 2) (substring b 0 2)) #t))\n        ((string=? b \"#f\") (= (cycpattern_check\
    \ (substring a 0 2) (substring b 0 2)) #f))\n        ((string=? (substring b 0\
    \ 2) (substring a 0 2)) #t) ; substring match\n        ((string=? (substring b\
    \ 0 2) (substring a 0 2)) #f) ; substring match\n        ((string=? (substring\
    \ a 0 2) (substring b 0 2)) #t) ; substring match\n        ((string=? (substring\
    \ a 0 2) (substring b 0 2)) #f) ; substring match\n        (else #f))) ; all other\
    \ cases are false\n", "  (or (equal? a b)\n      (substring b 0 (= (length a)\
    \ (length b)))\n      (substring? (substring a 0 (- (length a) (length b))) b)))\n",
  "  (cond\n    [(or (string-match a \"\\\\A.*\\\\b\" b) #t)\n     (cond\n       [(or\
    \ (string-match a \"\\\\b\" b) #t) (or\n                                     \
    \   (or\n                                           (string-match a \"\\\\A.*\\\
    \\b\" b)\n                                           (string-match a \"\\\\b\"\
    \ b))\n                                        #t)\n         ;; a is a substring\
    \ of b\n         ;; a's last letter could be a letter of b\n         (string-match\
    \ \"\\\\b\" b)\n         (string-match \"\\\\A.*\\\\b\" b)]\n      [else #f]))\n\
    \    ((or\n       (string-match a \"\\\\b\" b)\n       (string-match \"\\\\A.*\\\
    \\b\" b))\n     (cond\n       [(string-match \"\\\\b\" b) #t]\n      [else #f]))\n\
    \    [else #f]))\n", "  (or (string-equal? (string-ref a 1) (string-ref b 0))\n\
    \      (string-equal? (string-ref b 0) (string-ref a 1))\n      (let ((c (string-ref\
    \ a 0))\n            (d (string-ref b 0)))\n        (not (string-equal? (string-ref\
    \ b 0) (string-ref a 1))\n             (string=? c d (cycpattern_check d c))))))",
  "  (cond\n    [(string-equal a b) #t]\n    [(substring a #0? b) #t]\n    [(substring\
    \ a #1? b) #t]\n    [(substring a #1? #0? b) #t]\n    [(substring a #0? #1? b)\
    \ #t]\n    [(substring a #1? #0? #1? b) #t]\n    [(substring a #2? #0? b) #t]\n\
    \    [(substring a #2? #1? b) #t]\n    [(substring a #2? #1? #0? b) #t]\n    [(substring\
    \ a #2? #0? #1? b) #t]\n    [(substring a #2? #1? #0? #1? b) #t]\n    [(substring\
    \ a #2? #2? b) #t]\n    [(substring a #2? #2? #0? b) #t]\n    [(substring a #2?\
    \ #2? #1? b) #t]\n    [(substring a #2? #2? #1? #0? b) #t]\n    [(substring a\
    \ #2? #2? #0? #1? b) #t]\n    [(substring a #2? #2? #0? #1? #1? b) #t]\n    [(substring\
    \ a #2? #2? #1? #1? #0? b) #t]\n    [(substring a #2? #2? #1? #1? #0? #1? b) #t]\n\
    \    [(substring a #2? #2? #2? b) #t]\n    [(substring a #2? #2? #2? #0? b) #t]\n\
    \    [(substring a #2? #2? #2? #1? b) #t]\n    [(substring a #2? #2? #2? #1? #0?\
    \ b) #t]\n    [(substring a #2? #2? #2? #1? #0? #1? b) #t]\n    [(substring a\
    \ #2? #2? #2? #0? #1? #1? b) #t]\n    [(substring a #2? #2", "  (cond ((null?\
    \ a) b)\n        ((and (or (string=? (substring a 0 1) b)\n                  \
    \ (string=? (substring a 0 -1) b))\n              (substring a 1 0))\n       \
    \  (or (cycpattern_check (substring a 1 0)\n                               (substring\
    \ a 0 -1))\n             (cycpattern_check (substring a 1 0)\n               \
    \                (substring a 0 1)))\n         (cycpattern_check (substring a\
    \ 1 0)\n                               (substring a 0 1))))\n        (#t #f)))\n",
  "  (cond ((or (string-match \"(#\\\\{)\" a) (string-match \"(#\\\\{)\" b))\n   \
    \      (string-match \"(#\\\\{)\" b))\n        ((or (string-match \"(#\\\\{)\"\
    \ a) (string-match \"(#\\\\{)\" b))\n         (string-match \"(#\\\\{)\" a))\n\
    \        ((or (string-match \"(#\\\\{)\" a) (string-match \"(#\\\\{)\" b))\n \
    \        (string-match \"(#\\\\{)\" a))\n        ((string-match \"(#\\\\{)\" a)\
    \ (string-match \"(#\\\\{)\" b))\n         (string-match \"(#\\\\{)\" b))\n  \
    \      ((string-match \"(#\\\\{)\" a) (string-match \"(#\\\\{)\" b))\n       \
    \  (string-match \"(#\\\\{)\" b))\n        (else\n         (string-match \"(#\\\
    \\{)\" b))\n        (else #f)))\n", "  (cond\n    [(or (string=? a \"\")\n   \
    \       (string=? b \"efef\"))\n     (if (string=? a b)\n         (if (substring\
    \ a 0)\n             (substring b 0)\n             (substring b (substring b 0)\
    \ 0))\n         #f)]\n    [else #f]\n    [else #f]\n    [else #f]\n    [else #f]\n\
    \    [else #f]\n    [else #f]\n    [else #f]\n    [else #f]\n    [else #f]\n \
    \   [else #f]\n    [else #f]\n    [else #f]\n    [else #f]\n    [else #f]\n  \
    \  [else #f]\n    [else #f]\n    [else #f]\n    [else #f]\n    [else #f]\n   \
    \ [else #f]\n    [else #f]\n    [else #f]\n    [else #f]\n    [else #f]\n    [else\
    \ #f]\n    [else #f]\n    [else #f]\n    [else #f]\n    [else #f]\n    [else #f]\n\
    \    [else #f]\n    [else #f]\n    [else #f]\n    [else #f]\n    [else #f]\n \
    \   [else #f]\n    [else #f]\n    [else #f]\n    [else #f]\n    [else #f]\n  \
    \  [else #f]\n    [else #f]\n    [else #f]\n    [else #f]\n    [else #f]\n   \
    \ [else #f]\n    [else #f]\n    [else #f]\n    [else #f]\n    [else #f]\n    [else\
    \ #f]\n    [else #f]\n    [else #f]\n    [else #f]\n    [else #f]\n    [else #f]\n\
    \    [else #f]\n    [else #f]\n    [else #f]\n    [else #f]\n    [else #f]\n \
    \   [else #f]\n    [else #f]\n    [else #f]\n    [else #f]\n    [else #f]\n  \
    \  [else #f]\n    [else #f]\n    [else #f]\n    [else #f]\n    [else #f]\n   \
    \ [else #f]\n    [else #f]\n    [else #f]\n    [else #f]\n    [else #f]\n    [else\
    \ #f]\n    [else #f]\n    [else #f]\n    [else #f]\n    [else #f]\n    [else #f]\n\
    \    [else #f]\n    [else #f]\n    [else #f]\n    [else #f]\n    [else #f]\n \
    \   [else #f]\n    [else #f]\n    [else #f]\n    [else #f", "  (let ((len (string-length\
    \ a #\\space)))\n    (cond [(or (not (string-contains b a)) (<= (length a) (length\
    \ b)) (< (length b) len))\n           #t]\n          [else\n           (cond [(or\
    \ (string-contains b a-1 #\\space) (string-contains b a-1 #\\newline))\n     \
    \           #t]\n                  [else\n                  (cycpattern_check\
    \ (cdr a) b)]))))\n", "  (cond [(empty? a) (equal? b empty?)]\n        [(empty?\
    \ b) (foldr equal? empty a)]\n        [else (equal? (first (last (rotate b (substring\
    \ a 0 length))) \n                                   (substring a 0 (- (length\
    \ a) \n                                                 (length b))))\n      \
    \               empty?)]))\n", "  (or (equal? (string=? b a) true)\n      (and\
    \ (equal? (string=? a b) true)\n          (or (cycpattern_check (substring b 0\
    \ 1) a)\n              (cycpattern_check (substring a 0 1) b)))))\n", "  (or (substring\
    \ b 0) (substring a 0)\n      (or (string-match \"#*#\" b) (string-match \"#*#\"\
    \ a)))) ;; #lang racket\n", "  (or (string-equal? (list-ref a 0) (list-ref b 0))\n\
    \      (for/or ((x a) (y b))\n            (cond ((string-equal x y) #t)\n    \
    \              ((list-ref-rotations x 0) (list-ref y 0))\n                  ((list-ref-rotations\
    \ x 1) (list-ref y 1))\n                  ((list-ref-rotations x 2) (list-ref\
    \ y 2))\n                  ((list-ref-rotations x 3) (list-ref y 3))\n       \
    \           ((list-ref-rotations x 4) (list-ref y 4))\n                  ((list-ref-rotations\
    \ x 5) (list-ref y 5))\n                  ((list-ref-rotations x 6) (list-ref\
    \ y 6))\n                  ((list-ref-rotations x 7) (list-ref y 7))\n       \
    \           ((list-ref-rotations x 8) (list-ref y 8))\n                  ((list-ref-rotations\
    \ x 9) (list-ref y 9))\n                  ((list-ref-rotations x 10) (list-ref\
    \ y 10))\n                  ((list-ref-rotations x 11) (list-ref y 11))\n    \
    \              ((list-ref-rotations x 12) (list-ref y 12))\n                 \
    \ ((list-ref-rotations x 13) (list-ref y 13))\n                  ((list-ref-rotations\
    \ x 14) (list-ref y 14))\n                  ((list-ref-rotations x 15) (list-ref\
    \ y 15))\n                  ((list-ref-rotations x 16) (list-ref y 16))\n    \
    \              ((list-ref-rotations x 17) (list-ref y 17))\n                 \
    \ ((list-ref-rotations x 18) (list-ref y 18))\n                  ((list-ref-rotations\
    \ x 19) (list-ref y 19))\n                  ((list-ref-rotations x 20) (list-ref\
    \ y 20))\n                  ((list-ref-rotations x 21) (list-ref y 21))\n    \
    \              ((list-ref-rotations x 22) (list-ref y 22))\n                 \
    \ ((list-ref-rotations x 23) (list-ref y 23))\n                  ((list-ref-rotations\
    \ x 24) (list-ref y 24))\n                  ((list-ref-rotations x 25) (list-ref\
    \ y 25))\n                  ((list-ref-rotations x 26) (list-ref y 26))\n    \
    \              ((list-ref-rotations x 27) (list-ref y 27))\n                 \
    \ ((list-ref-rotations x 28) (list-ref y 28))\n                  ((list-ref-rotations\
    \ x 29) (list-ref y 29))\n                  ((list-ref-rot", "  (or\n   (and (eq\
    \ b \"\") (string-equal a b))\n   (or\n    (substring (string b) 0 (string-length\
    \ b)) ; checking for substring\n    (map (lambda (c) (car b)) (rotate-right1 (string\
    \ b)) ; checking for rotations\n      (lambda (r) (or (substring (b (- (string-length\
    \ a) r)) 0 r) (substring b 0 r)))))) ; checking for rotation\n", "  (cond\n  \
    \  ((empty? a) #t)\n    ((equal? a b) #f)\n    ((char-subset? a b)\n     (char-subset?\
    \ (first a) (first b)))\n    (else (cycpattern_check (rest a) b))\n  )\n)\n",
  "  (define (is-substring w s)\n    (and (eq? (string-length w) (string-length s))\n\
    \         (eql (string-downcase w) (string-downcase s))))\n  (and (is-substring\
    \ (branch a) (cons \"\" (branch a)))\n       (is-substring (branch b) (cons \"\
    \" (branch b))))\n  (and (is-substring (branch a) (cons \"\" (branch b)))\n  \
    \     (is-substring (branch b) (cons \"\" (branch a))))\n  (and (is-substring\
    \ (branch a) (cons \"\" b))\n       (is-substring (branch b) (cons \"\" a)))\n\
    \  (and (is-substring (branch a) (cons b (branch b)))\n       (is-substring (branch\
    \ b) (cons a (branch a))))\n  (and (is-substring (branch a) (cons (branch a) b))\n\
    \       (is-substring (branch b) (cons (branch b) a)))\n  (and (is-substring (branch\
    \ a) (cons (branch a) (branch b)))\n       (is-substring (branch b) (cons (branch\
    \ a) (branch b))))\n  (and (is-substring (branch a) (cons (branch b) a))\n   \
    \    (is-substring (branch b) (cons (branch a) (branch b))))\n  (and (is-substring\
    \ (branch a) (cons (branch a) (branch b)))\n       (is-substring (branch b) (cons\
    \ (branch a) (branch b))))\n  (and (is-substring (branch a) (cons b (branch a)))\n\
    \       (is-substring (branch b) (cons (branch b) a)))\n  (and (is-substring (branch\
    \ a) (cons b (branch b)))\n       (is-substring (branch b) (cons b (branch a))))\n\
    \  (and (is-substring (branch a) (cons b (branch b)))\n       (is-substring (branch\
    \ b) (cons b (branch b))))\n  (and (is-substring (branch a) (cons b (branch a)))\n\
    \       (is-substring (branch b) (cons b (branch a))))\n  (and (is-substring (branch\
    \ a) (cons b (branch b)))\n       (is-substring (branch b) (cons b (branch b))))\n\
    \  (and (is-substring (branch a) (cons b", "  (or (= (length a) (length b))\n\
    \      (= (length a) 0)\n      (= (length b) 0)\n      (mem-ref a (cycpattern_check\
    \ b (sub1 b)))))\n", "  (cond\n    [(empty? a) #f]\n    [(empty? b) #f]\n    [(member\
    \ (substring a 1 end) b) #t]\n    [else (cond [(member (substring a 1 end) b)\
    \ #t]\n                 [(member (substring b 1 end) a) #t]\n                \
    \ [else (cycpattern_check (substring b 1 end) (substring a 1 end))]))) ; recursion\
    \ case\n", "  ;; (cond (or (or (string=? a b) (string=? b a) (string-match a b))\
    \ (string-match b a)) #t #f) ; This one works but it's too slow - it would be\
    \ better to find a faster way to compare strings\n  (cond\n    ((or (string=?\
    \ a b) (string=? b a) (string-match a b)) #t)\n    ((string-match b a) #f)\n \
    \   ((string-match a b) #f)\n    ((string-match a b) #f)\n    (else #f)))", " \
    \ (or (string=? (string-ref b 0) (string-ref a 0))\n      (or (string=? (string-ref\
    \ a 0) (string-ref b 0))\n          (string=? (string-ref b 1) (string-ref a 1))\n\
    \          (string=? (string-ref b 2) (string-ref a 2))\n          (string=? (string-ref\
    \ b 3) (string-ref a 3))\n          (string=? (string-ref b 4) (string-ref a 4))\n\
    \          (string=? (string-ref b 5) (string-ref a 5))\n          (string=? (string-ref\
    \ b 6) (string-ref a 6))\n          (string=? (string-ref b 7) (string-ref a 7))))",
  "  (cond\n    [(empty? b) #t]\n    [(substring b 0)(empty? a) #f]\n    [(substring\
    \ b 0)#t]\n    [else\n     (if (member (substring a 0)(substring b 0))\n     \
    \    (cycpattern_check (substring b 0)(substring a 0))\n         (cycpattern_check\
    \ (substring a 0)(substring b 0)))]))\n", "  (cond\n    [(or (string-match a b)\
    \ #t)\n     (string-match a b)]\n    [else\n     (match (string-match b a)\n \
    \          [()\n            #t\n            #f\n            ((match (string-match\
    \ a (car (cdr (cdr b)))) \n                   [()\n                    #t\n  \
    \                  #f\n                    (match (string-match a (car (cdr (cdr\
    \ b)))) \n                          [()\n                           #t\n     \
    \                      #f\n                           (match (string-match a (car\
    \ (cdr (cdr b)))) \n                                   [()\n                 \
    \                   #t\n                                    #f\n             \
    \                       (match (string-match a (car (cdr (cdr b)))) \n       \
    \                                   [()\n                                    \
    \       #f\n                                           #f]\n                 \
    \                        (error (string-match-failure (string-match a b) a b)))]\n\
    \                                 (error (string-match-failure (string-match a\
    \ b) a b)))]\n                             (error (string-match-failure (string-match\
    \ a b) a b)))]\n                       (error (string-match-failure (string-match\
    \ a b) a b)))]\n             (error (string-match-failure (string-match a b) a\
    \ b)))]\n    [else\n     (match (string-match a b)\n           [()\n         \
    \   #t\n            #f\n            ((match (string-match a (car (cdr (cdr b))))\
    \ \n                   [()\n                    #t\n                    #f\n \
    \                   (match (string-match a (car (cdr (cdr b)))) \n           \
    \               [()\n                           #t\n                         \
    \  #f\n                           (match (string-match a (car (cdr (cdr b))))\
    \ \n                                   [()\n                                 \
    \   #t\n                                    #f\n                             \
    \       (match (string-match a (car (cdr (cdr b)))) \n                       \
    \                   [()\n                                           #f\n     \
    \                                      #f]\n                                 \
    \        (error (string-match-failure (string-match a b) a b)))]\n           \
    \                      (error (string-match-failure (string-match a b) a b)))]\n\
    \                             (error (string-match-failure (string-match a b)\
    \ a b)))]\n                       (error (string-match-failure (string-match a\
    \ b) a b)))]\n             (error (string-match-failure (string-match a b) a b)))]\n\
    \    [else\n     (match (string-match a b)\n           [()\n            #t\n \
    \           #f\n            ((match (string-match a (c", "  (cycpattern_aux\n\
    \   (lambda (p)\n     (if (null? p)\n         #t\n         (string-equal? (cdr\
    \ (last p)) b)\n         (string-equal? (car p) b)\n         (string-equal? (cdr\
    \ (last p)) (car p))))\n   (string a)))\n", "  (cond\n    [(or (string-match a\
    \ b) #t) (list-match a b)]\n    [else (equal? a b)]))\n", "  (cond (empty? a)\
    \ (empty? b) #f)\n  (cond ((null? a) (empty? b)) #f\n        (else (equal? (substring\
    \ a 0 (string-length a)) (substring b 0 (string-length b)))\n               (equal?\
    \ (substring a 0 (string-length a)) (cycpattern_check (substring b 1 (string-length\
    \ b)) a))\n               (equal? (substring a 0 (string-length a)) (cycpattern_check\
    \ b (substring a 1 (string-length a)))\n               (equal? (substring a 0\
    \ (string-length a)) (cycpattern_check b (substring a 1 (string-length a))))\n\
    \               (equal? (substring a 0 (string-length a)) (cycpattern_check b\
    \ (substring a 1 (string-length a))))\n               (equal? (substring a 0 (string-length\
    \ a)) (cycpattern_check b (substring a 1 (string-length a))))\n              \
    \ (equal? (substring a 0 (string-length a)) (cycpattern_check b (substring a 1\
    \ (string-length a))))\n               (equal? (substring a 0 (string-length a))\
    \ (cycpattern_check b (substring a 1 (string-length a))))\n               (equal?\
    \ (substring a 0 (string-length a)) (cycpattern_check b (substring a 1 (string-length\
    \ a))))\n               (equal? (substring a 0 (string-length a)) (cycpattern_check\
    \ b (substring a 1 (string-length a))))\n               (equal? (substring a 0\
    \ (string-length a)) (cycpattern_check b (substring a 1 (string-length a))))\n\
    \               (equal? (substring a 0 (string-length a)) (cycpattern_check b\
    \ (substring a 1 (string-length a))))\n               (equal? (substring a 0 (string-length\
    \ a)) (cycpattern_check b (substring a 1 (string-length a))))\n              \
    \ (equal? (substring a 0 (string-length a)) (cycpattern_check b (substring a 1\
    \ (string-length a))))\n               (equal? (substring a 0 (string-length a))\
    \ (cycpattern_check b (substring a 1 (string-length a))))\n               (equal?\
    \ (substring a 0 (string-length a)) (cycpattern_check b (substring a 1 (string-length\
    \ a))))\n               (equal? (substring a 0 (string-length a)) (cycpattern_check\
    \ b (substring a 1 (string-length a))))\n               (equal? (substring a 0\
    \ (string-length a)) (cy", "  (cond ((null? a) b)\n        ((substring a (cycle-k\
    \ b (length a (length b))))\n         (begin\n          (cycpattern_check (substring\
    \ a (+ 0 (length b)) (- 0 (length b)))\n                         (substring b\
    \ (+ 0 (length a)) (- 0 (length a))))\n          (begin #t (#t (substring a (cycle-k\
    \ b (length a (length b)))))))))\n", "  (cond [(ormap a '(#f #t)) #f]\n      \
    \  [(ormap b '(#f #t)) #f]\n        [else\n         (ormap a (string->list\n \
    \                (string-join (reverse (substring-all a b))\n                \
    \               (map string->string '(#t #f #t))))]))", "  (or (substring-match\
    \ a b)\n      (or (cycpattern_check (rotate_string a 1) b)\n          (substring-match\
    \ b (rotate_string a 2)))))\n", "  (cond\n    [(empty? b) #t]\n    [(symbol=?\
    \ (char-ref b 0) a) #t]\n    [(symbol=? (char-ref b 0) (cycpattern_shift a)) #t]\n\
    \    [else (symbol=? (char-ref b 0) (cycpattern_rotate a))]\n    ))\n", "  (cond\
    \ ((null? a) #f)\n        ((not (eq? a b))\n         (and (substring b 0)\n  \
    \            (substring a 0)))\n        (else (substring a 0)\n              (substring\
    \ b 0))\n        (else #f)))\n", "  (or (string=? b a)\n      (let ((r-a (reverse\
    \ a)))\n        (string=? (reverse b) (intersection r-a (b a)))\n      ))\n)\n",
  "  (or (string=? (substring b 0 a)\n                  (substring a 0 b))\n     \
    \ (map (lambda (x)\n             (if (string=? (substring b 0 x)\n           \
    \               (substring a 0 x))\n                 (cond ((string=? (substring\
    \ b 0 x)\n                                (substring a 0 x))\n               \
    \         (cond ((string=? (substring b 0 x)\n                               \
    \       (substring a 0 x))\n                               (cond ((string=? (substring\
    \ b 0 x)\n                                               (substring a 0 x))\n\
    \                                      (cond ((string=? (substring b 0 x)\n  \
    \                                                    (substring a 0 x))\n    \
    \                                         (cond ((string=? (substring b 0 x)\n\
    \                                                             (substring a 0 x))\n\
    \                                                    (cond ((string=? (substring\
    \ b 0 x)\n                                                                  (substring\
    \ a 0 x))\n                                                          (cond ((string=?\
    \ (substring b 0 x)\n                                                        \
    \                (substring a 0 x))\n                                        \
    \                        (cond ((string=? (substring b 0 x)\n                \
    \                                                                            \
    \    (substring a 0 x))\n                                                    \
    \                      #f)))))))))\n                       (else\n           \
    \             #f))))\n           a)))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
