name: HumanEval_60_sum_to_n
language: rkt
prompt: "#lang racket\n\n;; sum_to_n is a function that sums numbers from 1 to n.\n\
  ;; >>> (sum_to_n 30)\n;; 465\n;; >>> (sum_to_n 100)\n;; 5050\n;; >>> (sum_to_n 5)\n\
  ;; 15\n;; >>> (sum_to_n 10)\n;; 55\n;; >>> (sum_to_n 1)\n;; 1\n(define (sum_to_n\
  \ n)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate sum_to_n))\n\
  \    (check-equal? (candidate 1) 1)\n    (check-equal? (candidate 6) 21)\n    (check-equal?\
  \ (candidate 11) 66)\n    (check-equal? (candidate 30) 465)\n    (check-equal? (candidate\
  \ 100) 5050)\n))\n\n(test-humaneval)"
completions: ["  (if (= n 1)\n      n\n      (+ (* (sum_to_n (- n 1)) (- n 1))\n \
    \        (* (sum_to_n (- n 2)) (- n 2)))))\n", "  (let loop ((i 1))\n    (cond\
    \ ((> i n) 0)\n          (else (+ (* i n) (loop (+ i 1))))))))\n", "  (if (= n\
    \ 1)\n      n\n      (+ n (sum_to_n (- n 1)))))\n", "  (if (= n 0)\n      0\n\
    \      (+ (* n n) (sum_to_n (sub1 n)))))\n</code>\n<|/ a |>\n<| a dscore=1 |>\n\
    You can do it with tail recursion:\n<code>", "  (define (helper n sum accum)\n\
    \    (cond [(> n 0) (helper (- n 1) (+ sum accum) accum)]\n          [else (+\
    \ sum accum)]\n          ))\n  (helper n 0 0))\n", "  (lambda () (loop for i from\
    \ 0 to (- n 1) sum (+ i n))))\n", "  (+ (* n (+ (* n 3) 1) \n          (lambda\
    \ (n acc)\n            (if (= n 1)\n                acc\n                (begin\
    \ (set! acc (+ acc (* n (+ (* n 3) 1))))\n                       (lambda (n acc)\n\
    \                         (begin (set! acc (+ acc (* n (+ (* n 3) 1))))\n    \
    \                            (lambda (n acc)\n                               \
    \    (if (= n 1)\n                                       acc\n               \
    \                        (begin (set! acc (+ acc (* n (+ (* n 3) 1))))\n     \
    \                                     (lambda (n acc)\n                      \
    \                      (if (= n 1)\n                                         \
    \       acc\n                                                (begin (set! acc\
    \ (+ acc (* n (+ (* n 3) 1))))\n                                             \
    \         (lambda (n acc)\n                                                  \
    \      (if (= n 1)\n                                                         \
    \   acc\n                                                            (begin (set!\
    \ acc (+ acc (* n (+ (* n 3) 1))))\n                                         \
    \                           (lambda (n acc)\n                                \
    \                                      (if (= n 1)\n                         \
    \                                                 acc\n                      \
    \                                                    (begin (set! acc (+ acc (*\
    \ n (+ (* n 3) 1))))\n                                                       \
    \                       (lambda (n acc)\n                                    \
    \                                            (if (= n 1)\n                   \
    \                                                                 acc\n      \
    \                                                                            \
    \  (begin (set! acc (+ acc (* n (+ (* n 3) 1))))\n                           \
    \                                                               (lambda (n acc)\n\
    \                                                                            \
    \                (if (= n 1)\n                                               \
    \                                                 acc\n                      \
    \                                                                          (begin\
    \ (set! acc (+ acc (* n (+ (* n 3) 1))))\n                                   \
    \                                                                   (lambda (n\
    \ acc)\n                                                                     \
    \                                   (if (= n 1)\n                            \
    \                                                                            \
    \    acc\n                                                                   \
    \                                         (begin (set! acc (+ acc (* n (+ (* n\
    \ 3) 1))))\n                                                                 \
    \                                                 (lambda (n acc)\n          \
    \                                                                            \
    \                              (if (= n 1)\n                                 \
    \                                                                            \
    \           acc\n                                                            \
    \                                                            (begin (set! acc\
    \ (+ acc (* n (+ (* n 3) 1))))\n                                             \
    \                                                                            \
    \     (lambda (n acc)\n                                                      \
    \                                                                          (if\
    \ (= n 1)\n                                                                  \
    \                                                              acc\n         \
    \                                                                            \
    \                                           (begin (set! acc (+ acc (* n (+ (*\
    \ n 3) 1))))\n                                                               \
    \                                                                         (lambda\
    \ (n acc)\n                                                                  \
    \                                                              (if (= n 1)\n \
    \                                                                            \
    \                                                   acc\n                    \
    \                                                                            \
    \                                (begin (set! acc (+ acc (* n (+ (* n 3) 1))))\n\
    \                                                                            \
    \                                                            (lambda (n acc)\n\
    \                                                                            \
    \                                                    (if (= n 1)\n           \
    \                                                     ", "  (foldr (lambda (x\
    \ acc) (+ acc x)) 0 n))\n", "  (if (= n 0)\n      0\n      (+ (car lst)\n    \
    \     ((lambda () \n            (sum_to_n (- n 1)))))))\n", "  (define (sum-to-n\
    \ n acc i)\n    (if (< i n)\n        (+ acc (* i (+ i 1)))\n        acc))\n  (sum-to-n\
    \ n 0 1))\n", "  ;; sum_to_n returns a function whose input is the\n  ;; number\
    \ of terms summed.\n  ;; >>> sum_to_n(0)(0)(0)(0)(0)(0)(0)\n  ;; (0 1 1 2 3 5\
    \ 8)\n  (define (sum_to_n_aux a b c d e f g h)\n    (+ a (+ b (+ c (+ d (+ e (+\
    \ f g (+ h 0)))))))\n  (sum_to_n_aux 1 2 3 4 5 6 7 8))\n", "  (cond\n    [(= n\
    \ 0) 1]\n    [else (+ (* n (sum_to_n (- n 1))) 1)]))\n", "  (cond ((= n 1) 1)\n\
    \        ((= n 2) 2)\n        ((= n 3) (+ 3 4))\n        (else (+ (sum_to_n (-\
    \ n 1)) (* n 3)))))\n", "  (if (< n 0)\n      '()\n      (+ (add1 n) (sum_to_n\
    \ (sub1 n)))\n      )\n  )", "  (if (= n 1)\n      1\n      (+ (* n (sum_to_n\
    \ (- n 1))))))\n", "  (if (= n 0)\n      0\n      (+ (* n n) (sum_to_n (- n 1)))))\n",
  "  (define (iter sum i)\n    (if (< i n)\n        (iter (+ sum i) (+ i 1))\n   \
    \     sum))\n  (iter 0 0))\n", "  (define (helper sum number)\n    (if (= number\
    \ 0)\n        sum\n        (helper (+ sum number) (rest number))))\n  (helper\
    \ 0 n))\n", "  (+ (* n n) (sum_to_n (+ n 1))))\n", "  (if (zero? n)\n      0\n\
    \      (+ (* n n) (sum_to_n (- n 1)))))\n", "  (cond [(= n 0) 1]\n        [(=\
    \ n 1) 1]\n        [else (+ (sum_to_n (- n 1)) (+ n 1))]))\n", "  (cond [(= n\
    \ 0)\n         1]\n        [else (+ 1 (sum_to_n (- n 1)))]))\n", "  (define (sum-to-n\
    \ acc n)\n    (if (= n 0)\n        acc\n        (sum-to-n (+ acc (expt n 2)) (n-1)\
    \ )))\n  (sum-to-n 1 n))\n", "  (if (= n 1)\n      n\n      (+ (sum_to_n (- n\
    \ 1))\n         (* (- n 1) n))))\n", "  (if (= n 1)\n      n\n      (+ (* n (sum_to_n\
    \ (- n 1))))\n      )\n  )\n", "  (sum (range 1 (+ n 1))))\n</code>\n<|/ a tags=racket,scheme\
    \ |>\n<| c |>\n`(define (sum_to_n n) \n  (let ([sum (lambda (x) (+ x (if (= x\
    \ n) x 0)))]) \n    (lambda () sum)))`\n<|/ c |>\n<| c |>\nIf you use `let` to\
    \ create a named recursive function instead of `lambda`, you can avoid the extra\
    \ closure and `lambda` keywords.\n<|/ c |>\n<| a tags=racket,scheme |>\nI think\
    \ you asked this same question last year, and got many interesting answers.  But\
    \ today it's clear that it's about finding the sum of numbers from 1 to n, not\
    \ just counting up or down.  And I don't want to just give up on scheme.  I want\
    \ the code to run on any real racket implementation.\nHere's my answer.  And now\
    \ the code is just for fun -- not production code.  And it's just for fun.  And\
    \ I learned a lot.  \nThis answer uses Racket macros.  It uses some Racket macros.\
    \  \n<code>", "  (let loop ((sum 0)\n             (n n)\n             (acc 1))\n\
    \    (cond [(= n 0) acc]\n          [(< n 0) (loop (+ sum acc) (- n 1) 0)]\n \
    \         [(= 0 n) (loop (+ sum acc) (- n 1) 0)]\n          [else (loop (+ sum\
    \ acc) n (+ acc 1))])))\n</code>\n<|/ a |>\n<| a tags=racket,scheme |>\nIt's a\
    \ tail-recursive solution that doesn't use an accumulator:\n<code>", "  (define\
    \ (iter sum)\n    (if (< sum n)\n        sum\n        (iter (+ sum 1))))\n  (iter\
    \ 0))\n</code>\nThe trick is that sum is initially set to zero, and each iteration\
    \ of the function calls (the recursive call) adds one to the sum.\n<|/ a |>\n\
    <| a tags=scheme,recursion,racket |>\nA version using loop/recur:\n<code>", " \
    \ (+ (* n n) (sum_to_n (- n 1))))\n", "  (if (= n 0)\n      0\n      (+ n (sum_to_n\
    \ (- n 1)))))\n", "  (define (loop n total)\n    (if (= n 0)\n        total\n\
    \        (loop (- n 1) (+ total n))))\n  (loop n 0))\n", "  (define (sum-to-n\
    \ n sum)\n    (cond [(= n 0) sum]\n          [(= n 1) (+ 1 sum)]\n          [else\
    \ (sum-to-n (- n 1) (+ 1 sum))]))\n  (sum-to-n n 0))\n", "  (cond\n    ((= n 1)\
    \ 1)\n    ((= n 2) 2)\n    ((= n 3) (+ (* 3 3) (* 3 4)))\n    ((= n 4) (+ (* 4\
    \ 4) (* 4 5)))\n    ((= n 5) (+ (* 5 5) (* 5 6)))\n    ((= n 6) (+ (* 6 6) (*\
    \ 6 7)))\n    ((= n 7) (+ (* 7 7) (* 7 8)))\n    ((= n 8) (+ (* 8 8) (* 8 9)))\n\
    \    ((= n 9) (+ (* 9 9) (* 9 10)))\n    ((= n 10) (+ (* 10 10) (* 10 11)))\n\
    \    ((= n 11) (+ (* 11 11) (* 11 12)))\n    ((= n 12) (+ (* 12 12) (* 12 13)))\n\
    \    ((= n 13) (+ (* 13 13) (* 13 14)))\n    ((= n 14) (+ (* 14 14) (* 14 15)))\n\
    \    ((= n 15) (+ (* 15 15) (* 15 16)))\n    ((= n 16) (+ (* 16 16) (* 16 17)))\n\
    \    ((= n 17) (+ (* 17 17) (* 17 18)))\n    ((= n 18) (+ (* 18 18) (* 18 19)))\n\
    \    ((= n 19) (+ (* 19 19) (* 19 20)))\n    ((= n 20) (+ (* 20 20) (* 20 21)))\n\
    \    ((= n 21) (+ (* 21 21) (* 21 22)))\n    ((= n 22) (+ (* 22 22) (* 22 23)))\n\
    \    ((= n 23) (+ (* 23 23) (* 23 24)))\n    ((= n 24) (+ (* 24 24) (* 24 25)))\n\
    \    ((= n 25) (+ (* 25 25) (* 25 26)))\n    ((= n 26) (+ (* 26 26) (* 26 27)))\n\
    \    ((= n 27) (+ (* 27 27) (* 27 28)))\n    ((= n 28) (+ (* 28 28) (* 28 29)))\n\
    \    ((= n 29) (+ (* 29 29) (* 29 30)))\n    ((= n 30) (+ (* 30 30) (* 30 31)))\n\
    \    ((= n 31) (+ (* 31 31) (* 31 32)))\n    ((= n 32) (+ (* 32 32) (* 32 33)))\n\
    \    ((= n 33) (+ (* 33 33) (* 33 34)))\n    ((= n 34) (+ (* 34 34) (* 34 35)))\n\
    \    ((= n 35) (+ (* 35 35) (* 35 36", "  (define (sum_to_n' n acc)\n    (if (=\
    \ n 0)\n        acc\n        (sum_to_n' (sub1 n) (+ acc n))))\n  (sum_to_n' n\
    \ 0))\n", "  (if (= n 1)\n      1\n      (+ (* n (sum_to_n (- n 1))))))\n", " \
    \ (if (= n 0)\n      0\n      (+ (* n n) (sum_to_n (- n 1)))))\n", "  (sum (for\
    \ ([i n])\n          (if (= 0 i)\n              0\n              (+ (* i i) 1)))))\n",
  "  (cond\n    [(= n 0) 1]\n    [(= n 1) 1]\n    [else (+ 1 (sum_to_n (- n 1)))]))\n\
    </code>\n<|/ a tags=scheme,racket |>\n<| a tags=scheme,racket |>\nHere's my take\
    \ at it:\n<code>", "  (if (= n 1)\n      1\n      (+ (* n n) (sum_to_n (- n 1)))))\n",
  "  (if (= n 0)\n      n\n      (+ n (sum_to_n (- n 1)))))\n", "  (define (loop n\
    \ acc)\n    (cond [(< n 0) acc]\n          [else (loop (- n 1) (+ n acc))]))\n\
    \  (loop n 0))\n", "  (if (= n 0)\n      0\n      (+ (* n (sum_to_n (- n 1))))))\n",
  "  (define (sum-to-n n acc)\n    (cond ((= n 1) acc)\n          ((even? n) (sum-to-n\
    \ (- n 1) (+ acc n)))\n          (else (sum-to-n (- n 1) acc))))\n  (sum-to-n\
    \ n 0))\n", "  (define (sum-to-n x acc)\n    (if (zero? x)\n        acc\n    \
    \    (sum-to-n (sub1 x) (+ x acc))))\n  (sum-to-n n 0))\n", "  (if (zero? n)\n\
    \      '1\n      (+ (sum_to_n (- n 1))\n         (* n n))))\n", "  (if (= n 0)\
    \ 0\n      (+ (* n n) (sum_to_n (- n 1)))))\n", "  (cond [(= n 0) 1]\n       \
    \ [else (+ 1 (sum_to_n (- n 1)))]))\n</code>\n<|/ a |>\n<| c |>\nHmmm.... `factorial`\
    \ should be `factorial`.\n<|/ c |>\n<| c |>\n`factorial` is also a function\n\
    <|/ c |>\n<| c |>\n`factorial` is a function, just like `add`. `factorial` is\
    \ also a function in Racket since R6. Racket has had `factorial` since R5 and\
    \ `factorial` since R6.\n<|/ c |>\n<| c |>\nMy apologies, you are correct, just\
    \ remembered this and forgot to edit the answer :)\n<|/ c |>\n<| c |>\nThe factorial\
    \ function isn't recursive either.\n<|/ c |>\n<| a |>\nThe \"simplest\" way to\
    \ do this in Racket is probably to use the fold function\n<code>", "  (if (= n\
    \ 0)\n      0\n      (+ (first lst)\n         (sum_to_n (sub1 n)))))\n", "  (let\
    \ ([sum (+ 1 n)]) \n    (if (zero? n)\n        sum\n        (sum_to_n (- n 1)))))\n",
  "  (cond\n    ((= n 1) 1)\n    ((= n 2) 2)\n    (else (+ (sum_to_n (- n 1)) (* n\
    \ (sum_to_n (- n 2)))))))\n", "  (if (= n 1)\n      n\n      (+ n (sum_to_n (-\
    \ n 1)))))\n</code>\n<|/ a |>\n<| c |>\nIt's unfair to edit my answer. It would\
    \ be more appropriate to comment on others' answers and give a suggestion. This\
    \ edit is not helping anyone.\n<|/ c |>\n<| c |>\nThe edit was just to remove\
    \ the code from the comments. You shouldn't do that. You should instead edit your\
    \ answer. Also, please don't comment on your own question, that makes it confusing.\n\
    <|/ c |>\n<| c |>\nYeah, sorry, I misunderstood the edit part. Edited that now\
    \ so it makes more sense.\n<|/ c |>\n<| a tags=racket,scheme |>\nThis solution\
    \ doesn't use recursion, although it does use recursion.  Here's my solution in\
    \ Racket:\n<code>", "  (if (= n 0)\n      0\n      (+ (* n (sum_to_n (- n 1)))\
    \ (sum_to_n (- n 1)))))\n", "  (define (loop i acc)\n    (if (zero? i)\n     \
    \   acc\n        (loop (sub1 i) (* (+ i acc) i))))\n  (loop (sub1 n) 0))\n", " \
    \ (cond\n    [(= n 1) 1]\n    [else (+ n (sum_to_n (- n 1)))]))\n", "  (if (=\
    \ n 1)\n      1\n      (+ (* n n) (sum_to_n (sub1 n)))))", "  (if (= n 0)\n  \
    \    1\n      (+ (* (sum_to_n (- n 1)) (- n 1)) n)))\n</code>\n<|/ a dscore=2\
    \ |>\n<| a |>\n<code>", "  (if (= n 0)\n      1\n      (+ (* n (sum_to_n (- n\
    \ 1))))))\n", "  (define (loop n acc)\n    (if (= n 0)\n        acc\n        (loop\
    \ (sub1 n) (+ acc (nth n 'sum))))\n    (loop (sub1 n) 0))\n  (loop n 0))\n", " \
    \ (cond\n    [(= n 1) 1]\n    [else (+ (* n n) (sum_to_n (- n 1)))]))\n", "  (if\
    \ (< n 0)\n      0\n      (+ n (sum_to_n (- n 1)))))", "  (let loop ((s 0)\n \
    \            (n n))\n    (if (= n 0)\n        s\n        (loop (+ s n) (- n 1)))))\n",
  "  (cond [(< n 0)]\n        [else\n         (+ (* n n) (sum_to_n (- n 1)))]))\n",
  "  (if (zero? n)\n      0\n      (+ (car n) (sum_to_n (cdr n)))))\n", "  (if (<\
    \ n 0) 0\n      (+ (* (- n 1) (+ 1 n)) (sum_to_n (- n 1)))))\n", "  (+ n (sum_to_n\
    \ (sub1 n))))\n", "  (lambda (prod)\n    (if (= n 1) \n        prod \n       \
    \ (+ (prod 1)\n           (sum_to_n (- n 1))))\n  )\n)\n", "  (cond [(< n 0) 0]\n\
    \        [else (+ (* (sum_to_n (- n 1)) n) 1)]))\n", "  (if (< n 1)\n      n\n\
    \      (+ n (sum_to_n (- n 1)))))\n", "  (if (= n 0)\n      0\n      (+ (* (quotient\
    \ n n) 10)\n         (sum_to_n (sub1 n)))))\n</code>\n<|/ a tags=scheme,racket\
    \ dscore=3 |>\n<| a dscore=3 |>\nOne approach would be to find the sum of the\
    \ first n numbers then apply the sum to the first n - 1 numbers. For example:\n\
    <code>", "  (nth (+ 1 n) '(1)))\n", "  (if (= n 0)\n      0\n      (+ n (sum_to_n\
    \ (- n 1)))))\n", "  (define (sum-to-n n sum)\n    (if (< n 0)\n        sum\n\
    \        (sum-to-n (- n 1)\n                  (+ sum n))\n      )\n    )\n  (sum-to-n\
    \ n (if (= n 0) 0 1)))\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThanks, I've added\
    \ a solution based on your solution with your comment.\n<|/ c |>\n<| a dscore=1\
    \ |>\nAnother solution based on-Yousef solution:\n<code>", "  (define (helper\
    \ i sum)\n    (cond [(= i n) sum]\n          [else (helper (+ i 1) (+ sum i))]))\n\
    \  (helper 0 0))\n", "  ;; This is the recursive call -- remember that in lisp\n\
    \  ;; the last expression in a function is its return value.\n  (if (= n 1)\n\
    \      n\n      (+ n (sum_to_n (- n 1)))))\n", "  (cond\n    [(zero? n) 0]\n \
    \   [else (+ (tail n) (sum_to_n (pred n)))]))\n", "  (if (< n 1) n (+ (+ (- n\
    \ 1) 1) (sum_to_n (- n 1)))))\n", "  (if (= n 0)\n      0\n      (+ (* n (sum_to_n\
    \ (- n 1))) (* n 1))))\n", "  (define (loop n acc)\n    (if (zero? n) acc\n  \
    \      (loop (- n 1) (+ n acc))))\n  (loop n 0))\n", "  (if (< n 0)\n      0\n\
    \      (+ (* n (sum_to_n (- n 1))) (sum_to_n n))))", "  (if (= n 1)\n      n\n\
    \      (+ (* n (sum_to_n (- n 1)))\n         (sum_to_n (- n 1)))))\n", "  (define\
    \ (loop i acc #:mutable acc)\n    (cond\n      [(= i n) acc]\n      [(< i n) (loop\
    \ (+ i 1) (+ acc i) acc)]\n      [else (loop (+ i 1) acc #:mutable acc)])\n  \
    \  (loop 1 0 #:mutable 0))\n  (loop (- n 1) 0 #:mutable 0))\n", "  (define (loop\
    \ a b)\n    (if (> b n) 0 \n        (+ a \n           (loop (+ a 1) (+ b 1)))))\n\
    \  (loop 0 1))\n", "  ; write your code here\n  ; for example: (sum_to_n 4)\n\
    \  ; (define (sum-to-n n) \n  ;   (cond \n  ;     ((> n 0) \n  ;      (+ n (sum-to-n\
    \ (- n 1))))\n  ;     (#t 1)))\n  ; return (sum-to-n n)\n)\n", "  (cond [(= n\
    \ 0) 1]\n        [else (* 2 (sum_to_n (- n 1))))]))\n", "  (define (helper x total\
    \ acc)\n    (if (= x n)\n      total\n      (helper (+ x 1) (+ total acc) (+ acc\
    \ x))))\n  (helper 1 0 0))\n", "  (define (sum-to-n n sum)\n    (if (< n 0)\n\
    \        sum\n        (sum-to-n (- n 1) (+ sum n))))\n  (define (helper n sum)\n\
    \    (if (= n 0)\n        sum\n        (helper (- n 1) (+ sum n))))\n  (helper\
    \ n 0))\n", "  (let loop ([n n] [sum 0] [sum 0])\n    (cond\n      [(> n 0) sum]\n\
    \      [else (loop (sub1 n) (+ sum n) sum)])\n    ))\n", "  (if (< n 0)\n    \
    \  (error \"sum argument must be > 0\")\n      (+ (expt 2 n)\n         (expt 3\
    \ (- n 1)))))\n", "  (if (= n 0)\n      0\n      (+ (* n (sum_to_n (sub1 n)))\
    \ 1)))\n", "  (cond\n    [(= n 1) 1]\n    [(= n 2) 2]\n    [else\n     (+ (* n\
    \ (sum_to_n (- n 1))) 2)]))\n</code>\n<|/ a dscore=0 tags=scheme |>\n<| a tags=scheme\
    \ |>\n<code>", "  (if (< n 0)\n      0\n      (+ n (sum_to_n (- n 1)))))\n", " \
    \ (define (helper n sum)\n    (if (= n 0)\n        sum\n        (helper (- n 1)\
    \ (+ sum n))))\n  (helper n 0))", "  (if (= n 1)\n      n\n      (+ n (sum_to_n\
    \ (- n 1)))))\n", "  (define (helper n sum)\n    (cond ((= n 0)\n           (if\
    \ (= sum 0)\n               sum\n               (helper 0 (+ sum n))))\n     \
    \     ((even? n)\n           (helper n (+ sum n)))\n          (else\n        \
    \   (helper (- n 1) (+ sum n))))\n  (helper n 0))\n", "  (cond [(< n 1) 1]\n \
    \       [else (+ (sum_to_n (- n 1)) (+ n 1))]))\n", "  (let ([s 0])\n    (if (<\
    \ n 0)\n        0\n        (+ (+ n s)\n           (sum_to_n (- n 1))))))\n", " \
    \ (if (zero? n)\n      0\n      (+ (+ (* n n) (sum_to_n (- n 1))) (* n n))))\n",
  "  (if (= n 0)\n      0\n      (+ (first lst) (sum_to_n (- n 1)))))\n", "  (sum\
    \ (+ 1 n)))\n", "  (cond\n    [(= n 0) 1]\n    [else (+ 1 (sum_to_n (- n 1)))]))\n",
  "  (cond\n    [(= n 0) 1]\n    [else (+ 1 (sum_to_n (sub1 n)))]))\n", "  (sum (+\
    \ 1 n)))\n", "  (if (= n 0)\n      0\n      (+ (expt 2 (- n 1)) (* n (sum_to_n\
    \ (- n 1))))))\n", "  (let ([current 1])\n    (if (= n 0)\n        current\n \
    \       (sum_to_n (- n 1)\n                   (+ current current)\n          \
    \         ))))\n", "  (define (helper n total acc)\n    (cond\n      [(zero? n)\
    \ acc]\n      [(= n 1) (helper (sub1 n) (+ total acc) acc)]\n      [else\n   \
    \    (helper (sub1 n) (+ total acc) (+ total acc))]))\n  (helper n 0 0))\n", " \
    \ (define (loop n)\n    (cond [(= n 0) 1]\n          [(even? n) (loop (sub1 n))]\n\
    \          [else (+ (* n n) (loop (sub1 n)))]))\n  (loop (+ 1 n)))\n", "  (cond\n\
    \    [(= n 0) 0]\n    [else (+ (* n n) (sum_to_n (- n 1)))]))\n", "  (if (zero?\
    \ n)\n      0\n      (+ (nth n 'a) (nth (+ n 1) 'a))\n    )\n  )\n", "  (let loop\
    \ ((acc 0) (i (sub1 n)))\n    (cond\n      [(zero? i) acc]\n      [else (loop\
    \ (+ (* i acc) 1) (sub1 i))]))))\n", "  (define (sum-to-n n sum)\n    (if (= n\
    \ 0)\n        sum\n        (sum-to-n (- n 1)\n                  (+ sum n))))\n\
    \  (sum-to-n n 0))\n", "  (cond\n    [(or (zero? n) (string? n)) (error \"n is\
    \ zero or is not a number\")]\n    [else (+ n 1)]))\n", "  (+ n 1))\n", "  (if\
    \ (= n 0)\n      0\n      (+ (car lst)\n         (sum_to_n (- n 1)))))\n", " \
    \ (if (= n 1)\n      n\n      (+ (* n (sum_to_n (sub1 n)))\n         (sum_to_n\
    \ (sub1 n))))) ;; see note at #lang racket\n</textarea></form>\n    <script>\n\
    \      var editor = CodeMirror.fromTextArea(document.getElementById(\"code\"),\
    \ {\n        lineNumbers: true,\n        matchBrackets: true,\n        mode: \"\
    text/x-racket\"\n      });\n    </script>\n\n    <p><strong>MIME types defined:</strong>\
    \ <code>text/x-racket</code>.</p>\n\n    <p>Supported options: <code>racket</code>,\
    \ <code>plain</code>.</p>\n\n    <p><strong>Parsing/Highlighting Tests:</strong>\
    \ <a href=\"../../test/index.html#?source=racket%20lang&t=0-8\">normal</a>,\n\
    \    <a href=\"../../test/index.html#?source=racket%20lang&t=0-8&full=1\">precise</a></p>\n\
    \  </article>\n\n<|/ file source=gitlab filename=index.html |>\n<| c |>\nI see\
    \ that you've used a special theme for the code in your answer. Would you mind\
    \ adding a link to your personal theme in addition to the link to your theme?\
    \ I really like the theme you used. I'd like to give it a try in Brackets when\
    \ I get the chance, but I'm also learning Racket and wanted to know if you have\
    \ any other good themes to try out. Thanks!\n<|/ c |>\n<| c |>\nI haven't tested\
    \ any other themes. I use the default theme. There are some very nice themes available\
    \ at https://github.com/georgewang/brackets-racket.\n<|/ c |>\n<| c |>\nThe theme\
    \ I like best is the [racket-theme](https://github.com/georgewang/brackets-racket-theme)\
    \ one. I've also written [an article](http://blog.georgewang.com/2012/08/13/racket-on-github-with-racket-theme/)\
    \ about it. BTW, do you use the [Brackets Themes plugin](https://github.com/jasonm2/brackets-themes)\
    \ that adds the theme? It would be really nice to use that instead of writing\
    \ the theme yourself.\n<|/ c |>\n<| c |>\nI installed it from the plugin manager.\
    \ I'll try again when I get the chance. I've been working with Brackets since\
    \ early beta releases. I appreciate your help and I hope you enjoy Brackets.\n\
    <|/ c |>\n<| c |>\nYes, I use the Brackets Themes plugin. Although I use the racket\
    \ theme from Github.\n<|/ c |>\n<| a tags=ra", "  (cond\n    [(= n 1) 1]\n   \
    \ [else (+ (* n n) (sum_to_n (- n 1)))]))\n", "  (if (= n 1)\n      (add1 n)\n\
    \      (+ n (sum_to_n (sub1 n))))\n)\n", "  (if (zero? n)\n      1\n      (+ (*\
    \ (- n 1) (sum_to_n (- n 1))) (sum_to_n (- n 2)))))\n", "  (let loop ((acc 0)\
    \ (n n))\n    (if (= n 0)\n        acc\n        (loop (+ acc n) (sub1 n)))))\n",
  "  (rev (map + (range 1 n))))\n", "  (cond\n    [(= n 1) 1]\n    [else (+ (sum_to_n\
    \ (- n 1))) n]))\n", "  (if (= n 0)\n      0\n      (+ (* n (sum_to_n (- n 1)))\
    \ 0)))\n", "  (cond\n    [(= n 0) 1]\n    [else (+ 1 \n             (sum_to_n\
    \ (- n 1)))]))\n", "  (define (sum-to-n n sum)\n    (if (= n 0)\n        sum\n\
    \        (sum-to-n (- n 1) (+ sum n))))\n  (sum-to-n n 0))", "  (if (= n 0)\n\
    \      0\n      (+ (car lst) (* (+ 1 n) (sum_to_n (- n 1))))))\n", "  (if (= n\
    \ 0)\n      0\n      (+ (+ 1 1) (sum_to_n (- n 1)))))\n", "  (if (= n 0) 1\n \
    \     (+ (sum_to_n (- n 1)) (* n n))))\n", "  (if (= n 0)\n      n\n      (+ (*\
    \ n (sum_to_n (sub1 n)))\n         (* n n))))\n", "  (if (= n 0)\n      1\n  \
    \    (+ (first numbers) (sum_to_n (- n 1)))))\n", "  (+ 1 (apply + '(1 2 3 4 5\
    \ 6 7 8 9 10))))", "  (let loop ((sum 0) (n n))\n    (if (zero? n)\n        sum\n\
    \        (loop (+ sum n) (quotient n 2)))))\n", "  (if (= n 1)\n      n\n    \
    \  (+ (* n n) (sum_to_n (- n 1)))))\n", "  (if (> n 0)\n      (+ (* n n) (sum_to_n\
    \ (- n 1))) (error \"n too big!\"))))\n", "  (if (= n 0)\n      0\n      (+ (*\
    \ (sum_to_n (sub1 n)) n) (sum_to_n (sub1 n))))))\n</code>\n<|/ a dscore=2 |>\n\
    <| a |>\nHere is an approach using a tail-recursive function. It has the benefit\
    \ of not having to reverse the list beforehand, and thus avoiding the problem\
    \ of trying to calculate the sum of a list with negative numbers. \n<code>", " \
    \ (if (= n 0)\n      0\n      (+ (* n n) (sum_to_n (sub1 n))))))", "  (define\
    \ (helper n)\n    (cond [(zero? n) 1]\n          [(= n 1) n]\n          [else\
    \ (+ (helper n) (helper (sub1 n))))]))\n  (helper n))\n", "  (if (< n 0)\n   \
    \   0\n      (+ (sum_to_n (- n 1)) (* n n))))", "  (if (zero? n)\n      n\n  \
    \    (+ (* (quotient n 10) (+ 1 n))\n         (sum_to_n (- n 1)))))", "  (if (=\
    \ n 0)\n      0\n      (+ (* n n) (sum_to_n (- n 1)))))\n", "  (define (sum-to-n\
    \ n total)\n    (cond\n      [(zero? n) total]\n      [else (sum-to-n (sub1 n)\
    \ (+ total n))]))\n  (sum-to-n n 0))\n", "  (if (zero? n)\n      0\n      (+ (car\
    \ list) (sum_to_n (- n 1)))))\n</pre>\n</div>\n</div>\n</div>\n<div class=\"cell\
    \ border-box-sizing text_cell rendered\"><div class=\"prompt input_prompt\">\n\
    </div><div class=\"inner_cell\">\n<div class=\"text_cell_render border-box-sizing\
    \ rendered_html\">\n<p>Now, let's try to use <code>racket</code> to do the same\
    \ thing! Let's start by importing <code>racket</code> and creating a function\
    \ that takes <code>n</code> to sum numbers from 1 to <code>n</code>. First, let's\
    \ start out by creating a <code>list</code> that we can use to store numbers in\
    \ <code>racket</code>. We'll do this with a <code>let</code> statement and pass\
    \ in our value we want to sum:</p>\n\n</div>\n</div>\n</div>\n<div class=\"cell\
    \ border-box-sizing code_cell rendered\">\n<div class=\"input\">\n<div class=\"\
    prompt input_prompt\">In&nbsp;[1]:</div>\n<div class=\"inner_cell\">\n    <div\
    \ class=\"input_area\">\n<div class=\" highlight hl-r\"><pre><span></span><span\
    \ class=\"kn\">let</span> <span class=\"nn\">list</span><span class=\"o\">=</span><span\
    \ class=\"kp\">(</span><span class=\"kt\">null</span><span class=\"o\">:</span><span\
    \ class=\"k\">begin</span><span class=\"o\">-</span><span class=\"n\">value</span><span\
    \ class=\"o\">:</span><span class=\"n\">number</span> <span class=\"mi\">0</span><span\
    \ class=\"p\">)</span>\n</pre></div>\n\n    </div>\n</div>\n</div>\n\n</div>\n\
    <div class=\"cell border-box-sizing text_cell rendered\"><div class=\"prompt input_prompt\"\
    >\n</div><div class=\"inner_cell\">\n<div class=\"text_cell_render border-box-sizing\
    \ rendered_html\">\n<p>Now that we have our <code>list</code> we want to sum from,\
    \ we need to write some code that does this. We will use <code>if</code> statements\
    \ to see if the current number is the number we want to sum. If it is, we will\
    \ add the current number to the sum and continue looping. We will do this until\
    \ we reach our end value. Let's start by writing a code that sums numbers from\
    \ 1 to <code>n</code>:</p>\n\n</div>\n</div>\n</div>\n<div class=\"cell border-box-sizing\
    \ code_cell rendered\">\n<div class=\"input\">\n<div class=\"prompt input_prompt\"\
    >In&nbsp;[2]:</div>\n<div class=\"inner_cell\">\n    <div class=\"input_area\"\
    >\n<div class=\" highlight hl-r\"><pre><span></span><span class=\"kd\">let</span>\
    \ <span class=\"nn\">sum_to_n</span><span class=\"p\">(</span><span class=\"n\"\
    >n</span><span class=\"p\">)</span>\n    <span class=\"kd\">let</span> <span class=\"\
    nn\">list</span><span class=\"o\">=</span><span class=\"kp\">(</span><span class=\"\
    kt\">null</span><span class=\"o\">:</span><span class=\"k\">begin</span><span\
    \ class=\"o\">-</span><span class=\"n\">value</span><span class=\"o\">:</span><span\
    \ class=\"n\">number</span> <span class=\"mi\">0</span><span class=\"p\">)</span>\n\
    \    <span class=\"kd\">let</span> <span class=\"nn\">sum</span><span class=\"\
    o\">=</span><span class=\"kp\">(</span><span class=\"kt\">null</span><span class=\"\
    o\">:</span><span class=\"k\">begin</span><span class=\"o\">-</span><span class=\"\
    n\">value</span><span class=\"o\">:</span><span class=\"n\">number</span> <span\
    \ class=\"mi\">0</span><span class=\"p\">)</span>\n    <span class=\"kd\">let</span>\
    \ <span class=\"nn\">i</span><span class=\"o\">=</span><span class=\"kp\">(</span><span\
    \ class=\"kt\">null</span><span class=\"o\">:</span><span class=\"k\">begin</span><span\
    \ class=\"o\">-</span><span class=\"n\">value</span><span class=\"o\">:</span><span\
    \ class=\"n\">number</span> <span class=\"mi\">0</span><span class=\"p\">)</span>\n\
    \    <span class=\"kd\">let</span> <span class=\"nn\">list</span><span class=\"\
    o\">-</span><span class=\"k\">while</span><span class=\"p\">(</span><span class=\"\
    k\">lambda</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"\
    p\">)</span><span class=\"o\">-</span><span class=\"n\">&gt;</span><span class=\"\
    p\">(</span><span class=\"n\">", "  (if (= n 0)\n      0\n      (+ (*  (sum_to_n\
    \ (- n 1)) n) n)))\n", "  (cond\n    [(= n 0) 1]\n    [(< n 1) (* n (sum_to_n\
    \ (- n 1)))]\n    [else (+ n (sum_to_n (- n 1)))]))\n", "  (if (= n 0)\n     \
    \ 1\n      (+ (* n n) (sum_to_n (sub1 n)))))\n", "  (define (sum-to-n accum n)\n\
    \    (cond ((= n 0) (+ accum n))\n          ((odd? n) (sum-to-n (+ accum n) (sub1\
    \ n)))\n          (else (sum-to-n accum (sub1 n))))\n    (sum-to-n 0 n))\n  (sum-to-n\
    \ 0 n))\n</code>\n<|/ a tags=racket,scheme |>\n<| c |>\nWhile this link may answer\
    \ the question, it is better to include the essential parts of the answer here\
    \ and provide the link for reference.  Link-only answers can become invalid if\
    \ the linked page changes. - [From Review](/review/low-quality-posts/11270103)\n\
    <|/ c |>\n<| c |>\nWell, I thought it would be a good example. :) I believe that\
    \ it is good now. :)\n<|/ c |>\n<| a dscore=1 |>\nHere is an implementation using\
    \ Racket (Racket) functional programming features:\n<code>", "  (if (= n 0)\n\
    \      0\n      (+ (* n (sum_to_n (- n 1))) 1)))\n", "  (lambda () \n    (if (=\
    \ n 0)\n      1\n      (+ (sum_to_n (- n 1)) (* n n))))\n)\n", "  (cond\n    ((=\
    \ n 0) 0)\n    ((even? n) (+ (* (modulo n 2) (modulo (+ n 1) 2)) (* 2 (sum_to_n\
    \ (sub1 n))))))\n    (else (+ (* 2 (sum_to_n (sub1 n))) (* 2 (sum_to_n (sub1 n)))))))\n",
  "  (if (= n 0)\n      1\n      (+ (* n (sum_to_n (- n 1))))))\n</code>\n<|/ a tags=racket,functional-programming\
    \ |>\n<| c |>\nThanks for the great answer. I was trying to understand what you\
    \ did here and how it worked. Since you wrote it like a function, I decided to\
    \ see how it would be used in other areas of my code, and I noticed that the way\
    \ you used it didn't require the let binding. Why is that? I understand how you\
    \ used this in the context of a list, but I don't see how it could work without\
    \ the let binding and how it could work.\n<|/ c |>\n<| c |>\n: I added an example\
    \ how to use it in a list context (which is probably the most common usage).\n\
    <|/ c |>\n<| c |>\nOk, so I think I understand it a little bit better. I also\
    \ see now that you can use it in a list expression as well (like in my first example).\
    \ So the let binding is there to let you reference the value of the recursive\
    \ function inside the definition of the list. This is because you cannot use the\
    \ function definition in the body of the list because it only defines the function\
    \ before you call the function. Thank you for the explanation!\n<|/ c |>\n<| c\
    \ |>\n: Yes, in list expressions you cannot define a new function and use it in\
    \ an expression. But you can (as in the second example) define a new function\
    \ and use it as an expression in a list expression. As you can see, I use the\
    \ function as expression in a list expression just as I do in the first example.\n\
    <|/ c |>\n<| c |>\n: Btw, just to let you know that it is possible to define a\
    \ new function inside an expression as well. Using an `if` expression: `(if (=\
    \ n 0) 1 ... (* n (sum_to_n (- n 1))))`. This works since `if` has a \"then\"\
    \ part and a \"else\" part.\n<|/ c |>\n<| a dscore=2 |>\n<code>", "  (cond\n \
    \   [(< n 1) (error \"n must be at least 1\")]\n    [(= n 0) 1]\n    [else (+\
    \ (sum_to_n (sub1 n)) (sum_to_n (sub1 n)))]))\n", "  (if (= n 0)\n      0\n  \
    \    (+ n (sum_to_n (- n 1)))))\n</code>\n<|/ a dscore=2 tags=scheme,racket |>\n\
    <| c |>\nYour solution uses a `do` loop, which is not required and in some cases\
    \ is considered un-idiomatic when compared to recursion, since it creates a new\
    \ stack frame on each iteration.\n<|/ c |>\n<| c |>\nMy solution is `O(n)`. I\
    \ agree that the `do` is not idiomatic in Racket but it's still a solution to\
    \ the problem. Yes, `do` is a bad solution but it's only a bad solution in Racket\
    \ since it uses a `do` loop, which is not required and in some cases is considered\
    \ un-idiomatic when compared to recursion, since it creates a new stack frame\
    \ on each iteration\n<|/ c |>\n<| c |>\nThanks for your answer. I understood it\
    \ better than my solution (which is too close to mine) but I am still puzzled\
    \ that my solution is wrong and yours is correct. Did you try to run my code with\
    \ your function sum_to_n? I think it is incorrect because I do not understand\
    \ how it works but I tried it and it produces wrong result.\n<|/ c |>\n<| c |>\n\
    I edited my answer to correct the mistake, it's not perfect but it is a correct\
    \ solution\n<|/ c |>\n<| c |>\nI appreciate your answer, but it is still not correct.\
    \ I still cannot understand how it works. I checked it several times and it gives\
    \ the wrong answer. I do not understand how it works because I do not understand\
    \ it at all. I tried to run your function with my function sum_to_n and it produces\
    \ the same result as mine. By the way, I think you do not understand the question.\
    \ There is no need to sum numbers from 1 to n. I have already written the code\
    \ and it is not the answer. Thanks anyway.\n<|/ c |>\n<| a |>\nMy solution using\
    \ recursion:\n<code>", "  (if (= n 1)\n      n\n      (+ (sum-to-n n) (- n 1))))\n",
  "  (let loop ((n n) (sum 0))\n    (cond ((< n 0) sum)\n          ((= n 1) sum)\n\
    \          ((= n 2) (+ sum n))\n          ((= n 3) (+ sum (+ n 3)))\n        \
    \  ((= n 4) (+ sum (+ n 3) (+ n 4)))\n          ((= n 5) (+ sum (+ n 3) (+ n 4)\
    \ (+ n 5))))\n    (loop (- n 1) sum)))\n", "  (if (= n 0)\n      1\n      (+ (sum_to_n\
    \ (- n 1)) (* n (sum_to_n n))))\n)", "  (define (helper n sum)\n    (if (= n 0)\n\
    \        sum\n        (helper (sub1 n) (+ sum n))))\n  (helper n 0))\n", "  (if\
    \ (< n 1)\n      1\n      (+ (sum_to_n (- n 1))\n         (* n (sum_to_n (- n\
    \ 1))))))\n", "  (if (= n 0)\n      1\n      (+ (sum_to_n (- n 1))\n         (list\
    \ (- n 1)))))\n", "  (let loop ([i 1])\n    (if (= i n) i\n      (loop (+ i 1)))))\n",
  "  (define (loop-sum i acc)\n    (if (= i n)\n        acc\n        (loop-sum (+\
    \ i 1) (+ acc i))))\n  (loop-sum 0 0))\n", "  (define (helper i acc)\n    (if\
    \ (= i n)\n        acc\n        (helper (+ i 1) (+ acc i))))\n  (helper 1 0))\n",
  "  (let loop ([i 1] [s 0])\n    (if (zero? i)\n        s; \n        (loop (+ i 1)\
    \ (+ s i)))))\n", "  (let loop ([sum 1] [n n])\n    (if (< n 0)\n        sum\n\
    \        (loop (+ sum n) (- n 1)))))\n", "  (if (< n 1)\n      0\n      (+ (car\
    \ xs) (sum_to_n (- n 1)))))\n\n#lang racket\n", "  (cond\n    [(= n 0) 0]\n  \
    \  [(= n 1) 1]\n    [else (+ (sum_to_n (- n 1))\n             (+ n (sum_to_n (-\
    \ n 1))))]))\n", "  (if (= n 1)\n      n\n      (+ (* n (sum_to_n (- n 1)))\n\
    \         (sum_to_n (- n 1)))))\n", "  (cond\n    ((zero? n) 0)\n    ((= n 1)\
    \ 1)\n    (else (+ (* 2 (sum_to_n (- n 1))) (sum_to_n n))))) ;; #lang racket\n",
  "  (cond\n    [(= n 1) 1]\n    [else (+ (+ 1 1) (sum_to_n (- n 1)))]))\n", "  (if\
    \ (= n 0)\n      0\n      (+ (* n n) (sum_to_n (- n 1)))))\n", "  ((lambda (x\
    \ y)\n     (if (< y n)\n         (+ x (sum_to_n y (+ 1 y)))\n         (+ x 1)))\n\
    \   0 1))\n", "  (define (loop i accum)\n    (if (= i n)\n        accum\n    \
    \    (loop (+ i 1) (+ accum i))))\n  (loop (add1 n) 0))\n", "  (cond\n    [(=\
    \ n 1) 1]\n    [(= n 2) 2]\n    [else (+ (* 2 (sum_to_n (- n 1))) (sum_to_n (-\
    \ n 2)))]))\n", "  (if (= n 0)\n      0\n      (+ (* n n) (sum_to_n (- n 1)))))\n",
  "  (define (loop i s)\n    (cond ((> i n) (+ s i))\n          ((odd? i) (loop (+\
    \ i 1) (+ s i)))\n          (else (loop (+ i 1) s)))\n  (loop 1 0))\n", "  (let\
    \ loop ((i 0) (sum 0))\n    (if (zero? i)\n        sum\n        (loop (add1 i)\
    \ (inc sum)))))\n", "  (let loop ((n n) (sum 0))\n    (if (> n 0)\n        (let\
    \ ((x (- n 1)))\n          (loop x (+ sum x))\n          sum)))", "  (cond\n \
    \   [(= n 1) 1]\n    [else (+ 1 1 (sum_to_n (- n 1)))]))\n</code>\n<|/ a dscore=1\
    \ tags=racket,recursion,scheme,iteration |>\n<| c |>\nYour solutions iterates\
    \ until it sums up to n.  I think it is what OP meant by \"iterate until the sum\
    \ of the numbers reaches n\".\n<|/ c |>\n<| a tags=racket,recursion,scheme,iteration\
    \ |>\nHere's a solution using foldr:\n<code>", "  (cond [(= n 1) 1]\n        [else\
    \ (+ (* (sum_to_n (- n 1)) n) 1)]))\n", "  (define (aux sum current i)\n    (if\
    \ (= i n)\n        sum\n        (aux (+ current (* sum i)) (+ current (* i 2))\
    \ (inc i))))\n  (aux 0 1 1))\n", "  (apply + \n       (map \n        (lambda (x)\
    \ (+ x x)) \n        '(1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22\
    \ 23 24 25 26 27 28 29 30) \n        :from-end n)))\n</code>\n<|/ a |>\n<| a dscore=1\
    \ |>\nThis implementation is pretty straightforward - it only uses lambda and\
    \ map.\n<code>", "  (if (= n 1)\n      n\n      (+ (* n n) (sum_to_n (- n 1)))))",
  "  (define (helper i acc)\n    (cond\n      [(<= i n) acc]\n      [(zero? i) (reverse\
    \ acc)]\n      [(zero? acc)\n       (helper (+ i 1) (+ acc (modulo i 10)))]\n\
    \      [(not (zero? i))\n       (helper (+ i 1) (+ acc (modulo i 10)))]\n    \
    \  [else (error \"Unknown error in sum_to_n\")]))\n  (helper 1 0))\n", "  (if\
    \ (= n 0)\n      0\n      (+ (* (quotient n 10) 10) \n         (sum_to_n (- n\
    \ 10)))))\n", "  (define (sum-to-n i acc)\n    (cond\n      [(< i n) acc]\n  \
    \    [(equal? i n) (+ acc 'done)]\n      [else (sum-to-n (+ i 1) (+ acc i))]))\n\
    \  (sum-to-n 0 0))\n", "  (if (= n 0)\n      n\n      (+ n (sum_to_n (- n 1)))))\n",
  "  (if (= n 0)\n      0\n      (+ (* n (sum_to_n (- n 1)))\n         (* (- n 1)\
    \ (sum_to_n (- n 2))))))\n", "  (if (= n 0)\n      0\n      (+ (* n n) (sum_to_n\
    \ (- n 1)))))\n", "  (define (sum-to-n n) \n    (if (= n 0)\n        1\n     \
    \   (+ (* (- n 1) n) (sum-to-n (- n 1)))))\n  (sum-to-n n))\n", "  (define (sum-to-n\
    \ x)\n    (if (< x n)\n        x\n        (+ (sum-to-n x) (- n x))\n      )\n\
    \    )\n  (sum-to-n 1))\n", "  (let loop ((i 1) (sum 0))\n    (if (= i n)\n  \
    \      sum\n        (loop (+ i 1) (+ sum i))))))\n", "  (cond [(zero? n) 1]\n\
    \        [else (+ (first n) (sum_to_n (sub1 n)))]))\n</code>\nEDIT\nAs per my\
    \ comment, here's a more \"pure\" way of doing the same thing, which I guess is\
    \ more readable. \n<code>", "  (if (< n 0)\n      0\n      (+ (+ (- n (modulo\
    \ n 10)) 10)\n         (modulo n 10))))\n", "  (if (< n 1)\n      n\n      (+\
    \ (* n (sum_to_n (- n 1)))\n         (sum_to_n (- n 1)))))\n", "  (+ n (sum_to_n\
    \ (- n 1))))\n", "  (if (= n 0)\n      0\n      (+ (expt 2 n) (expt 3 n))))\n",
  "  (if (> n 0)\n      (+ 1 (sum_to_n (- n 1)))\n      1))\n", "  (define (sum_to_n_aux\
    \ (accum n)\n                    (if (= n 0) accum\n                        (sum_to_n_aux\
    \ (+ (accum n) (1- n)) n))))\n  (sum_to_n_aux 0 n))\n", "  (if (= n 0)\n     \
    \ 1\n      (+ (* (sum_to_n (- n 1)) (add1 n)) (* 2 n))))\n", "  (let loop ((acc\
    \ 0) (n n))\n    (if (= n 0)\n        acc\n        (loop (+ acc n) (quotient n\
    \ 10)))))\n", "  (if (= n 0)\n      n\n      (+ (* n n) (sum_to_n (- n 1)))))\n",
  "  (if (= n 0)\n      0\n      (+ (* n n) (sum_to_n (- n 1)))))\n", "  (define (sum-to-n\
    \ n result)\n    (if (< n 0)\n        result\n        (sum-to-n (- n 1) (+ result\
    \ n))))\n  (define (loop n result)\n    (if (< n 0)\n        result\n        (loop\
    \ (- n 1) (+ result n))))\n  (loop (+ n 1) 0))"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
