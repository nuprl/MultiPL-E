name: HumanEval_117_select_words
language: rkt
prompt: "#lang racket\n\n;; Given a string s and a natural number n, you have been\
  \ tasked to implement \n;; a function that returns a list of all words from string\
  \ s that contain exactly \n;; n consonants, in order these words appear in the string\
  \ s.\n;; If the string s is empty then the function should return an empty list.\n\
  ;; Note: you may assume the input string contains only letters and spaces.\n;; Examples:\n\
  ;; >>> (select_words \"Mary had a little lamb\" 4)\n;; (list \"little\")\n;; >>>\
  \ (select_words \"Mary had a little lamb\" 3)\n;; (list \"Mary\" \"lamb\")\n;; >>>\
  \ (select_words \"simple white space\" 2)\n;; (list )\n;; >>> (select_words \"Hello\
  \ world\" 4)\n;; (list \"world\")\n;; >>> (select_words \"Uncle sam\" 3)\n;; (list\
  \ \"Uncle\")\n(define (select_words s n)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate select_words))\n\
  \    (check-equal? (candidate \"Mary had a little lamb\" 4) (list \"little\"))\n\
  \    (check-equal? (candidate \"Mary had a little lamb\" 3) (list \"Mary\" \"lamb\"\
  ))\n    (check-equal? (candidate \"simple white space\" 2) (list ))\n    (check-equal?\
  \ (candidate \"Hello world\" 4) (list \"world\"))\n    (check-equal? (candidate\
  \ \"Uncle sam\" 3) (list \"Uncle\"))\n    (check-equal? (candidate \"\" 4) (list\
  \ ))\n    (check-equal? (candidate \"a b c d e f\" 1) (list \"b\" \"c\" \"d\" \"\
  f\"))\n))\n\n(test-humaneval)"
completions: ["  (if (empty? s)\n      '()\n      (append (split_string (first (split_string\
    \ s n)) #\\Space #\\Space)\n              (select_words (second (split_string\
    \ s n)) n))))\n", "  (cond\n    ((null? s) '())\n    ((equal? (count_consonants\
    \ s) n) \n     (append (remove_consonants (word s) n)\n            (select_words\
    \ (word s) n)))\n    (else '())))\n", "  (cond ((empty? s) empty)\n        ((=\
    \ (length s) 0) empty)\n        ((= n 0) (list empty))\n        ((= (length s)\
    \ n) (cons empty empty))\n        (else (append (take_n s (- n 1))\n         \
    \              (select_words (rest s) n)))\n        )\n        )\n", "  (cond\n\
    \    [(empty? s) empty]\n    [(> (length s) n) (cons (first s) (select_words (rest\
    \ s) n))]\n    [else (cons (first s) (select_words (rest s) n))]))\n", "  (cond\n\
    \    [(empty? s) '()]\n    [(equal? (string-length s) n) '()]\n    [else (cons\
    \ (first s) (select_words (rest s) n))]\n  ))\n", "  (if (empty? s)\n      '()\n\
    \      (let ((result (make-array (length s) (lambda (x) '()))))\n        (let\
    \ loop ((i 0) (word (make-string n)))\n          (cond\n            ((empty? (string->list\
    \ s))\n             (loop i (string->list word)))\n            ((< n 0)\n    \
    \         (loop i (string->list word))\n             (begin\n               (set!\
    \ i (add1 i))\n               (set! word (substring s (add1 i) (add1 i)))\n  \
    \             (set! result (append result (list word))))\n            ((eq? (string->list\
    \ word) (string->list s))\n             (loop (add1 i) word))\n            (else\
    \ \n             (loop (add1 i) word)))))\n      result))\n</cell>\n<cell>", " \
    \ (cond\n    [(null? s)\n      empty]\n    [(= n 0)\n      empty]\n    [else \n\
    \      (cons \n       (find (lambda (x) (x->char-property x #:cons)) \n      \
    \         (map (lambda (word) (string->list word)) \n                    (reverse\
    \ (substring s (- (length s) n))))) \n       (select_words (substring s n) (-\
    \ n 1))]))\n  ", "  (cond [(empty? s) (list)]\n        [(eq? (car s) (first s))\
    \ (cons (first s) (select_words (cdr s) n))]\n        [else (cons (first s)(select_words\
    \ (cdr s) n))]))\n", "  (cond ((empty? s) '())\n        ((and (> (length (first\
    \ s)) n)\n               (= (length (first s)) n))\n         (list '(first (rest\
    \ s))))\n        (else (append (select_words (rest s) n)\n                   \
    \   (select_words (first s) n))))) ", "  (cond [(empty? s) (list '())]\n     \
    \   [(equal? (char-alphabet (car s)) n) (cons (car s) \n                     \
    \                         (select_words (cdr s) n))]\n        [else (select_words\
    \ (cdr s) n)]))\n", "  (cond\n    [(empty? s)(list)]\n    [(not (number? n))(list)]\n\
    \    [(= n 0)(list)]\n    [else (cons (first s) (select_words (rest s) (sub1 n)))]))\n",
  "  (cond\n    [(null? s) '()]\n    [(zero? n) '()]\n    [(< n 1) '()]\n    [else\
    \ (cons (car s)\n                (select_words (cdr s) (sub1 n)))]))\n", "  (define\
    \ (helper s)\n    (cond\n      [(empty? s) (list ())]\n      [(equal? count n)\
    \ (cons (first word) result)])\n    (cond\n      [(cons? s) (helper (cdr s))]\n\
    \      [(cons? c) (helper (cdr c))]\n      [else (helper (cdr s))]))\n  (helper\
    \ s))\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThank you so much for that detailed\
    \ answer !\n<|/ c |>\n<| c |>\nYou're welcome! I'm glad I could help. :)\n<|/\
    \ c |>\n<| a dscore=0 |>\nYour code looks good to me as you are getting output\
    \ as expected. \nYour mistake is you are not incrementing count value in this\
    \ code:\n<code>\n[(equal? count n) (cons (first word) result)]\n</code>\nYou are\
    \ just checking the count value with n which is not incremented, instead you should\
    \ increment count and then check.\nDo like this:\n<code>\n[(equal? (+ count 1)\
    \ n) (cons (first word) result)]\n</code>\nThis will solve your issue and also\
    \ your code is also running as expected.\n<|/ a tags=racket,scheme,lisp |>\n<|\
    \ a dscore=0 tags=racket,scheme,lisp |>\nI have corrected your code\n<code>",
  "  (cond\n    [(empty? s) '()]\n    [(= n 0) '()]\n    [(equal? (first s) '#\\space)\
    \ '()]\n    [else (cons (first s) (select_words (rest s) (sub1 n)))]))\n", " \
    \ (cond\n    ((empty? s) (empty))\n    ((= n 0) (empty))\n    ((= n 1) (cons s))\n\
    \    ((not (symbol=? (first s) 'space)) (cons (first s) (select_words (rest s)\
    \ n)))\n    (else (append (select_words (rest s) n) (list (first s))))))\n", " \
    \ (cond [(empty? s) empty]\n        [(equal? (length s) n) (list s)]\n       \
    \ [(equal? (length s) 1) (list (first s))]\n        [else (cons (first s)\n  \
    \                   (select_words (rest s)\n                                (sub1\
    \ (length s))))]))\n", "  (cond\n    [(empty? s) '()]\n    [(= n 0) '()]\n   \
    \ [(contains-consonants (first s)) \n     (cons (first s) (select_words (rest\
    \ s) (sub1 n)))]\n    [else (select_words (rest s) n)]))\n", "  (cond\n    [(empty?\
    \ s) empty]\n    [(= 0 (string-length s)) empty]\n    [(= n (string-length s))\
    \ empty]\n    [(= n 0) empty]\n    [(= 1 (string-length s)) s]\n    [else (append\
    \ (select (map char->string (remove '() s) '()) (lambda (x) (equal? x \" \") (equal?\
    \ x (first (map first (remove '() s))))) (select_words (rest s) (sub1 n)))]))\n",
  "  (cond [(empty? s) empty]\n        [(= n 0) (list empty)]\n        [(or (char-alphabetic?\
    \ #\\space) (char-alphabetic? #\\newline)) (list empty)]\n        [else (cons\
    \ (first s)\n                  (select_words (rest s)\n                      \
    \        (- n (length s))))]))\n", "  (cond\n    [(empty? s) (empty)]\n    [else\
    \ (cons (first (filter (lambda (x) (equal? (count-consonants x) (- n 1))\n   \
    \                            s))) \n               (select_words (rest s) n))]\n\
    \    ))\n", "  (define (dfs s acc)\n    (cond [(= (length s) 0) (append acc empty)]\n\
    \          [(string=? (car s) ?a) (dfs (cdr s) (cons ?a acc))]\n          [else\
    \ (dfs (cdr s) (cons (car s) acc))]))\n  (dfs s empty))\n", "  (if (empty? s)\n\
    \      '()\n      (let ([lst (build-list n '())]\n            [w (first (split-string\
    \ s)) j (+ n 1)])\n        (cond\n          [(= n 1) (cons (first w) lst)]\n \
    \         [(empty? w) (list-set! lst j (first w) j)]\n          [(char-alphabetic?\
    \ w) (cond\n                                [(char-alpha-in-alphabet w) (list-set!\
    \ lst j (first w) j)]\n                                [(char-alpha-in-alphabet?\
    \ w) (cons (first w) lst)]\n                                [else (error 'select_words\
    \ \"Invalid input\" 'empty-input)]\n                                )]\n     \
    \     [else (error 'select_words \"Invalid input\" 'not-alphanumeric)])\n    \
    \    (select_words (substring s j) (- n 1)))))\n", "  (cond\n    [(empty? s) '()]\n\
    \    [(= n 1) (cons s (list ))]\n    [else (cons (substring (first s) 0 (first\
    \ s)) \n               (select_words (substring (first s) 1 ((first s) (length\
    \ (first s))))\n                         (substring (first s) (length (first s))\
    \ n))]\n   ))\n", "  (cond [(empty? s) '()]\n        [(= n 1) (list s)]\n    \
    \    [(= 0 (- n 1)) (list)]\n        [else (cons (first s) (select_words (rest\
    \ s) (sub1 n)))]))\n", "  (cond\n    [(empty? s) '()]\n    [(= 0 (string-length\
    \ s)) '()]\n    [(= n 0) '()]\n    [else (cons (first s) (select_words (rest s)\
    \ (sub1 n)))]))\n", "  (cond [(null? s) '()]\n        [(= n 0) '()]\n        [(=\
    \ n 1) (list s)]\n        [else (append (filter (lambda (w) (and (>= (length w)\
    \ n) (char=? (first w) (first s))))\n                            (select_words\
    \ (rest s) (sub1 (length s)))) ]\n))\n", "  (cond\n    [(empty? s) (list empty)]\n\
    \    [(and (equal? (char-ref s 0) #\\s)\n           (not (= n (char-length s)))\n\
    \           (not (equal? (char-ref s 0) #\\space))\n           (< n (char-length\
    \ s))\n           (equal? (char-ref s n) #\\space)) (cons (car s) (select_words\
    \ (cdr s) n))]\n    [(equal? (char-ref s 0) #\\space) (cons empty\n          \
    \                          (select_words (cdr s) n))]\n    [else (select_words\
    \ (cdr s) n)]\n  ))\n", "  (cond\n    [(empty? s) (list)]\n    [(equal? (first\
    \ s) (first n)) (cons (first s) (select_words (rest s) (+ n 1)))]\n    [else (cons\
    \ (first s)\n                (select_words (rest s) n)]))\n  )\n", "  (cond\n\
    \    [(empty? s) (list)] \n    [(equal? (count s) n) (cons s (list (car s)))]\n\
    \    [else (cons (car s) (select_words (cdr s) n))]))\n", "  (cond\n    [(empty?\
    \ s) empty]\n    [(= n 0) (list '())]\n    [else (append (select_words (car s)\
    \ n) (select_words (cdr s) n))]))\n", "  (cond [(null? s) '()]\n        [(not\
    \ (empty? s)) (cons (first s) (select_words (rest s) n))])\n  [else (select_words\
    \ (rest s) n)]))\n", "  ;; (define (count_letters s) \n  ;;   (define (count_letters-helper\
    \ s n acc lst)\n  ;;     (cond \n  ;;       ((null? s) (cons n acc))\n  ;;   \
    \    ((eq? (car s) ?a) (count_letters-helper (cdr s) n (cons n (car acc)) lst))\n\
    \  ;;       (else (count_letters-helper (cdr s) n (cons (car s) acc) lst)))\n\
    \  ;;   (count_letters-helper s n '() '()))\n  (define (count_letters s)\n   \
    \ (define (count_letters-helper s n acc lst)\n      (cond \n        ((null? s)\
    \ (cons n acc))\n        ((eq? (car s) ?a) (count_letters-helper (cdr s) n (cons\
    \ n (car acc)) lst))\n        (else (count_letters-helper (cdr s) n (cons (car\
    \ s) acc) lst))))\n    (count_letters-helper s n '() '()))\n  (define (count_letters-helper\
    \ s n acc lst)\n    (cond \n      ((null? s) (cons n acc))\n      ((eq? (car s)\
    \ ?a) (count_letters-helper (cdr s) n (cons n (car acc)) lst))\n      (else (count_letters-helper\
    \ (cdr s) n (cons (car s) acc) lst))))\n  (count_letters-helper s n '() '()))\n",
  "  (if (= n 0)\n      '()\n      (let ((c (char-ref s 0))\n            (w (make-empty-string\
    \ s))\n            (l (length (string->list w)))\n            (words (make-empty-string\
    \ s)))\n        (cond ((and (>= l n) \n                   (string-match \"[^aeiouyAEIOUY]\"\
    \ s))\n               (select-words s n))\n              ((or (char-is-alpha c)\n\
    \                  (char-is-space c))\n               (cond ((string-match \"\
    [^aeiouyAEIOUY]\" w)\n                      (select-words s n))\n            \
    \          ((string-match \"[^aeiouyAEIOUY]\" s)\n                       (if (string-match\
    \ \"[^aeiouyAEIOUY]\" words)\n                           (cons words (select-words\
    \ s n))\n                           (select-words s n)))\n                   \
    \   ((string-match \"[^aeiouyAEIOUY]\" s)\n                       (select-words\
    \ s n)))\n               (else\n               (string-append words (string->list\
    \ c))))))\n", "  (cond\n    [(empty? s) '()]\n    [(= n 0) '()]\n    [(zero? (count\
    \ s #\\space)) (cons \"empty\" (select_words (tail s) 0))]\n    [else (cons (first\
    \ s) (select_words (rest s) (sub1 n)))]))\n", "  (cond [(empty? s) '()]\n    \
    \    [(= n (length s)) '()]\n        [(eq? (car s) ?a) '()]\n        [else (cons\
    \ (car s) (select_words (cdr s) (- n 1)))]))\n", "  (cond ((or (empty? s) (= n\
    \ 0)) '())\n        ((chars-equal s \" \")\n         (append (select_words (substring\
    \ s 0) n) (select_words (substring s 1) n)))\n        ((chars-equal s \"\\n\"\
    ))\n        ((chars-equal s \"\\t\")\n         (append (select_words (substring\
    \ s 0) n) (select_words (substring s 1) n)))\n        (else\n         (append\
    \ (select_words (substring s 0 (- (length s) n)) n)\n                (select_words\
    \ (substring s (+ (length s) n) n))))))\n</code>\n<|/ a dscore=3 tags=scheme,racket\
    \ |>\n<| a tags=scheme,racket dscore=2 |>\nI guess you can write it down in many\
    \ ways, here is one in Racket using filter:\n<code>", "  (cond\n    [(null? s)\
    \ '()]\n    [(= (length s) n) (list s)]\n    [(= n 0) '()]\n    [(= (length s)\
    \ 1) (list s)]\n    [(equal? (char-index s #\\A) (char-index s #\\a)) (cons (string->symbol\
    \ (substring s (char-index s #\\A) 1)) (select_words (substring s #\\A 1) (n-1))]\n\
    \    [(equal? (char-index s #\\T) (char-index s #\\t)) (cons (string->symbol (substring\
    \ s (char-index s #\\T) 1)) (select_words (substring s #\\T 1) (n-1))]\n    [(equal?\
    \ (char-index s #\\G) (char-index s #\\g)) (cons (string->symbol (substring s\
    \ (char-index s #\\G) 1)) (select_words (substring s #\\G 1) (n-1))]\n    [(equal?\
    \ (char-index s #\\M) (char-index s #\\m)) (cons (string->symbol (substring s\
    \ (char-index s #\\M) 1)) (select_words (substring s #\\M 1) (n-1))]\n    [(equal?\
    \ (char-index s #\\P) (char-index s #\\p)) (cons (string->symbol (substring s\
    \ (char-index s #\\P) 1)) (select_words (substring s #\\P 1) (n-1))]\n    [(equal?\
    \ (char-index s #\\Y) (char-index s #\\y)) (cons (string->symbol (substring s\
    \ (char-index s #\\Y) 1)) (select_words (substring s #\\Y 1) (n-1))]\n    [(equal?\
    \ (char-index s #\\W) (char-index s #\\w)) (cons (string->symbol (substring s\
    \ (char-index s #\\W) 1)) (select_words (substring s #\\W 1) (n-1))]\n    [else\
    \ (cons (string->symbol (substring s 0 n)) (select_words (substring s 1 n) (substring\
    \ s 2 n))]))\n</code>\n<|/ q dscore=2 |>\n<| a dscore=2 tags=racket,functional-programming,scheme\
    \ |>\nThe solution is actually quite simple: split up your list into a list of\
    \ words, and then filter that list of words based on the requirement:\n<code>",
  "  (cond\n    [(empty? s) (list)] \n    [(not (zero? n)) (cons (first (first s))\n\
    \                         (select_words (rest s)\n                           \
    \            (sub1 n)))] \n    [else (cons (first (first s))\n               \
    \ (select_words (rest s)\n                             (sub1 n))\n           \
    \     (select_words (rest s)\n                             (sub1 n)))]))\n", " \
    \ (cond\n    [(empty? s) '()]\n    [(or (string=? s \" \") (string=? s \"\"))\
    \ '()]\n    [else\n     (cons (list (substring s 0 (- n 1)))\n           (select_words\
    \ (substring s (+ 1 n)) n))]))\n", "  (if (empty? s)\n      '()\n      (cons (take\
    \ (count (first s)) (second s)) \n            (select_words (drop (count (first\
    \ s)) (second s)) n))))\n            ", "  (cond\n    [(empty? s) '()]\n    [(=\
    \ (length s) n) (list s)]\n    [else (substring (words-containing-at-most-n s\
    \ n) (length s))]))\n", "  (cond\n    [(empty? s) '()]\n    [(equal? (length s)\
    \ 0) '()]\n    [(equal? (length s) n) '()]\n    [else (append (take s (- n 1))\n\
    \                   (select_words (drop s (- n 1)) (sub1 n)))]))\n</code>\n<|/\
    \ a |>\n<| c |>\nthank you so much for the reply. But can you explain the difference\
    \ between \"append\" and \"cons\" in the else block? I couldn't find any documentation\
    \ for it online. I'm really new to Racket.\n<|/ c |>\n<| c |>\n[`append`](https://docs.racket-lang.org/reference/pairs.html?q=append#%28def._%28%28lib._racket%2Flist..rkt%29._append%29%29)\
    \ is used to append two lists, as is [`cons`](https://docs.racket-lang.org/reference/pairs.html?q=cons#%28def._%28%28lib._racket%2Flist..rkt%29._cons%29%29).\
    \ Those are very different operations and have completely different effects. It\
    \ is important to note that [`append`](https://docs.racket-lang.org/reference/pairs.html?q=append#%28def._%28%28lib._racket%2Flist..rkt%29._append%29%29)\
    \ is used in [this implementation](https://github.com/racket/racket/blob/master/collects/private/string/string.rkt).\
    \ You will learn more by looking at the source code. Also, I recommend that you\
    \ try the example from my answer.\n<|/ c |>\n<| c |>\n`append` joins two lists.\
    \ `cons` is to construct a list from the lists. If you use `cons`, you'll see\
    \ that you get the same result as my `select_words`. See [this answer](https://stackoverflow.com/a/60102880/849891)\
    \ too.\n<|/ c |>\n<| c |>\nAh I see, thank you! It really helps me understand\
    \ more about Racket!\n<|/ c |>\n<| c |>\nThe `length` implementation is also poor.\
    \ Racket has a built-in `length` function which can be used with strings because\
    \ Racket strings are [sequences](https://docs.racket-lang.org/reference/sequences.html?q=string#%28def._%28%28lib._racket%2Flist..rkt%29._%28lib.racket%2Fstring..rkt%29._length%29%29)\
    \ of `Char` values, which makes the `length` function an acceptable replacement\
    \ for `length` here. It is a very inefficient implementation, though, and I ",
  "  (cond\n    [(equal? (length s) 0) (empty-words-list)]\n    [(equal? (length s)\
    \ n) (list-of-words s)]))\n", "  (cond\n    [(empty? s) '()]\n    [(not (list?\
    \ s)) '()]\n    [(and (number? n) (>= n 0)) '()]\n    [(= n 0) '()]\n    [else\
    \ (cons \n           (nth (list->string \n                   (string->list \n\
    \                    (string-match #rx\"\\A[a-zA-Z']+\\Z\" s)))\n           (select_words\
    \ \n               (rest s)\n               (sub1 n))))]))\n", "  (cond ((equal?\
    \ n 0) '())\n        ((string=? \"Uncle\" s) (list \"Uncle\"))\n        ((equal?\
    \ (string=? \"Uncle\" s) (list_size s) (- n 1)) (cons \"Uncle\" (select_words\
    \ (string=? \"Uncle\" s) (- n 1)))\n        (else (append (select_words (string=?\
    \ \"Uncle\" s) (- n 1)) (list \"Uncle\")))))\n#lang racket\n", "  (cond ((null?\
    \ s)'())\n        ((= n 0)'())\n        (else \n           (append (split (first\
    \ s) \"()\")\n                   (select_words (rest s) (sub1 n))))))\n", "  (cond\
    \ [(empty? s) '()]\n        [(or (empty? s) (equal? n (length s))) (list )]\n\
    \        [(or (= (length s) n) (equal? n (length s))) (cons (first s) (select_words\
    \ (rest s) n))]\n        [else (cons (first s)\n                   (select_words\
    \ (rest s) n))]\n))\n", "  (cond\n    ((empty? s) '())\n    ((char=? (first s)\
    \ #\\s) (cons (first s) (select_words (rest s) n)))\n    ((= (length s) n) (cons\
    \ (first s) (select_words (rest s) n)))\n    ((char=? (first s) #\\y) (cons (first\
    \ s) (select_words (rest s) n)))\n    ((char=? (first s) #\\o) (cons (first s)\
    \ (select_words (rest s) n)))\n    ((char=? (first s) #\\n) (cons (first s) (select_words\
    \ (rest s) n)))\n    ((char=? (first s) #\\g) (cons (first s) (select_words (rest\
    \ s) n)))\n    ((char=? (first s) #\\h) (cons (first s) (select_words (rest s)\
    \ n)))\n    ((char=? (first s) #\\y) (cons (first s) (select_words (rest s) n)))\n\
    \    ((char=? (first s) #\\e) (cons (first s) (select_words (rest s) n)))\n  \
    \  ((char=? (first s) #\\p) (cons (first s) (select_words (rest s) n)))\n    ((char=?\
    \ (first s) #\\c) (cons (first s) (select_words (rest s) n)))\n    ((char=? (first\
    \ s) #\\m) (cons (first s) (select_words (rest s) n)))\n    ((char=? (first s)\
    \ #\\v) (cons (first s) (select_words (rest s) n)))\n    ((char=? (first s) #\\\
    r) (cons (first s) (select_words (rest s) n)))\n    ((char=? (first s) #\\n) (cons\
    \ (first s) (select_words (rest s) n)))\n    ((char=? (first s) #\\a) (cons (first\
    \ s) (select_words (rest s) n)))\n    ((char=? (first s) #\\s) (cons (first s)\
    \ (select_words (rest s) n)))\n    ((char=? (first s) #\\v) (cons (first s) (select_words\
    \ (rest s) n)))\n    ((char=? (first s) #\\e) (cons (first s) (select_words (rest\
    \ s) n)))\n    ((char=? (first s) #\\o) (cons (first s) (select_words (rest s)\
    \ n)))\n    ((char=? (first s) #\\i) (cons (first s) (select_words (rest s) n)))\n\
    \    ((char=? (first s) #\\e) (cons (first s) (select_words (rest s) n)))\n",
  "  (cond\n    [(empty? s) (list)]\n    [(= n 0) (list)]\n    [(= n 1)(list)]\n \
    \   [else (cons (first s)\n                (select_words (rest s)\n          \
    \                    (sub1 (- n 1))))]))\n", "  (cond\n    [(empty? s) (list ())]\n\
    \    [else\n     (if (= 0 (string-length s) (+ n 1))\n       (list s)\n      \
    \ (begin\n        (define str (substring s 0 n))\n        (cond\n          [(empty?\
    \ str) empty]\n          [(string-equal? \"\" str) (list s)]\n          [(string-equal?\
    \ (first (car str)) (first (last str)))]\n          [else (cons (first str) (select_words\
    \ (rest str) n))]\n         )\n       )\n     )\n    ]\n  )\n )\n", "  \n  (cond\
    \ [(empty? s) '()]\n        [(equal? (length s) n) (list s)]\n        [else (cons\
    \ (first s) (select_words (rest s) n))]\n  \n))\n", "  (cond\n    ((null s)\n\
    \     ())\n    ((= (length (filter (lambda (x) (= (string-length (car x)) n))\
    \ s)) 0)\n     (list s))\n    (else (list (car s)\n              (select_words\
    \ (cdr s) n)))))", "  (cond\n    ((null? s)\n     (list))\n    ((= (length s)\
    \ n)\n     (cons (first s) (select_words (rest s) n)))\n    (else (select_words\
    \ (rest s) n))))\n", "  (cond\n    [(empty? s) (list)]\n    [(= (length s) n)\
    \ (list s)]\n    [(= (length s) 0) (list)]\n    [(= n 0)\n     (list (append (reverse\
    \ (subseq s 0 n)) (list s))]\n    [else\n     (cond [(= (length s) (n-1))\n  \
    \          (list (reverse (subseq s 0 n)) (append s (reverse (subseq s 0 n))))]\n\
    \           [else\n            (list (reverse (subseq s 0 n)) (append s (reverse\
    \ (subseq s 0 n))))])))\n", "  (cond\n    [(empty? s) empty]\n    [(> (length\
    \ (string->list s)) n) empty]\n    [(= n 1) (list (string->list s))]\n    [else\
    \ (cons (string->list (substring (string->list s) 0 n)) (select_words (substring\
    \ (string->list s) (+ 0 (length (string->list s) n)) n))]\n  )\n)\n", "  (cond\n\
    \    [(empty? s) '()]\n    [(or (empty? s) (>= n (car s))) (list '())]\n    [else\
    \ (cond\n        [(= (length s) (- n (car s)))\n         (cons (car s) (select_words\
    \ (cdr s) n))]\n        [else\n         (cons (car s)\n               (select_words\
    \ (cdr s) n))]))))\n", "  (cond ((null? s) '())\n        ((= n 0)\n         (append\
    \ '() (list s))\n         (cons (first s)\n               (select_words (rest\
    \ s) (- n 1)))))\n</code>\n<|/ a tags=racket,scheme,string |>\n<| c |>\nThanks,\
    \ this helped a lot. I'm trying to understand it but I'm kind of stuck. I'm new\
    \ to Racket but I'm having trouble understanding how the recursive calls are working.\
    \ I understand the functional approach but I don't get how to get that output\
    \ to show in a list format. How do I get my list to show in that format? Am I\
    \ making a call to list somewhere and that's why it isn't printing in a list format?\
    \ Do I need to use a different method? Thanks for any help you can provide.\n\
    <|/ c |>\n<| c |>\nOk I think I figured it out. Thank you so much!\n<|/ c |>\n\
    <| c |>\nNo problem. Remember that `append` is the function `'(a b) '(c d)` will\
    \ result in `(a c b)`. `list` is the function `'(a b) '(c d)` will result in `'(a\
    \ b c d)`. The two operations are really helpful in Racket - they are the only\
    \ two functions you need in most languages.\n<|/ c |>\n<| c |>\nThanks again.\
    \ I'm still having trouble understanding how the recursive call works. I get how\
    \ the function returns one list but I don't understand how the other list shows\
    \ up at the end of the function. What is this second list that is being appended\
    \ to? Where are that lists coming from?\n<|/ c |>\n<| c |>\nYour code does not\
    \ return the expected output for the second example: it returns just \"little\"\
    \ instead of \"little\", \"lamb\".\n<|/ c |>\n<| a dscore=1 |>\nYou will have\
    \ to define what a \"word\" is. A word is something that ends in a space or at\
    \ the end of a line. So, something like this:\n<code>", "  (cond ((empty? s) (list))\n\
    \        ((= 0 (length s)) (list ))\n        ((= n (length s))\n         (list\
    \ (cons (car s) (select_words (cdr s) n))))\n        (else (cons (car s) (select_words\
    \ (cdr s) n))))))\n", "  (define (cons_helper l word cons)\n    (if (= 0 (length\
    \ word))\n      (cons word)\n      (cons_helper (cons (car word) l) (cdr word)\
    \ cons)))\n  (cons_helper '() s string))\n", "  (cond\n    [(empty? s) (empty-words-list)]\n\
    \    [(= 0 (string-length (first s)) (- n 1)) (cons (first s) (select_words (rest\
    \ s) n))]\n    [else (select_words (rest s) n)]\n    ))\n", "  (cond\n    [(empty?\
    \ s) empty]\n    [(not (character? s)) empty]\n    [(equal? (length (filter_vowels\
    \ s)) n) (list)]\n    [else (cons (first s) (select_words (rest s) n))]))\n",
  "  (cond\n    [(empty? s) '()]\n    [(= n 0)\n     (list '())]\n    [else \n   \
    \  (append (select (count-consonants s) (- n 1)) \n             (select s n))]))\n",
  "  (cond\n    [(empty? s) (list)] \n    [(= n (car s))\n     (cons (car s)\n   \
    \        (select_words (cdr s) n))]\n    [else (cons (car s)\n               \
    \   (select_words (cdr s) n))]\n  )\n)\n", "  (cond [(empty? s)\n         empty]\n\
    \        [(equal? (char->integer ?a) ?a)\n         (cons (string->symbol (string->string\
    \ ?a)) (select_words (string->string s) n))]\n        [else (select_words (string->string\
    \ s) n)]))\n", "  (define (word s n)\n    (cond\n      [(empty? s) '()]\n    \
    \  [(equal? (first s) (first n)) (cons (first s) (word (rest s) n))]\n      [(equal?\
    \ (first n) (first s)) (cons (first s) (word (rest s) n))]\n      [else (word\
    \ (rest s) n)]))\n  (word s n))\n", "  (cond\n    [(empty? s) '()]\n    [(empty?\
    \ (car s)) '()]\n    [(equal? (count-consonants (car s)) n) (cons (car s) (select_words\
    \ (cdr s) n))]))\n", "  (cond\n    [(or (null? s) (zero? n)) '()]\n    [else\n\
    \     (let ([words (subseq s (- n 1))])\n       (cond\n         [(empty? words)\
    \ '()]\n         [(char=? (first words) 'a) (cons (first words) (select_words\
    \ s (+ n 1))) (cons (first words) words)]\n         [(char=? (first words) 'e)\
    \ (cons (first words) (select_words s (+ n 1))) (cons (first words) words)]\n\
    \         [(char=? (first words) 'i) (cons (first words) (select_words s (+ n\
    \ 1))) (cons (first words) words)]\n         [(char=? (first words) 'o) (cons\
    \ (first words) (select_words s (+ n 1))) (cons (first words) words)]\n      \
    \   [(char=? (first words) 'u) (cons (first words) (select_words s (+ n 1))) (cons\
    \ (first words) words)]\n         [else (cons (first words) (select_words s (+\
    \ n 1)))]))]))\n", "  (cond ((or (not s) (= n 0))\n         (empty))\n       \
    \ ((= (string-length s) 0) '())\n        (else (cons (string->list s)\n      \
    \               (select-words (string->list s)\n                             \
    \    (- n))))))\n", "  (if (or (equal? s \"\") (equal? n 0))\n      '()\n    \
    \  (append (select (split_string s \"\\\\w\") n)\n               (select_words\
    \ (split_string s \" \") (- n 1)))))\n", "  (cond ((equal? n (string-length s))\n\
    \         (list))\n        (else\n         (cons (string->list (substring s 0\
    \ n)) \n               (select_words (substring s n) (- n 1))))))\n", "  (if (empty?\
    \ s)\n      empty\n      (cons (first (subseq s 0 n)) (select_words (rest s) n))))\n",
  "  (if (empty? s) \n      '()\n      (append (if (= n (string->number s))\n    \
    \              (substring s (string->number s) n)\n                  (substring\
    \ s \"a\" (string->number s) n)))))\n", "  (cond\n    [(empty? s) (list ())]\n\
    \    [(= (length s) n) (list (list (first s)))]\n    [else (cons (first s) (select_words\
    \ (rest s) n))]\n  ))\n", "  (cond\n    [(empty? s)\n     (list)] \n    [(>= n\
    \ 1)\n     (list s)]\n    [else\n     (append (select_words (rest s) n) \n   \
    \         (cons (first s) (select_words (rest s) (n-1))))]))\n", "  (cond\n  \
    \  [(empty? s) (list)]\n    [(equal? n (length (first s))) (rest s)]\n    [(equal?\
    \ n (length (first s))) (cons s (first s) (select_words (rest s) n))]\n    [else\
    \ (cons (first s) (select_words (rest s) n))]\n  )\n)\n</cell>\n<code language=dyalog-kernel>\n\
    #lang racket\n", "  (cond\n    [(empty? s) '()]\n    [(= (length s) n) s]\n  \
    \  [(< n (length s)) (select_words (drop-last s) n)]\n    [else (cons (take-last\
    \ s) (select_words (drop-last s) n))]))\n", "  (cond [(empty? s)\n         empty]\n\
    \        [(= n 1)\n         (cons (first s)\n               empty)]\n        [(=\
    \ 0 n)\n         empty]\n        [else\n         (cons (first s)\n           \
    \    (select_words (rest s) (- n 1)))])) ", "  (cond\n    ((empty? s) '())\n \
    \   ((= (length s) 0) '())\n    (else (cons (first s)\n                (select_words\
    \ (rest s) n)))))\n", "  (cond [(string=? s \"\")          (empty? '())]\n   \
    \     [(= 0 (remainder n 2)) (cons (car s) (select_words (cdr s) n))]\n      \
    \  [else (cons (car s) (select_words (cdr s) (sub1 n)))]))\n", "  (cond\n    [(empty?\
    \ s) empty]\n    [(equal? n (length s)) s]\n    [else (cons (car s)\n        \
    \        (select_words (cdr s) n))]\n  )\n)\n", "  (cond ((or (empty? s) (null\
    \ n)) '())\n        ((char=? (first s) (first n)) (cons (first s) (select_words\
    \ (rest s) (rest n)))\n         (select_words (rest s) (rest n)))\n        (else\
    \ (select_words (rest s) (rest n)))))\n", "  (cond\n    [(empty? s) '()]\n   \
    \ [(= (count s #\\?) n) s]\n    [else (cons (first s) (select_words (rest s) n))]))\n",
  "  (if (empty? s) '())\n  (let ((temp '()))\n    (loop for c in\n           (cons\
    \ (first s)\n                 (if (>= n (length s)) (cons c (select_words \n \
    \                                             (rest s)\n                     \
    \                         n) temp)\n                     (select_words (rest s)\
    \ n))))))\n", "  (cond\n    [(empty? s) '()]\n    [(not (= (length s) n)) (select_words\
    \ s (- n 1))]\n    [else (cons s (select_words (rest s) n))]\n  )\n)\n", "  ;;\
    \ (define (vowels-cons vc)\n  ;;     (cond\n  ;;       ((empty? vc) (empty))\n\
    \  ;;       ((symbol=? (first vc) (second vc)) (cons (first vc) (list (second\
    \ vc)))))\n  ;;       (else (cons (first vc) (list (first vc))))))\n  (cond\n\
    \    ((empty? s) (empty))\n    ((= n 0) (list s))\n    ((symbol=? (first s) (second\
    \ s)) (list (first s) (second s)))\n    ((char= (first s) (first s)) (list (first\
    \ s)))\n    ((char= (first s) (second s)) (list (first s) (first s)))\n    (else\
    \ (cons (first s) (list (first s) (first s))))))\n", "  (cond\n    [(empty? s)\
    \ (list)] \n    [(= 0 (string-length s)) empty]\n    [else (cons (first s)\n \
    \               (select_words (rest s) n)) ]\n  ))\n", "  (cond \n    ((empty?\
    \ s) '())\n    ((= n 0) '())\n    ((null? (cdr s)) '())\n    ((eq? (first (car\
    \ s)) (car s)) \n     (cons (car s) (select_words (cdr s) (- n 1))))\n    (else\
    \ \n     (cons (car s) \n           (select_words (cdr s) (- n (length s))))))\n\
    )\n</cell>\n<cell>\n#lang racket\n", "  (cond\n    [(empty? s)\n     nil]\n  \
    \  [(equal? n (car s))\n     (cons (car s) (select_words (cdr s) n))]\n    [else\n\
    \     (cons (car s)\n           (select_words (cdr s) n)]))) ;; use cond here\
    \ to make it return an object\n", "  (cond\n    [(empty? s) (list)] \n    [(equal?\
    \ n (length s)) s]\n    [(equal? n (sub1 n)) (cons (first s) (select_words (rest\
    \ s) n))]\n    [else (cons (first s) (select_words (rest s) n))]\n  )\n)\n", " \
    \ (cond\n    [(empty? s) empty]\n    [(equal? n (length s)) empty]\n    [else\
    \ (cons (first s) (select_words (rest s) n))]\n    )\n  )\n", "  (cond [(empty?\
    \ s) empty]\n        [(= n 0) (list empty)]\n        [(equal? (length (string->list\
    \ (substring s 0 (- (length s) n)))) n) (string->list (substring s 0 (- (length\
    \ s) n)))]\n        [else (cons (string->list (substring s 0 (- (length s) n)))\
    \ (select_words (substring s n (- (length s) n)) (- n 1))]\n        )\n  )\n",
  "  (cond\n    [(empty? s) (list)]\n    [(not (equal? n (string-length (first s))))\n\
    \     (list)]\n    [else \n     (let ([found (equal? (first s) \"\")\n       \
    \      list (list)]\n           [len (string-length (first s))])\n       (loop\
    \ [i 0\n              j n\n              found (equal? found (first s))]\n   \
    \      [if (> len i)\n           (begin\n             (set! i (+ i 1))\n     \
    \        (set! list (cons found list)))\n           (set! i (+ i 1))\n       \
    \    (set! list (cons found (select_words (first s) (sub1 j))\n              \
    \             list))])])]))\n", "  (cond\n    [(empty? s) '()]\n    [(equal? n\
    \ 0) '()]\n    [else (cons (first s) (select_words (rest s) (sub1 n)))]))\n",
  "  (cond ((empty? s) '())\n        ((= n 0)\n         )\n        ((string=? (car\
    \ s) \" \")\n         (cons (car s) (select_words (cdr s) (sub1 n)))\n       \
    \  )\n        ((string=? (car s) \"M\")\n         (cons (car s) (select_words\
    \ (cdr s) (sub1 n)))\n         )\n        ((string=? (car s) \"a\")\n        \
    \ (cons (car s) (select_words (cdr s) (sub1 n)))\n         )\n        ((string=?\
    \ (car s) \"i\")\n         (cons (car s) (select_words (cdr s) (sub1 n)))\n  \
    \       )\n        ((string=? (car s) \"u\")\n         (cons (car s) (select_words\
    \ (cdr s) (sub1 n)))\n         )\n        ((string=? (car s) \"l\")\n        \
    \ (cons (car s) (select_words (cdr s) (sub1 n)))\n         )\n        ((string=?\
    \ (car s) \"l\")\n         (cons (car s) (select_words (cdr s) (sub1 n)))\n  \
    \       )\n        ((string=? (car s) \"a\")\n         (cons (car s) (select_words\
    \ (cdr s) (sub1 n)))\n         )\n        ((string=? (car s) \"u\")\n        \
    \ (cons (car s) (select_words (cdr s) (sub1 n)))\n         )\n        ((string=?\
    \ (car s) \"e\")\n         (cons (car s) (select_words (cdr s) (sub1 n)))\n  \
    \       )\n        ((string=? (car s) \"s\")\n         (cons (car s) (select_words\
    \ (cdr s) (sub1 n)))\n         )\n        ((string=? (car s) \"t\")\n        \
    \ (cons (car s) (select_words (cdr s) (sub1 n)))\n         )\n        ((string=?\
    \ (car s) \"h\")\n         (cons (car s) (select_words (cdr s) (sub1 n)))\n  \
    \       )\n        ((string=? (car s) \"l\")\n         (cons (car s) (select_words\
    \ (cdr s) (sub1 n)))\n         )\n        ((string=? (car s) \"e\")\n        \
    \ (cons (car s) (select_words (", "  (cond\n    [(empty? s) '()]\n    [(not (even?\
    \ n)) (cons (car s) (select_words (cdr s) n))]\n    [else (cons (car s)\n    \
    \            (select_words (cdr s) (sub1 n)))]))\n", "  (cond\n    [(empty? s)\
    \ '()]\n    [(= n 0) '()]\n    [(= n 1) (list (first (split-string (string s)\
    \ #\\Spaces)))]\n    [else (cons (first (split-string (string s) #\\Spaces)) (select_words\
    \ (rest s) (sub1 n)))]))\n", "  (cond\n    [(empty? s) (list)]\n    [(= 0 (length\
    \ s)) (list)]\n    [(= 0 (remainder (length s) n)) (list)]\n    [else (append\
    \ (substring s 0 (- (length s) n))\n                 (select_words (substring\
    \ s (+ 0 (length s) n) 1))\n                 (select_words (substring s (+ 0 (-\
    \ n (length s)) n) 1)))]))\n</code>\n<|/ a tags=racket,recursion,scheme dscore=0\
    \ |>\n<| c |>\nIt took me a moment to figure out what was going on, so I rewrote\
    \ my answer in Racket and added the original code. Feel free to replace with my\
    \ answer, just make sure you test it thoroughly before submitting it to your homework.\
    \ :)\n<|/ c |>\n<| a dscore=0 |>\nHere is another solution, which is slightly\
    \ different from yours. It also works if you want to return multiple words. Also,\
    \ I'm using the list returned by substring to find the next word (instead of the\
    \ index returned by string-ref). Hope that helps.\n<code>", "  (cond ((empty?\
    \ s) empty)\n        ((= n 0) (list s))\n        (else (cons (car s) (select_words\
    \ (cdr s) (sub1 n))))))\n", "  (cond\n    [(empty? s) (list)] \n    [(equal? (length\
    \ s) n) (cons (first s) (select_words (rest s) n))]\n    [else (cons (first s)\n\
    \                (select_words (rest s) n))]\n  )\n)\n", "  ; Write your solution\
    \ here.\n  (cond\n    [(empty? s) '()]\n    [(= n 0) '()]\n    [else (cons (car\
    \ s) (select_words (cdr s) (sub1 n)))]))\n", "  (if (null? s)\n      '()\n   \
    \   (cond \n         ((empty? s) \n          '())\n         ((zero? n) \n    \
    \      '())\n         ((equal? (count (first s)) n) (cons (first s) (select_words\
    \ (rest s) n)))\n         (else\n           (select_words (rest s) n))\n     \
    \   ))\n", "  (cond\n    ((null? s) '())\n    ((equal? n 0) '())\n    ((equal?\
    \ n 1) (list s))\n    ((equal? n 2)\n     (cond\n       ((equal? (string-match\
    \ \"[^aeiouAEIOU]\" s) 0)\n        (cons (string-match \"[^aeiouAEIOU]\" s) '()))\n\
    \       ((equal? (string-match \"[^aeiouAEIOU]\" s) 1)\n        (cons (string-match\
    \ \"[^aeiouAEIOU]\" s) (list (string-match \"[^aeiouAEIOU]\" s))))\n       ((equal?\
    \ (string-match \"[^aeiouAEIOU]\" s) 2)\n        (cons (string-match \"[^aeiouAEIOU]\"\
    \ s) (list (string-match \"[^aeiouAEIOU]\" s) (string-match \"[^aeiouAEIOU]\"\
    \ s))))\n       ((equal? (string-match \"[^aeiouAEIOU]\" s) 3)\n        (cons\
    \ (string-match \"[^aeiouAEIOU]\" s) (list (string-match \"[^aeiouAEIOU]\" s)\
    \ (string-match \"[^aeiouAEIOU]\" s) (string-match \"[^aeiouAEIOU]\" s))))\n \
    \      ((equal? (string-match \"[^aeiouAEIOU]\" s) 4)\n        (cons (string-match\
    \ \"[^aeiouAEIOU]\" s) (list (string-match \"[^aeiouAEIOU]\" s) (string-match\
    \ \"[^aeiouAEIOU]\" s) (string-match \"[^aeiouAEIOU]\" s) (string-match \"[^aeiouAEIOU]\"\
    \ s))))\n       ((equal? (string-match \"[^aeiouAEIOU]\" s) 5)\n        (cons\
    \ (string-match \"[^aeiouAEIOU]\" s) (list (string-match \"[^aeiouAEIOU]\" s)\
    \ (string-match \"[^aeiouAEIOU]\" s) (string-match \"[^aeiouAEIOU]\" s) (string-match\
    \ \"[^aeiouAEIOU]\" s) (string-match \"[^aeiouAEIOU]\" s))))\n       ((equal?\
    \ (string-match \"[^aeiouAEIOU]\" s) 6)\n        (cons (string-match \"[^aeiouAEIOU]\"\
    \ s) (list (string-match \"[^aeiouAEIOU]\" s) (string-match \"[^aeiouAEIOU]\"\
    \ s) (string-match \"[^", "  (if (empty? s) \n      empty\n      (let ((result\
    \ '()))\n        (cond\n          ((equal? (string=? (string-length s) n) (string-length\
    \ s)) (cons (substring s 0 (string-length s)) result))\n          (else (cons\
    \ (substring s 0 ((string-length s) n)) (cons (substring s ((string-length s)\
    \ n) (string-length s))) (cons (substring s ((string-length s) n) (n-) (substring\
    \ s 0 n))) (select-words s (+ n 1)))))))\n</code>\n<|/ a tags=racket,string,substring\
    \ dscore=1 |>\n<| c |>\nThank you for sharing the solution with me.\n<|/ c |>\n\
    <| a tags=racket,string,substring |>\nHere's a solution using recursion and string->list.\n\
    <code>", "  (cond\n    [(empty? s) '()]\n    [(equal? (length s) 0) '()]\n   \
    \ [(equal? (length s) n) s]\n    [else (cons (car s) (select_words (cdr s) n))]))\n",
  "  (cond\n    [(empty? s) (list ())]\n    [(eq? (length s) n) (cons s (select_words\
    \ (rest s) n))]\n    [else (cons (first s) (select_words (rest s) n))]\n  ))\n",
  "  (cond\n    [(empty? s) '()]\n    [(eq? (first s) space) (cons space (select_words\
    \ (rest s) n))]\n    [else (cons (first s) (select_words (rest s) n))]\n  ))\n",
  "  (cond\n    [(empty? s) empty]\n    [(equal? n 0) empty]\n    [(equal? n 1) (list\
    \ s)]\n    [else\n     (cond\n       [(contains? s #\\cons) (select_words (drop-cons\
    \ s n) 1)]\n       [(equal? n (string-length (first s))) (rest s)]\n       [else\n\
    \        (select_words (drop-cons s n) (add1 n))]))]))\n", "  (if (empty? s)\n\
    \      '()\n      (append (filter_words s #(<= n %))\n              (select_words\
    \ (rest (rest s)) n))))\n", "  (cond ((empty? s) '())\n        ((= n 0)\n    \
    \     (cond ((= (length s) 0)\n                (list (string-append \"the\" (string\
    \ \"\")))\n                (list \"the\"))\n               ((empty? (rest s))\
    \ #f)\n               ((eq? (first s) '#\\s)\n                (list (string-append\
    \ (substring (string s) (+ 1 n))\n                                    (string\
    \ \"\")))\n                (list (substring (string s) (+ 1 n))))\n          \
    \     ((eq? (first s) '#\\a)\n                (list (string-append (substring\
    \ (string s) (+ 1 n))\n                                    (string \"\")))\n \
    \               (list (substring (string s) (+ 1 n))))\n               ((eq? (first\
    \ s) '#\\e)\n                (list (string-append (substring (string s) (+ 1 n))\n\
    \                                    (string \"\")))\n                (list (substring\
    \ (string s) (+ 1 n))))\n               ((eq? (first s) '#\\i)\n             \
    \   (list (string-append (substring (string s) (+ 1 n))\n                    \
    \                (string \"\")))\n                (list (substring (string s)\
    \ (+ 1 n))))\n               ((eq? (first s) '#\\o)\n                (list (string-append\
    \ (substring (string s) (+ 1 n))\n                                    (string\
    \ \"\")))\n                (list (substring (string s) (+ 1 n))))\n          \
    \     ((eq? (first s) '#\\u)\n                (list (string-append (substring\
    \ (string s) (+ 1 n))\n                                    (string \"\")))\n \
    \               (list (substring (string s) (+ 1 n))))\n               ((eq? (first\
    \ s) '#\\y)\n                (list (string-append (substring (string s) (+ 1 n))\n\
    \                                    (string \"\")))\n                (list (substring\
    \ (string s) (+ 1 n))))\n               ((eq? (first s) '#\\h)\n             \
    \   (list (string-append (substring (string s) (+ 1 n))\n                    \
    \                (string \"\")))\n                (list (substring (string s)\
    \ (+ 1 n))))\n               ((eq? (first s) '#\\n)\n                (list (string-append\
    \ (substring (string s) (+ 1 n))\n                                    (string\
    \ \"\")))\n                (list (substring (string s) (+ 1 n))))\n          \
    \     ((eq? (first s) '#\\g)\n                (list (string-append (substring\
    \ (string s) (+ 1 n))\n                                    (string \"\")))\n \
    \               (list (substring (string s) (+ 1 n))))\n               ((eq? (first\
    \ s) '#\\f)\n                (list (string-append (substring (", "  (cond [(empty?\
    \ s) (list)]\n        [(equal? (length s) 0) (list)]\n        [(equal? (length\
    \ s) n) (list)])\n  (cond [(null? (cdr s)) nil]\n        [(equal? (car s) #\\\
    space) nil]\n        [else (cons (car s) (select_words (cdr s) n))])))\n", " \
    \ (cond\n    [(empty? s) (empty)]\n    [(= n 0) (empty)]\n    [else (cons (first\
    \ s)\n                (select_words (rest s) (sub1 (second s)))]))\n  )\n)\n</code>\n\
    <|/ a tags=racket,string,recursion |>\n<| a dscore=1 |>\nI really like this question,\
    \ I think it's a bit hard to do without a helper function that has some state\
    \ to keep track of the recursion depth. Here's a recursive function that does\
    \ the job:\n<code>", "  (cond [(empty? s) (empty)]\n        [(equal? (chars-at\
    \ (string->list s) 0) #\\Space) (empty)]\n        [else (append (select_words\
    \ (substring s 0 n) #\\Space)\n                       (list (substring s 0 n))))]))\n",
  "  (cond\n    [(empty? s) (list)] \n    [(= n 0) (list)] \n    [else (cons (first\
    \ s)\n                (select_words (rest s)\n                             n-1))]))\n",
  "  (if (empty? s) '() \n      (if (equal? (length (filter (lambda (x) (equal? x\
    \ #\\cons) s)) n) #\\space)\n          (cons (filter (lambda (x) (equal? x #\\\
    cons) s)) '())\n          (cons (filter (lambda (x) (equal? x #\\cons) s) (select_words\
    \ (filter (lambda (x) (equal? x #\\cons) s) n)) '()))))\n", "  (cond\n    [(empty?\
    \ s) '()]\n    [(= 0 n) (list s)]\n    [else\n     (cond\n       [(eq? (first\
    \ s) \"a\") (cons (first s) (select_words (drop 1 (rest s)) (n-1)))]\n       [(eq?\
    \ (first s) \"e\") (cons (first s) (select_words (drop 1 (rest s)) (n-1)))]\n\
    \       [(eq? (first s) \"i\") (cons (first s) (select_words (drop 1 (rest s))\
    \ (n-1)))]\n       [(eq? (first s) \"o\") (cons (first s) (select_words (drop\
    \ 1 (rest s)) (n-1)))]\n       [(eq? (first s) \"u\") (cons (first s) (select_words\
    \ (drop 1 (rest s)) (n-1)))]\n       [(eq? (first s) \"y\") (cons (first s) (select_words\
    \ (drop 1 (rest s)) (n-1)))]\n       [else (cons (first s) (select_words (drop\
    \ 1 (rest s)) n-1))]))]))\n", "  (cond\n    [(empty? s) '()]\n    [(zero? n) '()]\n\
    \    [(cons? s) (append (select-words (first s) n) (select_words (rest s) n))]\n\
    \    [else (select_words (first s) n)]))\n", "  (cond\n    [(null? s) '()]\n \
    \   [(= (length s) n) '()]\n    [(= (length s) 1) (string-append (list s) (select\
    \ s n))]\n    [else (list \"(\" select_words (select s n) (+ n 1) \")\")]))\n",
  "  (cond\n    ((empty? s) (list))\n    ((equal? (first s) n) (cons (first s) (select_words\
    \ (rest s) n)))\n    (else (select_words (rest s) n))))\n", "  (cond\n    [(empty?\
    \ s) (list)] \n    [(empty? (rest s)) (list)] \n    [else (cons (string->list\
    \ (string->symbol (first s))) (select_words (rest s) n))]))\n", "  (cond\n   \
    \ [(empty? s) (empty-list )]\n    [(equal? (length (first s)) n) (cons (first\
    \ s) (select_words (rest s) n))]\n    [else (cons (first s)(select_words (rest\
    \ s) n))]))\n", "  (cond\n    [(empty? s) '()]\n    [(= n 0) '()]\n    [(equal?\
    \ (first s) \" \") '()]\n    [else \n     (cond\n       [(and (not (equal? (first\
    \ s) (first words-containing-n (length s)) (first s))) \n          (select_words\
    \ (drop (first s) (length s)) (n-1))]\n       [else (cons (first words-containing-n\
    \ (length s) (first s)) (select_words (drop (first s) (length s)) (n-1))]))]))]))",
  "  (cond ((string? s) (map (lambda (word) (cons word s)) '()))\n        ((equal?\
    \ s \"\") '())\n        (else\n         (map (lambda (word) (cons word s)) \n\
    \             (filter (lambda (word) (equal? (count_cons word s) n))\n       \
    \              \n                     (map (lambda (word) (cons word s)) \n  \
    \                       (filter (lambda (word) (equal? (count_cons word s) n))\
    \ \n                             \n                         (map (lambda (word)\
    \ (cons word s)) \n                             (filter (lambda (word) (equal?\
    \ (count_cons word s) n)) \n                             \n                  \
    \           (map (lambda (word) (cons word s)) \n                            \
    \     (filter (lambda (word) (equal? (count_cons word s) n)) \n              \
    \                   \n                                 (map (lambda (word) (cons\
    \ word s)) \n                                     (filter (lambda (word) (equal?\
    \ (count_cons word s) n)) \n                                     \n          \
    \                           (map (lambda (word) (cons word s)) \n            \
    \                             (filter (lambda (word) (equal? (count_cons word\
    \ s) n)) \n                                         \n                       \
    \                  (map (lambda (word) (cons word s)) \n                     \
    \                       (filter (lambda (word) (equal? (count_cons word s) n))\
    \ \n                                            \n                           \
    \                 (map (lambda (word) (cons word s)) \n                      \
    \                          (filter (lambda (word) (equal? (count_cons word s)\
    \ n)) \n                                                \n                   \
    \                             (map (lambda (word) (cons word s)) \n          \
    \                                          (filter (lambda (word) (equal? (count_cons\
    \ word s) n)) \n                                                    \n       \
    \                                             (map (lambda (word) (cons word s))\
    \ \n                                                        (filter (lambda (word)\
    \ (equal? (count_cons word s) n)) \n                                         \
    \               \n                                                        (map\
    \ (lambda (word) (cons word s)) \n                                           \
    \                 (filter (lambda (word) (equal? (count_cons word s) n)) \n  \
    \                                                          \n                \
    \                                            (map (lambda (word) (cons word s))\
    \ \n                                                                (filter (lambda\
    \ (word) (equal? (count_cons word s) n)) \n                                  \
    \                              \n                                            \
    \                    (map (lambda (word) (cons word s)) \n                   \
    \                                                 (filter (lambda (word) (equal?\
    \ (count_cons word s) n)) \n                                                 \
    \                   \n                                                       \
    \             (map (lambda (word) (cons word s)) \n                          \
    \                                              (filter (lambda (word) (equal?\
    \ (count_cons word s) n)) \n                                                 \
    \               \n                                                           \
    \             (", "  (if (empty? s)\n      '()\n      (if (= n 0)\n          (list\
    \ s)\n          (cons (list) (select_words (append s (make-string n)) (sub1 n))\
    \ ))\n      ))\n      ;; The base case here will return the empty list.\n</code>\n\
    <|/ a |>\n<| c |>\nThank you! It helped me a lot.\n<|/ c |>\n<| a tags=racket,list,scheme\
    \ |>\nHere's a solution that's pretty similar to what you're already doing, but\
    \ more clear, concise, and avoids recursion.\n<code>", "  (cond\n    [(empty?\
    \ s) '()]\n    [(= n 1) (list s)]\n    [else\n     (let ((w (split_string s #\\\
    Space)))\n       (select_words (join_string w #\\Space) (remainder (length w)\
    \ n))]))))\n", "  (cond\n    [(empty? s) (empty)]\n    [(equal? n (string->number\
    \ s)) (empty)]\n    [else (append (cons (string->number s) empty)\n          \
    \         (select_words (string->list s) n)])))\n", "  (cond\n    [(empty? s)\
    \ '()]\n    [(> (length (first s)) n) '()]\n    [(= n 0) '()]\n    [(= n 1) (cons\
    \ (first s) (select_words (rest s) (- n 1)))]\n    [else (cons (first s) (select_words\
    \ (rest s) (- n 1))) (select_words (rest s) (- n 1))]))\n", "  (cond\n    [(empty?\
    \ s) '()]\n    [(= n 0) '()]\n    [(= (length s) n) (list s)]\n    [else (let\
    \ ([head-word (car s)])\n             (cond\n              [(string=? (make-string-from-bytes\
    \ head-word 0 1) head-word) \n               (cons (string->list head-word) (select_words\
    \ (cdr s) (- n 1)))]\n              [else (cons (string->list head-word) (select_words\
    \ (cdr s) n))])))]))\n</code>\n<|/ a tags=racket,scheme dscore=0 |>\n<| c |>\n\
    Thanks for your solution, but can you please explain how my code is wrong? It\
    \ doesn't seem to work. I'm not getting any errors, but I'm also not getting any\
    \ words in the list.\n<|/ c |>\n<| c |>\nI updated my answer with some explanations\
    \ about the mistakes that I noticed in your code. Hope that helps\n<|/ c |>\n\
    <| a dscore=0 |>\nA solution that should work:\n<code>", "  (cond\n    [(empty?\
    \ s) (list)] \n    [(= n 0)]\n    [else \n     (let ([words (remove-duplicates\
    \ \n          (filter (lambda (x) (string-contains? x s) \n                  (select-all\
    \ x n))))])\n       \n       (cons (car words) (select_words (cdr words) n)))]))\n",
  "  (cond\n    [(empty? s) (list )]\n    [(equal? s \"\") (list \"\")]\n    [(equal?\
    \ s \"\") (list \"\")]\n    [else (cons (first s) \n               (select_words\
    \ (rest s)\n                            (sub1 n)))]))\n</code>\n<|/ a |>\n<| a\
    \ tags=scheme |>\nIn Racket/Scheme you have a number of options, including:\n\n\
    Using list-ref\nUsing string-ref\nUsing string-set-char\nUsing string-append\n\
    Using string-length\nUsing substring\nUsing list-ref\n\nThese functions have various\
    \ advantages over the others, depending on what you want to do.  In general I\
    \ recommend using string-set-char for any purpose where you might want to set\
    \ or modify characters.\n<|/ a dscore=2 |>\n<| c |>\nI forgot that Racket's string-ref\
    \ returns references.  Thanks for pointing that out!\n<|/ c |>\n<| c |>\nAlso,\
    \ it's worth noting that list-ref doesn't return references, it returns values.\n\
    <|/ c |>\n<| a dscore=2 |>\nMy solution:\n<code>", "  (cond\n    [(empty? s) empty]\n\
    \    [(= n 0)\n     (cons (first s) (select_words (rest s) n))]\n    [else (cons\
    \ (first s)\n                (cons (select_words (rest s) n) \n              \
    \        (select_words (rest (rest s)) (sub1 n))))]))\n", "  (cond\n    [(empty?\
    \ s) (empty)]\n    [(empty? (rest s)) (empty)]\n    [(equal? (length s) 0) (empty)]\n\
    \    [(equal? (length s) n) (empty)]\n    [else (cons (first s) (select_words\
    \ (rest s) n))]\n  ))\n", "  (cond\n    [(empty? s) (list)]\n    [(= (length s)\
    \ n) (list)]\n    [else (cons (first s) \n                (select_words (rest\
    \ s) n))]))\n", "  (cond\n    [(empty? s) '()]\n    [(= n 0) '()]\n    [else\n\
    \     (cond \n       [(contains? s c)\n        (cons c (select_words (cdr s) (sub1\
    \ n)))]\n       [else\n        (select_words (cons (car s) '()) (sub1 n))]))]))\n",
  "  (cond\n    [(empty? s) (empty)]\n    [else \n     (cond\n       [(equal? (length\
    \ (string->list s)) (+ n 1)) (string->list s)]\n       [(equal? (length (string->list\
    \ s)) (+ n 2)) (cons (string->list s) (list ))]\n       [(equal? (length (string->list\
    \ s)) (+ n 3)) \n        (cons (string->list s) \n            (append (select_words\
    \ (remove (length (string->list s)) s)) \n                    (select_words (remove\
    \ (length (string->list s)) s) \n                                (- n 1)))]\n\
    \       [(equal? (length (string->list s)) (+ n 4)) \n        (cons (string->list\
    \ s) \n            (append (select_words (remove (length (string->list s)) s))\
    \ \n                    (select_words (remove (length (string->list s)) s) \n\
    \                                (- n 1))\n                    (select_words (remove\
    \ (length (string->list s)) s) \n                                (- n 1)))]\n\
    \       [(equal? (length (string->list s)) (+ n 5)) \n        (cons (string->list\
    \ s) \n            (append (select_words (remove (length (string->list s)) s))\
    \ \n                    (select_words (remove (length (string->list s)) s) \n\
    \                                (- n 1))\n                    (select_words (remove\
    \ (length (string->list s)) s) \n                                (- n 1))\n  \
    \                  (select_words (remove (length (string->list s)) s) \n     \
    \                           (- n 1)))]\n       [(equal? (length (string->list\
    \ s)) (+ n 6)) \n        (cons (string->list s) \n            (append (select_words\
    \ (remove (length (string->list s)) s)) \n                    (select_words (remove\
    \ (length (string->list s)) s) \n                                (- n 1))\n  \
    \                  (select_words (remove (length (string->list s)) s) \n     \
    \                           (- n 1))\n                    (select_words (remove\
    \ (length (string->list s)) s) \n                                (- n 1))\n  \
    \                  (select_words (remove (length (string->list s)) s) \n     \
    \                           (- n 1)))]\n       [(equal? (length (string->list\
    \ s)) (+ n 7)) \n        (cons (string->list s) \n            (append (select_words\
    \ (remove (length (string->list s)) s)) \n                    (select_words (remove\
    \ (length (string->list s)) s) \n                                (- n 1))\n  \
    \                  (select_words (remove ", "  (cond\n    [(empty? s) '()]\n \
    \   [(empty? s)\n     '()]\n    [(or (empty? (car s))\n         (= n 1))\n   \
    \  (cons (car s) (select_words (cdr s) n))]\n    [else\n     (select_words (append\
    \ (list (car s))\n                          (select_words (cdr s) n-1))\n    \
    \             n)]))\n</code>\n<|/ a dscore=1 |>\n<| c |>\nA list comprehension\
    \ is a good idea, but the implementation will be very different to a for loop.\
    \ Just wanted to point out that the algorithm can still be improved since it is\
    \ designed to handle empty strings and a single letter word.\n<|/ c |>\n<| a tags=algorithm,racket\
    \ dscore=1 |>\nHere is another solution, using streams.\n<code>\n#lang racket",
  "  \n  (cond [(empty? s) '()]\n        [(or (char=? #\\Space s) (char=? #\\Tab s))\
    \ '()]\n        [(or (char=? #\\Newline s) (char=? #\\Return s)) '()]\n      \
    \  [else (append (select_word (first s) n) (select_words rest n) (select_word\
    \ (first s) n))]\n))\n", "  (cond\n    ((null? s) '())\n    ((= n (length s))\
    \ '())\n    ((char-at-pos? (car s) n) (cdr s))\n    (else (cons (car s)\n    \
    \            (select_words (cdr s) n)))))\n", "  (cond\n    [(empty? s) (list)]\n\
    \    [(= n 0) (empty)]\n    [(= n 1) (cons (first s) (select_words (rest s) 0))]\n\
    \    [else (cons (first s) (select_words (rest s) (sub1 n)))]))\n", "  (cond\n\
    \    [(empty? s) empty]\n    [(= n 0) empty]\n    [(symbolp (first s)) (list s)]\n\
    \    [else (cons (first s)\n                (select_words (rest s) (sub1 n)))]))\n",
  "  (cond\n    [(empty? s) (list)]\n    [(empty? (cdr s)) (list)] \n    [(= (car\
    \ s) 'a) (cons ((substring (car s) 0 n) \"a\") (select_words (substring (cdr s)\
    \ 0 n) n))]\n    [(= (car s) 'e) (cons ((substring (car s) 0 n) \"e\") (select_words\
    \ (substring (cdr s) 0 n) n))]\n    [(= (car s) 'i) (cons ((substring (car s)\
    \ 0 n) \"i\") (select_words (substring (cdr s) 0 n) n))]\n    [(= (car s) 'o)\
    \ (cons ((substring (car s) 0 n) \"o\") (select_words (substring (cdr s) 0 n)\
    \ n))]\n    [(= (car s) 'u) (cons ((substring (car s) 0 n) \"u\") (select_words\
    \ (substring (cdr s) 0 n) n))]\n    [(= (car s) 'y) (cons ((substring (car s)\
    \ 0 n) \"y\") (select_words (substring (cdr s) 0 n) n))]\n    [else (cons (car\
    \ s) (select_words (cdr s) n))]))\n", "  (cond\n    [(empty? s)\n     (list)\n\
    \     (define (re-count word)\n       (cond\n         [(= (remainder n #\\a) (length\
    \ word))\n          (cons word (rest word))\n          (else (rest word)))]\n\
    \        [else\n         (cons word (re-count (append word (rest word))))]))\n\
    \     (filter (lambda (w)\n               (matches-count? (car w) (select-char\
    \ (car (re-count w)) n)))\n             (reverse (map (lambda (x)\n          \
    \                (cons (car x) (cdr x)))\n                         (remove-if-not\
    \ (lambda (x)\n                                         (matches-count? (car x)\
    \ n)) \n                                     (reverse (cons (first s) (rest s))))))]\n\
    \    [else\n     (list s)]))\n", "  (cond\n    [(empty? s) (empty?)] \n    [(equal?\
    \ (length (string->list s))) (cons nil nil)]\n    [(equal? (length (string->list\
    \ s))) (cons (first s) (select_words (rest s) n))] \n    [else (cons (first s)\
    \ (select_words (rest s) n))]\n    ))\n", "  (define (helper-recur s i r) \n \
    \   (cond\n      [(empty? s) '()]\n      [(char=? (car s) (car i)) (cons (car\
    \ i) r)])\n    (helper-recur (cdr s) (+ (car i) 1) r))\n  (helper-recur s '()\
    \ '()))\n", "  (cond\n    [(empty? s) '()]\n    [else\n     (cond [(= (length\
    \ s) n)\n            (cons (first s) (select_words (rest s) n))\n            (select_words\
    \ (rest s) n)]\n          [(not (even? n)) (cons (first s) (select_words (rest\
    \ s) n))])]))\n", "  (cond [(empty? s) empty]\n        [(= n 0) (list s)]\n  \
    \      [(= n 1) (list s)]\n        [(= (length s) (length s)) (list)]))\n", " \
    \ (cond\n    [(empty? s) '()]\n    [(<= n 1) '()]\n    [(equal? (first s) ?a)\
    \ (list ?a)]\n    [else (cons (first s) (select_words (rest s) (sub1 n)))]))\n\
    </code>\nIn Racket it can be done in one line and in three like this:\n<code>",
  "  (cond (empty? s)\n        '()\n        (cons\n          (take-until (char-ref\
    \ s n) #\\Space)\n          (select_words (drop-char s n) #\\Space))\n       \
    \ (cons\n          (take-until (char-ref s n) #\\Space)\n          (select_words\
    \ (drop-char s n) #\\Newline)))\n  )\n)\n", "  (cond\n    [(empty? s) (empty)]\n\
    \    [(eq? (length s) n) (list)] \n    [else (cons (first s)\n               \
    \ (select_words (rest s) n)]))) \n", "  (cond\n    [(empty? s) (list)]\n    [else\
    \ (cons (caar s)(select_words (cdr s) n))]\n  ))\n", "  (cond\n    [(empty? s)\
    \ '()]\n    [(equal? n 0) (list s)]\n    [else (words-in-order (drop-first s)\
    \ (count-consonants n)) ]))\n", "  (cond [(empty? s)\n         '()]\n        [(and\
    \ (cons? s) (> (length (first s)) n))\n         (cons (first s) (select_words\
    \ (rest s) n))]\n        [else\n         (select_words (rest s) n)]))\n", "  (cond\n\
    \    [(empty? s) (list)]\n    [(= 0 (mod n (count-consonants s))) (cons s (cons\
    \ s ()))]\n    [else (cons (first s) (select_words (rest s) (mod n (count-consonants\
    \ s))))]))\n", "  (cond\n    [(empty? s) '()]\n    [(zero? n) empty]\n    [else\
    \ (cons (first s)\n                (select_words (rest s) (sub1 n)))]))\n", " \
    \ (cond\n    [(empty? s) (list ())]\n    [else (cons (first (filter letter? (map\
    \ char->list (count-vowels s))))\n                (select_words (rest s)\n   \
    \                            (- n (length (first (filter letter? (map char->list\
    \ (count-vowels s))))))))]))\n", "  (if (empty? s)\n      '()\n      (cons (car\
    \ (filter_words (string->list s) n)) (select_words (cdr s) n))))\n", "  (cond\n\
    \    [(empty? s) '()]\n    [(= n 0) '()]\n    [else (if (or (eq? (first s) (first\
    \ '())) (eq? (first s) (first '())))\n            (if (eq? (first s) (first '()))\n\
    \                (select_words (rest s) n)\n                (if (eq? (first s)\
    \ (first '()))\n                    (select_words (rest s) (- n 1))\n        \
    \            (let ((w (first s)))\n                        (cond\n           \
    \               [(equal? w (first '())) (cons (first s) (select_words (rest s)\
    \ n))]\n                          [(equal? (first w) (first '())) (cons (first\
    \ w) (select_words (rest s) n))]\n                          [(equal? (first w)\
    \ (first '())) (cons (first w) (select_words (rest s) (- n 1)))]\n           \
    \               [else (cons (first w) (select_words (rest s) n))]))]\n    [else\
    \ (select_words (rest s) (- n 1))]))) ; #lang racket\n", "  (cond\n    [(empty?\
    \ s) (list)]\n    [(= n (string-length s)) (list s)]\n    [else (cons (string->list\
    \ (substring s 0 (min n string-length s))) \n               (select_words (substring\
    \ s n (string-length s))\n                             (- n 1)))])))\n</code>\n\
    <|/ a |>\n<| c |>\nI ran the code and it gave me a result but it seems slightly\
    \ off. I've added an extra example to the original post, but your example gave\
    \ me a \"no\" as the answer. Maybe I'm missing something? Thanks so much for the\
    \ help though. =)\n<|/ c |>\n<| c |>\nOhh, that's because the answer assumes that\
    \ you know what \"consonant\" means.\n<|/ c |>\n<| c |>\nYeah I assumed they meant\
    \ consonants. Thanks again! =)\n<|/ c |>\n<| c |>\nThe first part of the solution\
    \ (`cond`) can be replaced with: `(cond\n  [(empty? s) (list)] [else (cons (string->list\
    \ (substring s 0 (min n string-length s))) (select_words (substring s n (string-length\
    \ s))) (- n 1)))])`\n<|/ c |>\n<| c |>\nThanks for the suggestion, I've updated\
    \ my code accordingly.\n<|/ c |>\n<| a dscore=2 |>\nYou can create a function\
    \ like that:\n<code>", "  (cond\n    [(empty? s) (list)]\n    [(equal? (length\
    \ (first s)) n) (cons (first s)\n                                         (select_words\
    \ (rest s) n))]))\n</cell>\n<text>\nExercise 2.23: Define a procedure called select_word_counts\
    \ that takes a non-empty string s as input and a natural number n as output and\
    \ returns a list of counts of how many words in string s have exactly n consonants\
    \ in them. \nNote: You may assume the input string contains only letters and spaces.\n\
    Examples\n>>> (select_word_counts \"Mary had a little lamb\" 4)", "  (cond\n \
    \   [(empty? s) (list )]\n    [(equal? s \"\") (list )]\n    [(equal? n 0) (list\
    \ )]\n    [else (append (select_words (substring s 0 (- (length s) n)) n) (list\
    \ (substring s 0 (- (length s) n)))]))\n  ", "  (cond\n    [(empty? s)\n     empty]\n\
    \    [(= (length s) n)\n     (cons (first s) (select_words (rest s) n))]))", " \
    \ (cond\n    [(empty? s) (list)] \n    [(>= (length (first s)) n) (list)]\n  \
    \  [else (cons (first s) (select_words (rest s) n))]\n    )\n  )\n)\n#lang racket\n",
  "  (if (null? s)\n      '()\n      (append (select_words (first s) n) (select_words\
    \ (rest s) n))))\n", "  (cond [(empty? s) (list ) ]\n        [(or (= (length s)\
    \ 0) (= n 0))\n         (list )]\n        [(= n (length s))\n         (cons (substring\
    \ s 0 (- (length s) n)) (select_words (substring s (+ 0 (- n 1))) (- n 1))) ]\n\
    \        [else\n         (cons (substring s 0 (- (length s) n)) (select_words\
    \ (substring s (+ 0 (- n 1))) (- n 1))) ]))\n", "  (cond\n    [(empty? s) (list\
    \ ())]\n    [(equal? (length s) n) (list)]\n    [(equal? (length s) 0) (list s)]\n\
    \    [else (append (filter_words (substring s 0 (length s)) n) (select_words (substring\
    \ s (length s) (length s))  n)]\n  )\n)\n", "  (cond ((null? s) '())\n       \
    \ ((equal? (string-length s) n) (cons s nil))\n        (else (cons (string-ref\
    \ s 0) (select_words (substring s 1) n)))\n  )\n)\n", "  (cond\n    [(empty? s)\
    \ '()]\n    [(= (length s) 0) '()]\n    [(= n 0) '()]\n    [else (cons (first\
    \ s)\n                (select_words (rest s)\n                             (-\
    \ n\n                               (length (first s)))))]))\n", "  (cond\n  \
    \  [(empty? s) '()]\n    [(equal? s \"\") '()]\n    [(equal? s \" \") '()]\n \
    \   [else (cons (first s) (select_words (rest s) n))]\n  ))\n", "  (cond\n   \
    \ [(empty? s) '()]\n    [(= n 0) '()]\n    [else (cons (first s)\n           \
    \     (select-words (rest s) (sub1 n)))]))\n</cell>\n<cell>\n#lang racket\n",
  "  (cond\n    [(empty? s)  empty]\n    [(> (length s) n) empty]\n    [else (cons\
    \ (first s)(select_words (rest s)(- n 1))) ]\n  )\n)\n", "  (cond ((or (not s)\
    \ (< n 0))\n         ())\n        ((equal? (car s) \" \")\n         (cons (car\
    \ s) (select_words (cdr s) n)))\n        (else\n         (cons (car s)\n     \
    \         (select_words (cdr s) (- n 1))))))\n", "  (cond\n    [(empty? s) '()]\n\
    \    [(= n 0) '()]\n    [else (cons (car s)\n                (select_words (cdr\
    \ s)\n                             (sub1 n)))]))\n", "  (cond\n    [(empty? s)\
    \ (list)] \n    [(= (length s) 0)]\n    [else (append (select-words-helper (substring\
    \ s 0 n))\n                    (select-words-helper (substring s 1 (length s))))]))\n",
  "  (cond ((string=? \"\" s) ())\n        ((empty? s) ())\n        (else\n      \
    \   (append (map (lambda (x) (cond ((char=? x 'A) (cons x (select_words (string-append\
    \ x s) n))))\n                      (substring-no-equals (string-append s \"A\"\
    ) \"Z\"))\n                 (select_words (string-append s \"Z\") n))))))\n",
  "  (cond\n    [(empty? s)\n     empty]\n    [else\n     (cons (substring (first\
    \ s) 0 (- (length s) n) (lambda (index string)\n                             \
    \            (cond\n                                           [(= n (length string))\n\
    \                                             (cons string empty)]\n         \
    \                                  [else\n                                   \
    \          (cons string\n                                                   (select_words\
    \ (cdr string) n)))]))]))))\n", "  (cond\n    [(empty? s) '()]\n    [(= n 0) '()]\n\
    \    [else (cons (first s)\n                (select_words (rest s) (- n 1)))]));;#lang\
    \ racket\n", "  (cond\n    [(empty? s) '()]\n    [(zero? n) '()]\n    [(equal\
    \ n 1) (list s)]\n    [else\n     (cond\n       [(contains-consonants s n) (cons\
    \ (cdr s) (select_words s (- n 1)))]\n       [(contains-consonants s '()) (cons\
    \ '() (cdr s))])))])\n", "  (cond\n    [(empty? s) '()]\n    [(= n 0) '()]\n \
    \   [else (filter (lambda (x) (= x n)) (split s #\\Space #\\Space))]))\n", " \
    \ (cond\n    [(empty? s) '()]\n    [(equal? s \" \") '()]\n    [(equal? s \" \
    \ \") '()]\n    [(equal? s \"\") '()]\n    [else (cons\n           (first s)\n\
    \           (select_words (rest s)\n                         (- n (char-count\
    \ (first s)))))]))\n", "  (cond\n    ((empty? s) '())\n    ((equal? n 0) '())\n\
    \    (else (let ((c (first s))\n                 (rest (rest s)))\n          \
    \ (if (not (empty? rest))\n           (if (equal? (length c) (length rest))\n\
    \           (if (equal? (char-code c) (char-code (first rest)))\n           (cons\
    \ c (select_words (rest rest) (sub1 n)))\n           (select_words (rest rest)\
    \ (sub1 n))))))))\n", "  (cond\n    [(empty? s) '()]\n    [(= n 0) '()]\n    [(=\
    \ (length s) n) (cons (substring s 0 n) '())]\n    [else (cons (substring s 0\
    \ (+ n 1)) \n           (select_words (substring s n) (- n 1)))]))\n", "  (cond\n\
    \    [(empty? s) (empty)]\n    [else\n     (cond\n       [(equal? n 0) (list s)]\n\
    \       [(equal? n 1) (list (first s))]\n       [(equal? n 2) (cons (first s)\
    \ (select_words (rest s) (- n 1)))]\n       [(equal? n 3) (cons (first s) (select_words\
    \ (rest s) (- n 2)))]\n       [(equal? n 4) \n        (cons (first s)\n      \
    \         (select_words (rest s) (- n 3))\n               (cons (first s)\n  \
    \                     (select_words (rest s) (- n 4)))]\n       [(equal? n 5)\n\
    \        (cons (first s)\n               (select_words (rest s) (- n 3))\n   \
    \            (cons (first s)\n                       (select_words (rest s) (-\
    \ n 4))\n                       (cons (first s)\n                            (select_words\
    \ (rest s) (- n 5)))]\n       [(equal? n 6)\n        (cons (first s)\n       \
    \        (select_words (rest s) (- n 3))\n               (cons (first s)\n   \
    \                    (select_words (rest s) (- n 4))\n                       (cons\
    \ (first s)\n                            (select_words (rest s) (- n 5))\n   \
    \                         (cons (first s)\n                                  \
    \ (select_words (rest s) (- n 6))))]\n       [(equal? n 7)\n        (cons (first\
    \ s)\n               (select_words (rest s) (- n 3))\n               (cons (first\
    \ s)\n                       (select_words (rest s) (- n 4))\n               \
    \        (cons (first s)\n                            (select_words (rest s) (-\
    \ n 5))\n                            (cons (first s)\n                       \
    \            (select_words (rest s) (- n 6))\n                               \
    \    (cons (first s)\n                                        (select_words (rest\
    \ s) (- n 7))))]\n       [(equal? n 8)\n        (cons (first s)\n            \
    \   (select_words (rest s) (- n 3))\n               (cons (first s)\n        \
    \               (select_words (rest s) (- n 4))\n                       (cons\
    \ (first s)\n                            (select_words (rest s) (- n 5))\n   \
    \                         (cons (first s)\n                                  \
    \ (select_words (rest s) (- n 6))\n                                   (cons (first\
    \ s)\n                                        (select_words (rest s) (- n 7))\n\
    \                                        (cons (first s)\n                   \
    \                            (select_words (rest s) (- n 8))))]\n       [(equal?\
    \ n ", "  (if (empty? s)\n      '()\n      (cons (substring (string s) 0 n)\n\
    \            (select_words (substring (string s) n))))) \n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nI see what you did here, but your solution is not scalable, i.e.\
    \ you had to write more code for the general case. I'm also not sure why you think\
    \ that the OP knows how to find and count the consonants, and you only have shown\
    \ him/her how to find them.\n<|/ c |>\n<| c |>\nI think there is a reason OP mentioned\
    \ \"consonants\" in the title. He wants the solution to scale up to a more general\
    \ case where he wants to find the most common consonants.\n<|/ c |>\n<| c |>\n\
    The OP asked for \"consonants\" and then showed code that counts them and I showed\
    \ how to implement the solution for \"consonants\" too. There are different ways\
    \ to solve the problem and I chose a different one for counting consonants. Anyway\
    \ I see your point and will update my answer.\n<|/ c |>\n<| c |>\n, thank you,\
    \ I am glad you found it helpful.\n<|/ c |>\n<| a dscore=0 tags=string,racket,scheme\
    \ |>\nOh, I see! This problem can be simplified quite a bit. Here we go with the\
    \ problem as stated:\n<code>\n#lang racket\n", "  (cond\n    [(empty? s) '()]\n\
    \    [(equal? (car s) #\\M) (cons (car s) (select_words (cdr s) n))\n     (cons\
    \ (car s) (select_words (cdr s) n))]\n    [else (cons (car s) (select_words (cdr\
    \ s) n))]))\n", "  (cond\n    [(empty? s) (list)] \n    [(not (= (length s) n))\
    \ (list)] \n    [else (append (take s (- n 1))\n                   (select_words\
    \ (drop s (- n 1))\n                                 n))]))\n", "  (cond\n   \
    \ [(empty? s) (list)]\n    [(equal? n (length s))\n     (list (string->symbol\
    \ (car s)))]\n    [else \n     (let ([head (car s)])\n       (if (or (= head (car\
    \ s)) (equal? n (- n 1)))\n           (select_words (cdr s) n)\n           (append\
    \ \n            (select_words (cons (string->symbol (car s)) empty) n) \n    \
    \        (select_words (cdr s) n))))]))\n", "  (if (empty? s)\n      ()\n    \
    \  (cons (first s) (select_words (rest s) n))))\n", "  (cond\n    [(empty? s)\
    \ (list)] \n    [(equal? (count-consonants s) n) (cons (first s) (select_words\
    \ (rest s) n))] \n    [else (cons (first s) (select_words (rest s) n))]\n  )\n\
    )\n", "  ;; TODO: Use a hash table here\n  (define (helper s acc count)\n    (cond\n\
    \      [(empty? s) (append acc '())]\n      [(equal? (first s) count) (helper\
    \ (rest s) acc (+ count 1))]\n      [else\n       (helper (rest s) (cons (first\
    \ s) acc) count)]))\n  (helper s () (- n 1))) ", "  (cond ((empty? s) '())\n \
    \       ((equal? (count_vowels s) n) '())\n        (else (append (list (take_consonants\
    \ s n)) (select_words (rest_of_string s n) (- n 1))))))\n", "  (if (<= n 0)\n\
    \      '()\n      (let ((letters (string->list (string->symbol s))))\n       \
    \ (if (empty? letters)\n            (list s)\n            (append (select_words\
    \ (string->list (substring s 0 n)) (substring n 1))\n                    (list\
    \ letters))))))\n", "  (cond\n    [(empty? s) empty]\n    [(= n 0) empty]\n  \
    \  [else (cons (first s) (select_words (rest s) (sub1 n)))]))\n", "  (cond\n \
    \   [(empty? s) '()]\n    [(= n 0) '()]\n    [(= (count-consonants s) n) s]\n\
    \    [else (cons (string->word s)\n                (select_words (string->rest\
    \ s) (sub1 n)))]))", "  (cond\n    [(empty? s) '()]\n    [(eq? (count-cons s)\
    \ n) (cons s (select_words s (- n 1)))]\n    [else (cons (first s) (select_words\
    \ s (- n 1)))]))\n", "  (cond\n    [(empty? s) (list)] \n    [else (cons (car\
    \ s) (cons (car s) (select_words (cdr s) n)))]))\n", "  (if (empty? s) '())\n\
    \  (if (= 0 n) '())\n  (if (char-alphabet (char->integer (first s)) (char->integer\
    \ (rest s))) \n    (cons (first s)\n          (select_words (rest s) (sub1 n))))\n\
    \  (if (char-alphabet (char->integer (first s)) (char->integer (rest s))) \n \
    \   (cons (first s)\n          (select_words (rest s) (sub1 n)))\n    (select_words\
    \ (rest s) (sub1 n))\n    )\n  )\n", "  (cond\n    ((empty? s) '())\n    ((= n\
    \ 0) '())\n    ((= (count s) n) (list (first s)))\n    (else\n     (append (list\
    \ (first s))\n             (select_words (rest s) (sub1 n)))))\n  )\n)\n", " \
    \ (cond\n    [(empty? s) '()]\n    [else (cond\n            [(= n 0)\n       \
    \      empty]\n            [else\n             (cond \n               [(char=?\
    \ (first s) (first '(A B C D E F G H I J K L M N O P Q R S T U V W X Y Z))\n \
    \               (cons (first s) (select_words (rest s) (sub1 (+ n 1)))]\n    \
    \           [else (cons (first s) (select_words (rest s) (sub1 (+ n 1))))]\n \
    \              )])]))", "  (cond [(empty? s) '()]\n        [(= n 0)'()]\n    \
    \    [(symbol=? (first s) #\\&) '()]\n        [else (cons (first s) (select_words\
    \ (rest s) (sub1 n)))]))\n", "  (cond\n    [(empty? s) (list '())]\n    [(= n\
    \ 0) (list '())]\n    [(= n 1) (cons s (first s))]\n    [else (cons s (select_words\
    \ (rest s) (sub1 n)))]))\n", "  (cond [(empty? s) (list ())]\n        [(and (empty?\
    \ (cdr s)) (= (length s) n)) (list ())]\n        [(>= (length s) n) (list (car\
    \ s))]))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
