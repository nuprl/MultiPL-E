name: HumanEval_7_filter_by_substring
language: rkt
prompt: "#lang racket\n\n;; Filter an input list of strings only for ones that contain\
  \ given substring\n;; >>> (filter_by_substring (list ) \"a\")\n;; (list )\n;; >>>\
  \ (filter_by_substring (list \"abc\" \"bacd\" \"cde\" \"array\") \"a\")\n;; (list\
  \ \"abc\" \"bacd\" \"array\")\n(define (filter_by_substring strings substring)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate filter_by_substring))\n\
  \    (check-equal? (candidate (list ) \"john\") (list ))\n    (check-equal? (candidate\
  \ (list \"xxx\" \"asd\" \"xxy\" \"john doe\" \"xxxAAA\" \"xxx\") \"xxx\") (list\
  \ \"xxx\" \"xxxAAA\" \"xxx\"))\n    (check-equal? (candidate (list \"xxx\" \"asd\"\
  \ \"aaaxxy\" \"john doe\" \"xxxAAA\" \"xxx\") \"xx\") (list \"xxx\" \"aaaxxy\" \"\
  xxxAAA\" \"xxx\"))\n    (check-equal? (candidate (list \"grunt\" \"trumpet\" \"\
  prune\" \"gruesome\") \"run\") (list \"grunt\" \"prune\"))\n))\n\n(test-humaneval)"
completions: ["  (cond [(empty? strings) strings]\n        [(eq? (first strings) substring)\
    \ (filter_by_substring (rest strings) substring)]\n        [else (cons (first\
    \ strings) (filter_by_substring (rest strings) substring))]))\n", "  (filter strings-contains-substring\
    \ strings))\n", "  (filter (\u03BB (x) (equal? (string-ref x 0) substring)) strings))\n",
  "  (filter (lambda (str)\n           (string=? (string=? str substring) substring))\n\
    \         strings))", "  (cond [(null? strings) strings]\n        [(string-contains-substring\
    \ substring (car strings)) (cons (car strings) (filter_by_substring (cons (cdr\
    \ strings) (cddr strings)) substring))]\n        [else (filter_by_substring (cdr\
    \ strings) substring)]))\n", "  (cond [(empty? strings) empty]\n        [(member?\
    \ (car strings) substring) (cons (car strings) (filter_by_substring (cdr strings)\
    \ substring))]\n        [else (filter_by_substring (cdr strings) substring)]))\n",
  "  (if (empty? strings)\n      '()\n      (if (equal? (car strings) substring)\n\
    \          (cons (car strings) (filter_by_substring (cdr strings) substring))\n\
    \          (cons (car strings)\n                (filter_by_substring (filter_by_substring\
    \ (filter_by_substring (filter_by_substring (cdr strings)) substring) substring)\
    \ substring))))) ;; #lang racket\n", "  (cond [(null? strings) strings]\n    \
    \    [(string-contains-substring substring (string-ref strings 0)) (string-append\
    \ substring (string-ref strings 0))]\n        [else (filter_by_substring (substring\
    \ (string-ref strings 0)) substring)]))\n", "  (define (check string substr)\n\
    \    (if (null? string)\n        '()\n        (if (equal? (substr string) (substr\
    \ substr))\n            (cons string check)\n            (check (rest string)\
    \ substr)))))\n  (cond ((null? strings) '())\n        (else (let ((result '()))\n\
    \               (for ([string (first strings)])\n                   (for ([check\
    \ (filter string (substring string))])\n                     (cond ((equal? (length\
    \ check) 0) (append result check))\n                           (else (cons check\
    \ result)))))))\n        (else '())))\n", "  (cond\n    ((null? strings) '())\n\
    \    ((string=? substring (car strings)) (car strings))\n    (else (filter_by_substring\
    \ (filter_by_substring (cdr strings) substring) substring))))\n", "  (filter (\u03BB\
    \ (x) (= (string-match substring x) (string-length x))) strings))\n", "  (cond\
    \ [(empty? strings) strings]\n        [(member (car strings) substring) (cons\
    \ (car strings) (filter_by_substring (cdr strings) substring))]\n        [else\
    \ (filter_by_substring (cdr strings) substring)]))\n  ;; #lang racket\n  ;; Filter\
    \ a list of strings only for ones that contain given substring\n  (define (filter_by_substring\
    \ strings substring)\n    (cond [(empty? strings) strings]\n          [(member\
    \ (car strings) substring) (filter_by_substring (cdr strings) substring)]\n  \
    \        [else (filter_by_substring (cdr strings) substring)]))\n  ;; #lang racket\n\
    \  ;; Filter an input list of strings only for ones that contain given substring\n\
    \  ;; >>> (filter_by_substring (list ) \"a\")\n  ;; (list )\n  ;; >>> (filter_by_substring\
    \ (list \"abc\" \"bacd\" \"cde\" \"array\") \"a\")\n  ;; (list \"abc\" \"bacd\"\
    \ \"array\")", "  (filter (lambda (x) (member x substring)) strings))\n", "  (map\
    \ (lambda (s) (if (contains? (substring s) s) s))\n       (filter strings)))",
  "  (cond [(empty? strings) (list empty)]\n        [(equal? (substring \"\") (first\
    \ strings)) (list strings)]\n        [else (cons (first strings) (filter_by_substring\
    \ (rest strings) substring))]))\n", "  (filter (lambda (string) (member substring\
    \ string)) strings))\n", "  (cond ((null? strings) '())\n        ((list? (car\
    \ strings)) (filter_by_substring (filter_by_substring (car strings) substring)\
    \ (cdr strings)))\n        (else (and (= (car strings) substring)\n          \
    \         (filter_by_substring (strings (cdr strings)) substring)))))\n", "  (filter\
    \ (lambda (str)\n            (and (equal? substring str)\n                 (equal?\
    \ (first str) substring)))\n          strings))\n", "  (cond [(empty? strings)\
    \ empty]\n        [(string-match? substring (car strings)) (cons (car strings)\
    \ (string-match? substring (cdr strings)))]\n        [else (string-match? substring\
    \ (car strings)) (filter_by_substring (cdr strings) substring)]\n  ))\n", "  (cond\
    \ [(null? strings) '()]\n        [(string-contains? substring (car strings)) (string-append\
    \ (car strings) substring)]\n        [else (cons (car strings) (filter_by_substring\
    \ (cdr strings) substring))]))\n", "  (filter (lambda (s) (memq s (string-split\
    \ substring))))\n  (string-join (map string-append strings (string-split substring))))",
  "  (cond [(null? strings) '()]\n        [(string-contains-substring substring (string-ref\
    \ strings 0))\n         (cons (string-ref strings 0)\n               (filter_by_substring\
    \ (string-rest strings)\n                                   (substring (string-ref\
    \ strings 0))))]\n        [else (filter_by_substring (string-rest strings) substring)]))\n",
  "  (filter \n   (lambda (x)\n     (include? x substring)\n   strings))\n", "  (define\
    \ (helper str index)\n    (cond ((eq? index 0) (list str))\n          ((string=?\
    \ (substring str) substring) (helper str (add1 index)))\n          (t (helper\
    \ (cdr str) (add1 index)))))\n  (helper strings 0))\n</code>\n<|/ a |>\n<| c |>\n\
    I think this is the most concise and efficient solution. Thank you!\n<|/ c |>\n\
    <| a tags=racket,list |>\nI find it more intuitive to first create a list containing\
    \ the elements I want to keep and then use subseq.\n<code>", "  (filter string?\
    \ strings))\n", "  (filter substring strings))\n", "  (if (null? strings)\n  \
    \    '()\n      (if (eq? (first strings) substring)\n          (cons (first strings)\
    \ (filter_by_substring (rest strings) substring))\n          (cons (first strings)\
    \ (filter_by_substring (rest strings) substring))))))\n", "  (cond [(empty? strings)\
    \ empty]\n        [(equal? (first strings) substring) (cons first strings)]\n\
    \        [else (cons (first strings)\n                    (filter_by_substring\
    \ (substring (second strings))\n                                    substring)))]))\n",
  "  (apply append (map (lambda (string) (if (string-contains string substring)\n\
    \                                       string\n                             \
    \          (list))) strings)))\n", "  (map substring (filter (lambda (x) (memq\
    \ x strings)))))\n", "  (reverse (filter (lambda (x) (contains-string? x substring))\
    \ strings)))\n", "  (filter (lambda (substr)\n            (member substring substr)\n\
    \          strings))\n  )\n", "  (cond\n    [(empty? strings) empty]\n    [(equal?\
    \ (first strings) substring) (filter_by_substring (tail strings) substring)]\n\
    \    [else (cons (first strings)\n                (filter_by_substring (tail strings)\
    \ substring))]))\n", "  (cond\n    ((null? strings) strings)\n    ((= (length\
    \ strings) 0) strings)\n    (else (append (filter_by_substring (rest strings)\
    \ substring)\n                (list (first strings))))))\n", "  (cond [(empty?\
    \ strings) '()]\n        [(string-contains-substring substring (car strings))\n\
    \         (cons (car strings) (filter_by_substring (cdr strings) substring))]\n\
    \        [else (filter_by_substring (cdr strings) substring)]))\n", '  (filter
    strings? (substring strings)))', "  (cond [(null? strings) strings]\n        [(equal?\
    \ (car strings) substring) strings]\n        [else (append (filter_by_substring\
    \ (cdr strings) substring)\n                    (list strings))]))\n</cell>\n\
    <code language=dyalog-kernel>\n#lang racket\n", "  (cond\n    ((empty? strings)\
    \ strings)\n    ((equal? (first strings) substring) (filter_by_substring (rest\
    \ strings) substring))\n    (else (cons (first strings) (filter_by_substring (filter_by_substring\
    \ (rest strings) substring) substring)))))\n", "  (cond (null? strings) strings\n\
    \        (string-contains substring (first strings))\n        (filter_by_substring\
    \ (rest strings) substring)\n        ;; No match\n        :else (cons (first strings)\
    \ (filter_by_substring (rest strings) substring))\n       ))", "  (if (null? substring)\n\
    \      strings\n      (filter_by_substring (substring (car strings)) (cadr strings))))\n",
  "  (filter (lambda (element) (= (string-index element substring) 0)) strings))\n",
  "  (flatten (filter substring strings)))\n", "  (cond [(null? strings) strings]\n\
    \        [(member (car strings) substring)\n         (filter_by_substring (tail\
    \ strings) substring)]\n        [else (cons (car strings)\n                  \
    \  (filter_by_substring (tail strings)\n                                     substring))]))\n",
  "  (filter string? strings (map substring strings)))\n", "  (cond [(empty? strings)\
    \ strings]\n        [(equal? (first strings) substring) (filter_by_substring (rest\
    \ strings) substring)]\n        [else (cons (first strings)\n                \
    \    (filter_by_substring (filter_by_substring (rest strings) substring) substring))]))\n",
  "  (map string->string (string-filter (lambda (s)\n                            \
    \         (string=? (substring s) (string-first s)))\n                       \
    \                      strings)))\n  #'string->string)\n", "  (cond\n    [(empty?\
    \ strings) strings]\n    [(string? (first strings)) (cond\n                  \
    \                 [(string-match? substring (string-ref (string-first strings)\
    \ 0))\n                                     (cons (string-ref (string-first strings)\
    \ 0) (string-rest strings))]\n                                   [else (cons (first\
    \ strings) (filter_by_substring (rest strings) substring))]\n                \
    \                  )]))", "  ;; TODO: add some special handling for cases where\
    \ substring appears as substring\n  (filter (lambda (string)\n           (or (contains\
    \ string substring) (contains substring string)))\n         strings))\n", "  (filter\
    \ (\u03BB (string) (member substring string))\n          strings))\n", "  (define\
    \ (helper string substring acc)\n    (cond [(null? string) acc]\n          [(string=?\
    \ string substring) acc]\n          [(string=? (string-tail string) substring)\
    \ (helper \n                                                    (string-tail string)\
    \ \n                                                    (cons (string-head string)\n\
    \                                                  acc))]\n          [else (helper\
    \ (string-tail string)\n                       (cons (string-head string) acc))]\n\
    \          ))\n  (helper strings substring '()))", "  (cond (empty? strings) empty\n\
    \        (equal? (first strings) substring) (rest strings)\n        (else (filter_by_substring\
    \ (filter_by_substring (filter_by_substring (rest strings)) substring) substring))))\n",
  "  (filter (lambda (s)\n           (and (string= substring s) (string-length s))\n\
    \           (not (null? (string->list s))))\n         strings))\n", "  (cond [(empty?\
    \ strings) strings]\n        [(equal? (first strings) substring) (list strings)]\n\
    \        [else (cons (first strings) (filter_by_substring (rest strings) substring))]))\n",
  "  (filter string? strings (lambda (s) (contains substring s))))\n", "  (cond [(empty?\
    \ strings) strings]\n        [(string-contains? substring (car strings)) \n  \
    \       (filter_by_substring (tail strings) substring)]\n        [else (cons (car\
    \ strings) (filter_by_substring (tail strings) substring))]))\n", "  (cond\n \
    \   [(empty? strings) strings]\n    [else (if (equal? (first strings) substring)\
    \ (strings (rest strings)) \n               (filter_by_substring (filter_by_substring\
    \ (first strings) substring) (strings (rest strings))))]))\n", "  (cond\n    [(empty?\
    \ strings) strings]\n    [(string-contains-substring strings (substring \"\"))\
    \ strings]\n    [else (filter_by_substring (filter_by_substring (substring strings)\
    \ substring) substring)]))\n", "  (cond (empty? strings) '()\n        (equal?\
    \ (first strings) substring)\n        (else (strings\n                   (filter_by_substring\
    \ (rest strings)\n                                    substring)))))\n", "  (cond\
    \ [(empty? strings) '()]\n        [(string-match? substring (car strings)) (cons\
    \ substring\n                                              (filter_by_substring\
    \ (cdr strings)\n                                                            \
    \   substring))]\n        [else (cons (car strings)\n                    (filter_by_substring\
    \ (cdr strings)\n                                      substring))]))\n", "  ;;\
    \ The idea is to convert the input list of strings to a list of lists\n  ;; and\
    \ to use the 'map' function on it.\n  (apply map (lambda (str)\n             \
    \ (if (string-contains str (string-append substring \"\"))\n                 \
    \ str)))\n  )\n", "  (if (null? strings) (list ())\n      (if (string-contains?\
    \ substring (string-ref strings 0)) \n          (cons (string-ref strings 0) \n\
    \                (filter_by_substring (string-cdr strings) substring))\n     \
    \     (filter_by_substring (string-cdr strings) substring))))\n", "  (cond\n \
    \   ((null? strings) '())\n    ((member (car strings) substring) (strings))\n\
    \    (else (cons (car strings) (filter_by_substring (remove (cdr strings) substring))))))",
  "  (cond [(empty? strings) strings]\n        [else (string-match? (substring (car\
    \ strings)) substring)\n               (filter_by_substring\n                (filter_by_substring\
    \ (cdr strings) substring)\n                (car strings))]))\n", "  (if (null?\
    \ strings)\n      '()\n      (append (filter_by_substring (substring string) substring)\n\
    \              (cons (car strings) (filter_by_substring (cdr strings) substring)))))\n",
  "  (cond [(empty? strings) strings]\n        [else (if (equal? (car strings) substring)\n\
    \                  (filter_by_substring (substring cdr strings)\n            \
    \                        substring)\n                  (cons (car strings) (strings\
    \ (filter_by_substring (substring cdr strings)\n                             \
    \                            substring))))]))\n", "  (cond [(empty? strings) empty]\n\
    \        [(string=? substring (first strings)) (cons (first strings) strings)]\n\
    \        [else (filter_by_substring (tail strings) substring)]))\n</cell>\n<code\
    \ language=racket-student>\n#lang racket\n", "  (cond\n    [(null? strings) '()]\n\
    \    [(equal? substring '') strings]\n    [else (cons (string->list\n        \
    \           (string->string\n                    (substring (first strings) 0))\n\
    \                   (filter_by_substring (rest strings) substring))]))) ; substring\
    \ as first parameter, since it's faster\n</code>\nThe idea is that we walk through\
    \ each string in strings and check whether it contains substring. If substring\
    \ matches any part of strings (substrings beginning or ending with the substring\
    \ are ignored), we cons the string as list element. Otherwise we return the list\
    \ as is. \nThis implementation is also quite efficient in time and space, since\
    \ strings are only consed once.\n<|/ a tags=list,racket,string |>\n<| c |>\nOk,\
    \ this is more efficient than my solution, I think. I just wonder if it could\
    \ perform better on a large string list.\n<|/ c |>\n<| a tags=list,racket,string\
    \ |>\nA recursive solution can be easily implemented using the standard procedures.\
    \ In this case, map can be used, with filter instead of map.\n<code>", "  (cond\
    \ (null? strings) #t (strings (rest strings) substring))\n  (else (filter_by_substring\
    \ (strings (rest strings)) substring))))\n", "  (filter (lambda (str) (string-contains\
    \ str substring)) strings))\n", "  (flatten (filter (lambda (x) (substring x))\
    \ strings)))\n", "  (filter substring-by-string? strings))\n", "  (filter (lambda\
    \ (x)\n            (contains-string? x substring))\n          strings))\n", " \
    \ (cond [(empty? strings) strings]\n        [(and (empty? (car strings)) (empty?\
    \ (cdr strings))) (list strings)]\n        [(and (empty? (car strings)) (empty?\
    \ (cdr strings))) (list strings )]\n        [(empty? (car strings)) (strings (cdr\
    \ strings))]\n        [else (cons (first strings)\n                    (filter_by_substring\
    \ (substring (rest strings))\n                                       (cons (substring\
    \ (car strings)) (second strings))))]))\n", "  (filter (lambda (x) (string=? substring\
    \ x)) strings))\n", "  (if (null? strings)\n      '()\n      (if (string=? (substring\
    \ (car strings)) substring)\n          (cons (car strings) (filter_by_substring\
    \ (cdr strings) substring))\n          (cons (car strings) (filter_by_substring\
    \ (cons (cdr strings) \"\") substring))))))\n", "  (cond\n    [(empty? strings)\
    \ empty]\n    [(substring (car strings)) (cons (car strings) empty)]\n    [else\
    \ (filter_by_substring(cdr strings) substring)]))\n</code>\n<|/ a tags=string,racket,scheme\
    \ dscore=2 |>\n<| a tags=string,racket,scheme |>\nA simple solution is to use\
    \ filter. \n<code>", "  (cond\n    ((null? strings) strings)\n    ((equal? (car\
    \ strings) substring) (filter_by_substring (cdr strings) substring))\n    (else\
    \ (cons (car strings) (filter_by_substring (filter_by_substring (cdr strings)\
    \ substring) substring)))))\n", "  (define (subseq? s sub)\n    (< #(subseq s\
    \ 0 0) (length sub)))\n  (cond ((null? strings) '())\n        ((subseq? strings\
    \ substring) (cons (first strings) (filter_by_substring (rest strings) substring)))\n\
    \        (else (filter_by_substring (cons (first strings) (filter_by_substring\
    \ (rest strings) substring))\n                                substring))))\n",
  "  (filter (lambda (elem) (equal? (substring elem) (string-length substring))) strings))\n",
  "  (filter (lambda (element)\n            (equal? (string-ref element 0) substring))\n\
    \          strings))\n", "  (map (\u03BB (s)\n         (if (string-contains s\
    \ substring)\n             (cons s strings))) strings))\n", "  (cond [(empty?\
    \ strings) strings]\n        [(member substring strings)\n         (filter_by_substring\
    \ (substring strings) substring)]\n        [else\n         (cons (first strings)\n\
    \               (filter_by_substring\n                (drop 1 (rest strings))\n\
    \                substring))]))\n", "  (filter strings-contains-substring strings))\n",
  "  (filter #(equal? (substring %) (string-ref %1 0)) strings))\n</code>\n<|/ a |>\n\
    <| c |>\nIt can be even more readable if you use a `let` instead of `define` here:\
    \ `(let loop ((i 0) (list strings) (found #f))\n   (cond [(or (null? list) (not\
    \ found))\n          list]\n         [(string=? (string-ref list i) substring)\
    \ (loop (+ i 1) (substring strings) #t)]\n         [else (loop (+ i 1) (filter_by_substring\
    \ (substring strings) (string-ref list i)) (or (not found) (string=? (string-ref\
    \ list i) substring)))]))`\n<|/ c |>\n<| a dscore=1 |>\nA variant of Sjoerd's\
    \ answer that doesn't require an explicit loop counter:\n<code>", "  (cond [(null?\
    \ strings) strings]\n        [(string=? (car strings) substring) (filter_by_substring\
    \ (filter_by_substring (cdr strings) substring) substring)]\n        [else (cons\
    \ (car strings) (filter_by_substring (cdr strings) substring))]))\n", "  (cond\
    \ [(empty? strings) strings]\n        [(member (car strings) substring) \n   \
    \      (filter_by_substring (filter (cdr strings) substring) substring)]))\n",
  "  (filter (lambda (str)\n            (contains? substring str))\n          strings))\n",
  "  (cond [(empty? strings) '()]\n        [(equal? (car strings) substring)\n   \
    \      (cons (car strings) (rest strings))]\n        [else (cons (car strings)\n\
    \                   (filter_by_substring (rest strings) substring))]))\n", " \
    \ (if (empty? strings)\n      ()\n      (cons (first strings)\n            (filter_by_substring\
    \ (drop 1 strings)\n                              substring))))\n", "  (cond [(null?\
    \ strings) empty]\n        [(null? substring) strings]\n        [(member (car\
    \ strings) substring)\n         (filter_by_substring (cdr strings) substring)]\n\
    \        [else (strings (car strings))]))\n", "  (map (\u03BB (string) (when (member\
    \ string substring) (list string))) strings))\n", "  (cond [(empty? strings) '()]\n\
    \        [(string-equal? substring (string-ref (string-first strings) 0)) \n \
    \        (cons (string-first strings) (filter_by_substring (list-tail strings)\
    \ substring))] \n        [else (cons (string-first strings) \n               \
    \     (filter_by_substring (list-tail strings) substring))]))\n", "  (for/or ([item\
    \ (in-list strings)])\n      (if (string=? item substring)\n          (cons item\
    \ '())\n          (cons item strings))))\n", "  (if (empty? strings)\n      '()\n\
    \      (if (contains-substring substring (strings))\n          (cons (car strings)\
    \ (filter_by_substring (rest strings) substring))\n          (filter_by_substring\
    \ (strings (cdr strings)) substring))))\n", "  (filter strings-contains? substring\
    \ strings))\n", "  (filter (lambda (s) (member s substring)) strings))\n", " \
    \ (cond\n    [(string-empty? strings) '()]\n    [(equal? (substring '\"\") (string-ref\
    \ (string-first strings) 0)) (string-tail strings)]\n    [else (append (filter_by_substring\
    \ (list-tail strings) substring) (list-tail strings)])\n  )\n)\n</cell>\n<text>\n\
    Exercise 7 - Filtering a list of strings for only ones that begin with the prefix\
    \ \"abc\"\nThe function should return a list that only contains strings that start\
    \ with the prefix \"abc\".\n\nFor this exercise, use a recursive approach in writing\
    \ a function that only filters a list of strings for ones that begin with the\
    \ prefix \"abc\".\n\nFor each sub-list, (filter-by-substring) should return a\
    \ list containing only the strings starting with \"abc\". For example:\n", " \
    \ (map string->list strings))\n</code>\n<|/ a |>\n<| c |>\nThank you for putting\
    \ this together - I like that it takes the input list and returns the output list\
    \ - much easier than my solution.\n<|/ c |>\n<| c |>\nThis solution still has\
    \ the issue of not filtering the input list by the substring. For example, if\
    \ the input list is '(foo bar baz)' and substring is 'bar', the resulting list\
    \ should be '(bar baz)', not '(bar baz foo)'.\n<|/ c |>\n<| c |>\nThe first sentence\
    \ of code should read \"filter a list of strings only for ones that contain given\
    \ substring\"\n<|/ c |>\n<| a tags=list,racket,scheme |>\nYou can do this in constant\
    \ time by converting your list into a hash table and using that hash to determine\
    \ whether each string is in your search string.\n<code>", "  (cond [(empty? strings)\
    \ empty]\n        [(string-contains-substring (string-ref strings 0) substring)\n\
    \         (cons strings (filter_by_substring (tail strings) substring))]\n   \
    \     [else (strings (filter_by_substring (tail strings) substring))]))\n", " \
    \ (if (null? strings)\n      '()\n      (cond ((member substring strings) strings)\n\
    \            ((string? (car strings)) (filter_by_substring (substring (car strings))\
    \ substring))\n            (else (filter_by_substring (cdr strings) substring)))))\n",
  "  (cond\n    ((empty? strings)\n     strings)\n    (else (cond\n             ((null?\
    \ (first strings))\n               (filter_by_substring (rest strings) substring))\n\
    \             (else (cond\n                       ((= (first strings) substring)\n\
    \                        (filter_by_substring (cons (first strings) (rest strings))\
    \ substring))\n                       (else\n                        (cons (first\
    \ strings)\n                              (filter_by_substring (cons (rest strings)\
    \ strings) substring)))))) ))) ))\n", "  (cond\n    [(empty? strings) empty]\n\
    \    [else (cons (substring (first strings)) \n\t\t (filter_by_substring (rest\
    \ strings) substring))]\n    ))\n", "  (map (\u03BB (x) \n         (if (equal?\
    \ x substring)\n             (list x)\n             (cons x (filter x strings))))\n\
    \       strings))\n", "  (map (lambda (x)\n         (cond [(member x substring)\
    \ (list x)]\n               [else x]))\n       strings))\n", "  (cond\n    [(empty?\
    \ strings) '()]\n    [(string-contains-substring substring (car strings)) \n \
    \    (cons (car strings) (filter_by_substring (cdr strings) substring))]\n   \
    \ [else (filter_by_substring (cdr strings) substring)]))\n", "  (cond\n    [(empty?\
    \ strings) empty]\n    [(string-contains? string substring) (concat string)]\n\
    \    [else (concat strings)]))\n", "  (cond [(null? strings) strings]\n      \
    \  [(equal? (car strings) substring) (cons (car strings) strings)]\n        [else\
    \ (filter_by_substring (filter_by_substring (cdr strings) substring) substring)]))\n",
  "  (cond\n    ((null? strings) '())\n    ((string= substring (car strings)) \n \
    \    (cdr strings))\n    (else (filter_by_substring (cdr strings) substring))))\n",
  "  (cond [(empty? strings) '()]\n        [(eq? (caar strings) substring) (cons (car\
    \ strings) '())]\n        [else (cons (car strings)\n                    (filter_by_substring\
    \ (cdr strings) substring))]))\n", "  (filter (\u03BB (x) (string-contains? x\
    \ substring)) strings))\n", "  (define (filter items substring)\n    (cond\n \
    \     [(null? items) '()]\n      [(string=? (substring (car items)) substring)\
    \ '((car items)))]\n      [else (cons (car items) (filter (cdr items) substring))]))\n\
    \  (filter (reverse (string->list strings)) substring))\n", "  (if (null? substring)\n\
    \      strings\n      (let ((first-match (member substring (string-ref strings\
    \ 0))))\n        (cond ((null? (string-ref strings 0))\n              (string-append\
    \ strings \"\"))\n              ((null? first-match)\n               (append strings\
    \ (list \"\")))\n              (else (append (string-append strings \"\") (string-ref\
    \ strings (+ 0 (string-length first-match)))))\n              )\n        )\n \
    \     )\n  )\n#lang racket\n", "  (cond ((null? strings) nil)\n        ((member\
    \ (string-ref strings 0) substring) (string-ref strings 0))\n        (else (filter_by_substring\
    \ (filter (lambda (s) (string-ref s 0)) strings)\n                           \
    \   substring))))\n", "  (define (iter l substr)\n    (cond\n      [(null? l)\
    \ (string-append \"()\" \"\")] \n      [(equal? (caar l) substr) (string-append\
    \ (cadar l) \"\")] \n      [else (string-append (iter (cdr l) substr) (car l))]))\n\
    \  (iter strings substring))\n", "  (cond [(empty? strings) (list)]\n        [(equal?\
    \ (first strings) substring) (cons (first strings) strings)]\n        [else (cons\
    \ (first strings)\n                    (filter_by_substring (rest strings)\n \
    \                                     substring))]))\n", "  (cond [(empty? strings)\
    \ strings]\n        [(substring string) strings])\n)\n", "  (filter (lambda (s)\
    \ (includes? substring s)) strings))\n", "  (cond (null? strings) strings\n  \
    \      (string=? (substring (car strings)) substring)\n        (else (cons (car\
    \ strings) (filter_by_substring (cdr strings) substring)))))\n", "  (let loop\
    \ ((i 0) (result '()))\n    (cond\n      [(empty? strings) result]\n      [else\
    \ (if (equal? (first strings) substring) (loop (+ i 1) (cons (first strings) result)))]\n\
    \      [else (loop (+ i 1) (cons (first strings) result))])))\n", "  (cond [(empty?\
    \ strings) (empty? substring)]\n        [(equal? (car strings) substring) (cons\
    \ (car strings) (filter_by_substring (cdr strings) substring))]\n        [else\
    \ (cons (car strings) (filter_by_substring (cdr strings) substring))]\n    )\n\
    )\n</code>\nAs you can see there is some repetition in our code. Think about that\
    \ for three or more strings. So let's define a helper function to filter our strings\
    \ only once.\n<code>", "  (filter\n   (\u03BB (x)\n      (equal? (string-match\
    \ substring x) 1))\n   strings))\n", "  (cond\n    ((null? strings) '())\n   \
    \ ((string? (car strings)) (cons (car strings) (filter_by_substring (cdr strings)\
    \ substring)))\n    (else\n     (cons (first strings)\n           (filter_by_substring\
    \ (filter (fn (car strings) (lambda (string) (substring string 0))) (cdr strings)\n\
    \                                  substring)))\n     )\n   ))\n", "  (cond\n\
    \    [(empty? strings) empty]\n    [(equal? (first strings) substring) (cons (first\
    \ strings) strings)]\n    [else (cons (first strings)\n                (filter_by_substring\
    \ (rest strings)\n                                  substring))]\n  ))\n", " \
    \ (cond\n    [(empty? strings) '()]\n    [(string-contains? substring (string-ref\
    \ strings 0)) \n     (cons (string-ref strings 0)\n           (filter_by_substring\
    \ (substring (substring (reverse (string-ref strings 0))) (string-ref strings\
    \ 1)))]\n    [else (filter_by_substring (string-tail strings)\n              \
    \             substring)]))\n", "  (filter (lambda (str)\n            (string=\
    \ (substring str) substring))\n          strings))\n", "  (cond ((empty? strings)\
    \ '())\n        ((member (car strings) substring) (filter_by_substring (cdr strings)\
    \ substring))\n        (else (cons (car strings) (filter_by_substring (cdr strings)\
    \ substring)))))\n", "  (cond\n    ((empty? strings) '())\n    ((member? (car\
    \ strings) substring) (strings))\n    (else (filter_by_substring (filter_by_substring\
    \ (cdr strings) substring) substring))))\n", "  (cond [(empty? strings) strings]\n\
    \        [(= 0 (string-length substring)) strings]\n        [(string-contains?\
    \ substring (string-ref (string-ref strings 0) 0))\n         (filter_by_substring\
    \ (substring (rest strings)) substring)]))\n", "  (define (filter-by-substring\
    \ input substring)\n    (if (null? input)\n        '()\n        (if (string=?\
    \ substring (car input))\n            (cons (car input) (filter-by-substring (cdr\
    \ input) substring))\n            (filter-by-substring (cons (car input) (cdr\
    \ input)) substring))))\n  (filter-by-substring strings substring))\n", "  (cond\
    \ [(null? strings) strings]\n        [(equal? (car strings) substring) (cons (car\
    \ strings) (strings))]\n        [else (cons (car strings)\n                  \
    \  (filter_by_substring (cdr strings)\n                                     substring))]))\n",
  "  (filter\n   (lambda (str) (string=? (string-ref str 0) substring))\n   strings))\n",
  "  (cond ((null? strings) (strings))\n        (else (map (lambda (x) (when (string=?\
    \ x substring) (cons x strings))) strings))))\n</cell>\n<text>\nExercise 5: Write\
    \ a filter_by_prefix function that filters an input list of strings only for ones\
    \ that contain given prefix\n>>> (filter_by_prefix (list \"a\" \"b\") \"ab\")",
  "  (filter (lambda (str) (member str (substring strings)))\n          strings))\n",
  "  (filter (lambda (x)\n            (member x substring))\n          strings))\n",
  "  (let loop ((input strings)\n             (found false))\n    (cond ((null? input)\
    \ (or found (= found false)))\n          ((memq (car input)\n                \
    \ (cadr input)\n                 false)\n           (loop (cdr input) true))\n\
    \          (else\n           (loop (cdr input) (or (memq (car input)\n       \
    \                                (cadr input)\n                              \
    \         false)\n                                  found))))))\n", "  (define\
    \ (helper strings substring i)\n    (cond [(null? strings) '()]\n          [(eq?\
    \ i (string-length substring)) (string->list strings)]\n          [else\n    \
    \       (let ([string (substring (car strings) i)])\n             (helper strings\
    \ (substring string) (incf i))\n             )\n           ]\n          ))\n \
    \ (helper strings substring 0))\n", "  (map #(when (find substring %) #%) (subseq\
    \ strings)))\n</cell>\n<text>", "  (cond\n    [(empty? strings) (list strings)]\n\
    \    [else (cond\n             [(string-contains? strings substring) (list strings)]\n\
    \             [else (cons (first strings)\n                         (filter_by_substring\
    \ (remove strings substring)))]))]))\n", "  (cond [(empty? strings) empty]\n \
    \       [(substring (car strings))\n         (filter_by_substring (cdr strings)\
    \ substring)]\n        [else (cons (car strings)\n                  (filter_by_substring\
    \ (cdr strings) substring))]))\n", "  (cond\n    ((null? strings) strings)\n \
    \   ((string=? substring (car strings)) strings)\n    (else (filter_by_substring\
    \ (filter_by_substring (filter_by_substring strings (cdr strings)) substring)\
    \ substring))))\n", "  (if (null? strings)\n      (strings)\n      (filter_by_substring1\
    \ (car strings) (substring substring) (filter_by_substring1 (cdr strings) substring))))\n",
  "  (define (helper i acc)\n    (cond\n      [(empty? strings) acc]\n      [(equal?\
    \ (first strings) substring) (helper i (cons (first strings) acc))]\n      [else\
    \ (helper (rest strings) (cons (first strings) acc))]\n      ))\n  (helper 0 empty))\n",
  "  (define (iter current i l)\n    (cond [(null? l) (list current)]\n          [(equal?\
    \ (string-ref l i) substring) (cons current l)]\n          [else (iter (cons (string-ref\
    \ l i) current) i (cdr l))]))\n  (iter '() 0 strings))\n", "  (cond ((null? strings)\
    \ '())\n        ((member substring strings)\n         (cons (car strings) (filter_by_substring\
    \ (cons (cdr strings) strings) substring)))\n        (else (filter_by_substring\
    \ (cons (cdr strings) strings) substring))))\n", "  (filter (lambda (s) (member\
    \ s substring)) strings))\n", "  (cond [(empty? strings) '()]\n        [(member\
    \ substring strings) (cons substring strings)]\n        [else (filter_by_substring\
    \ (strings-reverse strings) substring)]))\n", "  (let ([f (lambda (substring)\
    \ (member substring strings))])\n    (filter f)))\n", "  (if (null? substring)\n\
    \      strings\n      (if (string= (first strings) substring)\n          (filter_by_substring\
    \ (next strings) substring)\n          (cons (first strings) (filter_by_substring\
    \ (next strings) substring)))))\n", "  (map #(if (string-match substring %) #%)\n\
    \       (reverse strings)))\n", "  (string-filter strings substring #t))\n", " \
    \ (cond\n    [(empty? strings) (empty? substring)]\n    [(equal? (first strings)\
    \ substring) (list strings)]\n    [else (filter_by_substring\n           (rest\
    \ strings)\n           (cons (first strings) substring))]))\n</code>\n<|/ a tags=scheme,racket\
    \ |>\n<| c |>\nThanks for your answer! I'll have a look at the `filter` function\
    \ and see if I can understand it better\n<|/ c |>\n<| a dscore=0 |>\nIf you're\
    \ not interested in recursion and want to avoid the use of recursion, here's a\
    \ function that can return the list of strings that contain the substring:\n<code>",
  "  (cond [(null? strings) empty]\n        [(eq? (first strings) substring) (tail\
    \ strings)]\n        [else (cons (first strings) (filter_by_substring (rest strings)\
    \ substring))]))\n", "  (cond\n    ((empty? strings) empty)\n    ((substring empty?\
    \ (car strings)) (car strings))\n    ((equal? (car strings) substring) (filter_by_substring\
    \ (tail strings) substring))\n    (else (filter_by_substring (tail strings) substring))))\n",
  "  (map (lambda (x) (when (find x substring) x)) strings))\n", "  (cond\n    [(empty?\
    \ strings) empty]\n    [(member (car strings) substring) (cons (car strings) (filter_by_substring\
    \ (cdr strings) substring))]\n    [else (filter_by_substring (cdr strings) substring)]))\n",
  "  (cond [(empty? strings) strings]\n        [(string=? (car strings) substring)\
    \ (cons (car strings) strings)]\n        [else (filter_by_substring (filter_by_substring\
    \ (cdr strings) substring) substring)]))\n", "  (cond\n    [(null? strings) strings]\n\
    \    [else (cons (first strings)\n                (filter_by_substring (tail strings)\
    \ substring))]\n    ))\n</code>\nI hope this helps you with your problem!\n<|/\
    \ a tags=string,filter,racket,list |>\n<| c |>\nThank you, I'm new to Racket,\
    \ what is the difference between using filter and filter_by_substring?\n<|/ c\
    \ |>\n<| c |>\n: In general, you can only use `filter` when you want to filter\
    \ the list based on the result of a predicate (which is true or false), such as\
    \ `filter (\u03BB (x) (equal? x \"a\")) '(a b c d e f g) ; => '(\"a\" \"b\" \"\
    c\")`. Using `filter_by_substring`, you get a list of strings that contain the\
    \ given substring, which means you could then use the result to filter the other\
    \ list. Hope this answers your question!\n<|/ c |>\n<| c |>\nHow could I do this\
    \ with lambda?\n<|/ c |>\n<| a tags=string,filter,racket,list |>\nUsing Racket's\
    \ list processing facilities it might be possible to do it in a single list comprehension,\
    \ using filter and sublist?. \nI believe a list comprehension like this would\
    \ do it:\n<code>", "  (cond\n    [(empty? strings) '()]\n    [(string=? (first\
    \ strings) substring) (cons (first strings) (filter_by_substring (next strings)\
    \ substring))]\n    [else (filter_by_substring (next strings) substring)]))\n",
  "  (map (fn [string] (find string substring)) strings))\n", "  (map #(when (string-contains\
    \ % substring)\n          (cons (substring %) (string-append % \"\"))\n      \
    \    %)\n       (reverse strings)))\n", "  (cond\n    ((null? strings) strings)\n\
    \    (else (append (filter_by_substring (first strings) substring)\n         \
    \        (filter_by_substring (rest strings) substring)))))\n", "  (filter (lambda\
    \ (str)\n           (memq str substring))\n         strings))\n", "  (let loop\
    \ ((strings strings)\n             (strings-length 0)\n             (substring\
    \ substring))\n    (cond\n      [(empty? strings) strings]\n      [else\n    \
    \  (cond [(not (substring (car strings)))\n             (loop (cdr strings) (strings-length\
    \ strings) substring)] \n            [else \n             (loop (cdr strings)\
    \ (strings-length (car strings)) (substring (car strings)))]))]))\n", "  (filter\
    \ (lambda (str)\n            (string=? str substring))\n          strings))",
  "  (cond\n    [(string-equal? substring \"\") (list \"\")]\n    [(empty? strings)\
    \ (list \"\")]\n    [else (string-contains-substring substring strings)]))\n",
  "  (define (filter-by-substring items)\n    (cond\n      [(empty? items)\n     \
    \  #()]\n      [(string=? (first items) substring)\n       (cons items (filter-by-substring\
    \ (substring (rest items))))]\n      [else\n       (cons (first items) (filter-by-substring\
    \ (substring (rest items)))])]))\n  (filter-by-substring (list substring ) strings))\n",
  '  (filter (lambda (s) (string-contains s substring)) strings))', "  (cond ((null?\
    \ strings) strings)\n        (else (if (string= (first strings) substring)\n \
    \                 (filter_by_substring (rest strings) substring)\n           \
    \       (cons (first strings) (filter_by_substring (rest strings) substring)))))\n\
    \  )\n", "  (cond [(null? strings) empty]\n        [else (if (contains? (first\
    \ strings) substring)\n                   (filter_by_substring (tail strings)\
    \ substring)\n                   (filter_by_substring (first strings) substring))]\n\
    \        ))\n", "  (cond\n    ((null? strings) '())\n    ((equal? (first strings)\
    \ substring)\n     (filter_by_substring (rest strings) substring))\n    (else\n\
    \     (cons (first strings)\n           (filter_by_substring (rest strings) substring))))\n\
    </code>\n<|/ a dscore=2 |>\n<| a tags=racket,functional-programming,list,scheme\
    \ |>\nYou could use filter and a predicate which filters out the empty lists.\n\
    <code>", "  (filter strings-contains substring strings))\n", "  (map (\u03BB (x)\n\
    \         (if (equal? (string-length substring)\n                   (string-length\
    \ x))\n             (append x (filter_by_substring (rest x) substring))\n    \
    \         x))\n       (reverse strings))\n  (if (null? (rest strings))\n     \
    \ (append (string-append substring (string-append (first strings) \"\") \"\")\n\
    \              (string-append (first strings) \"\"))\n      (filter_by_substring\
    \ (filter_by_substring (filter_by_substring strings (first strings)) substring)\
    \ substring))))\n</code>\n<|/ a tags=racket,list,scheme,string,recursion |>\n\
    <| c |>\nThanks, it works really well but I think I didn't explained well enough.\
    \ I'm trying to implement the function without using string-length (just to know\
    \ how long a string is). So I only have to take the first three letters of each\
    \ string and compare with substring until no new string is added. For example\
    \ \"abcde\" should be (filter_by_substring \"abcde\" \"ab\") not (filter_by_substring\
    \ \"abcde\" \"a\"). And \"array\" should be (filter_by_substring \"array\" \"\
    ar\").\n<|/ c |>\n<| c |>\nThanks, it works really well but I think I didn't explained\
    \ well enough. I'm trying to implement the function without using string-length\
    \ (just to know how long a string is). So I only have to take the first three\
    \ letters of each string and compare with substring until no new string is added.\
    \ For example \"abcde\" should be (filter_by_substring \"abcde\" \"ab\") not (filter_by_substring\
    \ \"abcde\" \"a\"). And \"array\" should be (filter_by_substring \"array\" \"\
    ar\").\n<|/ c |>\n<| a tags=racket,list,scheme,string,recursion |>\nIt's a little\
    \ hard to read your description, but I'm guessing you want to search each string\
    \ in turn for another string and then stop at the first position that it finds\
    \ so if you had (\"abc\" \"cde\" \"def\" \"efg\") (\"ab\") and wanted (ab) you\
    \ would get ab. The following function does this:\n<code>", "  (cond [(empty?\
    \ strings) strings]\n        [(string=? (first strings) substring) (filter_by_substring\
    \ (rest strings) substring)]\n        [else (cons (first strings) (filter_by_substring\
    \ (rest strings) substring))]))\n", "  (filter strings-contains-substring strings\
    \ substring))\n", "  (filter (lambda (string)\n           (string=? (string substring)\
    \ (string-length string)))\n         strings))\n", "  (cond [(empty? strings)\
    \ empty]\n        [(member (first strings) substring) (cons (first strings) strings)]\n\
    \        [else (filter_by_substring (rest strings) substring)]))\n", "  (cond\n\
    \    [(empty? strings) strings]\n    [(equal? (first strings) substring) (rest\
    \ strings)]\n    [else (cons (first strings)\n               (filter_by_substring\
    \ (rest strings) substring))]))\n", "  (if (null? strings) (list )\n      (let\
    \ ((head (car strings))\n            (tail (cdr strings)))\n        (if (equal?\
    \ (substring head) substring) \n            (list head) \n            (filter_by_substring\
    \ (cons (car strings) tail) substring))))))\n", "  (cond ((null? strings) '())\n\
    \        ((equal? substring (car strings)) (list strings))\n        (else (filter_by_substring\
    \ (filter (lambda (s) (equal? (car strings) s) substring) strings)\n         \
    \                          (cdr strings)))))\n", "  (define (helper input matched)\n\
    \    (cond\n      [(empty? input)\n       matched]\n      [(equal? (car input)\
    \ substring)\n       (helper input (cons (car input) matched))]\n      [else\n\
    \       (helper (cdr input) (cons (car input) matched))]))\n  (helper strings\
    \ \"\"))\n", "  (cond [(null? strings) strings]\n        [(mem? (car strings)\
    \ substring) (cons (car strings) (strings (cdr strings)))]\n        [else (cons\
    \ (car strings) (filter_by_substring (cdr strings) substring))]\n  )\n)\n", " \
    \ (cond ((null? strings) '())\n        ((equal? (car strings) substring) (cons\
    \ (car strings) (strings (cdr strings))))\n        (else (strings (filter_by_substring\
    \ (list(car strings)) substring))))\n)\n", "  (filter strings-contains strings\
    \ `(~(list substring \"\")))\n  )\n", "  (cond (empty? strings)\n        empty\n\
    \        (strings-contains-string-in-list substring strings))\n  (cons (first\
    \ strings)\n        (filter_by_substring (rest strings)\n                    \
    \       substring)))\n", "  ;; FIXME: is this efficient for long strings?\n  (cond\
    \ ((null? strings) '())\n        (else (cons (string->list (first strings)) (filter_by_substring\n\
    \                                              (rest strings)\n              \
    \                                substring)))))\n", "  (let loop ((strings strings)\n\
    \             (substring substring))\n    (cond\n      [(empty? strings) strings]\n\
    \      [(eq? (first strings) substring) (loop (rest strings)\n               \
    \                            (rest substring))]\n      [else (cons (first strings)\n\
    \                   (loop (rest strings)\n                         (rest substring)))])))\n\
    </code>\nThe second version uses cons as an accumulator to filter strings instead\
    \ of an explicit loop: \n<code>", "  (filter (\u03BB (s) (member substring s))\n\
    \         strings))\n", "  (cond\n    [(empty? strings) strings]\n    [(string-contains?\
    \ substring (car strings)) (filter_by_substring (cdr strings) substring)]\n  \
    \  [else (cons (car strings) (filter_by_substring (cdr strings) substring))]))\n",
  "  (cond [(empty? strings) strings]\n        [else (cons (filter_by_substring (first\
    \ strings)\n                                  substring)\n                   \
    \ (filter_by_substring\n                     (rest strings)\n                \
    \     substring))]\n        ))\n</code>\n<|/ a tags=scheme,string,racket,string\
    \ |>\n<| a tags=scheme,string,racket,string |>\nThis is a simple solution using\
    \ map:\n<code>", "  (filter (lambda (s) (string-contains? s substring))\n    \
    \     strings))\n", "  (filter \n   (lambda (x)\n     (string-contains-substring\
    \ x substring))\n   strings))\n", "  (let loop [strings (strings-ref strings 0)\
    \ substring (substring \"\") result '()]\n    (cond [(string= (strings-ref strings\
    \ 0) substring)\n           (cons (strings-ref strings 1)\n                 (loop\
    \ (strings-ref strings 2)\n                       substring\n                \
    \       (cons (strings-ref strings 3)\n                             result)))]\n\
    \          [(string-length (strings-ref strings 1) > 0)\n           (loop (strings-ref\
    \ strings 1)\n                 substring\n                 (cons (strings-ref\
    \ strings 0)\n                       result))]\n          [else\n           (cons\
    \ (strings-ref strings 0)\n                 result)]))))\n", "  (cond\n    ((null?\
    \ strings) strings)\n    ((equal? (first strings) substring) (filter_by_substring\
    \ (rest strings) substring))\n    (else (strings strings))))\n", "  (cond\n  \
    \  [(empty? strings) strings]\n    [(member (first strings) substring) (rest strings)]\n\
    \    [else (filter_by_substring (rest strings) substring)]))\n", "  (filter (lambda\
    \ (s) (string-includes? s substring)) strings))\n", "  (filter substring (map\
    \ string strings)))\n", "  (cond [(empty? strings) empty]\n        [else (if (string=?\
    \ substring (car strings))\n                  (cons (car strings)\n          \
    \              (filter_by_substring (cdr strings) substring))\n              \
    \    (filter_by_substring (cons (car strings) (cdr strings)) substring))]))\n",
  "  (cond [(empty? strings) strings]\n        [(memq substring (string-append strings\
    \ (string->list (car strings))))\n         (cons (car strings)\n             \
    \  (filter_by_substring (substring (substring 1 -1)) substring))]))\n", "  (fold-left\
    \ (\u03BB (x y)\n               (when (= (length x) 0)\n                 (reverse\
    \ y))\n               (if (member x y)\n                 (cons x y)\n        \
    \         (cons x (reverse y))))\n             (list empty)\n             strings))\n",
  "  (cond [(empty? strings) empty]\n        [else (cons (substring (first strings))\
    \ \n                  (filter_by_substring (substring (rest strings)) substring))]))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
