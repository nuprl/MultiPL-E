name: HumanEval_19_sort_numbers
language: rkt
prompt: "#lang racket\n\n;; Input is a space-delimited string of numberals from 'zero'\
  \ to 'nine'.\n;; Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five',\
  \ 'six', 'seven', 'eight' and 'nine'.\n;; Return the string with numbers sorted\
  \ from smallest to largest\n;; >>> (sort_numbers \"three one five\")\n;; \"one three\
  \ five\"\n(define (sort_numbers numbers)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate sort_numbers))\n\
  \    (check-equal? (candidate \"\") \"\")\n    (check-equal? (candidate \"three\"\
  ) \"three\")\n    (check-equal? (candidate \"three five nine\") \"three five nine\"\
  )\n    (check-equal? (candidate \"five zero four seven nine eight\") \"zero four\
  \ five seven eight nine\")\n    (check-equal? (candidate \"six five four three two\
  \ one zero\") \"zero one two three four five six\")\n))\n\n(test-humaneval)"
completions: ["  (cond\n    [(empty? numbers) \"\"]\n    [(equal? (car numbers) 'zero)\
    \ \"zero\"]\n    [(equal? (car numbers) 'one) \"one\"]\n    [(equal? (car numbers)\
    \ 'two) \"two\"]\n    [(equal? (car numbers) 'three) \"three\"]\n    [(equal?\
    \ (car numbers) 'four) \"four\"]\n    [(equal? (car numbers) 'five) \"five\"]\n\
    \    [(equal? (car numbers) 'six) \"six\"]\n    [(equal? (car numbers) 'seven)\
    \ \"seven\"]\n    [(equal? (car numbers) 'eight) \"eight\"]\n    [(equal? (car\
    \ numbers) 'nine) \"nine\"]\n    [else (cons (car numbers) (sort_numbers (cdr\
    \ numbers))))))\n", "  (define (helper numbers acc)\n    (if (null? numbers)\n\
    \        acc\n        (helper (cdr numbers) (append (cons (first numbers) acc))\
    \ (first numbers))))\n  (helper numbers \"\"))\n</code>\n<|/ a tags=racket,sorting,scheme\
    \ dscore=1 |>\n<| a tags=racket,sorting,scheme |>\nIf your list is supposed to\
    \ be sorted from smallest to largest and you only want to return the sorted list\
    \ and not change a variable in the caller's environment:\n<code>", "  (sort (split\
    \ numbers #\\Space :key (lambda (x) (- x 9))) :asc))\n", "  (if (string=? numbers\
    \ \"nine\")\n      \"nine\"\n      (append (sort_numbers (substring numbers 1\
    \ 6)) (substring numbers (+ 6 1)) \"\")))\n", "  (let ([number-list #(zero\n \
    \                     one\n                      two\n                      three\n\
    \                      four\n                      five\n                    \
    \  six\n                      seven\n                      eight\n           \
    \           nine)\n        numbers-sorted #(zero\n                          one\n\
    \                          two\n                          three\n            \
    \              four\n                          five\n                        \
    \  six\n                          seven\n                          eight\n   \
    \                       nine)]\n         number-sorted-indices #(#(\n        \
    \                   #(#(zero 1 2 3 4 5 6 7 8 9)\n                            \
    \  #(1 2 3 4 5 6 7 8 9 0)\n                              #(2 3 4 5 6 7 8 9 0 1)\n\
    \                              #(3 4 5 6 7 8 9 0 1 2)\n                      \
    \        #(4 5 6 7 8 9 0 1 2 3)\n                              #(5 6 7 8 9 0 1\
    \ 2 3 4)\n                              #(6 7 8 9 0 1 2 3 4 5)\n             \
    \                 #(7 8 9 0 1 2 3 4 5 6)\n                              #(8 9\
    \ 0 1 2 3 4 5 6 7)\n                              #(9 0 1 2 3 4 5 6 7 8))\n  \
    \                         #(#(0 1 2 3 4 5 6 7 8 9)\n                         \
    \     #(1 2 3 4 5 6 7 8 9 0)\n                              #(2 3 4 5 6 7 8 9\
    \ 0 1)\n                              #(3 4 5 6 7 8 9 0 1 2)\n               \
    \               #(4 5 6 7 8 9 0 1 2 3)\n                              #(5 6 7\
    \ 8 9 0 1 2 3 4)\n                              #(6 7 8 9 0 1 2 3 4 5)\n     \
    \                         #(7 8 9 0 1 2 3 4 5 6)\n                           \
    \   #(8 9 0 1 2 3 4 5 6 7)\n                              #(9 0 1 2 3 4 5 6 7\
    \ 8)))])\n    (string-append\n     (string-join\n      (map (lambda (number)\n\
    \            (substring (number-list number) 0 1)\n            number))\n    \
    \  numbers)\n     (string-join\n      (map (lambda (number)\n            (substring\
    \ (number-list number) 1 2)\n            number))\n      numbers)\n     (string-join\n\
    \      (map (lambda (number)\n            (substring (number-list number) 2 3)\n\
    \            number))\n      numbers)\n     (string-join\n      (map (lambda (number)\n\
    \            (substring (number-list number) 3 4)\n            number))\n    \
    \  numbers)\n     (string-join\n      (map (lambda (number)\n            (sub",
  "  (let loop ((numbers numbers)\n             (result '()))\n    (cond ((null? numbers)\
    \ result)\n          ((char? (car numbers))\n           (loop (cdr numbers)\n\
    \                 (cons (car numbers) result)))\n          ((char? (car numbers))\n\
    \           (loop (cdr numbers)\n                 (cons (car numbers) result)))\n\
    \          ((string? (car numbers))\n           (loop (cdr numbers)\n        \
    \         (cons (car numbers) result)))\n          ((number? (car numbers))\n\
    \           (loop (cdr numbers)\n                 (cons (car numbers) result)))\n\
    \          ((number? (car numbers))\n           (loop (cdr numbers)\n        \
    \         (cons (car numbers) result)))\n          (else\n           (loop (cdr\
    \ numbers)\n                   (cons (car numbers) result))))))\n", "  (define\
    \ (swap x y acc)\n    (if (< y x)\n        (cons x acc)\n        (cons y acc)))\n\
    \  (define (sort numbers acc length)\n    (cond ((null? numbers)\n           (reverse\
    \ acc))\n          ((= 0 (length numbers))\n           (reverse acc))\n      \
    \    (else\n           (let ((smallest (first numbers))\n                 (rest\
    \ (rest numbers)))\n             (if (null? rest)\n                 (sort (drop\
    \ 1 numbers) (cons (first numbers) acc) 0)\n                 (sort (rest numbers)\
    \ (cons (first smallest) (cons (first numbers) acc)) (+ 1 length)))))))\n  (sort\
    \ numbers '() 0))\n", "  (cond\n    ((null? numbers) '())\n    ((equal? (first\
    \ numbers) 'zero) (sort_numbers (rest numbers)))\n    ((equal? (first numbers)\
    \ 'one) (sort_numbers (rest numbers)))\n    ((equal? (first numbers) 'two) (sort_numbers\
    \ (rest numbers)))\n    ((equal? (first numbers) 'three) (sort_numbers (rest numbers)))\n\
    \    ((equal? (first numbers) 'four) (sort_numbers (rest numbers)))\n    ((equal?\
    \ (first numbers) 'five) (sort_numbers (rest numbers)))\n    ((equal? (first numbers)\
    \ 'six) (sort_numbers (rest numbers)))\n    ((equal? (first numbers) 'seven) (sort_numbers\
    \ (rest numbers)))\n    ((equal? (first numbers) 'eight) (sort_numbers (rest numbers)))\n\
    \    ((equal? (first numbers) 'nine) (sort_numbers (rest numbers)))\n    ((equal?\
    \ (first numbers) 'zero) (sort_numbers (rest numbers)))\n    ((equal? (first numbers)\
    \ 'one) (sort_numbers (rest numbers)))\n    ((equal? (first numbers) 'two) (sort_numbers\
    \ (rest numbers)))\n    ((equal? (first numbers) 'three) (sort_numbers (rest numbers)))\n\
    \    ((equal? (first numbers) 'four) (sort_numbers (rest numbers)))\n    ((equal?\
    \ (first numbers) 'five) (sort_numbers (rest numbers)))\n    ((equal? (first numbers)\
    \ 'six) (sort_numbers (rest numbers)))\n    ((equal? (first numbers) 'seven) (sort_numbers\
    \ (rest numbers)))\n    ((equal? (first numbers) 'eight) (sort_numbers (rest numbers)))\n\
    \    ((equal? (first numbers) 'nine) (sort_numbers (rest numbers)))\n    (else\
    \ (cons (first numbers) (sort_numbers (rest numbers))))\n    )\n  )", "  (cond\n\
    \    ((string? numbers) (cons numbers (sort_numbers (cdr numbers))))\n    ((list?\
    \ numbers) (sort_numbers (cons (car numbers) (sort_numbers (cdr numbers))))))\n\
    \  (define (compare-numbers left right)\n    (cond\n      ((equal? (first left)\
    \ (car right))\n       (cons (second left) (compare-numbers (rest left) right)))\n\
    \      ((equal? (first right) (car left))\n       (cons (second right) (compare-numbers\
    \ (rest right) left)))\n      (else (error \"Invalid input -- numbers can't be\
    \ sorted this way\"))))\n  (if (null? numbers)\n      '()\n      (let ((smallest\
    \ (car numbers))\n            (largest (car numbers)))\n        (cons (cons smallest\
    \ largest) (compare-numbers (rest numbers) (sort_numbers (cdr numbers)))))))\n\
    </code>\n<|/ a dscore=4 tags=racket,scheme |>\n<| c |>\nThanks, this was the most\
    \ elegant solution so far.\n<|/ c |>\n<| a dscore=3 |>\nA solution without loops.\
    \ Just an alternative to #lang racket.\n<code>", "  (define (compare-numbers num1\
    \ num2)\n    (cond\n      [(and (number? num1) (number? num2)) (compare-number\
    \ num1 num2)]\n      [(and (number? num1) (not (number? num2))) (compare-number\
    \ num1 \"zero\")]\n      [(and (not (number? num1)) (not (number? num2))) (compare-number\
    \ \"zero\" num2)]\n      [else (compare-number \"zero\" \"zero\")]\n      ))\n\
    \  (define (compare-number num1 num2)\n    (cond\n      [(and (number? num1) (number?\
    \ num2)) (compare-number num1 num2)]\n      [(and (number? num1) (not (number?\
    \ num2))) (compare-number num1 \"zero\")]\n      [(and (not (number? num1)) (not\
    \ (number? num2))) (compare-number \"zero\" num2)]\n      [(= num1 num2) (compare-number\
    \ \"one\" num2)]\n      [(< num1 num2) (compare-number num1 \"two\")]\n      [else\
    \ (compare-number \"two\" num1)]\n      ))\n  (define (sorted-numbers-from num)\n\
    \    (cond\n      [(and (number? num) (= num \"zero\") (= num \"one\") (= num\
    \ \"two\") (= num \"three\") (= num \"four\") (= num \"five\") (= num \"six\"\
    ) (= num \"seven\") (= num \"eight\") (= num \"nine\")) (sorted-numbers-from \"\
    zero\")]\n      [(and (number? num) (< num \"zero\") (< num \"one\") (< num \"\
    two\") (< num \"three\") (< num \"four\") (< num \"five\") (< num \"six\") (<\
    \ num \"seven\") (< num \"eight\") (< num \"nine\")) (sorted-numbers-from num)]\n\
    \      [(and (number? num) (> num \"zero\") (> num \"one\") (> num \"two\") (>\
    \ num \"three\") (> num \"four\") (> num \"five\") (> num \"six\") (> num \"seven\"\
    ) (> num \"eight\") (> num \"nine\")) (sorted-numbers-from \"one\")]\n      [else\
    \ (sorted-numbers-from \"two\")]))\n  (sorted-numbers-from numbers))\n", "  (if\
    \ (empty? numbers)\n      '()\n      (append (sub_string\n                 (sort\
    \ (split-string (first numbers) #\\Space) <???>)\n                 <???>))\n \
    \     (sort_numbers (rest numbers))))\n</code>\nTo use your code, you would need\
    \ to change the line\n<code>", "  (if (string= \"\" numbers)\n      (list)\n \
    \     (append (sort (numbers-list numbers)\n                     (lambda (x y)\n\
    \                        (< (numbers-to-largest x) \n                        \
    \  (numbers-to-largest y))))\n              (sort_numbers (substring numbers (string-length\
    \ numbers))))))\n", "  (cond ((null? numbers) '())\n        ((null? (rest numbers))\
    \ (reverse numbers))\n        ((= (first numbers) 'zero)\n         (cons (reverse\
    \ (sort_numbers (rest numbers)\n                           (cons (first numbers)\n\
    \                                 (sort_numbers (rest numbers))))))\n        ((=\
    \ (first numbers) 'one)\n         (cons (reverse (sort_numbers (rest numbers)\n\
    \                           (cons (first numbers)\n                          \
    \       (sort_numbers (rest numbers))))))\n        ((= (first numbers) 'two)\n\
    \         (cons (reverse (sort_numbers (rest numbers)\n                      \
    \     (cons (first numbers)\n                                 (sort_numbers (rest\
    \ numbers))))))\n        ((= (first numbers) 'three)\n         (cons (reverse\
    \ (sort_numbers (rest numbers)\n                           (cons (first numbers)\n\
    \                                 (sort_numbers (rest numbers))))))\n        ((=\
    \ (first numbers) 'four)\n         (cons (reverse (sort_numbers (rest numbers)\n\
    \                           (cons (first numbers)\n                          \
    \       (sort_numbers (rest numbers))))))\n        ((= (first numbers) 'five)\n\
    \         (cons (reverse (sort_numbers (rest numbers)\n                      \
    \     (cons (first numbers)\n                                 (sort_numbers (rest\
    \ numbers))))))\n        ((= (first numbers) 'six)\n         (cons (reverse (sort_numbers\
    \ (rest numbers)\n                           (cons (first numbers)\n         \
    \                        (sort_numbers (rest numbers))))))\n        ((= (first\
    \ numbers) 'seven)\n         (cons (reverse (sort_numbers (rest numbers)\n   \
    \                        (cons (first numbers)\n                             \
    \    (sort_numbers (rest numbers))))))\n        ((= (first numbers) 'eight)\n\
    \         (cons (reverse (sort_numbers (rest numbers)\n                      \
    \     (cons (first numbers)\n                                 (sort_numbers (rest\
    \ numbers))))))\n        ((= (first numbers) 'nine)\n         (cons (reverse (sort_numbers\
    \ (rest numbers)\n                           (cons (first numbers)\n         \
    \                        (sort_numbers (rest numbers))))))\n        (else (cons\
    \ (first numbers)\n                    (sort_numbers (rest numbers))))))\n</code>\n\
    <|/ a tags=racket,lisp,scheme,functional-programming |>\n<| a tags=racket,lisp,scheme,functional-programming\
    \ |>\nThis was my first attempt at it (I still don't know much about Racket) but ",
  "  (sort numbers\n        (lambda (x y)\n          (< (char-code x) (char-code y)))))\n",
  "  (define (helper)\n    (define (helper-helper input)\n      (cond\n        ((null?\
    \ input) \"\")\n        ((equal? (car input) 'zero) (helper-helper (cdr input)))\n\
    \        ((equal? (car input) 'one) (helper-helper (cdr input)))\n        ((equal?\
    \ (car input) 'two) (helper-helper (cdr input)))\n        ((equal? (car input)\
    \ 'three) (helper-helper (cdr input)))\n        ((equal? (car input) 'four) (helper-helper\
    \ (cdr input)))\n        ((equal? (car input) 'five) (helper-helper (cdr input)))\n\
    \        ((equal? (car input) 'six) (helper-helper (cdr input)))\n        ((equal?\
    \ (car input) 'seven) (helper-helper (cdr input)))\n        ((equal? (car input)\
    \ 'eight) (helper-helper (cdr input)))\n        ((equal? (car input) 'nine) (helper-helper\
    \ (cdr input)))\n        (else (helper (cdr input))))))\n    (helper-helper numbers))\n",
  "  (cond\n    ((null? numbers) '())\n    ((equal? (car numbers) 'zero) '(zero))\n\
    \    ((equal? (car numbers) 'one) '(one))\n    ((equal? (car numbers) 'two) '(two))\n\
    \    ((equal? (car numbers) 'three) '(three ))\n    ((equal? (car numbers) 'four)\
    \ '(four))\n    ((equal? (car numbers) 'five) '(five ))\n    ((equal? (car numbers)\
    \ 'six) '(six))\n    ((equal? (car numbers) 'seven) '(seven))\n    ((equal? (car\
    \ numbers) 'eight) '(eight))\n    ((equal? (car numbers) 'nine) '(nine))\n   \
    \ (else\n      (append (sort_numbers (cdr numbers)) (list (car numbers))))))\n",
  "  (let ((ns (string->list numbers)))\n    (let loop ((current 'zero)\n        \
    \       (ns '()))\n      (if (null? ns)\n          current\n          (loop (first\
    \ ns)\n                (cons (first ns) (ns)))))))\n", "  (let ((numbers (string-split\
    \ numbers \"\\s+\"))\n        (sorted-numbers '())\n        (i 0))\n    (for-each\
    \ (lambda (x)\n                  (if (number? (car x))\n                     \
    \ (set! i (+ i 1))\n                      (set! sorted-numbers (append sorted-numbers\
    \ x)))\n                  (set! i (+ i 1)))\n              numbers)\n    (if (null?\
    \ sorted-numbers)\n        numbers\n        (format #f \"~A\" (string->list sorted-numbers)))))\n\
    </code>\n<|/ a |>\n<| a dscore=2 |>\nA simple recursive solution in Racket:\n\
    <code>", "  (cond\n    [(null? numbers) \"\"]\n    [(= \"zero\" (car numbers))\
    \ (sort_numbers (cdr numbers))]\n    [(= \"one\" (car numbers)) (sort_numbers\
    \ (cdr numbers))]\n    [(= \"two\" (car numbers)) (sort_numbers (cdr numbers))]\n\
    \    [(= \"three\" (car numbers)) (sort_numbers (cdr numbers))]\n    [(= \"four\"\
    \ (car numbers)) (sort_numbers (cdr numbers))]\n    [(= \"five\" (car numbers))\
    \ (sort_numbers (cdr numbers))]\n    [(= \"six\" (car numbers)) (sort_numbers\
    \ (cdr numbers))]\n    [(= \"seven\" (car numbers)) (sort_numbers (cdr numbers))]\n\
    \    [(= \"eight\" (car numbers)) (sort_numbers (cdr numbers))]\n    [(= \"nine\"\
    \ (car numbers)) (sort_numbers (cdr numbers))]\n    [else (append (sort_numbers\
    \ (cdr numbers)) (cons (car numbers) (sort_numbers (cdr numbers))))]\n  )\n)\n",
  "  (let ([current (first numbers)]\n        [last (rest numbers)])\n    (cond\n\
    \      [(empty? numbers) numbers]\n      [(equal? current last) (sort_numbers\
    \ last)]\n      [(equal? current (first last)) (sort_numbers (rest last))]\n \
    \     [(equal? (first current) (first last)) (sort_numbers (rest current))\n \
    \       (append last (cons (first current) last))]\n      [else (append last (cons\
    \ current last))]))))\n", "  (if (string=? numbers \"\") \"\" \n      (if (string=?\
    \ numbers \" \") \"\" \n          (if (string=? (substring numbers 0 5) \"eight\
    \ \")\n               (substring numbers 0 5)\n               (if (string=? (substring\
    \ numbers 0 4) \"four \")\n                   (substring numbers 0 4)\n      \
    \             (if (string=? (substring numbers 0 3) \"three \")\n            \
    \           (substring numbers 0 3)\n                       (if (string=? (substring\
    \ numbers 0 2) \"two \")\n                           (substring numbers 0 2)\n\
    \                           (if (string=? (substring numbers 0 1) \"one \")\n\
    \                               (substring numbers 0 1)\n                    \
    \           (if (string=? (substring numbers 0 0) \"zero \")\n               \
    \                    (substring numbers 0 0)\n                               \
    \    (substring numbers 0)))))))))\n", "  (sort (map read-number-string numbers)\
    \ <))\n", "  (let ([nums (map number numbers)])\n    (let ([min-idx (min nums)])\n\
    \      (let ([max-idx (max nums)])\n        (let ([num-cnt (length (remove-if\
    \ (lambda (x) (<= x max-idx)) nums))])\n          (cond (num-cnt 0)\n        \
    \        numbers\n                (num-cnt (num-cnt -1))\n                (reverse\
    \ (remove-if (lambda (x) (< x min-idx)) nums))\n                else\n       \
    \         'else))))))\n", "  (let loop ((numbers (string->list numbers))\n   \
    \          (res \"\"))\n    (cond\n      [(null? numbers)\n       (string->list\
    \ res)]\n      [(= (length numbers) 0)\n       (string->list res)]\n      [(char=?\
    \ (car numbers) \"zero\")\n       (loop (cdr numbers)\n             (append (res\
    \ (cons (car numbers) \"\")) res))]\n      [(char=? (car numbers) \"one\")\n \
    \      (loop (cdr numbers)\n             (append (res (cons (car numbers) \"\"\
    )) res))]\n      [(char=? (car numbers) \"two\")\n       (loop (cdr numbers)\n\
    \             (append (res (cons (car numbers) \"\")) res))]\n      [(char=? (car\
    \ numbers) \"three\")\n       (loop (cdr numbers)\n             (append (res (cons\
    \ (car numbers) \"\")) res))]\n      [(char=? (car numbers) \"four\")\n      \
    \ (loop (cdr numbers)\n             (append (res (cons (car numbers) \"\")) res))]\n\
    \      [(char=? (car numbers) \"five\")\n       (loop (cdr numbers)\n        \
    \     (append (res (cons (car numbers) \"\")) res))]\n      [(char=? (car numbers)\
    \ \"six\")\n       (loop (cdr numbers)\n             (append (res (cons (car numbers)\
    \ \"\")) res))]\n      [(char=? (car numbers) \"seven\")\n       (loop (cdr numbers)\n\
    \             (append (res (cons (car numbers) \"\")) res))]\n      [(char=? (car\
    \ numbers) \"eight\")\n       (loop (cdr numbers)\n             (append (res (cons\
    \ (car numbers) \"\")) res))]\n      [(char=? (car numbers) \"nine\")\n      \
    \ (loop (cdr numbers)\n             (append (res (cons (car numbers) \"\")) res))]\n\
    \      [else\n       (loop (cdr numbers)\n             (append (res (cons (car\
    \ numbers) \"\")) res))]))\n", "  (cond\n    [(empty? numbers) \"\"]\n    [(number?\
    \ (first numbers)) (sort_numbers (rest numbers))]\n    [else (cons (first numbers)\
    \ (sort_numbers (rest numbers)))]))\n", "  (cond [(empty? numbers) \"\"]\n   \
    \     [(equal? (first numbers) \"zero\") (sort_numbers (rest numbers))]\n    \
    \    [(equal? (first numbers) \"one\") (sort_numbers (rest numbers))]\n      \
    \  [(equal? (first numbers) \"two\") (sort_numbers (rest numbers))]\n        [(equal?\
    \ (first numbers) \"three\") (sort_numbers (rest numbers))]\n        [(equal?\
    \ (first numbers) \"four\") (sort_numbers (rest numbers))]\n        [(equal? (first\
    \ numbers) \"five\") (sort_numbers (rest numbers))]\n        [(equal? (first numbers)\
    \ \"six\") (sort_numbers (rest numbers))]\n        [(equal? (first numbers) \"\
    seven\") (sort_numbers (rest numbers))]\n        [(equal? (first numbers) \"eight\"\
    ) (sort_numbers (rest numbers))]\n        [(equal? (first numbers) \"nine\") (sort_numbers\
    \ (rest numbers))]\n        [else (append (sort_numbers (rest numbers)) (first\
    \ numbers))]))\n", "  (define (parse str)\n    (let loop ((i 0) (acc '())\n  \
    \             (cur 'zero) (cur-count 0))\n      (cond ((null? str) (list acc))\n\
    \            ((char=? str ' ') (if (not (null? acc)) (list acc) (error \"Too few\
    \ numbers\")))\n            ((char=? str ',') (loop 0 (cons cur (cons cur acc))\n\
    \                                  cur 'zero (+ cur-count 1)))\n            (else\
    \ (loop (+ i 1) (cons (car str) acc) (cadr str) (+ cur-count 1)))))\n    (parse\
    \ numbers)))\n", "  (if (null? (cdddr numbers))\n      numbers\n      (append\
    \ (sort_numbers (caddr numbers))\n               (string-append (number-from-string\
    \ (caddr numbers)) \" \" (caddr numbers))\n               (sort_numbers (cdaddr\
    \ numbers)))))\n", "  (letrec ([helper (lambda (a b)\n                    (cond\n\
    \                      [(number-equal? a b) (list a b)] \n                   \
    \   [else (append (list a b) (helper (cons a (cdr b)) b))]\n                 \
    \     ))])\n    (helper 'zero '(nil))\n    (helper 'one '(nil))\n    (helper 'two\
    \ (cons 'one '(nil)))\n    (helper 'three (cons 'two (cons 'one '(nil))))\n  \
    \  (helper 'four (cons 'three (cons 'two (cons 'one '(nil))))))\n</code>\nIn Racket\
    \ we can rewrite this as:\n<code>\n#lang racket\n", "  (sort (split-string (interpose\
    \ \" \" (string->list numbers)) \" \") <))\n", "  (cond\n    [(string=? (number->string\
    \ 'one) (number->string 'zero)) 'zero]\n    [(string=? (number->string 'one) (number->string\
    \ 'two)) (number->string 'two)]\n    [(string=? (number->string 'one) (number->string\
    \ 'three)) (number->string 'three)]\n    [(string=? (number->string 'one) (number->string\
    \ 'four)) (number->string 'four)]\n    [(string=? (number->string 'one) (number->string\
    \ 'five)) (number->string 'five)]\n    [(string=? (number->string 'one) (number->string\
    \ 'six)) (number->string 'six)]\n    [(string=? (number->string 'one) (number->string\
    \ 'seven)) (number->string 'seven)]\n    [(string=? (number->string 'one) (number->string\
    \ 'eight)) (number->string 'eight)]\n    [(string=? (number->string 'one) (number->string\
    \ 'nine)) (number->string 'nine)]\n    [(string=? (number->string 'two) (number->string\
    \ 'zero)) (number->string 'two)]\n    [(string=? (number->string 'two) (number->string\
    \ 'one)) (number->string 'one)]\n    [(string=? (number->string 'two) (number->string\
    \ 'three)) (number->string 'three)]\n    [(string=? (number->string 'two) (number->string\
    \ 'four)) (number->string 'four)]\n    [(string=? (number->string 'two) (number->string\
    \ 'five)) (number->string 'five)]\n    [(string=? (number->string 'two) (number->string\
    \ 'six)) (number->string 'six)]\n    [(string=? (number->string 'two) (number->string\
    \ 'seven)) (number->string 'seven)]\n    [(string=? (number->string 'two) (number->string\
    \ 'eight)) (number->string 'eight)]\n    [(string=? (number->string 'two) (number->string\
    \ 'nine)) (number->string 'nine)]\n    [(string=? (number->string 'three) (number->string\
    \ 'zero)) (number->string 'three)]\n    [(string=? (number->string 'three) (number->string\
    \ 'one)) (number->string 'one)]\n    [(string=? (number->string 'three) (number->string\
    \ 'two)) (", "  (define (sort-helper list n)\n    (cond [(empty? list) list]\n\
    \          [(< n (car list)) (cons (car list) (sort-helper (cdr list) n))]\n \
    \         [else (sort-helper (cdr list) n)]\n        ))\n  (sort-helper numbers\
    \ (string->number numbers)))\n", "  (sort (split-string (read-string numbers))\
    \ <))\n", "  (sort_numbers-iter numbers '()))\n", "  (cond\n    [(string-empty?\
    \ numbers) numbers]\n    [else (sort_numbers (sort_strings numbers))]))\n", " \
    \ (sort numbers))\n", "  (define (helper n)\n    (if (eq? n 'zero)\n        'zero\n\
    \        (if (eq? n 'one)\n            'one\n            (if (eq? n 'two)\n  \
    \              'two\n                (if (eq? n 'three)\n                    'three\n\
    \                    (if (eq? n 'four)\n                        'four\n      \
    \                  (if (eq? n 'five)\n                            'five\n    \
    \                        (if (eq? n 'six)\n                                'six\n\
    \                                (if (eq? n 'seven)\n                        \
    \            'seven\n                                    (if (eq? n 'eight)\n\
    \                                        'eight\n                            \
    \            (if (eq? n 'nine)\n                                            'nine\n\
    \                                            (helper (sub1 n)))\n            \
    \                    )\n                            )\n                      \
    \  )\n                    )\n                )\n            )\n        )\n   \
    \ )\n  )\n  (reverse (sort (map helper numbers))))\n", "  (let ([len (string-length\
    \ numbers)]\n        [count (length numbers)]\n        [cur 0])\n    (loop\n \
    \      [i len]\n       [k 0]\n       [output '()]\n       [temp 0])\n    (cond\
    \ [(or (= i len) (= k count)) output]\n          [(number? numbers)\n        \
    \   (cond [(> i k) (cons numbers output)]\n                 [(< i k) (cons (substring\
    \ numbers i k) output)]\n                 [else (cons (substring numbers i k)\
    \ (sort_numbers (substring numbers i k)))]))]\n          [(equal? (char-type (car\
    \ numbers)) digit)\n           (cond [(> i k) (cons numbers output)\n        \
    \           (= i len) (cons (substring numbers i k) output)]\n               \
    \  [else (cons (substring numbers i k) (sort_numbers (substring numbers i k)))]))]\n\
    \          [else (cond [(< i k) (sort_numbers (substring numbers i k))]\n    \
    \               [else (cons (substring numbers i k) (cons numbers (substring output\
    \ (- k i))))]))\n    output))\n", "  (cond\n    [(empty? numbers) \"\"]\n    [(equal?\
    \ (first numbers) \"zero\") \"zero\"]\n    [(equal? (first numbers) \"one\") \"\
    one\"]\n    [(equal? (first numbers) \"two\") \"two\"]\n    [(equal? (first numbers)\
    \ \"three\") \"three\"]\n    [(equal? (first numbers) \"four\") \"four\"]\n  \
    \  [(equal? (first numbers) \"five\") \"five\"]\n    [(equal? (first numbers)\
    \ \"six\") \"six\"]\n    [(equal? (first numbers) \"seven\") \"seven\"]\n    [(equal?\
    \ (first numbers) \"eight\") \"eight\"]\n    [(equal? (first numbers) \"nine\"\
    ) \"nine\"]\n    [else (cons (first numbers)\n                (sort_numbers (rest\
    \ numbers))\n                (sort_numbers (rest numbers)))]))\n", "  (define\
    \ (loop index acc)\n    (cond\n      [(empty? numbers) acc]\n      [(equal? (first\
    \ numbers) 'zero) (loop (sub1 index) (string-append (first acc) \" zero\"))]\n\
    \      [(equal? (first numbers) 'one) (loop (sub1 index) (string-append (first\
    \ acc) \" one\"))]\n      [(equal? (first numbers) 'two) (loop (sub1 index) (string-append\
    \ (first acc) \" two\"))]\n      [(equal? (first numbers) 'three) (loop (sub1\
    \ index) (string-append (first acc) \" three\"))]\n      [(equal? (first numbers)\
    \ 'four) (loop (sub1 index) (string-append (first acc) \" four\"))]\n      [(equal?\
    \ (first numbers) 'five) (loop (sub1 index) (string-append (first acc) \" five\"\
    ))]\n      [(equal? (first numbers) 'six) (loop (sub1 index) (string-append (first\
    \ acc) \" six\"))]\n      [(equal? (first numbers) 'seven) (loop (sub1 index)\
    \ (string-append (first acc) \" seven\"))]\n      [(equal? (first numbers) 'eight)\
    \ (loop (sub1 index) (string-append (first acc) \" eight\"))]\n      [(equal?\
    \ (first numbers) 'nine) (loop (sub1 index) (string-append (first acc) \" nine\"\
    ))]\n      [(not (= (first numbers) 'zero)) (loop (sub1 index) (cons (first numbers)\
    \ (first acc))))]\n      [(not (= (first numbers) 'one)) (loop (sub1 index) (cons\
    \ (first numbers) (first acc))))]\n      [(not (= (first numbers) 'two)) (loop\
    \ (sub1 index) (cons (first numbers) (first acc))))]\n      [(not (= (first numbers)\
    \ 'three)) (loop (sub1 index) (cons (first numbers) (first acc))))]\n      [(not\
    \ (= (first numbers) 'four)) (loop (sub1 index) (cons (first numbers) (first acc))))]\n\
    \      [(not (= (first numbers) 'five)) (loop (sub1 index) (cons (first numbers)\
    \ (first acc))))]\n      [(not (= (first numbers) 'six)) (loop (sub1 index) (cons\
    \ (first number", "  (define numbers-sorted (list))\n  (define n (string-length\
    \ (string-downcase numbers)))\n  (let loop ((index (substring numbers 0 1)))\n\
    \    (if (< index 9)\n        (set! numbers-sorted (append numbers-sorted (list\
    \ (substring numbers 0 index))))\n        (loop (+ index 1))))\n  (set! numbers-sorted\
    \ (sort numbers-sorted <))\n  (string numbers-sorted))\n", "  (let loop ([i 0]\
    \ [sorted '()])\n    (if (empty? numbers)\n        (reverse sorted)\n        (loop\
    \ (+ i 1)\n              (append sorted\n                      (if (> (length\
    \ numbers) i)\n                          (list 'zero 'nine)\n                \
    \          (list numbers (list-ref numbers (- i 1)))))))\n    (loop '(0) '())))\n",
  "  (define (helper-sort list)\n    (let ((head (car list)))\n      (cond [(< head\
    \ 9) (helper-sort (append (list (car list)) (cdr list)))]\n            [else (cons\
    \ (car list) (cdr list))]))\n    (cond [(empty? list) empty]\n          [else\
    \ (helper-sort (list (reverse (helper-sort (list head)))))])))\n  (helper-sort\
    \ (split numbers)))\n", "  (let ([numbers_string\n         (string->symbol (string->list\
    \ numbers))])\n    (lambda (sorted-list)\n      (cond\n        ((symbol? sorted-list)\n\
    \         (cond\n           ((symbol=? numbers_string sorted-list)\n         \
    \   (sorted-list numbers_string sorted-list))\n           ((number? sorted-list)\n\
    \            (sorted-list numbers_string sorted-list))\n           ((number? sorted-list)\
    \ (sorted-list numbers_string sorted-list))\n           ((number? sorted-list)\
    \ (sorted-list numbers_string sorted-list))))\n        (else\n         (cond\n\
    \           ((number? sorted-list)\n            (sorted-list numbers_string sorted-list))\n\
    \           ((symbol? sorted-list)\n            (sorted-list numbers_string sorted-list))\n\
    \           ((number? sorted-list) (sorted-list numbers_string sorted-list))\n\
    \           ((symbol? sorted-list)\n            (sorted-list numbers_string sorted-list))\n\
    \           ((number? sorted-list) (sorted-list numbers_string sorted-list))))))))\n",
  "  (let ((numbers (string->list numbers)))\n    (append (reverse\n             \
    \ (map string->number\n                   (sort numbers '<))\n              (map\
    \ string->number\n                   (sort numbers '=))))))\n", "  (cond\n   \
    \ [(empty? numbers) '()]\n    [(equal? (first numbers) 'zero) (sort_numbers (rest\
    \ numbers))]\n    [(equal? (first numbers) 'one) (sort_numbers (rest numbers))]\n\
    \    [(equal? (first numbers) 'two) (sort_numbers (rest numbers))]\n    [(equal?\
    \ (first numbers) 'three) (sort_numbers (rest numbers))]\n    [(equal? (first\
    \ numbers) 'four) (sort_numbers (rest numbers))]\n    [(equal? (first numbers)\
    \ 'five) (sort_numbers (rest numbers))]\n    [(equal? (first numbers) 'six) (sort_numbers\
    \ (rest numbers))]\n    [(equal? (first numbers) 'seven) (sort_numbers (rest numbers))]\n\
    \    [(equal? (first numbers) 'eight) (sort_numbers (rest numbers))]\n    [(equal?\
    \ (first numbers) 'nine) (sort_numbers (rest numbers))]\n    [else (cons (first\
    \ numbers) (sort_numbers (rest numbers)))]\n    ))\n", "  (cond [(empty? numbers)\
    \ '()]\n        [(equal? (first numbers) \"nine\") (append (reverse \"one\" \"\
    two\" \"three\" \"four\" \"five\" \"six\" \"seven\" \"eight\" \"nine\") '())]\n\
    \        [(equal? (first numbers) \"one\") (append (reverse \"zero\" \"two\" \"\
    three\" \"four\" \"five\" \"six\" \"seven\" \"eight\" \"nine\") '())]\n      \
    \  [(equal? (first numbers) \"two\") (append (reverse \"zero\" \"one\" \"three\"\
    \ \"four\" \"five\" \"six\" \"seven\" \"eight\" \"nine\") '())]\n        [(equal?\
    \ (first numbers) \"three\") (append (reverse \"zero\" \"one\" \"two\" \"four\"\
    \ \"five\" \"six\" \"seven\" \"eight\" \"nine\") '())]\n        [(equal? (first\
    \ numbers) \"four\") (append (reverse \"zero\" \"one\" \"two\" \"three\" \"five\"\
    \ \"six\" \"seven\" \"eight\" \"nine\") '())]\n        [(equal? (first numbers)\
    \ \"five\") (append (reverse \"zero\" \"one\" \"two\" \"three\" \"four\" \"six\"\
    \ \"seven\" \"eight\" \"nine\") '())]\n        [(equal? (first numbers) \"six\"\
    ) (append (reverse \"zero\" \"one\" \"two\" \"three\" \"four\" \"five\" \"eight\"\
    \ \"nine\") '())]\n        [(equal? (first numbers) \"seven\") (append (reverse\
    \ \"zero\" \"one\" \"two\" \"three\" \"four\" \"five\" \"six\" \"eight\" \"nine\"\
    ) '())]\n        [(equal? (first numbers) \"eight\") (append (reverse \"zero\"\
    \ \"one\" \"two\" \"three\" \"four\" \"five\" \"six\" \"seven\" \"nine\") '())]\n\
    \        [(equal? (first numbers) \"nine\") (append (reverse \"zero\" \"one\"\
    \ \"two\" \"three\" \"four\" \"five\" \"six\" \"seven\" \"eight\") '())]\n   \
    \     [else (append (reverse \"zero\" \"one\" \"two\" \"three\" \"four\" \"five\"\
    \ \"six\" \"seven\" \"eight\" \"nine\") (reverse (sort_numbers (rest numbers))))]))\n",
  "  (define (helper numbers result)\n    (cond ((numbers '())\n           result)\n\
    \          ((member (first numbers) '(zero one two three four five six seven eight\
    \ nine))\n           (helper (rest numbers)\n                    (append result\
    \ (list numbers)))\n           (helper (rest numbers)\n                    (append\
    \ result (list (first numbers))))))\n  (helper (split numbers) '()))\n", "  (define\
    \ (numbers-sorted choice)\n    (cond\n      [(string=? choice \"zero\") 0]\n \
    \     [(string=? choice \"one\") 1]\n      [(string=? choice \"two\") 2]\n   \
    \   [(string=? choice \"three\") 3]\n      [(string=? choice \"four\") 4]\n  \
    \    [(string=? choice \"five\") 5]\n      [(string=? choice \"six\") 6]\n   \
    \   [(string=? choice \"seven\") 7]\n      [(string=? choice \"eight\") 8]\n \
    \     [(string=? choice \"nine\") 9]\n      [else (numbers-sorted (substring choice\
    \ 0 1))]))\n  (numbers-sorted (substring numbers 0 -1)))\n", "  (let loop ((a\
    \ numbers)\n             (b numbers))\n    (cond ((null? a)\n           (reverse\
    \ b))\n          ((< (first a) (first b))\n           (loop (rest a) (cons (first\
    \ b) (first a))))\n          (else\n           (loop (rest b) (cons (first b)\
    \ (first a)))))))\n</code>\n<|/ a tags=recursion,scheme,racket,sorting dscore=3\
    \ |>\n<| c |>\nThanks for your answer, I really appreciate it! I decided to go\
    \ with solution since it seemed more readable, but I do appreciate you taking\
    \ the time to provide a working example as well!\n<|/ c |>\n<| a tags=recursion,scheme,racket,sorting\
    \ |>\nIf you're looking for a recursive solution, one way would be to start with\
    \ the right order and to recurse down into this subproblem until you are down\
    \ to the right place (where you can use the builtin sort procedure).\n<code>",
  "  (cond [(empty? numbers) 'empty]\n        [(equal? 'empty numbers) 'empty]\n \
    \       [(equal? 'empty (first numbers)) numbers]\n        [else (sort_numbers\
    \ (rest numbers))]))\n", "  (cond [(null? numbers) '()] \n        [(member 'zero\
    \ numbers) 'zero]\n        [(member 'one numbers) 'one]\n        [(member 'two\
    \ numbers) 'two]\n        [(member 'three numbers) 'three]\n        [(member 'four\
    \ numbers) 'four]\n        [(member 'five numbers) 'five]\n        [(member 'six\
    \ numbers) 'six]\n        [(member 'seven numbers) 'seven]\n        [(member 'eight\
    \ numbers) 'eight]\n        [(member 'nine numbers) 'nine]\n        [else (sort_numbers\
    \ (rest numbers))]))\n", "  (let ([n (length numbers)])\n    (if (= n 0)\n   \
    \   '()\n      (append (sort_numbers (substring numbers (- n 1)))\n          \
    \     (list (substring numbers (length numbers) 1))))))\n", "  (if (empty? numbers)\n\
    \      '()\n      (let ([n (car numbers)])\n        (if (number? (cdr numbers))\n\
    \            (sort_numbers (cdr numbers)) \n            (append (list n) (sort_numbers\
    \ (cdr numbers))))))))\n", "  (cond\n    [(empty? numbers) \"\"]\n    [(number?\
    \ (car numbers)) (sort_numbers (cdr numbers))]\n    [else (append (sort_numbers\
    \ (string->list (number->string (car numbers))))\n                  (sort_numbers\
    \ (string->list (number->string (cdr numbers))))))]))\n", "  (let ((numbers (string->list\
    \ numbers)))\n    (sort numbers (<)\n          (lambda (a b)\n            (if\
    \ (string=? (string->number a) (string->number b))\n                (sub1 (string->number\
    \ a))\n                (sub1 (string->number b))\n            )\n          )\n\
    \          (lambda (a b)\n            (if (string=? (string->number a) (string->number\
    \ b))\n                (sub1 (string->number b))\n                (sub1 (string->number\
    \ a))\n            )\n          )\n          (lambda (a b)\n            (if (string=?\
    \ (string->number a) (string->number b))\n                (sub1 (string->number\
    \ b))\n                (sub1 (string->number a))\n            )\n          )\n\
    \          (lambda (a b)\n            (if (string=? (string->number a) (string->number\
    \ b))\n                (sub1 (string->number b))\n                (sub1 (string->number\
    \ a))\n            )\n          )\n          (lambda (a b)\n            (if (string=?\
    \ (string->number a) (string->number b))\n                (sub1 (string->number\
    \ b))\n                (sub1 (string->number a))\n            )\n          )\n\
    \          (lambda (a b)\n            (if (string=? (string->number a) (string->number\
    \ b))\n                (sub1 (string->number b))\n                (sub1 (string->number\
    \ a))\n            )\n          )\n          (lambda (a b)\n            (if (string=?\
    \ (string->number a) (string->number b))\n                (sub1 (string->number\
    \ b))\n                (sub1 (string->number a))\n            )\n          )\n\
    \          (lambda (a b)\n            (if (string=? (string->number a) (string->number\
    \ b))\n                (sub1 (string->number b))\n                (sub1 (string->number\
    \ a))\n            )\n          )\n          (lambda (a b)\n            (if (string=?\
    \ (string->number a) (string->number b))\n                (sub1 (string->number\
    \ b))\n                (sub1 (string->number a))\n            )\n          )\n\
    \          (lambda (a b)\n            (if (string=? (string->number a) (string->number\
    \ b))\n                (sub1 (string->number b))\n                (sub1 (string->number\
    \ a))\n            )\n          )\n          (lambda (a b)\n            (if (string=?\
    \ (string->number a) (string->number b))\n                (sub1 (string->number\
    \ b))\n                (sub1 (string->number a))\n            )\n          )\n\
    \          (lambda (a b)\n            (if (string=? (string->number a) (string->number\
    \ b))", "  (cond\n    [(empty? numbers) \"\"]\n    [(equal? (first numbers) \"\
    zero\") (sort_numbers rest)]\n    [(equal? (first numbers) \"one\") (cons (first\
    \ numbers) (sort_numbers (rest numbers)))]\n    [(equal? (first numbers) \"two\"\
    ) (cons (first numbers) (sort_numbers (rest numbers)))]\n    [(equal? (first numbers)\
    \ \"three\") (cons (first numbers) (sort_numbers (rest numbers)))]\n    [(equal?\
    \ (first numbers) \"four\") (cons (first numbers) (sort_numbers (rest numbers)))]\n\
    \    [(equal? (first numbers) \"five\") (cons (first numbers) (sort_numbers (rest\
    \ numbers)))]\n    [(equal? (first numbers) \"six\") (cons (first numbers) (sort_numbers\
    \ (rest numbers)))]\n    [(equal? (first numbers) \"seven\") (cons (first numbers)\
    \ (sort_numbers (rest numbers)))]\n    [(equal? (first numbers) \"eight\") (cons\
    \ (first numbers) (sort_numbers (rest numbers)))]\n    [(equal? (first numbers)\
    \ \"nine\") (cons (first numbers) (sort_numbers (rest numbers)))]\n    [else (cons\
    \ (first numbers) (sort_numbers (rest numbers))))]))\n", "  (cond\n    [(string-empty?\
    \ numbers) \"\"]\n    [(string-equal? \"zero\" (car numbers)) \"\"]\n    [(string-equal?\
    \ \"one\" (car numbers)) \"\"]\n    [(string-equal? \"two\" (car numbers)) \"\"\
    ]\n    [(string-equal? \"three\" (car numbers)) \"\"]\n    [(string-equal? \"\
    four\" (car numbers)) \"\"]\n    [(string-equal? \"five\" (car numbers)) \"\"\
    ]\n    [(string-equal? \"six\" (car numbers)) \"\"]\n    [(string-equal? \"seven\"\
    \ (car numbers)) \"\"]\n    [(string-equal? \"eight\" (car numbers)) \"\"]\n \
    \   [(string-equal? \"nine\" (car numbers)) \"\"]\n    [else (append (sort_numbers\
    \ (append (car numbers) (list (cadr numbers))))\n                (cons (cadr numbers)\
    \ \"-\")\n                (sort_numbers (append (caddr numbers) (list (cadr numbers)))))]))\n",
  "  (let ((nums '()))\n    (loop for i from 0\n         for item to numbers\n   \
    \      append (cons item nums))\n    (map string-join (sort (lambda (a b) (< (string-length\
    \ a) (string-length b))))\n         nums)))\n", "  (define nums (split_strings\
    \ numbers))\n  (sort nums <???>)\n  (join nums))\n", "  (sort (remove #(=? % 10)\
    \ numbers) <))\n", "  (if (empty? numbers)\n      numbers\n      (let ([number1\
    \ (split-string (first numbers) #\" \")]\n            [number2 (split-string (second\
    \ numbers) #\" \")]\n            [number3 (split-string (third numbers) #\" \"\
    )]\n            [number4 (split-string (fourth numbers) #\" \")]\n           \
    \ [number5 (split-string (fifth numbers) #\" \")]\n            [number6 (split-string\
    \ (sixth numbers) #\" \")]\n            [number7 (split-string (seventh numbers)\
    \ #\" \")]\n            [number8 (split-string (eighth numbers) #\" \")]\n   \
    \         [number9 (split-string (ninth numbers) #\" \")])\n        (cons number1\n\
    \               (if (< (first number1) (first number2))\n                   (cons\
    \ (first number1)\n                         (sort_numbers (rest numbers))\n  \
    \                     numbers)\n                   (cons (first number2)\n   \
    \                      (sort_numbers (rest numbers))\n                       numbers))\n\
    \               (if (< (first number1) (first number3))\n                   (cons\
    \ (first number1)\n                         (sort_numbers (rest numbers))\n  \
    \                     numbers)\n                   (cons (first number3)\n   \
    \                      (sort_numbers (rest numbers))\n                       numbers))\n\
    \               (if (< (first number1) (first number4))\n                   (cons\
    \ (first number1)\n                         (sort_numbers (rest numbers))\n  \
    \                     numbers)\n                   (cons (first number4)\n   \
    \                      (sort_numbers (rest numbers))\n                       numbers))\n\
    \               (if (< (first number1) (first number5))\n                   (cons\
    \ (first number1)\n                         (sort_numbers (rest numbers))\n  \
    \                     numbers)\n                   (cons (first number5)\n   \
    \                      (sort_numbers (rest numbers))\n                       numbers))\n\
    \               (if (< (first number1) (first number6))\n                   (cons\
    \ (first number1)\n                         (sort_numbers (rest numbers))\n  \
    \                     numbers)\n                   (cons (first number6)\n   \
    \                      (sort_numbers (rest numbers))\n                       numbers))\n\
    \               (if (< (first number1) (first number7))\n                   (cons\
    \ (first number1)\n                         (sort_numbers (rest numbers))\n  \
    \                     numbers)\n                   (cons (first number7)\n   \
    \                      (sort_numbers (rest numbers))\n                       numbers))\n\
    \               (if (< (first number1) (first number8))\n                   (cons\
    \ (first number1)\n                         (sort_numbers (rest numbers))\n  \
    \                     numbers)\n                   (cons (first ", "  (cond\n\
    \    [(empty? numbers) \"\"]\n    [(empty? (rest numbers)) numbers]\n    [else\
    \ (append (sort_numbers (rest numbers)) (sort_string (first numbers)))]))\n",
  "  (if (empty? numbers)\n      (list)\n      (let ([nums (split numbers)])\n   \
    \     (sort (map list nums (substring nums (- 1 (length nums))))\n           \
    \    (lambda (a b)\n                 (< (first a) (first b))\n               \
    \  (> (first a) (first b))\n                 (< (second a) (second b))\n     \
    \            (> (second a) (second b))))\n        (join (map list nums (substring\
    \ nums 0 (- (length nums) 1)))))))\n", "  (cond\n    [(string-contains \" \" (first\
    \ numbers)) (sort_numbers (rest_of numbers))]\n    [(and (number-char-set? numbers)\n\
    \          (number-char-set? (first numbers))) (sort_numbers (rest_of numbers))]\n\
    \    [(number-char-set? numbers) (number-char-set? (first numbers))]\n    [else\
    \ (number-char-set? (first numbers))]))\n", "  (string-append (sort_by_value numbers\
    \ \"one\") (sort_by_value numbers \"two\") (sort_by_value numbers \"three\")\n\
    \              (sort_by_value numbers \"four\") (sort_by_value numbers \"five\"\
    ) (sort_by_value numbers \"six\")\n              (sort_by_value numbers \"seven\"\
    ) (sort_by_value numbers \"eight\") (sort_by_value numbers \"nine\"))\n  ;; \"\
    one two three four five six seven eight nine\"\n  )\n", "  (let ([num-str numbers])\n\
    \    (list #(cond [(< %2 %1) (list %2)] [(< %1 %2) (list %1)]\n              \
    \  [else (list %1)]) (append (map (lambda (str)\n                            \
    \               (let ([num-str (string->list str)]\n                         \
    \                        [nums (sort num-str (lambda (x) (> x 0))))])\n      \
    \                                   (lambda (x) (first x)))\n                \
    \                        nums)))))\n", "  (cond [(empty? numbers) numbers]\n \
    \       [else\n         (let ([smallest (first numbers)])\n           (if (not\
    \ (number-valid? smallest))\n             (sort_numbers (rest numbers))\n    \
    \         (sort_numbers (rest (append (subseq numbers 0 1)\n                 \
    \                       (list smallest)\n                                    \
    \    (subseq numbers (+ 1 length))))))))])\n", "  (cond\n    [(empty? numbers)\
    \ \"\"]\n    [(equal? (first numbers) \"zero\") (cons (first numbers) (sort_numbers\
    \ (rest numbers)))]\n    [(equal? (first numbers) \"one\") (cons (first numbers)\
    \ (sort_numbers (rest numbers)))]\n    [(equal? (first numbers) \"two\") (cons\
    \ (first numbers) (sort_numbers (rest numbers)))]\n    [(equal? (first numbers)\
    \ \"three\") (cons (first numbers) (sort_numbers (rest numbers)))]\n    [(equal?\
    \ (first numbers) \"four\") (cons (first numbers) (sort_numbers (rest numbers)))]\n\
    \    [(equal? (first numbers) \"five\") (cons (first numbers) (sort_numbers (rest\
    \ numbers)))]\n    [(equal? (first numbers) \"six\") (cons (first numbers) (sort_numbers\
    \ (rest numbers)))]\n    [(equal? (first numbers) \"seven\") (cons (first numbers)\
    \ (sort_numbers (rest numbers)))]\n    [(equal? (first numbers) \"eight\") (cons\
    \ (first numbers) (sort_numbers (rest numbers)))]\n    [(equal? (first numbers)\
    \ \"nine\") (cons (first numbers) (sort_numbers (rest numbers)))]\n    [else (cons\
    \ (first numbers) (sort_numbers (rest numbers)))]))\n", "  (let loop ((i 'zero)\
    \ (a #) (c #) (d #) (result #))\n    (cond\n      [(null? numbers) result]\n \
    \     [(not (equal? d 'one)) (loop (+ i 1) (append a d) 'zero (append c result))]\n\
    \      [(not (equal? d 'two)) (loop (+ i 1) (append a d) 'one (append c result))]\n\
    \      [(not (equal? d 'three)) (loop (+ i 1) (append a d) 'two (append c result))]\n\
    \      [(not (equal? d 'four)) (loop (+ i 1) (append a d) 'three (append c result))]\n\
    \      [(not (equal? d 'five)) (loop (+ i 1) (append a d) 'four (append c result))]\n\
    \      [(not (equal? d 'six)) (loop (+ i 1) (append a d) 'five (append c result))]\n\
    \      [(not (equal? d 'seven)) (loop (+ i 1) (append a d) 'six (append c result))]\n\
    \      [(not (equal? d 'eight)) (loop (+ i 1) (append a d) 'seven (append c result))]\n\
    \      [(not (equal? d 'nine)) (loop (+ i 1) (append a d) 'eight (append c result))]\n\
    \      [(equal? d 'zero) (loop (+ i 1) (append a d) 'one (append c result))]\n\
    \      [(equal? d 'one) (loop (+ i 1) (append a d) 'two (append c result))]\n\
    \      [(equal? d 'two) (loop (+ i 1) (append a d) 'three (append c result))]\n\
    \      [(equal? d 'three) (loop (+ i 1) (append a d) 'four (append c result))]\n\
    \      [(equal? d 'four) (loop (+ i 1) (append a d) 'five (append c result))]\n\
    \      [(equal? d 'five) (loop (+ i 1) (append a d) 'six (append c result))]\n\
    \      [(equal? d 'six) (loop (+ i 1) (append a d) 'seven (append c result))]\n\
    \      [(equal? d 'seven) (loop (+ i 1) (append a d) 'eight (append c result))]\n\
    \      [(equal? d 'eight) (loop (+ i 1) ", "  (let ((result (list ')))\n    (let\
    \ loop ((n numbers)\n               (sorted result))\n      (if (empty? n)\n \
    \         sorted\n          (loop (cdr n)\n                (append sorted (list\
    \ n)))\n        )\n    )\n    result\n  )\n)\n", "  (sort numbers\n        #:key\
    \ (lambda (n)\n                (cond\n                 ((string=? (number->string\
    \ n) \"zero\") 0)\n                 ((string=? (number->string n) \"one\") 1)\n\
    \                 ((string=? (number->string n) \"two\") 2)\n                \
    \ ((string=? (number->string n) \"three\") 3)\n                 ((string=? (number->string\
    \ n) \"four\") 4)\n                 ((string=? (number->string n) \"five\") 5)\n\
    \                 ((string=? (number->string n) \"six\") 6)\n                \
    \ ((string=? (number->string n) \"seven\") 7)\n                 ((string=? (number->string\
    \ n) \"eight\") 8)\n                 ((string=? (number->string n) \"nine\") 9)\n\
    \                 ((string=? (number->string n) \"ten\") 10)\n               \
    \  ((string=? (number->string n) \"eleven\") 11)\n                 ((string=?\
    \ (number->string n) \"twelve\") 12)\n                 ((string=? (number->string\
    \ n) \"thirteen\") 13)\n                 ((string=? (number->string n) \"fourteen\"\
    ) 14)\n                 ((string=? (number->string n) \"fifteen\") 15)\n     \
    \            ((string=? (number->string n) \"sixteen\") 16)\n                \
    \ ((string=? (number->string n) \"seventeen\") 17)\n                 ((string=?\
    \ (number->string n) \"eighteen\") 18)\n                 ((string=? (number->string\
    \ n) \"nineteen\") 19)\n                 ((string=? (number->string n) \"twenty\"\
    ) 20)\n                 ((string=? (number->string n) \"thirty\") 30)\n      \
    \           ((string=? (number->string n) \"fourty\") 40)\n                 ((string=?\
    \ (number->string n) \"fifty\") 50)\n                 ((string=? (number->string\
    \ n) \"sixty\") 60)\n                 ((string=? (number->string n) \"seventy\"\
    ) 70)\n                 ((string=? (number->string n) \"eighty\") 80)\n      \
    \           ((string=? (number->string n) \"ninety\") 90)\n                 ((string=?\
    \ (number->string n) \"hundred\") 100)\n                 ((string=? (number->string\
    \ n) \"thousand\") 1000)\n                 ((string=? (number->string n) \"million\"\
    ) 1000000)\n                 ((string=? (number->string n) \"billion\") 1000000000)\n\
    \                 ((string=? (number->string n) \"trillion\") 1000000000000)\n\
    \                 ((string=? (number->string n) \"quadrillion\") 1000000000000000)\n\
    \                 ((string=? (number->string ", "  (let ((x (string->number numbers)))\n\
    \    (cond\n      [(< x 9) numbers]\n      [(< x 8) (string-append (symbol->string\
    \ 'two) numbers)]\n      [(< x 7) (cond [(< x 6) (cond [(< x 5) (cond [(< x 4)\
    \ (string-append (symbol->string 'three) numbers)] [(< x 3) (string-append (symbol->string\
    \ 'four) numbers)] [(< x 2) (string-append (symbol->string 'five) numbers)] [(<\
    \ x 1) (string-append (symbol->string 'six) numbers)])]\n                    [else\
    \ (string-append (symbol->string 'seven) numbers)])]\n      [(< x 6) (cond [(<\
    \ x 5) (cond [(< x 4) (cond [(< x 3) (string-append (symbol->string 'four) numbers)]\
    \ [(< x 2) (string-append (symbol->string 'five) numbers)] [(< x 1) (string-append\
    \ (symbol->string 'six) numbers)])]\n                    [else (string-append\
    \ (symbol->string 'eight) numbers)])]\n      [(< x 5) (cond [(< x 4) (cond [(<\
    \ x 3) (string-append (symbol->string 'four) numbers)] [(< x 2) (string-append\
    \ (symbol->string 'five) numbers)] [(< x 1) (string-append (symbol->string 'six)\
    \ numbers)])]\n                    [else (string-append (symbol->string 'nine)\
    \ numbers)])]\n      [else (cond [(< x 4) (cond [(< x 3) (string-append (symbol->string\
    \ 'four) numbers)] [(< x 2) (string-append (symbol->string 'five) numbers)] [(<\
    \ x 1) (string-append (symbol->string 'six) numbers)])]\n                 [(<\
    \ x 3) (cond [(< x 2) (string-append (symbol->string 'five) numbers)] [(< x 1)\
    \ (string-append (symbol->string 'six) numbers)] [(< x 0) (string-append (symbol->string\
    \ 'zero) numbers)])]\n                 [(< x 2) (cond [(< x 1) (string-append\
    \ (symbol->string 'six) numbers)] [(< x 0) (string-append (symbol->string 'zero)\
    \ numbers)])]\n                 [(< x 1) (cond [(< x 0) ", "  (sort numbers '<))\n",
  "  (cond [(empty? numbers) \"\"]\n        [(or (digit-char? first numbers)\n   \
    \          (equal? (number->string first) 'zero))\n         (cons (number->string\
    \ first)\n               (sort_numbers (rest numbers)))]\n        [else (cons\
    \ (number->string first)\n                    (sort_numbers (rest numbers)))]))\n",
  "  (let ([i 0])\n    (cond\n      [(null? numbers)\n       numbers]\n      [else\n\
    \       (cond\n         [(string? numbers)\n          (sort-strings numbers)]\n\
    \         [(number? numbers)\n          (sort-numbers numbers)]\n         [else\n\
    \          (error \"invalid input ~S\" (numbers))])])))\n", "  (define (helper\
    \ x y z)\n    (cond\n      [(< x y) (string-append (helper x (+ y 1) z)\n    \
    \                             (string-append \" \" (number->string x)))]\n   \
    \   [(< y z) (string-append (helper x (+ y 1) z)\n                           \
    \      (string-append \" \" (number->string y)))]\n      [else (string-append\
    \ (helper x (+ y 1) z)\n                            (number->string y))]))\n \
    \ (if (null? numbers)\n      \"\"\n      (helper (parse-integer (first numbers))\
    \ 0 n) (sort (subseq numbers 1) (helper (parse-integer (first numbers)) 1 n)))\n\
    \  )\n", "  (if (empty? numbers)\n      '()\n      (append (sort_numbers (rest\
    \ numbers)) (number-string (car numbers)))))\n", "  (cond\n    ((empty? numbers)\
    \ '())\n    ((null? (cdr numbers)) (cons (car numbers) '()))\n    ((member (car\
    \ numbers) '(zero one two three four five six seven eight nine))\n     (sort_numbers\
    \ (cdr numbers)))\n    (else (cons (car numbers) (sort_numbers (cdr numbers))))))\n",
  "  (let ((n (length numbers)))\n    (if (or (= n 0) (= n 1))\n        (if (string=\
    \ (substring numbers 0 1) 'zero)\n            (substring numbers 0 1)\n      \
    \      numbers)\n        (if (string= (substring numbers 0 1) 'one)\n        \
    \    (substring numbers (+ 1 1) n)\n            numbers))))\n", "  (cond\n   \
    \ [(empty? numbers) empty]\n    [(equal? first numbers) (sort_numbers rest)]\n\
    \    [else (cons first (sort_numbers (rest numbers)))]))\n", "  (let ([sorted-numbers\
    \ (sort-numbers-helper numbers 0 9)]\n        [indices (map (curry car sorted-numbers)\
    \ numbers)])\n    (string-append (string-append (format \"~s\" indices) \"~s\"\
    ) (format \"~s\" sorted-numbers))))\n</code>\n<code>\n#lang racket\n", "  (define\
    \ (comp x y)\n    (< (string->number x) (string->number y)))\n  (apply sorting-sort\n\
    \         (make-string\n          (map string->number\n              (split-string\
    \ (make-string numbers #\\Space)))\n          #:key comp)))\n", "  (let ([nums\
    \ (split-string (trim-whitespace numbers) #\" \")])\n    (sort (map read-number\
    \ nums) <))\n</code>\n<|/ a tags=scheme |>\n<| a |>\n<code>", "  (cond [(empty?\
    \ numbers) \"\"]\n        [else (cons (max_number (rest numbers)) (sort_numbers\
    \ (rest numbers)))]))\n", "  (string-append \n  (map \n   (lambda (x) (string-append\
    \ x \" \")) \n   (split numbers (string->char 'whitespace) 2)) \n  (string-append\
    \ \" (sorted)\" \"\\n\"))) \n", "  (if (equal? (string-length numbers) 9)\n  \
    \    (numbers)\n      (append (string-append \"zero\" \" \") (sort_numbers (string-append\
    \ \"one\" \" \"))\n              (string-append \"two\" \" \") (sort_numbers (string-append\
    \ \"three\" \" \"))\n              (string-append \"four\" \" \") (sort_numbers\
    \ (string-append \"five\" \" \"))\n              (string-append \"six\" \" \"\
    ) (sort_numbers (string-append \"seven\" \" \"))\n              (string-append\
    \ \"eight\" \" \") (sort_numbers (string-append \"nine\" \" \")))))\n", "  (sort\
    \ numbers\n        #:key (lambda (n)\n              (cond\n                [(<\
    \ n 'zero) 'zero]\n                [(< n 'one)  'one]\n                [(< n 'two)\
    \  'two]\n                [(< n 'three)  'three]\n                [(< n 'four)\
    \  'four]\n                [(< n 'five)  'five]\n                [(< n 'six) \
    \ 'six]\n                [(< n 'seven)  'seven]\n                [(< n 'eight)\
    \  'eight]\n                [(< n 'nine)  'nine]\n                [else (error\
    \ \"Invalid input string: ~s\" n)])))\n        #:reverse #t))\n", "  (cond\n \
    \   ((= (length numbers) 0) \"\")\n    ((string=? (substring numbers 0 1) 'zero)\
    \ \n         (cons 0 (sort_numbers (substring numbers 1 length))))\n    ((string=?\
    \ (substring numbers 0 1) 'one)\n         (cons 1 (sort_numbers (substring numbers\
    \ 1 length))))\n    ((string=? (substring numbers 0 1) 'two)\n         (cons 2\
    \ (sort_numbers (substring numbers 1 length))))\n    ((string=? (substring numbers\
    \ 0 1) 'three)\n         (cons 3 (sort_numbers (substring numbers 1 length))))\n\
    \    ((string=? (substring numbers 0 1) 'four)\n         (cons 4 (sort_numbers\
    \ (substring numbers 1 length))))\n    ((string=? (substring numbers 0 1) 'five)\n\
    \         (cons 5 (sort_numbers (substring numbers 1 length))))\n    ((string=?\
    \ (substring numbers 0 1) 'six)\n         (cons 6 (sort_numbers (substring numbers\
    \ 1 length))))\n    ((string=? (substring numbers 0 1) 'seven)\n         (cons\
    \ 7 (sort_numbers (substring numbers 1 length))))\n    ((string=? (substring numbers\
    \ 0 1) 'eight)\n         (cons 8 (sort_numbers (substring numbers 1 length))))\n\
    \    ((string=? (substring numbers 0 1) 'nine)\n         (cons 9 (sort_numbers\
    \ (substring numbers 1 length))))\n    ((string=? (substring numbers 0 1) 'zero)\n\
    \         (sort_numbers (substring numbers 1 length))) \n    ((string=? (substring\
    \ numbers 0 1) 'one)\n         (sort_numbers (substring numbers 1 length))) \n\
    \    ((string=? (substring numbers 0 1) 'two)\n         (sort_numbers (substring\
    \ numbers 1 length))) \n    ((string=? (substring numbers 0 1) 'three)\n     \
    \    (sort_numbers (substring numbers 1 length))) \n    ((string=? (substring\
    \ numbers 0 1) 'four)\n         (sort_numbers (substring numbers 1 length))) \n\
    \    ((string=? (substring numbers 0 1) 'five)\n         (sort_numbers (substring\
    \ numbers 1 length))) \n    ((string=? (substring numbers 0 1) 'six)\n       \
    \  (sort_numbers (substring numbers 1 length))) \n    ((string=? (substring numbers\
    \ 0 1) 'seven)\n         (sort_numbers (substring numbers 1 length))) \n    ((string=?\
    \ (substring numbers 0 1) 'eight)\n         (sort_numbers (", "  (define (helper\
    \ n)\n    (if (equal? (substring numbers n) \" \")\n        numbers\n        (helper\
    \ (+ n 1))))\n  (helper (length numbers)))\n", "  (cond\n    ((empty? numbers)\
    \ '())\n    ((string=? (first numbers) 'zero) '(zero))\n    ((string=? (first\
    \ numbers) 'one) '(one))\n    ((string=? (first numbers) 'two) '(two))\n    ((string=?\
    \ (first numbers) 'three) '(three three))\n    ((string=? (first numbers) 'four)\
    \ '(four four four))\n    ((string=? (first numbers) 'five) '(five five five))\n\
    \    ((string=? (first numbers) 'six) '(six six six six six))\n    ((string=?\
    \ (first numbers) 'seven) '(seven seven seven seven seven))\n    ((string=? (first\
    \ numbers) 'eight) '(eight eight eight eight eight eight eight))\n    ((string=?\
    \ (first numbers) 'nine) '(nine nine nine nine nine nine nine nine nine nine))\n\
    \    (else (cons numbers (sort_numbers (rest numbers))))))\n</code>\n<|/ a dscore=2\
    \ |>\n<| a |>\nAn industrial strength solution to your problem is to use recursive\
    \ descent parsers.\nThis is not that hard to do, especially if you take some time\
    \ to learn the theory behind parsers.\nI wrote a small parser using Common Lisp\
    \ and Parsec. It works fine in Common Lisp, but you should port it to SBCL.\n\
    <|/ a tags=algorithm,sorting dscore=2 |>\n<| c |>\nParsec's parsers aren't the\
    \ most efficient solution to this problem. Lexical analysers are still faster.\n\
    <|/ c |>\n<| c |>\nThis is probably not the most efficient solution, but it's\
    \ the simplest and has the fewest dependencies.\n<|/ c |>\n<| a dscore=2 |>\n\
    I made a quick and dirty sort function and decided to test it against quicksort\
    \ and insertion sort on small data sets.  On my machine, quicksort and insertion\
    \ sort were both faster than the sort function I created with heapsort. Here is\
    \ the code:\n<code>", "  (cond [(null? numbers) \"\"]\n        [(equal? numbers\
    \ \"\")\n         \"\"]\n        [else\n         (append (sort_numbers (substring\
    \ numbers 0 (string-length (string-trim numbers))))\n                 (string-append\
    \ numbers \" \"))]))\n", "  (let ((numbers (string numbers))\n        (result\
    \ (empty-string)))\n    (if (equal? numbers '())\n        result\n        (let\
    \ ((next (substring (numbers (string-length numbers))\n                      \
    \     0 (string.length numbers)))\n              (j (substring numbers (string-length\
    \ numbers) 0))\n              (i 0))\n          (if (equal? next '())\n      \
    \        result\n              (begin\n                (if (> (string->number\
    \ (string-ref numbers i)) (string->number (string-ref numbers j)))\n         \
    \           (append result (number->string (string->number (string-ref numbers\
    \ j)))) (sort_numbers (append next (number->string (string->number (string-ref\
    \ numbers i)))))\n                    (append result (number->string (string->number\
    \ (string-ref numbers j)))) (sort_numbers (append next (number->string (string->number\
    \ (string-ref numbers i)))) ))\n                (sort_numbers (append next (number->string\
    \ (string->number (string-ref numbers i)))))\n                (sort_numbers (append\
    \ next (number->string (string->number (string-ref numbers j)))))\n          \
    \      )))\n          (if (= i (string-length numbers))\n              (sort_numbers\
    \ (append next (number->string (string->number (string-ref numbers i)))))\n  \
    \            (begin (set! i (+ i 1)) (recur (substring numbers (string-length\
    \ numbers) (+ i 1)))))))))\n", "  (map string->number\n       (remove-if (lambda\
    \ (x) (equal? x '-))\n                  (map string->list numbers))))\n</code>\n\
    <|/ a |>\n<| c |>\nI'm guessing that this is homework given that the OP states\
    \ *\"Given a list of numbers, return a new list with the numbers sorted.\"*\n\
    <|/ c |>\n<| c |>\nYes, it's an assignment question. I do appreciate the example\
    \ code though and will use that in future assignments.\n<|/ c |>\n<| c |>\nNo\
    \ need for the `remove-if` though, `string->number` already removes anything other\
    \ than numbers.\n<|/ c |>\n<| c |>\nI'm pretty sure `string->number` doesn't remove\
    \ `-` but I can't find a reference.\n<|/ c |>\n<| c |>\nI added a link to my answer,\
    \ it appears to be untrue.\n<|/ c |>\n<| a tags=scheme |>\nThis solution works\
    \ for me, hope it helps. \n<code>", "  (let ([input (map read-string (string-split\
    \ numbers #\\Space #\\Newline))]) ; Split input on whitespace characters\n   \
    \ (if (null? input)\n        '()\n        (append (sort_numbers (sort (cons 0\
    \ (string-length input) <)\n                                 (lambda (x y) (-\
    \ x y))))\n                (map string-append input))))\n", "  (cond\n    [(empty?\
    \ numbers) \"\"]\n    [(equal? (car numbers) \"zero\") \"zero zero zero\"]\n \
    \   [(equal? (car numbers) \"one\") \"one one one\"]\n    [(equal? (car numbers)\
    \ \"two\") \"two two two\"]\n    [(equal? (car numbers) \"three\") \"three three\
    \ three\"]\n    [(equal? (car numbers) \"four\") \"four four four\"]\n    [(equal?\
    \ (car numbers) \"five\") \"five five five\"]\n    [(equal? (car numbers) \"six\"\
    ) \"six six six\"]\n    [(equal? (car numbers) \"seven\") \"seven seven seven\"\
    ]\n    [(equal? (car numbers) \"eight\") \"eight eight eight\"]\n    [(equal?\
    \ (car numbers) \"nine\") \"nine nine nine\"]\n    [else (cons (car numbers) (sort_numbers\
    \ (cdr numbers))) ]))\n", "  (cond\n    [(string-empty? numbers) numbers]\n  \
    \  [(string-contains-only numbers \"zero\") \"zero \"]\n    [(string-contains-only\
    \ numbers \"one\") \"one \"]\n    [(string-contains-only numbers \"two\") \"two\
    \ \"]\n    [(string-contains-only numbers \"three\") \"three \"]\n    [(string-contains-only\
    \ numbers \"four\") \"four \"]\n    [(string-contains-only numbers \"five\") \"\
    five \"]\n    [(string-contains-only numbers \"six\") \"six \"]\n    [(string-contains-only\
    \ numbers \"seven\") \"seven \"]\n    [(string-contains-only numbers \"eight\"\
    ) \"eight \"]\n    [(string-contains-only numbers \"nine\") \"nine \"]\n    [else\
    \ (append (sort_numbers (append (split_string numbers \" \") \"zero\"))\n    \
    \                (sort_numbers (append (split_string numbers \" \") \"one\"))\n\
    \                    (sort_numbers (append (split_string numbers \" \") \"two\"\
    ))\n                    (sort_numbers (append (split_string numbers \" \") \"\
    three\"))\n                    (sort_numbers (append (split_string numbers \"\
    \ \") \"four\"))\n                    (sort_numbers (append (split_string numbers\
    \ \" \") \"five\"))\n                    (sort_numbers (append (split_string numbers\
    \ \" \") \"six\"))\n                    (sort_numbers (append (split_string numbers\
    \ \" \") \"seven\"))\n                    (sort_numbers (append (split_string\
    \ numbers \" \") \"eight\"))\n                    (sort_numbers (append (split_string\
    \ numbers \" \") \"nine\")))]))\n", "  (define (helper n)\n    (cond\n      [(empty?\
    \ n) 'zero]\n      [(equal? (car n) 'zero) (cons (car n) (helper (cdr n)))]\n\
    \      [(equal? (car n) 'one) (cons (car n) (helper (cdr n)))]\n      [(equal?\
    \ (car n) 'two) (cons (car n) (helper (cdr n)))]\n      [(equal? (car n) 'three)\
    \ (cons (car n) (helper (cdr n)))]\n      [(equal? (car n) 'four) (cons (car n)\
    \ (helper (cdr n)))]\n      [(equal? (car n) 'five) (cons (car n) (helper (cdr\
    \ n)))]\n      [(equal? (car n) 'six) (cons (car n) (helper (cdr n)))]\n     \
    \ [(equal? (car n) 'seven) (cons (car n) (helper (cdr n)))]\n      [(equal? (car\
    \ n) 'eight) (cons (car n) (helper (cdr n)))]\n      [(equal? (car n) 'nine) (cons\
    \ (car n) (helper (cdr n)))]\n      [else (cons (car n) (helper (cdr n)))]))\n\
    \  (helper numbers))\n", '  (string-append (sort_numbers_helper numbers "") ""))',
  "  (let ([numbers (string->list numbers)]\n        [numbers (reverse numbers)])\n\
    \    (if (null? numbers)\n        '()\n        (append (sort_numbers (substring\
    \ numbers (+ 0 (length (first numbers))))) (cons (first numbers) numbers)))))\n",
  "  (cond\n    [(null? numbers) \"\"]\n    [(number-char? (first numbers)) (sort_numbers\
    \ (rest numbers))]\n    [else (append (sort_numbers (rest numbers)) (list (first\
    \ numbers)))]))\n", "  (if (null? numbers)\n      '()\n      (let ([digits (string->list\
    \ numbers)])\n        (cond [(< 9 digits)\n               (append (sort_numbers\
    \ (append (substring numbers (car digits))\n                                 \
    \          (list \"zero\"))))\n               (append (sort_numbers (append (substring\
    \ numbers (car digits))\n                                           (list \"one\"\
    ))))\n               (append (sort_numbers (append (substring numbers (car digits))\n\
    \                                           (list \"two\"))))\n              \
    \ (append (sort_numbers (append (substring numbers (car digits))\n           \
    \                                (list \"three\"))))\n               (append (sort_numbers\
    \ (append (substring numbers (car digits))\n                                 \
    \          (list \"four\"))))\n               (append (sort_numbers (append (substring\
    \ numbers (car digits))\n                                           (list \"five\"\
    ))))\n               (append (sort_numbers (append (substring numbers (car digits))\n\
    \                                           (list \"six\"))))\n              \
    \ (append (sort_numbers (append (substring numbers (car digits))\n           \
    \                                (list \"seven\"))))\n               (append (sort_numbers\
    \ (append (substring numbers (car digits))\n                                 \
    \          (list \"eight\"))))\n               (append (sort_numbers (append (substring\
    \ numbers (car digits))\n                                           (list \"nine\"\
    ))))\n               '()])))\n", "  (string-join (map \n\t\t   lambda(number)\
    \ \n\t\t   (if (string=? \"zero\" number) \n\t\t      \"zero\" \n\t\t      (if\
    \ (string=? \"one\" number) \n\t\t         \"one\" \n\t\t         (if (string=?\
    \ \"two\" number) \n\t\t            \"two\" \n\t\t            (if (string=? \"\
    three\" number) \n\t\t               \"three\" \n\t\t               (if (string=?\
    \ \"four\" number) \n\t\t                  \"four\" \n\t\t                  (if\
    \ (string=? \"five\" number) \n\t\t                     \"five\" \n\t\t      \
    \               (if (string=? \"six\" number) \n\t\t                        \"\
    six\" \n\t\t                        (if (string=? \"seven\" number) \n\t\t   \
    \                        \"seven\" \n\t\t                           (if (string=?\
    \ \"eight\" number) \n\t\t                              \"eight\" \n\t\t     \
    \                          (if (string=? \"nine\" number) \n\t\t             \
    \                      \"nine\" \n\t\t                                    number)))))))))\n",
  "  (let ([result '()])\n    (cond [(null? numbers)\n           (reverse result)]\n\
    \          [(number? (car numbers))\n           (cons (cons (car numbers) (car\
    \ result)) (sort_numbers (cdr numbers)))]\n          [else\n           (cons (cons\
    \ (car result) (car numbers)) (sort_numbers (cdr numbers)))]\n          )))\n",
  "  (match numbers\n    ['(zero) '(zero)]\n    ['(one) '(one)]\n    ['(two) '(two)]\n\
    \    ['(three) '(three)]\n    ['(four) '(four)]\n    ['(five) '(five)]\n    ['(six)\
    \ '(six)]\n    ['(seven) '(seven)]\n    ['(eight) '(eight)]\n    ['(nine) '(nine)]\n\
    \    [else (append (sort_numbers (subseq numbers 0 (min (length numbers) (length\
    \ numbers))))\n                  (sort_numbers (subseq numbers (min (length numbers)\
    \ (length numbers)) (min (length numbers) (length numbers))))]\n    ))\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nthanks for your response. I tried the code with slight\
    \ modification and it worked fine. I am a beginner in scheme and was just trying\
    \ to do the following code (sort_numbers \"three one five\"). but its not working.\
    \ i got this error message when i try to run the code (sort_numbers \"three one\
    \ five\"). Error: Unexpected error while compiling sort function: #<unbound variable>\n\
    <|/ c |>\n<| c |>\nThe `[else (append ...` line is the problem. The `else` is\
    \ an anonymous function and you need to give it a name. If you want to continue\
    \ using the same code change it to `[else (append ... (sort ...))]` and add `[else\
    \ (sort ...)]` at the end of the list so that the function returns a list. If\
    \ you want to write this in Scheme, I would recommend [Racket](http://racket-lang.org/)\
    \ over Scheme.\n<|/ c |>\n<| c |>\nthanks a lot for the response. I am using a\
    \ textbook and they gave me this code. so i guess i have to try the code in racket\
    \ and see if it works. I am learning scheme now and i dont want to change too\
    \ much of it.\n<|/ c |>\n<| a |>\nThere are several things you need to change\
    \ in your code:\n\nThe else should be the second list element instead of first.\n\
    You don't need to write (sort numbers), use sort instead.\nYou probably want to\
    \ remove any duplicates from the sorted list. If so, use sort again.\nIf you're\
    \ new to Racket you should probably learn about using racket's if/else instead\
    \ of (match ... ['(...) [else ...]]). Think about how this looks: is this an if\
    \ ... else ... clause, or is it a match ... clause with two branches?\n<|/ a dscore",
  "  (cond [(empty? numbers) \"\"]\n        [(equal? numbers \"zero\") \"zero\"]\n\
    \        [(equal? numbers \"one\") \"one\"]\n        [(equal? numbers \"two\"\
    ) \"two\"]\n        [(equal? numbers \"three\") \"three\"]\n        [(equal? numbers\
    \ \"four\") \"four\"]\n        [(equal? numbers \"five\") \"five\"]\n        [(equal?\
    \ numbers \"six\") \"six\"]\n        [(equal? numbers \"seven\") \"seven\"]\n\
    \        [(equal? numbers \"eight\") \"eight\"]\n        [(equal? numbers \"nine\"\
    ) \"nine\"]\n        [else (sort_numbers (list-sort-all numbers))]))\n", "  (cond\n\
    \    [(empty? numbers) \"\"]\n    [(number? (first numbers)) \"\"]\n    [else\
    \ (append (sort_numbers (rest numbers)) (first numbers))]))\n", "  (let ([s1 '()\n\
    \        s2 '()\n        ns (numbers-string->numbers (string->list numbers))])\n\
    \    (if (null? ns)\n        '()\n        (let (([a (car ns)\n               b\
    \ (caddr ns)\n               t (number-compare (caddr ns) (cadddr ns))\n     \
    \          c (cond ((< t 0) '())\n                       ((= t 0) s1)\n      \
    \                 ((= t 1) s2)\n                       ((> t 0) (cons a b))\n\
    \                       (else (cons (caddr ns) s2))])\n              [d (cdr ns)\n\
    \               (e (cadddr ns)\n                  c (cond ((< t 0) '())\n    \
    \                     ((= t 0) s1)\n                         ((= t 1) s2)\n  \
    \                       ((> t 0) (cons d e))\n                         (else (cons\
    \ (cadddr ns) (s1 d e))))])\n          (cond ((> t 0) (sort_numbers s1 s2))\n\
    \                ((> t 1) (sort_numbers s1 c))\n                (else (sort_numbers\
    \ c e))))))))\n", "  (let ([x (number->string 0)]\n        [y (number->string\
    \ 1)]\n        [z (number->string 2)]\n        [xs numbers-string->list]\n   \
    \     [ys numbers-string->list]\n        [zs numbers-string->list])\n    (if (null?\
    \ numbers)\n        '()\n        (append (if (string= x y) x y)\n            \
    \     (append x (sort_numbers (substring numbers 2)))\n                 (append\
    \ y (sort_numbers (substring numbers 2)))\n                 (append z (sort_numbers\
    \ (substring numbers 2)))))))\n", "  (cond\n    [(numbers = \"\") \"\"]\n    [(numbers\
    \ = \"zero\") \"zero\"]\n    [(numbers = \"one\") \"one\"]\n    [(numbers = \"\
    two\") \"two\"]\n    [(numbers = \"three\") \"three\"]\n    [(numbers = \"four\"\
    ) \"four\"]\n    [(numbers = \"five\") \"five\"]\n    [(numbers = \"six\") \"\
    six\"]\n    [(numbers = \"seven\") \"seven\"]\n    [(numbers = \"eight\") \"eight\"\
    ]\n    [(numbers = \"nine\") \"nine\"]\n    [else\n     (sort (numbers-of-digits\
    \ (string->number numbers)) <)]))", "  (cond [(empty? numbers) \"\"]\n       \
    \ [else (cond [(number? (car numbers))\n                       (sort_numbers (cdr\
    \ numbers))]\n                    [else (concat \"~a \" (sort_numbers numbers))]))]))\n",
  "  (map \n   (lambda (n) (if (string-equal? (number-string n) \"zero\") \"zero \"\
    \ number-string n))\n   (sort numbers))))\n", "  (string-replace (sort-numbers-helper\
    \ numbers)\n                  \"-\" \" \"))\n", "  (let ([alpha (append '(zero\
    \ one two three four five six seven eight nine)\n                     numbers))\n\
    \    (string-join (map string-concat (map to-number\n                        \
    \                 alpha (remove (\u03BB (x) (number-string x))\n             \
    \                                       numbers))\n                      (remove\
    \ (\u03BB (x) (number-string x))\n                               (remove (\u03BB\
    \ (x) (number-string x))\n                                      numbers))))))\n",
  "  (sort (map (lambda (num)\n              (cond [(number? (num)) (list num)]\n\
    \                    [(number? (cdr num)) (list num (car num))]\n            \
    \        [else (list num)])) \n              (split numbers (string->list \" \"\
    )))))\n", "  ;; Split string into an array of words\n  (define (split s)\n   \
    \ (string->list (string->string s))\n  )\n  (define (sort x)\n    (cond ((string=?\
    \ (car x) 'zero) (cons 0 x))\n          ((string=? (car x) 'one) (cons 1 x))\n\
    \          ((string=? (car x) 'two) (cons 2 x))\n          ((string=? (car x)\
    \ 'three) (cons 3 x))\n          ((string=? (car x) 'four) (cons 4 x))\n     \
    \     ((string=? (car x) 'five) (cons 5 x))\n          ((string=? (car x) 'six)\
    \ (cons 6 x))\n          ((string=? (car x) 'seven) (cons 7 x))\n          ((string=?\
    \ (car x) 'eight) (cons 8 x))\n          ((string=? (car x) 'nine) (cons 9 x))\n\
    \          (else (cons (sort (car x)) (sort (cdr x))))\n  )\n  (sort (split numbers)))\n",
  "  (map (lambda (number)\n         (sort_string number numbers))\n       (string->list\
    \ numbers)))\n", "  (map string->number numbers)\n  (sort (lambda (x) (< x 9))\
    \ numbers))\n", "  (cond\n    [(empty? numbers) \"\"]\n    [(or (= (length numbers)\
    \ 1) (= (length numbers) 2)) (sort_number numbers)]\n    [else (sort_string numbers)]))\n",
  "  (map string->number \n       (remove-duplicates\n        (sort \n         (map\
    \ string->list numbers)\n         <\n         (\u03BB (a b) (< (string->number\
    \ a) (string->number b)))\n         ))))\n", "  (sort\n   (remove-if (string=?\
    \ numbers \"zero\") (remove-if (string=? numbers \"one\") (remove-if (string=?\
    \ numbers \"two\") (remove-if (string=? numbers \"three\") (remove-if (string=?\
    \ numbers \"four\") (remove-if (string=? numbers \"five\") (remove-if (string=?\
    \ numbers \"six\") (remove-if (string=? numbers \"seven\") (remove-if (string=?\
    \ numbers \"eight\") (remove-if (string=? numbers \"nine\") numbers)))))))\n \
    \  '<)\n", "  (if (string=? (first numbers) \"zero\")\n      (cons (first numbers)\
    \ (rest (rest numbers)))\n      (cons (first numbers) (sort_numbers (rest numbers)))))\n",
  "  (define (compare-numbers num1 num2)\n    (if (number? num1)\n        (if (number?\
    \ num2)\n            (compare num1 num2)\n            (compare-numbers 'none of\
    \ num1 num2))\n        (if (number? num2)\n            (compare-numbers 'none\
    \ of num1 num2)\n            (compare num1 num2)))\n    (compare-numbers 'none\
    \ of numbers num1 num2))\n  (let ([digits (split numbers \" \")])\n    (reverse\
    \ (sort (map string->number digits) #'< :key #'car)))\n", "  (if (empty? numbers)\n\
    \      '()\n      (append (sort (number->number numbers)\n                   \
    \ <\n                    (lambda (a b)\n                      (< (number->number\
    \ a) (number->number b)))))\n              (sort_numbers (substring numbers (length\
    \ numbers) (length numbers)))))\n", "  (let loop ([numbers numbers]\n        \
    \     [output \"\"])\n    (cond\n      [(empty? numbers) output]\n      [(string=?\
    \ \"zero\" (first numbers)) (loop (rest numbers) (append output (first numbers)))]\n\
    \      [(string=? \"one\" (first numbers)) (loop (rest numbers) (append output\
    \ (first numbers)))]\n      [(string=? \"two\" (first numbers)) (loop (rest numbers)\
    \ (append output (first numbers)))]\n      [(string=? \"three\" (first numbers))\
    \ (loop (rest numbers) (append output (first numbers)))]\n      [(string=? \"\
    four\" (first numbers)) (loop (rest numbers) (append output (first numbers)))]\n\
    \      [(string=? \"five\" (first numbers)) (loop (rest numbers) (append output\
    \ (first numbers)))]\n      [(string=? \"six\" (first numbers)) (loop (rest numbers)\
    \ (append output (first numbers)))]\n      [(string=? \"seven\" (first numbers))\
    \ (loop (rest numbers) (append output (first numbers)))]\n      [(string=? \"\
    eight\" (first numbers)) (loop (rest numbers) (append output (first numbers)))]\n\
    \      [(string=? \"nine\" (first numbers)) (loop (rest numbers) (append output\
    \ (first numbers)))]\n      [else\n       (loop (rest numbers) (append output\
    \ (first numbers)))])))\n</code>\n<|/ a tags=string,racket,scheme,sorting |>\n\
    <| a |>\nAs others have already mentioned that sort is your friend, I wanted to\
    \ demonstrate how it can be implemented using sort (without using recursion).\n\
    <code>", "  (let ([nums numbers]\n        [n 0]\n        [max 9])\n    (cond\n\
    \      [(empty? nums) '()] \n      [(equal? (first nums) 'zero) (cons 0 (reverse\
    \ (sort_numbers (rest nums))))]\n      [(equal? (first nums) 'one) (cons 1 (reverse\
    \ (sort_numbers (rest nums))))]\n      [(equal? (first nums) 'two) (cons 2 (reverse\
    \ (sort_numbers (rest nums))))]\n      [(equal? (first nums) 'three) (cons 3 (reverse\
    \ (sort_numbers (rest nums))))]\n      [(equal? (first nums) 'four) (cons 4 (reverse\
    \ (sort_numbers (rest nums))))]\n      [(equal? (first nums) 'five) (cons 5 (reverse\
    \ (sort_numbers (rest nums))))]\n      [(equal? (first nums) 'six) (cons 6 (reverse\
    \ (sort_numbers (rest nums))))]\n      [(equal? (first nums) 'seven) (cons 7 (reverse\
    \ (sort_numbers (rest nums))))]\n      [(equal? (first nums) 'eight) (cons 8 (reverse\
    \ (sort_numbers (rest nums))))]\n      [(equal? (first nums) 'nine) (cons 9 (reverse\
    \ (sort_numbers (rest nums))))]\n      [else (cons n (sort_numbers (rest nums)))])))\n",
  "  (sort (string numbers) <))\n</cell>\n<cell>\n#lang racket\n", "  (let ([nums\
    \ (remove-if-not (lambda (x) (and (integer? (car x)) (not (member x '(zero one\
    \ two three four five six seven eight nine))))) numbers)])\n    (if (null? nums)\n\
    \        '()\n        (append (sort_numbers (sort_if-not (lambda (x) (and (integer?\
    \ (car x)) (not (member x '(zero one two three four five six seven eight nine)))))\
    \ (cdr nums)) (car nums)))))\n", "  (cond\n    [(empty? numbers) \"\"]\n    [(equal?\
    \ (first numbers) \"zero\") \"zero zero zero\"]\n    [(equal? (first numbers)\
    \ \"one\") \"one one one\"]\n    [(equal? (first numbers) \"two\") \"two two two\"\
    ]\n    [(equal? (first numbers) \"three\") \"three three three\"]\n    [(equal?\
    \ (first numbers) \"four\") \"four four four\"]\n    [(equal? (first numbers)\
    \ \"five\") \"five five five\"]\n    [(equal? (first numbers) \"six\") \"six six\
    \ six\"]\n    [(equal? (first numbers) \"seven\") \"seven seven seven\"]\n   \
    \ [(equal? (first numbers) \"eight\") \"eight eight eight\"]\n    [(equal? (first\
    \ numbers) \"nine\") \"nine nine nine\"]\n    [else (cons (first numbers)\n  \
    \            (sort_numbers (rest numbers))\n              )]))\n", "  (if (null?\
    \ numbers)\n      '()\n      (append (sort_numbers (split-string (substring numbers\
    \ 0) \" \"))\n              (cons (substring numbers (string-length numbers))\
    \ \" \")\n              (sort_numbers (split-string (substring numbers (string-length\
    \ numbers)) \" \")))))\n", "  (let ((number-list '()))\n    (for ([i (in-range\
    \ (length numbers) 1) ])\n      (if (= i 0)\n          (set-car! number-list numbers)\n\
    \          (cons (car numbers) number-list)))))\n", "  (sort numbers <))\n", " \
    \ (if (null? numbers) \"\"\n      (append (sort_numbers (cdr numbers)) (list (car\
    \ numbers)))))\n", "  (define (parse-number s)\n    (char->number (car s))\n \
    \   (let ((n (parse-number s)))\n      (cons n nil)))\n  (sort (parse-number numbers)\
    \ <))\n", "  (let loop ((numbers numbers)\n             (count 0))\n    (if (<=\
    \ count (length numbers))\n        (substring numbers (+ count 1) (length numbers))\n\
    \        (reverse numbers))))\n", "  (cond [(empty? numbers) \"\"]\n        [(string-equal?\
    \ \"zero\" (car numbers)) \n         (sort_numbers (cdr numbers))]\n        [(string-equal?\
    \ \"one\" (car numbers)) \n         (sort_numbers (cdr numbers))]\n        [(string-equal?\
    \ \"two\" (car numbers)) \n         (sort_numbers (cdr numbers))]\n        [(string-equal?\
    \ \"three\" (car numbers)) \n         (sort_numbers (cdr numbers))]\n        [(string-equal?\
    \ \"four\" (car numbers)) \n         (sort_numbers (cdr numbers))]\n        [(string-equal?\
    \ \"five\" (car numbers)) \n         (sort_numbers (cdr numbers))]\n        [(string-equal?\
    \ \"six\" (car numbers)) \n         (sort_numbers (cdr numbers))]\n        [(string-equal?\
    \ \"seven\" (car numbers)) \n         (sort_numbers (cdr numbers))]\n        [(string-equal?\
    \ \"eight\" (car numbers)) \n         (sort_numbers (cdr numbers))]\n        [(string-equal?\
    \ \"nine\" (car numbers)) \n         (sort_numbers (cdr numbers))]\n        [else\
    \ \n         (cons (car numbers)\n              (sort_numbers (cdr numbers))))]\n\
    ))\n", "  (define (split n s)\n    (if (empty? s) (list n) \n        (if (equal?\
    \ (car s) '-) \n            (if (< n (cadr s))\n                (split n (cdr\
    \ s))\n                (split n (cdr s)) \n            )\n            (split n\
    \ (cdr s)) \n        )\n    )\n  )\n  (define (sum l)\n    (if (null? l)\n   \
    \     0\n        (+ (car l) (sum (cdr l))) \n    )\n  )\n  (define (max l)\n \
    \   (if (null? l)\n        null\n        (if (< (car l) (max l))\n           \
    \ (max l)\n        )\n    )\n  )\n  (if (equal? numbers \"\")\n      (list \"\"\
    )\n      (if (equal? numbers (car numbers))\n          (list numbers)\n      \
    \    (if (< numbers (car numbers))\n              (if (empty? (cdr numbers))\n\
    \                  (list \"\")\n                  (list (car numbers) (car numbers))\n\
    \              )\n              (list (car numbers)\n                    (split\
    \ numbers (cdr numbers))\n                    (sum (split numbers (cdr numbers)))\n\
    \                    (max (split numbers (cdr numbers)))\n              ) \n \
    \         ) \n      )\n  )\n)\n", "  (if (numbers-valid numbers)\n      (sort\
    \ numbers)\n      null))\n", "  (define numbers-in-list \n    (string->list \n\
    \      (map number->string \n         (sort (list #'char->integer (string->char\
    \ numbers)) <)))\n    (string->list \n      (map char->string \n         (sort\
    \ (list #'string->integer (list->string numbers-in-list)) <)))))\n</code>\n<|/\
    \ a tags=racket,sorting dscore=3 |>\n<| c |>\nThank you. This was a fun exercise\
    \ and very interesting. :)\n<|/ c |>\n<| a tags=racket,sorting |>\nJust in case,\
    \ if you're stuck with Racket or R5RS and you want to have your solutions under\
    \ a certain language boundry, here is a solution using higher-order functions:\n\
    <code>", "  (string-replace (regexp-replace (regexp-split numbers #\"\\\\s+\"\
    ) \"nine\" #'<) \" \" #\"\"))\n", "  (if (null? numbers)\n      '()\n      (append\
    \ (sort numbers '<) (sort_numbers (rest numbers)))))\n", "  (define (compare x\
    \ y)\n    (when (string=? (string-compare x y) \"zero\")\n      0))\n  (define\
    \ (compare x y)\n    (when (string=? (string-compare x y) \"one\")\n      1))\n\
    \  (define (compare x y)\n    (when (string=? (string-compare x y) \"two\")\n\
    \      2))\n  (define (compare x y)\n    (when (string=? (string-compare x y)\
    \ \"three\")\n      3))\n  (define (compare x y)\n    (when (string=? (string-compare\
    \ x y) \"four\")\n      4))\n  (define (compare x y)\n    (when (string=? (string-compare\
    \ x y) \"five\")\n      5))\n  (define (compare x y)\n    (when (string=? (string-compare\
    \ x y) \"six\")\n      6))\n  (define (compare x y)\n    (when (string=? (string-compare\
    \ x y) \"seven\")\n      7))\n  (define (compare x y)\n    (when (string=? (string-compare\
    \ x y) \"eight\")\n      8))\n  (define (compare x y)\n    (when (string=? (string-compare\
    \ x y) \"nine\")\n      9))\n  (sort numbers compare))\n", "  (sort\n   (lambda\
    \ (x y)\n     (< x y)) (numbers)))\n", "  (let loop ([count 0]\n             [result\
    \ 'empty])\n    (if (empty? numbers)\n        result\n        (loop (add1 count)\n\
    \               (append (sort_numbers_part count numbers)\n                  \
    \    result)))))\n", "  (cond [(numbers '(zero zero zero)) '(zero zero zero)]\n\
    \        [(numbers '(zero zero zero)) '(zero zero zero)]\n        [(numbers '(zero\
    \ zero zero)) '(zero zero zero)]\n        [(numbers '(zero zero zero)) '(zero\
    \ zero zero)]\n        [(numbers '(zero zero zero)) '(zero zero zero)]\n     \
    \   [(numbers '(zero zero zero)) '(zero zero zero)]\n        [(numbers '(zero\
    \ zero zero)) '(zero zero zero)]\n        [(numbers '(zero zero zero)) '(zero\
    \ zero zero)]\n        [(numbers '(zero zero zero)) '(zero zero zero)]\n     \
    \   [(numbers '(zero zero zero)) '(zero zero zero)]\n        [(numbers '(zero\
    \ zero zero)) '(zero zero zero)]\n        [(numbers '(zero zero zero)) '(zero\
    \ zero zero)]\n        [(numbers '(zero zero zero)) '(zero zero zero)]\n     \
    \   [(numbers '(zero zero zero)) '(zero zero zero)]\n        [(numbers '(zero\
    \ zero zero)) '(zero zero zero)]\n        [(numbers '(zero zero zero)) '(zero\
    \ zero zero)]\n        [(numbers '(zero zero zero)) '(zero zero zero)]\n     \
    \   [(numbers '(zero zero zero)) '(zero zero zero)]\n        [(numbers '(zero\
    \ zero zero)) '(zero zero zero)]\n        [(numbers '(zero zero zero)) '(zero\
    \ zero zero)]\n        [(numbers '(zero zero zero)) '(zero zero zero)]\n     \
    \   [(numbers '(zero zero zero)) '(zero zero zero)]\n        [(numbers '(zero\
    \ zero zero)) '(zero zero zero)]\n        [(numbers '(zero zero zero)) '(zero\
    \ zero zero)]\n        [(numbers '(zero zero zero)) '(zero zero zero)]\n     \
    \   [(numbers '(zero zero zero)) '(zero zero zero)]\n        [(numbers '(zero\
    \ zero zero)) '(zero zero zero)]\n        [(numbers '(zero zero zero)) '(zero\
    \ zero zero)]\n        [(numbers '(zero zero zero)) '(zero zero zero)]\n     \
    \   [(numbers '(zero zero zero)) '(zero zero zero)]\n        [(numbers '(zero\
    \ zero zero)) '(zero zero zero)]\n        [(numbers '(zero zero zero)) '(zero\
    \ zero zero", "  (map \n   (\u03BB (x)\n     (sort (map number numbers) \n   \
    \         (\u03BB (a b) (< (number a) (number b)) \n                 (string x))))\n\
    \   (string numbers)))\n", "  (cond\n    [(string? numbers)\n     (sort (numbers-list\
    \ numbers) #(< (length %) 1)))]\n    [else\n     (error 'bad-type)]))\n", "  (if\
    \ (empty? numbers)\n      numbers\n      (sort_numbers (append numbers (list numbers)))))\n\
    </code>\n<|/ a tags=scheme dscore=1 |>\n<| a dscore=1 |>\nHere's an interesting\
    \ way to do it. It's almost certainly the most efficient.\n<code>", "  (if (null?\
    \ numbers)\n      '()\n      (append (sort_numbers (substring numbers 0 (string-length\
    \ numbers)))\n               (substring numbers 1 (string-length numbers)))))\n",
  "  (define (helper n lst)\n    (if (= n 9)\n        lst\n        (helper (sub1 n)\
    \ \n          (append \n            (if (= n 0) \"zero\"\n                (if\
    \ (= n 1) \"one\"\n                    (if (= n 2) \"two\"\n                 \
    \       (if (= n 3) \"three\"\n                            (if (= n 4) \"four\"\
    \n                                (if (= n 5) \"five\"\n                     \
    \               (if (= n 6) \"six\"\n                                        (if\
    \ (= n 7) \"seven\"\n                                            (if (= n 8) \"\
    eight\"\n                                                (if (= n 9) \"nine\"\n\
    \                                                    (if (number-gt?n lst)\n \
    \                                                       (number-gt?n (cons n (helper\
    \ n (sub1 lst))))\n                                                    (number-gt?n\
    \ lst)))))\n                                    lst)))))\n            (helper\
    \ (sub1 n) lst)))\n  (helper 1 (reverse (sort (number->string numbers)))))\n",
  "  (let ([nums (map (make-atom 'zero) '(0 1 2 3 4 5 6 7 8 9))]\n        (result\
    \ '()))\n    (loop for nt in numbers '()\n          for ns in (split nt \" \"\
    )\n          for n in (ns)\n          do (set! nums \n                  (cons\
    \ (- n 1) (cons! nums (make-atom n))))\n          until (> (length (rest nums))\
    \ 0))\n    (for-each (lambda (x) (push! result (print x))) nums)\n    result))\n\
    </code>\n<|/ a tags=racket,sorting,scheme |>\n<| c |>\nThis works too but I'm\
    \ more concerned about the speed and complexity as I will be doing this in real\
    \ life at some point in the future. I was wondering if I could use some kind of\
    \ sorting algorithm to sort the numbers in place.\n<|/ c |>\n<| c |>\nHi Glenn,\
    \ I added a solution without mutation. Can you think of a way to improve it ?\n\
    <|/ c |>\n<| c |>\n`for` loops are slow, `cond` is even worse, so I would avoid\
    \ this solution (although it is nice to see how it works).\n<|/ c |>\n<| c |>\n\
    `cond` is still more efficient than `for` loops. What about `for-each`? It should\
    \ be faster than `for`. Please let me know what you think.\n<|/ c |>\n<| c |>\n\
    `for` loops are fast but `for-each` is not. `for-each` is `for` that works on\
    \ lists, not on a `for` loop. It's a functional style for loop that can be written\
    \ as `for`-like code. In a functional style, `for` is used for side-effects. Mutation\
    \ is a side-effect, while `for` is used for side-effects and loops are for iterating.\
    \ That's why I said \"a nice to see how it works\". I don't know what is the complexity\
    \ of `cond`, I don't think it is O(n). `for-each` is O(n).\n<|/ c |>\n<| a tags=racket,sorting,scheme\
    \ |>\nThe Racket sort function takes a comparator that compares two elements of\
    \ the list to order them. Here's an example:\n<code>", "  (cond\n    [(null? numbers)\
    \ \"\"]\n    [(digits-length numbers < 9) \"illegal number of digits: ~d\"]\n\
    \    [else (cons (sort (map read-string (substring numbers (substring (length\
    \ (substring numbers 0 2)) 2) 'one'))\n                         (<)\n        \
    \                 (map read-string (substring numbers (substring (length (substring\
    \ numbers 0 2)) 2) 'two'))\n                         (<)\n                   \
    \      (map read-string (substring numbers (substring (length (substring numbers\
    \ 0 2)) 2) 'three'))\n                         (<)\n                         (map\
    \ read-string (substring numbers (substring (length (substring numbers 0 2)) 2)\
    \ 'four'))\n                         (<)\n                         (map read-string\
    \ (substring numbers (substring (length (substring numbers 0 2)) 2) 'five'))\n\
    \                         (<)\n                         (map read-string (substring\
    \ numbers (substring (length (substring numbers 0 2)) 2) 'six'))\n           \
    \              (<)\n                         (map read-string (substring numbers\
    \ (substring (length (substring numbers 0 2)) 2) 'seven'))\n                 \
    \        (<)\n                         (map read-string (substring numbers (substring\
    \ (length (substring numbers 0 2)) 2) 'eight'))\n                         (<)\n\
    \                         (map read-string (substring numbers (substring (length\
    \ (substring numbers 0 2)) 2) 'nine'))\n                         (<)\n       \
    \                  (map read-string (substring numbers (substring (length (substring\
    \ numbers 0 2)) 2) 'zero'))\n                         (<)\n                  \
    \       (map read-string (substring numbers (substring (length (substring numbers\
    \ 0 2)) 2) 'one'))\n                         (<)\n                         (map\
    \ read-string (substring numbers (substring (length (substring numbers 0 2)) 2)\
    \ 'two'))\n                         (<)\n                         (map read-string\
    \ (substring numbers (substring (length (substring numbers 0 2)) 2) 'three'))\n\
    \                         (<)\n                         (map read-string (substring\
    \ numbers (substring (length (substring numbers 0 2)) 2) 'four'))\n          \
    \               (<)\n                         (map read-string (substring numbers\
    \ (substring (length (substring numbers 0 2)) 2) 'five'))\n                  \
    \       (<)\n                         (map read-string (substring numbers (substring\
    \ (length (substring numbers 0 2)) 2) 'six'))\n                         (<)\n\
    \                         (map read-string (substring number", "  ;; sort a list\
    \ of numbers from smallest to largest\n  ;; returns a list, not a string\n  (cond\n\
    \    ((null? numbers) '())\n    ((numbers-only (first numbers)) (sort_numbers\
    \ (rest numbers)))\n    (else (cons (first (first numbers)) (sort_numbers (rest\
    \ numbers))))))\n", "  (let ([chars '(zero one two three four five six seven eight\
    \ nine)])\n    (cond\n      [(empty? numbers) '()]\n      [(equal? (first numbers)\
    \ 'zero) (sort_numbers \"\" '(zero one two three four five six seven eight nine))]\n\
    \      [(equal? (first numbers) 'one) (sort_numbers \"\" '(one two three four\
    \ five six seven eight nine))]\n      [(equal? (first numbers) 'two) (sort_numbers\
    \ \"\" '(two three four five six seven eight nine))]\n      [(equal? (first numbers)\
    \ 'three) (sort_numbers \"\" '(three four five six seven eight nine))]\n     \
    \ [(equal? (first numbers) 'four) (sort_numbers \"\" '(four five six seven eight\
    \ nine))]\n      [(equal? (first numbers) 'five) (sort_numbers \"\" '(five six\
    \ seven eight nine))]\n      [(equal? (first numbers) 'six) (sort_numbers \"\"\
    \ '(six seven eight nine))]\n      [(equal? (first numbers) 'seven) (sort_numbers\
    \ \"\" '(seven eight nine))]\n      [(equal? (first numbers) 'eight) (sort_numbers\
    \ \"\" '(eight nine))]\n      [(equal? (first numbers) 'nine) (sort_numbers \"\
    \" '(nine))]\n      [else (append (sort_numbers (rest (first numbers))) \n   \
    \                 (cons (first numbers) chars))])))\n", "  (define (helper lst\
    \ cur)\n    (cond [(null? lst) (list cur)]\n          [(= (rest (car lst)) cur)\
    \ (helper (cdr lst) cur)]\n          [else (helper (cdr lst) cur)]))\n  (helper\
    \ numbers 0))\n", "  (let ((numbers (string->list numbers)))\n    (sort numbers\
    \ (<)))\n  (apply string->string numbers))\n", "  (cond\n    [(string-empty? numbers)\
    \ \"\"]\n    [(equal? (string-ref numbers 0) \"zero\") \"\"]\n    [(equal? (string-ref\
    \ numbers 0) \"one\") \"one\"]\n    [(equal? (string-ref numbers 0) \"two\") \"\
    two\"]\n    [(equal? (string-ref numbers 0) \"three\") \"three\"]\n    [(equal?\
    \ (string-ref numbers 0) \"four\") \"four\"]\n    [(equal? (string-ref numbers\
    \ 0) \"five\") \"five\"]\n    [(equal? (string-ref numbers 0) \"six\") \"six\"\
    ]\n    [(equal? (string-ref numbers 0) \"seven\") \"seven\"]\n    [(equal? (string-ref\
    \ numbers 0) \"eight\") \"eight\"]\n    [(equal? (string-ref numbers 0) \"nine\"\
    ) \"nine\"]\n    [(equal? (string-ref numbers 0) \"zero\") \"\"]\n    [else (cons\
    \ (sort_numbers (substring numbers (string-length numbers) 1))\n             \
    \   (sort_numbers (substring numbers (string-length numbers) 2)))]\n    )\n  )\n",
  "  (cond [(null? numbers) numbers]\n        [(number? (car numbers)) (cons (car\
    \ numbers) (sort_numbers (cdr numbers)))]\n        [else (cons (car numbers) (sort_numbers\
    \ (cdr numbers)))]))\n", "  (map string \n       (append \n          (string-join\
    \ '() \n                        (sort numbers\n                              \
    \ (lambda (x)\n                                  (number->string\n           \
    \                          (number->number (first x))\n                      \
    \               #:negative-number-key \n                                     (number->number\
    \ x)\n                                     #:key (lambda (x)\n               \
    \                              (number->string \n                            \
    \                      (number->number x)))))\n                              \
    \ (lambda (x)\n                                  (number->string\n           \
    \                          (number->number (first x))\n                      \
    \               #:negative-number-key \n                                     (number->number\
    \ x)\n                                     #:key (lambda (x)\n               \
    \                              (number->string \n                            \
    \                      (number->number x)))))\n                              \
    \ (lambda (x)\n                                  (number->string\n           \
    \                          (number->number (first x))\n                      \
    \               #:negative-number-key \n                                     (number->number\
    \ x)\n                                     #:key (lambda (x)\n               \
    \                              (number->string \n                            \
    \                      (number->number x)))))\n                              \
    \ (lambda (x)\n                                  (number->string\n           \
    \                          (number->number (first x))\n                      \
    \               #:negative-number-key \n                                     (number->number\
    \ x)\n                                     #:key (lambda (x)\n               \
    \                              (number->string \n                            \
    \                      (number->number x)))))\n                              \
    \ (lambda (x)\n                                  (number->string\n           \
    \                          (number->number (first x))\n                      \
    \               #:negative-number-key \n                                     (number->number\
    \ x)\n                                     #:key (lambda (x)\n               \
    \                              (number->string \n                            \
    \                      (number->number x)))))\n                              \
    \ (lambda (x)\n                                  (number->string\n           \
    \                          (number->number (first x))\n                      \
    \               #:negative-number-key \n                                     (number->number\
    \ x)\n                                     #:key (lambda (x)\n               \
    \                              (number->string \n                            \
    \                      (number->number x)))))\n                              \
    \ (lambda (x)\n                                  (number->string\n           \
    \                          (number->number (first x))\n                      \
    \               #:negative-number-key \n                                     (number->number\
    \ x)\n                                     #:key (lambda (x)\n               \
    \                              (number->string \n                            \
    \                      (number->number x)))))\n                              \
    \ (lambda (x)\n                                  (number->string\n           \
    \                          (number->number (first x))\n                      \
    \               #:negative-number-key \n                                     (number->number\
    \ x)\n                                     #:key (lambda (x)\n               \
    \                              (number->string \n                            \
    \                      (number->number x)))))\n                              \
    \ (lambda (x)\n                                  (number->string\n           \
    \                          (number->number (first x))\n                      \
    \               #:negative-number-key \n                                     (number->number\
    \ x)\n                                     #:", "  (cond\n    [(string-empty?\
    \ numbers)\n     '']\n    [(string-contains? \"zero one\"\n                  \
    \     (substring numbers 0 1))\n     (cons numbers (sort_numbers (substring numbers\
    \ (string-length numbers) 2)))]\n    [(string-contains? \"two three\"\n      \
    \                 (substring numbers 0 2))\n     (cons numbers (sort_numbers (substring\
    \ numbers (string->length (substring numbers (string->length (substring numbers\
    \ 0 2)) 1)) 1)))]\n    [(string-contains? \"four five\"\n                    \
    \   (substring numbers 0 3))\n     (cons numbers (sort_numbers (substring numbers\
    \ (string->length (substring numbers (string->length (substring numbers 0 3))\
    \ 2)) 1)))]\n    [(string-contains? \"six seven\"\n                       (substring\
    \ numbers 0 4))\n     (cons numbers (sort_numbers (substring numbers (string->length\
    \ (substring numbers (string->length (substring numbers 0 4)) 3)) 1)))]\n    [(string-contains?\
    \ \"eight nine\"\n                       (substring numbers 0 5))\n     (cons\
    \ numbers (sort_numbers (substring numbers (string->length (substring numbers\
    \ (string->length (substring numbers 0 5)) 4)) 1)))]\n    [else\n     (cons numbers\
    \ (sort_numbers (substring numbers (string->length (substring numbers 0 5)) 5)))]))\n",
  "  (let ((result '()))\n    (loop \n      ((nums numbers)\n       (current (first\
    \ nums))\n       (next (next current))\n       (res (if (< (first nums) (first\
    \ next)) (append (cons (first nums) '()) result) (append result (cons (first next)\
    \ '()))))\n       (next (next next))\n       (res (if (< (first nums) (first next))\
    \ (append (cons (first nums) '()) result) (append result (cons (first next) '()))))\n\
    \       (next (next next))\n       (res (if (< (first nums) (first next)) (append\
    \ (cons (first nums) '()) result) (append result (cons (first next) '()))))\n\
    \       (next (next next))\n       (res (if (< (first nums) (first next)) (append\
    \ (cons (first nums) '()) result) (append result (cons (first next) '()))))\n\
    \       (next (next next))\n       (res (if (< (first nums) (first next)) (append\
    \ (cons (first nums) '()) result) (append result (cons (first next) '()))))\n\
    \       (next (next next))\n       (res (if (< (first nums) (first next)) (append\
    \ (cons (first nums) '()) result) (append result (cons (first next) '()))))\n\
    \       (next (next next))\n       (res (if (< (first nums) (first next)) (append\
    \ (cons (first nums) '()) result) (append result (cons (first next) '()))))\n\
    \       (next (next next))\n       (res (if (< (first nums) (first next)) (append\
    \ (cons (first nums) '()) result) (append result (cons (first next) '()))))\n\
    \       (next (next next))\n       (res (if (< (first nums) (first next)) (append\
    \ (cons (first nums) '()) result) (append result (cons (first next) '()))))\n\
    \       (next (next next))\n       (res (if (< (first nums) (first next)) (append\
    \ (cons (first nums) '()) result) (append result (cons (first next) '()))))\n\
    \       (next (next next))\n       (res (if (< (first nums) (first next)) (append\
    \ (cons (first nums) '()) result) (append result (cons (first next) '()))))\n\
    \       (next (next ", "  (sort_numbers-helper numbers '()))\n", "  (cond [(=\
    \ (string-length numbers) 0)\n         '()]\n        [(or (string=? (first numbers)\
    \ \"zero\")\n             (string=? (first numbers) \"one\"))\n         (sort_numbers\
    \ (rest numbers))]\n        [(string=? (first numbers) \"two\")\n         (cons\
    \ (first numbers) (sort_numbers (rest numbers)))]\n        [(string=? (first numbers)\
    \ \"three\")\n         (cons (first numbers) (sort_numbers (rest numbers)))]\n\
    \        [(string=? (first numbers) \"four\")\n         (cons (first numbers)\
    \ (sort_numbers (rest numbers)))]\n        [(string=? (first numbers) \"five\"\
    )\n         (cons (first numbers) (sort_numbers (rest numbers)))]\n        [(string=?\
    \ (first numbers) \"six\")\n         (cons (first numbers) (sort_numbers (rest\
    \ numbers)))]\n        [(string=? (first numbers) \"seven\")\n         (cons (first\
    \ numbers) (sort_numbers (rest numbers)))]\n        [(string=? (first numbers)\
    \ \"eight\")\n         (cons (first numbers) (sort_numbers (rest numbers)))]\n\
    \        [(string=? (first numbers) \"nine\")\n         (cons (first numbers)\
    \ (sort_numbers (rest numbers)))]\n        [else\n         (cons (first numbers)\n\
    \              (sort_numbers (rest numbers))))))\n", "  (sort_strings numbers\
    \ (reverse string->list numbers)))\n", "  (sort numbers (lambda (x y) (< (char-code\
    \ x) (char-code y))))) ;; #lang racket\n</code>\n<|/ a tags=scheme,racket dscore=0\
    \ |>\n<| a tags=scheme,racket |>\nA generic Scheme solution\n<code>", "  (if (null?\
    \ numbers)\n      '()\n      (let ([current-digit (first numbers)])\n        (sort\
    \ (sort_numbers (rest numbers)) ; Recurse the function on the rest of the list\n\
    \               (lambda (a b) ; Order function for a and b\n                 (cond\n\
    \                  [(< (char-code a) (char-code current-digit)) (- a b)] ; Swap\
    \ a with b if the smaller one comes before the one being compared to\n       \
    \           [(< (char-code b) (char-code current-digit)) (- b a)] ; Swap a with\
    \ b if the smaller one comes before the one being compared to\n              \
    \    [else (compare a b)] ; Otherwise, the smaller one comes before the one being\
    \ compared to\n                 )\n               )\n               )\n      \
    \       )\n        )\n      )\n    )\n\n#lang racket\n", "  (sort numbers\n  \
    \      (lambda (a b)\n          (< (char->integer a) (char->integer b)))))\n",
  "  (cond\n    [(null? numbers)\n     'zero]\n    [(= (length numbers) 1)\n     (sort\
    \ numbers (lambda (x y)\n                     (< x y)))]\n    [else\n     (let\
    \ [number-chars (map char->integer (string->list (string->symbol (first numbers))))]\n\
    \       (map (lambda (x)\n              (cond\n                [(< x (first number-chars))\
    \ (cons x (sort_numbers (rest numbers)))]\n                [else (cons x (sort_numbers\
    \ (rest numbers)))]))\n             number-chars))]))\n", "  (string-sort numbers\
    \ '<))\n", "  (cond\n    [(empty? numbers) '()] \n    [(number? (first numbers))\
    \ (cons (first numbers) (sort_numbers (rest numbers)))]\n    [else (sort_numbers\
    \ (rest numbers))]))\n", "  (cond\n    [(empty? numbers) \"\"]\n    [(string=?\
    \ (first numbers) \"zero\") (sort_numbers (rest numbers))]\n    [(string=? (first\
    \ numbers) \"one\") (sort_numbers (rest numbers))]\n    [(string=? (first numbers)\
    \ \"two\") (sort_numbers (rest numbers))]\n    [(string=? (first numbers) \"three\"\
    ) (sort_numbers (rest numbers))]\n    [(string=? (first numbers) \"four\") (sort_numbers\
    \ (rest numbers))]\n    [(string=? (first numbers) \"five\") (sort_numbers (rest\
    \ numbers))]\n    [(string=? (first numbers) \"six\") (sort_numbers (rest numbers))]\n\
    \    [(string=? (first numbers) \"seven\") (sort_numbers (rest numbers))]\n  \
    \  [(string=? (first numbers) \"eight\") (sort_numbers (rest numbers))]\n    [(string=?\
    \ (first numbers) \"nine\") (sort_numbers (rest numbers))]\n    [else (cons (first\
    \ numbers) (sort_numbers (rest numbers)))]))\n", "  (let ([numbers (map string->number\
    \ numbers)])\n    (sort numbers\n          (lambda (n)\n            (< (cdr n)\
    \ (first numbers))))\n    (apply string->string numbers)))\n", "  (apply string-append\
    \ (map sort (map string-split-on: numbers (string->list \"zero one two three four\
    \ five six seven eight nine\")))))\n", "  (sort numbers\n        #:initial-key\
    \ (lambda (x y)\n                        (cond\n                          ((string=?\
    \ (number->string x) (number->string y)) (number->string x))\n               \
    \           ((string=? (number->string x) (number->string y)) (number->string\
    \ y))\n                          ((string=? (number->string x) (number->string\
    \ y)) (string->number (number->string y)))\n                          (else 'invalid)))))\n",
  "  (if (null? numbers)\n      '()\n      (let ((numbers-list (string->list (string->space-delimited\n\
    \                                          (trim-whitespace\n                \
    \                           (replace-string \" \" \"+\" numbers))))))\n      \
    \  (let ((numbers-ordered (sort numbers-list <)))\n          (cons (substring\
    \ numbers-ordered 0 1)\n                (sort_numbers (substring numbers-ordered\
    \ 1 length)))))))\n", "  (cond\n    [(empty? numbers) \"\"]\n    [(equal? (first\
    \ numbers) \"zero\") \"zero\"]\n    [(equal? (first numbers) \"one\") \"one\"\
    ]\n    [(equal? (first numbers) \"two\") \"two\"]\n    [(equal? (first numbers)\
    \ \"three\") \"three\"]\n    [(equal? (first numbers) \"four\") \"four\"]\n  \
    \  [(equal? (first numbers) \"five\") \"five\"]\n    [(equal? (first numbers)\
    \ \"six\") \"six\"]\n    [(equal? (first numbers) \"seven\") \"seven\"]\n    [(equal?\
    \ (first numbers) \"eight\") \"eight\"]\n    [(equal? (first numbers) \"nine\"\
    ) \"nine\"]\n    [else (cons (first numbers) (sort_numbers (rest numbers)))]))\n",
  "  (cond\n    [(string-equal? numbers \"\") \"\"]\n    [(string-equal? numbers #\\\
    newline) \"\"]\n    [(string-equal? (string-ref numbers 0) #\\newline) numbers]\n\
    \    [else (string-append\n             (sort_numbers (substring numbers 1 string-length\
    \ (string-ref numbers 0)))\n             #\\space (sort_numbers (substring numbers\
    \ 0 string-length (string-ref numbers 0)))\n             #\\newline (substring\
    \ numbers 1 string-length (string-ref numbers 0)))]))\n", "  (if (null? numbers)\
    \ '()\n      (append (list (first numbers))\n               (sort_numbers (rest\
    \ numbers)))))\n", "  (let ((num-str numbers))\n    (cond\n      [(empty? num-str)\
    \ 'empty]\n      [(equal? (first num-str) 'zero) (sort_numbers (rest num-str))]\n\
    \      [(equal? (first num-str) 'one) (sort_numbers (rest num-str))]\n      [(equal?\
    \ (first num-str) 'two) (sort_numbers (rest num-str))]\n      [(equal? (first\
    \ num-str) 'three) (sort_numbers (rest num-str))]\n      [(equal? (first num-str)\
    \ 'four) (sort_numbers (rest num-str))]\n      [(equal? (first num-str) 'five)\
    \ (sort_numbers (rest num-str))]\n      [(equal? (first num-str) 'six) (sort_numbers\
    \ (rest num-str))]\n      [(equal? (first num-str) 'seven) (sort_numbers (rest\
    \ num-str))]\n      [(equal? (first num-str) 'eight) (sort_numbers (rest num-str))]\n\
    \      [(equal? (first num-str) 'nine) (sort_numbers (rest num-str))]\n      [else\n\
    \       (append (sort_numbers (rest num-str))\n              (concat num-str '(one\
    \ two))\n              (concat num-str '(three four))\n              (concat num-str\
    \ '(five six))\n              (concat num-str '(seven eight))\n              (concat\
    \ num-str '(nine zero)))]\n    )\n  )\n)\n", "  (cond\n    [(empty? numbers) numbers]\n\
    \    [else (append (append (sort_numbers (first numbers))\n                  \
    \        (cons (first numbers)\n                                (sort_numbers\
    \ (rest numbers)))))]))\n", "  (sort (map number->string (string->list numbers))))\n",
  "  (cond [(empty? numbers)\n         'zero]\n        [(member (first numbers) '(zero\
    \ one two three four five six seven eight nine))\n         #t]\n        [else\n\
    \         (let [[smallest (sort_numbers (rest numbers))]\n               [largest\
    \ (sort_numbers (rest numbers))]]\n           (cond (smallest\n              \
    \    (cons smallest numbers))\n                 (largest\n                  (cons\
    \ largest numbers))\n                 (else\n                  (append (cons smallest\
    \ numbers)\n                          (cons (first numbers) largest)))))))])\n",
  "  (if (or (empty? numbers)\n          (empty? (rest numbers)))\n      '()\n   \
    \   (append (sort_numbers (rest numbers))\n              (list (first numbers)))))\n",
  "  (cond ((empty? numbers)\n         numbers)\n        ((>= (first numbers) (first\
    \ 'one))\n         (sort_numbers (rest numbers))\n         (append (first 'one)\
    \ (rest numbers))\n         (sort_numbers (rest 'one)))\n        ((>= (first numbers)\
    \ (first 'two))\n         (sort_numbers (rest numbers))\n         (append (first\
    \ 'two) (rest numbers))\n         (sort_numbers (rest 'two)))\n        ((>= (first\
    \ numbers) (first 'three))\n         (sort_numbers (rest numbers))\n         (append\
    \ (first 'three) (rest numbers))\n         (sort_numbers (rest 'three)))\n   \
    \     ((>= (first numbers) (first 'four))\n         (sort_numbers (rest numbers))\n\
    \         (append (first 'four) (rest numbers))\n         (sort_numbers (rest\
    \ 'four)))\n        ((>= (first numbers) (first 'five))\n         (sort_numbers\
    \ (rest numbers))\n         (append (first 'five) (rest numbers))\n         (sort_numbers\
    \ (rest 'five)))\n        ((>= (first numbers) (first 'six))\n         (sort_numbers\
    \ (rest numbers))\n         (append (first 'six) (rest numbers))\n         (sort_numbers\
    \ (rest 'six)))\n        ((>= (first numbers) (first 'seven))\n         (sort_numbers\
    \ (rest numbers))\n         (append (first 'seven) (rest numbers))\n         (sort_numbers\
    \ (rest 'seven)))\n        ((>= (first numbers) (first 'eight))\n         (sort_numbers\
    \ (rest numbers))\n         (append (first 'eight) (rest numbers))\n         (sort_numbers\
    \ (rest 'eight)))\n        ((>= (first numbers) (first 'nine))\n         (sort_numbers\
    \ (rest numbers))\n         (append (first 'nine) (rest numbers))\n         (sort_numbers\
    \ (rest 'nine))))\n</code>\n<|/ a dscore=2 tags=racket,scheme |>\n<| c |>\nWhile\
    \ I like's answer I wanted to share my solution for the problem. I think it has\
    \ the best readability and is easy to understand. :)\n<|/ c |>\n<| c |>\nSure,\
    \ but why don't you write it up and accept your own answer?\n<|/ c |>\n<| c |>\n\
    Just did. Sorry about that guys, was thinking of a different problem at hand.\n\
    <|/ c |>\n<| a dscore", "  (cond [(null? numbers) 'empty]\n        [(numbers-in-order?\
    \ numbers) numbers]\n        [else 'empty]))\n", "  (if (null? numbers)\n    \
    \  numbers\n      (append (sort-numbers numbers (substring numbers 0 1))\n   \
    \           (append (split-string (substring numbers 2) #\\Space) #(#\\Space))\n\
    \              (sort-numbers numbers (substring numbers 3)))))\n", "  (let ([sorted\
    \ (sort (numbers-to-list numbers) (lambda (n) (< *n* 9))))]\n    (displayln sorted)\n\
    \    (if (null? sorted)\n        '(numbers)\n        (reverse sorted))))\n", " \
    \ (if (string-empty? numbers)\n      '()\n      (append (sort-numbers-helper numbers\
    \ #:ascending '())\n              (sort-numbers-helper numbers #:descending '()))))\n",
  "  (cond\n    [(empty? numbers) \"\"]\n    [(equal? (first numbers) 'zero) (sort_numbers\
    \ (rest numbers))]\n    [(equal? (first numbers) 'one) (sort_numbers (rest numbers))]\n\
    \    [(equal? (first numbers) 'two) (sort_numbers (rest numbers))]\n    [(equal?\
    \ (first numbers) 'three) (sort_numbers (rest numbers))]\n    [(equal? (first\
    \ numbers) 'four) (sort_numbers (rest numbers))]\n    [(equal? (first numbers)\
    \ 'five) (sort_numbers (rest numbers))]\n    [(equal? (first numbers) 'six) (sort_numbers\
    \ (rest numbers))]\n    [(equal? (first numbers) 'seven) (sort_numbers (rest numbers))]\n\
    \    [(equal? (first numbers) 'eight) (sort_numbers (rest numbers))]\n    [(equal?\
    \ (first numbers) 'nine) (sort_numbers (rest numbers))]\n    [else\n     (cons\
    \ (first numbers)\n           (sort_numbers (rest (rest numbers))))]\n    )\n\
    \  )\n)\n</code>\n<|/ a tags=scheme,racket dscore=2 |>\n<| a dscore=2 tags=scheme,racket\
    \ |>\nHere is a simpler implementation in Scheme:\n<code>", "  (cond\n    [(empty?\
    \ numbers) \"zero\"]\n    [(member \"one\" numbers)\n     (cons (car numbers)\
    \ (sort_numbers (cdr numbers)))]\n    [(member \"two\" numbers)\n     (cons (car\
    \ numbers) (sort_numbers (cdr numbers)))]\n    [(member \"three\" numbers)\n \
    \    (cons (car numbers) (sort_numbers (cdr numbers)))]\n    [(member \"four\"\
    \ numbers)\n     (cons (car numbers) (sort_numbers (cdr numbers)))]\n    [(member\
    \ \"five\" numbers)\n     (cons (car numbers) (sort_numbers (cdr numbers)))]\n\
    \    [(member \"six\" numbers)\n     (cons (car numbers) (sort_numbers (cdr numbers)))]\n\
    \    [(member \"seven\" numbers)\n     (cons (car numbers) (sort_numbers (cdr\
    \ numbers)))]\n    [(member \"eight\" numbers)\n     (cons (car numbers) (sort_numbers\
    \ (cdr numbers)))]\n    [(member \"nine\" numbers)\n     (cons (car numbers) (sort_numbers\
    \ (cdr numbers)))]\n    [else (cons (car numbers) (sort_numbers (cdr numbers)))]))\n",
  "  (sort_string\n   (string->number\n    (sort \n      (map \n       string->number\n\
    \       numbers)\n     '<)))\n", "  (cond [(empty? numbers) \"\"]\n        [(equal?\
    \ (first numbers) \"zero\") \"zero\"]\n        [(equal? (first numbers) \"one\"\
    ) \"one\"]\n        [(equal? (first numbers) \"two\") \"two\"]\n        [(equal?\
    \ (first numbers) \"three\") \"three\"]\n        [(equal? (first numbers) \"four\"\
    ) \"four\"]\n        [(equal? (first numbers) \"five\") \"five\"]\n        [(equal?\
    \ (first numbers) \"six\") \"six\"]\n        [(equal? (first numbers) \"seven\"\
    ) \"seven\"]\n        [(equal? (first numbers) \"eight\") \"eight\"]\n       \
    \ [(equal? (first numbers) \"nine\") \"nine\"]\n        [else (append (sort_numbers\
    \ (cdr numbers)) (sort_numbers (cons (first numbers) (cdr (rest numbers)))))]))\n",
  "  (let loop ((numbers (string->list numbers))\n             (n (length numbers))\n\
    \             (result '()))\n    (cond\n      [(= n 0) result]\n      [(< (car\
    \ numbers) (cadr numbers)) (loop (cdr numbers) (- n 1) (cons (car numbers) result))]\n\
    \      [(> n (cadr numbers)) (loop (cdr numbers) n (cons (car numbers) result))]\n\
    \      [else (loop (cdr numbers) n (cons (car numbers) result))]))\n  (string->list\
    \ result))\n</code>\n<|/ a tags=scheme,racket,lisp |>\n<| c |>\nThanks for this\
    \ answer but I need it in Scheme. Is it possible to make it in Scheme? I thought\
    \ it would be easier because it's more like Lisp than Scheme\n<|/ c |>\n<| a tags=scheme,racket,lisp\
    \ dscore=0 |>\nYou cannot use string-set! since it would cause a stack overflow.\n\
    One way to solve this problem is by changing the function so that it returns '#t\
    \ or #f instead of strings. Then you can apply the procedure to each of the numbers,\
    \ checking if the result is #t or not.\n<code>", "  (let ((sl '()))\n    (for-each\
    \ (lambda (n)\n                 (if (number? n)\n                     (begin\n\
    \                       (set! sl (cons n sl))\n                       (reverse\
    \ sl))\n                     (reverse sl))\n               numbers)\n        \
    \       sl))\n", "  ;; Using a list is a simple way to sort a list of things\n\
    \  ;; but we can use sort-by if we want to\n  (sort-by compare (reverse (split\
    \ numbers \" \"))))\n", "  (if (string=? numbers \"zero\")\n      \"zero\"\n \
    \     (if (string=? numbers \"one\")\n          \"one\"\n          (if (string=?\
    \ numbers \"two\")\n              \"two\"\n              (if (string=? numbers\
    \ \"three\")\n                  \"three\"\n                  (if (string=? numbers\
    \ \"four\")\n                      \"four\"\n                      (if (string=?\
    \ numbers \"five\")\n                          \"five\"\n                    \
    \      (if (string=? numbers \"six\")\n                              \"six\"\n\
    \                              (if (string=? numbers \"seven\")\n            \
    \                      \"seven\"\n                                  (if (string=?\
    \ numbers \"eight\")\n                                      \"eight\"\n      \
    \                                (if (string=? numbers \"nine\")\n           \
    \                               \"nine\"\n                                   \
    \       (if (string=? numbers \"ten\")\n                                     \
    \         \"ten\"\n                                              (if (string=?\
    \ numbers \"eleven\")\n                                                  \"eleven\"\
    \n                                                  (if (string=? numbers \"twelve\"\
    )\n                                                      \"twelve\"\n        \
    \                                              (if (string=? numbers \"thirteen\"\
    )\n                                                          (if (string=? numbers\
    \ \"fourteen\")\n                                                            \
    \  \"fourteen\"\n                                                            \
    \  (if (string=? numbers \"fifteen\")\n                                      \
    \                            \"fifteen\"\n                                   \
    \                               (if (string=? numbers \"sixteen\")\n         \
    \                                                                \"sixteen\"\n\
    \                                                                        (if (string=?\
    \ numbers \"seventeen\")\n                                                   \
    \                         \"seventeen\"\n                                    \
    \                                        (if (string=? numbers \"eighteen\")\n\
    \                                                                            \
    \    \"eighteen\"\n                                                          \
    \                      (if (string=? numbers \"nineteen\")\n                 \
    \                                                                   \"nineteen\"\
    \n                                                                           \
    \         (if (string=? numbers \"twenty\")\n                                \
    \                                                        \"twenty\"\n        \
    \                                                                            \
    \    (if (string=? numbers \"thirty\")\n                                     \
    \                                                       \"thirty\"\n         \
    \                                                                            \
    \       (if (string=? numbers \"forty\")\n                                   \
    \                                                             \"forty\"\n    \
    \                                                                            \
    \                (if (string=? numbers \"fifty\")\n                          \
    \                                                                          \"\
    fifty\"\n                                                                    \
    \                                (if (string=? numbers \"sixty\")\n          \
    \                                                                            \
    \                  \"sixty\"\n                                               \
    \                                                         (if (string=? numbers\
    \ \"seventy\")\n                                                             \
    \                                               \"seventy\"\n                \
    \                                                                            \
    \                (if (string=? numbers \"eighty\")\n                         \
    \                                                                            \
    \           \"eighty\"\n                                                     \
    \                                                           (if (string=? numbers\
    \ \"ninety\")\n                                                              \
    \                                                      \"ninety\"\n          \
    \                                                                            \
    \                              (if (string=? numbers \"hundred\")\n          \
    \                                                                            \
    \                                  \"hund", "  (let ([num (string->list numbers)])\n\
    \    (sort num <)\n    (list->string num)))\n", "  (if (empty? numbers) '()\n\
    \    (let ([n (read)]\n          [small-num (first numbers)]\n          [big-num\
    \ (rest numbers)])\n      (cond [(< n big-num) (cons small-num big-num)]\n   \
    \         [else (cons small-num (sort_numbers big-num))]))))\n", "  (let ([nums\
    \ (map string->number numbers)\n         num-index (reverse (remove-if (complement\
    \ number?) nums))]\n        (result (make-array (length nums) string)))\n    (do\
    \ ([i (in-range (length nums))\n           j (in-range (length nums))]\n     \
    \   ([i (+ i 1)]\n         ([j 0]\n          (when (> (list-ref num-index i) list-ref\
    \ num-index j)\n            (set! i (+ i 1)))\n          (set! j (+ j 1))))\n\
    \        ((< i j)\n         (set! i (list-ref num-index i)))\n      (set! result\
    \ (set! result (concatenate 'string\n                                        \
    \  (substring result 0 (+ i 1) result)\n                                     \
    \     (substring result (+ i 1) (+ j 1) result))))\n    result))\n", "  (cond\
    \ ((null? numbers) '())\n        ((string=? (numbers) \"zero\") '())\n       \
    \ ((string=? (numbers) \"one\") '(\"one\"))\n        ((string=? (numbers) \"two\"\
    ) '(\"two\"))\n        ((string=? (numbers) \"three\") '(\"three\"))\n       \
    \ ((string=? (numbers) \"four\") '(\"four\"))\n        ((string=? (numbers) \"\
    five\") '(\"five\"))\n        ((string=? (numbers) \"six\") '(\"six\"))\n    \
    \    ((string=? (numbers) \"seven\") '(\"seven\"))\n        ((string=? (numbers)\
    \ \"eight\") '(\"eight\"))\n        ((string=? (numbers) \"nine\") '(\"nine\"\
    ))\n        (else (append (sort_numbers (substring numbers (length (string=? (numbers)\
    \ \"one\")) length (string=? (numbers) \"nine\")))\n                   (cond ((string=?\
    \ (numbers) \"one\") '())\n                        ((string=? (numbers) \"two\"\
    ) '(\"two\"))\n                        ((string=? (numbers) \"three\") '(\"three\"\
    ))\n                        ((string=? (numbers) \"four\") '(\"four\"))\n    \
    \                    ((string=? (numbers) \"five\") '(\"five\"))\n           \
    \             ((string=? (numbers) \"six\") '(\"six\"))\n                    \
    \    ((string=? (numbers) \"seven\") '(\"seven\"))\n                        ((string=?\
    \ (numbers) \"eight\") '(\"eight\"))\n                        ((string=? (numbers)\
    \ \"nine\") '(\"nine\"))))))))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
