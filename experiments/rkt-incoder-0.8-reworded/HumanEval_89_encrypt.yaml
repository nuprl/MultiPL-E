name: HumanEval_89_encrypt
language: rkt
prompt: "#lang racket\n\n;; Create a function encrypt that takes a string as an argument\
  \ and\n;; returns a string encrypted with the alphabet being rotated. \n;; The alphabet\
  \ should be rotated in a manner such that the letters \n;; shift down by two multiplied\
  \ to two places.\n;; For example:\n;; >>> (encrypt \"hi\")\n;; \"lm\"\n;; >>> (encrypt\
  \ \"asdfghjkl\")\n;; \"ewhjklnop\"\n;; >>> (encrypt \"gf\")\n;; \"kj\"\n;; >>> (encrypt\
  \ \"et\")\n;; \"ix\"\n(define (encrypt s)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate encrypt))\n\
  \    (check-equal? (candidate \"hi\") \"lm\")\n    (check-equal? (candidate \"asdfghjkl\"\
  ) \"ewhjklnop\")\n    (check-equal? (candidate \"gf\") \"kj\")\n    (check-equal?\
  \ (candidate \"et\") \"ix\")\n    (check-equal? (candidate \"faewfawefaewg\") \"\
  jeiajeaijeiak\")\n    (check-equal? (candidate \"hellomyfriend\") \"lippsqcjvmirh\"\
  )\n    (check-equal? (candidate \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
  ) \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\n    (check-equal? (candidate\
  \ \"a\") \"e\")\n))\n\n(test-humaneval)"
completions: ["  (let ((alphabet (gen-alphabet)))\n    (loop for i from 0 to (length\
    \ s) do (rotate-letters alphabet i (length alphabet))) \n    (append (rotate-letters\
    \ alphabet 0 (length alphabet))\n            (map char->symbol s))))\n", "  (let*\
    \ ((alpha (char->string\n                  (list\n                    (list-ref\
    \ '(a b c d e f g h i j k l m n o p q r s t u v w x y z) 2)\n                \
    \    (list-ref '(a b c d e f g h i j k l m n o p q r s t u v w x y z) 3)\n   \
    \                 (list-ref '(a b c d e f g h i j k l m n o p q r s t u v w x\
    \ y z) 4)\n                    (list-ref '(a b c d e f g h i j k l m n o p q r\
    \ s t u v w x y z) 5)\n                    (list-ref '(a b c d e f g h i j k l\
    \ m n o p q r s t u v w x y z) 6)\n                    (list-ref '(a b c d e f\
    \ g h i j k l m n o p q r s t u v w x y z) 7)\n                    (list-ref '(a\
    \ b c d e f g h i j k l m n o p q r s t u v w x y z) 8)\n                    (list-ref\
    \ '(a b c d e f g h i j k l m n o p q r s t u v w x y z) 9)\n                \
    \    (list-ref '(a b c d e f g h i j k l m n o p q r s t u v w x y z) 10)\n  \
    \                  (list-ref '(a b c d e f g h i j k l m n o p q r s t u v w x\
    \ y z) 11)\n                    (list-ref '(a b c d e f g h i j k l m n o p q\
    \ r s t u v w x y z) 12)\n                    (list-ref '(a b c d e f g h i j\
    \ k l m n o p q r s t u v w x y z) 13)\n                    (list-ref '(a b c\
    \ d e f g h i j k l m n o p q r s t u v w x y z) 14)\n                    (list-ref\
    \ '(a b c d e f g h i j k l m n o p q r s t u v w x y z) 15)\n               \
    \     (list-ref '(a b c d e f g h i j k l m n o p q ", "  (let ((alphabet \"abcdefghijklmnopqrstuvwxyz\"\
    ))\n    (loop ((letter letter) (i 0))\n      (if (or (not (eq? letter \"\")) (even?\
    \ (string->number letter))) (cons letter alphabet)\n        (cons (string->number\
    \ (substring alphabet (+ i 1) (- i 1))) alphabet)))))\n", "  (let* ((m (make-map\
    \ #:lower-case #:uppercase))\n         (f (lambda (x y) (rotate m x y)))))\n \
    \   (map (f s '#?_) (alphabet)))))\n", "  (cond [(string=? \"a\" s)\n        \
    \ (cons \"\" (encrypt (substring s \"a\" 1)))]\n        [(string=? \"b\" s)\n\
    \         (cons \"\" (encrypt (substring s \"b\" 1)))]\n        [(string=? \"\
    c\" s)\n         (cons \"\" (encrypt (substring s \"c\" 1)))]\n        [(string=?\
    \ \"d\" s)\n         (cons \"\" (encrypt (substring s \"d\" 1)))]\n        [(string=?\
    \ \"e\" s)\n         (cons \"\" (encrypt (substring s \"e\" 1)))]\n        [(string=?\
    \ \"f\" s)\n         (cons \"\" (encrypt (substring s \"f\" 1)))]\n        [(string=?\
    \ \"g\" s)\n         (cons \"\" (encrypt (substring s \"g\" 1)))]\n        [(string=?\
    \ \"h\" s)\n         (cons \"\" (encrypt (substring s \"h\" 1)))]\n        [(string=?\
    \ \"i\" s)\n         (cons \"\" (encrypt (substring s \"i\" 1)))]\n        [(string=?\
    \ \"j\" s)\n         (cons \"\" (encrypt (substring s \"j\" 1)))]\n        [(string=?\
    \ \"k\" s)\n         (cons \"\" (encrypt (substring s \"k\" 1)))]\n        [(string=?\
    \ \"l\" s)\n         (cons \"\" (encrypt (substring s \"l\" 1)))]\n        [(string=?\
    \ \"m\" s)\n         (cons \"\" (encrypt (substring s \"m\" 1)))]\n        [(string=?\
    \ \"n\" s)\n         (cons \"\" (encrypt (substring s \"n\" 1)))]\n        [(string=?\
    \ \"o\" s)\n         (cons \"\" (encrypt (substring s \"o\" 1)))]\n        [(string=?\
    \ \"p\" s)\n         (cons \"\" (encrypt (substring s \"p\" 1)))]\n        [(string=?\
    \ \"q\" s)\n         (cons \"\" (encrypt (substring s \"q\" 1)))]\n        [(string=?\
    \ \"r\" s)\n         (cons \"\" (encrypt (substring s \"r\" 1)))]\n        [(string=?\
    \ \"s\" s)\n         (cons \"\" (encrypt (substring s \"s\" 1)))]\n        [(string=?\
    \ \"t\" s)\n         (cons \"\" (encrypt (substring s \"t\" 1)))]\n        [(string=?\
    \ \"u\" s)\n         (cons \"\" (encrypt (substring s \"u\" 1)))]\n        [(string=?\
    \ \"v\" s)", "  (cond\n    [(empty? s) \"\"]\n    [else (let [curr (first s)]\n\
    \             (cond\n              [(char-alphabet curr) \n               (append\
    \ (map (lambda (c1) (cons (char-alphabet (cdr curr)) (cdr curr))\n           \
    \                 (encrypt (rest s))))\n                      (map char-alphabet\n\
    \                           (reverse (cons (char-alphabet (car curr)) (encrypt\
    \ (rest s)))))]\n              [else (cons (char-alphabet curr)\n            \
    \            (encrypt (rest s))))])))]))\n", "  (let loop ([i 0] [result \"\"\
    ])\n    (if (empty? s)\n        (list result)\n        (loop (add1 i)\n      \
    \        (+ result (list-ref alphabet-list i))))))\n", "  (let ((alphabet  '(\"\
    a\". \"b\". \"c\". \"d\". \"e\". \"f\". \"g\". \"h\". \"i\". \"j\". \"k\". \"\
    l\". \"m\". \"n\". \"o\". \"p\". \"q\". \"r\". \"s\". \"t\". \"u\". \"v\". \"\
    w\". \"x\". \"y\". \"z\"))\n        (len (length alphabet))\n        (rota (aref\
    \ alphabet 1))\n        (shift (- len 2)))\n    (cond\n      [(empty? s) (empty?\
    \ rota rota rota rota rota rota rota rota rota rota rota rota rota rota rota rota\
    \ rota rota rota rota rota rota rota rota rota rota rota rota rota rota rota rota\
    \ rota rota rota rota rota rota rota rota rota rota rota rota rota rota rota rota\
    \ rota rota rota rota rota rota rota rota rota rota rota rota rota rota rota rota\
    \ rota rota rota rota rota rota rota rota rota rota rota rota rota rota rota rota\
    \ rota rota rota rota rota rota rota rota rota rota rota rota rota rota rota rota\
    \ rota rota rota rota rota rota rota rota rota rota rota rota rota rota rota rota\
    \ rota rota rota rota rota rota rota rota rota rota rota rota rota rota rota rota\
    \ rota rota rota rota rota rota rota rota rota rota rota rota rota rota rota rota\
    \ rota rota rota rota rota rota rota rota rota rota rota rota rota rota rota rota\
    \ rota rota rota rota rota rota rota rota rota rota rota rota rota rota rota rota\
    \ rota rota rota rota rota rota rota rota rota rota rota rota rota rota rota rota\
    \ rota rota rota rota rota rota rota rota rota rota rot", "  (string-append (rotate-string\
    \ s 2)\n                 (rotate-string s 4)))\n", "  (let ((alpha (char->string\
    \ \"abcdefghijklmnopqrstuvwxyz\")))\n    (string->char (rotate alpha (string->char\
    \ s)))))\n", "  (let ([t (char s)\n         (a (rot-array (char #\\a) (char->int\
    \ (char->string t) 2))\n         (b (rot-array (char #\\b) (char->int (char->string\
    \ t) 1))\n         (c (rot-array (char #\\c) (char->int (char->string t) 0))]\n\
    \         ;; a b c are each a character in the alphabet\n         (newS (make-string\
    \ (str c) (char->int (char->string t) 0)))\n         (newT (make-string (str c)\
    \ (char->int (char->string t) 1)))]\n    (do ([i 0 (+ i 1) newS newT]\n      \
    \   ;; iterate through all characters in s\n         ;; and rotate the corresponding\
    \ character in t and \n         ;; insert newT's character at the correct index\
    \ \n         ;; of newS\n         ;; rotate to go from s -> a b c -> a b c ->\
    \ s\n         (when (<= i str-length t)\n           (set! t (substring t i (+\
    \ i 1)))\n           (set! newT (substring newT i (+ i 1)))\n           (set!\
    \ newS (substring newS i (+ i 1))))\n         newS))\n    (set! newS (string newT)))\n",
  "  (cond [(string-length s <> 0)\n         (string-append (list (first s)\n    \
    \                            (second s)\n                                (third\
    \ s)\n                                (fourth s)\n                           \
    \     (fifth s)\n                                (sixth s)\n                 \
    \               (seventh s)\n                                (eigth s)\n     \
    \                           (ninth s)\n                                (tenth\
    \ s)\n                                (eleventh s)\n                         \
    \       (twelfth s)\n                                (thirteenth s)\n        \
    \                        (fourteenth s)\n                                (fifteenth\
    \ s)\n                                (sixteenth s)\n                        \
    \        (seventeenth s)\n                                (eighteenth s)\n   \
    \                             (nineteenth s)\n                               \
    \ (twentieth s)\n                                (twenty-first s)\n          \
    \                      (twenty-second s)\n                                (twenty-third\
    \ s)\n                                (twenty-fourth s)\n                    \
    \            (twenty-five s)\n                                (twenty-six s)\n\
    \                                (twenty-seven s)\n                          \
    \      (twenty-eight s)\n                                (twenty-nine s)\n   \
    \                             (thirtieth s)\n                                (thirty-first\
    \ s)\n                                (thirty-second s)\n                    \
    \            (thirty-third s)\n                                (thirty-fourth\
    \ s)\n                                (thirty-five s)\n                      \
    \          (thirty-six s)\n                                (thirty-seven s)\n\
    \                                (thirty-eight s)\n                          \
    \      (thirty-nine s)\n                                (fourtieth s)\n      \
    \                          (fourty-first s)\n                                (fourty-second\
    \ s)\n                                (fourty-third s)\n                     \
    \           (fourty-fourth s)\n                                (fourty-five s)\n\
    \                                (fourty-six s)\n                            \
    \    (fourty-seven s)\n                                (fourty-eight s)\n    \
    \                            (fourty-nine s)\n                               \
    \ (fiftieth s)\n                                (fifty-first s)\n            \
    \                    (fifty-second s)\n                                (fifty-third\
    \ s)\n                                (fifty-fourth s)\n                     \
    \           (fifty-five s)\n                                (fifty-six s)\n  \
    \                              (fifty-seven s)\n                             \
    \   (fifty-eight s)\n                                (fifty-nine s)\n        \
    \                        (sixtieth s)\n                                (sixty-first\
    \ s)\n                                (sixty-second s)\n                     \
    \           (sixty-third s)\n                                (sixty-fourth s)\n\
    \                                ", "  (let ((alphabet (make-array (length s)\
    \ (lambda (i j) (alphabet-ref alphabet i (- j 2))))))\n    (do ((i 0 (+ i 1))\n\
    \         (j (+ j 1)))\n        ((< i length) (set! alphabet (rotate-array alphabet\
    \ (- i 1) (- j 1))))\n        (set! alphabet-ref (subscript alphabet i j) (char->integer\
    \ (char->string (car s))))\n        (set! s (cadr s)))))\n", "  (let loop ((s\
    \ s)\n             (enc '(z x w v u t s r q a o p d f g h j k l m n o p q r s\
    \ t u v w x y z)))\n    (cond [(empty? s) (list)] \n          [(equal? (char (first\
    \ s)) ?z) (loop (rest s) (conj enc ?z))] \n          [(equal? (char (first s))\
    \ ?x) (loop (rest s) (conj enc ?x))] \n          [(equal? (char (first s)) ?w)\
    \ (loop (rest s) (conj enc ?w))] \n          [(equal? (char (first s)) ?v) (loop\
    \ (rest s) (conj enc ?v))] \n          [(equal? (char (first s)) ?u) (loop (rest\
    \ s) (conj enc ?u))] \n          [(equal? (char (first s)) ?t) (loop (rest s)\
    \ (conj enc ?t))] \n          [(equal? (char (first s)) ?s) (loop (rest s) (conj\
    \ enc ?s))] \n          [(equal? (char (first s)) ?r) (loop (rest s) (conj enc\
    \ ?r))] \n          [(equal? (char (first s)) ?q) (loop (rest s) (conj enc ?q))]\
    \ \n          [(equal? (char (first s)) ?a) (loop (rest s) (conj enc ?a))] \n\
    \          [(equal? (char (first s)) ?o) (loop (rest s) (conj enc ?o))] \n   \
    \       [(equal? (char (first s)) ?p) (loop (rest s) (conj enc ?p))] \n      \
    \    [(equal? (char (first s)) ?d) (loop (rest s) (conj enc ?d))] \n         \
    \ [(equal? (char (first s)) ?f) (loop (rest s) (conj enc ?f))] \n          [(equal?\
    \ (char (first s)) ?g) (loop (rest s) (conj enc ?g))] \n          [(equal? (char\
    \ (first s)) ?h) (loop (rest s) (conj enc ?h))] \n          [(equal? (char (first\
    \ s)) ?j) (loop (rest s) (conj enc ?j))] \n          [(equal? (char (first s))\
    \ ?k) (loop (rest s) (conj ", "  (let* ((a (string->list s))\n         (b (copy-rotated-alphabet\
    \ a))\n         (c (copy-rotated-alphabet (rotate-alphabet b 'up)))\n        \
    \ (d (copy-rotated-alphabet (rotate-alphabet c (- 'a 1)))\n         ;; \"a\" ->\
    \ \"b\"\n         (e (copy-rotated-alphabet (rotate-alphabet d 'up)))\n      \
    \   ;; \"b\" -> \"c\"\n         (f (copy-rotated-alphabet (rotate-alphabet e 'up)))\n\
    \         ;; \"c\" -> \"d\"\n         (g (copy-rotated-alphabet (rotate-alphabet\
    \ (rotate-alphabet d 'up) 'up)))\n         ;; \"d\" -> \"e\"\n         (h (copy-rotated-alphabet\
    \ (rotate-alphabet (rotate-alphabet e 'up) 'up))))\n    (concat a b) \n    ))\n",
  "  (let loop ((s (string->list s))\n             (result (list->string s)))\n  \
    \  (cond\n      [(empty? s) result]\n      [(char-before? (first s) 'e) (loop\
    \ (rest s) (append result (list (first s))))]\n      [(char-before? (first s)\
    \ 'o) (loop (rest s) (append result (list (second s))))]\n      [(char-before?\
    \ (first s) 'w) (loop (rest s) (append result (list (third s))))]\n      [(char-before?\
    \ (first s) 'h) (loop (rest s) (append result (list (first s))))]\n      [(char-before?\
    \ (first s) 'j) (loop (rest s) (append result (list (second s))))]\n      [(char-before?\
    \ (first s) 'k) (loop (rest s) (append result (list (third s))))]\n      [(char-before?\
    \ (first s) 'l) (loop (rest s) (append result (list (first s))))]\n      [else\
    \ (loop (rest s) (append result (list (first s))))])))\n  (string->list result))\n",
  "  (define (alphabet s index)\n    (cond ((null? s) (list 'a))\n          ((eqv?\
    \ (char (car s)) (car (substring s '(cons-string index index))))\n           (append\
    \ (list (char (substring s '(cons-string index index))))\n                  (alphabet\
    \ s (+ index 1)))\n           (else (alphabet s (+ index 1)))))\n  (append (alphabet\
    \ s '(0))\n          (map \n             (lambda (a i)\n               (let ((letter\
    \ (substring s '(cons-string index i))))\n                 (cond ((char (substring\
    \ s '(cons-string index i))) a)\n                       (else (cond ((char (substring\
    \ s '(cons-string index i)))\n                                    (cons letter\
    \ a))\n                                 (else (append a letter))))))\n       \
    \      (alphabet\n               (list '())\n               (substring s '(cons-string\
    \ 0 (length s))))))) ; Index = 0\n", "  (string->list (loop (lambda (c a)\n  \
    \                    (cond [(char=? (char->integer c) a)\n                   \
    \          #\\space]\n                             [else\n                   \
    \           (cons (char->integer c) \n                                 (string->list\
    \ (rotate-chars \n                                                    (rotate-chars\
    \ \n                                                     a\n                 \
    \                                    c)\n                                    \
    \                 (string->list a))))])\n                     #\\a\n         \
    \            #\\z)))\n", "  (char-rot2 s)\n)\n", "  (cond [(empty? s) \"\"]\n\
    \        [else (add-to-end (rotate-char (first s)) s)]))\n", "  (cond [(string=?\
    \ (string-length s) 0)\n         (string-append (encrypt \"\") (string-append\
    \ s \"a\"))]\n        [else\n         (string-append (encrypt (rotate-letter s\
    \ 0))\n                      (string-append s \n                             \
    \       (rotate-letter s 1))]))\n", "  (let loop ((a #\\A) (s s)\n           \
    \  (r #\\B) (result '()))\n    (cond\n      [(null? s) (append result (list #\\\
    Z))]\n      [(equal? (car s) #\\Z) (loop a (cdr s) r)]\n      [(char< (car s)\
    \ a) \n       (loop (char-before (car s) a) (cdr s) r)]\n      [else \n      \
    \ (loop (char-before (car s) a) (cdr s) (append r (list (car s))))]))))\n", " \
    \ (let loop ((s s)\n             (alphabet '(a b c d e f g h i j k l m n o p q\
    \ r s t u v w x y z))\n             (accum \"\")\n             (newchar '(a b\
    \ c d e f g h i j k l m n o p q r s t u v w x y z))\n             (shift '(0 0\
    \ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)))\n    (cond [(empty? s) (set!\
    \ accum (string->list accum))]\n          [(char? (car s)) (loop (cdr s) alphabet\
    \ (append accum newchar) (append accum shift))\n           (loop (cdr s) alphabet\
    \ (append accum newchar) shift newchar)]\n          [else (loop (cdr s) alphabet\
    \ (append accum newchar) shift newchar)]))\n  accum)\n", "  (let loop ((s s)\n\
    \             (alphabet '(a b c d e f g h i j k l m n o p q r s t u v w x y z))\n\
    \             (i 0))\n    (if (>= i 26)\n        (cons s alphabet)\n        (loop\
    \ (substring s 0 (add1 i)) (substring alphabet 0 (add1 i)) (add1 i))))))\n", " \
    \ (let loop ((s s) (result '())\n             (position 0)) \n    (if (empty?\
    \ s)\n        result\n        (loop (rest s)\n              (cons \n         \
    \        (char \n                   (if (= position 0)\n                     \
    \  (char char result)\n                       (char (char (substring result 0\
    \ position)) (char char result))))\n                 result)\n              (+\
    \ position))))))\n", "  (let ([char-table (list\n                      '(\n  \
    \                     (list\n                         (cons 97 '(a b c d e f g\
    \ h i j k l m n o p q r s t u v w x y z)))\n                       (list\n   \
    \                      (cons 98 '(a b c d e f g h i j k l m n o p q r s t u v\
    \ w x y z)))\n                       (list\n                         (cons 99\
    \ '(a b c d e f g h i j k l m n o p q r s t u v w x y z)))\n                 \
    \      (list\n                         (cons 100 '(a b c d e f g h i j k l m n\
    \ o p q r s t u v w x y z)))\n                       (list\n                 \
    \        (cons 101 '(a b c d e f g h i j k l m n o p q r s t u v w x y z)))\n\
    \                       (list\n                         (cons 102 \n         \
    \                     '(a b c d e f g h i j k l m n o p q r s t u v w x y z)))\n\
    \                       (list\n                         (cons 103 '(a b c d e\
    \ f g h i j k l m n o p q r s t u v w x y z)))\n                       (list\n\
    \                         (cons 104 \n                              '(a b c d\
    \ e f g h i j k l m n o p q r s t u v w x y z)))\n                       (list\n\
    \                         (cons 105 '(a b c d e f g h i j k l m n o p q r s t\
    \ u v w x y z)))\n                       (list\n                         (cons\
    \ 106 '(a b c d e f g h i j k l m n o p q r s t u v w x y z)))\n             \
    \          (list\n                         (cons 107 '(a b c d e f g h i j k l\
    \ m n o p q r s t u v w x y z)))\n                       (list\n             \
    \            (cons 108 '(a b c d e f g h i j k l m n o p q r s t u v w x y z)))\n\
    \                       (list\n                         (cons 109 '(a b c d e\
    \ f g h i j k l m n o p ", "  (encrypt s \"kj\"))\n", "  (let ((letters (string->list\
    \ (rot-letters (string->list s)))))\n    (string->list \n      (map (lambda (letter)\n\
    \             (cons (list-ref letters 0) (list-ref letters 1)))) \n      (apply\
    \ append letters))))\n</cell>\n<code language=racket-tutorial>\n#lang racket\n",
  "  (let ([n (length s)])\n    (let loop ([s (reverse s)])\n      (let ([c (char\
    \ s)])\n        (if (< c 65)\n            (cons (char (+ 65 c)) s)\n         \
    \   (cons (char c) s)))))))\n", "  (if (null? s)\n      '()\n      (append (encrypt\
    \ (car s)) (cons (char->int (car s)) (rotate (car s)) (encrypt (cdr s))))))",
  "  (cond [(empty? s) \"\"]\n        [else (rotate-to-right (substring s 0 (length\
    \ s)) (substring s (length s) (length s)))]))\n", "  (let* ((len (length s))\n\
    \         (chars (make-array len (lambda (e) (cond [(= e 0) #\\space] \n     \
    \                                           [(= e 1) #\\A] \n                \
    \                                [(= e 2) #\\B] \n                           \
    \                     [(= e 3) #\\C] \n                                      \
    \          [(= e 4) #\\D] \n                                                [(=\
    \ e 5) #\\E] \n                                                [(= e 6) #\\F]\
    \ \n                                                [(= e 7) #\\G] \n        \
    \                                        [(= e 8) #\\H] \n                   \
    \                             [(= e 9) #\\I] \n                              \
    \                  [(= e 10) #\\J] \n                                        \
    \        [(= e 11) #\\K] \n                                                [(=\
    \ e 12) #\\L] \n                                                [(= e 13) #\\\
    M] \n                                                [(= e 14) #\\N] \n      \
    \                                          [(= e 15) #\\O] \n                \
    \                                [(= e 16) #\\P] \n                          \
    \                      [(= e 17) #\\Q] \n                                    \
    \            [(= e 18) #\\R] \n                                              \
    \  [(= e 19) #\\S] \n                                                [(= e 20)\
    \ #\\T] \n                                                [(= e 21) #\\U] \n \
    \                                               [(= e 22) #\\V] \n           \
    \                                     [(= e 23) #\\W] \n                     \
    \                           [(= e 24) #\\X] \n                               \
    \                 [(= e 25) #\\Y] \n                                         \
    \       [(= e 26) #\\Z] \n                                                [(=\
    \ e 27) #\\a] \n                                                [(= e 28) #\\\
    b] \n                                                [(= e 29) #\\t] \n      \
    \                                          [(= e 30) #\\z] \n                \
    \                                [(= e 31) #\\0]))\n                         \
    \                    (map (lambda (c) (substring c 0 2)) (string->list (reverse\
    \ s)))))))\n    (for-each (lambda (i) (set! s (substring s i (+ 2 i)))) (range))\n\
    \    (for-each (lambda (i) (set! s (substring s (+ 2 i) (+ 2 i)))) (range))\n\
    \    (for-each (lambda (i) (set! s (substring s (+ i 1) i))) (range))\n    (for-each\
    \ (lambda (i) (set! s (substring s (+ i 1) i))) (range))\n    (for-each (lambda\
    \ (i) (set! s (substring s (+ i 1) i))) (range))\n    (for-each (lambda (i) (set!\
    \ s (substring s (+ i 1) i))) (range))\n    (for-each (lambda (i) (set! s (substring\
    \ s (+ i 1) i))) (range))\n    (for-each", "  (cond [(empty? s) s]\n        [(eq?\
    \ (first s) \"a\") (encrypt (substring s \"a\" (+ 2 (length s))))]\n        [(eq?\
    \ (first s) \"b\") (encrypt (substring s \"b\" (+ 2 (length s))))]\n        [(eq?\
    \ (first s) \"c\") (encrypt (substring s \"c\" (+ 2 (length s))))]\n        [(eq?\
    \ (first s) \"d\") (encrypt (substring s \"d\" (+ 2 (length s))))]\n        [(eq?\
    \ (first s) \"e\") (encrypt (substring s \"e\" (+ 2 (length s))))]\n        [(eq?\
    \ (first s) \"f\") (encrypt (substring s \"f\" (+ 2 (length s))))]\n        [(eq?\
    \ (first s) \"g\") (encrypt (substring s \"g\" (+ 2 (length s))))]\n        [(eq?\
    \ (first s) \"h\") (encrypt (substring s \"h\" (+ 2 (length s))))]\n        [(eq?\
    \ (first s) \"i\") (encrypt (substring s \"i\" (+ 2 (length s))))]\n        [(eq?\
    \ (first s) \"j\") (encrypt (substring s \"j\" (+ 2 (length s))))]\n        [(eq?\
    \ (first s) \"k\") (encrypt (substring s \"k\" (+ 2 (length s))))]\n        [(eq?\
    \ (first s) \"l\") (encrypt (substring s \"l\" (+ 2 (length s))))]\n        [(eq?\
    \ (first s) \"m\") (encrypt (substring s \"m\" (+ 2 (length s))))]\n        [(eq?\
    \ (first s) \"n\") (encrypt (substring s \"n\" (+ 2 (length s))))]\n        [(eq?\
    \ (first s) \"o\") (encrypt (substring s \"o\" (+ 2 (length s))))]\n        [(eq?\
    \ (first s) \"p\") (encrypt (substring s \"p\" (+ 2 (length s))))]\n        [(eq?\
    \ (first s) \"q\") (encrypt (substring s \"q\" (+ 2 (length s))))]\n        [(eq?\
    \ (first s) \"r\") (encrypt (substring s \"r\" (+ 2 (length s))))]\n        [(eq?\
    \ (first s) \"s\") (encrypt (substring s \"s\" (+ 2 (length s))))]\n        [(eq?\
    \ (first s) \"t\") (encrypt (substring s \"t\" (+ 2 (length s))))]\n        [(eq?\
    \ (first s) \"u\") (encrypt (substring s \"u\" (+ 2 (length s))))]\n        [",
  "  (cond [(string= s \"\")\n         \"\"]\n        [(string= s \"a\")\n       \
    \  (concat s \"z\")]\n        [(string= s \"b\")\n         (concat s \"x\")]\n\
    \        [(string= s \"c\")\n         (concat s \"y\")]\n        [(string= s \"\
    d\")\n         (concat s \"w\")]\n        [(string= s \"e\")\n         (concat\
    \ s \"v\")]\n        [(string= s \"f\")\n         (concat s \"u\")]\n        [(string=\
    \ s \"g\")\n         (concat s \"t\")]\n        [(string= s \"h\")\n         (concat\
    \ s \"p\")]\n        [(string= s \"i\")\n         (concat s \"q\")]\n        [(string=\
    \ s \"j\")\n         (concat s \"r\")]\n        [(string= s \"k\")\n         (concat\
    \ s \"s\")]\n        [(string= s \"l\")\n         (concat s \"q\")]\n        [(string=\
    \ s \"m\")\n         (concat s \"x\")]\n        [(string= s \"n\")\n         (concat\
    \ s \"y\")]\n        [(string= s \"o\")\n         (concat s \"v\")]\n        [(string=\
    \ s \"p\")\n         (concat s \"w\")]\n        [(string= s \"q\")\n         (concat\
    \ s \"v\")]\n        [(string= s \"r\")\n         (concat s \"u\")]\n        [(string=\
    \ s \"s\")\n         (concat s \"t\")]\n        [(string= s \"t\")\n         (concat\
    \ s \"s\")]\n        [(string= s \"u\")\n         (concat s \"v\")]\n        [(string=\
    \ s \"v\")\n         (concat s \"w\")]\n        [(string= s \"w\")\n         (concat\
    \ s \"x\")]\n        [(string= s \"x\")\n         (concat s \"y\")]\n        [(string=\
    \ s \"y\")\n         (concat s \"z\")]\n        [else\n         (append (substring\
    \ (map string->char (map string-append (map string-append (map string-append s\
    \ s) \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"\
    m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\" \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"\
    z\")) 0 2)\n                 (substring (map string->char (map string-append (map\
    \ string-append (map string-append s s) \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"\
    g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\" \"\
    t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"", "  (define (enc-letter letter)\n    (char->string\
    \ (char->int letter)))\n  (define (enc-rot letter)\n    (char->int (substring\
    \ letter (string-length letter))))\n  (define (enc-shift letter)\n    (substring\
    \ letter (+ 2 (string-length letter))))\n  (define (enc-rot letter)\n    (char->int\
    \ (substring letter (string-length letter))))\n  (define (enc-shift letter)\n\
    \    (substring letter (+ 2 (string-length letter))))\n  (map (lambda (l) (cond\
    \ ((string=? l \"\") (enc-letter l))\n                      ((string=? l \"z\"\
    ) (enc-letter l))\n                      ((string=? l \"a\") (enc-letter l))\n\
    \                      ((string=? l \"b\") (enc-letter l))\n                 \
    \     ((string=? l \"c\") (enc-letter l))\n                      ((string=? l\
    \ \"d\") (enc-letter l))\n                      ((string=? l \"e\") (enc-letter\
    \ l))\n                      ((string=? l \"f\") (enc-letter l))\n           \
    \           ((string=? l \"g\") (enc-letter l))\n                      ((string=?\
    \ l \"h\") (enc-letter l))\n                      ((string=? l \"i\") (enc-letter\
    \ l))\n                      ((string=? l \"j\") (enc-letter l))\n           \
    \           ((string=? l \"k\") (enc-letter l))\n                      ((string=?\
    \ l \"l\") (enc-letter l))\n                      ((string=? l \"m\") (enc-letter\
    \ l))\n                      ((string=? l \"n\") (enc-letter l))\n           \
    \           ((string=? l \"o\") (enc-letter l))\n                      ((string=?\
    \ l \"p\") (enc-letter l))\n                      ((string=? l \"q\") (enc-letter\
    \ l))\n                      ((string=? l \"r\") (enc-letter l))\n           \
    \           ((string=? l \"s\") (enc-letter l))\n                      ((string=?\
    \ l \"t\") (enc-letter l))\n                      ((string=? l \"u\") (enc-letter\
    \ l))\n                      ((string=? l \"v\") (enc-letter l))\n           \
    \           ((string=? l \"w\") (enc-letter l))\n", "  (let* ((a (substring s\
    \ 0 26))\n         (b (substring s 1 27))\n         (c (substring s 2 28))\n \
    \        (d (substring s 3 29))\n         (e (substring s 4 30))\n         (f\
    \ (substring s 5 31))\n         (g (substring s 6 32))\n         (h (substring\
    \ s 7 33))\n         (i (substring s 8 34))\n         (j (substring s 9 35))\n\
    \         (k (substring s 10 36))\n         (l (substring s 11 37))\n        \
    \ (m (substring s 12 38))\n         (n (substring s 13 39))\n         (o (substring\
    \ s 14 40))\n         (p (substring s 15 41))\n         (q (substring s 16 42))\n\
    \         (r (substring s 17 43))\n         (s (substring s 18 44))\n        \
    \ (t (substring s 19 45))\n         (u (substring s 20 46))\n         (v (substring\
    \ s 21 47))\n         (w (substring s 22 48))\n         (x (substring s 23 49))\n\
    \         (y (substring s 24 50))\n         (z (substring s 25 51))\n        \
    \ (a-list (cons a a-list))\n         (b-list (cons b b-list))\n         (c-list\
    \ (cons c c-list))\n         (d-list (cons d d-list))\n         (e-list (cons\
    \ e e-list))\n         (f-list (cons f f-list))\n         (g-list (cons g g-list))\n\
    \         (h-list (cons h h-list))\n         (i-list (cons i i-list))\n      \
    \   (j-list (cons j j-list))\n         (k-list (cons k k-list))\n         (l-list\
    \ (cons l l-list))\n         (m-list (cons m m-list))\n         (n-list (cons\
    \ n n-list))\n         (o-list (cons o o-list))\n         (p-list (cons p p-list))\n\
    \         (q-list (cons q q-list))\n         (r-list (cons r r-list))\n      \
    \   (s-list (cons s s-list))\n         (t-list (cons t t-list))\n         (u-list\
    \ (cons u u-list))\n         (v-list (cons v v-list))\n         (w-list (cons\
    \ w w-list))\n         (x-list (cons x x-list))\n         (y-list (cons y y-list))\n\
    \         (z-list (cons z z-list))\n         (alphabet-list (con", "  (if (empty?\
    \ s)\n      '()\n      (append\n       (map (lambda (c) (cond ((string=? c 'A)\
    \ (char->number (char->string (cdr c))))\n                            ((string=?\
    \ c 'B) (char->number (char->string (car c))))\n                            ((string=?\
    \ c 'C) (char->number (char->string (car c))))\n                            ((string=?\
    \ c 'D) (char->number (char->string (car c))))\n                            ((string=?\
    \ c 'E) (char->number (char->string (car c))))\n                            ((string=?\
    \ c 'F) (char->number (char->string (car c))))\n                            (else\
    \ '(error \"Unsupported character\"))))\n          (map char->string (char->number\
    \ (string->char s)))))))\n", "  (if (empty? s) \n      (empty-string)\n      (append\
    \ (cons (first s) (encrypt (subseq s 2))) (cons (second s) (encrypt (subseq s\
    \ (+ 2 2)))))))\n", "  (cond [(empty? s) \"\"]\n        [(equal? (char-before\
    \ (first s) #\\A) (string-append \"a\" (char-after (first s) #\\A)))\n       \
    \  (string-append \"a\" (char-after (first s) #\\A))\n         (string->list\n\
    \            (encrypt (char-after (first s) #\\A)))]\n        [else\n        \
    \ (string->list\n           (encrypt (char-after (first s) #\\A)))]))\n", "  (cond\n\
    \    [(empty? s) '()]\n    [(cons? s) (map (lambda (c) (cons c (encrypt  (cdr\
    \ s))))\n                      (first  s))]\n    [else (append (map (lambda (c)\
    \ (cons c (encrypt  (cdr s))))\n                         (rotate s (+ 1 alphabet)))]))\n",
  "  (let ((alpha (char->list\n             (apply rot13 (string->list s))))\n   \
    \     (i 0))\n    (apply append (map make-char alpha (- i 26))))))\n</cell>\n\
    <cell>\n%kata T141_Decrypt_Rot13 \n", "  (let loop ((alpha (make-alphabet \"abcdefghijklmnopqrstuvwxyz\"\
    ))\n             (s-alpha (rotate alpha (char-index s-letter 0))\n           \
    \           (+ 2 s-letter)))\n    (cond\n      [(empty? s) (list-reverse (list-concat\
    \ '() (make-letter (char-index s-letter 0) s))\n                         (list-length\
    \ s))]\n      [else (list-reverse (list-concat '() \n                        \
    \            (make-letter (char-index s-letter 0) s)\n                       \
    \             (make-letter (char-index s-letter 1) s))\n                     \
    \  (loop (rotate the alpha s-letter) (char-index s 1))]))))\n", "  (encrypt s\
    \ #\\a))\n", "  (let loop ([alphabet (list* 'a 'b 'c 'd 'e 'f 'g 'h 'i 'j 'k 'l\
    \ 'm 'n 'o 'p 'q 'r 's 't 'u 'v 'w 'x 'y 'z)]\n             [rotated (list* 'a\
    \ 'b 'c 'd 'e 'f 'g 'h 'i 'j 'k 'l 'm 'n 'o 'p 'q 'r 's 't 'u 'v 'w 'x 'y 'z)]\n\
    \             [result '()])\n    (if (null? s)\n        result\n        (loop\
    \ (subseq alphabet 1 \n                     (add1 (- \n                      \
    \       (sub (length s) \n                                 1 (length (first alphabet)))))\
    \ \n               (subseq rotated (length (first alphabet) \n               \
    \                (add1 (- \n                                       (sub (length\
    \ s) \n                                         1 (length (first alphabet)))))\
    \ \n                               (add1 (- \n                               \
    \        (sub (length s) \n                                         1 (length\
    \ (first alphabet))))))\n               (if (= (sub (length s) \n            \
    \                 (length (first alphabet)) \n                             0)\n\
    \                   result\n                   (append result \n             \
    \             (list (first s))))))))\n", "  (let loop ((string s)\n          \
    \   (result \"\")\n             (i 0))\n    (if (= i 26)\n        (printf \"\\\
    n>>> (encrypt \\\"%s\\\")\\n%s\" string result)\n        (let ((c (char-ref string\
    \ i))\n              (rest (substring string i (+ i (char 1)))))\n          (loop\
    \ (append rest (list c)) (append result (list c)) (+ i 1))))))\n", "  (string-append\
    \ (encrypt (substring s 0 0)) \n                (substring s 1 1)))\n", "  (cond\
    \ ((empty? s) \"\")\n        ((member? (first s) alphabet) (rest s)\n        (substring\
    \ (rest s) 0 (- (length s) 2))\n        (substring (rest s) 2 (- (length s) 2))\n\
    \        (cons substring (substring (rest s) 0 (- (length s) 2) (+ 1 0))\n   \
    \           (cons substring (substring (rest s) (+ 1 0) (+ 1 0) (+ 1 0))\n   \
    \                     (cons substring (substring (rest s) (+ 1 0) (+ 1 0) (+ 1\
    \ 1))\n                                (cons substring (substring (rest s) (+\
    \ 1 1) (+ 1 1) (+ 1 1))\n                                        (cons substring\
    \ (substring (rest s) (+ 1 1) (+ 1 1) (+ 1 2))\n                             \
    \                   (cons substring (substring (rest s) (+ 1 2) (+ 1 2) (+ 1 2))\n\
    \                                                        (cons substring (substring\
    \ (rest s) (+ 1 2) (+ 1 2) (+ 1 3))\n                                        \
    \                        (cons substring (substring (rest s) (+ 1 3) (+ 1 3) (+\
    \ 1 3))\n                                                                    \
    \    (cons substring (substring (rest s) (+ 1 3) (+ 1 3) (+ 1 4))\n          \
    \                                                                      (cons substring\
    \ (substring (rest s) (+ 1 4) (+ 1 4) (+ 1 4))\n                             \
    \                                                           (cons substring (substring\
    \ (rest s) (+ 1 4) (+ 1 4) (+ 1 5))\n                                        \
    \                                                        (cons substring (substring\
    \ (rest s) (+ 1 5) (+ 1 5) (+ 1 5))\n                                        \
    \                                                                (cons substring\
    \ (substring (rest s) (+ 1 5) (+ 1 5) (+ 1 6))\n                             \
    \                                                                            \
    \       (cons substring (substring (rest s) (+ 1 6) (+ 1 6) (+ 1 6))\n       \
    \                                                                            \
    \                                     (cons substring (substring (rest s) (+ 1\
    \ 6) (+ 1 6) (+ 1 7))\n                                                      \
    \                                                                          (cons\
    \ substring (substring (rest s) (+ 1 7) (+ 1 7) (+ 1 7))\n                   \
    \                                                                            \
    \                                         (cons substring (substring (rest s)\
    \ (+ 1 7) (+ 1 7) (+ 1 8))\n                                                 \
    \                                                                            \
    \                   (cons substring (substring (rest s) (+ 1 8) (+ 1 8) (+ 1 8))\n\
    \                                                                            \
    \                                                            (cons substring (substring\
    \ (rest s) (+ 1 8) (+ 1 8) (+ 1 9))\n                                        \
    \                                                                            \
    \                                            (", "  (let* ((alpha (rotate 'a 'b))\n\
    \         (alpha-i (make-list 26)))\n    (char->integer (char->string s)\n   \
    \                 (lambda (c) (let* ((alpha-ch (char-chr alpha (char-code c))))\n\
    \                                   (cond [(< alpha-ch alpha-i) alpha-i]\n   \
    \                                      [(eq alpha-ch alpha-i) alpha]\n       \
    \                                  [else alpha-ch])))\n                    (lambda\
    \ (c alpha-ch) (let ((alpha-ch-old\n                                         \
    \       (if (eq alpha-ch alpha-i) alpha-i\n                                  \
    \                  alpha-ch)))\n                                      (set! alpha-ch\
    \ (char-chr alpha (char-code c))\n                                           \
    \     alpha-ch-old))))\n    (map char->string (number->chars (list->string alpha-i))))\n",
  "  (define (encrypt s)\n    (if (null? s)\n      '()\n      (cons (char->num (car\
    \ s)) (encrypt (cdr s)))))\n  (encrypt s))\n", "  (define (shift a b)\n    (cond\n\
    \      [(not (<= a b))\n       (rotate-char a b #\\A)]\n      [(<= a b)\n    \
    \   (rotate-char a b #\\B)]\n      [(not (<= b #\\Z))\n       (rotate-char a b\
    \ #\\A)]\n      [(<= b #\\Z)\n       (rotate-char a b #\\B)]\n      [else\n  \
    \     (rotate-char a b #\\A)]\n      ))\n\n  (define (rotate-char c r alphabet)\n\
    \    (cond\n      [(string=? c \"\")\n       (string)\n      [(string=? (substring\
    \ alphabet 0 r) c)\n       (substring alphabet 0 r)]\n      [(string=? (substring\
    \ alphabet (r + 1) r) c)\n       (substring alphabet (r + 1) r)]\n      [(string=?\
    \ (substring alphabet (r + 1) (r + 1)) c)\n       (substring alphabet (r + 1)\
    \ (r + 1))]\n      [else\n       (substring alphabet (r + 1) r)]\n      ))\n\n\
    \  (define (rotate s c)\n    (cond\n      [(string=? c \"\")\n       \"\"]\n \
    \     [(string=? (substring s 0 r) c)\n       (substring s 0 r)]\n      [(string=?\
    \ (substring s (r + 1) r) c)\n       (substring s (r + 1) r)]\n      [else\n \
    \      (substring s (r + 1) r)]))\n\n  (define (encrypt s c)\n    (cond\n    \
    \  [(string=? c \"\")\n       \"\"]\n      [(string=? (substring s 0 r) c)\n \
    \      (substring s 0 r)]\n      [(string=? (substring s (r + 1) r) c)\n     \
    \  (substring s (r + 1) r)]\n      [(string=? (substring s (r + 1) (r + 1)) c)\n\
    \       (substring s (r + 1) (r + 1))]\n      [else\n       (substring s (r +\
    \ 1) r)]))\n\n  (define (encrypt-char c s r)\n    (cond\n      [(string=? c \"\
    \")\n       \"\"]\n      [(string=? (substring s 0 r) c)\n       (substring s\
    \ 0 r)]\n      [(string=? (substring s (r + 1) r) c)\n       (substring s (r +\
    \ 1) r)]\n      [else\n       (substring s (r + 1) r)]))\n\n  (define (encrypt\
    \ s c)\n    (cond", "  (cond\n    [(empty? s)\n     (string->symbol 'q)]\n   \
    \ [else\n     (append (apply rot13 (string->list s))\n             (list (symbol->string\
    \ (first s))))])))\n", "  (let ([k (length s)])\n    (if (= k (length s))\n  \
    \      (reverse s)\n        (let ([m (mod k 26)]\n              [shift (- m 26)])\n\
    \          (let ([ss (string->list (list 'a s s s s s s))])\n            (cond\n\
    \              [(= m 0)\n               (set! s (string->string (ss (- shift 26))))\n\
    \               (set! s (string->string (cons (string->char s) s)))]\n       \
    \       [(= shift 0)\n               (set! k (- k 26))\n               (set! s\
    \ (string->string (cons (string->char s) s)))]\n              [(= shift 1)\n \
    \              (set! s (string->string (cons (string->char s) (cons (string->char\
    \ s) ss))))]\n              [else\n               (set! s (string->string (cons\
    \ (string->char s) (cons (string->char (mod k 26)) ss))))])))])))\n</code>\n<|/\
    \ a tags=string,racket,scheme,lisp |>\n<| a |>\nI came up with another solution\
    \ in C#.\n<code>\npublic class Program\n{\n    public static void Main(string[]\
    \ args)\n    {\n        string s = args[0];\n        int l = s.Length;\n     \
    \   Console.WriteLine(s.Length);\n        Console.WriteLine(l);\n        int a\
    \ = l;\n        for (int i = l-1; i > 0; i--)\n        {\n            Console.WriteLine(s.Substring(i,\
    \ 2));\n            Console.WriteLine(a--);\n        }\n    }\n}\n</code>\n<|/\
    \ a tags=string,racket,scheme,lisp dscore=0 |>\n<| a tags=string,racket,scheme,lisp\
    \ dscore=0 |>\nHere is a solution in Racket (Racket's official language):\n<code>\n\
    #lang racket\n", "  (cond\n    [(empty? s) '()]\n    [(equal? (first s) (first\
    \ '())) \n    (append (encrypt (substring s 0 (- 1 (length s))))\n           \
    \ (encrypt (substring s 1 (- 1 (length s)))))]\n    [else (cons (first s)\n  \
    \             (append (encrypt (substring s (+ 2 (length s))))\n             \
    \          (encrypt (substring s (+ 2 (length s)))))]))\n)\n", "  (let ((a (char-alphabet\
    \ s))\n        (c (char-alphabet (copy-rotated-alphabet a))))\n    (string->list\
    \ (cons c s))))", "  (cond [(empty? s) s]\n        [(empty? (rest s)) empty]\n\
    \        [(equal? (first s) (last (rest s))) (cons (first s) (encrypt (rest s)))]\n\
    \        [else (cons (cons (first s) (encrypt (rest s))) (encrypt (substring (rest\
    \ s) 0 (- (length s) 1))))]))\n", "  (let ((alphabet (list \"abc\" \"def\" \"\
    ghi\" \"jkl\" \"mno\" \"pqrs\" \"tuv\" \"wxy\" \"z\"))\n        (pc (car alphabet))\n\
    \        (len (length alphabet))\n        (pcs (cdr alphabet)))\n    (loop for\
    \ i from 0 to (length s) do\n      (let ((result (make-string len))\n        \
    \    (remainder (- i 1)))\n        (for-each [r alphabet (+ i 1)]\n          (let\
    \ ((letter (car r)))\n            (set! letter (char (char (char (char (char (char\
    \ (char (char (char (char (char (char (char (char (char (char (char (char (char\
    \ (char (char (char (char (char (char (char (char (char (char (char (char (char\
    \ (char (char (char (char (char (char (char (char (char (char (char (char (char\
    \ (char (char (char (char (char (char (char (char (char (char (char (char (char\
    \ (char (char (char (char (char (char (char (char (char (char (char (char (char\
    \ (char (char (char (char (char (char (char (char (char (char (char (char (char\
    \ (char (char (char (char (char (char (char (char (char (char (char (char (char\
    \ (char (char (char (char (char (char (char (char (char (char (char (char (char\
    \ (char (char (char (char (char (char (char (char (char (char (char (char (char\
    \ (char (char (char (char (char (char (char (char (char (char (char (char (char\
    \ (char (char (char (char (char (char (char (char (char (char (char (char (char\
    \ (char (char (char (char (char (char (char (char (char (char (char (char (char\
    \ (char (char (char (char (char (char (char (char (char (char (char (char (char\
    \ (char (char (char (char (char (char (char (char (char (char (char (char (char\
    \ (char (char (char (char (char (char (char (char (char (char", "  (cond\n   \
    \ [(empty? s) \"\"]\n    [(equal? (char (first s)) (char (last (rest s))))\n \
    \    (string-append (encrypt (substring s 0 (length s))) (encrypt (substring s\
    \ (length s) (length s))))]\n    [else \n     (string-append (encrypt (substring\
    \ s 0 (length s))) (encrypt (substring s (length s) (length s))) (encrypt (substring\
    \ s (length s) (length s))) (encrypt (substring s 0 (length s)))) ]\n    ))\n\
    </code>\n<|/ a tags=scheme |>\n<| c |>\nHmm this doesn't seem to output the correct\
    \ value when encrypting \"hi\" into \"lm\". Still gives me \"hi\" as an output...\n\
    <|/ c |>\n<| c |>\nOops, I didn't notice that the output was wrong. I've updated\
    \ my answer with a fix and tested with DrRacket.\n<|/ c |>\n<| a |>\nHere is a\
    \ solution I came up with that seems to work in R6RS and Racket, and hopefully\
    \ it will work in R6RS or Racket too:\n<code>", "  (define (encrypt s i k)\n \
    \   (if (null? s)\n        (string \"\")\n        (let ((c (char s i)))\n    \
    \      (set! s (substring s 0 (+ i k)))\n          (set! i (+ i k))\n        \
    \  (set! k (+ k 2))\n          (concat i (encrypt s (+ i 1) k))\n          (concat\
    \ c (encrypt s (+ i 1) k))))\n  (encrypt s 0 0))\n", "  (let loop ((i 0) (c (chars->list\
    \ 'a #'(lambda (x y) (+ x y))))\n             (r (reverse (cons (chars->list 'z\
    \ '#'(lambda (x y) (- x y)))\n                             (reverse (c))))\n \
    \            (t (reverse (c))))\n    (cond\n      [(char=? s (car r)) (reverse\
    \ (car r))] \n      [else (loop (+ i 1) (append r (car c)) t (reverse t))]))))\n",
  "  (let ((alpha (char->list (symbol->string \"abcdefghijklmnopqrstuvwxyz\"))))\n\
    \    (apply (lambda (x)\n             (map (lambda (y)\n                    (cond\
    \ ((>= y (length alpha)) y)\n                          ((< y 0) (modulo (+ y (length\
    \ alpha)) (length alpha)))\n                          (else y)))\n           \
    \       (apply str->list s))))))\n", "  (if (empty? s)\n      s\n      (let ((a\
    \ (map char->char (string->list (string->list s)))))\n        (map (lambda (x)\n\
    \              (rotate-char\n                (string-ref x 0)\n              \
    \  (string-ref x 1)\n                (string-ref x 2)\n                (string-ref\
    \ x 3)\n                (string-ref x 4))\n              a))))\n</code>\n<|/ a\
    \ dscore=3 tags=functional-programming,scheme,encryption,racket,string |>\n<|\
    \ c |>\nThis is actually a great answer, thanks! I do have one question: how would\
    \ you approach the problem if someone wanted to write a function that would encrypt\
    \ an arbitrary string?\n<|/ c |>\n<| c |>\nThis is more of a challenge in functional\
    \ programming than in scheme or racket. I'd start by having a look at the chapter\
    \ on lists and recursion in HtDP. You'll have to write two procedures - one that\
    \ takes a string, and one that takes a list. You'll need to implement a function\
    \ that shifts the characters 2 places down, which is fairly trivial. You'll probably\
    \ want a helper function that takes the shift amount, and applies your shift function.\
    \ You'll then need to map each character in your string through your shift function.\
    \ Once you've got it working, then try writing it in a tail-recursive fashion.\n\
    <|/ c |>\n<| c |>\nOh, one other thing - you can implement a shift by x characters\
    \ by doing (- x 2) (for example, shift by 2 is (- 2 0)).\n<|/ c |>\n<| c |>\n\
    I think I'm getting confused on how this actually works. Would you be able to\
    \ write down an example of what you mean?\n<|/ c |>\n<| a dscore=2 |>\nHere is\
    \ a Racket solution using a mutable list instead of a foldr.\n<code>\n#lang racket\n",
  "  (define (alphabet n)\n    (define (shifted char n)\n      (cond [(= n 0)\n  \
    \           char]\n            [else\n             (+ (char (expt char n)) (char\
    \ (expt char n)))]\n          ))\n    (define (rotated char n)\n      (cond [(=\
    \ n 0)\n             char]\n            [else\n             (rotated(char (expt\
    \ char n)) (- n 1))]\n          ))\n    (define (n c)\n      (cond [(or (char=?\
    \ c #\\a)\n              (char=? c #\\z)\n              (char=? c #\\v)\n    \
    \          (char=? c #\\W)\n              (char=? c #\\D)\n              (char=?\
    \ c #\\S)\n              (char=? c #\\Q)\n              (char=? c #\\R)\n    \
    \          (char=? c #\\Z)]\n            [(= (char-alphabet c) (alphabet n)) (shifted\
    \ c n)]\n            [else (rotated c n)]))\n    (cond [(empty? s) \"\"]\n   \
    \       [(char=? (car s) #\\a) (n 'a)]\n          [(char=? (car s) #\\z) (n 'z)]\n\
    \          [(char=? (car s) #\\v) (n 'v)]\n          [(char=? (car s) #\\W) (n\
    \ 'W)]\n          [(char=? (car s) #\\D) (n 'D)]\n          [(char=? (car s) #\\\
    S) (n 'S)]\n          [(char=? (car s) #\\Q) (n 'Q)]\n          [(char=? (car\
    \ s) #\\R) (n 'R)]\n          [(char=? (car s) #\\Z) (n 'Z)]\n          [else\
    \ (rotated (car s) (- n 1))]\n          ))\n", "  (let loop ((s s)\n         \
    \    (char (length s))\n             (chars (make-array (char) \n            \
    \                    (sub1 char) (lambda (x) (+ x 2)) \n                     \
    \           (sub1 char) (lambda (x) (- x 2))\n                               \
    \ (sub1 char) (lambda (x) (- x 1))\n                                (sub1 char)\
    \ (lambda (x) (- x 1))))\n             (alpha (sub1 char) (lambda (x) (+ x 2))))\n\
    \    (cond\n      [(empty? s) \"\"]\n      [else (loop (cdr s)\n             \
    \   (char (car s))\n                (chars (array (car chars) \n             \
    \               (lambda (x) (+ x 2))\n                            (lambda (x)\
    \ (- x 2))\n                            (lambda (x) (- x 1))\n               \
    \             (lambda (x) (- x 1))))\n          alpha]\n      [else (loop (cdr\
    \ s)\n                char\n                chars\n                (lambda (x)\
    \ (+ x 2))))))\n", "  (let loop ((count 0))\n    (cond\n      [(equal? s \"\"\
    ) \"\"]\n      [(equal? s #\\space) s]\n      [(char=? (char-code (substring s\
    \ 0 1)) #\\a) (substring s 1 2)]\n      [(char=? (char-code (substring s 0 1))\
    \ #\\b) (substring s 2 3)]\n      [(char=? (char-code (substring s 0 1)) #\\c)\
    \ (substring s 3 4)]\n      [(char=? (char-code (substring s 0 1)) #\\d) (substring\
    \ s 4 5)]\n      [(char=? (char-code (substring s 0 1)) #\\e) (substring s 5 6)]\n\
    \      [(char=? (char-code (substring s 0 1)) #\\f) (substring s 6 7)]\n     \
    \ [(char=? (char-code (substring s 0 1)) #\\g) (substring s 7 8)]\n      [(char=?\
    \ (char-code (substring s 0 1)) #\\h) (substring s 8 9)]\n      [(char=? (char-code\
    \ (substring s 0 1)) #\\i) (substring s 9 10)]\n      [(char=? (char-code (substring\
    \ s 0 1)) #\\j) (substring s 10 11)]\n      [(char=? (char-code (substring s 0\
    \ 1)) #\\k) (substring s 11 12)]\n      [(char=? (char-code (substring s 0 1))\
    \ #\\l) (substring s 12 13)]\n      [(char=? (char-code (substring s 0 1)) #\\\
    m) (substring s 13 14)]\n      [(char=? (char-code (substring s 0 1)) #\\n) (substring\
    \ s 14 15)]\n      [(char=? (char-code (substring s 0 1)) #\\o) (substring s 15\
    \ 16)]\n      [(char=? (char-code (substring s 0 1)) #\\p) (substring s 16 17)]\n\
    \      [(char=? (char-code (substring s 0 1)) #\\q) (substring s 17 18)]\n   \
    \   [(char=? (char-code (substring s 0 1)) #\\r) (substring s 18 19)]\n      [(char=?\
    \ (char-code (substring s 0 1)) #\\s) (substring s 19 20)]\n      [(char=? (char-code\
    \ (substring s ", "  (let ((c (char->integer #\\a)))\n    (cond\n      [(empty?\
    \ s) s]\n      [(< (char-length (first s)) 26) (cons (char->string (+ (char->integer\
    \ #\\a) c)) (encrypt (rest s)))]\n      [else (cons (char->string (+ (char->integer\
    \ #\\a) c)) (encrypt (rest s)))])))\n", "  (cond [(empty? s) \"\"]\n        [(>=\
    \ (length s) 26) (cons \"a\" (encrypt (substring s 0 1)))]\n        [(>= (length\
    \ s) 25) (cons \"b\" (encrypt (substring s 0 2)))]\n        [(>= (length s) 24)\
    \ (cons \"c\" (encrypt (substring s 0 3)))]\n        [(>= (length s) 23) (cons\
    \ \"d\" (encrypt (substring s 0 4)))]\n        [(>= (length s) 22) (cons \"e\"\
    \ (encrypt (substring s 0 5)))]\n        [(>= (length s) 21) (cons \"f\" (encrypt\
    \ (substring s 0 6)))]\n        [(>= (length s) 20) (cons \"g\" (encrypt (substring\
    \ s 0 7)))]\n        [(>= (length s) 19) (cons \"h\" (encrypt (substring s 0 8)))]\n\
    \        [(>= (length s) 18) (cons \"i\" (encrypt (substring s 0 9)))]\n     \
    \   [(>= (length s) 17) (cons \"j\" (encrypt (substring s 0 10)))]\n        [(>=\
    \ (length s) 16) (cons \"k\" (encrypt (substring s 0 11)))]\n        [(>= (length\
    \ s) 15) (cons \"l\" (encrypt (substring s 0 12)))]\n        [(>= (length s) 14)\
    \ (cons \"m\" (encrypt (substring s 0 13)))]\n        [(>= (length s) 13) (cons\
    \ \"n\" (encrypt (substring s 0 14)))]\n        [(>= (length s) 12) (cons \"o\"\
    \ (encrypt (substring s 0 15)))]\n        [(>= (length s) 11) (cons \"p\" (encrypt\
    \ (substring s 0 16)))]\n        [(>= (length s) 10) (cons \"q\" (encrypt (substring\
    \ s 0 17)))]\n        [(>= (length s) 9) (cons \"r\" (encrypt (substring s 0 18)))]\n\
    \        [(>= (length s) 8) (cons \"s\" (encrypt (substring s 0 19)))]\n     \
    \   [(>= (length s) 7) (cons \"t\" (encrypt (substring s 0 20)))]\n        [(>=\
    \ (length s) 6) (cons \"u\" (encrypt (substring s 0 21)))]\n        [(>= (length\
    \ s) 5) (cons \"v\" (encrypt (substring s 0 22)))", "  (map \n   (lambda (x) (rot\
    \ x 1)) \n   s))", "  (define (encrypt i k)\n    (cond\n      [(= i 0) (cons k\
    \ s)]\n      [(null? (rest k)) \n       (cons (first k) s)]\n      [(< (modulo\
    \ i (length (rest k))) 2)\n       (cons (first k) (encrypt (+ i 1) (rest k)))]\n\
    \      [(> (modulo i (length (rest k))) 2)\n       (encrypt (+ i 1) (rest k))]\n\
    \      [else (cons (first k) (encrypt (i (rest k))))])))\n  (reverse (encrypt\
    \ 0 (reverse (list 'a 'b 'c 'd 'e 'f 'g 'h 'i 'j 'k 'l 'm 'n 'o 'p 'q 'r 's 't\
    \ 'u 'v 'w 'x 'y 'z 'a 'b 'c 'd 'e 'f 'g 'h 'i 'j 'k 'l 'm 'n 'o 'p 'q 'r 's 't\
    \ 'u 'v 'w 'x 'y 'z))))\n", "  (apply string\n         (map string-append \n \
    \              (map string-append\n                    (cons s)\n            \
    \        (rot1 s)))))\n", "  (cond\n    [(empty? s) s]\n    [(equal? (char s (cdr\
    \ s)) 'a) 'b]\n    [(equal? (char s (cdr s)) 'b) 'a]\n    [else (cons \n     \
    \ (cond \n        [(equal? (char s (cdr s)) 'c) 'd]\n        [(equal? (char s\
    \ (cdr s)) 'd) 'c]\n        [else (cons \n          (cond \n            [(equal?\
    \ (char s (cdr s)) 'e) 'f]\n            [(equal? (char s (cdr s)) 'f) 'e]\n  \
    \          [else (cons \n              (cond \n                [(equal? (char\
    \ s (cdr s)) 'g) 'h]\n                [(equal? (char s (cdr s)) 'h) 'g]\n    \
    \            [else (cons \n                  (cond \n                    [(equal?\
    \ (char s (cdr s)) 'i) 'j]\n                    [(equal? (char s (cdr s)) 'j)\
    \ 'i]\n                    [else (cons \n                      (cond \n      \
    \                  [(equal? (char s (cdr s)) 'k) 'l]\n                       \
    \ [ (equal? (char s (cdr s)) 'l) 'k]\n                        [else (cons \n \
    \                         (cond \n                            [(equal? (char s\
    \ (cdr s)) 'm) 'n]\n                            [(equal? (char s (cdr s)) 'n)\
    \ 'm]\n                            [else (cons \n                            \
    \  (cond \n                                [(equal? (char s (cdr s)) 'o) 'p]\n\
    \                                [(equal? (char s (cdr s)) 'p) 'o]\n         \
    \                       [else (cons \n                                  (cond\
    \ \n                                    [(equal? (char s (cdr s)) 'q) 'r]\n  \
    \                                  [(equal? (char s (cdr s)) 'r) 'q]\n       \
    \                             [else (cons \n                                 \
    \     (cond \n                                        [(equal? (char s (cdr s))\
    \ 's) 't]\n                                        [(equal? (char s (cdr s)) 't)\
    \ 's]\n                                        [else (cons \n                \
    \                          (cond \n                                          \
    \  [(equal? (char s (cdr s)) 'u) 'v]\n                                       \
    \     [(equal? (char s (cdr s)) 'v) 'u]\n                                    \
    \        [else (cons \n                                              (cond \n\
    \                                                [(equal? (char s (cdr s)) 'w)\
    \ '", "  (let ((alpha (make-alpha-rotated-alphabet s)))\n    (map alpha-char-at-pos-2\
    \ alpha (concat s alphabet))))\n", "  (let loop ((x 0) (result \"\")) \n    (cond\
    \ ((null? s) result) \n          ((string=? s (substring s x (+ x 2)) (+ x 1))\n\
    \           (loop (+ x 1) (concat (substring s x (+ x 2)) (substring s x)))) \n\
    \          (else (loop (+ x 1) (concat result (substring s x))))))\n", "  (map\
    \ \n   (lambda (c)\n     (let ((rotated (rotate-letter c 'a)))\n       (cond\n\
    \        [(empty? s) c]\n        [else rotated]))) s))\n", "  (let ((alpha (char->string\
    \ rot)))\n    (cond\n      [(empty? s) \"\"]\n      [(char->char-index (string->char\
    \ s))\n       (cond [(char->char-index c) (car alpha (+ char->char-index c 26))\
    \ | else]\n             [else (cond [(char->char-index c) (cdr alpha (+ char->char-index\
    \ c 26)) | else]\n                       [else (car alpha (+ char->char-index\
    \ c 26)) | else])))])))\n", "  (cond [(null? s) \"\"]\n        [(eq? (first s)\
    \ 'a) (concat (char->string (rotate 'a)) (encrypt (rest (rest s))))]\n       \
    \ [(eq? (first s) 'b) (concat (char->string (rotate 'b)) (encrypt (rest (rest\
    \ s))))]\n        [(eq? (first s) 'c) (concat (char->string (rotate 'c)) (encrypt\
    \ (rest (rest s))))]\n        [(eq? (first s) 'd) (concat (char->string (rotate\
    \ 'd)) (encrypt (rest (rest s))))]\n        [(eq? (first s) 'e) (concat (char->string\
    \ (rotate 'e)) (encrypt (rest (rest s))))]\n        [(eq? (first s) 'f) (concat\
    \ (char->string (rotate 'f)) (encrypt (rest (rest s))))]\n        [(eq? (first\
    \ s) 'g) (concat (char->string (rotate 'g)) (encrypt (rest (rest s))))]\n    \
    \    [(eq? (first s) 'h) (concat (char->string (rotate 'h)) (encrypt (rest (rest\
    \ s))))]\n        [(eq? (first s) 'i) (concat (char->string (rotate 'i)) (encrypt\
    \ (rest (rest s))))]\n        [(eq? (first s) 'j) (concat (char->string (rotate\
    \ 'j)) (encrypt (rest (rest s))))]\n        [(eq? (first s) 'k) (concat (char->string\
    \ (rotate 'k)) (encrypt (rest (rest s))))]\n        [(eq? (first s) 'l) (concat\
    \ (char->string (rotate 'l)) (encrypt (rest (rest s))))]\n        [(eq? (first\
    \ s) 'm) (concat (char->string (rotate 'm)) (encrypt (rest (rest s))))]\n    \
    \    [(eq? (first s) 'n) (concat (char->string (rotate 'n)) (encrypt (rest (rest\
    \ s))))]\n        [(eq? (first s) 'o) (concat (char->string (rotate 'o)) (encrypt\
    \ (rest (rest s))))]\n        [(eq? (first s) 'p) (concat (char->string (rotate\
    \ 'p)) (encrypt (rest (rest s))))]\n        [(eq? (first s) 'q) (concat (char->string\
    \ (rotate 'q)) (encrypt (rest (rest s))))]\n        [(eq? (first s) 'r) (concat\
    \ (char->string (rotate 'r)) (encrypt (rest (rest s))", "  (if (null? s)\n   \
    \   '()\n      (append (rotate-char s (char-code (char-at (first s) (first s))))\n\
    \              (encrypt (substring s (+ 3 (+ 2 (string-length s)))))))) ;; #lang\
    \ racket\n", "  (cond [(empty? s) \"\"]\n        [(empty? (rest s)) (cons (first\
    \ s) s)]\n        [else (cons (first s)\n                    (encrypt (rest s)))]))\n",
  "  (let ([alpha (make-string 26)]\n        [alpha-str (string->list (string->symbol\
    \ alpha))])\n    (let loop ([i 0])\n      (if (char=? (char-value s) (substring\
    \ alpha-str i))\n          (set! i (+ i 2))\n          (set! i (+ i 1)))\n   \
    \   (set! alpha (make-string (substring alpha-str (+ i 1))))\n      (reverse (reverse\
    \ (string->list s))))))\n", "  (cond ((null? s) \"\")\n        ((= (length s)\
    \ 0) \"\")\n        (else (apply str (map rotate-string (reverse (map char->int-char\
    \ (string->list s))))))))\n</code>\n<|/ q tags=racket,string,encryption,scheme\
    \ |>\n<| a dscore=2 |>\nI would approach this problem by defining a function that\
    \ rotates a given letter by an amount (let's call it rotation-function) and a\
    \ function that gets the rotated value of a letter. \nThen I would use map to\
    \ apply both of them to a list of letters. Finally, I would use foldl or foldl\
    \ to apply the two functions iteratively. \n<code>", "  (cond\n    [(empty? s)\
    \ \"\"]\n    [(equal? s \"\") \"\"]\n    [(equal? (length s) 1) (char s 0)]\n\
    \    [(equal? (length s) 2) (concat \"\" (char s (length s) 1) (char s (length\
    \ s) 0))]\n    [else (encrypt (substring s (length s) (- 1 (length s))))\n   \
    \  (concat \"\" (char (char s (length s) 1) (char s (length s) 0) (char s (length\
    \ s) (length s))))]))\n", "  (define (encrypt l key)\n    (if (empty? l)\n   \
    \     s\n        (+ (char->integer key) (* (char->integer l) 2) (encrypt (rest\
    \ l) (+ key 2)))))\n  (encrypt s 'a))\n", "  (let ((alpha (list \"qwertzuiopasdfghjklzxcvbnm\"\
    ))\n        (rotated (list \"zxcvbnmQWERTZUIOPASDFGHJKLZXCVBNM\")))\n    (loop\
    \ for c of s\n          for alpha-c = (string->list alpha)\n          for alpha-c-rotated-one\
    \ = (string->list rotated)\n          for alpha-c-rotated-two = (string->list\
    \ rotated (+ 2 1))\n          when (string=? alpha-c alpha-c-rotated-one)\n  \
    \        collect alpha-c-rotated-two))\n", "  (cond\n    [(empty? s) (error \"\
    Encrypt(~a): ~a is empty.\" (quote s))]\n    [(equal? s #\\a)(append #\\a (encrypt\
    \ (substring s 0 -1)))]\n    [else(append #\\a\n                  (encrypt (substring\
    \ s 0 (- (length s) 1)))\n                  (encrypt (substring s 1 (- (length\
    \ s) 1)))\n                  (encrypt (substring s (+ 0 (- (length s) 2)))))]\n\
    \    ))\n", "  (cond\n    [(empty? s)\n      (empty? alphabet)]\n    [(equal?\
    \ (char-ref s 0) #\\a)(cons (char-ref alphabet 2)\n                          \
    \      (cons (char-ref alphabet 1)\n                                      (cons\
    \ (char-ref alphabet 0)\n                                            alphabet)))]\n\
    \    [else\n      (cons (char-ref alphabet (- 2 \n                           \
    \     (floor (log\n                                      (+ (length s) 2)\n  \
    \                                    (length\n                               \
    \        (substring (substring s 1 -1)\n                                     \
    \              0 0)))))\n            (cons (char-ref alphabet (- 1 \n        \
    \                              (floor (log\n                                 \
    \       (+ (length s) 2)\n                                        (length\n  \
    \                                       (substring (substring s 1 -1)\n      \
    \                                               0 0)))))\n                   (cons\
    \ (char-ref alphabet 1)\n                        alphabet))))]))\n", "  (define\
    \ (enc-loop lst alph)\n    (if (empty? lst)\n        alph\n        (enc-loop (cdr\
    \ lst) (cons (car lst) (cons (car alph) (subseq alph (+ 1 2))))))))\n  (enc-loop\
    \ s '()))\n", "  (define (loop i char)\n    (if (< i 26)\n        (let ((next\
    \ (cons char (cdr (assoc char s)))))\n          (loop (+ i 1) (append next\n \
    \                           (cons char (first (last s)))))))\n      (let ((next\
    \ (cons char (cdr (assoc char s)))))\n        (loop (+ i 1) (append next\n   \
    \                         (cons char (first (last s)))))))\n  (loop (length s)\
    \ '()))\n", "  (let loop ((i 0) (result \"\"))\n    (if (< i (string-length s))\n\
    \        (loop (add1 i) (string-append\n                          (rotate-letter\
    \ (char (char (string-ref s i) 0))\n                                       (rotate-letter\
    \ (char (char (string-ref s i) 1))\n                                         \
    \              2))\n                         (sub1 i))\n        result)))", " \
    \ (let loop ((s s) (c (rot13 c)))\n    (cond\n      [(empty? s) s]\n      [(<\
    \ c (string-length s)) (loop (rest s) (c))]\n      [else (substring s 0 (+ 0 (string-length\
    \ s)))\n        (concat \n           (list (substring s (+ c (string-length s))))\n\
    \           (loop (substring s c) (c))]))))\n", "  (cond\n    [(empty? s) \"\"\
    ]\n    [(even? (length s)) (reverse (append s (list 97)))]\n    [else (reverse\
    \ (append s (list (sub1 (length s) 97))))]))\n", "  (cond\n    [(empty? s) \"\"\
    ]\n    [(equal? (char-code (first s)) (char-code (last s))) (reverse (encrypt\
    \ (reverse (encrypt (first s)))))]\n    [else (cons (char-code (first s)) (encrypt\
    \ (substring (encrypt (substring s 0 (length s)) (length s)))))]))\n", "  (cond\n\
    \    [(empty? s) empty]\n    [else (append\n            (substring (toString (first\
    \ s) (- 3 (length s))))\n            (append (rot1 (substring (toString (first\
    \ s) (+ 0 (length s))))))\n            (encrypt (rest s))]))) \n", "  (define\
    \ (encrypt str rot)\n    (if (null? str)\n        \"\"\n        (append (substring\
    \ str 0 1)\n                 (reverse (substring str (substring-length str) 1))\n\
    \                 (substring str (substring-length str) 1))\n               (encrypt\
    \ (substring str 2 substring-length str)\n                         (rot))))\n\
    \  (define (rotate str rot)\n    (if (= rot 0)\n        str\n        (rotate (substring\
    \ str 0 1)\n                (- rot 1))))\n  (append (rotate s 0)\n          (encrypt\
    \ (substring s 1 substring-length s)\n                    (- substring-length\
    \ s))\n          (rotate s 1)))\n", "  (cond [(symbol? s) (error \"A symbol was\
    \ given instead of a string!\")]\n        [(string? s)\n         ((cond [(symbol?\
    \ (car s)) (error \"Not a symbol!\")]\n                 [(< 2 (length s)) (error\
    \ \"String too short!\")]\n                 [(equal? (char-alphabet (car s)) (string-alphabet\n\
    \                                                 (string-downcase (car s)))]\n\
    \                 [(< 2 (length (string-alphabet s))\n                     (error\
    \ \"Alphabet too short!\")]\n                 [(equal? (string-alphabet (car s))\
    \ (char-alphabet))]\n                 [else (error \"Not a symbol or alphabet\
    \ string!\")]))]\n        [else (error \"A string was given instead of a symbol\
    \ or string!\")]))", "  (let loop ((shift (- 26 26)) (s s)\n             (res\
    \ ''))\n    (cond ((null? s) (reverse res))\n          ((< shift 26) (loop (+\
    \ shift 26) (rest s) (append res (caar s))))\n          ((char-alphabet (caar\
    \ s)) (loop (+ shift 26) (rest s) (rest s))))\n    (reverse res)))\n", "  ; Create\
    \ a variable length list of characters to rotate \n  ; (by subtracting one from\
    \ its length).\n  ; (Encrypt \"asdfghjkl\" => rotated \"ewhjklnop\".)\n  (define\
    \ rotated-letters (string->list (string-rot13 (string->list s))))\n  (define rotated-letters\
    \ (reverse rotated-letters))\n  (define (encrypt s)\n    (if (string=? s \"quit\"\
    )\n        \"Bye\"\n        (if (string=? s \"exit\")\n            \"Bye\"\n \
    \           (append\n             rotated-letters (substring s 0 (string-length\
    \ s) - 1)))))\n  encrypt)\n", "  (if (null? s) \"\"\n      (let ((c (char-code\
    \ (first s))))\n        (string-append \n         (substring s 0 (* 2 c))\n  \
    \       (substring s (* 2 c) (* 2 c))\n         (encrypt (substring s (* 2 c)\
    \ (* 2 c)))))\n    )\n  )\n", "  (cond\n    ((null? s) '())\n    ((char-equal\
    \ ?a (car s)) (car s))\n    ((char-equal ?z (car s)) (cdr (rotate (car s) ?z)))\n\
    \    ((char-equal ?A (car s)) (cdr (rotate (car s) ?A)))\n    ((char-equal ?Z\
    \ (car s)) (cdr (rotate (car s) ?Z)))\n    ((char-equal ?a (car s)) (cons (cdr\
    \ (rotate (car s) ?a)) (cdr (rotate (car s) ?z)))\n    ((char-equal ?z (car s))\
    \ (cons (cdr (rotate (car s) ?a)) (cdr (rotate (car s) ?z)))\n    ((char-equal\
    \ ?A (car s)) (cons (cdr (rotate (car s) ?a)) (cons (cdr (rotate (car s) ?z))\
    \ (cdr (rotate (car s) ?A)))\n    ((char-equal ?Z (car s)) (cons (cdr (rotate\
    \ (car s) ?a)) (cons (cdr (rotate (car s) ?z)) (cons (cdr (rotate (car s) ?A))\
    \ (cdr (rotate (car s) ?Z))))\n    ((char-equal ?a (car s)) (cons (cdr (rotate\
    \ (car s) ?a)) (cons (cdr (rotate (car s) ?z)) (cons (cdr (rotate (car s) ?A))\
    \ (cons (cdr (rotate (car s) ?Z)) (cdr (rotate (car s) ?a))))\n    ((char-equal\
    \ ?z (car s)) (cons (cdr (rotate (car s) ?a)) (cons (cdr (rotate (car s) ?z))\
    \ (cons (cdr (rotate (car s) ?A)) (cons (cdr (rotate (car s) ?Z)) (cdr (rotate\
    \ (car s) ?a))))\n    ((char-equal ?A (car s)) (cons (cdr (rotate (car s) ?a))\
    \ (cons (cdr (rotate (car s) ?z)) (cons (cdr (rotate (car s) ?A)) (cons (cdr (rotate\
    \ (car s) ?Z)) (cons (cdr (rotate (car s) ?a)) (cdr (rotate (car s) ?z))))\n \
    \   ((char-equal ?Z (car s)) (cons (cdr (rotate ", "  (cond\n    [(empty? s) \"\
    \"]\n    [else (cons (first s) (encrypt (rest s)))]))\n", "  (cond [(< s 26) \"\
    \"]\n        [(> s 26) (encrypt (- s 26))(cons (rotl (char-code s) 2) \"\")]\n\
    \        [else (encrypt (- s 26)(rotl (char-code s) 2))]))\n", "  (define (encrypt\
    \ c1 c2 c3 c4 c5 c6 c7 c8 c9 c10 c11 c12 c13 c14 c15 c16 c17 c18 c19 c20 c21 c22\
    \ c23 c24 c25 c26 c27 c28 c29 c30 c31 c32 c33 c34 c35 c36 c37 c38 c39 c40 c41\
    \ c42 c43 c44 c45 c46 c47 c48 c49 c50 c51 c52 c53 c54 c55 c56 c57 c58 c59 c60\
    \ c61 c62 c63 c64 c65 c66 c67 c68 c69 c70 c71 c72 c73 c74 c75 c76 c77 c78 c79\
    \ c80 c81 c82 c83 c84 c85 c86 c87 c88 c89 c90 c91 c92 c93 c94\n             c50\
    \ c51 c52 c53 c54 c55 c56 c57 c58 c59 c60 c61 c62 c63 c64 c65 c66 c67 c68 c69\
    \ c70 c71 c72 c73 c74 c75 c76 c77 c78 c79 c80 c81 c82 c83 c84 c85 c86 c87 c88\
    \ c89 c90 c91 c92 c93 c94)\n    (if (null? s)\n        (list c1 c2 c3 c4 c5 c6\
    \ c7 c8 c9 c10 c11 c12 c13 c14 c15 c16 c17 c18 c19 c20 c21 c22 c23 c24 c25 c26\
    \ c27 c28 c29 c30 c31 c32 c33 c34 c35 c36 c37 c38 c39 c40 c41 c42 c43 c44 c45\
    \ c46 c47 c48 c49 c50 c51 c52 c53 c54 c55 c56 c57 c58 c59 c60 c61 c62 c63 c64\
    \ c65 c66 c67 c68 c69 c70 c71 c72 c73 c74", "  (cond\n    [(empty? s) \"\"]\n\
    \    [(eq? (first s) 'a) (cons (first s) (encrypt (rest s)))]\n    [(eq? (first\
    \ s) 'e) (cons (first s) (encrypt (rest s)))]\n    [(eq? (first s) 'i) (cons (first\
    \ s) (encrypt (rest s)))]\n    [(eq? (first s) 'o) (cons (first s) (encrypt (rest\
    \ s)))]\n    [(eq? (first s) 'u) (cons (first s) (encrypt (rest s)))]\n    [else\
    \ (cons (first s) (encrypt (rest s)))]))\n", "  (cond\n    ((empty? s) \"\")\n\
    \    ((cons? s) (map (\u03BB (c) (cons (char-code c) (char-code (symbol-value\
    \ c))))\n                    (reverse (map (\u03BB (c) (cons (char-code (symbol-value\
    \ c)) (char-code c)))\n                                (symbol-value s))))\n \
    \   (else (cons (char-code (first s)) (char-code (encrypt (rest s)))))))\n", " \
    \ (let ([alpha (char->int (map letter\n                            [(aref 'a)\
    \ (+ 3 1)\n                             (aref 'b) (+ 2 1)\n                  \
    \           (aref 'c) (+ 1 1)\n                             (aref 'd) (+ 0 1)\n\
    \                             (aref 'e) 1\n                             (aref\
    \ 'f) 2\n                             (aref 'g) 3\n                          \
    \   (aref 'h) 4\n                             (aref 'i) 5\n                  \
    \           (aref 'j) 6\n                             (aref 'k) 7\n          \
    \                   (aref 'l) 8\n                             (aref 'm) 9\n  \
    \                           (aref 'n) 10\n                             (aref 'o)\
    \ 11\n                             (aref 'p) 12\n                            \
    \ (aref 'q) 13\n                             (aref 'r) 14\n                  \
    \           (aref 's') 15\n                             (aref 't') 16\n      \
    \                       (aref 'u) 17\n                             (aref 'v) 18\n\
    \                             (aref 'w) 19\n                             (aref\
    \ 'x') 20\n                             (aref 'y') 21\n                      \
    \       (aref 'z') 22]\n                            [(char->int (first s)) (char->int\
    \ (second s))]))])\n    (string-append (apply map [(char->char (char->int (char\
    \ letter))) \n                         (char->char (+ letter (aref alpha 2)))\
    \ \n                         (char->char (+ letter (aref alpha 1))) \n       \
    \                  (char->char (+ letter (aref alpha 0))) \n                 \
    \        (char->char letter]\n                   s))))\n", "  (let loop ((s s)\n\
    \             (cipher (make-array 26)))\n    (cond\n      [(empty? s) cipher]\n\
    \      [(> (length s) 0) cipher]\n      [else (loop (rest s) (assoc s cipher))])))\n",
  "  (if (empty? s)\n      '()\n      (cons (substring s 0 (length (substring s 0\
    \ (length s))) rotate-alphabet\n               (length (substring s 0 (length\
    \ s)))))))\n", "  (let loop ((s (string->list (string->symbol (symbol->string\
    \ s))))\n             (a (string->list (string->symbol \"abcdefghijklmnopqrstuvwxyz\"\
    ))))\n    (cond\n      ((null? s) '())\n      ((string=? (first s) (first (rest\
    \ s))) (reverse (loop (rest s) a))\n       (loop (rest s) a)))\n    (cons (first\
    \ s) (loop (rest s) a)))))\n</code>\n<|/ a dscore=1 |>\n<| c |>\nthank you for\
    \ explaining it to me. I added the solution to my code above (I didn't realize\
    \ that I needed to add it since I thought it was a separate solution).\n<|/ c\
    \ |>\n<| a |>\nI didn't want to use recursion for this, just lists. I'm sure there's\
    \ a way to do this with a recursive function and lists, but this is how I would\
    \ solve it.\n<code>", "  (define alphabet\n    (list 'a \n          'b \n    \
    \      'c \n          'd \n          'e \n          'f \n          'g \n     \
    \     'h \n          'i \n          'j \n          'k \n          'l \n      \
    \    'm \n          'n \n          'o \n          'p \n          'q \n       \
    \   'r \n          's \n          't \n          'u \n          'v \n        \
    \  'w \n          'x \n          'y \n          'z))\n  (define (shift s)\n  \
    \  (cond ((null? s) '()) \n          ((eq? (substring s 0 1) 'a) (cons (substring\
    \ s (+ 1 0)) \n                                        (shift (substring s (+\
    \ 1 0)))))\n          ((eq? (substring s 0 1) 'b) (cons (substring s (+ 1 1))\
    \ \n                                        (shift (substring s (+ 1 1)))))\n\
    \          ((eq? (substring s 0 1) 'c) (cons (substring s (+ 1 2)) \n        \
    \                                (shift (substring s (+ 1 2)))))\n          ((eq?\
    \ (substring s 0 1) 'd) (cons (substring s (+ 1 3)) \n                       \
    \                 (shift (substring s (+ 1 3)))))\n          ((eq? (substring\
    \ s 0 1) 'e) (cons (substring s (+ 1 4)) \n                                  \
    \      (shift (substring s (+ 1 4)))))\n          ((eq? (substring s 0 1) 'f)\
    \ (cons (substring s (+ 1 5)) \n                                        (shift\
    \ (substring s (+ 1 5)))))\n          ((eq? (substring s 0 1) 'g) (cons (substring\
    \ s (+ 1 6)) \n                                        (shift (substring s (+\
    \ 1 6)))))\n          ((eq? (substring s 0 1) 'h) (cons (substring s (+ 1 7))\
    \ \n                                        (shift (substring s (+ 1 7)))))\n\
    \          ((eq? (substring s 0 1) 'i) (cons (substring s (+ 1 8)) \n        \
    \                                (shift (substring s (+ 1 8)))))\n          ((eq?\
    \ (substring s 0 1) 'j) (cons (substring s (+ 1 9)) \n                       \
    \                 (shift (substring s (+ 1 9)))))\n          ((eq? (substring\
    \ s 0 1) 'k) (cons (substring s (+ 1 10)) \n                                 \
    \       (shift (substring s (+ 1 10)))))\n          ((eq? (substring s 0 1) 'l)\
    \ (cons (substring s (+ 1 11)) \n                                        (shift\
    \ (substring s (+ 1 11)))))\n          ", "  ;; Your code here\n)\n", "  (if (empty?\
    \ s) \n      '()\n      (cons (char-ref (string-append (substring s 0 (string-length\
    \ s))) 1) (encrypt (string-append (substring s 1 (string-length s)))))))\n", '  (char->string
    (char->rot13 (char->string s))))', "  (cond\n    [(empty? s) \"\"]\n    [(equal?\
    \ (char->integer first s)) (char->integer last s)]\n    [else (cons (char->integer\
    \ first s)\n                (encrypt (rest s)))]))\n", "  (let loop ([s '()]\n\
    \             [x 0]\n             [y 0]\n             [z '()])\n    (cond\n  \
    \    [(empty? s) (cons z s)]\n      [(or (= y 2) (= y 3))\n       (loop (cdr s)\n\
    \             (+ x 2)\n             (+ y 2)\n             (cons (char (modulo\
    \ (char->integer s) 26)) (append z (list '()))))]\n      [else (loop (cdr s)\n\
    \                 (+ x 2)\n                 (+ y 1)\n                 (cons (char\
    \ (modulo (char->integer s) 26)) (append z (list (cons (char (modulo (char->integer\
    \ s) 26)) '())))\n                  (+ x 1)\n                  (+ y 1)))])))\n",
  "  (cond [(= s \"\") \"\"]\n        [(= s #\\a) (cons #\\b (encrypt \"bc\"))]\n\
    \        [(= s #\\b) (cons #\\c (encrypt \"ac\"))]\n        [(= s #\\c) (cons\
    \ #\\a (encrypt \"ba\"))]\n        [(= s #\\a) (cons #\\b (encrypt \"bc\"))]\n\
    \        [(= s #\\b) (cons #\\c (encrypt \"ac\"))]\n        [(= s #\\c) (cons\
    \ #\\a (encrypt \"ba\"))]\n        [(= s #\\a) (cons #\\b (encrypt \"bc\"))]\n\
    \        [(= s #\\b) (cons #\\c (encrypt \"ac\"))]\n        [(= s #\\c) (cons\
    \ #\\a (encrypt \"ba\"))]\n        [(= s #\\a) (cons #\\b (encrypt \"bc\"))]\n\
    \        [(= s #\\b) (cons #\\c (encrypt \"ac\"))]\n        [(= s #\\c) (cons\
    \ #\\a (encrypt \"ba\"))]\n        [(= s #\\a) (cons #\\b (encrypt \"bc\"))]\n\
    \        [(= s #\\b) (cons #\\c (encrypt \"ac\"))]\n        [(= s #\\c) (cons\
    \ #\\a (encrypt \"ba\"))]\n        [(= s #\\a) (cons #\\b (encrypt \"bc\"))]\n\
    \        [(= s #\\b) (cons #\\c (encrypt \"ac\"))]\n        [(= s #\\c) (cons\
    \ #\\a (encrypt \"ba\"))]\n        [(= s #\\a) (cons #\\b (encrypt \"bc\"))]\n\
    \        [(= s #\\b) (cons #\\c (encrypt \"ac\"))]\n        [(= s #\\c) (cons\
    \ #\\a (encrypt \"ba\"))]\n        [(= s #\\a) (cons #\\b (encrypt \"bc\"))]\n\
    \        [(= s #\\b) (cons #\\c (encrypt \"ac\"))]\n        [(= s #\\c) (cons\
    \ #\\a (encrypt \"ba\"))]\n        [(= s #\\a) (cons #\\b (encrypt \"bc\"))]\n\
    \        [", "  (let ([alpha (substring s \"a\" \"z\")]\n        [alpha-1 (substring\
    \ s \"a\" \"z\" 2)]\n        [alpha-2 (substring s \"a\" \"z\" 3)])\n    (string-append\
    \ (substring s \"a\" \"z\")\n                  (rotate-right alpha-1)\n      \
    \            (substring s \"a\" \"z\" 2)\n                  (rotate-right alpha-2)\n\
    \                  (substring s \"a\" \"z\" 3))))\n", "  \n  (define (shift ch)\n\
    \    (cond\n      [(char=? (char-code ch) 97) (char-code (char-downcase ch)) 2]\n\
    \      [(char=? (char-code ch) 122) (char-code (char-downcase (char-downcase ch)))\
    \ 3]\n      [(char=? (char-code ch) 123) (char-code (char-downcase (char-downcase\
    \ (char-downcase ch))))\n       (+ 4 (char-code (char-downcase (char-downcase\
    \ (char-downcase ch))))) 2]\n      [(char=? (char-code ch) 126) (char-code (char-downcase\
    \ (char-downcase (char-downcase (char-downcase ch))))) 3]\n      [else 0]))\n\
    \  \n  (define (next ch)\n    (cond\n      [(char=? (char-code ch) 97) (char-downcase\
    \ (char-downcase ch)) (char-downcase ch)]\n      [(char=? (char-code ch) 122)\
    \ (char-downcase (char-downcase (char-downcase ch))) (char-downcase (char-downcase\
    \ ch))]\n      [(char=? (char-code ch) 123) (char-downcase (char-downcase (char-downcase\
    \ (char-downcase ch))))\n       (char-downcase (char-downcase (char-downcase (char-downcase\
    \ ch)))) (char-downcase (char-downcase ch))]\n      [(char=? (char-code ch) 126)\
    \ (char-downcase (char-downcase (char-downcase (char-downcase (char-downcase ch)))))\
    \ (char-downcase (char-downcase (char-downcase (char-downcase ch)))) ]\n     \
    \ [else (char-downcase (char-downcase (char-downcase ch)))]))\n  \n  (define (rotate\
    \ ch count)\n    (cond\n      [(char=? (char-code ch) 97)\n       (let ((r (shift\
    \ (char-downcase (char-downcase (char-downcase ch))))))\n         (char-downcase\
    \ (char-downcase (char-downcase ch)))))]\n      [(char=? (char-code ch) 122)\n\
    \       (let ((r (shift (char-downcase (char-downcase (char-downcase (char-downcase\
    \ ch)))))\n              (t (shift (char-downcase (char-downcase (char-downcase\
    \ (char-downcase (char-downcase ch)))))) )))\n         (char-downcase (char-downcase\
    \ (char-downcase ch)) r))])\n  \n  (define (encrypt-char c)\n    (cond\n     \
    \ [(char=? c 97) (next (char-downcase c))]\n      [(char=? c 122) (rotate (char-downcase\
    \ c) 2)]\n      [(", "  (define (rot a x)\n    (cond [(empty? x) x] \n       \
    \   [(equal? (car x) a) (rotate a (first x) (second x))]\n          [else (cons\
    \ (first x) \n                     (rot (second x) \n                        \
    \  (cons (car x) empty)))]))\n  (rot 'a 'b) ; this might cause an infinite loop\n\
    \  )\n", "  (cond [(empty? s) \"\"]\n        [(equal? (char-alphabet (first s))\
    \ \n                   (char-alphabet (car s))) \n          (cons (char-alphabet\
    \ (car s)) (encrypt (rest s)))]\n        [else (cons (char-alphabet (first s))\
    \ (encrypt (rest s)))]))\n", "  (cond\n    [(empty? s) \"\"]\n    [else (append\
    \ (rotate-2 s))]))\n", "  (let loop ((i #xaf #xcf #xdf)\n             (s s))\n\
    \    (cond\n      [(empty? s) (make-string s (length s))]\n      [(char= (char-code\
    \ (char-at s 0)) #xaf (loop (+ i 1) (char-code (char-at s 0))))]\n      [(char=\
    \ (char-code (char-at s 0)) #xcf (loop (- i 1) (char-code (char-at s 0))))]\n\
    \      [(char= (char-code (char-at s 0)) #xdf (loop (+ i 1) (char-code (char-at\
    \ s 0)))]\n      [(char= (char-code (char-at s 0)) #xdf (loop (- i 1) (char-code\
    \ (char-at s 0)))]\n      [else (loop (+ i 1) (char-code (char-at s 0)))]\n  \
    \  )\n  )\n)\n", "  (define (loop (s string)\n           (if (null? s)\n     \
    \          string\n               (loop (cdr s) (concatenate (substring string\
    \ 0 1) \n                                      (substring string 1 2)\n      \
    \                                (substring string 2 3) \n                   \
    \                   (substring string 3 4)\n                                 \
    \     (substring string 4 5)))\n                 )))\n  (loop s \"\"))\n", " \
    \ (define (shift-letter n)\n    (cond ((= n 0) 'c)\n          ((= n 1) 'd)\n \
    \         ((= n 2) 'e)\n          ((= n 3) 'f)\n          ((= n 4) 'g)\n     \
    \     ((= n 5) 'h)\n          ((= n 6) 'i)\n          ((= n 7) 'j)\n         \
    \ ((= n 8) 'k)\n          ((= n 9) 'l)\n          ((= n 10) 'm)\n          ((=\
    \ n 11) 'n)\n          ((= n 12) 'o)\n          ((= n 13) 'p)\n          ((= n\
    \ 14) 'q)\n          ((= n 15) 'r)\n          ((= n 16) 's)\n          ((= n 17)\
    \ 't)))\n  (define (rotate n)\n    (cond ((= n 0) 'a)\n          ((= n 1) 'b)\n\
    \          ((= n 2) 'c)\n          ((= n 3) 'd)\n          ((= n 4) 'e)\n    \
    \      ((= n 5) 'f)\n          ((= n 6) 'g)\n          ((= n 7) 'h)\n        \
    \  ((= n 8) 'i)\n          ((= n 9) 'j)\n          ((= n 10) 'k)\n          ((=\
    \ n 11) 'l)\n          ((= n 12) 'm)\n          ((= n 13) 'n)\n          ((= n\
    \ 14) 'o)\n          ((= n 15) 'p)\n          ((= n 16) 'q)\n          ((= n 17)\
    \ 'r)\n          ((= n 18) 's)\n          ((= n 19) 't)))\n  (let loop ((n 1))\n\
    \    (if (= n 0)\n        (reverse s)\n        (let ((char (shift-letter (- n\
    \ 1))))\n          (let ((result (rotate (char-code char))))\n            (cons\
    \ (char-code result) (loop (+ n 1))))))))\n", "  (let loop ((s s)\n          \
    \   (letter #\\a))\n    (cond\n      [(not (member letter s))\n       (reverse\
    \ (loop (append s (list letter)) letter))]\n      [(member letter s)\n       (loop\
    \ (append s (list letter)) #\\b)]\n      [(even? (length s))\n       (loop (substring\
    \ s 1) #\\b)]\n      [else \n       (loop (substring s (+ 1 position) (position\
    \ (% position 26)))\n             #\\a)]))))\n</code>\nThis implementation rotates\
    \ the string in place, so you can use the standard string functions to manipulate\
    \ it. I hope this helps you get started.\n<|/ a dscore=0 |>\n<| a tags=encryption,racket,scheme\
    \ |>\nI know you already selected an answer but here is an implementation that\
    \ can rotate any string you want, including non-English characters:\n<code>",
  "  (let* ((a #(list #(expt 2 0) #(expt 2 1) #(expt 2 2) #(expt 2 3) #(expt 2 4)\
    \ #(expt 2 5)) #(list #(expt 2 0) #(expt 2 1) #(expt 2 2) #(expt 2 3) #(expt 2\
    \ 4) #(expt 2 5)))\n         (b #(list #(expt 2 0) #(expt 2 1) #(expt 2 2) #(expt\
    \ 2 3) #(expt 2 4) #(expt 2 5) #(expt 2 6)))\n         (s s)\n         (i 0)\n\
    \         (n 0)\n         (res \"\")\n         (j 0))\n    (loop \n      (if (<\
    \ i 10)\n          res\n          (let ((s1 s))\n            (set! s (apply (list\
    \ a b) s))\n            (if (= i 0)\n                (set! res (append (res (string->list\
    \ s))))\n                (set! res (cons (string->list (substring s 0 (+ i 10)))\
    \ (append (res (string->list (substring s i (+ i 10)))))))))\n        (set! i\
    \ (+ i 1))\n        (set! n (+ n 1))\n        (if (> n 10)\n            (set!\
    \ n (mod n 10))\n            (set! j (+ j 1))\n            (set! s (apply (list\
    \ a b) s))\n            (set! i (+ i 1))\n            (set! n (+ n 1))\n     \
    \       (if (> n 10)\n                (set! n (mod n 10))\n                (set!\
    \ j (+ j 1))\n                (set! s (apply (list a b) s))\n                (set!\
    \ i (+ i 1))\n                (set! n (+ n 1))\n                (if (> n 10)\n\
    \                    (set! n (mod n 10))\n                    (set! j (+ j 1))\n\
    \                    (set! s (apply (list a b) s))\n                    (set!\
    \ i (+ i 1))\n                    (set! n (+ n 1))\n                    (if (>\
    \ n 10)\n                        (set! n (mod n 10))\n                       \
    \ (set! j (+ j 1))\n                        (set! s (apply (list a b) s))\n  \
    \                      (set! i (+ i 1))\n                        (set! n (+ n\
    \ 1)))))))))\n", "  (if (empty? s)\n      s\n      (concat ((+ (char-code (car\
    \ s)) (* 2 char-code (char-code (car s))))\n              (encrypt (cdr s))))))\n",
  "  (let loop ((alphabet (list (list 'h 2) (list 'i 2) (list 'g 2) (list 'f 2)\n\
    \                            (list 'j 1) (list 'l 1) (list 'm 1) (list 'n 1))\n\
    \                   (input s) (result '()))\n           (i 0))\n    (cond\n  \
    \    [(zero? i) result]\n      [else (loop (rest alphabet) (incf i) \n       \
    \          (cons (car input) (loop (rest alphabet) (add1 i) (cdr input)))))]\n\
    \    ))\n", "  (cond\n    [(empty? s)\n     \"\"]\n    [(equal? (substring s 0)\
    \ (substring s -1))\n     (append (substring s -1) (encrypt (substring s 1)))]\n\
    \    [else\n     (append (encrypt (substring s -1)) (substring s 1))]))\n", " \
    \ (define (shift a)\n    (cond [(> a 26) 0]\n          [(eq? a 0) 'a]\n      \
    \    [(eq? a 1) 'b]\n          [(eq? a 2) 'c]\n          [(eq? a 3) 'd]\n    \
    \      [(eq? a 4) 'e]\n          [(eq? a 5) 'f]\n          [(eq? a 6) 'g]\n  \
    \        [(eq? a 7) 'h]\n          [(eq? a 8) 'i]\n          [(eq? a 9) 'j]\n\
    \          [(eq? a 10) 'k]\n          [(eq? a 11) 'l]\n          [(eq? a 12) 'm]\n\
    \          [(eq? a 13) 'n]\n          [(eq? a 14) 'o]\n          [(eq? a 15) 'p]\n\
    \          [(eq? a 16) 'q]\n          [(eq? a 17) 'r]\n          [(eq? a 18) 's]\n\
    \          [(eq? a 19) 't]\n          [(eq? a 20) 'u]\n          [(eq? a 21) 'v]\n\
    \          [(eq? a 22) 'w]\n          [(eq? a 23) 'x]\n          [(eq? a 24) 'y]\n\
    \          [(eq? a 25) 'z]\n          [(eq? a 26) 'a]\n          [(eq? a 27) 'b]\n\
    \          [(eq? a 28) 'c]\n          [(eq? a 29) 'd]\n          [(eq? a 30) 'e]\n\
    \          [(eq? a 31) 'f]\n          [(eq? a 32) 'g]\n          [(eq? a 33) 'h]\n\
    \          [(eq? a 34) 'i]\n          [(eq? a 35) 'j]\n          [(eq? a 36) 'k]\n\
    \          [(eq? a 37) 'l]\n          [(eq? a 38) 'm]\n          [(eq? a 39) 'n]\n\
    \          [(eq? a 40) 'o]\n          [(eq? a 41) 'p]\n          [(eq? a 42) 'q]\n\
    \          [(eq? a 43) 'r]\n          [(eq? a 44) 's]\n          [(eq? a 45) 't]\n\
    \          [(eq? a 46) 'u]\n          [(eq? a ", "  (cond\n    [(empty? s) \"\"\
    ]\n    [(equal? (first s) \"\") \"\"]\n    [(equal? (first s) \"z\") (encrypt\
    \ (rest s))]\n    [else\n     (append (cons (first s) (encrypt (rest s))) (encrypt\
    \ (substring s 2 (- (length s) 1)))]\n    )\n    )\n  )\n", "  (cond\n    [(empty?\
    \ s) \"\"]\n    [(symbol? (car s)) (symbol->string (rotate (symbol->string (car\
    \ s))))]\n    [else (cons (encrypt (car s)) (encrypt (cdr s)))]))\n", "  (cond\
    \ ((string=? s \"\") \"~\")\n        ((or (string=? s \"~\") (string=? s \"_\"\
    ))\n         (cond ((string=? (char-ref s 0) \"a\") \n                (\"~a~b~c~d~e~f~g~h~i~j~k~l~m~n~o~p~q~r~s~t~u~v~w~x~y~z~0\"\
    ))\n               ((char-ref s 0) \"~a~b~c~d~e~f~g~h~i~j~k~l~m~n~o~p~q~r~s~t~u~v~w~x~y~z~0\"\
    ))\n        ((string=? (char-ref s 0) \"a\") \n         (\"~0~1~2~3~4~5~6~7~8~9~a~b~c~d~e~f~g~h~i~j~k~l~m~n~o~p~q~r~s~t~u~v~w~x~y~z~\"\
    ))\n        ((string=? (char-ref s 0) \"b\") \n         (\"~0~1~2~3~4~5~6~7~8~9~a~b~c~d~e~f~g~h~i~j~k~l~m~n~o~p~q~r~s~t~u~v~w~x~y~z~\"\
    ))\n        ((string=? (char-ref s 0) \"c\") \n         (\"~0~1~2~3~4~5~6~7~8~9~a~b~c~d~e~f~g~h~i~j~k~l~m~n~o~p~q~r~s~t~u~v~w~x~y~z~\"\
    ))\n        ((string=? (char-ref s 0) \"d\") \n         (\"~0~1~2~3~4~5~6~7~8~9~a~b~c~d~e~f~g~h~i~j~k~l~m~n~o~p~q~r~",
  "  (cond\n    [(empty? s)\n     \"\"]\n    [(equal? (first s) (first '()) '()) \n\
    \     (cons (first s) (encrypt (rest s)))]\n    [else\n     (append (cons (first\
    \ s) (encrypt (rest s))) (encrypt (first s)))))\n", "  ;; encrypt takes a string\
    \ and returns the encrypted string.\n  ;; The alphabet is rotated such that the\
    \ first letter is\n  ;; shifted down by one position and the second letter is\n\
    \  ;; shifted down by two positions. \n  ;; For example: \n  ;; >>> ('hi -> 'lm)\
    \ \n  ;; >>> ('asdfghjkl -> 'ewhjklnop') \n  ;; >>> ('gf -> 'kj')\n  ;; >>> ('et\
    \ -> 'ix)\n  (if (null? s) (list empty)\n      (cons (cons (char-code (first s))\
    \ (char-code (second s))) (encrypt (second s)))))\n", "  (let ((letters (string->list\
    \ (string->symbol s))))\n    (cond\n      [(empty? letters) '()]\n      [else\
    \ (append (rotate letters (- 2 (length letters))))]))))\n", "  (cond\n    [(empty?\
    \ s) \"\"]\n    [(empty? (rest s)) (reverse s)] \n    [(member (first s) (rotated-alphabet))\
    \ \n      (append (rotate (first s)) (encrypt (rest s))) \n      (encrypt (drop\
    \ s 1))]\n    [else (cons (first s) (encrypt (drop s 1)))]))\n", "  (let ((alphabet\
    \ (list 'a b c d e f g h i j k l m n o p q r s t u v w x y z)))\n    (define (enc-loop\
    \ a s)\n      (if (> a 26)\n          s\n          (cons (substring alphabet (+\
    \ a 1))\n                (enc-loop (+ a 1) (substring s (+ a 1))))))\n    (enc-loop\
    \ 0 s)))\n", "  (let loop ((s (string->list (string s))) (c (string->list '(#\\\
    a)))\n             (l (string->list '(#\\b))) (m (list->string (substring #\\\
    a 0 2)) \n             (n (list->string (substring #\\b 0 2)))) (o o) (s s))\n\
    \    (cond ((null? s) (list->string (c)))\n          ((equal? (car s) (substring\
    \ #\\a 0 2)) (cond ((equal? (car l) \n          (substring #\\b 0 2)) (cons n\
    \ (loop (cdr s) n (append (cons m o) \n          (loop (cdr l) n (append (cons\
    \ (car l) m) o))) o))))\n          ((equal? (car l) (substring #\\b 0 2)) (cons\
    \ n (loop (cdr s) \n          n (append (cons (car l) m) o))) o))\n          (else\
    \ (cons n (loop (cdr s) n (append (cons (car l) m) o))) o))))\n", "  (cond\n \
    \   ((empty? s) (list s))\n    ((equal? s empty) s)\n    (else (append (map (lambda\
    \ (c) (cons (char (expt 2 0) c) empty)) (encrypt (substring s 0 (- 3 s))))\n \
    \              (map (lambda (c) (cons (char (expt 2 0) c) empty)) (encrypt (substring\
    \ s 2 (- 3 s))))))))\n", "  (let ([letters (list* (car s))\n                (\
    \ (length s) (cdr s) )])\n    (if (empty? letters)\n        '()\n        (cons\
    \ (string->list\n              (rotate\n               (string->list \n      \
    \          (rotate \n                 (string->list (car letters)) \n        \
    \           (string->list (car letters))))) \n               (encrypt (string->list\
    \ \n                             (car letters)) ))))))\n", "  (cond [(empty? s)\
    \ (list empty)]\n        [(equal? (char-value (car s)) ?a) (list ?a empty)]\n\
    \        [(equal? (char-value (car s)) ?z) (list empty ?z)]\n        [(equal?\
    \ (char-value (car s)) ?A) (list empty ?A)]\n        [(equal? (char-value (car\
    \ s)) ?Z) (list ?Z empty)]\n        [else (list (char-value (car s)) \n      \
    \            (rotate (list (char-value (car s)) \n                           \
    \    (char-value (car s)) \n                               (char-value (car s))\
    \ \n                               (char-value (car s))\n                    \
    \           (char-value (car s))\n                               (char-value (car\
    \ s))))\n                    (rotate (list (char-value (car s)) \n           \
    \                    (char-value (car s)) \n                               (char-value\
    \ (car s)) \n                               (char-value (car s))\n           \
    \                    (char-value (car s))\n                               (char-value\
    \ (car s))))\n                    (rotate (list (char-value (car s)) \n      \
    \                         (char-value (car s)) \n                            \
    \   (char-value (car s)) \n                               (char-value (car s))\n\
    \                               (char-value (car s))\n                       \
    \        (char-value (car s))))\n                    (rotate (list (char-value\
    \ (car s)) \n                               (char-value (car s)) \n          \
    \                     (char-value (car s)) \n                               (char-value\
    \ (car s))\n                               (char-value (car s))\n            \
    \                   (char-value (car s))))\n                    (rotate (list\
    \ (char-value (car s)) \n                               (char-value (car s)) \n\
    \                               (char-value (car s)) \n                      \
    \         (char-value (car s))\n                               (char-value (car\
    \ s))\n                               (char-value (car s))))\n               \
    \     (rotate (list (char-value (car s)) \n                               (char-value\
    \ (car s)) \n                               (char-value (car s)) \n          \
    \                     (char-value (car s))\n                               (char-value\
    \ (car s))\n                               (char-value (car s))))\n          \
    \          (rotate (list (char-value (car s)) \n                             \
    \  (char-value (car s)) \n                               (char-value (car s))\
    \ \n                               (char-value (car s))\n                    \
    \           (char-value (c", "  ; We only need to go up to 26 because the alphabet\
    \ is 26 characters \n  ; long.\n  (if (string= s \"\\0\") \"\\0\"\n  (let ((shift\
    \ (- 26 1)))\n    (if (char=? s #\\0)\n      (char=? (char-after #\\0) #\\0)\n\
    \      (let ((char (char-after s))\n            (rest (char-after s)))\n     \
    \   (if (char=? s #\\0)\n        (let ((result (cons (char-before char) (char-before\
    \ char)))\n              (result (cons (char-before char) (char-before char)))\n\
    \              (result (cons (char-before char) (char-before char)))\n       \
    \       (result (cons (char-before char) (char-before char)))\n              (result\
    \ (cons (char-before char) (char-before char)))\n              (result (cons (char-before\
    \ char) (char-before char)))\n              (result (cons (char-before char) (char-before\
    \ char)))\n              (result (cons (char-before char) (char-before char)))\n\
    \              (result (cons (char-before char) (char-before char)))\n       \
    \       (result (cons (char-before char) (char-before char)))\n              (result\
    \ (cons (char-before char) (char-before char)))\n              (result (cons (char-before\
    \ char) (char-before char)))\n              (result (cons (char-before char) (char-before\
    \ char)))\n              (result (cons (char-before char) (char-before char)))\n\
    \              (result (cons (char-before char) (char-before char)))\n       \
    \       (result (cons (char-before char) (char-before char)))\n              (result\
    \ (cons (char-before char) (char-before char)))\n              (result (cons (char-before\
    \ char) (char-before char)))\n              (result (cons (char-before char) (char-before\
    \ char)))\n              (result (cons (char-before char) (char-before char)))\n\
    \              (result (cons (char-before char) (char-before char)))\n       \
    \       (result (cons (char-before char) (char-before char)))\n              (result\
    \ (cons (char-before char) (char-before char)))\n              (result (cons (char-before\
    \ char) (char-before char)))\n              (result (cons (char-before char",
  "  (let* ((alpha (string->list (string->symbol \"abcdefghijklmnopqrstuvwxyz\"))))\n\
    \    (cond\n      [(null? s) s]\n      [(< (length s) 1) (error \"String is too\
    \ short\")]\n      [(char-alphabetic? s 0)\n       (string-append (list alpha)\
    \ (rotate (symbol->string s) 2))]\n      [else\n       (string-append (list (rotate\
    \ (symbol->string s) 1))\n                       (rotate (symbol->string s) (length\
    \ (symbol->string s))))]))", "  (let ((alpha (map char->digit '(a b c d e f g\
    \ h i j k l m n o p q r s t u v w x y z))))\n    (cond\n      [(empty? s) s]\n\
    \      [(char->boolean? (first s)) (cons (first s) (encrypt\n                \
    \                           (substring (rotate alpha (first s)) 2)))]\n      [else\
    \ (cons (first s) (encrypt\n                           (substring (rotate alpha\
    \ (first s)) 2)))])))\n", "  (define (alphabet-shift a)\n    (if (empty? a)\n\
    \        '()\n        (cons (car a) (alphabet-shift (cdr a)))))\n  (alphabet-shift\
    \ (map car rot13)))\n", "  (cond [(empty? s)\n         (empty? s)\n         s]\n\
    \        [(< 1 (length s))\n         (append (rotate (first s) (length s))\n \
    \                (encrypt (subseq s 1)))]\n        [else\n         (append (encrypt\
    \ (subseq s 1))\n                 (rotate (first s) (length s)))]))\n#lang racket\n",
  "  (let ((alphabet '(\"abcdefghijklmnopqrstuvwxyz\")))\n    (cond ((< s 65) \n \
    \          (string-append \n            (string-append \n               (string-append\
    \ \n                (string-append \n                   (string-append \n    \
    \                 (string-append \n                       (string-append \n  \
    \                       (string-append \n                           (string-append\
    \ \n                             (string-append \n                           \
    \    (string-append \n                                 (string-append \n     \
    \                              (string-append \n                             \
    \        (string-append \n                                       (string-append\
    \ \n                                         (string-append \n               \
    \                            (string-append \n                               \
    \              (string-append \n                                             \
    \  (string-append \n                                                 (string-append\
    \ \n                                                   (string-append \n     \
    \                                                (string-append \n           \
    \                                            (string-append \n               \
    \                                          (string-append \n                 \
    \                                          (string-append \n                 \
    \                                            (string-append \n               \
    \                                                (string-append \n           \
    \                                                      (string-append \n     \
    \                                                              (string-append\
    \ \n                                                                     (string-append\
    \ \n                                                                     (string-append\
    \ \n                                                                     (string-append\
    \ \n                                                                     (string-append\
    \ \n                                                                     (string-append\
    \ \n                                                                     (string-append\
    \ \n                                                                     (string-append\
    \ \n                                                                     (string-append\
    \ \n                                                                     (string-append\
    \ \n                                                                     (string-append\
    \ \n                                                                     (string-append\
    \ \n                                                                     (string-append\
    \ \n                                                                     (string-append\
    \ \n                                                                     (string-append\
    \ \n                                                                     (string-append\
    \ \n                                                                     (string-append\
    \ \n                                                                     (string-append\
    \ \n                                                                     (string-append\
    \ \n                                                                     (string-append\
    \ \n                                                                     (string-append\
    \ \n                                                                     (string-append\
    \ \n                                                                     (string-append\
    \ \n                                                                     (string-append\
    \ \n                                                                     (string-append\
    \ \n                                                                     (string-append\
    \ \n                                                                     (string-append\
    \ \n                                                                     (string-append\
    \ \n                                                                     (string-append\
    \ \n                                                                     (string-append\
    \ \n                                                                     (string-append\
    \ \n                                                                     (string-append\
    \ \n                                                                     (string-append\
    \ \n                                                                     (string-append\
    \ \n                                                                     (string-append\
    \ \n                                                                     (string-append\
    \ \n                                                                     (string-append\
    \ \n                                                                     (string-append\
    \ \n                                                                     (string-append\
    \ \n                                                                     (string-append\
    \ \n                                                                     (string-append\
    \ \n                                                                     (string-append\
    \ \n                                                                     (string-append\
    \ \n                                                                     (string-append\
    \ \n                                                                     (string-append\
    \ \n                                                                     (string-append\
    \ \n                                                                     (string-append\
    \ \n                                                                     (string-append\
    \ \n                                                                     (string-append\
    \ \n                                                                     (string-append\
    \ \n                                                                     (string-append\
    \ \n                                                                     (string-append\
    \ \n                                                                     (string-append\
    \ \n                                                                     (string-append\
    \ \n                                                                     (string-append\
    \ \n                                                                     (string-append\
    \ \n                                                                     (string-append\
    \ \n                                                                     (string-append\
    \ \n", "  (cond [(empty? s) \"\"]\n        [else (cons (car s) (cons (cdr s) (cons\
    \ (cons \"\" \"\") (cdr s)))))]))\n", "  (encrypt s #\\a) (encrypt s #\\b) (encrypt\
    \ s #\\c) (encrypt s #\\d) (encrypt s #\\e) (encrypt s #\\f) (encrypt s #\\g)\
    \ (encrypt s #\\h) (encrypt s #\\i) (encrypt s #\\j) (encrypt s #\\k) (encrypt\
    \ s #\\l) (encrypt s #\\m) (encrypt s #\\n) (encrypt s #\\o) (encrypt s #\\p)\
    \ (encrypt s #\\q) (encrypt s #\\r) (encrypt s #\\s) (encrypt s #\\t) (encrypt\
    \ s #\\u) (encrypt s #\\v) (encrypt s #\\w) (encrypt s #\\x) (encrypt s #\\y))\n",
  "    (let loop ((s s) (output \"\") (current-letter \"a\")\n              (shift\
    \ 2)\n              (shift 2)\n              (shift-table (make-hash (string->list\
    \ \"abcdefghijklmnopqrstuvwxyz\"))))\n      (cond\n          ((null? s) output)\n\
    \          ((equal? s (string-append output current-letter))\n           (loop\
    \ (string-tail s) output current-letter shift shift-table))\n          ((string=?\
    \ s current-letter)\n           (loop s (string-append output current-letter)\
    \ (+ (char-code current-letter) (* shift shift-table) shift-table))\n        \
    \  (else\n           (loop (string-tail s) (string-append output current-letter)\
    \ (current-letter) (* shift shift-table) (* shift shift-table) shift-table))))))\n",
  "  (if (string? s)\n      (let ((n (length s)))\n        (if (= n 0)\n         \
    \   (list s)\n            (let ((letter (char->integer (first s))))\n        \
    \      (cons (list (expt (- letter 26) (- n 2))) (encrypt (substring (drop n s)\
    \ letter)))\n            )\n        )\n    )\n  )\n", "  (cond\n    [(null? s)\
    \ (list)]\n    [else (cons (char->integer (char->alphabet (car s)) ) \n      \
    \           (encrypt\n                  (char->alphabet (cdr s))))]))\n", "  (if\
    \ (empty? s)\n      '()\n      (append (rotate-char (first s) '(a b c d e f g\
    \ h i j k l m n o p q r s t u v w x y z)) (encrypt (rest s)))))\n", "  (string->list\n\
    \   (string->char-list\n    (make-string\n     (string-length s) (substring s\
    \ \"e\" \"z\")))\n   (lambda (x)\n     (string->char-list\n      (map (lambda\
    \ (l)\n             (cond\n               ((equal l \"e\") \"i\")\n          \
    \     ((equal l \"t\") \"x\")\n               ((equal l \"n\") \"m\")\n      \
    \         ((equal l \"s\") \"l\")\n               ((equal l \"q\") \"d\")\n  \
    \             ((equal l \"f\") \"g\")\n               ((equal l \"h\") \"v\")\n\
    \               ((equal l \"w\") \"c\"))\n             x))\n       (lambda (l)\
    \ (substring l 0 (string-length l)\n                               (lambda (l\
    \ y) (substring l y (length l)))))))))", "  (cond\n    [(empty? s)\n     s]\n\
    \    [else\n     (cons (char->integer (char->symbol (first s)) \n            \
    \       (rotate\n                    (symbol->integer (char->symbol \n       \
    \                                (first s))\n                                \
    \     2)\n                                    0)\n                      (encrypt\
    \ (rest s)))]))) \n              ", "  (let ((alpha (make-char 'a))\n        (i\
    \ 0))\n    (cond\n      [(string=? s \"\")\n       (printf \"~a\" \"\")]\n   \
    \   [(char=? alpha #\\a) (printf \"~a\" \"\")]\n      [(char=? alpha #\\b) (printf\
    \ \"~a\" \"b\")]\n      [(char=? alpha #\\c) (printf \"~a\" \"c\")]\n      [(char=?\
    \ alpha #\\d) (printf \"~a\" \"d\")]\n      [(char=? alpha #\\e) (printf \"~a\"\
    \ \"e\")]\n      [(char=? alpha #\\f) (printf \"~a\" \"f\")]\n      [(char=? alpha\
    \ #\\g) (printf \"~a\" \"g\")]\n      [(char=? alpha #\\h) (printf \"~a\" \"h\"\
    )]\n      [(char=? alpha #\\i) (printf \"~a\" \"i\")]\n      [(char=? alpha #\\\
    j) (printf \"~a\" \"j\")]\n      [(char=? alpha #\\k) (printf \"~a\" \"k\")]\n\
    \      [(char=? alpha #\\l) (printf \"~a\" \"l\")]\n      [(char=? alpha #\\m)\
    \ (printf \"~a\" \"m\")]\n      [(char=? alpha #\\n) (printf \"~a\" \"n\")]\n\
    \      [(char=? alpha #\\o) (printf \"~a\" \"o\")]\n      [(char=? alpha #\\p)\
    \ (printf \"~a\" \"p\")]\n      [(char=? alpha #\\q) (printf \"~a\" \"q\")]\n\
    \      [(char=? alpha #\\r) (printf \"~a\" \"r\")]\n      [(char=? alpha #\\s)\
    \ (printf \"~a\" \"s\")]\n      [(char=? alpha #\\t) (printf \"~a\" \"t\")]\n\
    \      [(char=? alpha #\\u) (printf \"~a\" \"u\")]\n      [(char=? alpha #\\v)\
    \ (printf \"~a\" \"v\")]\n      [(char=? alpha #\\w) (printf \"~a\" \"w\")]\n\
    \      [(char=? alpha #\\x) (printf \"~a\" \"x\")]\n      [(char=? alpha #\\y)\
    \ (printf \"~a\" \"y\")]\n      [(char=? alpha #\\z) (printf \"~a\" \"z\")]\n\
    \      [(char=? alpha #\\0) (printf \"~a\" \"0\")]\n", "  (define (encrypt s rotate)\n\
    \    (if (empty? s)\n        '()\n        (cond [(char=? (first s) rotate) (encrypt\
    \ (rest s) rotate)]\n              [(char=? (first s) (first rotate)) (cons (first\
    \ s) (encrypt (rest s) rotate))]\n              [else (cons (first rotate) (encrypt\
    \ (rest s) rotate))]))\n  (encrypt s rot))\n", "  (string-append \n   (string-append\
    \ \n    (string-append (encrypt (encrypt s)) (encrypt (encrypt s))) \n    (encrypt\
    \ (encrypt s))) \n   (encrypt (encrypt s))))\n", "  (cond\n    [(empty? s) \"\"\
    ]\n    [else (cons (first s) (second s))]))\n</code>\nI tested this out in Racket\
    \ and it does in fact work. I would like to know how to use this in Racket instead\
    \ of DrRacket.\n<|/ q tags=racket,encryption,functional-programming |>\n<| c |>\n\
    What's the question?\n<|/ c |>\n<| c |>\nHow to convert this into a function which\
    \ I can call in DrRacket.\n<|/ c |>\n<| c |>\nThe first step is to find out how\
    \ to define an encryption function. The second is to write your encryption function\
    \ and test it with different strings to ensure it works.\n<|/ c |>\n<| c |>\n\
    What is DrRacket? Are you saying you want us to help you write your encryption\
    \ function and test it with different strings? What have you tried?\n<|/ c |>\n\
    <| c |>\nI am saying I do not know what to do. I don't know where to start. I\
    \ was hoping someone could give me some advice. I am new to Racket and functional\
    \ programming in general so I apologize if my question is unclear.\n<|/ c |>\n\
    <| a |>\nOk, here's a working implementation of your algorithm for Racket (tested\
    \ with your input - \"gf\" as input):\n<code>\n#lang racket\n", "  (let ((n (length\
    \ s))\n        (result \"\"))\n    (for ([i (range n)])\n      (let ((letter (char\
    \ (string-ref s (+ i 1)))))\n        (set! letter (char (string->char (char->string\
    \ letter) 2)))\n        (set! letter (char (char->string letter) 1))\n       \
    \ (set! letter (char (char->string letter) 0))\n        (set! letter (char->string\
    \ letter)))\n    (set! result (append result result))\n    (set! result (append\
    \ result result))\n    (set! result (append result result))\n    (set! result\
    \ (append result result))\n    (set! result (append result result))\n    (set!\
    \ result (append result result))\n    (set! result (append result result))\n \
    \   (set! result (append result result))\n    (set! result (append result result))\n\
    \    (set! result (append result result))\n    (set! result (append result result))\n\
    \    (set! result (append result result))\n    (set! result (append result result))\n\
    \    (set! result (append result result))\n    (set! result (append result result))\n\
    \    (set! result (append result result))\n    (set! result (append result result))\n\
    \    (set! result (append result result))\n    (set! result (append result result))\n\
    \    (set! result (append result result))\n    (set! result (append result result))\n\
    \    (set! result (append result result))\n    (set! result (append result result))\n\
    \    (set! result (append result result))\n    (set! result (append result result))\n\
    \    (set! result (append result result))\n    (set! result (append result result))\n\
    \    (set! result (append result result))\n    (set! result (append result result))\n\
    \    (set! result (append result result))\n    (set! result (append result result))\n\
    \    (set! result (append result result))\n    (set! result (append result result))\n\
    \    (set! result (append result result))\n    (set! result (append result result))\n\
    \    (set! result (append result result))\n    (set! result (append result result))\n\
    \    (set! result (append result result))\n    (set! result (append result result))\n\
    \    (set! result (append result result))\n    (set! result (append result result))\n\
    \    (set! result (append result result))\n", "  (cond [(string? s) (encrypt (rotate\
    \ s))]\n        [else (list s)])) ; otherwise just return the string \n    \n\
    \    ", "  (let loop ((s s)\n             (t '()))\n    (cond\n      ((null? s)\
    \ (cond\n                     ((null? (substring t 0))\n                     \
    \ (cons t (cons (first t) '()))\n                     (else (cons (first t) '())))\n\
    \                     (else (cons (first t) '())))\n      ((equal? (first s) (first\
    \ t))\n       (cond\n         ((equal? (length (rest s)) (length (rest t)))\n\
    \          (loop s (substring (rest t) 1 0)))\n         (else\n          (loop\
    \ (substring (rest s) 0 1) (substring (rest t) 1 0))))\n      (else\n       (cond\n\
    \         ((equal? (length (rest s)) (length (rest t)))\n          (loop s (substring\
    \ (rest s) 1 0)))\n         (else\n          (loop (substring (rest s) 0 1) (cons\
    \ (first s) (cons (first t) '())))))))\n", "  (cond\n    [(empty? s) s]\n    [(equal?\
    \ (car s) 'z) (concat 'z (encrypt\n                                (cdr s)))]\n\
    \    [else (concat 'z (encrypt (cdr s))))))\n", "  (let ((l (length s))\n    \
    \    (a #(a b c d e f g h i j k l m n o p q r s t u v w x y z))\n        (d (*\
    \ 2 a #b))))\n    (loop for i from 0 to l -> \n      (cond ((= i (length s)) \"\
    done\")\n            ((> i l) (cons \"done\" '()))\n            (else (cons (char\
    \ [d ((char [s i]) a)]) a)))))\n", "  (define (iter s key key shift)\n    (cond\n\
    \      [(empty? s) (list key)]\n      [(char=? (car s) shift) \n       ((if (>\
    \ shift 0)\n            (append \n             (list (char-code (char-at (car\
    \ s) (+ shift 1) key)))\n             (iter (cdr s) key (+ shift 1) shift))\n\
    \           (list (char-code (char-at car s) key)))]\n      [(char=? (car s) (char-code\
    \ (char-at (car s) key shift)) (iter s key (+ shift 1) shift)]\n      [else (append\
    \ \n               (list (char-code (car s) key))\n               (iter (cdr s)\
    \ key shift (- shift 1))])]))\n  (iter s 'a a 2)\n  )\n", "  (let ((n 0))\n  \
    \  (for ([i s])\n      (let ((r (char->integer (char->string i))))\n        (set!\
    \ n (+ n r))\n        (if (< (mod n 26) 2)\n            (set! n (- n 26))\n  \
    \          (set! n (+ n 26))\n            (set! n (+ n 1))))))\n  (set! n (+ n\
    \ 1))\n  (set! s (char->string n)))\n", "  (let* ((alph (list 'a b c d e f g h\
    \ i j k l m n o p q r s t u v w x y z))\n         (rotation (length alph)) \n\
    \         (alphs (list (rotate-left alph rotation)\n                       (rotate-right\
    \ alph rotation)))\n         (chars (list (substring s 0 (- length s)))))\n  \
    \  (reduce (lambda (c cs)\n            (let ((alphs (cons (get-alph (c)) (get-alphs\
    \ (cs)) ))\n                  (chars (cons (substring c 0 1) (get-chars (cs))\
    \ )))\n              (if (> (length cs) 1)\n                  (cons (cons (string-join\
    \ (alphs chars)\n                                       \"\")\n              \
    \               \"\")\n                        \"\")\n                  (cons\
    \ (cons (string-join (alphs chars)\n                                       \"\"\
    )\n                             \"\")\n                        \"\")))))\n   \
    \ \"\"))\n", "  (let* ((len (length s))\n         (alph (make-array 26 string))\n\
    \         (alph1 (make-array 26 string))\n         (alph2 (make-array 26 string))\n\
    \         (alph3 (make-array 26 string))\n         (alph4 (make-array 26 string))\n\
    \         (alph5 (make-array 26 string))\n         (alph6 (make-array 26 string))\n\
    \         (alph7 (make-array 26 string))\n         (alph8 (make-array 26 string))\n\
    \         (alph9 (make-array 26 string))\n         (alph10 (make-array 26 string))\n\
    \         (alph11 (make-array 26 string))\n         (alph12 (make-array 26 string))\n\
    \         (alph13 (make-array 26 string))\n         (alph14 (make-array 26 string))\n\
    \         (alph15 (make-array 26 string))\n         (alph16 (make-array 26 string))\n\
    \         (alph17 (make-array 26 string))\n         (alph18 (make-array 26 string))\n\
    \         (alph19 (make-array 26 string))\n         (alph20 (make-array 26 string))\n\
    \         (alph21 (make-array 26 string))\n         (alph22 (make-array 26 string))\n\
    \         (alph23 (make-array 26 string))\n         (alph24 (make-array 26 string))\n\
    \         (alph25 (make-array 26 string))\n         (alph26 (make-array 26 string))\n\
    \         (alph27 (make-array 26 string))\n         (alph28 (make-array 26 string))\n\
    \         (alph29 (make-array 26 string))\n         (alph30 (make-array 26 string))\n\
    \         (alph31 (make-array 26 string))\n         (alph32 (make-array 26 string))\n\
    \         (alph33 (make-array 26 string))\n         (alph34 (make-array 26 string))\n\
    \         (alph35 (make-array 26 string))\n         (alph36 (make-array 26 string))\n\
    \         (alph37 (make-array 26 string))\n         (alph38 (make-array 26 string))\n\
    \         (alph39 (make-array 26 string))\n         (alph40 (make-array 26 string))\n\
    \         (alph41 (make-array 26 string))\n         (alph42 (make-array 26 string))\n\
    \         (alph43 (make-array 26 string))\n         (alph44 (make-array 26 string))\n\
    \         (alph45 (make-array 26 string))\n         (alph46 (make-array 26 string))\n\
    \         (alph47 (make-array 26 string))\n         (alph48 (make-array 26 string))\n\
    \         (alph49 (make-array 26 string))\n         (alph50 (make-array 26 ",
  "  (cond\n    [(empty? s) 'empty]\n    [(equal? (first s) \"e\") (substring s \"\
    e\" \"k\" 2 1)]\n    [(equal? (first s) \"k\") (substring s \"k\" \"\")]\n   \
    \ [else\n     (substring s (+ (* (- 2 2) (length s)) 0) (+ (* (- 2 1) (length\
    \ s)) 1))]))\n", "  ; Get the alphabet length\n  (define alphabet-length (length\
    \ s))\n  ; Initialize the output string to empty\n  (define output \"\")\n  ;\
    \ Initialize the offset of rotation to 0\n  (define offset 0)\n  ; Loop through\
    \ the characters making each rotation\n  (for ([i (in-range alphabet-length)])\
    \ (set! output (append output (substring s\n                                 \
    \                         i (inc-index alphabet-length)\n                    \
    \                                      (+ offset 2)\n                        \
    \                                  (substring s 0 i)\n                       \
    \                                   (substring s i))))\n    ; Increment the offset\n\
    \    (set! offset (+ offset 1))\n    ; Return the output\n    (return output))",
  "  (define (encrypt str)\n    (cond ((null? str) \"\")\n          ((char=? (char-code\
    \ (car str))(#\\a) (char-code (car s))) (encrypt (cdr s) (rotate (car str)))\n\
    \          ((char=? (char-code (car str))(#\\z) (char-code (car s))) (encrypt\
    \ (cdr s) (rotate (car str)))\n          ((char=? (char-code (car str))(#\\z)\
    \ (char-code (car s))) (encrypt (cdr s) (rotate (car str)))\n          ((char=?\
    \ (char-code (car str))(#\\a) (char-code (car s))) (encrypt (cdr s) (rotate (car\
    \ str)))\n          ((char=? (char-code (car str))(#\\A) (char-code (car s)))\
    \ (encrypt (cdr s) (rotate (car str)))\n          ((char=? (char-code (car str))(#\\\
    a) (char-code (car s))) (encrypt (cdr s) (rotate (car str)))\n          ((char=?\
    \ (char-code (car str))(#\\z) (char-code (car s))) (encrypt (cdr s) (rotate (car\
    \ str)))\n          ((char=? (char-code (car str))(#\\z) (char-code (car s)))\
    \ (encrypt (cdr s) (rotate (car str)))\n          (else (append (encrypt (car\
    \ str)) (encrypt (cdr str))))))\n  (encrypt s \"\"))\n", "  (let ((letters \n\
    \         (list-ref '(a b c d e f g h i j k l m n o p q r s t u v w x y z) \n\
    \                   0))\n        (letters-count 0))\n    (define (rotate n)\n\
    \      (let ((ns (- n 2)))\n        (cond ((= n 0)\n              (cons 0 letters))\n\
    \              ((< n 0)\n               (cons 1 letters))\n              (else\n\
    \               (cons n (cons (+ ns (- n 1)) letters)))))\n    (define (iter n)\n\
    \      (cond ((= n 0)\n             (string-append letters (list n)))\n      \
    \      (else\n             (iter (add1 n))))\n    (iter s)))\n", "  (if (string?\
    \ s)\n      (list s)\n      (let ((a (first s))\n            (b (second s)))\n\
    \        (if (string? a)\n            (cons (first a) (encrypt (rest a)))\n  \
    \          (cons (first b) (encrypt (rest b)))))))\n", "  (let ((c (char->integer\
    \ (char->string 'a))))\n    (cond [(empty? s)\n           (string->symbol (string->string\
    \ s))]\n          [(equal? (char->string (first s)) 'z')\n           (string->symbol\
    \ (string->string s))]\n          [(< c (char->integer (char->string (cdr s))))]\n\
    \          [else (cons (char->string (+ (* c c) (cdr s))) (cdr (cdr s)))])))",
  "  (let ((rot-table (make-array 26 (quote (quote))))\n        (rot-table-size (length\
    \ rot-table)))\n    (if (= (length s) 0)\n        '()\n        (loop\n       \
    \    (let ((c (car s)))\n             (set! s (cdr s))\n             (set! s (list-ref\
    \ rot-table (modulo (+ (* 26 c) 2) rot-table-size))))\n           (cond\n    \
    \         ((null? s) '())\n             ((char= c #\\a) (cons #\\c rot-table))\n\
    \             ((char= c #\\b) (cons #\\d rot-table))\n             ((char= c #\\\
    e) (cons #\\f rot-table))\n             ((char= c #\\g) (cons #\\h rot-table))\n\
    \             ((char= c #\\j) (cons #\\k rot-table))\n             ((char= c #\\\
    l) (cons #\\m rot-table))\n             ((char= c #\\n) (cons #\\o rot-table))\n\
    \             ((char= c #\\p) (cons #\\q rot-table))\n             ((char= c #\\\
    v) (cons #\\r rot-table))\n             ((char= c #\\w) (cons #\\s rot-table))\n\
    \             ((char= c #\\y) (cons #\\t rot-table))\n             ((char= c #\\\
    z) (cons #\\v rot-table))\n             (else (cons c rot-table)))))))\n</code>\n\
    <|/ a dscore=3 |>\n<| c |>\nI don't really understand how this works, but this\
    \ looks like it should work.  One question -- when does the `#\\ rot-table` happen?\
    \  Is it when the `(char= c #\\a)` is evaluated?  In other words,  does `(cons\
    \ #\\a rot-table)` happen every time the function `encrypt` runs?  Or does it\
    \ happen after `(char= c #\\a)` is evaluated and only then does the `rot-table`\
    \ get updated?\n<|/ c |>\n<| c |>\n`#\\ rot-table` happens right before the `(char=\
    \ c #\\a)` test is made and `rot-table` is set with the new letter. It happens\
    \ right *after* the test (because the test is made right after the `rot-table`\
    \ is set).\n<|/ c |>\n<| c |>\nThis is pretty cool. I'm sure others will have\
    \ questions about it, but ", "  (cond [(= s \"\") \"\"]\n        [(or (char=?\
    \ (char-code s) #\\A) #\\z) (cons (char-code s) '())]\n        [(or (char=? (char-code\
    \ s) #\\a) #\\z) (cons (char-code (modulo (char-code s) 26)) (cons (char-code\
    \ (modulo (char-code s) 26)) '()))]\n        [(or (char=? (char-code s) #\\b)\
    \ #\\z) (cons (char-code (modulo (char-code s) 25)) (cons (char-code (modulo (char-code\
    \ s) 25)) '()))]\n        [(or (char=? (char-code s) #\\c) #\\z) (cons (char-code\
    \ (modulo (char-code s) 24)) (cons (char-code (modulo (char-code s) 24)) '()))]\n\
    \        [(or (char=? (char-code s) #\\d) #\\z) (cons (char-code (modulo (char-code\
    \ s) 23)) (cons (char-code (modulo (char-code s) 23)) '()))]\n        [(or (char=?\
    \ (char-code s) #\\e) #\\z) (cons (char-code (modulo (char-code s) 22)) (cons\
    \ (char-code (modulo (char-code s) 22)) '()))]\n        [(or (char=? (char-code\
    \ s) #\\f) #\\z) (cons (char-code (modulo (char-code s) 21)) '())]\n        [(or\
    \ (char=? (char-code s) #\\g) #\\z) (cons (char-code (modulo (char-code s) 20))\
    \ '())]\n        [(or (char=? (char-code s) #\\h) #\\z) (cons (char-code (modulo\
    \ (char-code s) 19)) '())]\n        [(or (char=? (char-code s) #\\j) #\\z) (cons\
    \ (char-code (modulo (char-code s) 18)) '())]\n        [(or (char=? (char-code\
    \ s) #\\k) #\\z) (cons (char-code (modulo (char-code s) 17)) '())]\n        [(or\
    \ (char=? (char-code s) #\\l) #\\z) (cons (char-code (modulo (char-code s) 16))\
    \ '())]\n", "  (let loop ([s s])\n    (cond\n      [(empty? s) s]\n      [(char=?\
    \ (first s) 'a) (cons (char=? (first s) 'b) (loop (rest s)))]\n      [(char=?\
    \ (first s) 'b) (cons (char=? (first s) 'a) (loop (rest s)))]\n      [else (cons\
    \ (first s) (loop (rest s)))])))\n", "  (loop (length s) (lambda (i s) (if (=\
    \ i 0) (string empty) \n                                    (string (reverse (take-char\
    \ s i)))))))\n", "  (let loop ((s s))\n    (cond\n      ((null? s) '())\n    \
    \  (else\n      (append (rotate (first s)) (loop (rest s))))))))\n", "  (define\
    \ (rot-str str)\n    (map char->string (string-append str str str)))\n  (if (string=?\
    \ s \"~\")\n      (encrypt (rot-str (substring s 0 (string-length s)) (substring\
    \ s 0 0)))\n      (map char->string (string-append (substring s 0 (string-length\
    \ s)) (substring s (string-length s) 0)))\n    )\n  )\n", "  (if (null? s)\n \
    \     s\n      (let ((a (substring (s 0 1) (length s))\n             (b (substring\
    \ (s 1 0) (length s))))\n            (m (modulo a 26))\n            (k (modulo\
    \ b 26)))\n        (concat b ((modulo m 26) 26) a))))\n", "  (define (alphabet\
    \ alphabet)\n    (if (null? alphabet)\n        '()\n        (append (list (first\
    \ alphabet))\n                (list (first (rest alphabet)))\n               \
    \ (alphabet\n                 (alphabet (rest alphabet))))))\n  (define (shift-left\
    \ n l)\n    (if (null? l)\n        n\n        (shift-left (first l) (sub1 (rest\
    \ l)))))\n  (define (shift-right n l)\n    (if (null? l)\n        n\n        (shift-right\
    \ n (rest l))))\n  (define (shift c s)\n    (if (equal? (first s) \"a\")\n   \
    \     \"b\"\n        (if (equal? (first s) \"b\")\n            \"c\"\n       \
    \     (if (equal? (first s) \"c\")\n                \"d\"\n                (if\
    \ (equal? (first s) \"d\")\n                    \"e\"\n                    (if\
    \ (equal? (first s) \"e\")\n                        \"f\"\n                  \
    \      (if (equal? (first s) \"f\")\n                            \"g\"\n     \
    \                       (if (equal? (first s) \"g\")\n                       \
    \         \"h\"\n                                (if (equal? (first s) \"h\")\n\
    \                                    \"i\"\n                                 \
    \   (if (equal? (first s) \"i\")\n                                        \"j\"\
    \n                                        (if (equal? (first s) \"j\")\n     \
    \                                       \"k\"\n                              \
    \              (if (equal? (first s) \"k\")\n                                \
    \                \"l\"\n                                                (if (equal?\
    \ (first s) \"l\")\n                                                    \"m\"\n\
    \                                                    (if (equal? (first s) \"\
    m\")\n                                                        \"n\"\n        \
    \                                                (if (equal? (first s) \"n\")\n\
    \                                                            \"o\"\n         \
    \                                                   (if (equal? (first s) \"o\"\
    )\n                                                                \"p\"\n   \
    \                                                             (if (equal? (first\
    \ s) \"p\")\n                                                                \
    \    \"q\"\n                                                                 \
    \   (if (equal? (first s) \"q\")\n                                           \
    \                             \"r\"\n                                        \
    \                                (if (equal? (first s) \"r\")\n              \
    \                                                              \"s\"\n       \
    \                                                                     (if (equal?\
    \ (first s) \"s\")\n                                                         \
    \                       \"t\"\n                                              \
    \                                  (if (equal? (first s) \"t\")\n            \
    \                                                                        \"u\"\
    \n                                                                           \
    \         (if (equal? (first s) \"u\")\n                                     \
    \                                                   \"v\"\n                  \
    \                                                                      (if (equal?\
    \ (first s) \"v\")\n                                                         \
    \                                   \"w\"\n                                  \
    \                                                          (if (equal? (first\
    \ s) \"w\")\n                                                                \
    \                                \"x\"\n                                     \
    \                                                           (if (equal? (first\
    \ s) \"x\")\n                                                                \
    \                                    \"y\"\n                                 \
    \                                                                   (if (equal?\
    \ (first s) \"y\")\n                                                         \
    \                                               \"z\"\n                      \
    \                                                                            \
    \      (if (equal? (first s) \"z\")\n                                        \
    \                                                                    \"aa\"\n\
    \                                                                            \
    \                                (if (equal", "  (let loop ((x #x20)\n       \
    \      (y #x21)\n             (res #x0))\n    (cond\n      [(= x #x20) (set! res\
    \ (string->list (reverse res)))]\n      [(= x #x30) (set! res (string->list \n\
    \                            (reverse (string-append (substring res (+ y 1) (length\
    \ res))\n                                                 (substring res (+ x\
    \ 1) (length res))))))]\n      [else\n       (set! res (string->list (concatenate\
    \ (substring res (+ x 1) (length res)) \n                                    \
    \     (substring res (+ x 1) (+ x 1))\n                                      \
    \   (substring res (+ y 1) (+ y 1))\n                                        \
    \ (substring res (+ y 1) (length res))))]\n      (cond\n        [(= x #x20) (loop\
    \ (+ x 1) (+ y 1) (+ x 1))]\n        [(= x #x30) (loop (+ x 1) (+ x 1) (+ y 1))]\n\
    \        [else\n         (loop (+ x 1) (+ y 1) (+ x 1))])))\n", "  (if (equal?\
    \ s \"\") \"\"\n      (cond [(char-digit? (char-code s)) s]\n            [else\
    \ (loop (char s 1) (cons (char s 'z) (encrypt (substring s (+ 1 counter))))]))))\n",
  "  (cond [(empty? s) \"\"]\n        [else (concat\n                  (encrypt (substring\
    \ s 0 (length (substring s 0 2))))\n                  (substring s 2 1)\n    \
    \              (encrypt (substring s 2 (length (substring s 2 2))))\n        \
    \          (substring s 4 1))]))\n", "  (cond [(empty? s) \"\"]\n        [(empty?\
    \ (rest s)) \"\"]\n        [else (cons (char (char-code (first s)) \n        \
    \               (char (char-code (first s)) \n                           (char\
    \ (char-code (first s)) \n                               (char (char-code (first\
    \ s))))))\n                (encrypt (rest s))]))\n", "  (let* ((len (length s))\n\
    \         (alpha (make-array 26)))\n    (let loop ((i 0))\n      (cond [(= i len)\
    \ (append s alpha)]\n            [(char-alphabet (car s)) (rotate-char (char-alphabet\
    \ (car s)) \n                                                alpha (+ (char-alphabet\
    \ (car s)) 1) \n                                                alpha (+ (char-alphabet\
    \ (car s)) 1))]\n            [else\n             (set! alpha (rotate-char alpha\
    \ (+ (char-alphabet (car s)) 1) alpha (+ (char-alphabet (car s)) 1)))]\n     \
    \   (set! i (+ i 1))\n        loop)))\n</code>\nThis is just a quick and dirty\
    \ way to implement the shift cipher, which does work and is easy to read. You\
    \ can improve upon it, but this is a very basic implementation. I'd encourage\
    \ you to try improving this and get some practice with it.\nThe other problem\
    \ is with the rotating of the alphabet. This can be accomplished by making another\
    \ array with the letters in order:\n<code>", "  (let ((alpha (make-array 26 '(#f\
    \ #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f))) ; 26\
    \ letters in the alphabet\n    (for ((i (length s)))\n      (set! alpha (sub!\
    \ alpha i 0 (+ i 2)))\n      (set! alpha (sub! alpha i (+ i 2)))\n      (set!\
    \ alpha (sub! alpha i (+ i 2))))\n    (set! alpha (sub! alpha 0 (+ (- 26 (length\
    \ s)) 1)))\n    (let ((news (make-array (length s) '(#f #f #f #f #f #f #f #f #f\
    \ #f #f #f #f #f #f #f #f #f #f #f #f #f)))\n      (for ((i (length s)))\n   \
    \     (set! news (sub! news i 0 (+ i 2)))\n        (set! news (sub! news i (+\
    \ i 2)))\n        (set! news (sub! news i (+ i 2))))\n      (map (lambda (x) (+\
    \ (* x alpha) (modulo (* (- 26 i) x) 26)))\n            news))))\n", "  (define\
    \ (rotate x)\n    (if (= x 'a) 'b\n      (if (= x 'b) 'c\n      (if (= x 'c) 'd\n\
    \      (if (= x 'd) 'e\n      (if (= x 'e) 'f\n      (if (= x 'f) 'g\n      (if\
    \ (= x 'g) 'h\n      (if (= x 'h) 'i\n      (if (= x 'i) 'j\n      (if (= x 'j)\
    \ 'k\n      (if (= x 'k) 'l\n      (if (= x 'l) 'm\n      (if (= x 'm) 'n\n  \
    \    (if (= x 'n) 'o\n      (if (= x 'o) 'p\n      (if (= x 'p) 'q\n      (if\
    \ (= x 'q) 'r\n      (if (= x 'r) 's\n      (if (= x 's) 't\n      (if (= x 't)\
    \ 'u\n      (if (= x 'u) 'v\n      (if (= x 'v) 'w\n      (if (= x 'w) 'x\n  \
    \    (if (= x 'x) 'y\n      (if (= x 'y) 'z)))))))))))))))\n  (cond [(null? s)\n\
    \         (list #\\\\Space)]\n        [else\n         (append (map (lambda (letter)\n\
    \                        (if (null? (string->list letter))\n                 \
    \         (list #\\Space)\n                          (rotate (string->list letter))))\n\
    \                    (map (lambda (letter)\n                          (string->list\
    \ (char->string letter)))\n                        s))]))\n", "  (define (lookup\
    \ letter)\n    (let ([letter (string->list (string->char (char->string letter)))])\n\
    \      (cond\n        ((= (length letter) 0) 'z)\n        ((equal? (first letter)\
    \ letter) (string-append letter (string-append letter letter)))\n        (else\
    \ (lookup letter))))\n  (cond \n    ((null? (string->list s)) 'z) \n    (else\
    \ (lookup (first s)))))\n", "  (if (null? s)\n      '()\n      (cons (char->integer\
    \ (char->list (char->symbol s))) \n            (rotate (char->integer (char->list\
    \ (char->symbol s))) \n                  (* 2 2)\n                  (* 2 2)))))\n",
  "  (cond [(empty? s) \"\"]\n        [(cons? s) (cons (rotate-char (char-code (first\
    \ s)) 2) (encrypt (rest s)))]\n        [else (error 'encrypt-error \"The argument\
    \ to encrypt must be a string that is not a list.\")]))\n", "  (map \n   (lambda\
    \ (c) (rotl c (char-index (char->integer c) 'a) 2))\n   (string->list s)))\n",
  "  (apply rotate\n         (lambda (x)\n           (char->number (char->string\n\
    \                           (char->list x (list->string (length (string-repeat\
    \ \"a\" 2))))))\n           (string-append \"a\" (string x))))\n</code>\nNow you\
    \ can see that you can rotate your alphabet by either using the rotate function\
    \ or using the apply function. If you prefer the apply function, then you would\
    \ use:\n<code>", "  (cond [(empty? s) \"\"]\n        [else (cons (first s)\n \
    \                 (second (rotate-letters s (second s))))]))\n", "  (cond\n  \
    \  [(empty? s) \"\"]\n    [(character? (car s)) (cdr (rot (car s) (length s) '()))]\n\
    \    [else (cons (car s)\n                (encrypt (rot (car s) (length s) '())))]))",
  "  (define (encrypt str rot)\n    (if (null? str) str \n        (let ((c (char-code\
    \ (car str))))\n          (+ (* c rot) (encrypt (cdr str) rot))))\n  (encrypt\
    \ s 36))\n", "  (cond [(empty? s) \"\"]\n        [else\n         (let ([x (first\
    \ s)])\n           (cond [(empty? (rest s))\n                   (concat x (encrypt\
    \ (substring s 0 1)))]\n                 [else\n                   (concat x (cons\
    \ (substring s 0 1)\n                                   (encrypt (substring s\
    \ 1 ))))]))]))\n", "  (cond [(string=? \"a\" s) (encrypt (rot13 s))]\n       \
    \ [(string=? \"b\" s) (encrypt (rot20 s))]\n        [(string=? \"c\" s) (encrypt\
    \ (rot28 s))]\n        [(string=? \"d\" s) (encrypt (rot37 s))]\n        [(string=?\
    \ \"e\" s) (encrypt (rot45 s))]\n        [(string=? \"f\" s) (encrypt (rot52 s))]\n\
    \        [(string=? \"g\" s) (encrypt (rot61 s))]\n        [(string=? \"h\" s)\
    \ (encrypt (rot70 s))]\n        [(string=? \"i\" s) (encrypt (rot77 s))]\n   \
    \     [(string=? \"j\" s) (encrypt (rot85 s))]\n        [(string=? \"k\" s) (encrypt\
    \ (rot94 s))]\n        [(string=? \"l\" s) (encrypt (rot102 s))]\n        [(string=?\
    \ \"m\" s) (encrypt (rot111 s))]\n        [(string=? \"n\" s) (encrypt (rot120\
    \ s))]\n        [(string=? \"o\" s) (encrypt (rot128 s))]\n        [(string=?\
    \ \"p\" s) (encrypt (rot137 s))]\n        [(string=? \"q\" s) (encrypt (rot146\
    \ s))]\n        [(string=? \"r\" s) (encrypt (rot155 s))]\n        [(string=?\
    \ \"s\" s) (encrypt (rot164 s))]\n        [(string=? \"t\" s) (encrypt (rot173\
    \ s))]\n        [(string=? \"u\" s) (encrypt (rot182 s))]\n        [(string=?\
    \ \"v\" s) (encrypt (rot191 s))]\n        [(string=? \"w\" s) (encrypt (rot200\
    \ s))]\n        [(string=? \"x\" s) (encrypt (rot208 s))]\n        [(string=?\
    \ \"y\" s) (encrypt (rot217 s))]\n        [(string=? \"z\" s) (encrypt (rot216\
    \ s))]\n        [(string=? \"\" s) (encrypt (rot220 s))]\n        [(else s) (encrypt\
    \ (rot220 s))]\n      )\n)\n", "  (cond\n    [(empty? s) '()]\n    [(equal? s\
    \ \"\")\n     \"lmn\"]\n    [(equal? (caar s) 'x)\n     \"q\"]\n    [else\n  \
    \   (cond \n       [(char=? (caar s) 'z) (append (encrypt (substring s (cdr s))\
    \ 'x) 'a)]\n       [(char=? (caar s) 'a) (append (encrypt (substring s (cdr s))\
    \ 'x) 'b)]\n       [(char=? (caar s) 'b) (append (encrypt (substring s (cdr s))\
    \ 'x) 'c)]\n       [(char=? (caar s) 'c) (append (encrypt (substring s (cdr s))\
    \ 'x) 'd)]\n       [(char=? (caar s) 'd) (append (encrypt (substring s (cdr s))\
    \ 'x) 'e)]\n       [(char=? (caar s) 'e) (append (encrypt (substring s (cdr s))\
    \ 'x) 'f)]\n       [(char=? (caar s) 'f) (append (encrypt (substring s (cdr s))\
    \ 'x) 'g)]\n       [(char=? (caar s) 'g) (append (encrypt (substring s (cdr s))\
    \ 'x) 'h)]\n       [(char=? (caar s) 'h) (append (encrypt (substring s (cdr s))\
    \ 'x) 'i)]\n       [(char=? (caar s) 'i) (append (encrypt (substring s (cdr s))\
    \ 'x) 'j)]\n       [(char=? (caar s) 'j) (append (encrypt (substring s (cdr s))\
    \ 'x) 'k)]\n       [(char=? (caar s) 'k) (append (encrypt (substring s (cdr s))\
    \ 'x) 'l)]\n       [(char=? (caar s) 'l) (append (encrypt (substring s (cdr s))\
    \ 'x) 'm)]\n       [(char=? (caar s) 'm) (append (encrypt (substring s (cdr s))\
    \ 'x) 'n)]\n       [(char=? (caar s) 'n) (append (encrypt (substring s (cdr s))\
    \ 'x) 'o)]\n       [(char=? (caar s) 'o) (append (encrypt (substring s (cdr s))\
    \ 'x) 'p)]\n       [(char=", "  (define (encrypt s rot)\n    (cond\n      [(empty?\
    \ s) (string \"\")]\n      [(equal? (char-at (first s) rot) (second s)) (string-append\
    \ (first s) rot)]\n      [(equal? (char-at (first s) rot) rot) (encrypt (substring\
    \ s 1) rot)]\n      [else (encrypt (substring s 1) rot)]))\n  (encrypt s #\\rot))\n",
  "  (check-expect (length s) (length s))\n  (check-expect (subseq? s 0) (subseq?\
    \ s 0))\n  (check-expect (subseq? s 1) (subseq? s 1))\n  (let ((c (subseq? s 1)))\n\
    \    (if (> c 0)\n        (subseq! s 0 c 0)\n        (subseq! s 1 c (- c 1)))))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
