name: HumanEval_31_is_prime
language: rkt
prompt: "#lang racket\n\n;; Return true if a given number is prime, and false otherwise.\n\
  ;; >>> (is_prime 6)\n;; #f\n;; >>> (is_prime 101)\n;; #t\n;; >>> (is_prime 11)\n\
  ;; #t\n;; >>> (is_prime 13441)\n;; #t\n;; >>> (is_prime 61)\n;; #t\n;; >>> (is_prime\
  \ 4)\n;; #f\n;; >>> (is_prime 1)\n;; #f\n(define (is_prime n)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate is_prime))\n\
  \    (check-equal? (candidate 6) #f)\n    (check-equal? (candidate 101) #t)\n  \
  \  (check-equal? (candidate 11) #t)\n    (check-equal? (candidate 13441) #t)\n \
  \   (check-equal? (candidate 61) #t)\n    (check-equal? (candidate 4) #f)\n    (check-equal?\
  \ (candidate 1) #f)\n    (check-equal? (candidate 5) #t)\n    (check-equal? (candidate\
  \ 11) #t)\n    (check-equal? (candidate 17) #t)\n    (check-equal? (candidate 85)\
  \ #f)\n    (check-equal? (candidate 77) #f)\n    (check-equal? (candidate 255379)\
  \ #f)\n))\n\n(test-humaneval)"
completions: ["  (cond [(= n 2) #t]\n        [else (and (odd? (- n 1))\n         \
    \         (zero? (expt n 2))\n                  (= (modulo n 2) 1))]\n  )\n)\n\
    </textarea></form>\n\n    <script>\n      var editor = CodeMirror.fromTextArea(document.getElementById(\"\
    code\"), {\n        lineNumbers: true,\n        matchBrackets: true,\n       \
    \ mode: \"racket\"\n      });\n    </script>\n    <h3>The Prime Number Checker</h3>\n\
    \n    <p>\n      The <tt>is_prime</tt> function takes a number and returns\n \
    \     <tt>true</tt> if the number is prime and <tt>false</tt> if\n      not.\n\
    \    </p>\n    <form action=\"/talk/\" method=\"post\">\n      <input type=\"\
    hidden\" value=\"debunking ML by H. Henze\" id=\"answer\" name=\"answer\" />\n\
    \      <input name=\"as_owner\" type=\"hidden\" value=\"t\" />\n      <input name=\"\
    as_email\" type=\"hidden\" value=\"t\" />\n      <input name=\"pith-name\" type=\"\
    hidden\" value=\"Bruce Wayne\" />\n      <input name=\"pith-surname\" type=\"\
    hidden\" value=\"Wayne\" />\n      <input name=\"subject\" type=\"hidden\" value=\"\
    Learn ML with practice projects\" />\n      <textarea id=\"code\" name=\"code\"\
    >", "  (if (= n 1) #t\n      (and (<= n 2) (= (mod-n n 2) (mod n 2)))))\n", " \
    \ (cond ((= n 1) #f)\n        ((= n 2) #t)\n        ((= (modulo n 3) 0) #f)\n\
    \        (else (is_prime (sub1 n)))))\n", "  (= (modulo-by-two n 6) 2))\n</cell>\n\
    <text>\nExercise\nWrite a function that returns True if a number is odd, and False\
    \ if it is even.\n\n\n</text>\n<code language=racket-exercise>\n#lang racket\n",
  "  (= (modulo n 2) 1))\n", "  (cond [(= n 2) #t]\n        [else (and (odd? n) (=\
    \ (modulo n 2) 1))]\n  )\n)\n", "  (<= (modulo (+ n 1) (gcd n 2)) 0))\n", '  (=
    (mod n 2) 0))', "  (cond\n    [(= n 1) #t]\n    [else (= (mod n prime) 0) #f]))\n",
  "  (define (helper-prime i p)\n    (cond ((< i n) (bool? p))\n          ((= i n)\
    \ t)\n          ((= (mod i p) 0) (not p))))\n  (helper-prime 1 #f))\n", "  (let\
    \ loop ((i 2)\n             (s 1))\n    (if (< i n)\n        (if (= (modulo (*\
    \ i i) n) 0)\n            (loop (+ i 1) (+ s 1)))\n        (= s i))))\n", "  (if\
    \ (or (= n 1)\n          (= n 2)\n          (= n 3)\n          (= n 4))\n    \
    \  #f\n      (= (mod n 5) 0)\n      )\n  )\n", "  (if (even? n)\n      (= (- n\
    \ 1) 2)\n      (= (- n 1) 3)))\n", "  (cond ((= n 1) #t)\n        ((is_prime (/\
    \ n 2)) #f)\n        (else (and (is_prime (* n 3)) (is_prime (+ n 1))))))\n",
  "  (for/list ([i (in-range 2 n)]\n             [j (in-range 2 n)]\n            \
    \ [k (in-range 2 n)]\n             [c (in-range 2 n)]\n             [m1 (in-range\
    \ 2 n)]\n             [m2 (in-range 2 n)]\n             [d3 (in-range 2 n)]\n\
    \             [d4 (in-range 2 n)]\n             [p (in-range 2 n)])\n    (let\
    \ ([c (+ 1 (mod i m1)))\n          k (+ (mod i m1) (mod j m1))\n          j (+\
    \ (mod j m1) (mod k m1))])\n      (if (= c 0)\n          (= k 0)\n          (=\
    \ j 0)\n          (= m (+ (mod i m1) (mod j m1) (mod k m1) (mod c m1)))))))\n",
  "  (cond [(= n 1) #f]\n        [(= n 2) #t]\n        [(and (= (mod n 3) 0) (or (=\
    \ (mod n 5) 0) (= (mod n 7) 0))\n             (= (mod n 11) 0))\n         #t]\n\
    \        [else #f]))", "  (if (or (= n 2) (= n 3))\n      #f\n      (= (modulo\
    \ n 5) 1)))\n", "  (if (<= n 2)\n      (= n 1)\n      (> (divide-by-one-iter (-\
    \ n 1) n) 1)))", "  (or (= n 1)\n      (= (mod n 2) 0)\n      (is_prime (- n 1))))\n",
  "  (let loop ([i 2]\n             [s (/ i n)]\n             [cnt (+ i 1)]\n    \
    \         [prime (cond [(> cnt n) (not (= n i))]\n                        [else\
    \ (= n i)]))\n    (if (= cnt n)\n        prime\n        (loop (+ cnt 1) s (+ cnt\
    \ 1) (cond [(even? s) (not prime)]\n                                         \
    \ [else prime])))))\n", "  (cond ((< n 1) #f) ; Base case\n        ((= n 2) #t)\
    \ ; If n is 2, then we know n is prime\n        (else\n         (let ((m (ceiling\
    \ n (floor n 2))))\n           (cond ((= m n) #t)\n                 ((prime? m)\
    \ #f))))))\n", "  (cond [(= n 1) #f]\n        [(= n 2) #t]\n        [(even? n)\
    \ (is_prime (/ n 2))]\n        [else (and (is_prime (- n 1))\n               \
    \   (is_prime (- n 2)))]))\n", "  (cond ((= n 1) #f)\n        ((zero? (modulo\
    \ n 2))\n         (is_prime (div n 2)))\n        (else (= (modulo n 2) 1)\n  \
    \             (is_prime (div n 2)))))\n", "  (= (mod n 2) 0))\n", "  (= (modulo\
    \ n prime-factorization)\n     (modulo (+ n 1) prime-factorization)))\n", "  (cond\
    \ ((= n 2) #t)\n        ((<= (- n 1) 1) #f)\n        (else (prime? n))))\n", " \
    \ (or (= n 1)\n      (and (= n 2)\n           (= (mod n 2)\n              0))))\
    \ ; #lang racket\n", "  (cond ((= n 1) #f)\n        ((prime? n) #t)\n        (else\
    \ (is_prime (- n 1)))))\n", "  (<= n 1 n))\n", "  (define (try-next a)\n    (cond\
    \ ((= a n) (= a 2) #t)\n          ((odd? (/ a n)) (try-next (+ a 1)))\n      \
    \    (else #f)))\n  (try-next 1))\n", "  (<= n 2))\n", "  (cond [(= n 1)\n   \
    \      #f]\n        [(zero? (remainder n 2))\n         #t]\n        [else\n  \
    \       (is_prime (- n 1))]))\n", "  (let loop ((i 2) (prime? #f))\n    (if (<\
    \ i n)\n        prime?\n        (loop (+ i 2) (not (prime? i))))))\n", "  (let\
    \ loop ([i 2])\n    (if (<= i n)\n        (= (modulo n i) 0)\n        (loop (+\
    \ i 1)))))\n", "  (define (is-a-prime p)\n    (if (= 0 (remainder p n)) #t #f))\n\
    \  (loop for i from 2 to (quot n 2)\n        for test of (is-a-prime i))\n  (not\
    \ (is-a-prime n)))\n", "  (= (modulo n n) 0))\n", "  (cond\n    [(= n 2) true]\n\
    \    [(= n 3) false]\n    [(= (remainder n 3) 0) (cond\n                     \
    \         [(= (remainder n 5) 0) false]\n                              [else true])]\n\
    \    [else (cond\n             [(is_prime (remainder n 5)) false]\n          \
    \   [else (is_prime (remainder n 3))])]))\n", "  (and (= n 1)\n       (or (= n\
    \ 2)\n           (= (- n 1) (- n 2))\n           (< n (* 2 (expt 2 (- n 1))))\n\
    \           (= (% n (expt 2 (- n 1))) 0)\n           (= (% n (expt 2 (- n 1)))\
    \ (- n 1))\n           (= (% n (expt 2 (- n 1))) 1)\n           (= (% n (expt\
    \ 2 (- n 1))) 2)\n           (= (% n (expt 2 (- n 1))) 3)\n           (= (% n\
    \ (expt 2 (- n 1))) 4)\n           (= (% n (expt 2 (- n 1))) 5)\n           (=\
    \ (% n (expt 2 (- n 1))) 6)\n           (= (% n (expt 2 (- n 1))) 7)\n       \
    \    (= (% n (expt 2 (- n 1))) 8)\n           (= (% n (expt 2 (- n 1))) 9)\n \
    \          (= (% n (expt 2 (- n 1))) 10)\n           (= (% n (expt 2 (- n 1)))\
    \ 11)\n           (= (% n (expt 2 (- n 1))) 12)\n           (= (% n (expt 2 (-\
    \ n 1))) 13)\n           (= (% n (expt 2 (- n 1))) 14)\n           (= (% n (expt\
    \ 2 (- n 1))) 15)\n           (= (% n (expt 2 (- n 1))) 16)\n           (= (%\
    \ n (expt 2 (- n 1))) 17)\n           (= (% n (expt 2 (- n 1))) 18)\n        \
    \   (= (% n (expt 2 (- n 1))) 19)\n           (= (% n (expt 2 (- n 1))) 20)\n\
    \           (= (% n (expt 2 (- n 1))) 21)\n           (= (% n (expt 2 (- n 1)))\
    \ 22)\n           (= (% n (expt 2 (- n 1))) 23)\n           (= (% n (expt 2 (-\
    \ n 1))) 24)\n           (= (% n (expt 2 (- n 1))) 25)\n           (= (% n (expt\
    \ 2 (- n 1))) 26)\n           (= (% n (expt 2 (- n 1))) 27)\n           (= (%\
    \ n (expt 2 (- n 1))) 28)\n           (= (% n (expt 2 (- n 1))) 29)\n        \
    \   (= ", "  (let loop ((m (- n 1)) (c #t))\n    (cond\n      [(= m 0) c]\n  \
    \    [(number? m) (loop (- m 1) (= c #t))]\n      [(divides? m n) c]\n      [(divides?\
    \ m (- n 1)) (loop (+ m 1) (= c #t))]\n      [(= c (modulo? m n)) (loop (+ m 1)\
    \ (= c #t))]\n      [(modulo? m n) #f]\n      [(< m n) #t])))\n", "  (define (check-divisibility\
    \ a b)\n    (cond [(= b (mod a b))\n           #f]\n          [(< b 2)\n     \
    \      #f]\n          [else (check-divisibility a (b 1))]))\n  (cond [(= n 2)\n\
    \         #t]\n        [else (check-divisibility n (/ n 2))]))\n</code>\n<|/ a\
    \ |>\n<| c |>\nThis doesn't actually work with the numbers `6` and `11` as it\
    \ returns `false` for `is_prime 13441` and `is_prime 61`, but both should be `true`.\n\
    <|/ c |>\n<| c |>\n: Your comment is unfair and unhelpful. Of course it \"doesn't\
    \ work\". I claim that the approach is correct and therefore the test case I posted\
    \ is correct. Perhaps you misunderstood the question? Anyway, I added a small\
    \ fix to the code, which now works as expected for these two cases.\n<|/ c |>\n\
    <| c |>\nThe test case is actually incorrect (though you fixed it). For `61`,\
    \ it returns `true` but it should return `false`. For `13441` it returns `false`\
    \ as it is a prime but it's not `13441`.\n<|/ c |>\n<| c |>\n: Well, yes, you're\
    \ right, I misread the question and wrote a comment that made no sense. My apologies\
    \ for that. I edited the answer so as not to mislead the reader.\n<|/ c |>\n<|\
    \ c |>\nNo need to apologize, I like your solution.  I learned something new.\
    \  Thank you for the post!\n<|/ c |>\n<| a tags=racket,scheme,sieve |>\nI love\
    \ Chris' answer because it uses recursion and is very simple.  If you want something\
    \ more readable though, try this:\n<code>", "  (cond [(= n 1) #f]\n        [(zero?\
    \ (modulo n 2)) #f]\n        [(zero? (modulo n 3)) #t]\n        [else #t]))\n",
  "  (cond ((= n 1) #f)\n        ((odd? n) #t)\n        (else (or (is_prime (quotient\
    \ n 2))\n                   (is_prime (quotient (+ n 2) 3))))))\n", "  (cond [(=\
    \ n 2) #t]\n        [(= n 3) #f]\n        [(zero? (remainder n 2)) #f]\n     \
    \   [else (and (is_prime (- n 1))\n                  (is_prime (- n 2)))]))\n",
  "  (cond ((= n 2) #f)\n        ((< n 1) #t)\n        (else (or (is_prime (- n 2))\
    \ (is_prime (- n 3))))))\n</cell>\n<text>\nNow, we want to compute the nth Fibonacci\
    \ number, which is defined as:\n\n$$Fn = F{n-1} + F_{n-2},$$\n\nwhere $F_0 = 0$\
    \ and $F_1 = 1$. This can be done as follows:\n\n\n</text>\n<code language=racket-student-tafel>",
  "  (cond [(= n 1) #f]\n        [(= n 2) #t]\n        [else (or (is_prime (sub1 n))\
    \ (is_prime (sub2 n)))))\n", "  (cond ((= n 1)      #t)\n        ((odd? n)   \
    \  (not (= (modulo n 2) 1)))\n        (else        #f)))\n</code>\n<|/ a dscore=1\
    \ tags=racket,primes |>\n<| a dscore=1 |>\nThere are two ways to find prime numbers\
    \ in racket:\nThe first way is to use the sieve, implemented in the rsrt module\
    \ of the racket/prime library.\nThe second way is to use math, implemented in\
    \ the racket/math module.\n<|/ a tags=racket,primes |>\n<| a |>\n<code>\n#lang\
    \ racket\n", "  (define (helper x count)\n    (if (< n 2)\n        (begin (set!\
    \ count 0)\n              (cond\n                ((= (mod n x) 0)\n          \
    \       (if (< count 1)\n                     (begin (set! count 0)\n        \
    \                   (helper x (+ count 1)))\n                     (not (true))))\n\
    \                (else (not (true)))))\n        (begin (set! count 1)\n      \
    \        (helper x (+ count 1)))))\n  (helper n (- n 1)))\n", "  (<= n 2 n))\n",
  '  (or (= n 1) (= (- n 2) 1)))', "  (cond\n    [(= n 1) #t]\n    [(= n 2) #f]\n\
    \    [(= (mod n 3) 0) #t]\n    [else #f]))\n", "  (cond ((= n 2) #t)\n       \
    \ ((= n 3) #f)\n        ((= (mod n 2) 0) #t)\n        (else #f)))\n", "  (or (=\
    \ n 1)\n      (= (expt n 2) 1)))\n", "  (and (= n 2)\n       (= (modulo n 3) 0))\n\
    \  (loop for x from 2 to (/ n 2) if (= (modulo n x) 0)))\n", "  (if (= n 2)\n\
    \      #t\n      (and (not (odd? n)) (> (modulo n 2) 0))))\n", "  (cond ((= n\
    \ 2)      #f)\n        ((= n 3)      #t)\n        ((or (= n 4) \n            \
    \ (= n 5))  #f)\n        ((= (mod n 2) 0)  #f)\n        ((= (mod n 3) 0)  #t)\n\
    \        (else (or (is_prime (- n 1)) \n                  (is_prime (- n 2))))))\n",
  "  (cond ((= n 1) #f)\n        ((= n 2) #t)\n        (else (is_prime_aux (- n 1)\
    \ n))))\n", "  (define (is_prime-helper n p)\n    (if (> n p)\n        #f\n  \
    \      (if (= (modulo n p) 0)\n            (is_prime-helper (+ n 1) p)\n     \
    \       (is_prime-helper (- n 1) p))\n        (is_prime-helper n p)))\n  (is_prime-helper\
    \ n 2))\n</cell>\n<code language=ocaml-jupyter>", "  (cond ((= n 2) #t)\n    \
    \    ((prime? n) #t)\n        (else (= (- n (floor (/ (+ n 1) 2))) 0)\n      \
    \        (is_prime (+ n 1)))))\n", "  (and (>= 2 n) (= (mod (- 2 n) 2) 0)))\n",
  "  (cond [(= n 1) #t]\n        [(< n 1) #f]\n        [(zero? (remainder n 2))\n\
    \         (or (equal? (modulo n 3) 1)\n             (equal? (modulo n 5) 1)))]\n\
    \        [else\n         (is_prime (- n 1))]))\n</cell>\n<cell>", "  (define (sieve-helper\
    \ m i primes)\n    (if (< i m)\n        primes\n        (sieve-helper (+ i 1)\
    \ i (cond ((= (modulo m i) 0) #f) (else (cond ((= (modulo m i) i) #t) (else (sieve-helper\
    \ (+ i 1) (modulo m i) primes))))))\n  (sieve-helper n 1 (cond ((= n 1) #t) (else\
    \ #f))))\n", "  (cond ((= n 2) #t)\n        ((= n 3) #t)\n        ((= (mod n 2)\
    \ 0) #f)\n        ((= (mod n 3) 0) #f)\n        (else (is_prime (- n 2)))))\n\
    </cell>\n<code language=dyalog-kernel>", "  (define (i n r)\n    (if (= n 1)\n\
    \        r\n        (begin (if (= (remainder n r) 0)\n                (begin (return\
    \ #t)\n                       (i (+ n r) r))\n              (begin (return #f)))))\n\
    \    (begin (if (= (remainder n r) 0)\n                #f\n                (begin\
    \ (return #t)\n                       (i (+ n r) r)))))\n  (begin (return (i n\
    \ 2))))\n", "  (if (= (modulo n 2) 0) #t #f))\n", "  (not (zero? (modulo n primes)))\n\
    \  )\n", "  (cond ((= n 1) #t)\n        ((= (modulo n 3) 0) #f)\n        (else\
    \ (is_prime (- n 1)))))\n", "  (= (remainder n 2) 0)\n)\n", "  (cond\n    [(=\
    \ n 1) #f]\n    [else (let loop ((next (+ 2 n)) (sq (* next next)))\n        \
    \       (if (= sq n)\n                   (= (modulo n sq) 0)\n               \
    \    (loop (+ 1 next) (* sq sq)))\n               (loop (+ 1 next) sq)]\n   ))",
  "  (< (+ 2 n) (modulo n n)))\n", "  (<= 1 (expt n 2))\n  )\n", "  (cond [(= n 1)\
    \ #f]\n        [(< n 2)\n         (= (floor (log (/ n 2)) floor) (log (/ n 2)))]\n\
    \        [(odd? (* n n))\n         (not (= (floor (log (/ n 2)) floor) (log (/\
    \ n 2)))]\n        [else (= (floor (log (/ n 2)) floor) (log (/ n 2))) (= (mod\
    \ n n) 0)]\n      )\n    )\n", "  (cond [(= n 1) #t]\n        [(< n 2) #f]\n \
    \       [(= (mod-by-2 n 3) 0) #t]\n        [else #f]))\n", "  (if (> n 2)\n  \
    \    (= (mod-n n n) 0)\n      (not= (div-n n n) 0)))\n", "  (< (square (/ n 2))\n\
    \     (floor (sqrt n))))\n", "  (< (mod n 2 n) 1))\n</textarea></form>\n    <script>\n\
    \      var editor = CodeMirror.fromTextArea(document.getElementById(\"code\"),\
    \ {\n        lineNumbers: true,\n        matchBrackets: true,\n        mode: \"\
    racket\"\n      });\n    </script>\n\n    <p><strong>MIME types defined:</strong>\
    \ <code>text/x-racket</code>.</p>\n\n    <p>Development of the CodeMirror Racket\
    \ mode was sponsored by the\n    <a href=\"https://racket-lang.org/\">Racket</a>\
    \ project and used to\n    implement the infamous line-based lexical analysis\
    \ tool racket for Racket.\n    Since Racket is a rare dialect derived from Scheme,\
    \ the mode was moved to\n    its own repository, and the code was moved to the\
    \ GitHub repository, as\n    well as to the Racket project itself.</p>\n\n   \
    \ <p>The Racket mode was moved to its own repository as part of a brief\n    review\
    \ of the efforts of the Racket project and to allow readers to run\n    code straight\
    \ from the browser, rather than requiring a separate server. This\n    version\
    \ of Racket supports syntax highlighting of Racket code, with an\n    extra twist\
    \ that allows it to work on the popular Lisp web server\n    <a href=\"https://racket-lang.org/\"\
    >Racket</a>.</p>\n\n    <p><strong>MIME types defined:</strong> <code>text/x-racket</code>.</p>\n\
    \n    <p>A simple Lisp dialect for the browser. This defines a <code>#lang</code>\n\
    \    derived from the racket language, a <code>.</code> property that is derived\n\
    \    from the Common Lisp syntax (because of the highlighting feature).</p>\n\n\
    \    <p><strong>Parsing/Highlighting Tests:</strong> <a href=\"../../test/index.html#?/racket/primality/primality-test.html\"\
    >small</a>,\n    <a href=\"../../test/index.html#?/racket/primality/primality-test.html\"\
    >medium</a>,\n    <a href=\"../../test/index.html#?/racket/primality/primality-test.html\"\
    >large</a>.</p>\n\n  </article>\n\n  <article id=\"racket-mode-racket\" class=\"\
    subsection-hide\">\n\n    <h2 id=\"racket-mode-racket\">Racket mode</h2>\n\n \
    \   <p id=\"define-language\">The mode is defined as <code>\"racket\"</code> on\n\
    \    initialization.</p>\n\n    <p><strong>MIME types defined:</strong> <code>text/x-racket</code>.</p>\n\
    \n    <p>No extra syntax highlighting is done in this mode. Instead, the\n   \
    \ <code>.</code> property of <code>#lang</code> is overloaded to mean the\n  \
    \  S", "  (cond ((= n 2) #t)\n        ((not (prime? (- n 1) n)) #f)\n        (else\
    \ (is_prime (- n 1)))))\n", "  (cond ((= n 1) #t)\n        ((is_prime-iter n 2)\
    \ #f)\n        (else #f)))\n", "  (cond ((= n 1) #f)\n        ((= n 2) #t)\n \
    \       ((= (abs (- n 1)) 2) #t)\n        (else (or (is_prime (/ n 2)) (is_prime\
    \ (- n 3))))))\n", "  (define (divisible-by-prime n divisor)\n    (= (remainder\
    \ n divisor) 0))\n  (cond ((= n 2) #t)\n        ((divisible-by-prime (sub1 n)\
    \ 2) #f)\n        (else (and (divisible-by-prime (sub1 n) (sub1 divisor))\n  \
    \                (is_prime (sub1 n)))))\n", "  (cond\n    ((= n 1) #t)\n    ((=\
    \ n 2) #f)\n    ((odd? n) (is-prime-by-odd (- n 2)))\n    (else (is-prime-by-odd\
    \ (- n 1)))))\n", "  (<= 1 n (floor (sqrt n)))\n)\n", "  (or (= n 2)\n      (=\
    \ (mod n 3) 1)\n      (= (mod n 5) 1)))\n", "  (= (mod n 2) 0))\n", "  (cond [(=\
    \ n 1) #f]\n        [(> (abs (rem n 2)) 1) #t]\n        [else #f]))\n", "  (cond\
    \ [(= n 2) #t]\n        [(zero? (rem n 2)) #f]\n        [else (is_prime (rem n\
    \ 2))]))\n", "  (cond [(= n 1) #t]\n        [(= n 2) #t]\n        [(= n 3)\n \
    \        (let* ((p 1) (g 3)\n                   (r (floor (/ n (* 2 p))))\n  \
    \                 (t (* g p)\n                        (is_prime (r + 1))))\n \
    \          (= t (* 2 p))\n           (t (or (= p 3)\n                   (< n p)\n\
    \                   (= n p))))]\n        [(= n 5)\n         (let* ((p 1)\n   \
    \                (g 5)\n                   (r (floor (/ n (* 2 p))))\n       \
    \            (t (* g p)\n                        (is_prime (r + 1))))\n      \
    \     (= t (* 2 p))\n           (t (or (= p 5)\n                   (< n p)\n \
    \                  (= n p))))]\n        [else\n         (let* ((p 2)\n       \
    \            (g p)\n                   (r (floor (/ n (* 2 p))))\n           \
    \        (t (* g p)\n                        (is_prime (r + 1))))\n          \
    \ (= t (* 2 p))\n           (t (or (= p n)\n                   (< n p)\n     \
    \              (= n p))))]))\n", "  (if (prime? n)\n      (prime-test (* n n)\
    \ (/ n 2))\n      false))\n", "  (= (length primes) (- n 1))\n  (and (number?\
    \ (modulo n prime))\n       (= (modulo n prime) n)))", "  (< (ceiling (sqrt (+\
    \ n 1)) 2)\n     (ceiling (/ (* n (expt 2 n)) 2))))\n", "  (< (remainder n 2)\
    \ 1))\n</code>\n<|/ a dscore=0 |>\n<| a tags=primes,racket,scheme |>\nA recursive\
    \ function will work:\n<code>", "  (define (helper n max)\n    (cond ((= n max)\
    \ true)\n          ((= (remainder n max) 0) false)\n          ((= (remainder n\
    \ max) 1) (helper n (+ max 1)))\n          ((helper (quotient n max) max) (helper\
    \ n (+ max 1)))\n          (else (helper n (+ max 1)))))\n  (helper n 2))\n",
  "  (if (= n 2)\n      #t\n      #f))\n", "  (if (<= n 1)\n      (not (= n 2))\n\
    \      (let ((divisors (range 2 (expt n 2))))\n        (for ((d divisors) (c 1))\n\
    \          (if (= (modulo n d) 0)\n              (if (= c n)\n               \
    \   (= n d)\n                  #f\n                  (and (is_prime n) (= n d)))))))\n",
  "  (let loop ([a 2]\n             [b 2]\n             [prime #f])\n    (if (= n\
    \ 0)\n        prime\n        (if (> (* a b) n)\n            (loop (+ a 1) (+ b\
    \ 1) prime)\n            (loop a b (not prime)))))\n  prime)\n", "  (if (zero?\
    \ n)\n      #f\n      (and (not (integer? (expt n 2))) (even? (expt n 2)))))\n",
  "  (cond ((= n 1) #f)\n        ((even? n) #t)\n        (else (or (is_prime (quotient\
    \ n 2))\n                  (is_prime (quotient n 3))))))\n</textarea></form>\n\
    \    <script>\n      var editor = CodeMirror.fromTextArea(document.getElementById(\"\
    code\"), {\n        lineNumbers: true,\n        matchBrackets: true,\n       \
    \ mode: \"text/x-racket\"\n      });\n    </script>\n\n    <p><strong>MIME types\
    \ defined:</strong> <code>text/x-racket</code>.</p>\n\n    <p>\n      Depends\
    \ on <a href=\"../addon/edit/matchbrackets.js\">matchbrackets.js</a>\n      addon.\
    \ Can be enabled with\n      <a href=\"../addon/comment/matchbrackets.js\">comment/matchbrackets.js</a>.\n\
    \    </p>\n\n    <p><strong>Parsing/Highlighting Tests:</strong> <a href=\"../../test/index.html#r560\"\
    ><span class=\"viewcode-link\">[source]</span></a><a class=\"headerlink\" href=\"\
    #r560</a></p>\n</article>\n\n<script>setTimeout(function(){CodeMirror.colorize();},\
    \ 20);</script>\n\n \n    </article>\n  </section>\n\n  <section id=\"meta\">\n\
    \    <p>\n      For the last two <a href=\"http://meta.stackoverflow.com/questions/tagged/racket-specification\"\
    >Racket tagged questions</a>,\n      consider the following code:\n    </p>\n\n\
    \    <pre class=\"example\">\n#!racket", "  (= (mod n 2) 0))\n", "  (cond ((=\
    \ n 1) #f)\n        ((prime? n) #t)\n        (else (is_prime (quotient n 2)))))\n",
  "  (if (<= n 2)\n      false\n      (or (= (modulo n 7) 0)\n          (= (modulo\
    \ n 11) 0))))\n", "  (= (modulo n prime-count)\n     (modulo n prime-count))\n\
    \  (= (modulo n prime-count)\n     (modulo n prime-count)))\n", "  (define (is-prime\
    \ p k)\n    (cond ((= k 1) #t)\n          ((= p k) #f)\n          ((= (remainder\
    \ n k) 0) (is-prime p (- k 1)))))\n  (is-prime n 2))\n", "  (= (modulo n 2) 1))\n",
  "  (if (= n 1)\n      #f\n      (or (= (modulo n 2) 0)\n          (or (= (modulo\
    \ n 3) 0)\n              (or (= (modulo n 5) 0)\n                  (or (= (modulo\
    \ n 7) 0)\n                      (is_prime (- n 1))))))))\n", "  (< n 2)\n  ;;\
    \ Sieve of Eratosthenes:\n  ;; 1. For even numbers n > 2, we know that n is divisible\
    \ by 2 and\n  ;; so any number that ends in an even number is a composite.\n \
    \ ;; 2. For odd numbers n < 2, we know that n is composite.\n  (if (even? n)\n\
    \      (= (remainder n 2) 0)\n      #t))\n", "  (cond ((= n 2) #t)\n        ((=\
    \ n 3) #f)\n        ((= (sqrt-integer n) n) #t)\n        (else #f)))\n", "  (=\
    \ (remainder n 2) 0))\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThat is some serious\
    \ code. Thank you for sharing it.\n<|/ c |>\n<| c |>\nI wish I had thought of\
    \ this. The other answers here are correct, but this one really helped me understand.\
    \ Thank you!\n<|/ c |>\n<| a tags=racket,scheme |>\nI guess you are familiar with\
    \ recursion. Here's another solution using tail recursion:\n<code>", "  (< (expt\
    \ n 2) 2))\n</code>\n<|/ a dscore=1 |>\n<| c |>\nI made a few minor changes that\
    \ will make it run on Racket's command line.  It now prints either `prime: 13441`\
    \ or `prime: #t`.  The `for` loop is now a `while` loop and `if` branches are\
    \ only evaluated if necessary.  I also added a few tests for input of 0 or 1.\n\
    <|/ c |>\n<| a dscore=0 |>\nHere are two more implementations. One using list\
    \ comprehensions only, the other using map and filter. Both are functional programming\
    \ and will run faster. Just in case you need a non-functional solution too.\n\
    Non-Functional (Just for educational purposes)\n<code>", "  (if (= n 1)\n    \
    \  #f\n      (let ((i (floor (/ n 2))))\n        (if (= (mod n i) 0)\n       \
    \     #f\n            (begin (return #t) (is_prime i))))))\n", "  (let ((c (gcd\
    \ n 2)))\n    (if (= c 0)\n        #f\n        (if (= (modulo n c) 0)\n      \
    \      #t\n            (is_prime n)))))\n</cell>\n<text>\nExercise 2\nWrite a\
    \ function that computes the nth fibonacci number in the Fibonacci sequence.\n\
    \n\n</text>\n<cell>\n#lang racket\n", "  (prime? n #t))\n", "  (if (= n 1)\n \
    \     #f\n      (let loop ((i 2) (c 'a))\n        (cond ((= i n) (not c))\n  \
    \            ((odd? i) c)\n              (else (loop (+ i 1) (loop (- i 1) c)))))))\n",
  "  (let loop ((i n) (s #t))\n    (if (= i 1)\n        ; If n is 1, then return #t.\n\
    \        ; Otherwise, return #f.\n        (eq? i 1)\n        s)\n    (loop (/\
    \ i 2) (or (not (= (mod* i i) n)) s))))\n", "  (if (= n 1)\n      #f\n      (and\
    \ (<= n 2)\n           (is_prime (sub1 n)))))\n", "  (cond ((= n 1) #t)\n    \
    \    ((= n 2) #t)\n        ((= n 3) #t)\n        ((= (% n 3) 2) #f)\n        (else\
    \ (is_prime (/ n 2)))))\n", "  (let ((c (car factors)))\n    (cond\n      [(null?\
    \ factors) false]\n      [else (<= n (* (first factors) n)) (is_prime n)]\n  \
    \    [else\n      (let ((i (min (+ (first factors) 1) (- n 1))))\n        (cond\n\
    \          [(null? factors) false]\n          [(<= i factors) (is_prime n)]\n\
    \          [else (is_prime n)]\n          ))]\n      ]))\n  )\n)\n", "  (and (number?\
    \ n) (= n 2) (= (modulo n n) 1)))\n  ;; Return the next prime greater than or\
    \ equal to N.\n", "  (cond\n    [(= n 2) #t]\n    [(= n 3) #f]\n    [else (> (prime\
    \ n) 0) (is_prime (+ n 1))]))\n", "  (<= n (/ (+ 1 n) (expt 2 n))\n      ;; This\
    \ could be optimized to stop testing if the\n      ;; result of the division was\
    \ 2, but this would be\n      ;; a little trickier to do properly.\n      ;; This\
    \ is because of the way racket handles\n      ;; negative numbers, -1 / 2 = -1\n\
    \      2))\n</cell>\n<cell>\n#lang racket\n", "  (if (= n 1)\n      #f\n     \
    \ (if (even? n)\n          (or (is_prime (/ n 2))\n              (is_prime (/\
    \ n 3)))\n          #t\n          #f))))\n", "  (cond [(= n 1) #t]\n        [(=\
    \ n 2) #f]\n        [(even? n) (is_prime (/ n 2))]\n        [else (or (is_prime\
    \ (/ n 3))\n                   (is_prime (/ n 5))))]))\n", "  (cond\n    ((= n\
    \ 2) #t)\n    ((prime? n) #f)\n    (else\n     (let* ((n-minus 1 (- n 2))\n  \
    \          (mult 2 (add1 (- n 1))))\n       (while (< n-minus 1)\n         (let\
    \ ((product (* mult mult)))\n           (if (< product n)\n               (cons\
    \ product (is_prime (+ n product)))\n               #f)))))))\n", "  (cond [(=\
    \ n 1) #t]\n        [(zero? (divide-by-one n)) #f]\n        [else (prime? (divide-by-two\
    \ n))]))\n", "  (= (mod-prime n 2) 1))\n", "  (if (< n 2)\n      #f\n      (if\
    \ (odd? n)\n          (is_prime (- n 1))\n          (= (modulo n n #t) #f)\n \
    \         (= (modulo n n #f) #t))))\n", "  (= (modulo (+ n 1) 2) n))\n", "  (let\
    \ loop ((n n) (k 0) (acc #f))\n    (cond ((= n 1) (= acc #t)) acc\n          ((zero?\
    \ (modulo n k)) (not acc))\n          (else (loop (quotient n k) (+ 1 k) acc))))))\n",
  "  (cond [(= n 1) #t]\n        [(< n 2) #f]\n        [(<= (mod n 3) 1) #t]\n   \
    \     [else (is_prime (- n 1))]))\n", "  (cond\n    [(= n 2) #f]\n    [(= n 0)\
    \ #f]\n    [(zero? n) #f]\n    [else (let ([i (+ 1 n)]) (not (prime? i)))]))\n",
  "  (cond ((= n 1) #f) \n        ((= n 2) #f)\n        ((< n 3) #t)\n        (else\
    \ (= (% n 3) 0) (is_prime (quotient n 3)))))\n", "  (let loop ((n n)\n       \
    \      (found #f))\n    (cond ((< n 2) found)\n          ((= n 3) found)\n   \
    \       ((= n (/ n 2))\n           (loop (- n 1) found))\n          (else (loop\
    \ (+ n 1) (= n (/ n 2))))))\n  found)\n", "  (let ([divisible-by-one (lambda (n)\n\
    \                        (= n 1))]\n        [factors (list 1 2 3 5 7 11 13 17\
    \ 19)]\n        [primes (list 2)]\n        [squares (list 4)]\n        [prime\
    \ (first primes)]\n        [square 0 (first squares)])\n    (if (null? factors)\n\
    \    #f\n      (let loop ([product 1])\n        (cond [(< (+ product 1) n) (>\
    \ product (first primes))]\n              [else (loop (+ product 1))]\n      \
    \        [else (loop (+ product 1))])))\n    (let loop ([product 1])\n      (cond\
    \ [(< (+ product 1) n) (> product (first primes))]\n            [else (loop (+\
    \ product 1))]\n            [else (loop (+ product 1))])))\n  ;; If n is not prime,\
    \ then it must be divisible by one of the prime factors\n  (and (= n 1)\n    \
    \   (null? (divisible-by-one n)))\n  ;; Otherwise, n is prime, so return true\n\
    \  true)\n", "  (or (= (modulo n 2) 0)\n      (= (modulo n 3) 0)\n      (= (modulo\
    \ n 5) 0)\n      (= (modulo n 7) 0)\n      (= (modulo n 11) 0)\n      (= (modulo\
    \ n 13) 0)\n      (= (modulo n 17) 0)\n      (= (modulo n 19) 0)\n      (= (modulo\
    \ n 23) 0)\n      (= (modulo n 29) 0)\n      (= (modulo n 31) 0)\n      (= (modulo\
    \ n 37) 0)\n      (= (modulo n 41) 0)\n      (= (modulo n 43) 0)\n      (= (modulo\
    \ n 47) 0)\n      (= (modulo n 53) 0)\n      (= (modulo n 59) 0)\n      (= (modulo\
    \ n 61) 0)\n      (= (modulo n 67) 0)\n      (= (modulo n 71) 0)\n      (= (modulo\
    \ n 73) 0)\n      (= (modulo n 79) 0)\n      (= (modulo n 83) 0)\n      (= (modulo\
    \ n 89) 0)\n      (= (modulo n 91) 0)\n      (= (modulo n 101) 0)\n      (= (modulo\
    \ n 103) 0)\n      (= (modulo n 107) 0)\n      (= (modulo n 109) 0)\n      (=\
    \ (modulo n 113) 0)\n      (= (modulo n 117) 0)\n      (= (modulo n 121) 0)\n\
    \      (= (modulo n 127 0)\n      (= (modulo n 131) 0)\n      (= (modulo n 137)\
    \ 0)\n      (= (modulo n 139) 0)\n      (= (modulo n 143) 0)\n      (= (modulo\
    \ n 147) 0)\n      (= (modulo n 151) 0)\n      (= (modulo n 157) 0)\n      (=\
    \ (modulo n 163 0)\n      (= (modulo n 169) 0)\n      (= (modulo n 173) 0)\n \
    \     (= (modulo n 179) 0)\n      (= (modulo n 183) 0)\n      (= (modulo n 187\
    \ 0)\n      (= (modulo n 191 0)\n      (= (modulo n 193 0)\n      (= (modulo n\
    \ 197 0)\n      (= (modulo n 203 0)\n      (= (modulo n 207 0)\n      (= (modulo ",
  "  (for/or ((i 2 (+ n 1))\n            (p (+ i 2)\n              (+ 2 n)))\n   \
    \ (= (modulo (modulo n p) p)\n        p)))\n", "  (if (< n 1)\n      (= (modulo\
    \ n 2) 0)\n      (= (modulo n 3) 0)\n      (= (modulo n 4) 0)\n      (= (modulo\
    \ n 5) 0)\n      (= (modulo n 7) 0)\n      (= (modulo n 11) 0)\n      (= (modulo\
    \ n 13) 0)\n      (= (modulo n 17) 0)\n      (= (modulo n 19) 0)\n      (= (modulo\
    \ n 23) 0)\n      (= (modulo n 29) 0)\n      (= (modulo n 31) 0)\n      (= (modulo\
    \ n 37) 0)\n      (= (modulo n 41) 0)\n      (= (modulo n 43) 0)\n      (= (modulo\
    \ n 47) 0)\n      (= (modulo n 53) 0)\n      (= (modulo n 59) 0)\n      (= (modulo\
    \ n 61) 0)\n      (= (modulo n 67) 0)\n      (= (modulo n 71) 0)\n      (= (modulo\
    \ n 73) 0)\n      (= (modulo n 79) 0)\n      (= (modulo n 83) 0)\n      (= (modulo\
    \ n 89) 0)\n      (= (modulo n 97) 0)\n      (= (modulo n 101) 0)\n      (= (modulo\
    \ n 103) 0)\n      (= (modulo n 107) 0)\n      (= (modulo n 109) 0)\n      (=\
    \ (modulo n 113) 0)\n      (= (modulo n 117) 0)\n      (= (modulo n 121) 0)\n\
    \      (= (modulo n 127) 0)\n      (= (modulo n 131) 0)\n      (= (modulo n 137)\
    \ 0)\n      (= (modulo n 139) 0)\n      (= (modulo n 143) 0)\n      (= (modulo\
    \ n 147) 0)\n      (= (modulo n 151) 0)\n      (= (modulo n 157) 0)\n      (=\
    \ (modulo n 163) 0)\n      (= (modulo n 169) 0)\n      (= (modulo n 173) 0)\n\
    \      (= (modulo n 179) 0)\n      (= (modulo n 183) 0)\n      (= (modulo n 187)\
    \ 0)\n      (= (modulo n 191) 0)\n      (= (modulo n 193) 0)\n      (= (modulo\
    \ n 197) 0)\n      (= (modulo n 201) 0)\n      (", "  (cond [(= n 1) #t]\n   \
    \     [(< n 1) #f]\n        [else (let ([i (floor n 2)])\n              (if (=\
    \ i n)\n                  #f\n                  (or (is_prime (- n i)) (= n (-\
    \ n i))))])))\n", "  (or (= (length (primes n)) 0)\n      (and (even? n) (= (length\
    \ (primes n)) (ceiling (/ n 2))))))\n", "  (cond [(= n 1)                    #f]\n\
    \        [(= n 2)                    #t]\n        [else                      (or\
    \ (is_prime (- n 2)) (is_prime (- n 3)))]))\n", "  (cond [(= n 1) #t]\n      \
    \  [(or (= (prime? (car n)) 0)\n             (is_prime (cdr n)))\n         #t]\n\
    \        [else #f]))\n", "  (let ([prime (<= n 1)])\n    (cond [(= n 2)\n    \
    \       #t]\n          [(prime)\n           #f]\n          [else (is-prime (/\
    \ n 2))])))\n", "  (cond ((= n 1) #f)\n        ((odd? n) #f)\n        ((= (mod\
    \ n 2) 0) #t)\n        (else (is_prime (- n 1)))))\n", "  (cond [(zero? n) #f]\n\
    \        [(zero? (remainder n 2)) #f]\n        [else #t]))\n", "  (cond ((= n\
    \ 1) #f)\n        ((= n 2) #t)\n        (else (> (expt 2 n) (expt 3 n)))))\n",
  "  (cond ((= n 1) #t)\n        ((= (mod-n n) 0) #f)\n        (else (is_prime (sub1\
    \ n)))\n))\n", "  (cond ((= n 1) #t)\n        (else (and (not (odd? n)) (= (gcd\
    \ n 2) 1))\n              #t)))\n", "  (cond ((= n 1) #t)\n        ((even? n)\
    \ #f)\n        (else (= (gcd n 2) n) #t)))\n</textarea></form>\n\n    <script>\n\
    \      var editor = CodeMirror.fromTextArea(document.getElementById(\"code\"),\
    \ {\n        lineNumbers: true,\n        matchBrackets: true,\n        mode: \"\
    text/x-scheme\"\n      });\n    </script>\n\n    <p><strong>MIME types defined:</strong>\
    \ <code>text/x-scheme</code>.</p>\n\n    <p>The Racket implementation is also\
    \ available as a <a href=\"https://www.racket-lang.org/\">Racket</a> module.\n\
    \    If you find this content useful, please consider supporting the work by\n\
    \    <a href=\"https://htmledit.squarefree.com/\">HTMLEdit</a> or <a href=\"mailto:removed@example.com\"\
    >email</a>.</p>\n</article>\n\n<section id=\"section-5\">\n<h2><a name=\"writing-your-own-minimax\"\
    \ href=\"#writing-your-own-minimax\">Writing your own minimax</a></h2>\n\n<p style=\"\
    font-size: 50%\">\nThis section describes two simple implementations of minimax\
    \ that you can use\nto develop your game.\n</p>\n\n<p style=\"font-size: 50%\"\
    >\nThe first implements a game in which all moves are win conditions.\nThis means\
    \ that it's guaranteed that if you're playing against an opponent,\nthe game will\
    \ end when you reach a win condition, or if you win with a\nnon-winning move.\n\
    </p>\n\n<p style=\"font-size: 50%\">\nThe second implementation is much simpler:\
    \ if you know the value of a\ncertain position, and you know the opponent's move,\
    \ it's easy to figure out\nthe value of the other position. You can use this information\
    \ to implement\nthe alpha-beta pruning algorithm.\n</p>\n</section>\n\n<section\
    \ id=\"section-6\">\n<h2><a name=\"the-alpha-beta-pruning-algorithm\" href=\"\
    #the-alpha-beta-pruning-algorithm\">The Alpha-Beta pruning algorithm</a></h2>\n\
    \n<p style=\"font-size: 50%\">\nThe Alpha-Beta algorithm is a simple pruning algorithm.\n\
    It works by \"pruning\" the best move from the open set, whenever you\nmake a\
    \ new best move.\n</p>\n\n<p style=\"font-size: 50%\">\nThe open set contains\
    \ all the positions you're about to play, and\nthe best move you have. If you're\
    \ currently playing position X, and\nthe best move you made was position Y, then\
    \ you can prune Y from your\nopen set, because it's obviously better than X. If\
    \ Y was the best\nmove you could play, then you can remove it from your open set,\
    \ and that's\nall you need to do if you made Y a better move ", "  (if (<= n 2)\n\
    \      (= (modulo n 3) 0)\n      (if (even? n)\n          (= (modulo n 2) 0)\n\
    \          (= (modulo n 3) 1)\n          (= (modulo n 5) 0)\n          (= (modulo\
    \ n 7) 0)\n          (= (modulo n 11) 0)\n          (= (modulo n 13) 0)\n    \
    \      (= (modulo n 17) 0)\n          (= (modulo n 19) 0)\n          (= (modulo\
    \ n 23) 0)\n          (= (modulo n 29) 0)\n          (= (modulo n 31) 0)\n   \
    \       (= (modulo n 37) 0)\n          (= (modulo n 41) 0)\n          (= (modulo\
    \ n 43) 0)\n          (= (modulo n 47) 0)\n          (= (modulo n 53) 0)\n   \
    \       (= (modulo n 59) 0)\n          (= (modulo n 61) 0)\n          (= (modulo\
    \ n 67) 0)\n          (= (modulo n 71) 0)\n          (= (modulo n 73) 0)\n   \
    \       (= (modulo n 79) 0)\n          (= (modulo n 83) 0)\n          (= (modulo\
    \ n 89) 0)\n          (= (modulo n 91) 0)\n          (= (modulo n 97) 0)\n   \
    \       (= (modulo n 101) 0)\n          (= (modulo n 103) 0)\n          (= (modulo\
    \ n 107) 0)\n          (= (modulo n 109) 0)\n          (= (modulo n 113) 0)\n\
    \          (= (modulo n 117) 0)\n          (= (modulo n 121) 0)\n          (=\
    \ (modulo n 127) 0)\n          (= (modulo n 131) 0)\n          (= (modulo n 137)\
    \ 0)\n          (= (modulo n 139) 0)\n          (= (modulo n 143) 0)\n       \
    \   (= (modulo n 147) 0)\n          (= (modulo n 151) 0)\n          (= (modulo\
    \ n 157) 0)\n          (= (modulo n 163) 0)\n          (= (modulo n 169) 0)\n\
    \          (= (modulo n 173) 0)\n          (= (modulo n 177) 0)\n", "  (if (zero?\
    \ n) false (= (modulo n 2) 0)))\n", "  (and (integer? (remainder n 2)) \n    \
    \   (primes? n)))\n", "  (cond ((= n 2)) #t\n        ((< n 3)) #f\n        ((=\
    \ (remainder n 2) 0)\n         (= (is_prime (remainder n 2)) #t)\n         (else\
    \ (is_prime (remainder n 2)))))) ;; Side effect: modifies n.\n", "  (if (= n 1)\n\
    \      #f\n      (= (modulo n 2) 0)\n      (let ([p (primes n)])\n        (and\
    \ (= (length p) 2)\n             (= (first (reverse p)) n)\n             (is_prime\
    \ (first (reverse p))))))))\n", "  (cond [(= n 1) #f]\n        [(= n 2) #t]\n\
    \        [else\n         (<= (log n) 0 (* n 2))\n         #t]\n        ))\n",
  "  (= (gcd n 2) n))\n", "  (cond [(= n 1)\n         #f]\n        [(zero? n)\n  \
    \       #t]\n        [else\n         (let loop ((p 2)\n                     (rem\
    \ (quotient n p)))\n           (loop (+ p 1)\n                  (* p rem))\n \
    \          (= rem 1)\n           #t]\n        ))\n", "  (and (= 2 (remainder n\
    \ 2))\n       (= (mod (+ n 1) n) n)))\n", "  (let loop ((n n) (i 2))\n    (if\
    \ (= i n)\n        #t\n        (loop (quotient n i) (+ i 1)))))\n", "  (if (=\
    \ n 1)\n      #f\n      (let loop ((i 1))\n        (if (<= i n)\n            (if\
    \ (= (mod n i) 0)\n                #f\n                (loop (+ i 1)))))\n   \
    \   #f))\n", "  (let loop ((sqrt n) (i 1))\n    (if (< i sqrt)\n        (or (zero?\
    \ (remainder n i))\n            (not (is_prime (+ i 1)))\n            (not (is_prime\
    \ (- i 1))))\n        (not (odd? n)))))\n", "  (cond [(= n 1) #t]\n        [else\
    \ (= (modulo n 2) 0)]\n  )\n)\n", "  (if (= n 1)\n      #f\n      (let ((factors\
    \ (list-ref (list-ref (prime-factors n) 0) 0)))\n        (and (number? n)\n  \
    \           (number? factors)\n             (apply (lambda (x) (= (modulo n x)\
    \ 0)) factors)))))\n", "  (cond ((= n 1) #f)\n        ((= (mod n 2) 0) #t)\n \
    \       (else (or (is_prime (- n 1)) (is_prime (- n 2))))))\n", "  (define (try-to-divide\
    \ x y)\n    (cond ((< x y) #f) \n          ((eq? (modulo x y) 0) (try-to-divide\
    \ (+ x 1) y))\n          (else (try-to-divide (+ x 1) (modulo y x)))))\n  (if\
    \ (or (= n 2) (even? n)) (= n 2) #f) ; 2 or 4\n  (if (or (= n 3) (even? n)) (=\
    \ n 3) #f) ; 3 or 5\n  (if (or (= n 5) (even? n)) (= n 5) #f) ; 5\n  (if (< n\
    \ 8) (try-to-divide 2 2))       ; 8\n  (if (< n 11) (try-to-divide 3 3))     \
    \  ; 11\n  (if (< n 13) (try-to-divide 5 5))       ; 13\n  (if (< n 17) (try-to-divide\
    \ 7 7))       ; 17\n  (if (< n 19) (try-to-divide 9 9))       ; 19\n  (if (< n\
    \ 23) (try-to-divide 11 11))     ; 23\n  (if (< n 29) (try-to-divide 13 13)) \
    \    ; 29\n  (if (< n 31) (try-to-divide 15 15))     ; 31\n  (if (< n 37) (try-to-divide\
    \ 17 17))     ; 37\n  (if (< n 43) (try-to-divide 19 19))     ; 43\n  (if (< n\
    \ 49) (try-to-divide 23 23))     ; 49\n  (if (< n 53) (try-to-divide 29 29)) \
    \    ; 53\n  (if (< n 59) (try-to-divide 31 31))     ; 59\n  (if (< n 61) (try-to-divide\
    \ 37 37))     ; 61\n  (if (< n 67) (try-to-divide 43 43))     ; 67\n  (if (< n\
    \ 73) (try-to-divide 49 49))     ; 73\n  (if (< n 79) (try-to-divide 53 53)) \
    \    ; 79\n  (if (< n 83) (try-to-divide 59 59))     ; 83\n  (if (< n 89) (try-to-divide\
    \ 61 61))     ; 89\n  (if (< n 97) (try-to-divide 67 67))     ; 97\n  (if (< n\
    \ 101) (try-to-divide 73 73))     ; 101\n  (if (< n 103) (try-to-divide 79 79))\
    \     ; 103\n  (if (< n 107) (try-to-divide 83 83))     ; 107\n  (if (< n 111)\
    \ (try-to-divide 89 89))     ; 111", "  (cond [(zero? n) #f]\n        [(even?\
    \ n) #f]\n        [else (let ([d (remainder n 2)])\n               (is_prime d)\n\
    \               (cond [(zero? d) #t]\n                     [else #f])]))])\n",
  "  (= (modulo n 2) 1))\n", "  (let ([sieve (make-array (unsigned-byte 32) \n   \
    \                        :element-type '(unsigned-byte 8))))\n    (racket:for/fold\
    \ ([i 2] [acc #f])\n                  (([y n])\n                   (vector:memref-set!\
    \ sieve (unsigned-byte i) y)\n                   (vector:memref-set! sieve (unsigned-byte\
    \ i+1) (vector:memref-ref sieve (unsigned-byte i+1)) acc)\n                  \
    \ (vector:memref-set! sieve (unsigned-byte i+1) (vector:memref-ref sieve (unsigned-byte\
    \ i+1)) acc)))\n    (let ([y n])\n      (vector:memref-set! sieve (unsigned-byte\
    \ 32) y)\n      (vector:memref-set! sieve (unsigned-byte 32) (vector:memref-ref\
    \ sieve (unsigned-byte 32)) acc))))\n", "  (cond ((= n 2) #t)\n        ((odd?\
    \ n) (is_prime (- n 1)))\n        (else (and (<= n 6)\n                   (is_prime\
    \ (- n 2))))))\n", "  (cond [(zero? n) #f]\n        [(zero? (modulo n 2)) #f]\n\
    \        [else #t]))\n", "  (if (= n 1) #t\n      (let loop ((i 2))\n        (if\
    \ (= i n) #f\n            (loop (+ i 1))))))\n", "  (cond ((= n 1) #t)\n     \
    \   ((= n 2) #t)\n        ((= (mod n 3) 0) #f)\n        (else (= (= (mod n 5)\
    \ 0) (is_prime (+ n 1))))))\n", "  (cond ((= n 1) #t)\n        ((even? n) #f)\n\
    \        (else (let ((a (- n 1)))\n                 (loop for i from 2 to (* n\
    \ 2) #:when (= i a)\n                       #:do (set! a (+ a 1))\n          \
    \             #:until (= n a))\n                 (= a n))))))\n", "  (cond ((=\
    \ n 2) #t)\n        ((= n 3) #t)\n        ((odd? n) #f)\n        (else (and (is_prime\
    \ (- n 1)) (is_prime (- n 2))))))\n", "  (or (= n 1)\n      (= (expt n 2) n)))\n",
  "  (if (<= n 2)\n      #f\n      (> (expt n 2) (floor (/ n 2)))))\n", "  (or (=\
    \ n 2)\n      (and (not (= n 3))\n           (= (floor (+ (* 3 n) 2)) n))))\n",
  "  (< (* 2 n) (+ n 1)))\n", "  (= (modulo-arithmetic? n 2) 0))\n", "  (= (mod n\
    \ 2) 0))\n", "  (if (> n 1)\n      (and (integer? (modulo n 2))\n           (not\
    \ (is_prime (/ n 2))))\n      #t))\n", "  (= (mod n 2) 0))\n  ", "  (< n 2))\n",
  "  (define (is-factor? i j)\n    (<= i j))\n  (define (is-prime? i)\n    (and (not\
    \ (is-factor? i i))\n         (not (is-factor? i (- n 1)))))\n  (is-prime? n))\n",
  "  (< n (/ (* (+ 2 1) n) (+ (square n) (* n n))))\n)\n", "  (cond ((= n 1) #t)\n\
    \        ((odd? n) #f)\n        (else (prime? n))))\n", "  (cond ((= n 1) #f)\n\
    \        ((or (= (expt 2 n) 1)\n             (= n (sub1 n)))\n         (= n 2))\n\
    \        ((= n (sub1 n)) (is_prime (sub1 n)))\n        ((> (expt 2 n) 1) (= n\
    \ 2))\n        ((<= (expt 2 n) 1) (is_prime (sub1 n)))\n        (else (= (expt\
    \ 2 n) (sub1 n))))\n", "  (cond [(= n 1) #t]\n        [(= (remainder n 2) 0) #f]\n\
    \        [else (or (is_prime (remainder n 2))\n                   (is_prime (remainder\
    \ n 3) (+ n 1)))]))\n", "  (cond\n    ((zero? n) #f)\n    ((= n 1) #t)\n    ((=\
    \ (modulo (+ n 1) (+ n 2)) (mod n 2)) #t)\n    (else #f)\n  )\n)\n", "  (or (=\
    \ n 2) (even? (modulo-by-square-of-two? n n))))\n", "  (cond [(< n 2) #t]\n  \
    \      [(or (= (remainder n 2) 1) (= (remainder n 3) 0)) #f]\n        [(= (remainder\
    \ n 2) 0) #t]\n        [else (is_prime (remainder n 2))]))\n", "  (= (modulo n\
    \ 2 100) 0))\n", "  (cond [(= n 1) #f]\n        [(zero? (modulo-by-prime-number\
    \ n 7))\n         #f]\n        [(zero? (modulo-by-prime-number n 14))\n      \
    \   #f]\n        [else\n         (not (is_prime (modulo-by-prime-number n 7)))]))\n",
  "  (cond [(= n 1) #f]\n        [(zero? n) #t]\n        [(= (remainder n 2) 0) #f]\n\
    \        [else (or (is_prime (remainder n 2))\n                   (is_prime (remainder\
    \ (+ n 1) 2)))]))\n", "  (for/fold ([prime #f])\n            ([divisor n])\n \
    \   (if (= 0 (modulo n divisor))\n        (let ([prime #t])\n          (set! divisor\
    \ n-2)\n          prime)))\n  prime)\n", "  (cond [(= n 1) #f]\n        [(> n\
    \ 1) (is_prime (- n 1))]\n        [(even? n) (= (- n 1) (floor n 2))]\n      \
    \  [else (= (% n 3) 1)]))\n", "  (cond [(= n 1)\n         #t]\n        [(= (remainder\
    \ n 2) 0)\n         #f]\n        [else\n         (is_prime (remainder n 2))]))\n\
    </code>\nIt seems that it works in Scheme, and I've tested it with Racket, Python,\
    \ and Java.  It seems to me that the \"language\" for the code is Scheme, though\
    \ I'm not positive.\n<|/ a |>\n<| c |>\nThanks for pointing out the `remainder`\
    \ function.\n<|/ c |>\n<| c |>\nNo problem.  I thought it was a language thing,\
    \ but I could be wrong.\n<|/ c |>\n<| c |>\nThe language for the code is Scheme.\
    \ Scheme is derived from MIT/GNU Scheme for Macintosh, Linux, and Windows (and\
    \ other Unix systems). The only thing that makes it Scheme is the `#lang racket`\
    \ directive\n<|/ c |>\n<| c |>\nSo this is probably the most correct answer here,\
    \ although I personally would prefer a more idiomatic solution for prime testing,\
    \ like \"Sieve of Eratosthenes\".\n<|/ c |>\n<| c |>\n: that's why I started with\
    \ #lang racket. :)\n<|/ c |>\n<| a |>\nYou could use something like this to test\
    \ if it is prime or not:\n<code>", "  (for/or ([i 2])\n    (- (odd? (mod n i))\n\
    \       (even? (mod n i))))\n  (= i n)\n  (= n (* i (sqrt 2))))\n", "  (= (mod\
    \ n 2) 1))\n  ", "  (= n (floor (/ n 2))))\n", "  (define (trial x)\n    (if (=\
    \ x 1)\n        n\n        (if (even? x)\n            (trial (/ x 2))\n      \
    \      (not (or (= (trial x) (/ x 2))\n                     (= (trial x) (/ x\
    \ 3))))))))\n  (trial n))\n", "  (cond [(= n 2) #t]\n        [else (prime? (-\
    \ n 1))]))\n", "  (< (mod n prime) 1))\n</code>\n<|/ a |>\n<| a tags=scheme,racket\
    \ |>\nAnother approach is to use the prime number theorem to determine primes.\
    \  Using an Scheme language that has first-class procedures, this can easily be\
    \ accomplished.  For example, in Racket we can write:\n<code>", "  (cond [(= n\
    \ 1) #f]\n        [(< n 2) #f]\n        [(> (modulo n 3) 0) #f]\n        [else\
    \ (= (modulo n 3) 1)]))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
