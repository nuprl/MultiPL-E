name: HumanEval_136_largest_smallest_integers
language: rkt
prompt: "#lang racket\n\n;; Create a function that returns a list (a, b), where 'a'\
  \ is\n;; the largest of negative integers, and 'b' is the smallest\n;; of positive\
  \ integers in a list.\n;; If there is no negative or positive integers, return them\
  \ as #f.\n;; Examples:\n;; >>> (largest_smallest_integers (list 2 4 1 3 5 7))\n\
  ;; (list #f 1)\n;; >>> (largest_smallest_integers (list ))\n;; (list #f #f)\n;;\
  \ >>> (largest_smallest_integers (list 0))\n;; (list #f #f)\n(define (largest_smallest_integers\
  \ lst)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate largest_smallest_integers))\n\
  \    (check-equal? (candidate (list 2 4 1 3 5 7)) (list #f 1))\n    (check-equal?\
  \ (candidate (list 2 4 1 3 5 7 0)) (list #f 1))\n    (check-equal? (candidate (list\
  \ 1 3 2 4 5 6 -2)) (list -2 1))\n    (check-equal? (candidate (list 4 5 3 6 2 7\
  \ -7)) (list -7 2))\n    (check-equal? (candidate (list 7 3 8 4 9 2 5 -9)) (list\
  \ -9 2))\n    (check-equal? (candidate (list )) (list #f #f))\n    (check-equal?\
  \ (candidate (list 0)) (list #f #f))\n    (check-equal? (candidate (list -1 -3 -5\
  \ -6)) (list -1 #f))\n    (check-equal? (candidate (list -1 -3 -5 -6 0)) (list -1\
  \ #f))\n    (check-equal? (candidate (list -6 -4 -4 -3 1)) (list -3 1))\n    (check-equal?\
  \ (candidate (list -6 -4 -4 -3 -100 1)) (list -3 1))\n))\n\n(test-humaneval)"
completions: ["  (cond [(empty? lst)\n         (list #f #f)] [(< (first lst) 0) (list\
    \ (first lst) #f #f)] [(> (first lst) 0)\n                                   \
    \                       (list #f (first lst))]))\n", "  (let ([a (max 0 (map -\
    \ (rest lst)) #f (map - (rest lst))))]\n        [b (min 0 (map - (rest lst)) #f\
    \ (map - (rest lst)))]))\n", "  (cond\n    ((null? lst) (list #f #f))\n    ((number?\
    \ first lst) (list first first))\n    ((equal? (first lst) 0)\n     (cond\n  \
    \     ((null? (rest lst)) (list #f #f))\n       ((equal? (first lst) (second lst))\
    \ (list first first))\n       (else (list first first))))\n    (else\n     (cond\n\
    \       ((null? (rest lst)) (list #f #f))\n       (else (append (largest_smallest_integers\
    \ first)\n                    (largest_smallest_integers (rest lst)))))\n    )))\n",
  "  (if (empty? lst)\n      #f\n      (let ((smallest (car lst))\n            (largest\
    \ (first lst)))\n        (cond ((< (- smallest largest) (first lst))\n       \
    \        (cons (- smallest largest) \n                     (largest (rest lst))))\n\
    \               ((> (first lst) largest)\n               (cons smallest \n   \
    \                  (smallest (rest lst))))\n               (else\n           \
    \    (largest_smallest_integers (rest lst)))))))\n", "  (cond [(empty? lst)\n\
    \         (list #f #f #f #f #f #f #f #f #f #f #f)\n         ;; else (largest_smallest_integers\
    \ (cdr lst))\n         (largest_smallest_integers (cdr lst))]\n        [(< (first\
    \ lst) 0)\n         (largest_smallest_integers (cons (first lst) (cons (first\
    \ lst) (cdr lst)))]\n        [else (largest_smallest_integers (cdr lst))]))\n",
  "  (cond\n    [(empty? lst)\n     (list #f #f)\n     (let\n       ([smallest (first\
    \ lst)]\n        [largest #f])\n       (cond\n         [(or (< smallest 0) (<\
    \ largest 0))\n          (list smallest largest)\n          #t]\n         [(>=\
    \ smallest 0)\n          (largest_smallest_integers (rest lst))\n          (if\
    \ (not (< smallest 0)) (list smallest largest)\n             #f)\n          (if\
    \ (not (>= smallest 0)) (list largest smallest)\n             #f)]))]\n    [else\n\
    \     (largest_smallest_integers (rest lst))\n     (let ([smallest (first lst)])\n\
    \       (cond\n         [(or (< smallest 0) (< largest 0))\n          (list smallest\
    \ largest)\n          #t]\n         [(>= smallest 0)\n          (largest_smallest_integers\
    \ (rest lst))\n          (if (not (< smallest 0)) (list smallest largest)\n  \
    \           #f)\n          (if (not (>= smallest 0)) (list largest smallest)\n\
    \             #f)]))]))\n", "  (cond [(null? lst)\n         (list #f #f (if (null?\
    \ (cdr lst)) 0 (car lst)))]\n        [(> (car lst) #f)\n         (if (null? (cdr\
    \ lst)) (list #f #f (car lst))\n               (cons (car lst) (list (car lst)\
    \ (if (null? (cdr lst)) 0 (car lst))))]\n        [(< (car lst) #f)\n         (if\
    \ (null? (cdr lst)) (list #f #f (car lst))\n               (cons (car lst) (list\
    \ (car lst) (if (null? (cdr lst)) 0 (car lst))))]\n        [else (cons (car lst)\
    \ (list (car lst) (if (null? (cdr lst)) 0 (car lst)))]))\n", "  (cond\n    [(empty?\
    \ lst)\n     (list #f #f)\n    ]\n    [(< (first lst) (first rest))\n     (largest_smallest_integers\
    \ (rest lst))\n    ]\n    [else\n     (largest_smallest_integers (rest lst))\n\
    \     (first lst)\n    ]\n   )\n  )\n  ", "  (let loop ((largest #f) (smallest\
    \ #f) (lst (reverse lst)))\n    (cond ((null? lst) (list #f #f))\n          ((integer?\
    \ (car lst))\n           (loop\n            (let ((larger (car lst)) (smallest\
    \ (car lst)))\n               (cdr lst))\n            (cond\n              ((>\
    \ largest -largest) (list largest smallest))\n              ((< smallest -largest)\
    \ (list largest smallest))\n              (else (list largest smallest))))\n \
    \         (else (loop\n                  (let ((larger (car lst)) (smallest (car\
    \ lst)))\n                    (cond\n                      ((> largest -largest)\
    \ (list larger smallest))\n                      ((< smallest -largest) (list\
    \ larger smallest))\n                      (else (list larger smallest))))\n \
    \                 (cdr lst))))))\n", "  (cond [(null? lst)\n         #f]\n   \
    \     [(zero? (first lst))\n         (largest_smallest_integers (rest lst))]\n\
    \        [else\n         (cond [(< (first lst) (- (first lst) 1))\n          \
    \       #t]\n               [else (largest_smallest_integers (rest lst))])]))\n\
    \n#lang racket\n", "  (cond\n    ((null? lst)\n     (list #f #f))\n    ((< (car\
    \ lst) (cadr lst))\n     (list (car lst) (cadr lst)))\n    ((> (car lst) (cadr\
    \ lst))\n     (list (car lst) (cadr lst)))\n    (else\n     (largest_smallest_integers\
    \ (cdr lst)))))\n", "  (cond ((null? lst)\n         (list #f #f))\n        ((member\
    \ (car lst)\n                 (negative-integers (cdr lst)))\n         (list car\
    \ cdr))\n        (else\n         (largest_smallest_integers (cdr lst)))))\n",
  "  (let ([big (first lst)\n        small (rest lst)])\n    (cond\n      [(< small\
    \ big) (list small big)]\n      [(> small big) (list big small)]\n      [else\
    \ (list big small)])))\n", "  (cond\n    [(empty? lst) (list #f #f #f)\n     ((member\
    \ (first lst) (list (- #f #f (first lst))) #t) (list #f (first lst) (first lst))\n\
    \     (else\n      (cond\n        [(null? (rest lst)) (list #f #f #f)\n      \
    \   ((member (first lst) (list (- #f #f (first lst))) #t) (list #f (first lst)\
    \ (first lst))\n         (else (append (largest_smallest_integers (rest lst))\
    \ (list (first lst))))]))]))\n", "  (if (empty? lst)\n      ;; If there are no\
    \ integers, return them as #f.\n      (list #f #f)\n      (let ((a (car lst))\n\
    \            (b (cdr lst)))\n        (if (< (- b) a)\n          ;; If 'a' is negative,\
    \ then 'b' is positive.\n          (cons b a)\n          ;; If 'a' is positive,\
    \ then 'b' is negative.\n          (cons a (- b))))))\n", "  (if (or (null? lst)\
    \ (empty? lst))\n      (list #f #f)\n      (let ((max-negative-value (first lst))\n\
    \            (max-positive-value (first lst)))\n        (if (> (first lst) max-negative-value)\n\
    \            (cons max-negative-value (largest_smallest_integers (rest lst)))\n\
    \            (if (< (first lst) max-positive-value)\n                (cons max-positive-value\
    \ (largest_smallest_integers (rest lst)))\n                (cons lst '())))))\n",
  "  (cond\n    ((null? lst)\n     (list #f #f))\n    ((< (car lst) 0)\n     (list\
    \ (car lst) #f))\n    ((< (cdr lst) 0)\n     (list (car lst) (cdr lst)))\n   \
    \ (else (largest_smallest_integers (cdr lst))))\n  )\n", "  (define (helper lst\
    \ smallest smallest pos)\n    (if (null? lst)\n        (values smallest smallest\
    \ pos)\n        (let ((a (car lst))\n              (b (cdr lst)))\n          (if\
    \ (or (< a 0) (< b 0))\n              (values smallest smallest pos)\n       \
    \       (if (< a b)\n                  (helper (cdr lst) a smallest pos)\n   \
    \               (helper (cdr lst) b smallest pos))))))\n  (helper lst #f #f #f))\n",
  "  (cond\n    [(empty? lst)\n     (list #f #f)\n     (let ([smallest (first lst)])\n\
    \       (cond\n         [(< smallest 0)\n          (list #f #f)]\n         [else\n\
    \          (let ([max (first lst)])\n            (cond\n              [(< max\
    \ 0)\n               (list smallest #f)]\n              [else\n              \
    \ (list max smallest)]))]))]\n    [else\n     (let ([smallest (first lst)])\n\
    \       (cond\n         [(< smallest 0)\n          (list #f #f)]\n         [else\n\
    \          (let ([max (first lst)])\n            (cond\n              [(< max\
    \ 0)\n               (list smallest #f)]\n              [else\n              \
    \ (list max smallest)]))\n          (append (largest_smallest_integers (rest lst))\
    \ (largest_smallest_integers (rest lst)))]))]))\n", "  (cond\n    [(null? lst)\n\
    \     (list #f #f)\n     (let ([a (first lst)\n            b (second lst)])\n\
    \       (cond\n         [(< a #f)\n          (list a b)\n          (cond [(< b\
    \ #f)\n                 (list a b)\n                 (list (+ a b) (- a b)))]\n\
    \         [else (list #f #f)]))]\n    [else\n     (let ([a (first lst)\n     \
    \       b (second lst)])\n       (cond\n         [(< a #f)\n          (list a\
    \ b)\n          (cond\n             [(< b #f)\n              (list a b)\n    \
    \          (list (+ a b) (- a b)))]\n         [else (list (+ a b) (- a b)))])]))\
    \ ; #lang racket\n))\n", "  (if (empty? lst)\n      #f\n      (let ((max-value\
    \ (first lst))\n            (min-value (second lst)))\n        (cond ((or (empty?\
    \ lst) (< max-value min-value))\n              (list max-value min-value))\n \
    \             (else\n              (largest_smallest_integers (rest lst))))))\n\
    \n#lang racket", "  (cond ((empty? lst) (list #f #f))\n        ((< (first lst)\
    \ 0)\n         (cons (first lst) (largest_smallest_integers (rest lst))))\n  \
    \      (else\n         (largest_smallest_integers (rest lst))))\n</code>\nNow\
    \ let's go back to our homework question:\n\nWrite a function largest_positive_integers\
    \ that returns a list of the integers from 1 to 100,000. Add up to at least 5000,\
    \ and there must be at least two of each positive and negative integer. You may\
    \ find that some numbers are more likely to be negative than positive than they\
    \ are to be positive. In that case, use #f for both for them and #t for either\
    \ of them. You may have to use two separate functions.\n\nOkay, one approach is\
    \ to make a function that returns a list, but that returns #f for everything,\
    \ and #t for either of the positive and negative numbers. So we might use that\
    \ in our main function, like this:\n<code>", "  (let ((largest-integer (first\
    \ lst))\n        (smallest-integer (rest lst)))\n    (cond ((null? lst)\n    \
    \       (list largest smallest))\n          ((< smallest largest)\n          \
    \ (list largest smallest))\n          ((< largest largest)\n           (list largest\
    \ smallest))\n          (else\n           (list largest smallest))))", "  (cond\n\
    \    ((empty? lst) #f)\n    ((empty? (cdr lst)) (first lst))\n    ((< 0 (second\
    \ (cdr lst))) (cons (first lst) (largest_smallest_integers (cdr lst))))\n    ((<\
    \ 0 (first (cdr lst))) (largest_smallest_integers (cdr lst)))))\n\n#lang racket\n",
  "  (let loop ((lst lst) (acc (list #f #f)))\n    (cond ((null? lst) acc)\n     \
    \     ((and (integer? (car lst)) (<= (car lst) #f))\n           (loop (cdr lst)\
    \ (append (list car lst) acc)))\n          (else (loop (cdr lst) (cons (car lst)\
    \ acc)))))\n", "  (if (or (null? lst) (empty? lst))\n      (list #f #f)\n    \
    \  (let ((max (car lst)))\n        (if (> (car lst) max) (list max (car lst))\n\
    \          (if (< (car lst) max) (list max max) \n            (let ((min (car\
    \ (cdr lst))))\n              (if (< (car lst) min) (list min min)\n         \
    \       (if (> (car lst) min) (list min max))))))))\n</code>\n<|/ a |>\n<| a tags=scheme\
    \ |>\nJust for fun here is another solution using lambdas:\n<code>", "  (cond\n\
    \    ((or (null? lst) (null? (cdr lst)))\n     (list #f #f)\n    (else (cond\n\
    \           ((or (< 0 (car lst)) (> 0 (car lst)))\n            (largest_smallest_integers\
    \ (cdr lst)))\n           (else\n            (largest_smallest_integers (cdr lst)))))))\n",
  "  (cond [(empty? lst) (list #f #f)] \n        [(cons? first)(cons (largest_smallest_integers\
    \ (rest lst)) \n          (largest_smallest_integers (rest lst)))]\n        [else\
    \ (cons first \n                  (largest_smallest_integers (rest lst)))]))\n",
  "  (cond [(null? lst)\n         (list #f #f)] \n        [(> (car lst) (largest-positive-integer\
    \ (cdr lst)))\n         (cons (car lst) (largest-positive-integer (cdr lst)))]\n\
    \        [else\n         (largest_smallest_integers (cdr lst))]))\n", "  (cond\
    \ [(null? lst) (list #f #f)]\n        [(negative? (car lst)) (list (car lst) (smallest-negative-integer\
    \ (cdr lst)))]\n        [(positive? (car lst)) (list (car lst) (largest-positive-integer\
    \ (cdr lst)))]\n        [else (largest_smallest_integers (cdr lst))]))\n", " \
    \ (let ((a (first lst))\n        (b (second lst)))\n    (cond\n      [(or (< a\
    \ b) (< b a)) (list a b)]\n      [else (list a b)]))\n  )\n", "  (cond [(null?\
    \ lst)\n         (list #f #f)\n         (and (number? (car lst))\n           \
    \   (<= (- (car lst) 0) (car (cdr lst))))]\n        [(number? (car lst))\n   \
    \      (if (<= (- (car lst) 0) (car (cdr lst)))\n             (list (car lst)\
    \ (car (cdr lst)))\n             (list (car lst) #f))\n         (largest_smallest_integers\
    \ (cdr lst))]))\n", "  (if (or (null? lst) (= (length lst) 1))\n      (cons (car\
    \ lst)\n            (if (or (= (car (rest lst)) #f)\n                    (< (car\
    \ lst) (car (rest lst))))\n                (cons (car lst)\n                 \
    \     (cons (cdr (rest lst))\n                            (cons (car lst) (cons\
    \ (cdr (rest lst)) #f)))))\n      (let ((largest (car lst))\n            (smallest\
    \ (car (rest lst))))\n        (if (or (= (length lst) 2)\n                (not\
    \ (= smallest #f)))\n            (cons largest smallest)\n            (cons largest\
    \ smallest\n                  (largest_smallest_integers (cdr lst)))))\n     \
    \ #f))\n", "  (cond ((null? lst) '())\n        ((> (first lst) 0) (list (first\
    \ lst) (second lst)))\n        (else (if (> (second lst) 0) (list (first lst)\
    \ (second lst)) (list (first lst) '#f)))))\n", "  (cond ((null? lst) #f)\n   \
    \     ((< 0 (first lst)) (list 0 (first lst)))\n        (else (cons (first (first\
    \ lst)) (largest_smallest_integers (rest lst))))))\n", "  (let ([lst-len (length\
    \ lst)])\n    (cond [(> lst-len 0) (list #f #f)] \n          [(> lst-len 1) (cons\
    \ (car lst) (cdr lst))]\n          [else (let ([smallest (car lst)]) (let ([largest\
    \ (car lst)])\n                                            (if (> smallest largest)\n\
    \                                            (let ([smallest (car lst)])\n   \
    \                                           (let ([largest (car lst)])\n     \
    \                                           (cons smallest largest)))))]))))\n\
    \      ", "  (let loop ((lst lst) (a #f) (b #t))\n    (if (null? lst)\n      \
    \  a\n        (loop (cdr lst)\n              (if (< a (car lst))\n           \
    \       a\n                  (car lst))\n              (b f))))))\n", "  (cond\n\
    \    [(empty? lst)\n     (list #f #f)]\n    [(null? (car lst)) (list #f #f)]\n\
    \    [(< (car lst) 0)\n     (cons (car lst) (largest_smallest_integers (cdr lst)))]\n\
    \    [else (largest_smallest_integers (cdr lst))]))\n", "  (cond [(empty? lst)\n\
    \         (list #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f\
    \ #f #f #f)\n         ;; This could be a better solution.\n         [(not (integer?\
    \ (first lst)))\n          (largest_smallest_integers (rest lst))]\n         [(integer?\
    \ (first lst))\n          (largest_smallest_integers (rest lst))]\n         [else\n\
    \          (let ([a (largest (first lst)) (b (smallest (first lst)))]\n      \
    \          [rest (rest lst)])\n            (largest-smallest a b (largest_smallest_integers\
    \ rest)))]))\n", "  (cond\n    [(empty? lst) (list #f #f)]\n    [(= (first lst)\
    \ 0) (list #f #f)]\n    [else (cond\n             [(< (first lst) 0) (list #f\
    \ (first lst))]\n             [(> (first lst) 0) (list (first lst) #f)]\n    \
    \         [else (largest_smallest_integers (rest lst))]))]))\n", "  (cond [(empty?\
    \ lst) '()]\n        [(< (first lst) 0) '(first (first lst))]\n        [else (first\
    \ lst)]))\n", "  (cond [(null? lst) '()]\n        [(and (number? first) (negative?\
    \ first)) (list (max (first lst)) (min (first lst)))]\n        [else (largest_smallest_integers\
    \ (rest lst))]))\n</code>\n<|/ a |>\n<| c |>\nThis was my first thought too, to\
    \ sort and then reverse, but this would require the list to be sorted already.\
    \ Not sure if this is what the OP wants, but I assume it is.\n<|/ c |>\n<| c |>\n\
    It's not very efficient for large lists, as it requires recalculation of all elements\
    \ in the list after each change. Though a simple sort can easily be modified to\
    \ work this way, it still requires recalculation of all elements after each change,\
    \ which is what the question is about.\n<|/ c |>\n<| c |>\n: This solution is\
    \ O(n log n), which is better than the O(n^2) of the naive approach, which would\
    \ require a full recalculation of all elements after each change. It also preserves\
    \ the original ordering which would not be possible if a new list was produced\
    \ after each change. Of course it does require a full recalculation of all elements\
    \ after each change, as it can't just be done lazily by comparing each element\
    \ to the previous one.\n<|/ c |>\n<| a tags=functional-programming,sorting,racket,scheme\
    \ |>\nI like your idea of implementing it as a pair of separate procedures; it's\
    \ really a great idea.  And it could really use the benefits of functional programming...\n\
    However, if you wanted to keep it all in one procedure, you could do it as follows:\n\
    <code>", "  (cond\n    [(empty? lst) '#f]\n    [(< (first lst) (first rest)) (largest_smallest_integers\
    \ rest)]\n    [(> (first lst) (first rest)) (largest_smallest_integers rest)]))\n\
    </cell>\n<cell>\n#lang racket\n", "  (cond ((empty? lst) (list #f #f))\n     \
    \   ((> (first lst) 0) (list #f (first lst)))\n        (else (largest_smallest_integers\
    \ (rest lst)))))\n", "  (cond ((null? lst)\n         #f)\n        (else (let ([a\
    \ (- (car lst) (car lst))])\n                  (b (car lst))\n               \
    \   (largest-smallest-integers a b lst)))))", "  (cond\n    ((null? lst)\n   \
    \  (list (number->string #f) #f))\n    ((number? (car lst))\n     (list (number->string\
    \ (car lst)) (number->string #f))\n    (else\n     (let ((largest (car lst))\n\
    \           (smallest (car lst)))\n       (cond\n         ((< smallest largest)\n\
    \          (list (number->string largest)\n                 (number->string smallest)))\n\
    \         ((< largest (car lst))\n          (list (number->string largest)\n \
    \                (number->string (car lst))))\n         ((< largest (car lst)\
    \ smallest)\n          (list (number->string largest)\n                 (number->string\
    \ (min largest (car lst)))))))))\n</code>\n<code>\n#lang racket\n", "  (cond\n\
    \    [(empty? lst) (list #f #f)]\n    [(= (first lst) -#inf ) (list #f (first\
    \ lst))]\n    [(= (first lst) #inf ) (list #f (first lst))]\n    [else (cons (max\
    \ (first lst) (largest_smallest_integers (rest lst))))]))\n", "  (cond [(null?\
    \ lst) '()]\n        [(< (first lst) #f)\n         (cons (first lst) (largest_smallest_integers\
    \ (rest lst)))]\n        [else\n         (largest_smallest_integers (rest lst))]))\n",
  "  (cond [(empty? lst)\n         #f]\n        [(integer? (car lst))\n         (cons\
    \ (car lst)\n              (largest_smallest_integers (cdr lst)))]\n        [else\n\
    \         (let ((a (largest_smallest_integers (cdr lst)))\n              (b (largest_smallest_integers\
    \ (car lst))))\n           (cond [(< a b)\n                   (cons (car lst)\n\
    \                         (largest_smallest_integers (cdr lst)))]\n          \
    \        [(< b a)\n                   (cons (car lst)\n                      \
    \   (largest_smallest_integers (cdr lst)))]\n                  [else (cons (car\
    \ lst)\n                               (largest_smallest_integers (cdr lst)))])))]))\n",
  "  (cond\n    [(empty? lst) (list #f #f)]\n    [(positive? (first lst)) (cons (first\
    \ lst) (largest_smallest_integers (rest lst)))]\n    [else (cons (first lst) (largest_smallest_integers\
    \ (rest lst)))]\n  )\n)\n#lang racket\n", "  (if (empty? lst)\n      (list #f\
    \ #f)\n      (let ((largest (car lst))\n            (smallest (car lst)))\n  \
    \      (if (<= smallest -1)\n            (let ((new-largest (car lst))\n     \
    \             (new-largest (car lst)))\n              (cond ((< largest new-largest)\
    \ new-largest)\n                    (else largest)))\n        (if (< smallest\
    \ 0)\n            (let ((new-largest (car lst))\n                  (new-largest\
    \ (car lst)))\n              (cond ((< largest new-largest) new-largest)\n   \
    \                 (else smallest)))\n        (largest_smallest_integers (cdr lst)))))\n",
  "  (cond\n    ((null? lst)\n     (list #f))\n    ((> -1 lst)\n     (list (max (first\
    \ lst)) (min (first lst))))\n    (else (list (max (first lst)) (min (first lst))))))\n\
    </code>\n<|/ a tags=scheme,racket,lisp |>\n<| a dscore=0 |>\nHere are a couple\
    \ of more efficient functions:\n<code>", "  (cond [(null? lst) (list #f #f)]\n\
    \        [(zero? (car lst))\n         (list #f (-largest lst (cdr lst)))]\n  \
    \      [else (list #f (-largest lst #t))]))\n", "  (cond\n    ((null? lst) (list\
    \ #f #f))\n    ((< (first lst) 0) (list (first lst) #f #f))\n    ((< (first lst)\
    \ (- (first lst)))\n     (list (first lst) (first lst) #f #f))\n    (else (list\
    \ (first lst) (first lst) (first lst) (first lst))))) ;; #lang racket\n</code>\n\
    And here is the full solution:\n<code>", "  (cond [(empty? lst) (list #f #f)]\n\
    \        [(and (negative? (first lst)) (positive? (first lst))) (list (first lst)\
    \ (smallest (rest lst)))]\n        [else (list (first lst) (largest (rest lst)))]))\n",
  "  (define (largest_integer lst)\n    (if (null? lst)\n        0\n        (if (<\
    \ 0 (car lst))\n            (car lst)\n            (if (< (car lst) 0)\n     \
    \           (cadr lst)\n                (cdr lst)))))\n  (define (smallest_integer\
    \ lst)\n    (if (null? lst)\n        0\n        (if (> 0 (car lst))\n        \
    \    (car lst)\n            (if (> (car lst) 0)\n                (cadr lst)\n\
    \                (cdr lst)))))\n  (let loop ((lst lst) (result #f))\n    (if (null?\
    \ lst)\n        result\n        (if (< (largest_integer lst) (smallest_integer\
    \ lst))\n            (recur (cdr lst) (cons (largest_integer lst) result))\n \
    \           (recur (cdr lst) result))))))\n", "  (cond [(null? lst)\n        \
    \ #f]\n        [(null? (cdr lst))\n         (cons (car lst) (car lst))]\n    \
    \    [else\n         (let ((a (max 0 (car lst))))\n           (let ((b (min 1\
    \ (cdr lst))))\n             (cons a b))]))\n</code>\n<|/ a tags=racket,scheme\
    \ dscore=1 |>\n<| a dscore=1 |>\nI propose the following solution, which, when\
    \ applied to a list of positive integers gives the smallest and largest integers.\n\
    <code>\n#lang racket\n", "  (cond\n    ((null? lst) '())\n    ((not (pair? (car\
    \ lst)))\n     (cons (car lst) (largest_smallest_integers (cdr lst))))\n    ((<\
    \ (car lst) (- (car lst) (caar lst)))\n     (cons (car lst) (largest_smallest_integers\
    \ (cdr lst))))\n    (else (largest_smallest_integers (cdr lst)))))\n", "  (cond\n\
    \    [(empty? lst)\n     (list #f #f)\n     ((> ??? ???) #f #f)\n     :else (cons\
    \ (??? (largest_smallest_integers (rest lst))) (largest_smallest_integers (rest\
    \ lst)))]))\n", "  (cond ((null? lst) '(#f #f))\n        ((< 1 (car lst)) (list\
    \ 1 (car lst)))\n        (else (cons (car lst) (largest_smallest_integers (cdr\
    \ lst))))))\n", "  (cond\n    [(empty? lst) '()]\n    [(number? (first lst)) (cons\
    \ (first lst) '())]\n    [else (cons (max (first lst) (first lst)) (largest_smallest_integers\
    \ (rest lst)))]))\n", "  (cond\n    [(empty? lst)\n     (list #f #f #f #f #f #f\
    \ #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f\
    \ #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f\
    \ #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f\
    \ #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f\
    \ #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f\
    \ #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f\
    \ #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f\
    \ #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f\
    \ #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f\
    \ #f #f #f #f #f #f #f #f #f #f ", "  (if (null? lst)\n      (list #f #f)\n  \
    \    (let ((largest (car lst))\n            (smallest (cdr lst)))\n        (if\
    \ (or (= largest 0)\n                (= smallest 0))\n            (list #f largest)\n\
    \            (list largest smallest)\n            (if (or (= smallest 0)\n   \
    \                 (= largest 0))\n                (list smallest largest)\n  \
    \              (if (> largest smallest)\n                    (list largest smallest)\n\
    \                    (list smallest largest)\n                    (largest_smallest_integers\
    \ \n                      (remove-if (lambda (x) (> x largest)) \n           \
    \                     (remove-if (lambda (x) (< x smallest)) \n              \
    \                            (cdr lst))))))))\n", "  (cond [(empty? lst) (list\
    \ #f #f)] \n        [(<= (- (car lst) (caar lst)) (caar lst)) (cons (caar lst)\
    \ (largest_smallest_integers (cdr lst)))]\n        [else (largest_smallest_integers\
    \ (cdr lst))]))\n", "  (cond [(empty? lst)\n         #f]\n        [(or (null?\
    \ (car lst))\n             (null? (cdr lst)))\n         (list car lst)]\n    \
    \    [else\n         (let ([largest (max 0 (car lst))])\n           (cond [(>\
    \ largest 0 (car lst))\n                  (largest_smallest_integers (cdr lst))\n\
    \                  (list (max largest (car lst))\n                        largest)]\n\
    \                 [else\n                  (largest_smallest_integers (cdr lst))\n\
    \                  (list largest (max largest (car lst)))]))]))\n", "  (define\
    \ (helper lst max#) (if (empty? lst)\n                         (list max# #f)\n\
    \                         (if (< max# (car lst))\n                           \
    \  (helper (cdr lst)\n                                     (if (< max# (car lst))\n\
    \                                         max#\n                             \
    \            (car lst)))\n                             (helper (cdr lst)\n   \
    \                                  (if (< max# (car lst))\n                  \
    \                       max#\n                                         (car lst)))\n\
    \                             (helper lst\n                                  \
    \   (if (< max# (car lst))\n                                         max#\n  \
    \                                       (car lst))))))\n  (helper lst #f)\n)\n",
  "  (if (null? lst)\n      (list #f #f)\n      (let ([a (largest_smallest_integer\
    \ (cdr lst))]\n            [b (largest_smallest_integer (car lst))])\n       \
    \ (if (< a b)\n            (list (cons a b) b)\n            (list (list a b) a))))))\n",
  "  (if (null? lst)\n      (list #f #f)\n      (let ((largest (car lst))\n      \
    \      (smallest (car lst)))\n        (if (< (car lst) largest)\n            (list\
    \ (cons largest (largest (cdr lst)))\n                  smallest)\n          \
    \  (list (cons smallest smallest)))))\n", "  (cond ((null? lst)\n         #f)\n\
    \        ((= (rem* (car lst) 1) 0)\n         (append (largest_smallest_integers\
    \ (cdr lst)) (list (car lst)))\n         (largest_smallest_integers (cdr lst)))\n\
    \        (else\n         (append (largest_smallest_integers (cdr lst))\n     \
    \            (list (car lst))))))\n</code>\n<|/ q tags=scheme,racket |>\n<| a\
    \ tags=scheme,racket dscore=0 |>\n<code>", "  (if (or (empty? lst) (null? (cdr\
    \ lst)))\n      (cons (car lst)\n            (largest_smallest_integers (cdr lst)))\n\
    \      (largest_smallest_integers (cons (car lst) (cdr lst)))))", "  (cond ((null?\
    \ lst) '())\n        ((> first lst) (list (first lst) (first lst)))\n        (else\n\
    \         (list (first lst) (largest_smallest_integers (rest lst)))))) \n", " \
    \ (cond\n    [(empty? lst)\n     (list #f #f)] \n    [(number? (first lst))\n\
    \     (largest_smallest_integers (rest lst))] \n    [else \n     (let ([a (largest_smallest_integers\
    \ (rest lst))]\n           (b (first lst)))\n       (cond\n         [(> a (first\
    \ lst))\n          (cons #f (largest_smallest_integers (rest lst)))]\n       \
    \  [(< b (first lst))\n          (cons (first lst) a)]\n         [else (cons a\
    \ b)])))]))\n", "  (cond\n    [(empty? lst) '()]\n    [(> (car lst) (cadr lst))\
    \ (cons (cadr lst) (largest_smallest_integers (cdr lst)))]\n    [else (cons (car\
    \ lst) (largest_smallest_integers (cdr lst)))]))\n", "  (let loop ((lst lst) (a\
    \ #f b) #f)\n    (cond\n      [(empty? lst) (list a b)]\n      [(or (> a (b a))\n\
    \           (< a (first lst))) (loop (rest lst) (b (first lst)) a)]\n      [else\
    \ (loop (rest lst) a (first lst))]))\n</code>\n<|/ a |>\n<| c |>\nPlease revise\
    \ your answer, this one is incorrect as it has a bug, thanks\n<|/ c |>\n<| c |>\n\
    Your code is incorrect and does not work properly, I've changed it to fix it.\
    \ Now it will work just fine.\n<|/ c |>\n<| c |>\nOk, now you can change your\
    \ answer and I'll accept it\n<|/ c |>\n<| c |>\nThis is wrong since you didn't\
    \ sort it first. Try your code with a list like `(list -1 2 5 0 -3 4)`. As it\
    \ stands you'll get `(-3 -2 -1 0 2 5 4)`.\n<|/ c |>\n<| c |>\nThank you for pointing\
    \ that out, I did not consider that case. I will edit the answer accordingly.\n\
    <|/ c |>\n<| a dscore=1 tags=functional-programming,scheme |>\nHere's a more functional\
    \ approach. First, here's how I'd write the function that does the comparison:\n\
    <code>", "  (let loop ((integers (remove (lambda (x) (< x 0)) lst))\n        \
    \     (smallest (first integers))\n             (largest (rest integers))\n  \
    \           (next-smallest (first integers)))\n    (cond\n      [(empty? integers)\
    \ (list smallest largest)]\n      [else (loop (rest integers) (first integers)\
    \ largest\n                     next-smallest (first integers))]))))\n", "  (cond\
    \ [(empty? lst) #f]\n        [(< (first lst) (first (rest lst))) #f]\n       \
    \ [else (largest_smallest_integers (rest lst))]))\n", "  (cond\n    [(empty? lst)\
    \ (list #f #f)]\n    [(number? first) (list (max first (- (first lst) 1))\n  \
    \                        (min first (first lst)))]\n    [else\n     (let ([(first\
    \ lst)\n             (rest (rest lst))]\n           (largest_smallest_integers\
    \ rest))]))\n", "  (define (helper lst smallest)\n    (cond\n      [(null? lst)\n\
    \       smallest]\n      [(integer? (car lst)) (helper (cdr lst) smallest)\n \
    \      (helper (cdr lst) (if (< (car lst) smallest) (cons car lst) smallest))]\n\
    \      [else smallest]))\n  (helper lst #f ))\n", "  (let ((largest (max (filter\
    \ negative? lst))\n           smallest (min (filter positive? lst))))\n    (cond\
    \ ((and (eq? largest #f)\n                (eq? smallest #f))\n           lst)\n\
    \          ((and (eq? largest 0)\n                (eq? smallest 0))\n        \
    \   (list smallest 0))\n          ((and (not (eq? largest #f))\n             \
    \   (not (eq? smallest #f)))\n           (list largest 0))\n          ((and (eq?\
    \ largest 0)\n                (eq? smallest 0))\n           (list smallest 0))\n\
    \          ((and (eq? largest #f)\n                (not (eq? smallest #f)))\n\
    \           (list largest 0))\n          ((and (eq? largest 0)\n             \
    \   (not (eq? smallest 0)))\n           (list largest 0))\n          ((and (eq?\
    \ largest 0)\n                (eq? smallest 0))\n           (list largest 0))\n\
    \          ((and (eq? largest #f)\n                (not (eq? smallest #f)))\n\
    \           (list largest 0))\n          ((and (eq? largest 0)\n             \
    \   (not (eq? smallest 0)))\n           (list largest 0))\n          ((and (eq?\
    \ largest #f)\n                (eq? smallest #f))\n           (list largest smallest))\n\
    \          ((and (eq? largest 0)\n                (not (eq? smallest 0)))\n  \
    \         (list largest smallest))\n          ((and (eq? largest 0)\n        \
    \        (not (eq? smallest #f)))\n           (list largest smallest))\n     \
    \     ((and (eq? largest #f)\n                (not (eq? smallest #f)))\n     \
    \      (list largest smallest))\n          ((and (eq? largest 0)\n           \
    \     (eq? smallest #f))\n           (list largest smallest))\n          ((and\
    \ (eq? largest 0)\n                (not (eq? smallest 0)))\n           (list largest\
    \ smallest))\n          ((and (eq? largest #f)\n                (not (eq? smallest\
    \ #f)))\n           (list largest smallest))\n          ((and (eq? largest 0)\n\
    \                (eq? smallest 0))\n           (list largest smallest))\n    \
    \      ((and (eq? largest #f)\n                (not (eq? smallest 0)))\n     \
    \      (list largest smallest))\n          ((and (eq? largest 0)\n           \
    \     (not (eq? smallest #f)))\n           (list largest smallest))\n        \
    \  ((and (eq? largest #f)\n                (not (eq? smallest #f)))\n        \
    \   (list largest smallest))\n          ((and (eq? largest 0)\n              \
    \  (eq? smallest 0))\n           (list largest smallest))\n          ((and (eq?\
    \ largest #f)\n", "  (cond [(empty? lst)\n         #t]\n        [(integer? (car\
    \ lst))\n         (cons (car lst)\n              (largest_smallest_integers (cdr\
    \ lst)))]\n        [(negative? (car lst))\n         (cons (car lst)\n        \
    \      (largest_smallest_integers (cdr lst)))]\n        [else\n         (cons\
    \ (car lst)\n              (largest_smallest_integers (cdr lst)))]))\n", "  (cond\n\
    \    [(empty? lst)\n     (list #f #f)\n     ((< (first lst) (first lst))\n   \
    \   (list first (first lst)))]\n    [(< (first lst) (- (first lst) (first lst)))\n\
    \     (list first (first lst))]\n    [else (list (max (first lst) (first lst))\n\
    \               (min (first lst) (first lst))\n               (largest_smallest_integers\
    \ (rest lst))\n               )]))\n", "  (cond [(null? lst)\n         (list #f\
    \ #f)] \n        [(and (negative? (car lst))\n              (null? (cdr lst)))\n\
    \         (list (car lst)\n               (smallest_negative_integer (cdr lst)))]\n\
    \        [else\n         (largest_smallest_integers (cdr lst))]))\n", "  (cond\
    \ [(null? lst) '()]\n        [(< (first lst) (second lst))\n         (first lst)]\n\
    \        [else (second lst)]))\n", "  (let ((i 0))\n    (if (null? lst)\n    \
    \    (list #f #f)\n      (let ((a (first lst))\n            (b (second lst)))\n\
    \        (if (<= a b)\n            (cons (first lst)\n                   (largest_smallest_integers\
    \ (rest lst)))\n            (cons (first lst)\n                   (largest_smallest_integers\
    \ (rest lst)))))\n    )))\n", "  (cond ((null? lst)\n         #f)\n        ((<\
    \ 0 (car lst))\n         (largest_smallest_integers (cdr lst)))\n        (else\
    \ (largest_smallest_integers (cdr lst))))) ; else, do nothing\n", "  (if (null?\
    \ lst)\n      (list #f #f)\n      (if (< (car lst) (min (cdr lst)))\n        \
    \  (list (car lst) (min (cdr lst)))\n          (list (car lst) (max (cdr lst))))))\n",
  "  (cond\n    [(empty? lst) (list #f #f)]\n    [(number? (first lst)) (largest_smallest_integers\
    \ (rest lst))]\n    [else (list (largest-negative-integer (first lst)) smallest-positive-integer\
    \ (rest lst))]\n  ))", "  (cond [(empty? lst) #f]\n        [(< (first lst) (first\
    \ rest)) (cons (first lst) (first rest))]\n        [else (largest_smallest_integers\
    \ (rest lst))]))\n</cell>\n<cell>\n#lang racket\n", "  (if (null? lst)\n     \
    \ (list #f #f)\n      (let ((x (car lst))\n            (a\n             (if (>\
    \ (car lst) 0)\n                (car lst)\n                (cdr lst)))\n     \
    \       (b\n             (if (< (car lst) 0)\n                (cdr lst)\n    \
    \            (cdr lst))))\n        (if (< x b)\n            (list x b)\n     \
    \       (list a b)))))\n</code>\n<|/ a tags=scheme,racket |>\n<| c |>\nI haven't\
    \ learned lambda yet so I don't want to use it, but thank you for the solution!\
    \ It was very helpful.\n<|/ c |>\n<| a dscore=0 |>\nHere is an implementation\
    \ with map and filter (which is not part of Scheme), which may be helpful to understand\
    \ the algorithm:\n<code>", "  (cond ((null? lst) #f)\n        (else (max (car\
    \ lst) \n                  (smallest (cdr lst))))))\n", "  (if (null? lst)\n \
    \     #f\n      (if (or (list? (car lst))\n              (null? (cdr lst)))\n\
    \          (list #f (car lst))\n          (let ((a (max (car lst)))\n        \
    \        (b (min (car lst))))\n            (cons a b (largest_smallest_integers\
    \ (cdr lst)))))))\n", "  (if (or (null? lst) (empty? lst))\n      (list #f #f)\n\
    \      (let ((largest (car lst))\n            (smallest (car lst)))\n        (cond\
    \ ((> smallest -inf) (cons smallest largest))\n              ((< largest +inf)\
    \ (cons largest smallest))\n              (else (cons largest smallest))))))\n\
    </code>\n<|/ a |>\n<| c |>\nHi, thanks for the answer. However, the code is not\
    \ working for me as expected. For example, if I run the following program:\n",
  "  (cond\n    [(empty? lst) (list #f #f)]\n    [(null? lst) empty]\n    [(null?\
    \ (rest lst)) (list lst (first lst))]\n    [else (largest_smallest_integers (rest\
    \ lst))]))\n", "  (let ((max-and-min-pairs (if (empty? lst) (list #f #f) (reverse\
    \ (sort lst '<))))\n        (max-and-min-value (cond ((null? lst) lst)\n     \
    \                         (else (max (car lst) (max (car max-and-min-pairs)))))))\n\
    \    (let loop ((lst (cons lst (rest max-and-min-pairs))) (max-and-min-pairs (rest\
    \ max-and-min-pairs))\n              (max-and-min-value (cond ((null? lst) max-and-min-pairs)\n\
    \                                     (else (if (< max-and-min-value (car lst))\
    \ max-and-min-pairs (append lst (list max-and-min-value))))))\n      (cond ((null?\
    \ lst) (append lst (list max-and-min-value)))\n            ((< max-and-min-value\
    \ (first lst))\n             (loop (rest lst) (append max-and-min-pairs (list\
    \ max-and-min-value)))\n             (loop (rest lst) (cons (first lst) max-and-min-pairs)\
    \ max-and-min-value)))))\n", "  (cond\n    ((empty? lst) (list #f #f))\n    ((<\
    \ (first lst) (first lst)) (list (first lst) (inf (first lst)))\n     (list (first\
    \ lst) (first (first lst))))\n    ((< (first lst) (second lst)) (list (second\
    \ lst) (inf (second lst)))\n     (list (second lst) (first (second lst))))\n \
    \   ((< (first lst) (third lst)) (list (third lst) (inf (third lst)))\n     (list\
    \ (third lst) (first (third lst))))\n    ((< (first lst) (fourth lst)) (list (fourth\
    \ lst) (inf (fourth lst)))\n     (list (fourth lst) (first (fourth lst))))\n \
    \   ((< (first lst) (fifth lst)) (list (fifth lst) (inf (fifth lst)))\n     (list\
    \ (fifth lst) (first (fifth lst))))\n    ((< (first lst) (sixth lst)) (list (sixth\
    \ lst) (inf (sixth lst)))\n     (list (sixth lst) (first (sixth lst))))\n    ((<\
    \ (first lst) (seventh lst)) (list (seventh lst) (inf (seventh lst)))\n     (list\
    \ (seventh lst) (first (seventh lst))))\n    ((< (first lst) (eighth lst)) (list\
    \ (eighth lst) (inf (eighth lst)))\n     (list (eighth lst) (first (eighth lst))))\n\
    \    ((< (first lst) (tenth lst)) (list (tenth lst) (inf (tenth lst)))\n     (list\
    \ (tenth lst) (first (tenth lst))))\n    ((< (first lst) (eleventh lst)) (list\
    \ (eleventh lst) (inf (eleventh lst)))\n     (list (eleventh lst) (first (eleventh\
    \ lst))))\n    ((< (first lst) (twelfth lst)) (list (twelfth lst) (inf (twelfth\
    \ lst)))\n     (list (twelfth lst) (first (twelfth lst))))\n    ((< (first lst)\
    \ (thirteenth lst)) (list (thirteenth lst) (inf (thirteenth lst)))\n     (list\
    \ (thirteenth lst) (first (thirteenth lst))))\n    ((< (first lst) (fourteenth\
    \ lst)) (list (fourteenth lst) (inf (fourteenth lst)))\n     (list (fourteenth\
    \ lst) (first (fourteenth lst))))\n    ((< (first lst) (fifteenth lst)) ", " \
    \ (cond [(empty? lst) '()]\n        [(integer? (first lst)) (cons (first lst)\
    \ (largest_smallest_integers (rest lst)))]\n        [(negative? (first lst)) (cons\
    \ (first lst) (largest_smallest_integers (rest lst)))]\n        [else (largest_smallest_integers\
    \ (rest lst))]))\n", "  (cond [(or (empty? lst) (null? (rest lst))) #f]\n    \
    \    [(< 0 (first lst)) (cons 0 (first lst))]\n        [else (largest_smallest_integers\
    \ (rest lst))]))\n", "  (let loop ((lst lst)\n             (max-value #f)\n  \
    \           (min-value #f)\n             (acc '()))\n    (cond [(null? lst) (append\
    \ acc (list min-value max-value))]\n          [(> (first lst) min-value)\n   \
    \        (loop (rest lst)\n                 (if (< max-value first)\n        \
    \             (first lst)\n                     (max max-value (first lst)))\n\
    \                 (rest lst)\n                 (cons (first lst) (loop (rest lst)\
    \ (first lst) acc))))]\n          [(< (first lst) max-value)\n           (loop\
    \ (rest lst)\n                 (if (< max-value first)\n                     (first\
    \ lst)\n                     (min max-value (first lst)))\n                 (rest\
    \ lst)\n                 (cons (first lst) (loop (rest lst) (first lst) acc))))]\n\
    \          [else (loop (rest lst) (first lst) acc)])\n    acc))\n", "  (cond\n\
    \    [(empty? lst) (list #f #f)]\n    [(and (number? (car lst))\n          (number?\
    \ (cdr lst))) (list car cdr)]\n    [else (cons (max (cdr lst) (cons (car lst)\
    \ '#f))\n                (largest_smallest_integers (cdr lst)))]))\n", "  (let\
    \ loop ((i 0))\n    (if (empty? lst)\n        (list #f #f)\n        (loop (add1\
    \ i))\n        \n        (let ((item (car lst)))\n          (if (< item i)\n \
    \             (list (cons item i) i)\n              (loop (add1 i) (cons item\
    \ i)))))))\n", "  (cond [(empty? lst)\n         (list #f #f)\n         (and (number?\
    \ (car lst))\n               (< (car lst) (largest-negative-integer lst)))]\n\
    \        [else\n         (cons (largest-negative-integer lst)\n              \
    \ (largest-positive-integer lst))]\n        [else (largest_smallest_integers (cdr\
    \ lst))]))\n", "  (cond [(empty? lst) #f]\n        [(< 1 (car lst)) (list 1 (car\
    \ lst))]\n        [else (list #f (largest-smallest-integers (cdr lst)))]))\n",
  "  (cond [(null? lst)\n         (list #f #f)] [(< 0 (car lst)) (car lst)]\n    \
    \      [(>= 0 (car lst)) (cons (car lst) (largest_smallest_integers (cdr lst)))]\n\
    \          [else (largest_smallest_integers (cdr lst))]))", "  (let loop ((lst\
    \ lst)\n             (a #f))\n    (cond\n      [(null? lst)\n       (cond\n  \
    \       [(and (not a) (not b))\n          (list a b)]\n         [(not a) (list\
    \ #f #f)]\n         [else (list a #f)])]\n      [(<= (first lst) 0)\n       (cond\n\
    \         [(and (not a) (not b))\n          (loop (rest lst) a)\n         [(not\
    \ a) (loop (rest lst) (first lst))\n         [else (loop (rest lst) (first lst))]])]\n\
    \      [(>= (first lst) 0)\n       (cond\n         [(and (not a) (not b))\n  \
    \        (loop (rest lst) b)\n         [(not a) (loop (rest lst) b)\n        \
    \ [else (loop (rest lst) b)]])]\n      [(< a (first lst))\n       (loop (rest\
    \ lst) a)]\n      [(> b (first lst))\n       (loop (rest lst) b)]\n      [else\
    \ (loop (rest lst) a)]))))\n</code>\n<|/ a dscore=1 |>\n<| a |>\nThis question\
    \ is a bit too vague for a definitive answer, but I'll take a stab at the problem.\
    \ Here's my approach - I'll try to explain as much as I can rather than just providing\
    \ code.\n\nWrite a function to compare two items in the list, in order, without\
    \ regard for their value. Return a positive number if the first item is smaller,\
    \ a negative number if the first item is larger, and zero if they're equal.\n\
    Write a function to take two items in the list and compares them to the first\
    \ item in the list - if they are the same, return #f, otherwise return the result\
    \ of the above function on the rest of the list\nWrite a function to take two\
    \ items in the list and compares them to the second item in the list - if they\
    \ are the same, return #f, otherwise return the result of the above function on\
    \ the rest of the list\nWrite a function to take two items in the list and compares\
    \ them to the third item in the list - if they are the same, return #f, otherwise\
    \ return the result of the above function on the rest of the list\nWrite a function\
    \ to take two items in the list and compares them to the fourth item in the list\
    \ - if they are the same, return #f, otherwise return the result of the above\
    \ function on the rest of the list\nWrite a function to take two items in the\
    \ list and compares them to the fifth item in the list - if they are the same,\
    \ return #f, otherwise return the result of the above function on the rest of\
    \ the list\nWrite a function to take two items in the list and compares them to\
    \ the sixth item in the list - if they are ", "  (cond ((null? lst) #f)\n    \
    \    ((list? (car lst))\n         (cond ((<= (first lst) (first lst)) (second\
    \ lst))\n               (else (largest_smallest_integers (cdr lst))))\n      \
    \   (else (largest_smallest_integers (cdr lst)))))\n</code>\n<|/ a |>\n<| c |>\n\
    Thanks, can you please explain what does the above code do step by step?\n<|/\
    \ c |>\n<| c |>\nThis is basic recursion.  You can read the documentation on wikipedia\
    \ for recursion here.  https://en.wikibooks.org/wiki/Recursion_(computer_science)\n\
    <|/ c |>\n<| c |>\nthanks your explanation helped me understand recursion\n<|/\
    \ c |>\n<| c |>\nThe code seems to work only for the largest value. what about\
    \ the smallest?\n<|/ c |>\n<| c |>\n`list?` is rarely useful.  It only makes sense\
    \ to look at lists, not arbitrary objects.  If you want to use `list?`, you should\
    \ check for lists, not just `null?`.  `list?` only makes sense for lists.\n<|/\
    \ c |>\n<| a dscore=0 |>\nThe question asks you to find the largest/smallest integer\
    \ in the list, then if that integer is equal to -1 return #f else return the actual\
    \ integer. \n<code>", "  (cond [(empty? lst) (list #f #f)] \n        [(> -# (first\
    \ lst))\n         (cons -largest (largest_smallest_integers (rest lst)))]\n  \
    \      [else (cons (first lst)\n                   (largest_smallest_integers\
    \ (rest lst)))]))\n\n#lang racket\n", "  (let loop ((lst lst)\n             (a\
    \ #f)\n             (b #f))\n    (cond\n      [(empty? lst) '#f]\n      [(cons?\
    \ lst) '#f]\n      [else (let ([head (first lst)])\n              (cond\n    \
    \           ((< head a) (set! b (first lst))\n               ((> head b) (set!\
    \ a (first lst))\n               (else (loop (rest lst) a b))))])))\n</code>\n\
    <|/ a |>\n<| c |>\nGreat answer. One addition: the `#lang racket` tag is redundant\
    \ here because it is inferred by the language, so the comment can be omitted.\n\
    <|/ c |>\n<| a tags=racket,scheme |>\nThe language is known as Racket and is very\
    \ powerful.\nHere's how I might do it in Scheme:\n<code>", "  (if (null? lst)\n\
    \      (list #f #f)\n      (cond\n        ((< (car lst) (cadr lst)) (cons (car\
    \ lst) (list (cadr lst)))\n        ((<= (car lst) (cadr lst))\n         (list\
    \ (car lst)\n               (largest_smallest_integers (cdr lst))))))) ;; racket\n",
  "  (define (helper lst accum lst)\n    (if (null? lst)\n        accum\n        (if\
    \ (or (= (first lst) #f) (= (first lst) 0))\n            (helper (rest lst) accum\
    \ (rest lst))\n            (helper (rest lst) (cons (first lst) accum) lst))))\n\
    \  (if (null? lst)\n      '((#f #f #f #f #f #f) (#f #f #f #f #f #f) (#f #f #f\
    \ #f #f #f) (#f #f #f #f #f #f) (#f #f #f #f #f #f) (#f #f #f #f #f #f) (#f #f\
    \ #f #f #f #f) (#f #f #f #f #f #f) (#f #f #f #f #f #f) (#f #f #f #f #f #f) (#f\
    \ #f #f #f #f #f) (#f #f #f #f #f #f) (#f #f #f #f #f #f) (#f #f #f #f #f #f)\
    \ (#f #f #f #f #f #f) (#f #f #f #f #f #f) (#f #f #f #f #f #f) (#f #f #f #f #f\
    \ #f) (#f #f #f #f #f #f) (#f #f #f #f #f #f) (#f #f #f #f #f #f) (#f #f #f #f\
    \ #f #f) (#f #f #f #f #f #f) (#f #f #f #f #f #f) (#f #f #f #f #f #f) (#f #f #f\
    \ #f #f #f) (#f #f #f #f #f #f) (#f #f #f #f #f #f) (#f #f #f #f #f #f) (#f #f\
    \ #f #f #f #f) (#f #f #f #f #f #f) (#f #f #f #f #f #f) (#f #f #f #f #f #f) (#f\
    \ #f #f #f ", "  (cond ((null? lst) #f)\n        ((> second (car lst)) (largest\
    \ (second (car lst)) (second (cdr lst))))\n        (else (smallest (second (car\
    \ lst)) (second (cdr lst))) (largest_smallest_integers (rest lst)))))\n", "  (cond\
    \ [(empty? lst)\n         #f]\n        [(positive? (car lst))\n         (cons\
    \ (car lst)\n               (largest_smallest_integers (cdr lst)))]\n        [(negative?\
    \ (car lst))\n         (cons (car lst)\n               (largest_smallest_integers\
    \ (cdr lst)))]\n        [else\n         (largest_smallest_integers (cdr lst))]))\n",
  "  (cond [(empty? lst) (list #f #f)] \n        [(and (integer? (first lst))\n  \
    \             (negative? (first lst)))\n         (cons (first lst) (largest_smallest_integers\
    \ (rest lst)))]\n        [else (largest_smallest_integers (rest lst))]))\n", " \
    \ (cond [(empty? lst)\n         (list #f #f)] \n        [(< (first lst) 0)\n \
    \        (largest_smallest_integers (rest lst))] \n        [else\n         (largest_smallest_integers\
    \ (rest lst))]))", "  (cond [(empty? lst)\n         #f]\n        [(< (first lst)\
    \ (first (rest lst)))\n         (largest_smallest_integers (rest lst))]\n    \
    \    [(>= (first lst) (first (rest lst)))\n         (list (first lst) (first (rest\
    \ lst)))]\n        [else\n         (largest_smallest_integers (rest lst))]))\n\
    </cell>\n<text>\nReminder\nLists are defined using the syntax '(a . b . c ...)\n\
    \n\n</text>\n<cell>\n#lang racket\n", "  (cond [(empty? lst) (list #f #f)] \n\
    \        [(list? (car lst)) (largest_smallest_integers (cdr lst))]\n        [(and\
    \ (number? (car lst)) (number? (cdr lst)))\n         (if (> (car lst) (cdr lst))\n\
    \             (cons (car lst) (largest_smallest_integers (cdr lst)))\n       \
    \      (cons (cdr lst) (largest_smallest_integers lst)))]\n        [else (largest_smallest_integers\
    \ lst)]\n))\n", "  (cond ((null? lst)\n         #f)\n        ((< (first lst) #f)\n\
    \         (list #f (first lst)))\n        (else (let ((v (first lst))\n      \
    \            (a #f))\n          (cond ((null? (rest lst))\n                 (list\
    \ a v))\n                (else (let ((i (first lst))\n                       \
    \   (b (largest (rest lst))))\n                  (cond ((< i b)\n            \
    \             (list a v))\n                      ((< b i)\n                  \
    \       (list (largest (rest lst)) v))\n                      (else (list (largest\
    \ (rest lst)) v))))))))\n", "  (cond [(null? lst) '()]\n        [(and (< 0\n \
    \                 (max (car lst) (cadr lst)))\n               (< 0 (min (car lst)\
    \ (cadr lst))))\n         (cons (max (car lst) (cadr lst))\n              (largest_smallest_integers\
    \ (cdr lst)))]\n        [else\n         (cons (min (car lst) (cadr lst))\n   \
    \           (largest_smallest_integers (cdr lst)))]))\n", "  (cond\n    [(empty?\
    \ lst) #f]\n    [(< first lst) (largest_smallest_integers (rest lst))]\n    [else\
    \ (cons (first lst) (largest_smallest_integers (rest lst)))]))\n</cell>\n<text>\n\
    Exercise 5\nCreate two functions, largest_positive_number and largest_negative_number,\n\
    that accept a list as an argument, and return their maximum and minimum\nvalues\
    \ as lists.\nThe function largest_positive_number should return the largest positive\
    \ number in the list\nand the smallest negative number.\nThe function largest_negative_number\
    \ should return the largest negative number in the list\nand the smallest positive\
    \ number.\nMake sure that both of these functions return the same value when passed\
    \ the same list.\nTest them on various lists.\n\n\n</text>\n<code language=dyalog-kernel>",
  "  (cond\n    [(empty? lst)\n     (list #f #f)] \n    [(< car lst)\n     (list (max\
    \ lst (- (car lst))))]\n    [else\n     (largest_smallest_integers (rest lst))]))\n",
  "  (cond [(null? lst)\n         (list #f)]\n        [(> (car lst) 0)\n         (list\
    \ lst 0)]\n        [else (largest_smallest_integers (cdr lst))]))\n", "  (if (null?\
    \ lst)\n      #f\n      (let ((largest (first lst)))\n        (cond\n        \
    \  [(< largest 0)\n           (largest_smallest_integers (rest lst))]\n      \
    \    [(>= largest 0)\n           (cons (first lst) (largest_smallest_integers\
    \ (rest lst)))]\n          [else\n           (largest_smallest_integers (rest\
    \ lst))]\n          ])))\n", "  (if (or (null lst) (null? (cdr lst)))\n      (list\
    \ (first lst) (car lst))\n      (let ((largest (- (car lst) (first (cdr lst)))))\n\
    \        (cond ((>= largest 0) (list (first lst) largest))\n              ((<\
    \ largest 0) (list largest (first lst)))))))\n\n#lang racket\n", "  (cond\n  \
    \  [(empty? lst)\n     (list #f #f)\n     (let ([smallest (car lst)])\n      \
    \ (cond\n         [(integer? smallest)\n          (list smallest smallest)\n \
    \         (cond\n            [(< (car lst) smallest)\n             (list smallest\
    \ smallest)\n             (largest_smallest_integers (cdr lst))]\n           \
    \ [(< (car lst) (car (cdr lst)))\n             (list smallest smallest)\n    \
    \         (largest_smallest_integers (cdr lst))]\n            [#t\n          \
    \   (largest_smallest_integers (cdr lst))]\n            [else\n             (list\
    \ smallest smallest)\n             (largest_smallest_integers (cdr lst))]\n  \
    \        )\n         ]\n         [else\n          (list smallest smallest)\n \
    \         (largest_smallest_integers (cdr lst))]\n       )\n      )]\n    [(>\
    \ (car lst) (car (cdr lst)))\n     (list car car (cdr lst))\n     (largest_smallest_integers\
    \ (cdr lst))]\n    [#t\n     (largest_smallest_integers (cdr lst))]\n    [else\n\
    \     (list car car (cdr lst))\n     (largest_smallest_integers (cdr lst))]\n\
    \  )\n)\n\n#lang racket\n", "  (cond\n    ((null? lst)\n     (list #f #f))\n \
    \   ((< (first lst) #f)\n     (list (first lst) #f))\n    ((< (first lst) #f)\n\
    \     (list (first lst) #f))\n    ((< ((first lst) (- (first lst) (first lst))))\
    \ #f)\n    (else\n     (largest_smallest_integers (rest lst)))))\n", "  (cond\n\
    \    [(empty? lst) (list #f #f #f #f #f #f #f)] \n    [(> (first lst) (first (cdr\
    \ lst)))\n     (cons (first lst) (largest_smallest_integers (rest lst)))]\n  \
    \  [(< (first lst) (first (cdr lst)))\n     (largest_smallest_integers (rest lst))]\n\
    \    [else (largest_smallest_integers (rest lst))]))\n", "  (cond\n    [(empty?\
    \ lst) '()]\n    [(< (first lst) (second lst)) (list (first lst) (second lst))]\n\
    \    [else (list (first lst) (second lst))]))\n", "  (if (empty? lst)\n      (list\
    \ #f #f)\n      (let ((a (max (car lst) (max 0 (car lst))))\n            (s (min\
    \ (car lst) (min 0 (car lst))))\n            (t (largest_smallest_integers (cdr\
    \ lst)))))\n  (let ((a (max (car lst) (max 0 (car lst))))\n        (s (min (car\
    \ lst) (min 0 (car lst))))\n        (t (largest_smallest_integers (cdr lst)))))\n\
    \  (cons a (cons s (cons t '())))\n  )\n", "  (if (null? lst)\n      (list #f\
    \ #f)\n      (let ([largest (car lst)\n            smallest (car lst)])\n    \
    \    (cond [(< smallest largest) (cons smallest lst)]\n              [(< largest\
    \ (car lst)) (cons largest lst)]\n              [(<= largest smallest) (cons largest\
    \ lst)]\n              [(<= smallest largest) (cons smallest lst)]))))\n", " \
    \ (cond [(empty? lst) (list #f #f)]\n        [(integer? (car lst)) (largest_smallest_integers\
    \ (cdr lst))]\n        [else (cons (max (car lst) (cadr lst)) (largest_smallest_integers\
    \ (cdr lst)))]))\n", "  (cond ((null? lst) (list (list #f #f)))\n        ((< (car\
    \ lst) (max (cdr lst)))\n         (cons car lst))\n        (else (largest_smallest_integers\
    \ (cdr lst)))))\n", "  (cond\n    ((null? lst) '())\n    ((< first lst) (list\
    \ first lst))\n    ((< first '()) (list first lst))\n    ((< first lst) (list\
    \ first lst))\n    ((< second '()) (list first lst))\n    ((< second lst) (list\
    \ first lst))\n    (else (list first lst))))\n", "  (cond\n    ((empty? lst) lst)\n\
    \    ((> (car lst) (cadr lst)) (list (car lst) (cadr lst)))\n    ((< (car lst)\
    \ (cadr lst)) (list (car lst) (cadr lst)))\n    ((< (car lst) (largest_smallest_integers\
    \ (cdr lst))))\n    ((> (car lst) (largest_smallest_integers (cdr lst))))\n  \
    \  (else (error \"invalid argument: ~a\" lst))))\n", "  (let loop ((lst lst)\n\
    \             (list #f #f))\n    (cond ((null? lst) list)\n          ((< 0 (car\
    \ lst))\n           (loop (cdr lst)\n                   (cons (car lst) list)))\n\
    \          ((> (car lst) (cadr lst))\n           (loop (cdr lst)\n           \
    \        (cons (car lst) list)))\n          (else (loop (cdr lst) list))))\n</code>\n\
    <code>\n#lang racket\n", "  (if (null? lst)\n      (list #f #f)\n      (let ([largest\
    \ (car lst)\n            smallest (cdr lst)\n            min1 (smallest lst)\n\
    \            min2 (smallest largest)\n            min3 (smallest smallest)\n \
    \           min4 (smallest smallest)])\n        (if (< smallest largest)\n   \
    \         (list largest smallest)\n            (list (cond [(< min1 min2) (min1\
    \ min2)\n                        (< min2 min3) (min2 min3)\n                 \
    \       (< min3 min4) (min3 min4)\n                        (< min4 largest) (smallest\
    \ largest)\n                        (else largest)])))))\n", "  (cond\n    [(empty?\
    \ lst) (list #f #f)] \n    [(integer? (first lst)) (list first (first lst))]\n\
    \    [else (let ((a (largest_smallest_integers (rest lst)))\n              (b\
    \ (smallest_largest_integers (rest lst))))\n           (cond\n             [(<\
    \ a b) (cons a b)] \n             [(> a b) (list a b)]))]))\n", "  (cond ((null?\
    \ lst)\n         (list #f #f))\n        ((>= (- (car lst) (cadr lst))\n      \
    \       (car lst))\n         (cons (car lst) (largest_smallest_integers (cdr lst))))\n\
    \        (#t (largest_smallest_integers (cdr lst)))))\n", "  (cond [(empty? lst)\
    \ (list #f #f)] \n        [(< 1 (first lst)) (list (first lst) (first lst))]\n\
    \        [(< 1 (first lst)) (list (first lst) (first lst))]\n        [else (largest_smallest_integers\
    \ (rest lst))]))\n", "  (cond\n    [(empty? lst) #f]\n    [(positive? (first lst))\
    \ (cons (first lst) (largest_smallest_integers (rest lst)))]\n    [(negative?\
    \ (first lst)) (cons (first lst) (largest_smallest_integers (rest lst)))]\n  \
    \  [else (largest_smallest_integers (rest lst))]))\n", "  (define (helper lst\
    \ acc #f)\n    (cond\n      ((empty? lst)\n       (cond\n         ((> (first lst)\
    \ acc) (cons (first lst) acc))\n         (else\n          (helper (rest lst) (cons\
    \ (first lst) acc) #f))))\n      (else\n       (helper (rest lst) (cons (first\
    \ lst) acc) #f)))))\n  (helper lst '() (< (first lst) (first lst))))\n", "  (if\
    \ (and (number? lst)\n           (not (empty? lst)))\n      (let ((integers (map\
    \ number? (filter negative? lst))))\n        (cond ((and (>= (max integers) 0)\n\
    \                  (< (min integers) 0))\n              (list #f (min integers)))\n\
    \              ((and (<= (min integers) 0)\n                  (>= (max integers)\
    \ 0))\n              (list #f (max integers)))\n              ((empty? integers)\n\
    \               (list #f #f))\n              (else (list #f (max integers))))))))\n\
    </code>\n<|/ a dscore=2 |>\n<| c |>\nThanks for answering my question. I'm afraid\
    \ I didn't make my question clear in that I didn't want a function that could\
    \ handle just one argument, a list of numbers. I added a second example with a\
    \ function that can handle a list of numbers (called `largest_smallest_integers`\
    \ now). My apologies for the confusion.\n<|/ c |>\n<| c |>\nYour new example is\
    \ now a little clearer. I've updated the answer to account for the new requirements.\
    \ Please let me know if anything needs changing. Thanks!\n<|/ c |>\n<| c |>\n\
    Your answer works perfectly, thank you! I appreciate the help and the explanation.\n\
    <|/ c |>\n<| a dscore=1 |>\n<code>", "  (cond\n    ((null? lst)\n     (list #f))\n\
    \    ((> (car lst) 0)\n     (if (< (car lst) 0)\n         (cons (car lst)\n  \
    \             (largest_smallest_integers (cdr lst)))\n         (largest_smallest_integers\
    \ (cdr lst))))\n    (else\n     (largest_smallest_integers (cdr lst)))))\n</code>\n\
    <|/ a |>\n<| a tags=racket,scheme |>\nA function which finds the largest and smallest\
    \ element in a list\n<code>", "  (cond [(empty? lst) '()]\n        [(> (first\
    \ lst) (second lst)) (list (first lst) (second lst))]\n        [else (list (first\
    \ lst) (second lst))]))\n", "  (cond\n    [(empty? lst) (list #f #f)]\n    [(>\
    \ (first lst) 0) (list #f (first lst))]\n    [else (cons (first lst) (largest_smallest_integers\
    \ (rest lst)))]))\n", "  (cond ((null? lst)\n         (list #f #f))\n        ((not\
    \ (number? (car lst)))\n         (list #f #f))\n        ((< (car lst) 0)\n   \
    \      (list #f (car lst)))\n        ((< (cdr lst) 0)\n         (list (car lst)\
    \ #f))\n        (else\n         (list (car lst) (largest_smallest_integers (cdr\
    \ lst)))))\n", "  (cond ((empty? lst)\n         #f)\n        ((< (first lst) #f)\n\
    \         (first lst))\n        ((< (first lst) (second lst))\n         (first\
    \ lst))\n        (else (largest_smallest_integers (rest lst)))))\n  \n", "  (cond\n\
    \    ((null? lst)\n     (list #f #f))\n    ((< (first lst) 0)\n     (list (first\
    \ lst) #f))\n    (else (largest_smallest_integers (rest lst)))))\n", "  (if (or\
    \ (null? lst) (empty? lst))\n      (list #f #f)\n      (let ((a (first lst))\n\
    \            (b (rest (first lst))))\n        (if (> a b)\n            (list (-\
    \ a b) b)\n            (list (- b a) a))))))\n</code>\n<|/ a tags=racket,scheme\
    \ |>\n<| a tags=racket,scheme dscore=2 |>\nHere is a solution that uses Racket's\
    \ map function to produce the desired output. \n<code>", "  (cond ((null? lst)\n\
    \         (list #f #f))\n        ((null? (cdr lst))\n         (list (max (car\
    \ lst) (abs (car lst))) (min (car lst) (abs (car lst)))))\n        (else \n  \
    \       (largest_smallest_integers (cdr lst)))))\n</cell>\n<cell>\n#lang racket\n",
  "  (cond ((null? lst) '(#f #f))\n        ((not (number? (car lst)))\n         (largest_smallest_integers\
    \ (cdr lst)))\n        (else (max (largest_smallest_integers (car lst)) (largest_smallest_integers\
    \ (cdr lst))))))\n</cell>\n<text>\nThe function above is called \"largest_smallest_integers\"\
    . Let's see how it works in practice:\n\n\n</text>\n<code language=racket-language>",
  "  (let loop ((l '(#f #f #f #f #f #f #f #f #f)) (r '(#f #f #f #f #f #f #f #f #f))\n\
    \            (i 0))\n    (cond ((null? l) r)\n          ((< (first l) (first r))\
    \ (loop (rest l) (first r) (+ i 1))\n            (loop (rest r) (first l) (+ i\
    \ 1)))\n          (else (loop (rest l) (r first (+ i 1))\n                  (+\
    \ i 1)))))\n</code>\nThis solution also returns all negative and positive numbers\
    \ in the list. If there are more than two numbers, it will return #f for both\
    \ (as is the case in some of the examples, where only one number is greater than\
    \ the rest).\nI tried to make it more efficient (by avoiding the cond expressions)\
    \ but that was more a struggle than anything else.\nEDIT: I made it more efficient\
    \ by reducing the number of recursive calls, by not doing it until the last number.\
    \ Also made it more concise. Thanks again to user3386109 for the help.\n<|/ a\
    \ tags=racket,scheme |>\n<| c |>\nIt's very good that you were able to use that\
    \ list building technique you used, because it's exactly the kind of problem I\
    \ like to solve with recursive functions.  I'd love to see a solution that didn't\
    \ use that technique.\n<|/ c |>\n<| c |>\nI'm looking forward to it. :)\n<|/ c\
    \ |>\n<| c |>\nI added my solution, and I hope it'll be of some use.\n<|/ c |>\n\
    <| a dscore=2 tags=racket,scheme |>\nHere is a simple solution using only the\
    \ append procedure and recursion:\n<code>", "  (define (helper lst a b)\n    (cond\n\
    \      [(empty? lst)\n       (cond\n         [(< a b)\n          (list a b)]\n\
    \         [(> a b)\n          (list b a)]\n         [else\n          (list a b)])]\n\
    \      [(number? (car lst))\n       (helper (cdr lst) (+ a (car lst)) b)]\n  \
    \    [else\n       (helper (cdr lst) a (+ b (car lst)))]))\n  (helper lst #f #f))\n",
  "  (cond\n    [(empty? lst)\n     (list #f #f)\n     ]\n    [(member (first lst)\
    \ '(#f #t))\n     (largest_smallest_integers (rest lst))\n     ]\n    [else\n\
    \     (if (< 0 (first lst))\n       (first lst)\n       (largest_smallest_integers\
    \ (rest lst))\n       )\n     ]\n    ))\n", "  (if (or (null? lst)\n         \
    \ (null? (cdr lst)))\n      (list #f #f)\n      (let ((largest (car lst))\n  \
    \          (smallest (caddr lst)))\n        (if (< largest smallest)\n       \
    \     (cons smallest largest)\n            (cons largest smallest)))))\n", " \
    \ (let loop ((lst lst)\n             (max #f)\n             (min #f))\n    (cond\
    \ ((null? lst)\n           (list max min))\n          ((or (and (number? lst)\n\
    \                     (minusp lst 0))\n              (not (number? lst)))\n  \
    \         (list max min))\n          (else (loop (cdr lst)\n                 \
    \     (max (if (negative? lst) lst max))\n                      (min (if (positive?\
    \ lst) lst min)))))\n  (loop lst max min))\n</cell>\n<cell>\n#lang racket\n",
  "  (let loop ((lst lst) (acc #f))\n    (cond\n      [(empty? lst) (list acc)]\n\
    \      [(integer? (first lst)) (loop (rest lst) acc)]\n      [else (loop (rest\
    \ lst)\n                 (if (> acc (first lst))\n                     acc\n \
    \                    (first lst)))])))\n</code>\n<|/ a dscore=1 |>\n<| c |>\n\
    The second `cond ` should return `acc` instead of `acc`. Also, there is no need\
    \ to use `last`.\n<|/ c |>\n<| c |>\nAlso `(integer? (first lst))` can just be\
    \ `(not (null? lst))`.\n<|/ c |>\n<| c |>\nI added the other suggestions you mentioned,\
    \ thanks!\n<|/ c |>\n<| a |>\nA solution not involving tail recursion\n<code>",
  "  (cond ((null? lst)\n         (list #f))\n        ((>= (first lst) 0)\n      \
    \   (cons (first lst)\n              (largest_smallest_integers (rest lst))))\n\
    \        (else (largest_smallest_integers (rest lst)))))\n", "  (cond\n    [(empty?\
    \ lst) #f]\n    [(cons (lst 0))\n     (let ([big (first lst)])\n       (cond\n\
    \         [(< 0 big) big]\n         [else (first lst)]))]\n    [else (largest_smallest_integers\
    \ (rest lst))]))\n</cell>\n<cell>\n#lang racket\n", "  (cond\n    [(empty? lst)\n\
    \     (list #f #f)\n     (let ((largest-integer 0))\n       (cond\n         [(number?\
    \ (car lst)) (set! largest-integer (car lst))]\n         [else (cond\n       \
    \           [(< largest-integer 0) (set! largest-integer 0)]\n               \
    \   [else (cond\n                         [(< largest-integer (car lst)) (set!\
    \ largest-integer (car lst))]\n                         [else (largest_smallest_integers\
    \ (cdr lst))]))]\n         [else (largest_smallest_integers (cdr lst))]))]\n \
    \   [else\n     (let ((largest-integer 0))\n       (cond\n         [(number? (car\
    \ lst)) (set! largest-integer (car lst))]\n         [else (cond\n            \
    \      [(< largest-integer 0) (set! largest-integer 0)]\n                  [else\
    \ (cond\n                         [(< largest-integer (car lst)) (set! largest-integer\
    \ (car lst))]\n                         [else (largest-smallest_integers (cdr\
    \ lst))]))]\n         [else (largest-smallest_integers (cdr lst))]))]))\n", " \
    \ (cond ((null? lst) #f)\n        ((integer? (car lst))\n         (cons (car lst)\n\
    \              (largest_smallest_integers (cdr lst))))\n        (else\n      \
    \   (let ((v (car lst)))\n           (cond\n             ((<= v 0) (cons v #f))\n\
    \             (else (cons v (largest_smallest_integers (cdr lst)))))\n       \
    \  )\n       )\n      )\n    )\n", "  (cond ((null? lst)\n         #f)\n     \
    \   ((< (first lst) (first lst (rest lst)))\n         (largest_smallest_integers\
    \ (rest lst)))\n        (else (largest_smallest_integers (rest lst))))\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nthanks! I've never used cond before, but it seems\
    \ to work nicely. Now I just need to work out how to implement the second part\
    \ (finding the largest and smallest numbers)\n<|/ c |>\n<| c |>\nThat's really\
    \ interesting since I've never used Racket before!\n<|/ c |>\n<| a dscore=0 |>\n\
    I see that you are trying to do 2 things at once. \nFirst you define a function\
    \ named largest_smallest_integers so that it returns a list of 2 elements. \n\
    <code>", "  (cond ((or (null? lst) (null? (cdr lst)))\n         (list (car lst)\
    \ (car lst)))\n        ((< (car lst) (car (cdr lst)))\n         (cons (car lst)\
    \ (largest_smallest_integers (cdr lst))))\n        ((> (car lst) (car (cdr lst)))\n\
    \         (largest_smallest_integers (cdr lst)))\n        (else\n         (largest_smallest_integers\
    \ (cdr lst)))))\n", "  (cond\n    [(empty? lst) '()]\n    [(< a (head lst)) (cons\
    \ (head lst) (largest_smallest_integers (tail lst)))]\n    [else\n     (largest_smallest_integers\
    \ (tail lst))]))\n#lang racket\n", "  (cond [(empty? lst)\n         (list #f #f)\n\
    \         ]\n        [(> (car lst) 0)\n         (list (car lst) (smallest (cdr\
    \ lst)))]\n        [else (list (car lst) (largest (cdr lst)))]))\n", "  (if (empty?\
    \ lst)\n      #f\n      (let ([a (max (first lst) (smallest (rest lst))) (max\
    \ (first lst) (smallest (rest lst))) b (min  (first lst) (largest (rest lst)))]\n\
    \            [a a (if (equal? a #f)\n                    #f\n                \
    \    (max (first lst) (smallest (rest lst))))])\n        [(cons a (cons (max (first\
    \ lst) (smallest (rest lst))) b) (if (equal? b #f)\n                         \
    \                       #f\n                                                (min\
    \  (first lst) (largest (rest lst))))]))))\n", "  (cond\n    [(empty? lst)\n \
    \    (list #f #f)\n     (let ([a (first lst)\n            b (second lst)])\n \
    \      (cond (< a b) (list a b))\n       (else (list b a))))]\n    [(list? (first\
    \ lst))\n     (let ([a (first lst)\n            b (second lst)])\n       (cond\
    \ (< a b) (list a b))\n       (else (list b a)))]\n    [else (error \"Not a list\
    \ of integers: ~a\" lst)]\n    [else (error \"Not a list: ~a\" lst)]))\n", " \
    \ (if (null? lst)\n      #f\n      (let ([smallest (car lst)\n            largest\
    \ (largest-integer (cdr lst))])\n        (cond [(> smallest largest) (list smallest\
    \ largest)\n               (= smallest largest) (list smallest)\n            \
    \   (< smallest largest) (list largest)\n               :else\n              \
    \ (largest_smallest_integers (cdr lst))]))))\n", "  (if (null? lst)\n      (list\
    \ #f #f)\n      (let ((a (max (car lst) (- 1 (car lst)))))\n        (let ((b (min\
    \ (cdr lst) (+ 1 (cdr lst)))))\n          (cons a b))))\n</code>\n<|/ a tags=racket,list\
    \ |>\n<| c |>\nThis was the only solution that worked for me in R5RS. Thank you\
    \ for taking the time to write this.\n<|/ c |>\n<| c |>\nThe `max` and `min` functions\
    \ are part of R5RS (released 1991). Those are implemented in Racket as [`max-key`\
    \ and `min-key`](https://docs.racket-lang.org/reference/pairs.html#(def._((quote._~23~25kernel)._max-key%29)).\n\
    <|/ c |>\n<| a dscore=4 |>\nThis question has a very simple and intuitive solution\
    \ that does not involve recursion (yet). Here's an implementation that's a bit\
    \ more obvious:\n<code>", "  (if (null? lst)\n      (list #f #f)\n      (let ((largest\
    \ (car lst)))\n        (let ((smallest (caddr lst)))\n          (cond ((< smallest\
    \ largest)\n                 (cons (cons largest smallest) \n                \
    \      (largest_smallest_integers (cdr lst))))\n                ((< largest smallest)\n\
    \                 (cons (cons smallest largest) \n                      (largest_smallest_integers\
    \ (cdr lst))))\n                (else\n                 (largest_smallest_integers\
    \ (cdr lst))))))))\n", "  (cond\n    ((empty? lst)\n     (cons (car lst)\n   \
    \        (car lst))\n     (else (cond\n          ((< (car lst) 0)\n          \
    \ (cons (car lst)\n                 (car lst)))\n          ((> (car lst) 0)\n\
    \           (cons (car lst)\n                 (car lst)))))))\n", "  (cond [(empty?\
    \ lst) (list #f #f)] \n        [else (cond\n                [\n              \
    \    [\n                    [(>= first 0) (first (first lst))] \n            \
    \        [(< first 0) (second (first lst))] \n                  ] [\n        \
    \            [#f]\n                  ]\n                ]\n                [\n\
    \                  [\n                    [(>= second 0) (second (first lst))]\
    \ \n                    [(< second 0) (first (first lst))] \n                \
    \  ] [\n                    [#f]\n                  ]\n                ]\n   \
    \           )\n          ]\n))\n", "  (cond\n    [(null? lst) '()]\n    [(< (first\
    \ lst) #f #f (first lst)) (cons (first lst) (largest_smallest_integers (rest lst)))]\n\
    \    [else (largest_smallest_integers (rest lst))]))\n</code>\n<|/ a tags=lisp,racket,scheme\
    \ |>\n<| a tags=lisp,racket,scheme |>\nI thought I'd try this in Racket:\n<code>",
  "  (cond\n    [(empty? lst) (list #f #f)]\n    [(> (first lst) (first lst)) (list\
    \ (first lst) (first lst))]\n    [else (largest_smallest_integers (rest lst)\n\
    \                         (first lst))]\n    )\n  )\n", "  (cond [(empty? lst)\
    \ #f]\n        [(< second (first lst)) (first (first lst))]\n        [else (cons\
    \ (first lst) (largest_smallest_integers (rest lst)))))", "  (cond [(empty? lst)\n\
    \         (list #f #f)\n         ]\n        [(negative? (first lst))\n       \
    \  (append (largest_smallest_integers (rest lst))\n                 (list (first\
    \ lst)))]\n        [(positive? (first lst))\n         (append (largest_smallest_integers\
    \ (rest lst))\n                 (list (first lst)))]\n        [else\n        \
    \ (largest_smallest_integers (rest lst))]))\n", "  (let ([a #f])\n    (cond\n\
    \      [(empty? lst)\n       (cons a #f)\n       ]\n      [(number? lst)\n   \
    \    (cons a (min 0 (max 0 (cdr lst))))]\n      [else (largest_smallest_integers\
    \ (cdr lst))]))", "  (cond\n    [(empty? lst) (list #f #f)]\n    [(empty? (rest\
    \ lst)) (list #f #f)]\n    [(> (first lst) 0))\n     (list (first lst) (largest_smallest_integers\
    \ (rest lst)))]\n    [else (largest_smallest_integers (rest lst))]))\n", "  (cond\
    \ [(null? lst) #f]\n        [(< (car lst) 0)\n         (cons (car lst) (largest_smallest_integers\
    \ (cdr lst)))]\n        [else (largest_smallest_integers (cdr lst))]))\n", " \
    \ (cond [(empty? lst) #f]\n        [(< 0 (first lst)) (first lst)]\n        [else\
    \ (largest (rest lst))]))\n", "  (cond\n    ((null? lst) #f)\n    ((< (car lst)\
    \ 0) (car lst))\n    (else (largest_smallest_integers (cdr lst)))))\n</code>\n\
    <|/ a tags=racket,scheme dscore=1 |>\n<| a tags=racket,scheme |>\nIf you're trying\
    \ to solve this problem in Scheme, a more idiomatic solution would be to use define-syntax\
    \ and Racket's list comprehension syntax.\n<code>", "  (cond\n    ((null? lst)\n\
    \      (list #f #f))\n    ((> (car lst) 0)\n      (list (car lst)\n          \
    \  (smaller (cdr lst) (car lst)))))\n  (cond\n    ((< 0 (car lst) 0)\n      (list\
    \ (car lst)\n            (smaller (cdr lst) (car lst)))))\n  (cond\n    ((< (car\
    \ lst) #f)\n      (list (car lst)\n            (smaller (cdr lst) (car lst))))))\n",
  "  (let loop ((lst (reverse lst))\n             (smallest #f))\n    (cond ((or (null?\
    \ lst) (number? lst))\n           (if (not (or (number? lst) (number? smallest)))\n\
    \               (list lst smallest)\n               (list smallest lst)))\n  \
    \        ((list? (car lst))\n           (loop (cdr lst) smallest))\n         \
    \ ((number? (car lst))\n           (loop (cdr lst) (cond (smallest? (car lst))\n\
    \                                smallest\n                                (smallest\
    \ (car lst))))\n          ((< smallest smallest)\n           (loop (cdr lst) smallest))\n\
    \          (else\n           (loop (cdr lst) smallest)))\n    ))\n", "  (let loop\
    \ ((largest-n #f) (smallest-n #f) (lst (reverse lst)))\n    (cond ((null? lst)\n\
    \           (list largest-n smallest-n))\n          ((< (car lst) largest-n) (loop\
    \ (car lst) (smallest-n (car lst)) (rest lst)))\n          ((> (car lst) smallest-n)\
    \ (loop (largest-n largest-n) smallest-n (rest lst)))\n          (else (loop (car\
    \ lst) (smallest-n largest-n) (rest lst)))))) \n", "  (cond\n    [(null? lst)\
    \ (list #f #f)] \n    [(< 0 (car lst)) (cons (car lst) (largest_smallest_integers\
    \ (cdr lst)))]\n    [else (cons (car lst) (largest_smallest_integers (cdr lst)))]))\n\
    </code>", "  (cond\n    [(empty? lst) (list #f #f)]\n    [(and (= (rest lst) (-\
    \ 0))) (list #f (rest lst))]\n    [(and (< 1 (car lst)) (<= (rest lst) (- 0)))\n\
    \     (if (> (car lst) (cadr lst)) (list (car lst) (cadr lst))\n          (list\
    \ (car lst) (rest lst)))]\n    [else\n     (largest_smallest_integers (cdr lst))]))\n",
  "  (cond [(empty? lst) #f]\n        [(null? (cdr lst)) (list (car lst) #f)]\n  \
    \      [(> (cdr lst) (car lst)) (list (cdr lst) (car lst))]\n        [else (largest_smallest_integers\
    \ (cdr lst))]))\n</code>\n<|/ a dscore=0 |>\n<| c |>\nI used this in a [Scheme\
    \ interpreter](http://play.integer32.com/?interpreter), but when I run it on my\
    \ computer, I get the error \"unbound identifier: max\" on this line: `(define\
    \ (max a b)\n  (if (> a b) a b))` Any ideas?\n<|/ c |>\n<| c |>\nThe error seems\
    \ to indicate that max (or max) is unbound in the context of a definition. Can\
    \ you show me the full code?\n<|/ c |>\n<| c |>\nI posted the full code at the\
    \ end of my original post. Thanks\n<|/ c |>\n<| c |>\nAre you running this in\
    \ DrScheme? That may be a source of the problem, since the code works fine in\
    \ Racket (but will fail in DrScheme). Can you try running it in Racket?\n<|/ c\
    \ |>\n<| c |>\nI edited my post to include the code I ran in Racket. Thanks again.\n\
    <|/ c |>\n<| a |>\nTry this.\n<code>", "  (cond\n    ((empty? lst) (list #f #f))\n\
    \    ((< first lst) (list (first lst) 1))\n    ((< second lst) (list (second lst)\
    \ (+ (first lst) (second lst))))\n    (t (largest_smallest_integers (rest lst)))))\n",
  "  (cond\n    ((empty? lst) (list #f #f))\n    ((<* (first lst) (first lst))\n \
    \    (cons (first lst) (largest_smallest_integers (rest lst))))\n    ((>* (first\
    \ lst) (first lst))\n     (largest_smallest_integers (rest lst)))\n    ((> (first\
    \ lst) (first lst))\n     (largest_smallest_integers (rest lst)))\n    ((< (first\
    \ lst) (first lst))\n     (largest_smallest_integers (rest lst)))\n    ((= (first\
    \ lst) (first lst))\n     (largest_smallest_integers (rest lst)))\n    (else\n\
    \     (largest_smallest_integers (rest lst)))))\n", "  (cond ((null? lst) #f)\n\
    \        ((> (car lst) (- (car lst) (first lst)))\n         (largest_smallest_integers\
    \ (cdr lst)))\n        (else (largest_smallest_integers (cdr lst)))))\n", "  (define\
    \ (helper lst smallest_var largest-var)\n    (cond\n      [(null? lst) (reverse\
    \ (list largest-var smallest_var))]\n      [else (if (< (first lst) smallest_var)\
    \ (cons (first lst) largest-var) (helper (rest lst) (first lst) (second lst)))]))\n\
    \  (helper lst #f #f)\n)\n", "  (if (null? lst)\n      (list #f #f)\n      (let\
    \ ((l (car lst)))\n        (if (< (car lst) 0)\n            (if (< l 0)\n    \
    \            (list #f #f)\n                (list l #f)\n               (list (car\
    \ lst) (car lst)))\n            (if (< l 0)\n                (list l #f)\n   \
    \             (list (car lst) (car lst)))))))\n\n#lang scheme\n", "  (cond\n \
    \   [(empty? lst) (list #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f\
    \ #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f\
    \ #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f\
    \ #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f\
    \ #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f\
    \ #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f\
    \ #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f\
    \ #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f\
    \ #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f\
    \ #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f ",
  "  (cond\n    [(empty? lst)\n     (list #f #f #f #f #f #f #f #f #f #f #f #f #f #f\
    \ #f #f #f #f #f #f #f #f #f)\n    ]\n    [(number? (car lst))\n     (cond\n \
    \      [(number? (cadr lst))\n        (list #f (cadr lst) (cadr (cddr lst)))]\n\
    \       [(< (cadr lst) (car lst))\n        (list #f (car lst) (cadr lst) (cadr\
    \ (cddr lst)))]\n       [(> (cadr lst) (car lst))\n        (list #f (cadr lst)\
    \ (car lst) (cadr (cddr lst)))]\n       [(> (cadr lst) (cadr lst))\n        (list\
    \ #f (cadr lst) (cadr lst) (cadr (cddr lst)))]\n       [else\n        (list #f\
    \ #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f)\n       ]\n\
    \      ]\n    [else\n     (cond\n       [(empty? lst)\n        (list #f #f #f\
    \ #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f)\n       ]\n\
    \       [(number? (car lst))\n        (cond\n         [(number? (cadr lst))\n\
    \          (list #f (car lst) (cadr lst) (cadr (cddr lst)))]\n         [(< (cadr\
    \ lst) (car lst))\n          (list #f (car lst) (cadr lst) (cadr (cddr lst)))]\n\
    \         [(> (cadr lst) (car lst))\n          (list #f (cadr lst) (car lst) (cadr\
    \ (cddr lst)))]\n         [(> (cadr lst) (cadr lst))\n          (list #f (cadr\
    \ lst) (cadr lst) (cadr (cddr lst)))]\n         [else\n          (list #f #f #f\
    \ #f ", "  (cond [(empty? lst) (list #f #f #f)]\n        [(> (first lst) 0)\n\
    \         (cons 0 (largest_smallest_integers (rest lst)))]\n        [(< (first\
    \ lst) 0)\n         (cons (first lst) (largest_smallest_integers (rest lst)))]\n\
    \        [else (cons (first lst) (largest_smallest_integers (rest lst)))]))",
  "  (cond\n    [(empty? lst) (list #f #f)]\n    [(or (negative? (first lst)) (positive?\
    \ (first lst))) (cons (first lst) (largest_smallest_integers (rest lst)))]\n \
    \   [else (largest_smallest_integers (rest lst))]))\n", "  (cond ((null? lst)\
    \ '(#f #f))\n        ((< (first lst) #f)\n         (largest_smallest_integers\
    \ (rest lst)))\n        (else\n         (cons (first lst)\n               (largest_smallest_integers\
    \ (rest lst)))))\n)\n", "  (cond [(empty? lst) (list #f #f)] \n        [(negative?\
    \ (first lst)) (list (first lst) (second lst))] \n        [else (list (first lst)\
    \ (second (first lst)))]))\n</code>\n<|/ a tags=lisp,racket,scheme |>\n<| c |>\n\
    This doesn't answer my question. My question was how to solve the problem efficiently\
    \ using the `max` procedure from the standard library. I can't see how your solution\
    \ would work with my given list.\n<|/ c |>\n<| c |>\nThe answer doesn't use max\
    \ but uses two comparisons which is as efficient as you can get\n<|/ c |>\n<|\
    \ c |>\n: Thanks, I didn't realize that `(max lst #f)` is equivalent to `(let\
    \ ((min #f) (max #f)) (cond [(empty? lst) (min) (max)] (else (let ((fst (first\
    \ lst)) (snd (second lst)) (cond\n<|/ c |>\n<| c |>\n`(max lst #f)` also works\
    \ in scheme and it's `max`, not `maxcdr` so this isn't any more efficient.\n<|/\
    \ c |>\n<| c |>\n: ah thanks, I wasn't aware of that. I wonder how many people\
    \ were upset with that since it's very different from `(maxcddr lst #f)`\n<|/\
    \ c |>\n<| a tags=lisp,racket,scheme |>\nYou can simply use max instead of your\
    \ own max procedure. That's how it's done in the standard library.\n<|/ a dscore=0\
    \ |>\n<| c |>\nThis is not an answer to the question. The question is \"How to\
    \ use the `max` procedure from the standard library\". You've linked the `max`\
    \ procedure from the Scheme standard.\n<|/ c |>\n<| a tags=lisp,racket,scheme\
    \ |>\nIn Racket, max is a built-in procedure. As long as you are using Racket\
    \ version >= 5, you can simply use max. Otherwise, you can define your own max\
    \ procedure like this:\n<code>", "  (cond [(empty? lst)\n         (list #f #f)\n\
    \         (< (first lst) 0)\n         (< (first lst) (rest lst))\n         (cons\
    \ (first lst) (largest_smallest_integers (rest lst)))]\n        [else\n      \
    \   (cons (first lst)\n               (largest_smallest_integers (rest lst)))]))\n",
  "  (if (or (empty? lst) (empty? (cdr lst)))\n      (list #f #f)\n      (let ((first\
    \ lst))\n        (if (or (empty? first) (empty? (cdr first)))\n            (list\
    \ #f #f)\n            (let ((a (first first))\n                  (b (first (cdr\
    \ first))))\n              (if (or (< a b) (< b a))\n                  (list a\
    \ b)\n                  (list (max a b) (min a b))))))))", "  (cond [(empty? lst)\n\
    \         #f]\n        [(> head lst)\n         (largest_smallest_integers (rest\
    \ lst))]\n        [else\n         (list head (largest_smallest_integers (rest\
    \ lst)))]))\n", "  (cond [(empty? lst)\n         #f]\n        [(< (first lst)\
    \ (first (rest lst)))\n         (largest_smallest_integers (rest lst))]\n    \
    \    [else (list (first lst) (first (rest lst)))]))\n\n#lang scheme\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
