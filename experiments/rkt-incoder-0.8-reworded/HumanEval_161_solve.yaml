name: HumanEval_161_solve
language: rkt
prompt: "#lang racket\n\n;; You are given a string s.\n;; if s[i] is a letter, reverse\
  \ its case from lower to upper or vise versa, \n;; otherwise keep it as it is.\n\
  ;; If the string contains no letters, reverse the string.\n;; The function should\
  \ return the resulted string.\n;; Examples\n;; >>> (solve \"1234\")\n;; \"4321\"\
  \n;; >>> (solve \"ab\")\n;; \"AB\"\n;; >>> (solve \"#a@C\")\n;; \"#A@c\"\n(define\
  \ (solve s)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate solve))\n\
  \    (check-equal? (candidate \"AsDf\") \"aSdF\")\n    (check-equal? (candidate\
  \ \"1234\") \"4321\")\n    (check-equal? (candidate \"ab\") \"AB\")\n    (check-equal?\
  \ (candidate \"#a@C\") \"#A@c\")\n    (check-equal? (candidate \"#AsdfW^45\") \"\
  #aSDFw^45\")\n    (check-equal? (candidate \"#6@2\") \"2@6#\")\n    (check-equal?\
  \ (candidate \"#$a^D\") \"#$A^d\")\n    (check-equal? (candidate \"#ccc\") \"#CCC\"\
  )\n))\n\n(test-humaneval)"
completions: ["  (cond\n    [(empty? s) s]\n    [else\n     (cond\n       [(char=?\
    \ (first s) #\\a) (apply (lambda (r) \n                                (make-string\
    \ (inc (length s)) #\\a))\n                             s)]\n       [(char=? (first\
    \ s) #\\A) (apply (lambda (r) \n                                (make-string (inc\
    \ (length s)) #\\A))\n                             s)]\n       [(char=? (first\
    \ s) #\\U) (apply (lambda (r) \n                                (make-string (inc\
    \ (length s)) #\\U))\n                             s)]\n       [(char=? (first\
    \ s) #\\L) (apply (lambda (r) \n                                (make-string (inc\
    \ (length s)) #\\L))\n                             s)]\n       [(char=? (first\
    \ s) #\\l) (apply (lambda (r) \n                                (make-string (inc\
    \ (length s)) #\\L))\n                             s)]\n       [(char=? (first\
    \ s) #\\o) (apply (lambda (r) \n                                (make-string (inc\
    \ (length s)) #\\O))\n                             s)]\n       [(char=? (first\
    \ s) #\\O) (apply (lambda (r) \n                                (make-string (inc\
    \ (length s)) #\\O))\n                             s)]\n       [(char=? (first\
    \ s) #\\e) (apply (lambda (r) \n                                (make-string (inc\
    \ (length s)) #\\E))\n                             s)]\n       [(char=? (first\
    \ s) #\\u) (apply (lambda (r) \n                                (make-string (inc\
    \ (length s)) #\\U))\n                             s)]\n       [(char=? (first\
    \ s) #\\X) (apply (lambda (r) \n                                (make-string (inc\
    \ (length s)) #\\X))\n                             s)]\n       [(char=? (first\
    \ s) #\\x) (apply (lambda (r) \n                                (make-string (inc\
    \ (length s)) #\\X))\n                             s)]\n       [(char=? (first\
    \ s) #\\z) (apply (lambda (r) \n                                (make-string (inc\
    \ (length s)) #\\Z))\n                             s)]\n       [(char=? (first\
    \ s) #\\Z) (apply (lambda (r) \n                                (make-string (inc\
    \ (length s)) #\\Z))\n                             s)]\n       [(char=? (first\
    \ s) #\\b) (apply (lambda (r) \n                                (make-string (inc\
    \ (length s)) #\\b))\n                             s)]\n       [(char=? (first\
    \ s) #\\v) (apply (", "  (cond\n    [(empty? s) s]\n    [(number? (car s))\n \
    \    (cond \n       [(char=? (char->integer car s) 97) (let* ([letter (char->integer\
    \ car s)\n                                               (lower-letter (char->integer\
    \ 97))\n                                               (upper-letter (char->integer\
    \ 65))])\n                                  (cond \n                         \
    \          [(char=? letter lower-letter) (concat letter upper-letter)]\n     \
    \                              [(char=? letter upper-letter) (concat lower-letter\
    \ upper-letter)]\n                                   [else (concat letter lower-letter\
    \ upper-letter)])]\n       [(char=? (char->integer car s) 65) (let* ([letter (char->integer\
    \ car s)\n                                               (lower-letter (char->integer\
    \ 97))\n                                               (upper-letter (char->integer\
    \ 65))])\n                                  (cond \n                         \
    \          [(char=? letter lower-letter) (concat letter upper-letter)]\n     \
    \                              [(char=? letter upper-letter) (concat lower-letter\
    \ upper-letter)]\n                                   [else (concat letter lower-letter\
    \ upper-letter)])]\n       [else (let* ([letter (char->integer car s)])\n    \
    \                (cond \n                     [(char=? letter lower-letter) (concat\
    \ letter upper-letter)]\n                     [(char=? letter upper-letter) (concat\
    \ lower-letter upper-letter)]\n                     [else (concat letter lower-letter\
    \ upper-letter)])])]\n    [else (let* ([letter (char->integer car s)])\n     \
    \          (cond \n               [(char=? letter lower-letter) (concat letter\
    \ upper-letter)]\n               [(char=? letter upper-letter) (concat lower-letter\
    \ upper-letter)]\n               [else (concat letter lower-letter upper-letter)])]\n\
    \    [else (let* ([letter (char->integer car s)])\n               (cond \n   \
    \            [(char=? letter lower-letter) (concat letter upper-letter)]\n   \
    \            [(char=? letter upper-letter) (concat lower-letter upper-letter)]\n\
    \               [else (concat letter lower-letter upper-letter)])]\n    [else\
    \ (let* ([letter (char->integer car s)])\n               (cond \n            \
    \   [(char=? letter lower-letter) (concat letter upper-letter)]\n            \
    \   [(char=? letter upper-letter) (con", "  (let loop ((s (string->list s))\n\
    \             (result (list s))\n             (i 0)\n             (result (append\
    \ result (list (string->list (substring s i 1)))) ))\n    (if (empty? s)\n   \
    \     (reverse result)\n        (loop (rest s) result (i) (loop (substring s i)\
    \ result (i + 1))))))\n", "  (cond\n    [(empty? s) \"\"]\n    [(member? (car\
    \ s) #\\A) (upper-case? (solve (cdr s))) \n     (upper-case? (solve (cdr s)))]\n\
    \    [else (lower-case? (solve (cdr s)))]\n  )\n)\n", "  (cond [(string? s)\n\
    \         (reverse (map (lambda(x) (cond\n                              [(char=?\
    \ (car s) x) (string-upcase (char-upcase x))]\n                              [(char=?\
    \ (car s) x) (char-downcase (char-downcase x))])))]\n        [else s]))\n</code>\n\
    <|/ a dscore=0 |>\n<| a dscore=0 tags=racket,scheme |>\nThis might seem a bit\
    \ long but I'll give it a try. \nI assume you were asked to do this using Scheme's\
    \ map, filter, foldr, etc. functions. \nSo my solution would be something like\
    \ this:\n<code>", "  (cond\n    ((empty? s)\n     s)\n    ((char? c)\n     (cond\n\
    \       ((char= c #\\a)\n        (char= (substring s 0 (char-index s c)) (substring\
    \ s (+ 0 (char-index s c)))\n         (substring s (+ 0 (char-index s c)) (+ 0\
    \ (char-index s c)))\n         (substring s (+ 0 (char-index s c)) (+ 0 (char-index\
    \ s c))))\n       ((char= c #\\z)\n        (char= (substring s 0 (char-index s\
    \ c)) (substring s (+ 0 (char-index s c)))\n         (substring s (+ 0 (char-index\
    \ s c)) (+ 0 (char-index s c)))\n         (substring s (+ 0 (char-index s c))\
    \ (+ 0 (char-index s c))))\n       ((char= c #\\D)\n        (char= (substring\
    \ s 0 (char-index s c)) (substring s (+ 0 (char-index s c)))\n         (substring\
    \ s (+ 0 (char-index s c)) (+ 0 (char-index s c)))\n         (substring s (+ 0\
    \ (char-index s c)) (+ 0 (char-index s c))))\n       ((char= c #\\l)\n       \
    \ (char= (substring s 0 (char-index s c)) (substring s (+ 0 (char-index s c)))\n\
    \         (substring s (+ 0 (char-index s c)) (+ 0 (char-index s c)))\n      \
    \   (substring s (+ 0 (char-index s c)) (+ 0 (char-index s c))))\n       ((char=\
    \ c #\\G)\n        (char= (substring s 0 (char-index s c)) (substring s (+ 0 (char-index\
    \ s c)))\n         (substring s (+ 0 (char-index s c)) (+ 0 (char-index s c)))\n\
    \         (substring s (+ 0 (char-index s c)) (+ 0 (char-index s c))))\n     \
    \  ((char= c #\\P)\n        (char= (substring s 0 (char-index s c)) (substring\
    \ s (+ 0 (char-index s c)))\n         (substring s (+ 0 (char-index s c)) (+ 0\
    \ (char-index s c)))\n         (substring s (+ 0 (char-index s c)) (+ 0 (char-index\
    \ s c))))\n       ((char= c #\\r)\n        (char= (substring s 0 (char-index ",
  "  \n  (if (char-alphabet s)\n      (char-toLower s)\n      (char-toUpper s)))\n",
  "  (cond\n    ((or (not (number? s)) (string-empty? s))\n     (reverse s))\n   \
    \ ((string? (first s)) (cond\n                            ((or (string-equal?\
    \ (first s) \"a\") (string-equal? (first s) \"A\"))\n                        \
    \     (first (reverse (second s))))\n                            ((or (string-equal?\
    \ (first s) \"b\") (string-equal? (first s) \"B\"))\n                        \
    \     (first (reverse (third s))))\n                            ((or (string-equal?\
    \ (first s) \"c\") (string-equal? (first s) \"C\"))\n                        \
    \     (first (reverse (fourth s))))\n                            (else s))))\n\
    \    (else s)))\n", "  (cond [(empty? s) s]\n        [(eq? (first s) (first upper))\
    \ (lower (first s))]\n        [(eq? (first s) (first lower)) (upper (first s))]\n\
    \        [else (cons (first s) (solve (sub1 s))]))\n)", "  (define (helper (i\
    \ j)\n    (cond\n      [(char->integer s[i] >= (char->integer s[j])\n        \
    \       (char->integer s[i])\n               (char->integer s[j]))\n       (helper\
    \ (+ i 1) j)\n      [(char->integer s[i] <= (char->integer s[j])\n           \
    \    (char->integer s[i])\n               (char->integer s[j]))\n       (helper\
    \ (+ j 1) i)]\n      [(char->integer s[i] >= (char->integer s[j])\n          \
    \     (char->integer s[i])\n               (char->integer s[j]))\n       (helper\
    \ (+ i 1) j)\n      [(char->integer s[i] <= (char->integer s[j])\n           \
    \    (char->integer s[i])\n               (char->integer s[j]))\n       (helper\
    \ (+ j 1) i)]\n      [else\n       (helper (+ i 1) j)\n       (helper (+ j 1)\
    \ i)]))\n  (let ([i 0])\n    (cond\n      [(char->integer s[(+ i 1)] >= (char->integer\
    \ s[(+ j 1)])\n          (char->integer s[(+ i 1)])\n          (char->integer\
    \ s[(+ j 1)])]\n      (helper (+ i 1) (+ j 1))]\n      [else\n       (helper (+\
    \ i 1) (+ j 1))]))\n)\n", "  (if (empty? s)\n      (list s)\n      (let ((chars\
    \ (map list->string\n                        (map (\u03BB (ch) (if (char->integer?\
    \ ch) (char->integer ch) (string ch)))\n                               (string->list\
    \ s)))))\n        (define helper\n          (lambda (ls)\n            (cond\n\
    \              [(empty? ls) (list s)]\n              [(string=? (first ls) \"\"\
    ) ls]\n              [else (cons (first ls)\n                           (helper\
    \ (rest ls)))])))\n        (helper (map (\u03BB (ch) (if (char->integer? ch) (char->integer\
    \ ch) (string ch)))\n                    chars))))\n</code>\n<|/ a tags=scheme,racket,recursion,lisp\
    \ |>\n<| a dscore=2 |>\nHere's another solution, although I find the other solutions\
    \ more readable. Using a named let for clarity and readability:\n<code>", "  (cond\n\
    \    [(empty? s) \"\"]\n    [(= (char-case? first) (char-case? first)) \n    \
    \  (cons (char-case? (first s)) \n            (apply solve\n                 \
    \ (sub1 s)))]\n    [else (cons (first s) (apply solve (sub1 s))) ]))\n</code>\n\
    <|/ a dscore=1 |>\n<| a |>\n<code>", "  (cond\n    [(empty? s) s]\n    [(equal?\
    \ (first (first s)) (string->symbol (first (first s))))\n      (let ([s (reverse\
    \ (first s))])\n        (cond\n          [(null? s) s]\n          [(char->string?\
    \ (first s))\n           (cond\n             [(equal? (first s) #\\a)\n      \
    \         (let ([s (reverse (first s))])\n                 (cond\n           \
    \        [(null? s) s]\n                   [(char->string? (first s))\n      \
    \              (let ([s (reverse (first s))])\n                      (cond\n \
    \                       [(null? s) s]\n                        [(char->string?\
    \ (first s))\n                         (let ([s (reverse (first s))])\n      \
    \                     (cond\n                             [(null? s) s]\n    \
    \                         [(char->string? (first s))\n                       \
    \        (let ([s (reverse (first s))])\n                                 (cond\n\
    \                                   [(null? s) s]\n                          \
    \         [(char->string? (first s))\n                                    (let\
    \ ([s (reverse (first s))])\n                                      (cond\n   \
    \                                     [(null? s) s]\n                        \
    \                [(char->string? (first s))\n                                \
    \         (let ([s (reverse (first s))])\n                                   \
    \       (cond\n                                            [(null? s) s]\n   \
    \                                         [(char->string? (first s))\n       \
    \                                      (let ([s (reverse (first s))])\n      \
    \                                        (cond\n                             \
    \                   [(null? s) s]\n                                          \
    \      [else\n                                                 (cons (string->symbol\
    \ (first (first s))) s)])]))]))]))]))]))]\n          [else\n           (cond\n\
    \             [(null? s) s]\n             [(char->string? (first s))\n       \
    \        (cond\n                 [(equal? (first s) #\\a)\n                  \
    \ (let ([s (reverse (first s))])\n                    (cond\n                \
    \      [(null? s) s]\n                      [(char->string? (first s))\n     \
    \                  (let ([s (reverse (first s))])\n                        (cond\n\
    \                          [(null? s) s]\n                          [(char->string?\
    \ (first s))\n                           (let ([s (reverse (first s))])\n    \
    \                        (cond\n                              [(null? s) s]\n\
    \                              [(char->string? (first s))\n                  \
    \             (let ([s (reverse (first s))])\n                               \
    \ (cond\n                                  [(null? s) s]\n                   \
    \               [(char->string? (first s))\n                                 \
    \  (let ([s (reverse (first s))])\n                                    (cond\n\
    \                                      [(null? s) s]\n                       \
    \               [(char->string? (first s))\n                                 \
    \      (let ([s (reverse (first s))])\n                                      \
    \  (cond\n                                          [(null? ", "  (cond\n    [(empty?\
    \ s)\n      empty]\n    [(equal? (first s) (first #\\_))\n      (cond\n      \
    \  [(= (rest #\\_) empty)\n         empty]\n        [(equal? (first #\\_) (first\
    \ #\\_))\n         (cond\n           [(equal? (first s) (rest (rest s))) \n  \
    \          (cond\n             [(equal? (first #\\_) (rest (rest #\\_))) (cons\
    \ (char->string (char->int (first #\\_))) (solve (rest (rest #\\_)))]\n      \
    \       [(equal? (first #\\_) (first s)) (cons (char->string (char->int (first\
    \ #\\_))) (solve (rest s)))]\n             [else (solve (rest (rest #\\_)))]))]\n\
    \          [else (solve (rest (rest s))))]))]\n    [else\n      (cons (char->string\
    \ (char->int (first s))) (solve (rest (rest s))))]))\n</code>\n<|/ a tags=scheme,lisp,racket\
    \ dscore=2 |>\n<| c |>\nThank you so much! Your solution was really helpful. I\
    \ really appreciate it.\n<|/ c |>\n<| a dscore=1 |>\nThis code may help you\n\
    <code>", "  (cond\n    [(empty? s) s]\n    [(char? s)\n     (cond\n       [(eql?\
    \ (char-upcase? s) (char-downcase? s)) (reverse s)]\n       [(eql? (char-downcase?\
    \ s) (char-upcase? s)) (reverse (downcase s))]\n       [(eql? (char-upcase? s)\
    \ (char-downcase? s)) (upcase (downcase s))])]\n    [else (downcase s)]))\n",
  "  (cond\n    [(empty? s) \"\"]\n    [(letter? s) (upper-case (solve (reverse s))]\n\
    \    [else (lower-case (solve (reverse s)))]))\n)\n", "  (cond [(empty? s) \"\"\
    ]\n        [(equal? (car s) #\\a) (upper-case (solve (cdr s))]\n        [else\
    \ (lower-case (solve (cdr s)))]))\n)\n", "  (cond\n    ((null? s) s)\n    ((char?\
    \ (car s)) (toUpper (solve (cdr s))))\n    ((string? (car s)) (toLower (solve\
    \ (cdr s))))\n    ((char? (car s)) (toLower (solve (cdr s))))\n    (else (cons\
    \ (car s) (solve (cdr s))))))", "  (cond [(= (length s) 0)\n         s]\n    \
    \    [(or (char-? (first s)) (char-? (first s)))\n         (char-upper-case (first\
    \ s))]\n        [else\n         (let ([c (first s)])\n           (cond (char-?\
    \ (rest s)) (solve (rest s))\n                 (char-upper-case c) ; lower-case\n\
    \                 (char-lower-case c) ; upper-case\n                 (else (cons\
    \ (reverse c) (solve (rest s))))))]))\n</code>\n<|/ a |>\n<| c |>\nIt works great\
    \ but I can't understand one thing. Why do I need to call reverse and cons two\
    \ times while solving the problem? What is the purpose of calling reverse and\
    \ cons 2 times?\n<|/ c |>\n<| c |>\nWe first need to reverse the string because\
    \ we can't know which case is going to be applied to the given string. Then, we\
    \ need to convert our character to upper/lower-case since we can't know if the\
    \ letter is already upper/lower case. Finally, we need to cons that character\
    \ with our recursive function `solve` and the remaining string.\n<|/ c |>\n<|\
    \ c |>\nIf this answer has solved your question please consider accepting it by\
    \ clicking the check-mark. This indicates to the wider community that you've found\
    \ a solution and gives some reputation to both the answerer and yourself.\n<|/\
    \ c |>\n<| a dscore=1 |>\nI believe this was the best answer I could find online\
    \ for this question:\n<code>", "  (let ([count 0])\n    (define (char i)\n   \
    \   (if (string? i)\n          (reverse (substring i 0 (char-index i s)))\n  \
    \        (string-append i)))\n    (define (loop i count)\n      (if (< i (char-index\
    \ s count))\n          (set! count (+ count 1))\n          (if (char? i)\n   \
    \           (loop (char-code i) count)\n              (string-append (loop i (substring\
    \ s count s))))))\n    (loop s (substring s 0 s))))\n", "  (define (char-to-char\
    \ c)\n    (cond ((char=? c #\\A) (char= (char-downcase c) (cdr (char-to-string\
    \ (char-upcase c))))\n          (char= (char-downcase c) (char-upcase c))\n  \
    \        (char= (char-upcase c) (cdr (char-to-string (char-downcase c))))\n  \
    \        (char= (cdr (char-to-string (char-downcase c))) (char-upcase c))\n  \
    \        (char= (cdr (char-to-string (char-upcase c))) #\\A)))\n  (define (case-switch\
    \ c)\n    (char-to-char (cond ((char=? c #\\a) (char-upcase c))\n            \
    \          ((char=? c #\\b) (char-downcase c))\n                      ((char=?\
    \ c #\\d) (char-downcase c))\n                      ((char=? c #\\e) (char-downcase\
    \ c))\n                      ((char=? c #\\f) (char-downcase c))\n           \
    \           ((char=? c #\\n) (char-downcase c))\n                      ((char=?\
    \ c #\\v) (char-downcase c))\n                      ((char=? c #\\o) (char-downcase\
    \ c))\n                      (else c))))\n  (define (case-switch s)\n    (define\
    \ (case-switch c)\n      (cond ((char=? c #\\a) (char-upcase c))\n           \
    \ ( (char=? c #\\b) (char-downcase c))\n            ( (char=? c #\\d) (char-downcase\
    \ c))\n            ( (char=? c #\\e) (char-downcase c))\n            ( (char=?\
    \ c #\\f) (char-downcase c))\n            ( (char=? c #\\n) (char-downcase c))\n\
    \            ( (char=? c #\\v) (char-downcase c))\n            ( (char=? c #\\\
    o) (char-downcase c))\n            ( (char=? c #\\0) (cons '\\0 c)\n         \
    \   ( (char=? c #\\9) (cons '\\9 c)\n            ( (char=? c #\\a) (cons '\\A\
    \ c)\n            ( (char=? c #\\b) (cons '\\B c)\n            ( (char=? c #\\\
    c) (cons '\\C c)\n            ( (char=? c #\\d) (cons '\\D c)\n            ( (char=?\
    \ c #\\e) (cons '\\E c)\n            ( (char", "  (let ((r (reverse s))\n    \
    \    (l (length s))\n        (o (if (= l 0)\n               '#c\n            \
    \   (if (or\n                      (or\n                       (char=? (first\
    \ s) #\\A)\n                       (char=? (first s) #\\z))\n                \
    \       'a\n                       'z))))\n        (t (if (char=? (first s) #\\\
    L)\n               (cons (first s) r)\n               r)))\n    (if (or (char=?\
    \ (first s) #\\L)\n            (char=? (first s) #\\z))\n        (cons (first\
    \ s) r)\n        r)))\n", "  (cond ((null? s) s)\n        ((char=? (car s) #\\\
    a) (set! s (string->chars (string->string s)) (reverse (string->string s))))\n\
    \        (else (string->string s))))\n", "  (cond\n    [(empty? s) s]\n    [(member\
    \ (char->integer char) '(97 65 97 48 49)) (lowercase (toupper (char->integer char)))]\n\
    \    [else (toupper (char->integer char))]\n  )\n)\n", "  (cond [(empty? s) s]\n\
    \        [(character? (first s)) (reverse (solve (reverse (first s))))]\n    \
    \    [else (substring (first s) 1 (- (length s) 1))]))\n</code>\n<|/ a |>\n<|\
    \ c |>\nThis code will fail on \"aBcD\". Can you fix it?\n<|/ c |>\n<| c |>\n\
    Oh yes, it does, thanks for notifying. Updated my answer to handle it properly.\n\
    <|/ c |>\n<| a tags=scheme,racket,recursion,string dscore=2 |>\nHere is another\
    \ approach that uses recursion and a helper function. This solution does not mutate\
    \ the original string, but rather builds a new one.\n<code>", "  (cond ((empty?\
    \ s)\n         \"#\")\n        ((char-? (first s))\n         (if (equal? (first\
    \ s) (first (rest s)))\n             (reverse (apply (lambda (rest) (cons (first\
    \ rest) (first (rest rest)))\n                                   (solve (rest\
    \ rest))))\n               (reverse (apply (lambda (rest) (cons (first rest) (rest\
    \ (rest rest)))\n                                   (solve (rest rest))))\n  \
    \             (reverse (apply (lambda (rest) (cons (first rest) (rest (rest rest)))\n\
    \                                   (solve (rest rest))))\n               (reverse\
    \ (apply (lambda (rest) (cons (first rest) (first rest))\n                   \
    \                (solve (rest rest))))\n             s))\n         (else\n   \
    \       (first s))))\n", "  (cond\n    ((empty? s) s)\n    ((equal? (first s)\
    \ #\\A) (first s))\n    ((empty? (rest s)) (solve (last s)))\n    ((char? (first\
    \ s)) (solve (second (first s))))\n    ((char? (second s)) (solve (third (rest\
    \ s))))\n    ((char? (third s)) (solve (fourth (rest s))))\n    ((char? (fourth\
    \ s)) (solve (fifth (rest s))))\n    ((char? (fifth s)) (solve (sixth (rest s))))\n\
    \    ((char? (sixth s)) (solve (seventh (rest s))))\n    ((char? (seventh s))\
    \ (solve (eighth (rest s))))\n    ((char? (eighth s)) (solve (ninth (rest s))))\n\
    \    ((char? (ninth s)) (solve (tenth (rest s))))\n    ((char? (tenth s)) (solve\
    \ (eleventh (rest s))))\n    ((char? (eleventh s)) (solve (twelfth (rest s))))\n\
    \    ((char? (twelfth s)) (solve (thirteenth (rest s))))\n    ((char? (thirteenth\
    \ s)) (solve (fourteenth (rest s))))\n    ((char? (fourteenth s)) (solve (fifteenth\
    \ (rest s))))\n    ((char? (fifteenth s)) (solve (sixteenth (rest s))))\n    ((char?\
    \ (sixteenth s)) (solve (seventeenth (rest s))))\n    ((char? (seventeenth s))\
    \ (solve (eighteenth (rest s))))\n    ((char? (eighteenth s)) (solve (ninteenth\
    \ (rest s))))\n    ((char? (ninteenth s)) (solve (twelfth (rest s))))\n    ((char?\
    \ (twelfth s)) (solve (thirty-first (rest s))))\n    ((char? (thirty-first s))\
    \ (solve (thirty-second (rest s))))\n    ((char? (thirty-second s)) (solve (thirty-third\
    \ (rest s))))\n    ((char? (thirty-third s)) (solve (thirty-fourth (rest s))))\n\
    \    ((char? (thirty-fourth s)) (solve (thirty-fifth (rest s))))\n    ((char?\
    \ (thirty-fifth s)) (solve (thirty-sixth (rest s))))\n    ((char? (thirty-sixth\
    \ s)) (solve (thirty-seventh (rest s))))\n    ((char? (thir", "  (define (helper\
    \ s i)\n    (cond\n      [(char-or-not (char= s #\\a) (+ i 1))]\n      [(char-or-not\
    \ (char= s #\\A) (+ i 1))]\n      [else\n       (cond [(char-or-not (char= s #\\\
    b) (+ i 1))]\n             [(char-or-not (char= s #\\B) (+ i 1))]\n          \
    \   [else\n               (helper (reverse s) (- i 1))]))]\n    [else\n     (helper\
    \ (reverse s) (+ i 1))]))\n  (helper s 0))\n</code>\n<|/ a dscore=2 |>\n<| c |>\n\
    For some reason, `(solve \"#\")` returns `\"#\"`.\n<|/ c |>\n<| c |>\nSorry, there\
    \ was a bug. Fixed now.\n<|/ c |>\n<| c |>\nStill returning `\"#\"`.\n<|/ c |>\n\
    <| c |>\nOh, sorry about that. I forgot one more edge case. Fixed now. :)\n<|/\
    \ c |>\n<| c |>\nThis is really great.  I used this on a similar challenge to\
    \ reverse the characters in the string \"1234\" and it worked well.  I wonder\
    \ if you could explain the structure a little bit.  I understand that \"helper\"\
    \ is returning a new string, but don't understand the \"(char-or-not (char= s\
    \ #\\a) (+ i 1))\" syntax.  Also, why are you adding the new string to s1 and\
    \ not s2?\n<|/ c |>\n<| a tags=scheme,recursion,racket,string |>\nThis isn't the\
    \ fastest or most idiomatic solution but for those who, like me, want to avoid\
    \ loops in Scheme it's very helpful.\n<code>", "  (let loop ([i 0] [result '()])\n\
    \    (cond\n      [(empty? s) result]\n      [(char=? (car s) (char->integer i))\
    \ (loop (+ i 1) (cons (char->integer i) (loop (- i 1) result)))]\n      [(char=?\
    \ (car s) #\\A) (loop (+ i 1) (cons (char->integer i) (loop (- i 1) result)))]\n\
    \      [(char=? (car s) #\\a) (loop (+ i 1) (cons (char->integer i) (loop (- i\
    \ 1) result)))]\n      [else (loop (+ i 1) (cons (char->integer i) (loop (- i\
    \ 1) result)))]\n    )\n  )\n)", "  (let loop ((s s)\n             (a #f)\n  \
    \           (res #f)\n             (i 0))\n    (cond\n      ((null? s) (reverse\
    \ res))\n      ((char? s)\n       (let ((c (char-code (first (char-set s)))))\n\
    \         (cond ((or (> c 90) (< c 122)) (cond ((char->upper? c) (reverse (loop\
    \ (rest s) (or (char->upper? (first s)) (char->lower? (first s))) (inc (first\
    \ s)))))\n                 ((char->lower? c) (reverse (loop (rest s) (or (char->upper?\
    \ (first s)) (char->lower? (first s))) (inc (first s))))))\n          ((and (>=\
    \ i (length s))\n               (char->numeric? (first (char-set s))))\n     \
    \      (loop (rest s)\n                 (or (char->upper? (first s)) (char->lower?\
    \ (first s))) (inc (first s))\n                 i))\n          ((char->whitespace?\
    \ c) (loop (rest s) (or (char->upper? (first s)) (char->lower? (first s))) (inc\
    \ (first s))))\n          ((char->punctuation? c) (loop (rest s) (or (char->upper?\
    \ (first s)) (char->lower? (first s))) (inc (first s))))\n          (else\n  \
    \         (loop (rest s)\n                 (or (char->upper? (first s)) (char->lower?\
    \ (first s))) (inc (first s))\n                 i)))))\n      ((string? s)\n \
    \      (let ((c (first s)))\n         (loop (rest s)\n               (char->upper?\
    \ c)\n               (or (char->upper? (first s)) (char->lower? (first s))) (inc\
    \ (first s))\n               i))\n       (else res))))))\n</code>\n<|/ a dscore=1\
    \ tags=string,lisp,scheme |>\n<| a |>\nA solution in Scheme using reverse and\
    \ recursion:\n<code>", "  (define (lowercase ch) (if (char->integer? ch) (char->integer\
    \ ch) ch))\n  (define (toupper ch) (if (char->integer? ch) (char->integer ch)\
    \ ch))\n  (define (tolower ch) (if (char->integer? ch) (char->integer ch) ch))\n\
    \  (define (replace-case ch new-ch) (if (char->integer? ch) (char->integer ch)\
    \ ch))\n  (define (reverse str)\n    (if (char->integer? str)\n        (char->integer\
    \ str)\n        str))\n  (define (remove-case str)\n    (if (char->integer? str)\n\
    \        (char->integer str)\n        str))\n  (define (upper-case str)\n    (if\
    \ (char->integer? str)\n        (char->integer str)\n        str))\n  (define\
    \ (lower-case str)\n    (if (char->integer? str)\n        (char->integer str)\n\
    \        str))\n  (define (reverse str)\n    (if (char->integer? str)\n      \
    \  (char->integer str)\n        str))\n  (define (lower-case str)\n    (if (char->integer?\
    \ str)\n        (char->integer str)\n        str))\n  (define (replace str new-str\
    \ replacement)\n    (if (char->integer? str)\n        (char->integer str)\n  \
    \      str))\n  (define (upper-case str)\n    (if (char->integer? str)\n     \
    \   (char->integer str)\n        str))\n  (define (lower-case str)\n    (if (char->integer?\
    \ str)\n        (char->integer str)\n        str))\n  (define (toupper ch) (if\
    \ (char->integer? ch) (char->integer ch) ch))\n  (define (tolower ch) (if (char->integer?\
    \ ch) (char->integer ch) ch))\n  (define (replace-case ch new-ch) (if (char->integer?\
    \ ch) (char->integer ch) ch))\n  (define (reverse str)\n    (if (char->integer?\
    \ str)\n        (char->integer str)\n        str))\n  (define (remove-case str)\n\
    \    (if (char->integer? str)\n        (char->integer str)\n        str))\n  (define\
    \ (upper-case str)\n    (if (char->integer? str)\n        (char->integer str)\n\
    \        str))\n  (define (lower-case str)\n    (if (char->integer? str)\n   \
    \     (char->integer str)\n        str))\n  (define (replace str new-str replacement)\n\
    \    (if (char->integer? str)\n        (char->integer str)\n        str))\n  (define\
    \ (upper", "  (cond ((empty? s) s)\n        ((char? (car s))\n         (cond ((char->int\
    \ (car s)) >= 65)\n              ((char->int (car s)) <= 90) \n              (else\
    \ \n               (string->symbol (string->string (string->list (reverse s))))))\n\
    \         (else (string->symbol (string->string (reverse s)))))))\n", "  (cond\n\
    \    [(empty? s) s]\n    [(and (number? (first s)) (string=? (first (first s))\
    \ #\\a))\n     (string-set! s '(#\\A) (first s))]\n    [(and (number? (first s))\
    \ (string=? (first (first s)) #\\A))\n     (string-set! s '(#\\a) (first s))]\n\
    \    [(and (number? (first s)) (string=? (first (first s)) #\\z))\n     (string-set!\
    \ s '(#\\Z) (first s))]\n    [(and (number? (first s)) (string=? (first (first\
    \ s)) #\\Z))\n     (string-set! s '(#\\z) (first s))]\n    [(and (number? (first\
    \ s)) (string=? (first (first s)) #\\b))\n     (string-set! s '(#\\B) (first s))]\n\
    \    [(and (number? (first s)) (string=? (first (first s)) #\\b))\n     (string-set!\
    \ s '(#\\b) (first s))]\n    [(and (number? (first s)) (string=? (first (first\
    \ s)) #\\G))\n     (string-set! s '(#\\G) (first s))]\n    [(and (number? (first\
    \ s)) (string=? (first (first s)) #\\G))\n     (string-set! s '(#\\g) (first s))]\n\
    \    [(and (number? (first s)) (string=? (first (first s)) #\\h))\n     (string-set!\
    \ s '(#\\H) (first s))]\n    [(and (number? (first s)) (string=? (first (first\
    \ s)) #\\H))\n     (string-set! s '(#\\h) (first s))]\n    [(and (number? (first\
    \ s)) (string=? (first (first s)) #\\i))\n     (string-set! s '(#\\I) (first s))]\n\
    \    [(and (number? (first s)) (string=? (first (first s)) #\\I))\n     (string-set!\
    \ s '(#\\i) (first s))]\n    [(and (number? (first s)) (string=? (first (first\
    \ s)) #\\j))\n     (string-set! s '(#\\J) (first s))]\n    [(and (number? (first\
    \ s)) (string=? (first (first s)) #\\J))\n     (string-set! s '(#\\j) (first s))]\n\
    \    [(and (number? (first s)) (string=? (first (first s)) #\\k))\n     (string-set!\
    \ s '(#\\K) (first s))]", "  (cond\n    [(empty? s) (empty? s)]\n    [(char? \
    \ (first s)) (map (lambda (c) (cond [(or (char? c) (char? #\\A) (char? #\\z) (char?\
    \ #\\Z) (reverse (cat (substring (cdr s) (- 1 (string-length s))))))]\n      \
    \                             [(char? #\\A) (if (char? c) (reverse (string #\\\
    A)) (string c))]\n                                   [(char? #\\z) (if (char?\
    \ c) (reverse (string #\\z)) (string c))]\n                                  \
    \ [(char? #\\Z) (if (char? c) (reverse (string #\\Z)) (string c))]\n         \
    \                          [(char? #\\a) (if (char? c) (reverse (string #\\a))\
    \ (string c))]\n                                   [(char? #\\A) (if (char? c)\
    \ (reverse (string #\\A)) (string c))]\n                                   [(char?\
    \ #\\z) (if (char? c) (reverse (string #\\z)) (string c))]\n                 \
    \                  [(char? #\\Z) (if (char? c) (reverse (string #\\Z)) (string\
    \ c))]\n                                   [(char? #\\A) (if (char? c) (reverse\
    \ (string #\\a)) (string c))]\n                                   [(char? #\\\
    a) (if (char? c) (reverse (string #\\a)) (string c))]\n                      \
    \             [else (string-append (string c) (string #\\0))])))]\n    [else (map\
    \ (lambda (c) (cond [(or (char? c) (char? #\\A) (char? #\\z) (char? #\\Z)) (string-append\
    \ (string c) (string #\\0))]\n                                   [(char? #\\A)\
    \ (if (char? c) (string #\\A) (string c))]\n                                 \
    \  [(char? #\\z) (if (char? c) (string #\\z) (string c))]\n                  \
    \                 [(char? #\\Z) (if (char? c) (string #\\Z) (string c))]\n   \
    \                                [(char? #\\a) (if (char? c) (string #\\a) (string\
    \ c))]\n                                   [(char? #\\A) (if (char? c) (string\
    \ #\\A) (string c))]\n                                   [(char? #\\z) (if (char?\
    \ c) (string #\\z) (string c))]\n                                   [(char? #\\\
    Z) (if (char? ", "  (cond\n    [(empty? s) s]\n    [(is-letter? s) (letter-to-upper-or-lower-case?\
    \ (first s) (first s))]\n    [else (cons (first s) (solve (rest s))))]))\n", " \
    \ (let ((str (reverse s)))\n    (match str\n      [(empty? str) empty]\n     \
    \ [(not (alpha? (first str)))\n       (cons (first str) (solve (second str)))]\n\
    \      [else (cons (first str) (reverse (solve (second str))))]))\n</code>\n<code>",
  "  \n  (cond\n    [(empty? s) \"#\"]\n    [(char? (first s)) (cons (char->string\
    \ (toupper (first s)) (solve (rest s))))]\n    [else (cons (first s) (solve (rest\
    \ s)))]\n  )\n)\n", "  (cond [(empty? s) \"\"]\n        [(character? s) (switch-case\
    \ s)\n         ]\n        [else (switch-case (string s) (switch-case (string s)\
    \ #t (switch-case (string s) #t (switch-case (string s) #t (switch-case (string\
    \ s) #t (switch-case (string s) #t (switch-case (string s) #t (switch-case (string\
    \ s) #t (switch-case (string s) #t (switch-case (string s) #t (switch-case (string\
    \ s) #t (switch-case (string s) #t (switch-case (string s) #t (switch-case (string\
    \ s) #t (switch-case (string s) #t (switch-case (string s) #t (switch-case (string\
    \ s) #t (switch-case (string s) #t (switch-case (string s) #t (switch-case (string\
    \ s) #t (switch-case (string s) #t (switch-case (string s) #t (switch-case (string\
    \ s) #t (switch-case (string s) #t (switch-case (string s) #t (switch-case (string\
    \ s) #t (switch-case (string s) #t (switch-case (string s) #t (switch-case (string\
    \ s) #t (switch-case (string s) #t (switch-case (string s) #t (switch-case (string\
    \ s) #t (switch-case (string s) #t (switch-case (string s) #t (switch-case (string\
    \ s) #t (switch-case (string s) #t (switch-case (string s) #t (switch-case (string\
    \ s) #t (switch-case (string s) #t (switch-case (string s) #t (switch-case (string\
    \ s) #t (switch-case (string s) #t (switch-case (string s) #t (switch-case (string\
    \ s) #t (switch-case (string s) #t (switch-case (string s) #t (switch-case (string\
    \ s) #t (switch-case (string s) #t (switch-case (string s) #t (switch-case (string\
    \ s) #t (switch-case (string s) #t (switch-case (string s) #t (switch-case (string\
    \ s) #t (switch-case (string s) #t (switch-case (string s) #t (switch-case (string\
    \ s) #t (switch-case (string s) #t (switch-case (string s) #t (switch-case (string\
    \ s) #t (switch-case (string s) #t (switch-case (string s) ", "  (cond\n    [(empty?\
    \ s) \"0\"]\n    [(or (char-? (first s)) (char->integer first)) \n     (define\
    \ (char->integer c)\n       (cond\n         [(char->integer? (c)) c]\n       \
    \  [else (integer->char (char->integer c))]))\n     (reverse (map char->integer\
    \ s))]\n    [(and (char-? (first s)) \n          (char->integer first))\n    \
    \ (define (char->integer c)\n       (cond\n         [(char->integer? (c)) c]\n\
    \         [else (integer->char (char->integer c))]))\n     (reverse (map char->integer\
    \ s))]\n    [else s])) ;; # of solutions equals length of s\n</code>\nThe above\
    \ solution doesn't quite work. The following test cases are all okay but the following\
    \ one fails. I'm expecting \"#A@c\" to be the answer but instead I get \"#a@c\"\
    .\n<code>", "  (cond\n    [(empty? s) s]\n    [(or (char? first) (symbol? first))\
    \ s]\n    [else (define (letter? (car s))\n              (or (char? (cdr s)) (string-chars?\
    \ (cdr s))))\n       (define (case-letter? c)\n         (cond\n           [(char?\
    \ c) (string-upper (string-lower (car s)))]\n           [else (string-upper (car\
    \ s))]))\n       (define (case-letters-rest rest s)\n         (cond [(empty? rest)\
    \ (cons (reverse s) (reverse s))]\n               [(letter? c) (case-letter? c)\n\
    \                (case-letters-rest (cdr rest) (car s))]\n               [else\
    \ (reverse (cons (reverse c) (reverse rest)))]))\n       (define (case-letters\
    \ rest)\n         (cond [(empty? rest) (cons (reverse s) (reverse s))]\n     \
    \          [(letter? first) (case-letter? first)\n                (case-letters-rest\
    \ rest rest)]\n               [else (reverse (cons (reverse first) (reverse rest))))])\n\
    \      (reverse (case-letters (string->list (string->symbol s)))]))))\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nCan you explain the function a bit, especially the\
    \ \"let*\" part? It seems that all it does is take the first letter of the string\
    \ and uppercase it, so I assume the let block is for that? What is the purpose\
    \ of the \"reverse\" in the final block anyway? Thanks.\n<|/ c |>\n<| c |>\nThe\
    \ `let*` block is for splitting the string into a list of individual characters.\
    \ This is then used in the recursion function so that it can traverse the list\
    \ from the first character to the last, making each step of recursion go back\
    \ to the previous step rather than looping back around.\n<|/ c |>\n<| c |>\nIt's\
    \ really a matter of personal preference, I've just found using `let*` makes code\
    \ much more readable and easier to understand, and to help with debugging.\n<|/\
    \ c |>\n<| a |>\nIn Scheme, a function can return only a single value. \nIf you\
    \ want to return a list of values, you need to use an explicit list: \n<code>",
  "  (let loop ([s s])\n    (if (empty? s)\n        s\n        (let ((char (car s)))\n\
    \          (if (char-lower? char)\n              (loop (cdr s))\n            \
    \  (loop (cons (char-upper-case? char) s))))))))\n", "  (cond [(empty? s) \"\"\
    ]\n        [(letter? s (- i 1))\n         (let* ([new (string->list (string->upper\
    \ s))]\n                [old (string->list (string->lower s))])\n           (string-set!\
    \ s i (string->string new))\n           (string-set! s i (string->string old)))]\n\
    \        [else s]))\n", "  (if (string=? s \"#a@C\")\n      (cond [(string=? s\
    \ \"#A@c\") s]\n            [(string=? s \"#a@C\") (string->symbol (string->string\
    \ s))]\n            [(string=? s \"#A@C\") (string->string (string->symbol (string->string\
    \ s)))]\n            [else (cond [(string=? s \"#a@C\") (string->symbol (string->string\
    \ s))]\n                        [else (string->string (string->symbol (string->string\
    \ s)))]))\n      (cond [(string=? s \"ab\") (cond [(string=? s \"cAb\") (cond\
    \ [(string=? s \"BcA\") s]\n                                                 \
    \                  [(string=? s \"BaC\") (string->symbol (string->string s))]\n\
    \                                                                   [(string=?\
    \ s \"BAc\") (string->string (string->symbol (string->string s)))]\n         \
    \                                                          [else (cond [(string=?\
    \ s \"BaC\") (string->symbol (string->string s))]\n                          \
    \                                                 [(string=? s \"BcA\") (string->string\
    \ (string->symbol (string->string s)))]\n                                    \
    \                                       [else (cond [(string=? s \"BAc\") (string->symbol\
    \ (string->string s))]\n                                                     \
    \                              [(string=? s \"BcA\") (string->string (string->symbol\
    \ (string->string s)))]\n                                                    \
    \                               [else (cond [(string=? s \"BcA\") (string->symbol\
    \ (string->string s))]\n                                                     \
    \                                              [(string=? s \"BaC\") (string->string\
    \ (string->symbol (string->string s)))]\n                                    \
    \                                                               [else (string->string\
    \ (string->symbol (string->string s))))]))]\n                                \
    \    [else (cond [(string=? s \"cAb\") (cond [(string=? s \"BcA\") (string->symbol\
    \ (string->string s))]\n                                                     \
    \              [(string=? s \"BaC\") (string->string (string->symbol (string->string\
    \ s)))]\n                                                                   [else\
    \ (cond [(string=? s \"BaC\") (string->symbol (string->string s))]\n         \
    \                                                                  [(string=?\
    \ s \"BcA\") (string->string (string->symbol (string->string s)))]\n         \
    \                                                                  [else (cond\
    \ [(string=? s \"BcA\") (string->symbol (string->string s))]\n               \
    \                                                                    [(string=?\
    \ s \"BaC\") (string->string (string->symbol (string->string s)))]\n         \
    \                       ", "  (cond\n    [(empty? s) s]\n    [(member (first s)\
    \ (map char->string\n                      (cons (char->string\n             \
    \               (char->number (first s))\n                            (if (char->number\
    \ (rest s))\n                                (char->string (number->char (char->number\
    \ (rest s))))\n                                (char->string (number->char (char->number\
    \ (first s))))))))\n     (string-append (first (first s))\n                  \
    \  (cond\n                      [(string=? (rest s) (first (first s))) (cond\n\
    \                                                          [(char->number (first\
    \ s)) (first (first s))]\n                                                   \
    \       [(char->string (number->char (char->number (first s))))\n            \
    \                                               (cons (number->char (char->number\
    \ (first s))) (first (first s)))]\n                                          \
    \                [(char->string (number->char (char->number (rest s))))\n    \
    \                                                       (cons (number->char (char->number\
    \ (rest s))) (first (first s)))]\n                                           \
    \               [(char->number (rest s)) (first (first s))]\n                \
    \                                          [(char->string (number->char (char->number\
    \ (rest s))))\n                                                           (cons\
    \ (number->char (char->number (rest s))) (first (first s)))]\n               \
    \                                           [(char->string (number->char (char->number\
    \ (first s))))\n                                                           (cons\
    \ (number->char (char->number (first s))) (first (first s)))]\n              \
    \                                            [(char->number (first s)) (first\
    \ (first s))]\n                                                          [(char->string\
    \ (number->char (char->number (first s))))\n                                 \
    \                          (cons (number->char (char->number (first s))) (first\
    \ (first s)))]\n                                                          [(char->string\
    \ (number->char (char->number (rest s))))\n                                  \
    \                         (cons (number->char (char->number (rest s))) (first\
    \ (first s)))]\n                                                          [(char->number\
    \ (rest s)) (first (first s))]\n                                             \
    \             [(char->string (number->char (char->number (rest s))))\n       \
    \                                                    (cons (number->char (char->number\
    \ (rest s))) (first (first s)))]\n                                           \
    \               [(char->string (number->char (char->number (first s))))\n    \
    \                                                       (cons (number->char (char->number\
    \ (first s))) (first (first s)))]\n                                          \
    \                [(char->number (first s)) (first (first s))]\n              \
    \                                            [(char->string (number->char (char->number\
    \ (first s))))\n                                                           (cons\
    \ (number->char (char->number (first s))) (first (first s)))]\n              \
    \                                            [(char->string (number->char (char->number\
    \ (rest s))", "  (let ([r (reverse s)])\n    (cond\n      [(empty? r) \"\"]\n\
    \      [(char? r) (if (char-lower? (first r))\n                     (char-upper?\
    \ (first r))\n                     (concat \"#\" (first r)))]\n      [else (concat\
    \ r (char-lower? (first r)) (char-upper? (first r)))])))\n", "  (let loop ((res\
    \ \"\")\n             (ins \"\")\n             (s (string->list s)))\n    (cond\n\
    \      [(empty? s) res]\n      [(not (is-letter? (first s))) s]\n      [(= 0 (length\
    \ s))\n       (reverse (loop res (first s) (rest s)))]\n      [else (loop res\
    \ (first s) (append s (loop (reverse res) (ins (first s)))))]\n      )\n    )\n\
    \  )\n", "  (cond [(null? s)\n         (reverse s)]\n        [(or (char? (car\
    \ s))\n             (string=? (car s) \"#\"))\n         (string-reverse (solve\
    \ (cdr s))\n                        (+ (string=? (car s) \"#\") (string=? (car\
    \ s) \"@\")))]\n        [else (string=? (car s) \"#\")\n              (if (char=?\
    \ (car s) \"A\") (solve (cdr s))\n                  (string=? (car s) \"@\"))]\n\
    \        [else (string=? (car s) \"@\")\n              (if (char=? (car s) \"\
    a\") (solve (cdr s))\n                  (string=? (car s) \"#\"))]\n        [else\
    \ (string=? (car s) \"#\")\n              (if (char=? (car s) \"A\") (string=?\
    \ (car s) \"@\")\n                  (solve (cdr s)))]\n        [else (string=?\
    \ (car s) \"@\")\n              (if (char=? (car s) \"a\") (string=? (car s) \"\
    #\")\n                  (solve (cdr s)))]\n        [else (string=? (car s) \"\
    #\")\n              (if (char=? (car s) \"A\") (string=? (car s) \"#\")\n    \
    \              (string=? (car s) \"@\"))]\n        [else (string=? (car s) \"\
    @\")\n              (if (char=? (car s) \"a\") (string=? (car s) \"#\")\n    \
    \              (string=? (car s) \"@\"))]\n        [else (cons (car s) (solve\
    \ (cdr s)))]))\n</code>\n<|/ a tags=functional-programming,recursion,racket,scheme,string\
    \ dscore=2 |>\n<| c |>\nOh my! I think I missed the part in the problem description\
    \ that \"if the string contains no letters, reverse the string\". This will fail\
    \ for \"#a#\" which should be \"a#\". So the test should probably be `(string=?\
    \ (car s) \"#\")`.\n<|/ c |>\n<| c |>\nThank you for answering my question, I\
    \ edited the question and added the required example.\n<|/ c |>\n<| c |>\nI changed\
    \ the solution a bit to make it more readable. You can probably see why you needed\
    \ to do these things.\n<|/ c |>\n<| a |>\n<code>", "  (let ([result \"\"])\n \
    \   (loop\n       [s s]\n       (cond [(empty? s) result]\n             [else\
    \ \n               (let* ([letter (car s)]\n                      [uppercase-letter\
    \ (char->upper-case letter)]\n                      [reverse-letter (if (equal?\
    \ (char->lower-case letter) uppercase-letter)\n                              \
    \             uppercase-letter\n                                           lowercase-letter)\n\
    \                      [result (append result (reverse reverse-letter))]\n   \
    \                   )\n                 (recur (cdr s) \n                    \
    \     (if (= letter #\\a) (append result reverse-letter)\n                   \
    \          (if (equal? (char->lower-case letter) #\\A)\n                     \
    \            (append result (append reverse-letter letter))\n                \
    \                 (append result letter))))]))))\n", "  (cond\n    [(empty? s)\
    \ s]\n    [(equal? (first s) (first (first (reverse s))))\n     (cons (first s)\
    \ (solve (rest s)))]\n    [else (cons (first s) (solve (rest s)))]))\n</code>\n\
    <|/ a |>\n<| a tags=scheme,racket dscore=0 |>\nI wanted to write a recursive function\
    \ and this is what worked for me.\n<code>", "  (let ((helper (lambda (x)\n   \
    \                 (let ((letter (char->integer x)))\n                      (cond\
    \ ((< letter 97) (+ letter (- 97 letter)))\n                            (else\
    \ (+ letter 65)))))))\n    (cond\n      [(empty? s) s]\n      [(number? (first\
    \ s)) (helper first (rest s))]\n      [else (let ([result (substring s 0 (- (length\
    \ s) 1))])\n              (append (map (helper first) (rest s)) result))])))\n\
    </code>\n<|/ a dscore=0 |>\n<| a |>\nThis is a simple code \n<code>", "  (if (empty?\
    \ s)\n      (list)\n      (let ((c (first s))\n            (result (solve (rest\
    \ s))))\n        (cond\n          [(char=? c #\\a) (append result (list (char-upcase\
    \ c)))]\n          [(char=? c #\\z) (append result (list (char-downcase c)))]\n\
    \          [(char=? c #\\A) (append result (list (char-upcase c)))]\n        \
    \  [(char=? c #\\Z) (append result (list (char-downcase c)))]\n          [(char=?\
    \ c #\\c) (append result (list (char-downcase c)))]\n          [(char=? c #\\\
    d) (append result (list (char-reverse c)))]\n          [(char=? c #\\e) (append\
    \ result (list (char-reverse c)))]\n          [(char=? c #\\g) (append result\
    \ (list (char-reverse c)))]\n          [(char=? c #\\h) (append result (list (char-reverse\
    \ c)))]\n          [(char=? c #\\i) (append result (list (char-reverse c)))]\n\
    \          [(char=? c #\\k) (append result (list (char-reverse c)))]\n       \
    \   [(char=? c #\\n) (append result (list (char-reverse c)))]\n          [(char=?\
    \ c #\\o) (append result (list (char-reverse c)))]\n          [(char=? c #\\p)\
    \ (append result (list (char-reverse c)))]\n          [(char=? c #\\q) (append\
    \ result (list (char-reverse c)))]\n          [(char=? c #\\s) (append result\
    \ (list (char-reverse c)))]\n          [(char=? c #\\t) (append result (list (char-reverse\
    \ c)))]\n          [(char=? c #\\v) (append result (list (char-reverse c)))]\n\
    \          [(char=? c #\\x) (append result (list (char-reverse c)))]\n       \
    \   [(char=? c #\\y) (append result (list (char-reverse c)))]\n          [(char=?\
    \ c #\\z) (append result (list (char-reverse c)))]\n          [(char=? c #\\1)\
    \ (append result (list (char-reverse c)))]\n          [(char=? c #\\2) (append\
    \ result (list (char-reverse c)))]\n          [(char=? c ", "  (reverse-case s)\n\
    )\n", "  (cond\n    ((empty? s) (empty-string)\n     (string->list s))\n    ((char?\
    \ first) (list first (solve-case rest))\n     (list first (reverse-cases (solve-case\
    \ rest))))\n    ((string->chars (solve-char rest)) (reverse-cases (solve-char\
    \ rest)))\n    ((char->string (solve-char rest)) (reverse-cases (solve-char rest)))\n\
    \    ((string->list (solve-string rest)) (reverse-cases (solve-string rest)))\n\
    \    ((list->string (solve-list rest)) (reverse-cases (solve-list rest)))\n  \
    \  (else (error \"Unknown datatype.\"))))\n", "  (let ((x (length s))\n      \
    \  (y (length s)))\n    (cond\n      [(eq? (char-ref s 0) (char-ref x 0))\n  \
    \     (string->list s)\n       (if (eq? (char-ref s 0) (char-ref y 0))\n     \
    \      (string->list s)\n           (set! s (string->list (string->list s))))\n\
    \       (return (apply append (apply reverse (string->list (string->list s)))))]\n\
    \      [(char-ref s 0) (return (char-ref s 0))]\n      [(char-ref s 0) (set! s\
    \ (string->list (string->list s)))]\n      [else (if (eq? (char-ref s 0) (char-ref\
    \ x 0))\n                (set! x (- x 1))\n                (set! y (- y 1))\n\
    \                (set! s (string->list (string->list s))))\n              (set!\
    \ x (- x 1))\n              (set! y (- y 1))\n              (set! s (string->list\
    \ (string->list s))))]\n      [else (set! x (- x 1))]\n      [else (set! y (-\
    \ y 1))]\n      [else (set! s (string->list (string->list s))))]\n      (else\
    \ (set! x (- x 1))]\n      (else (set! y (- y 1))]\n      (else (set! s (string->list\
    \ (string->list s))))]))\n", "  (cond\n    [(empty? s)\n     (reverse s)]\n  \
    \  [else\n     (let ((first (first s)))\n       (cond\n         [(char-lower?\
    \ (first s)) (letter-to-upper (first s)) (reverse (letter-to-upper (first s)))\
    \ ]\n         [(char-upper? (first s)) (letter-to-lower (first s)) (reverse (letter-to-lower\
    \ (first s))) ]\n         [else (letter-to-upper (first s)) (reverse (letter-to-upper\
    \ (first s))) ]\n       )\n     )\n    ]))\n", "  (cond (empty? s) (empty? s)\n\
    \        (char-or-digit? (car s))\n        (else (cond (char-or-digit? (car s))\
    \ (solve (reverse s)))\n              (char? s)\n              (else (cons (car\
    \ s) (solve (reverse s)))))))\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThank you\
    \ for your answer, the problem is that my code must return \"#A@c\" because \"\
    a@c\" is a valid string\n<|/ c |>\n<| c |>\nThis does not meet the requirement\
    \ in the question \"If the string contains no letters, reverse the string.\"\n\
    <|/ c |>\n<| a dscore=1 tags=scheme,racket,string |>\n<code>", "  (if (string?\
    \ s)\n      (let ((result (if (char? s)\n                        (apply string->list\
    \ s)\n                        s))\n            (found (set! found #f)))\n    \
    \    (if (char? s)\n            (cond\n              [(or (char->digit (first\
    \ s)) (char->digit (first result)))\n               (apply (lambda (l)\n     \
    \                   (let ((l1 (char->digit l)))\n                          (if\
    \ (char->digit l)\n                              (let ((l2 (char->digit (first\
    \ result))))\n                                (cond [(< l1 l2)\n             \
    \                            (string-append (l (string-length l) l2))]\n     \
    \                                 [(> l1 l2)\n                               \
    \          (string-append (l (string-length l) l1))]\n                       \
    \               [(= l1 l2)\n                                         (string-append\
    \ (first l) (first result))]))\n                          (cond [(< l1 l2)\n \
    \                                 (string-append (first l) (first result))\n \
    \                                 (> l1 l2)\n                                \
    \  (string-append (l (- 1) (- 1) result))])\n                          [(> l1\
    \ l2)\n                                  (string-append (first l) (first result))\n\
    \                                  (< l1 l2)\n                               \
    \   (string-append (l (- 1) (- 1) result))])]\n              [found\n        \
    \       (cond [(or (char->digit (first s)) (char->digit (first result)))\n   \
    \                   (apply (lambda (l)\n                               (let ((l1\
    \ (char->digit l)))\n                                (if (char->digit l)\n   \
    \                                 (let ((l2 (char->digit (first result))))\n \
    \                                     (cond [(< l1 l2)\n                     \
    \                         (string-append (l (string-length l) l2))]\n        \
    \                                        [(> l1 l2)\n                        \
    \                         (string-append (l (string-length l) l1))]\n        \
    \                                        [(= l1 l2)\n                        \
    \                         (string-append (first l) (first result))]))\n      \
    \                              (cond [(< l1 l2)\n                            \
    \                 (string-append (first l) (first result))\n                 \
    \                            (> l1 l2)\n                                     \
    \        (string-append (l (- 1) (- 1) result))])\n                          \
    \          [(> l1 l2)\n                                             (string-append\
    \ (first l) (first result))\n                                             (< l1\
    \ l2)\n                                             (string-append (l (- 1) (-\
    \ 1) result))])]\n                                    [(= l1 l2)\n           \
    \                                  (string-append (first l) (first result))\n\
    \                                             (< l1 l", "  (cond [(empty? s) empty]\n\
    \        [(letter? (first s)) (cons \n                                (case (first\
    \ s)\n                                (\n                                (lower\
    \ (first s)) \n                                (upper (first s)))\n          \
    \                      (lower (first s))\n                                (upper\
    \ (first s)))\n                                (upper (first s)) (first s))]\n\
    \        [else (cons (first s)\n                    (solve (rest s)))]))\n", " \
    \ (cond\n    [(empty? s) s]\n    [(letter? (car s)) \n     (cond\n       [(uppercase?\
    \ (car s)) (swapcase? (car s) uppercase?)\n        (lowercase? (car s)) (swapcase?\
    \ (car s) lowercase?)\n        (else? ()) (car s)]\n       [else (swapcase? (car\
    \ s) uppercase?)]))\n     (reverse (solve (rest (reverse s)))]\n    [else (swapcase?\
    \ (car s) uppercase?)]))\n  ;; #lang racket\n  (display (solve (toupper s (string->list\
    \ s))))\n  ;; #lang racket\n  (reverse (display (solve (tolower s (string->list\
    \ s)))))\n  ;; #lang racket\n  (display (solve (toupper s (string->list s))))\n\
    \  ;; #lang racket\n  (reverse (display (solve (tolower s (string->list s)))))\n\
    \  ;; #lang racket\n  (display (solve (toupper s (string->list s))))\n  ;; #lang\
    \ racket\n  (reverse (display (solve (tolower s (string->list s)))))\n  ;; #lang\
    \ racket\n  (display (solve (toupper s (string->list s))))\n  ;; #lang racket\n\
    \  (reverse (display (solve (tolower s (string->list s)))))\n  ;; #lang racket\n\
    \  (display (solve (toupper s (string->list s))))\n  ;; #lang racket\n  (reverse\
    \ (display (solve (tolower s (string->list s)))))\n  ;; #lang racket\n  (display\
    \ (solve (toupper s (string->list s))))\n  ;; #lang racket\n  (reverse (display\
    \ (solve (tolower s (string->list s)))))\n  ;; #lang racket\n  (display (solve\
    \ (toupper s (string->list s))))\n  ;; #lang racket\n  (reverse (display (solve\
    \ (tolower s (string->list s)))))\n  ;; #lang racket\n  (display (solve (toupper\
    \ s (string->list s))))\n  ;; #lang racket\n  (reverse (display (solve (tolower\
    \ s (string->list s)))))\n  ;; #lang racket\n  (display (solve (toupper s (string",
  "  (cond\n    [(empty? s) \"\"]\n    [(char s (char i c)) (cond \n             \
    \           [((char->integer c) > 65 (char->integer c)) (concat s (char->integer\
    \ c))]\n                        [else (concat s (char->integer c))])]\n    [else\
    \ (concat s s)])\n  )\n)\n</code>\n<|/ a tags=scheme,racket,recursion |>\n<| a\
    \ dscore=1 tags=scheme,racket,recursion |>\nThis was a problem I thought about\
    \ and I wrote this recursive solution. It is not particularly elegant, and I doubt\
    \ there is a better way to do it, but it should work:\n<code>", "  (cond \n  \
    \  [(empty? s) s]\n    [(char s (char->integer (char->string s))) \n      (char->string\
    \ (integer->char (char->integer (char->string s))))\n      (if (char->integer\
    \ (char->string s))\n          (solve (char->string s))\n          (char->string\
    \ s))]\n    [else \n      (solve (char->string s))]))\n", "  (if (= s \"\")\n\
    \      \"\"\n      (let loop ((res '())\n                   (i (0))\n        \
    \           (len (length s)))\n        (if (char=? (substring s i (i+1))\n   \
    \                'a)\n            (loop (append (reverse (substring s i (i+1)))\
    \ res) (incf i) len)\n            (loop (cons (substring s i (i+1)) res) (incf\
    \ i) len)))))\n</code>\nThe code has some mistakes. You cannot write it by yourself,\
    \ because it's not easy. There are many ways to write this. The easiest way is\
    \ to use DrRacket. Just write\n<code>\n#lang racket\n", "  (cond\n    ((null?\
    \ s) s)\n    ((char? #\\a) (char->string (char->lower #\\A)))\n    ((char? #\\\
    z) (char->string (char->upper #\\A)))\n    ((char? #\\A) (char->string (char->lower\
    \ #\\z)))\n    ((char? #\\Z) (char->string (char->upper #\\z)))\n    (else (set!\
    \ s (string->char s #\\A))))\n  (cond\n    ((not (empty? s)) (list->string (map\
    \ solve (map char->string s))))\n    (else (set! s (string->char s #\\z))))\n\
    \  (cond\n    ((string->char (string->list s) #\\a) (list->string s))\n    (else\
    \ (string->char (string->list s) #\\z))))\n", "  (if (empty? s)\n      '()\n \
    \     (if (char? (car s))\n          (let ((char-lower (char->lower (car s))))\n\
    \            (if (char-lower? char-lower)\n                (cons (char->upper\
    \ (car s)) (cons (char->lower (car s)) solve))\n                (cons (char->lower\
    \ (car s)) (cons (char->upper (car s)) solve)))))\n      (cons (car s) (solve\
    \ (cdr s)))))\n", "  (let ([temp (reverse s)])\n    (cond\n      [(string? (car\
    \ temp)) (cdr temp)]\n      [(not (or (string? temp) (null? temp)))\n      (append\
    \ (map (lambda (s) (if (char=? (car s) #\\a)\n                               \
    \ (char-upper-case(car s))\n                                (char-lower-case(car\
    \ s))))\n                 (solve temp))]\n      [else temp]\n    ))))\n</code>\n\
    <|/ a tags=string,common-lisp,lisp |>\n<| c |>\nI'm curious what advantage this\
    \ has over `defun` or `labels`, or why this should be preferred over other answers.\n\
    <|/ c |>\n<| c |>\nThe advantage is that this solves the problem of how to apply\
    \ a function to elements of a list, not how to solve the general problem of reversing\
    \ a string.\n<|/ c |>\n<| c |>\nYou might want to explain how `(apply string '(\"\
    aaa\" \"bbb\")) ` evaluates to `\"Abba\"`.  I think it would be helpful.\n<|/\
    \ c |>\n<| c |>\n: It's not clear to me how you got the \"Abba\" output from the\
    \ `(apply string '(\"aaa\" \"bbb\"))` example.  Perhaps you meant `(apply string\
    \ '(\"aaa\" \"bbb\")) ;=> \"aBb\"`?\n<|/ c |>\n<| c |>\nI mean `(apply string\
    \ '(\"aaa\" \"bbb\"))` should return \"ABB\" and not \"aBb\".\n<|/ c |>\n<| a\
    \ dscore=5 |>\nIn Common Lisp, use defun to define functions that are not exported\
    \ and therefore can be called from any code where a function has been defined.\
    \  Defun defines a function that is available only in that code where it was defined.\
    \  It does this by defining a name that is only accessible within that code.\n\
    <code>", "  (let loop ((i 0) ((acc \"\")))\n    (if (= i (string-length s))\n\
    \        (reverse acc)\n        (loop (+ i 1) (cond [(number? s[i])\n        \
    \                      (if (< (char-code (car s)) (string-length s))\n       \
    \                           (loop (+ i 1) (to-upper (cadr s)) \"\")\n        \
    \                          (loop (+ i 1) (to-lower (cadr s)) \"\"))]\n       \
    \                      [(char? s[i]) \n                              (loop (+\
    \ i 1) (cadr s) (to-upper (cadr s) (to-lower (cadr s))) \"\")]\n             \
    \                [else \n                              (loop (+ i 1) (car s) (to-upper\
    \ (cadr s) (to-lower (cadr s))) \"\")])))))\n</code>\n<|/ a |>\n<| a dscore=1\
    \ |>\nHere is the complete solution\n<code>", "  (cond [(empty? s) (list s)] \n\
    \        [(char s (car s)) (char-case (car s)) (cdr s)] \n        [else (cons\
    \ (char-case (car s)) (solve (cdr s))))]))\n", "  (cond\n    [(empty? s) s]\n\
    \    [(letter? (first s)) (if (string->boolean (string-map tolower (first s)))\
    \ \n                           (string-map toupper (first s))\n              \
    \             (first s))]\n    [else (cons (first s) (solve (rest s)))]))\n  ",
  "  (cond [(null? s) \"\"]\n        [(character? (car s)) (reverse-case-letter (car\
    \ s))]\n        [else (reverse s)]))\n", "  (if (string? s)\n      (if (char?\
    \ (string-ref s 0))\n          (string-append (lower-case (substring s 0 1))\n\
    \                         (upper-case (substring s 1 1)))\n          (string-append\
    \ s (upper-case (substring s 0 1)))\n          (upper-case s))\n      (upper-case\
    \ s)))\n", "  (cond\n    [(empty? s) s]\n    [(char? (first s)) (string-reverse\
    \ (solve (rest (rest s))))]\n    [else (cons (first s) (solve (rest (rest s))))]\n\
    \  )\n)\n", "  (cond\n    [(empty? s) s]\n    [(list? (first s)) \n     (let ([char\
    \ (first s)])\n       (cond\n         [(char? (first s)) \n          (let ([cased-char\
    \ (char->cased-char (first s))])\n            (cond\n              [(char->cased-char\
    \ (first s)) \n               (reverse (solve (rest s)))]\n              [(char->cased-char\
    \ (first s)) \n               (reverse (solve (reverse (rest s))))]\n        \
    \      [(char->cased-char (first s)) \n               (reverse (solve (cons cased-char\
    \ (solve (rest s))))])\n              [(char->cased-char (first s)) \n       \
    \        (reverse (solve (cons (char->cased-char char) (solve (rest s)))))]\n\
    \              [(char->cased-char (first s)) \n               (reverse (solve\
    \ (cons (char->cased-char char) (cons (char->cased-char cased-char) (solve (rest\
    \ s)))))]\n              [(char->cased-char (first s)) \n               (reverse\
    \ (solve (cons (char->cased-char char) (cons (char->cased-char cased-char) (cons\
    \ (char->cased-char cased-char) (solve (rest s))))))])]\n              [(char->cased-char\
    \ (first s)) \n               (reverse (solve (cons (char->cased-char char) (cons\
    \ (char->cased-char cased-char) (cons (char->cased-char cased-char) (cons (char->cased-char\
    \ cased-char) (cons (char->cased-char cased-char) (solve (rest s))))))))]))]\n\
    \         [(char->cased-char (first s)) \n          (solve (cons (char->cased-char\
    \ char) (cons (char->cased-char cased-char) (solve (rest s)))))]\n         [(char->cased-char\
    \ (first s)) \n          (solve (cons (char->cased-char char) (cons (char->cased-char\
    \ cased-char) (cons (char->cased-char cased-char) (cons (char->cased-char cased-char)\
    \ (cons (char->cased-char cased-char) (cons (char->cased-char cased-char) (solve\
    \ (rest s)))))))]\n         [(char->cased-char (first s)) \n          (solve (cons\
    \ (char->cased-char char) (cons (char->", "  (cond\n    [(empty? s) (error \"\
    Please input a string\")]\n    [(eq? (first s) #\\a) (lower-case? (rest s))]\n\
    \    [else (upper-case? (rest s))]))\n", "  (cond \n    [(empty? s)  (append s\
    \ (reverse s))]\n    [(is-letter? (first s)) (\n      (let ([up (make-upper-case?\
    \ (first s))])\n        (cond (up (append (second s) (make-upper-case? (first\
    \ s))))\n              (up (append (second s) (make-lower-case? (first s)))))\n\
    \              [else (append s (make-lower-case? (first s)))]))]\n    [else (append\
    \ s (make-lower-case? (first s)))]))\n</code>\n<|/ a tags=racket,scheme |>\n<|\
    \ a |>\nHere is a more idiomatic solution that uses mapcar rather than a conditional\
    \ expression within a lambda expression:\n<code>", "  (cond (empty? s) \"\"\n\
    \        (char? (car s)) (cond ((char? (cdr s)) (upper (car s)) (lower (car s)))\n\
    \                              ((char? (cdr s)) (lower (car s)) (upper (car s)))\n\
    \                              (else (car s))))\n        (else (apply reverse\
    \ (map (fn [[a b]] (cond ((char? (a)) (lower (a)) (upper (a))) (else (a)))) s))))\n\
    )\n</code>\n<|/ a dscore=1 |>\n<| a dscore=0 tags=racket,scheme |>\nThe other\
    \ answers have a lot of useful insights. I wanted to add my own solution, which\
    \ is perhaps easier to understand and more straightforward.\n<code>", "  (cond\n\
    \    ((not (equal? s '()))\n     (string-reverse s))\n    ((char-ci=? (car s)\
    \ (first-char s))\n     (string-reverse (downcase-char s)))\n    ((char-ci=? (cdr\
    \ s) (first-char s))\n     (downcase-char (string-reverse (cdr s))))\n    (else\n\
    \     (string-reverse s))))\n", "  (let loop ((a s) (b '())) ; a is the current\
    \ char of s, b is the result char list\n    (if (empty? a) \n        (reverse\
    \ b)\n        (loop (cdr a) \n               (cons (char->integer (car a)) b))))\
    \ ; loop through and find the char. \n</code>\n<|/ a dscore=3 |>\n<| c |>\nYes.\
    \ I changed `char->integer (car a)` to `(char->integer c)` and it worked.\n<|/\
    \ c |>\n<| c |>\nI added the example in the answer.\n<|/ c |>\n<| c |>\nYou misspelled\
    \ the function: `char->integer` should be `char->integer?` https://gist.github.com/amandashik/0674456454096cf45557\n\
    <|/ c |>\n<| a tags=racket,scheme |>\n<code>", "  ; Only valid non-empty string\
    \ are accepted\n  (cond [(empty? s)\n         (string-append \"(no letters)\"\
    \ (string->list s))]\n        [(member (first s) (string-char-lower (first s)))\n\
    \         (string-append (list (string->list (first s)) (first s)) (second s))]\n\
    \        [else \n         (string-append (list (string->list (first s)) (first\
    \ s)) (second s))]))\n", "  (cond\n    ((null? s)  '())\n    ((char? s)  (string-reverse\
    \ (string-downcase (substring s 0 (length s)))))\n    (else (string-downcase s))))\n",
  "  (cond\n    [(empty? s)\n     (reverse-string (substring s \"0\"))]\n    [(character?\
    \ (char-code (first s)))\n     (cond\n       [(char-islower (char-code (first\
    \ s)))\n        (cond\n          [(not (char-isupper (char-code (first s)))) (substring\
    \ s \"0\")]\n          [(char-isupper (char-code (first s))) (substring s \"1\"\
    )]\n          [else (substring s \"2\")]\n          )] \n       [(char-isupper\
    \ (char-code (first s)))\n        (cond\n          [(not (char-islower (char-code\
    \ (first s)))) (substring s \"1\")]\n          [(char-islower (char-code (first\
    \ s))) (substring s \"2\")]\n          [else (substring s \"0\")]\n          )]\n\
    \       [else (substring s \"0\")]\n       )]\n    [else (substring s \"0\")]\n\
    \    ))\n", "  (cond\n    [(empty? s) empty]\n    [else\n     (let [ss (substring\
    \ s 0 (length s))]\n       (cond\n         [(char=? (first ss) ?a) (concat ? (substring\
    \ s (length ss) 2))]\n         [(char=? (first ss) ?A) (concat ? (substring s\
    \ (length ss) 2))]\n         [(char=? (first ss) ?b) (concat ? (substring s (length\
    \ ss) 1))]\n         [(char=? (first ss) ?B) (concat ? (substring s (length ss)\
    \ 1))]\n         [else (concat s? ss?)]))]))\n", "  (cond [(empty? s)\n      \
    \   (reverse s)]\n        [(equal? (char->integer first (first s)) ?A)\n     \
    \    (char->integer first (first s)) (solve\n                                \
    \       (substring (tail s) 1 \n                                             (-\
    \ 2 (length s)))\n                                       (rest s))]\n        [else\n\
    \         (char->integer first (first s)) (solve\n                           \
    \               (substring (tail s) 1 (- 2 (length s)))\n                    \
    \                      (rest s))]))\n</code>\n<|/ a |>\n<| a dscore=0 |>\n<code>",
  "  (cond\n    [(empty? s) \"\"]\n    [(char s (char-ref s 0) #\\A) (cons (char-ref\
    \ s 0) (solve (char-ref s 1)))]\n    [(char s (char-ref s 0) #\\a) (cons (char-ref\
    \ s 0) (solve (char-ref s 1)))]\n    [(char s (char-ref s 0) #\\b) (cons (char-ref\
    \ s 0) (solve (char-ref s 1)))]\n    [else (cons (char-ref s 0) (solve (char-ref\
    \ s 1)))]))\n", "  (cond\n    [(empty? s) \"\"]\n    [(= (first s) #\\A) (solve\
    \ (map upper s))]\n    [(or (char= (first s) #\\a) (char= (first s) #\\z)) (first\
    \ s)] \n    [else (first s)] \n  ))\n", "  (define (toUpper x)\n    (cond [(string=?\
    \ x \"A\")\n           \"a\"]\n          [(string=? x \"B\")\n           \"b\"\
    ]\n          [(string=? x \"C\")\n           \"c\"]\n          [(string=? x \"\
    D\")\n           \"d\"]\n          [(string=? x \"E\")\n           \"e\"]\n  \
    \        [(string=? x \"F\")\n           \"f\"]\n          [(string=? x \"G\"\
    )\n           \"g\"]\n          [(string=? x \"H\")\n           \"h\"]\n     \
    \     [(string=? x \"I\")\n           \"i\"]\n          [(string=? x \"J\")\n\
    \           \"j\"]\n          [(string=? x \"K\")\n           \"k\"]\n       \
    \   [(string=? x \"L\")\n           \"l\"]\n          [(string=? x \"M\")\n  \
    \         \"m\"]\n          [(string=? x \"N\")\n           \"n\"]\n         \
    \ [(string=? x \"O\")\n           \"o\"]\n          [(string=? x \"P\")\n    \
    \       \"p\"]\n          [(string=? x \"Q\")\n           \"q\"]\n          [(string=?\
    \ x \"R\")\n           \"r\"]\n          [(string=? x \"S\")\n           \"s\"\
    ]\n          [(string=? x \"T\")\n           \"t\"]\n          [(string=? x \"\
    U\")\n           \"u\"]\n          [(string=? x \"V\")\n           \"v\"]\n  \
    \        [(string=? x \"W\")\n           \"w\"]\n          [(string=? x \"X\"\
    )\n           \"x\"]\n          [(string=? x \"Y\")\n           \"y\"]\n     \
    \     [(string=? x \"Z\")\n           \"z\"]\n          [else x]))\n  (define\
    \ (toLower x)\n    (cond [(string=? x \"a\")\n           \"A\"]\n          [(string=?\
    \ x \"b\")\n           \"B\"]\n          [(string=? x \"c\")\n           \"C\"\
    ]\n          [(string=? x \"d\")\n           \"D\"]\n          [(string=? x \"\
    e\")\n           \"E\"]\n          [(string=? x \"f\")\n           \"F\"]\n  \
    \        [(string=? x \"g\")\n           \"G\"]\n          [(string=? x \"h\"\
    )\n           \"H\"]\n          [(string=? x \"i\")\n           \"I\"]\n     \
    \     ", "  (cond [(empty? s) empty]\n        [(eq? (first s) (string-ref s 0))\
    \ (reverse (solve (drop 1 s)))]\n        [else (cons (string-ref s 0) (solve (drop\
    \ 1 s)))]))\n", "  (cond\n    [(empty? s) s]\n    [(member (first s) (list->string\
    \ '(#\\A #\\b #\\C))) (string-lower (string-upcase (first s))) \n     (solve (rest\
    \ s))]\n    [else (string-downcase (first s))]))\n", "  (define (helper-loop s\
    \ i)\n    (cond ((char=? (char-code (substring s i (char-code (car s)) )) #\\\
    A) (cons (char->string\n                                                     \
    \           (char-upcase (car s)) (reverse (reverse (char-downcase (car s))))\
    \ \n                                                                (helper-loop\
    \ (cdr s) (+ i 1))))\n          ((char=? (char-code (substring s i (char-code\
    \ (car s)) )) #\\z) (cons (char->string\n                                    \
    \                                (char-downcase (car s)) (reverse (reverse (char-upcase\
    \ (car s)))) \n                                                              \
    \      (helper-loop (cdr s) (+ i 1))))\n          ((char=? (char-code (substring\
    \ s i (char-code (car s)) )) #\\Z) (cons (char->string\n                     \
    \                                               (char-downcase (car s)) (reverse\
    \ (reverse (char-downcase (car s)))) \n                                      \
    \                              (helper-loop (cdr s) (+ i 1))))\n          (else\
    \ (cons (char->string (substring s i i)) (helper-loop (cdr s) (+ i 1))))))\n \
    \ (helper-loop s '(0)))\n", "  ; Write your solution here\n)\n", "  (cond [(empty?\
    \ s) s]\n        [(letter? (first s)) (let* ([s (string->lower (first s))]\n \
    \                                [result (if (letter? (first s)) (string->lower\
    \ (first s)) (first s))])\n                           (cond [(letter? (first s))\
    \ (cons result (string->upercase (first s)))]\n                              \
    \   [else (cons (first s) result))])]\n        [else (cons (first s)\n       \
    \             (solve (rest s))]))))\n", "  (cond\n    [(empty? s) s]\n    [(character?\
    \ s)\n     (cond\n       [(character? (string->list s)) (string->list (case (solve\
    \ (string->list s)))) ]\n       [else (cons (char->list (string->list s)) (solve\
    \ (string->list s))) ]\n     )]\n    [else (cons (char->list (string->list s))\
    \ (solve (string->list s))) ]\n  )\n)\n</code>\n<|/ a |>\n<| a dscore=1 tags=racket,scheme\
    \ |>\nHere is a solution:\n<code>", "  (if (string-length (remove-chars s #\\\
    Space)) (substring s (string-length (remove-chars s #\\Space))) (substring s 0\
    \ (string-length (remove-chars s #\\Space)))))\n", "  (cond\n    ((empty? s) s)\n\
    \    ((char? s)\n     (cond\n       ((char=? #\\a #\\A)\n        (cond\n     \
    \     ((char=? (char-upcase s) #\\A)\n           (char=? (char-lowcase s) #\\\
    a))\n          ((char=? (char-lowcase s) #\\A)\n           (char=? (char-upcase\
    \ s) #\\a))))\n       ((char=? #\\A #\\a)\n        (cond\n          ((char=? (char-upcase\
    \ s) #\\A)\n           (char=? (char-lowcase s) #\\a))\n          ((char=? (char-lowcase\
    \ s) #\\A)\n           (char=? (char-upcase s) #\\a))))\n       ((char=? #\\a\
    \ #\\A)\n        (cond\n          ((char=? (char-upcase s) #\\A)\n           (char=?\
    \ (char-lowcase s) #\\a))\n          ((char=? (char-lowcase s) #\\A)\n       \
    \    (char=? (char-upcase s) #\\a))))\n       ((char=? #\\A #\\a)\n        (cond\n\
    \          ((char=? (char-upcase s) #\\A)\n           (char=? (char-lowcase s)\
    \ #\\a))\n          ((char=? (char-lowcase s) #\\A)\n           (char=? (char-upcase\
    \ s) #\\a))))\n       ((char=? #\\a #\\a)\n        (cond\n          ((char=? (char-upcase\
    \ s) #\\A)\n           (char=? (char-lowcase s) #\\a))\n          ((char=? (char-lowcase\
    \ s) #\\A)\n           (char=? (char-upcase s) #\\a))))\n       ((char=? #\\A\
    \ #\\A)\n        (cond\n          ((char=? (char-upcase s) #\\A)\n           (char=?\
    \ (char-lowcase s) #\\a))\n          ((char=? (char-lowcase s) #\\A)\n       \
    \    (char=? (char-upcase s) #\\a))))\n       ((char=? #\\a #\\A)\n        (cond\n\
    \          ((char=? (char-upcase s) #\\A)\n           (char=? (char-lowcase s)\
    \ #\\a))\n          ((char=? (char-lowcase s) #\\A)\n           (char=? (char-upcase\
    \ s) #\\a))))\n       ((char=? #\\A #\\a)\n        (cond\n          ((char=? (char-upcase\
    \ s) #\\A)\n           (char", "  (if (string=? s \"\")\n      (list)\n      (let\
    \ ((str (reverse (string s)))\n            (res\n             (cond ((char=? s\
    \ #\\a) (list (char->upper (first str)) (rest str)))\n                   ((char=?\
    \ s #\\z) (list (char->lower (first str)) (rest str)))\n                   ((char=?\
    \ s #\\A) (list (char->upper (first str)) (rest str)))\n                   ((char=?\
    \ s #\\Z) (list (char->lower (first str)) (rest str))))))\n    (reverse res)))\n",
  "  (cond\n    [(empty? s) s]\n    [(equal? (first s) (first s)) (cons (first (reverse\
    \ (second s))) \n                                    (solve (rest (rest s)))]\n\
    \    [else (cons (first s) (solve (rest (rest s))))]))\n</code>\n<|/ a tags=racket,scheme\
    \ |>\n<| c |>\nCan you comment your code and explain how it solves the question?\n\
    <|/ c |>\n<| c |>\nYes, my code reverses the case of the letters in any given\
    \ string. `solve` calls `cond` which handles all 3 cases. I hope this is helpful\
    \ to you. :)\n<|/ c |>\n<| c |>\n\"A procedure of case-conversion\nA procedure\
    \ of reversing-letters-of-a-string\nA procedure of solving a problem recursively\"\
    \ - I guess it's better to split this into three different procedures. One for\
    \ reversing case, one for case-conversion, and finally one for solving a problem\
    \ recursively.\n<|/ c |>\n<| c |>\nIt could be even better.\n<|/ c |>\n<| a |>\n\
    I did it like this:\n<code>", "  (define (loop i)\n    (cond\n      [(empty? s)\
    \ s]\n      [(char-? (car s)) (loop (reverse i))]\n      [else (loop (reverse\
    \ i))]))\n  (loop 0))\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis solution has\
    \ problems when there are two or more or more consecutive capital letters. The\
    \ function returns `#<procedure:loop>` instead of the string of the reversed string.\n\
    <|/ c |>\n<| a dscore=1 |>\nHere is my solution :\n<code>", "  (cond ( (empty?\
    \ s) s) \n        ( (string? (first s)) \n          (cond  \n            ((char->integer\
    \ (first s)) \n              (string->list (reverse (reverse-case (first s)))))\n\
    \            (else (first s))) \n        (else (cons (first s) (solve (rest s))))\
    \ ))) \n", "  (cond ((null? s)\n         (reverse s))\n        (else \n      \
    \   (cond ((char-? (car s))\n                (cons (char-upcase (car s)) \n  \
    \                    (solve (cdr s))))\n               ((char-? (car s))\n   \
    \             (cons (char-downcase (car s)) \n                      (solve (cdr\
    \ s))))\n               (else \n                (cons (car s) \n             \
    \         (solve (cdr s)))))))) \n</code>\n<|/ a dscore=1 |>\n<| a tags=scheme\
    \ dscore=1 |>\nHere is one solution. Hope it helps.\n<code>\n#lang racket\n",
  "  (cond [(null? s)\n         '()]\n        [(= (char-ascii (car s)) (char-ascii\
    \ (char-code (char-downcase (car s)))))\n         (cons (char-downcase (car s))\
    \ (solve (char-downcase (cdr s))))]\n        [else\n         (cons (char-downcase\
    \ (car s)) (solve (char-upcase (cdr s))))]))\n", "  (let loop ((s (string->list\
    \ s))\n             (r (string->list (string->string s))))\n    (if (null? s)\n\
    \        r\n        (let ((c (char->integer (first s))))\n          (if (or (<\
    \ c 97) (> c 122)) (loop (rest s) (rest r)) \n            (loop (rest s) (rest\
    \ r)))))\n    ))\n</code>\n<|/ a tags=racket,scheme |>\n<| c |>\nI like it, but\
    \ there's a mistake in the last line. (rest r)) should be (rest r)).  Otherwise,\
    \ it works for me.\n<|/ c |>\n<| c |>\n, you're right, thanks. I'm new to Racket\
    \ and I wasn't familiar with the `(let ((name (expression))) ...)` syntax. I've\
    \ updated the answer to reflect this.\n<|/ c |>\n<| a |>\n<code>", "  (if (null?\
    \ s)\n      s\n      (let ((l (char->integer (first s))))\n        (if (< l 26)\n\
    \            (if (char->integer (second s))\n                (cons (char->integer\
    \ (char-code (first s))) (solve (substring (second s) 1)))\n                (cons\
    \ (char->integer (char-code (first s))) (string->number (substring (second s)\
    \ 1))))\n            (cons (char->integer (char-code (first s))) (solve (substring\
    \ (second s) 1)))))))\n#lang racket\n", "  (cond\n    [(empty? s) s]\n    [else\
    \ (cond \n              [(char-? (car s)) (reverse-case-string (solve (cdr s)))]\n\
    \              [(not (char-? (car s))) (string (car s) (solve(cdr s))) ])))\n",
  "  (cond\n    ((empty? s) s)\n    ((char? (car s)) (solve (reverse s)))\n    (else\
    \ (cons (char->string (toupper (car s)) (solve (reverse (reverse s))))))))\n",
  "  (cond [(empty? s) s]\n        [(not(char? (car s))) (solve (reverse s))]\n  \
    \      [(char? (car s)) (cond\n                           [(char? (cadr s)) (cons\
    \ (car s) (solve (reverse (cddr s))))]\n                           [else (cons\
    \ (car s) (solve (cadr s))))]\n        )]))\n", "  (cond [(empty? s) s]\n    \
    \    [(letter? s) (substring s\n                              (make-string (string-length\
    \ s)\n                                       [char-downcase (first s)\n      \
    \                                  char-upcase (second s)]))]\n        [else (substring\
    \ s\n                      (make-string (string-length s)\n                  \
    \             [char-downcase (first s)\n                                char-upcase\
    \ (second s)]))]))\n", "  (cond [(string? s)\n         (string-reverse (replace-chars\
    \ s \"a\" \"A\") (replace-chars s \"b\" \"B\") (replace-chars s \"c\" \"C\"))]\n\
    \        [else\n         (replace-chars s \"a\" \"A\") (replace-chars s \"b\"\
    \ \"B\") (replace-chars s \"c\" \"C\")]))\n", "  (string-map #(lambda (c) (if\
    \ (char-or-not c) \n                       (if (char-or-not (char-case? c)) \n\
    \                           (char-upper-or-lower (char-lower-or-upper (char-or-not\
    \ c)))\n                           (char-lower-or-upper (char-or-not c))))\n \
    \             (substring s 0 (string-length s))))\n", "  (cond\n    [(empty? s)\
    \ s]\n    [(member? (char-upper-case) s) (char-upper-case (solve (char-down-case)\
    \ s))]\n    [else (solve (char-down-case) s)]))\n", "  (cond\n    [(empty? s)\
    \ s]\n    [(or (char=? (first s) #\\A)\n         (char=? (first s) #\\z)\n   \
    \      (char=? (first s) #\\A)\n         (char=? (first s) #\\z)\n         (char=?\
    \ (first s) #\\A #\\z)\n         (char=? (first s) #\\A #\\z)\n         (char=?\
    \ (first s) #\\A #\\z #\\z)\n         (char=? (first s) #\\A #\\z #\\z #\\z)\n\
    \         (char=? (first s) #\\A #\\z #\\z #\\z #\\z)) (solve (reverse (solve\
    \ (reverse s)))]\n    [else (first s) (solve (rest s))]))\n", "  (cond\n    [(empty?\
    \ s) s]\n    [(number? s) (number->string s)]\n    [(char? (car s)) (append (map\
    \ (lambda (c) (if (char? (car s)) \n                                         \
    \           (char->string c) (concat \"\" (char->string c)))\n               \
    \                                (cdr s))\n                            (list (car\
    \ s))))]\n    [else (cond\n            [(or (char->number (first s)) (char->string\
    \ (first s))) (cond\n                  [(char->number (first s)) (number->string\
    \ (first s))]\n                  [(char->string (first s)) (number->string (first\
    \ s))])]\n            [else (append (map (lambda (c) (if (char? (car s)) \n  \
    \                                            (char->string c) (concat \"\" (char->string\
    \ c)))\n                                    (cdr s))\n                       \
    \   (list (car s)))]))]))\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThe question asked\
    \ for a solution without mutating anything, which this does not.  It's just mapping\
    \ each character to its inverse.\n<|/ c |>\n<| a |>\n<code>", "  (cond\n    [(empty?\
    \ s) s]\n    [else (cond\n\t    [(char->integer (first s)) (solve (first s))]\n\
    \t    [(char->integer (first s)) (solve (make-string (length (first s) 2) (char->integer\
    \ (first s))))\n\t     (char->integer (first s)) (solve (make-string (length (first\
    \ s) 2) (char->integer (first s)) \n\t      (char->integer (first s))))]\n\t \
    \   [(char->integer (first s)) (string-append (solve (make-string (length (first\
    \ s) 2) (second s))\n\t      (first (reverse (second s))))) (string-append (solve\
    \ (make-string (length (first s) 2) (first (reverse (second s))))\n\t      (second)\n\
    \t      (first s))]]\n    [else (cond (char->integer (first s)) (solve (make-string\
    \ (length (first s) 2) (first s)\n\t      (second s))))]\n    [else (cond (char->integer\
    \ (first s)) (string-append (solve (make-string (length (first s) 2) (first s))\n\
    \t      (second s))\n\t      (string-append (solve (make-string (length (first\
    \ s) 2) (second s)) (first (reverse (first s))))\n\t      (second)\n\t      (first\
    \ s))))]\n    [else (string-append (solve (make-string (length (first s) 2) (first\
    \ s))\n\t      (second)\n\t      (second s))\n\t      (string-append (solve (make-string\
    \ (length (first s) 2) (first s))\n\t      (second s)) (first (reverse (first\
    \ s))))\n\t      (first s))])))\n", "  (cond (empty? s) s\n        (string-equal?\
    \ (char->integer (first (substring s 0 1)))\n                      (char->integer\
    \ (first (substring s (1- (length s) 0)))\n                      (+ (char->integer\
    \ (first (substring s 0 1))) \n                          (char->integer (first\
    \ (substring s (1- (length s) 0)))) \n                          (if (even? (string-length\
    \ (substring s 0 (1- (length s) 0))))\n                              (* 2 (char->integer\
    \ (first (substring s (1- (length s) 0)))))\n                              (*\
    \ 2 (char->integer (first (substring s 0 (1- (length s) 0))))))\n            \
    \          (string-equal? (char->integer (first (substring s 0 (1- (length s)\
    \ 0))))\n                      (char->integer (first (substring s (1- (length\
    \ s) 0)))\n                      (+ (char->integer (first (substring s 0 (1- (length\
    \ s) 0))))\n                          (char->integer (first (substring s (1- (length\
    \ s) 0)))) \n                          (if (even? (string-length (substring s\
    \ 0 (1- (length s) 0))))\n                              (* 2 (char->integer (first\
    \ (substring s (1- (length s) 0)))))\n                              (* 2 (char->integer\
    \ (first (substring s 0 (1- (length s) 0))))))\n                      (string-equal?\
    \ (char->integer (first (substring s 0 (1- (length s) 0)))\n                 \
    \     (char->integer (first (substring s (1- (length s) 0)))\n               \
    \       (+ (char->integer (first (substring s 0 (1- (length s) 0))))\n       \
    \                   (char->integer (first (substring s (1- (length s) 0)))) \n\
    \                          (if (even? (string-length (substring s 0 (1- (length\
    \ s) 0))))\n                              (* 2 (char->integer (first (substring\
    \ s (1- (length s) 0)))))\n                              (* 2 (char->integer (first\
    \ (substring s 0 (1- (length s) 0))))))\n                      (string-equal?\
    \ (char->integer (first (substring s 0 (1- (length s) 0))))\n                \
    \      (char->integer (first (substring s (1- (length s) 0)))\n              \
    \        (+ (char->integer (first (substring s 0 (1- (length s) 0))))\n      \
    \                    (char->integer (first (substring s (1- (length s) 0)))) \n\
    \                          (if (even? (string-length (substring s 0 (1- (length\
    \ s) 0))))\n                              (* 2 (char->integer", "  (if (empty?\
    \ s)\n      (append \"#\" \"\")\n      (let ((char (first s))\n            (new-s\
    \ (substring s 1 (string->length s))))\n        (cond\n          ((char=? (char-code\
    \ char) \"a\") (append (substring new-s (string-length new-s) #\\A)\n        \
    \                                                    (solve new-s)))\n       \
    \   ((char=? (char-code char) \"b\") (append (substring new-s (string-length new-s)\
    \ #\\B)\n                                                            (solve new-s)))\n\
    \          ((char=? (char-code char) \"c\") (append (substring new-s (string-length\
    \ new-s) #\\C)\n                                                            (solve\
    \ new-s)))\n          ((char=? (char-code char) \"d\") (append (substring new-s\
    \ (string-length new-s) #\\D)\n                                              \
    \              (solve new-s)))\n          ((char=? (char-code char) \"e\") (append\
    \ (substring new-s (string-length new-s) #\\E)\n                             \
    \                               (solve new-s)))\n          ((char=? (char-code\
    \ char) \"f\") (append (substring new-s (string-length new-s) #\\F)\n        \
    \                                                    (solve new-s)))\n       \
    \   ((char=? (char-code char) \"g\") (append (substring new-s (string-length new-s)\
    \ #\\G)\n                                                            (solve new-s)))\n\
    \          ((char=? (char-code char) \"h\") (append (substring new-s (string-length\
    \ new-s) #\\H)\n                                                            (solve\
    \ new-s)))\n          ((char=? (char-code char) \"i\") (append (substring new-s\
    \ (string-length new-s) #\\I)\n                                              \
    \              (solve new-s)))\n          ((char=? (char-code char) \"j\") (append\
    \ (substring new-s (string-length new-s) #\\J)\n                             \
    \                               (solve new-s)))\n          ((char=? (char-code\
    \ char) \"k\") (append (substring new-s (string-length new-s) #\\K)\n        \
    \                                                    (solve new-s)))\n       \
    \   ((char=? (char-code char) \"l\") (append (substring new-s (string-length new-s)\
    \ #\\L)\n                                                            (solve new-s)))\n\
    \          ((char=? (char-code char) \"m\") (append (substring new-s (string-length\
    \ new-s) #\\M)\n                                                            (solve\
    \ new-s)))\n          ((char=? (char-code char) \"n\") (append (substring new-s\
    \ (string-length new-s) #\\N)\n                                              \
    \              (solve new-s)))\n          ((char=? (char-code char) \"o", "  (cond\
    \ [(empty? s) \"\"]\n        [(digit? (car s)) (cons (digit (first s)) (solve\
    \ (rest s)))]\n        [(letter? (car s)) (cons (letter (first s)) (solve (rest\
    \ s)))]\n        [else (cons (car s) (solve (rest s)))]))\n", "  (cond\n    [(empty?\
    \ s) s]\n    [(cons? s) (solve (reverse s))]\n    [(cons? #\\A) (solve (reverse\
    \ (append #\\A (car s)))) ]\n    [(cons? #\\a) (solve (reverse (append #\\A (car\
    \ s)))) ]\n    [(cons? #\\Z) (solve (reverse (append #\\A (car s)))) ]\n    [else\
    \ s])\n  )", "  (define i 0)\n  (define j 0)\n  (define result '())\n  (loop\n\
    \    (if (null? s)\n      (reverse result)\n      (if (char=? (char s (+ i 1))\n\
    \              (char=? (char s (- j 1))\n                      #\\a\n        \
    \              #\\A))\n          (append result (char s (+ i 1))\n           \
    \       (char s (- j 1)))\n          (append result (char s (+ i 1)))\n      \
    \    (append result (char s (- j 1))))))\n  (printf \"%s\\n\" (convert result)))\n",
  "  (cond\n    [(empty? s) \"\"]\n    [(alpha? (first s)) (toUpper (reverse (toLower\
    \ s))]\n    [else (toLower s)]))\n", "  (cond\n    ((empty? s) s)\n    ((char?\
    \ (car s)) (case-fix (solve  (reverse s)) (car s)))\n    (else (cond ((char? (car\
    \ s)) (case-fix (solve  (reverse s)) (car s))) (else (cond ((char? (car s)) (solve\
    \  (reverse s)) (car s))))))))\n", "  (cond\n    [(empty? s)                 \
    \     s]\n    [(char? (car s))              (substring (toUpper s) 0 (- (length\
    \ s) 1))]\n    [else                         (substring s (- (length s) 1) (length\
    \ s))]\n  ))\n", "  (cond [(empty? s) \"\"]\n        [(list? (first s)) (cons\
    \ (solve (first s)) (solve (rest s)))]\n        [(character? (first s)) (if (string?\
    \ (second s)) (reverse (string s (string->list (first s))) (char->string (second\
    \ s)))]\n        [else (append (reverse (string s (string->list (first s)))) (solve\
    \ (rest s)))]\n        ))\n", "  (cond\n    ((null? s) (string s))\n    ((char->integer?\
    \ (car s)) (string->list s))\n    ((char->integer? (cadr s)) (string->list (char->string\
    \ (car s)) (caddr s)))\n    (else\n     (append \n      (solve (substring s 1\
    \ (char->integer? (caar s) (caddr s))))\n      (list (char->integer? (caar s)\
    \ (caddr s))))))))\n", "  (cond\n    [(empty? s) s]\n    [(or (char? (car s))\
    \ (char? (car s)))\n     (if (or (char? (car s)) (char? (car s))) (reverse-string-1\
    \ s)\n       (reverse-string s))]\n    [else (cons (char-car s) (reverse (reverse\
    \ s))]))) \n", "  (cond \n    [(empty? s) s]\n    [(char? (car s)) (cond\n   \
    \                     [(string=? (string-ref s 1) (char->string (char->integer\
    \ #\\A))) (cond\n                                                            \
    \  [(char->string (char->integer #\\A)) (char->string (char->integer #\\a))]\n\
    \                                                              [(char->string\
    \ (char->integer #\\a)) (char->string (char->integer #\\b))]\n               \
    \                                               [(char->string (char->integer\
    \ #\\b)) (char->string (char->integer #\\A))])]\n                        [(string=?\
    \ (string-ref s 1) (char->string (char->integer #\\a))) (cond\n              \
    \                                                [(char->string (char->integer\
    \ #\\a)) (char->string (char->integer #\\b))]\n                              \
    \                                [(char->string (char->integer #\\b)) (char->string\
    \ (char->integer #\\A))])]\n                        [(string=? (string-ref s 1)\
    \ (char->string (char->integer #\\b))) (cond\n                               \
    \                               [(char->string (char->integer #\\b)) (char->string\
    \ (char->integer #\\A))])]\n                        [(string=? (string-ref s 1)\
    \ (char->string (char->integer #\\A))) (cond\n                               \
    \                               [(char->string (char->integer #\\A)) (char->string\
    \ (char->integer #\\a))]]\n                        [(string=? (string-ref s 1)\
    \ (char->string (char->integer #\\a))) (cond\n                               \
    \                               [(char->string (char->integer #\\a)) (char->string\
    \ (char->integer #\\b))]\n                                                   \
    \           [(char->string (char->integer #\\b)) (char->string (char->integer\
    \ #\\A))])]\n                        [(string=? (string-ref s 1) (char->string\
    \ (char->integer #\\b))) (cond\n                                             \
    \                 [(char->string (char->integer #\\b)) (char->string (char->integer\
    \ #\\A))])]\n                        [(string=? (string-ref s 1) (char->string\
    \ (char->integer #\\A))) (cond\n                                             \
    \                 [(char->string (char->integer #\\A)) (char->string (char->integer\
    \ #\\a))]]\n                        [(string=? (string-ref s 1) (char->string\
    \ (char->integer #\\a))) (cond\n                                             \
    \                 [(char->string (char->integer #\\a)) (char->string (char->integer\
    \ #\\b))]\n                                                              [(char->string\
    \ (char->integer #\\b)) (char->string (char->integer #\\A))])]\n             \
    \           [(string=? (string-ref s 1) (char->string (char->integer #\\b))) (",
  "  (cond\n    [(empty? s) \"\"]\n    [(character? (first s)) (string-reverse (substring\
    \ (first s) 0 1))]\n    [else (string-reverse s)]))\n</code>\n<|/ a dscore=2 |>\n\
    <| a tags=scheme,string,racket,reverse |>\nIn Racket there are built-in functions\
    \ for doing this. See string.\n<code>", "  (if (empty? s)\n      (reverse s)\n\
    \      (if (char->integer? (car s))\n          (if (string? (cdr s))\n       \
    \       (define (make-uppper? s) \n                (char->integer? (car s)) \n\
    \                (make-uppper? (cdr s))) \n          (define (make-uppper? s)\
    \ \n            (char->integer? (car s)) \n            (make-uppper? (cdr s)))\n\
    \          (define (make-uppper? s) \n            (char->integer? (car s)) \n\
    \            (make-uppper? (cdr s)))\n          (make-uppper? (cdr s)))))\n</code>\n\
    <|/ a dscore=1 tags=scheme,racket,string |>\n<| c |>\nCan you please explain what\
    \ this line of code does? `(define (make-uppper? s) (char->integer? (car s)) (make-uppper?\
    \ (cdr s)))`\n<|/ c |>\n<| c |>\nSure. `(define (make-uppper? s) (char->integer?\
    \ (car s)) (make-uppper? (cdr s)))` defines a function `make-uppper?` that takes\
    \ two arguments, `s` and `(make-uppper? (cdr s))`. `make-uppper?` takes the `cdr`\
    \ of `s` and calls `make-uppper?` on that `cdr`. `(make-uppper? (cdr s))` calls\
    \ the function with the `(make-uppper? (cdr s))` argument.\n<|/ c |>\n<| c |>\n\
    I got it now. Thank you very much for the explanation. :)\n<|/ c |>\n<| a |>\n\
    Another way to do it using recursion instead of iteration:\n<code>", "  (cond\n\
    \    [(empty? s) s]\n    [(number? (car s))\n     (cond\n       [(char? (car s))\
    \ (substring (string (char->integer car s)) (- 1 (length s)))]\n       [(char?\
    \ (cdr s)) \n        (cond\n          [(char? (car s))\n           (substring\
    \ (string (char->integer car s)) (+ 1 (length s)))]\n          [else \n      \
    \     (cond\n              [(char? (cdr s))\n               (substring (string\
    \ (char->integer cdr s)) (+ 1 (length s)))]\n              [else \n          \
    \     (substring (string (char->integer car s)) (+ 1 (length s)))]))]\n      \
    \ [else \n        (substring (string (char->integer car s)) (+ 1 (length s)))]))]\n\
    \    [else \n    (substring (string (char->integer car s)) (+ 1 (length s)))]))\n\
    </code>\n<|/ a |>\n<| a |>\n<code>", "  (if (string? s)\n      (letfn [(case->case(char\
    \ ch)\n               (if (char-alphabetic? char)\n                   (char->upper-case-char\
    \ (char->lower-case-char char))\n                   (char->upper-case-char char))\n\
    \               (case->string(char ch))]\n        (case->string \n         (loop\
    \ for [ch (string->list s)] \n              for [new-char (case->case ch)] \n\
    \              collect new-char))\n      (string->list s))))\n", "  (cond\n  \
    \  ((empty? s)\n     (reverse s))\n    ((char? (car s)) (cond\n              \
    \        ((>= (car s) 'A) (cond\n                                        ((>=\
    \ (car s) 'Z) (set! s (string-append (string (car s) #\\Upcase) (substring s 1)))\n\
    \                                        ((>= (car s) 'a') (set! s (string-append\
    \ (string (car s) #\\Lowercase) (substring s 1)))\n                          \
    \              (substring s 1)\n                                        (substring\
    \ s 2)))\n                      ((>= (car s) 'z') (set! s (string-append (string\
    \ (car s) #\\Uppercase) (substring s 1)))\n                      (substring s\
    \ 1)\n                      (substring s 2)))\n                      (substring\
    \ s 1)\n                      (substring s 2)))\n    (else\n     (set! s (string-append\
    \ s (reverse (substring s 1)))))))\n", "  (cond [(empty? s)\n         s]\n   \
    \     [(alpha? (car s))\n         (if (lower? (car s))\n             (lower-case?\
    \ (car s)) (upper-case? (car s)) (upper-case? (car s))\n             (lower-case?\
    \ (car s)) (lower-case? (car s)))\n         (else (car s))]\n        [(alpha?\
    \ (car s))\n         (lower-case? (car s))\n         (upper-case? (car s))\n \
    \        (lower-case? (car s))]\n        [else\n         (upper-case? (car s))\n\
    \         (lower-case? (car s))\n         (upper-case? (car s))]\n        [else\
    \ (lower-case? (car s))]\n        [else (upper-case? (car s))]\n        [else\
    \ (upper-case? (car s))]))\n", "  (if (empty? s)\n      (list* \"Hello\")\n  \
    \    (let ((x (car s)) (y (if (char? x) (cdr s) (null (cdr x))))\n           \
    \ (z (car x)))\n        (cond ((and (char? (car s)) (char? (car x)))\n       \
    \        (cond ((char-lower? z) (cons z (solve (cons x (list '())))))\n      \
    \               ((char-upper? z) (cons (reverse z) x))\n                     (t\
    \   (cons (reverse z) (cons x y))))\n               ((char-upper? x) (cons (reverse\
    \ x) y))\n               ((char-lower? x) (cons x (reverse y))))\n           \
    \    (t   (cons x (cons y z)))))\n        (cond ((char? (car s)) (car s))\n  \
    \             (t (cons s (solve (list '())))))))\n", "  (let ((low (map char->integer\
    \ #\\a#\\A#\\c#\\C)))\n    (cond\n      [(null? s) s]\n      [(char->integer?\
    \ (car s)) (if (char->integer? (car s)) \n                                  (let\
    \ ((r (reverse (cdr s))))\n                                    (if (member (car\
    \ s) #\\a#\\A#\\c#\\C)\n                                        (cond [(member\
    \ #\\a#\\A#\\c#\\C r) (reverse r)]\n                                         \
    \     [(member #\\A#\\a#\\c#\\C r) (reverse r)]\n                            \
    \                  [(member #\\c#\\A#\\a#\\C r) (reverse r)]\n               \
    \                               [(member #\\C#\\a#\\a#\\c r) (reverse r)]\n  \
    \                                            [(member #\\a#\\c#\\A#\\C r) (reverse\
    \ r)]\n                                              [(member #\\A#\\c#\\a#\\\
    C r) (reverse r)]\n                                              [(member #\\\
    c#\\A#\\A#\\c r) (reverse r)]\n                                              [(member\
    \ #\\C#\\a#\\A#\\c r) (reverse r)]\n                                         \
    \     [(member #\\a#\\c#\\c#\\A r) (reverse r)]\n                            \
    \                  [(member #\\A#\\c#\\a#\\c r) (reverse r)]\n               \
    \                               [(member #\\c#\\A#\\c#\\a r) (reverse r)]\n  \
    \                                            [(member #\\C#\\a#\\c#\\a r) (reverse\
    \ r)]\n                                              [(member #\\a#\\c#\\c#\\\
    c r) (reverse r)]\n                                              [(member #\\\
    A#\\c#\\a#\\c r) (reverse r)]\n                                              [(member\
    \ #\\c#\\A#\\c#\\c r) (reverse r)]\n                                         \
    \     [(member #\\A#\\a#\\c#\\A r) (reverse r)]\n                            \
    \                  [(member #\\a#\\c#\\a#\\A r) (reverse r)]\n               \
    \                               [(member #\\c#\\A#\\a#\\A r) (reverse r)]\n  \
    \                                            [(member #\\C#\\a#\\a#\\A r) (reverse\
    \ r)]\n                                              [(member #", "  (cond [(empty?\
    \ s) '()]\n        [(symbol? (first s)) (reverse (solve (reverse s)))]\n     \
    \   [else\n         (let ([c (first (first s))])\n           (cond\n         \
    \    [(> c 'a) (cons (char->string (char->integer c)) (solve (reverse s)))]\n\
    \             [(> c 'z) (cons (char->string (char->integer c)) (solve (reverse\
    \ s)))]\n             [else (cons (char->string c) (solve (reverse s)))])))])\n",
  "  (let ([letters (string->list s)])\n    (cond\n      [(empty? letters) s]\n  \
    \    [(character? (first letters)) (string->list (reverse (first letters)))]\n\
    \      [else (cons (first letters)\n                  (solve (substring (substring\
    \ s 1) (+ 1 (string-length s) 1))))])))", "  (cond ((null? s) '())\n        ((char->integer?\
    \ (car s)) (reverse (list (char->integer (car s)) \n                         \
    \                  (char->integer (cadr s)))))\n        (else (car s))))\n", " \
    \ (cond [(null? s) s]\n        [(char s (car s)) (cons (char (char-code (car s))\
    \ \n                                  (case-name (char-code (cdr s))))\n     \
    \                          (solve (char (cdr s)))]\n        [else (cons (car s)\
    \ (solve (char (cdr s))))]))))\n</code>\n<|/ a tags=racket,string |>\n<| a dscore=0\
    \ |>\n<code>", "  (cond [(empty? s) \"\"]\n        [(equal? (first s) '#\\a) (upper\
    \ (reverse (second s))) (lower (reverse (second s))) s]\n        [else (cond [(equal?\
    \ (first s) #\\A)\n                      (upper (reverse (second s)))\n      \
    \                (lower (reverse (second s)))]\n                  [else (cond\
    \ [(equal? (first s) #\\b)\n                                (lower (reverse (second\
    \ s)))\n                                (upper (reverse (second s)))]\n      \
    \                    [else (cond [(equal? (first s) #\\C)\n                  \
    \                    (upper (reverse (second s)))\n                          \
    \            (lower (reverse (second s)))]\n                                 \
    \   [else (cond [(equal? (first s) #\\d)\n                                   \
    \            (lower (reverse (second s)))\n                                  \
    \             (upper (reverse (second s)))]\n                                \
    \          [else (cond [(equal? (first s) #\\E)\n                            \
    \                          (upper (reverse (second s)))\n                    \
    \                                  (lower (reverse (second s)))]\n           \
    \                                         [else (cond [(equal? (first s) #\\F)\n\
    \                                                               (upper (reverse\
    \ (second s)))\n                                                             \
    \  (lower (reverse (second s)))]\n                                           \
    \           [else (cond [(equal? (first s) #\\G)\n                           \
    \                                          (lower (reverse (second s)))\n    \
    \                                                                 (upper (reverse\
    \ (second s)))]\n                                                            \
    \    [else (cond [(equal? (first s) #\\H)\n                                  \
    \                                        (upper (reverse (second s)))\n      \
    \                                                                    (lower (reverse\
    \ (second s)))]\n                                                            \
    \    [else (cond [(equal? (first s) #\\I)\n                                  \
    \                                                    (upper (reverse (second s)))\n\
    \                                                                            \
    \          (lower (reverse (second s)))]\n                                   \
    \                             [else (cond [(equal? (first s) #\\J)\n         \
    \                                                                            \
    \  (lower (reverse (second s)))\n                                            \
    \                                           (upper (reverse (second s)))]\n  \
    \                                                                            [else\
    \ (cond [(equal? (first s) #\\K)\n                                           \
    \                                                           (upper (reverse (second\
    \ s)))\n                                                                     \
    \                                 (lower (reverse (second s)))]\n            \
    \                                                                            [else\
    \ (cond [(equal? (first s) #\\L)\n                                           \
    \                                                            (lower (reverse (second\
    \ s)))\n                                                                     \
    \                                  (upper (reverse (second s)))]\n           \
    \                                                                            \
    \      [else (cond [(equal? (first s) #\\M)\n                                \
    \                                                                         (lower\
    \ (reverse (second s)))\n                                                    \
    \                                                     (upper (reverse (second\
    \ s)))]\n                                                                    \
    \                              [else (cond [(equal? (first s) #\\N)\n", "  (define\
    \ (aux-string str1)\n    (if (string? str1)\n      (str1)\n      (append (map\
    \ character->string (string->list (char->lower-case\n                        \
    \   (char->upper-case (first str1))))))))\n  (cond\n    ((null? s) (aux-string\
    \ s))\n    ((char->boolean? (char->char (first s)))\n     (cond\n       ((char->lower-case?\
    \ (char->char (first s))) (aux-string (second s))))\n     ((char->upper-case?\
    \ (char->char (first s))) (aux-string (second s))))\n    (else (cons (first s)\
    \ (aux-string (second s))))))\n</code>\n<|/ a tags=racket,scheme |>\n<| a tags=racket,scheme\
    \ |>\n<code>", "  (cond\n    [(empty? s) s]\n    [(char? (first s)) (if (char?\
    \ (first s)) (char-case (first s)) (solve-cases (rest s))))]\n    [else (solve-cases\
    \ (rest s))]))\n", "  (cond\n    ((empty? s) s)\n    ((char? s) (let ((next (solve\
    \ (char->string s))))\n                    (cond\n                      ((char->string?\
    \ (first next)) (reverse (first next)))\n                      ((char->string?\
    \ (rest next)) (cons (first next) (rest (rest next))))\n                     \
    \ (else (cons (first next) (first next)))))))\n    (else (let ((next (solve (string->char\
    \ s))))\n            (cond\n              ((string->char? (first next)) (reverse\
    \ (first next)))\n              ((string->char? (rest next)) (cons (first next)\
    \ (rest (rest next))))\n              (else (cons (first next) (first next))))))))\n\
    </code>\n<|/ a dscore=2 |>\n<| a |>\nHere is a very short recursive solution,\
    \ which will run in O(n).\n<code>", "  (cond ((null? s) s)\n        ((char->integer?\
    \ (car s))\n         (cond ((char->boolean? (car s))\n                (cond ((char->char?\
    \ (car s)) (char->string (reverse (list char->char (car s)))))\n             \
    \          ((char->integer? (car s)) (cond ((char->char? (car s)) (char->string\
    \ (reverse (list char->integer (car s)))))\n                                 \
    \                    ((char->boolean? (car s)) (cond ((char->char? (car s)) (char->string\
    \ (reverse (list char->boolean (car s)))))\n                                 \
    \                                                             ((char->integer?\
    \ (car s)) (cond ((char->char? (car s)) (char->string (reverse (list char->integer\
    \ (car s)))))\n                                                              \
    \                                                       ((char->boolean? (car\
    \ s)) (cond ((char->char? (car s)) (char->string (reverse (list char->integer\
    \ (car s))))))))))))\n               ((char->char? (car s)) (char->string (reverse\
    \ (list char->char (car s))))))\n        ((char->boolean? (car s))\n         (cond\
    \ ((char->char? (car s))\n                (cond ((char->char? (car s)) (char->string\
    \ (reverse (list char->char (car s)))))\n                       ((char->integer?\
    \ (car s)) (cond ((char->char? (car s)) (char->string (reverse (list char->integer\
    \ (car s)))))\n                                                     ((char->boolean?\
    \ (car s)) (cond ((char->char? (car s)) (char->string (reverse (list char->boolean\
    \ (car s)))))\n                                                              \
    \                                ((char->integer? (car s)) (cond ((char->char?\
    \ (car s)) (char->string (reverse (list char->integer (car s)))))\n          \
    \                                                                            \
    \                               ((char->boolean? (car s)) (cond ((char->char?\
    \ (car s)) (char->string (reverse (list char->integer (car s))))))))))))\n   \
    \            ((char->integer? (car s)) (cond ((char->char? (car s)) (char->string\
    \ (reverse (list char->integer (car s)))))\n                                 \
    \                    ((char->boolean? (car s)) (cond ((char->char? (car s)) (char->string\
    \ (reverse (list char->boolean (car s)))))", "  (reverse-case (loop for i from\
    \ 0 to (string-length s) by 1 collect (match-string (substring s i i) [#\\a-z\
    \ #\\A-Z] [#\\A-Z #\\a-z])))\n)\n", "  (cond\n    [(empty? s) \"\"]\n    [(cons?\
    \ s) (solve (first s))]\n    [(number? (first s)) (cond\n                    \
    \        [(equal? (first s) 'a) (solve (rest s) #f 'A)]\n                    \
    \        [(equal? (first s) 'A) (solve (rest s) #f 'a)]\n                    \
    \        [(equal? (first s) #f '#f) (solve (rest s) #f '#)]\n                \
    \            [else (solve (rest s) #f (first s))])]\n    [else (cons (first s)\
    \ (solve (rest s) #f (first s)))]))", "  (cond (empty? s) s\n        (null? (rest\
    \ s)) (reverse s)\n        (char? (car s)) (if (string=? (reverse s) (lower-case-string\
    \ (car s))) (upper-case-string (car s)) (lower-case-string (car s)))\n       \
    \ (else (lower-case-string (solve (rest s))))))\n", "  (cond\n    ((empty? s)\
    \ \"0\")\n    ((char-alpha? (car s)) (subcase-string (car s) (cdr s)))\n    (else\
    \ s)))\n", "  (cond\n    ((empty? s) (string s))\n    ((char? (car s)) (cond\n\
    \                      ((char->integer (car s)) < 65)\n                      ((char->integer\
    \ (car s)) > 90)\n                      (else (cons (char->integer (char->lower-case\
    \ (car s))) (cons (char->integer (char->upper-case (car s))) (string-reverse (cdr\
    \ s)))))))\n    (else (cons (char->integer (char->lower-case (car s))) (cons (char->integer\
    \ (char->upper-case (car s))) (string-reverse (cdr s)))))))\n</code>\n<|/ a tags=racket,scheme\
    \ |>\n<| a tags=racket,scheme |>\nYou can't do it in place. You'll need to reverse\
    \ the list first:\n<code>", "  (cond [(null? s) \"\"]\n        [(char-upper? (car\
    \ s))\n         (append (solve (cdr s)) \n                 (string-append \"#\"\
    \ (char-upcase (car s)) \n                               (char-upcase (cadr s))\
    \ \n                               \"\"))]\n        [(char-lower? (car s))\n \
    \        (append (solve (cdr s)) \n                 (string-append \"#\" (char-upcase\
    \ (car s)) \n                               (char-downcase (cadr s)) \n      \
    \                         \"\"))]\n        [else\n         (string-append (car\
    \ s) \n                       (if (char-lower? (cadr s)) \n                  \
    \         \"\" \n                           (char-downcase (cadr s)))]\n     \
    \   [else \"\"]))\n", "  (if (null? s)\n      (string s)\n      (if (char? (car\
    \ s))\n          (if (char? (car s))\n              (if (char? (cadr s))\n   \
    \               (if (char? (cadr s))\n                      (if (char? (caddr\
    \ s))\n                          (if (char? (caddr s))\n                     \
    \         (if (char? (caddaddr s))\n                                  (if (char?\
    \ (caddaddr s))\n                                      (if (char? (caddaddaddr\
    \ s))\n                                          (if (char? (caddaddaddr s))\n\
    \                                              (if (char? (caddaddaddaddr s))\n\
    \                                                  (if (char? (caddaddaddaddr\
    \ s))\n                                                      (if (char? (caddaddaddaddaddr\
    \ s))\n                                                          (if (char? (caddaddaddaddaddaddr\
    \ s))\n                                                                  (if (char?\
    \ (caddaddaddaddaddaddaddr s))\n                                             \
    \                         (if (char? (caddaddaddaddaddaddaddaddr s))\n       \
    \                                                                   (if (char?\
    \ (caddaddaddaddaddaddaddaddr s))\n                                          \
    \                                    (if (char? (caddaddaddaddaddaddaddaddaddr\
    \ s))\n                                                                      \
    \            (if (char? (caddaddaddaddaddaddaddaddaddr s))\n                 \
    \                                                                     (if (char?\
    \ (caddaddaddaddaddaddaddaddaddr s))\n                                       \
    \                                                   (if (char? (caddaddaddaddaddaddaddaddaddaddr\
    \ s))\n                                                                      \
    \                        (if (char? (caddaddaddaddaddaddaddaddaddaddr s))\n  \
    \                                                                            \
    \                    (if (char? (caddaddaddaddaddaddaddaddaddaddr s))\n      \
    \                                                                            \
    \                    (if (char? (caddaddaddaddaddaddaddaddaddaddaddr s))\n   \
    \                                                                            \
    \                           (if (char? (caddaddaddaddaddaddaddaddaddaddaddr s))\n\
    \                                                                            \
    \                                  (if (char? (caddaddaddaddaddaddaddaddaddaddaddr\
    \ s))\n                                                                      \
    \                                            (if (char? (caddaddaddaddaddaddaddaddaddaddaddr\
    \ s))\n                                                                      \
    \                                                (if (char? (caddaddaddaddaddaddaddaddaddaddaddr\
    \ s))\n                                                                      \
    \                                                    (if (char? (caddaddaddaddaddaddaddaddaddaddaddr\
    \ s))\n                                                                      \
    \                                                        (if (char? (caddaddaddaddaddaddaddaddaddaddaddaddr\
    \ s))\n                                                                      \
    \                                                            (if (char? (caddaddaddaddaddaddaddaddaddaddaddaddr\
    \ s))\n                                                                      \
    \                                                                (if (char? (cadd",
  "  (cond\n    [(or (char? (first s)) (empty? s))\n     (reverse s)]\n    [(or (char?\
    \ (first s)) (empty? (rest s)))\n     (reverse (cons (first s) (solve (rest s))))]\n\
    \    [else\n     (cond\n       [(char? (first s))\n        (append (reverse (cons\
    \ (char-upcase (first s)) (solve (rest s))))\n                (list (char-downcase\
    \ (first s))))]\n       [else\n        (append (reverse (cons (first s) (solve\
    \ (rest s))))\n                (list (first s))])]))) ; cons(a,b) -> a,b\n", " \
    \ (cond\n    ((empty? s) s)\n    ((char-or-string (car s)) (set-to-string (cadr\
    \ s) (apply reverse (map char->string (cdr s)))))\n    ((char->string (car s))\
    \ (set-to-string (cadr s) (apply reverse (map char->string (cdr s)))))\n    (else\
    \ (set-to-string (cadr s) (apply reverse (map char->string (cdr s))))))", "  (cond\n\
    \    [(empty? s) s]\n    [(number? (car s)) (solve (reverse s))]\n    [(member?\
    \ ?a (car s)) (solve (upper-case-letters (solve (cdr s))))]\n    [(member? ?A\
    \ (car s)) (solve (lower-case-letters (solve (cdr s))))]\n    [else (cons (car\
    \ s) (solve (cdr s))) ]\n  )\n)\n", "  (cond\n    ((empty? s) s)\n    ((char?\
    \ (car s)) (cond\n                      ((char->int (car s)) (cond\n         \
    \                               ((>= (length s) 0) (error \"Empty string\"))\n\
    \                                        ((char->int  (car s)) (cond\n       \
    \                                                 ((>= (length s) 0) (error \"\
    Empty string\"))\n                                                        ((char->int\
    \  (car s)) (cond\n                                                          \
    \                ((char->int  (car s)) (cond\n                               \
    \                                             (char->int  (car s) (cond\n    \
    \                                                                            \
    \              ((char->int (car s)) \"\")\n                                  \
    \                                                            ((char->int (car\
    \ s)) (cond\n                                                                \
    \                                 ((char->int (car s)) (cond\n               \
    \                                                                            \
    \       ((char->int (car s)) \"\")\n                                         \
    \                                                         ((char->int (car s))\
    \ (cond\n                                                                    \
    \                                 ((char->int (car s)) (cond\n               \
    \                                                                            \
    \            ((char->int (car s)) \"\")\n                                    \
    \                                                                   ((char->int\
    \ (car s)) (cond\n                                                           \
    \                                             ((char->int (car s)) (cond\n   \
    \                                                                            \
    \                            ((char->int (car s)) \"\")\n                    \
    \                                                                            \
    \           ((char->int (car s)) (cond\n                                     \
    \                                                                        ((char->int\
    \ (car s)) (cond\n                                                           \
    \                                                    ((char->int (car s)) \"\"\
    )\n                                                                          \
    \                                     ((char->int (car s)) (cond\n           \
    \                                                                            \
    \                          ((char->int (car s)) (cond\n                      \
    \                                                                            \
    \                 ((char->int (car s)) \"\")\n                               \
    \                                                                            \
    \        ((char->int (car s)) (cond\n                                        \
    \                                                                            \
    \ ((char->int (car s)) (cond\n                                               \
    \                                                                        ((char->int\
    \ (car s)) \"\")\n                                                           \
    \                                                            ((char->int (car\
    \ s)) (cond\n                                                                \
    \                                                        ((char->int (car s))\
    \ (cond\n                                                                    \
    \                                                       ((char->int (car s)) \"\
    \")\n                                                                        \
    \                                                   ((char->int (car s)) (cond\n\
    \                                                                            \
    \                                                ((char->int (car s)) (cond\n\
    \                                                                            \
    \                                                   ((char->int (car s)) \"\"\
    )\n                                                                          \
    \                                                     ((char->int (car s)) (cond\n\
    \                                                                            \
    \                                                    ((char->int (car s)) (cond\n\
    \                                                                            \
    \                                                       ((char->int (car s)) \"\
    \")\n                                                                        \
    \                                                           ((char->int (car s))\
    \ (cond\n                                                                    \
    \                                                                ((char->int (car\
    \ s)) (cond\n                                                                \
    \                                                                     ((char->int\
    \ (car s)) \"\")\n                                                           \
    \                                                                          ((char->int\
    \ (car s)) (cond\n                                                           \
    \                                                                           ((char->int\
    \ (car s)) (cond\n                                                           \
    \                                                                            ((char->int ",
  "  (cond [(not (empty? s)) s]\n        [(symbol? (first s)) (cond [(upper? (first\
    \ s)) (first (first s))]\n                                   [(lower? (first s))\
    \ (first (first s))])]\n        [else (cond [(upper? (first s)) (first (first\
    \ s))]\n                    [(lower? (first s)) (first (first s))])]))\n", " \
    \ (cond [(empty? s) (empty-string)] \n        [(and (>= (length s) 1) (char? (first\
    \ s)) (char->integer (first s)) (char->integer (char->integer s))) (cons (char->integer\
    \ s)\n                                                                       \
    \                                  (reverse (substring s 1 (- 1 )))]\n       \
    \ [else (cons (char->integer s)\n                 (reverse (substring s 0 (+ 1\
    \ )))]))))\n", "  (define (solveHelper i r)\n    (cond\n      [(char-upper? (car\
    \ s)) (char-upper? (car r)) (cons (char-upper? (car s)) r)]\n      [(char-lower?\
    \ (car s)) (char-lower? (car r)) (cons (char-lower? (car s)) r)]\n      [else\
    \ (cons (car s) r)]))\n  (if (empty? s) r)\n  (solveHelper (first s) (solve (rest\
    \ s))))", "  (cond [(empty? s) \"\"]\n        [(equal? (first s) #\\a) (upper\
    \ (first s) #\\A)]\n        [(equal? (first s) #\\b) (lower (first s) #\\B)]\n\
    \        [else (cons (first s)\n                    (solve (rest s)))]))\n", " \
    \ ;; Use a for loop to reverse each letter\n  (define (helper l acc)\n    (if\
    \ (empty? l)\n        acc\n        (helper (cdr l) (cons (first l) acc))))\n \
    \ (helper s (list s)))\n", "  (cond\n    [(empty? s) (string empty)]\n    [(char?\
    \ (car s)) (let ([f (or (char->upper (car s)) (char->lower (car s)))])\n     \
    \               (append (solve (cdr s)) (list f))])\n    [else (let ([chars (string->list\
    \ (string->string s))])\n             (let ([newchars (map (lambda (c) (if (char->upper\
    \ (c)) (char->lower c) c)) chars)])\n               (cond\n                 [(empty?\
    \ newchars) (string empty)]\n                 [(char? (car newchars)) (let ([f\
    \ (or (char->upper (car newchars)) (char->lower (car newchars)))])\n         \
    \                                     (append (solve (cdr newchars)) (list f))])\n\
    \                 [else (let ([f (lambda (s) (if (empty? s) (char->upper (car\
    \ s)) (char->lower (car s)))))])\n                   (append (solve (cdr newchars))\
    \ (list f))])])])) \n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis doesn't do what\
    \ OP asked for. It converts to lowercase all occurrences of uppercase characters,\
    \ but it doesn't reverse the case.\n<|/ c |>\n<| c |>\nThis is indeed a good answer,\
    \ but there's a bug, since `reverse` is not defined for `char`. `char` implements\
    \ `string`, so `reverse char` works fine.\n<|/ c |>\n<| c |>\nOops, didn't realize\
    \ I forgot to call `string->string` on the argument of reverse... fixed. Thanks\
    \ for the catch.\n<|/ c |>\n<| a dscore=1 |>\n<code>", "  (define (helper s)\n\
    \    (cond\n      [(empty? s) s]\n      [(char? (car s)) (helper (char->string\n\
    \                               (string->char (string-replace s\n            \
    \                                             #\\ (char->string #\\)\n       \
    \                                                  #\\\n                     \
    \                                    (string->char (char->string #\\))\n     \
    \                                                    #\\\n                   \
    \                                      (string->char (char->string #\\)))\n  \
    \                             #\\\n                               (string->char\
    \ (char->string #\\))))]\n      [else (string->string (string->char (string-reverse\
    \ s)))]))\n  (helper s))\n", "  (if (empty? s)\n      '()\n      (let* ((ch (car\
    \ s))\n             (ch-next (next-char (car s) (list (car s) 'A 'a)))\n     \
    \        (ch-upper (upper-char (car s) (ch-next 'A)))\n             (ch-lower\
    \ (lower-char (car s) (ch-next 'a)))\n             (ch-next (ch-upper | ch-lower)))\n\
    \        (cond ((eq? ch '#) (cons ch (solve (ch-next (list))))\n             \
    \ ((eq? ch '@) (cons ch (solve (ch-next (list))))\n              (else (cons ch\
    \ (solve (ch-next (list))))))))\n", "  (cond [(empty? s) \"\"]\n        [(character?\
    \ (first s)) (char-case (first s) (first s))]\n        [else (concat (solve (rest\
    \ s)) (char-case (first s) (first s)))]))\n", "  (cond\n    ((or (char? (car s))\n\
    \         (string=? s (string-ref s 0)))\n     (string-reverse s))\n    ((char=?\
    \ #\\a (first s)) \n     (string-reverse (first s)))\n    (else\n     (string-append\
    \ (first s) (solve\n                         (rest s))))))\n", "  (let ([curr\
    \ 0])\n    (cond\n      [(null? s)\n       (string->symbol (string->string s))]\n\
    \      [(char->integer? (char->string (car s))) (lambda (i) (char->string (+ (char->integer\
    \ (char->string (car s)) i) (char->integer (char->string (cdr s))) i)))]\n   \
    \   [else (lambda (i) (if (char->integer? (char->string (cdr s))) (char->string\
    \ (+ (char->integer (char->string (car s)) i) (char->integer (char->string (cdr\
    \ s))) i)) (if (char->integer? (char->string (car s))) (char->string (+ (char->integer\
    \ (char->string (car s)) i) (char->integer (char->string (cdr s))) i)) (char->string\
    \ (+ i curr)))))]\n)))\n", "  (cond\n    [(empty? s) s]\n    [(char-blank? s)\
    \ s]\n    [else (let [(head (car s))\n              (tail (cdr s))]\n        \
    \    (cond\n              [(char? head) \n               (cond\n             \
    \    [(char-upper? head) (make-upper-case (make-lower-case tail))]\n         \
    \        [(char-lower? head) (make-lower-case (make-upper-case tail))]\n     \
    \            [(char-blank? head) (solve (make-lower-case tail))]\n           \
    \      [else (solve (make-upper-case tail))]\n                 )]\n          \
    \    [(char? tail) (solve (make-upper-case tail))]\n              [(char? tail)\
    \ (solve (make-lower-case tail))]\n              [else (solve (make-lower-case\
    \ tail))]\n              )]\n            )\n           )]\n))\n", "  (if (empty?\
    \ s)\n      s\n      (let ([first-letter (first s)])\n        (cond [(equal? (char-case\
    \ first-letter) (char-case (first s))) (solve (reverse s))]\n              [(equal?\
    \ (char-case first-letter) (char-case (first (reverse s)))) (solve (first (reverse\
    \ s)))]\n              [else (first (reverse s))])))) \n", "  (cond\n    ((char-?\
    \ (car s)) #t)\n    ((string=? \"#\" (car s)) (if (string=? (solve (cdr s)) #\"\
    a\" (solve (cdr s)))\n                                (if (string=? (solve (cdr\
    \ s)) #\"b\" (solve (cdr s)))\n                                    (if (string=?\
    \ (solve (cdr s)) #\"c\" (solve (cdr s)))\n                                  \
    \      (if (string=? (solve (cdr s)) #\"d\" (solve (cdr s)))\n               \
    \                             \"#\" \"#\")\n                                 \
    \       (if (string=? (solve (cdr s)) #\"e\" (solve (cdr s)))\n              \
    \                              \"#\" \"#\")\n                                \
    \        (if (string=? (solve (cdr s)) #\"f\" (solve (cdr s)))\n             \
    \                               \"#\" \"#\")\n                               \
    \         (if (string=? (solve (cdr s)) #\"g\" (solve (cdr s)))\n            \
    \                                \"#\" \"#\")\n                              \
    \          (if (string=? (solve (cdr s)) #\"h\" (solve (cdr s)))\n           \
    \                                 \"#\" \"#\")\n                             \
    \           (if (string=? (solve (cdr s)) #\"i\" (solve (cdr s)))\n          \
    \                                  \"#\" \"#\")\n                            \
    \            (if (string=? (solve (cdr s)) #\"j\" (solve (cdr s)))\n         \
    \                                   \"#\" \"#\")\n                           \
    \             (if (string=? (solve (cdr s)) #\"k\" (solve (cdr s)))\n        \
    \                                    \"#\" \"#\")\n                          \
    \              (if (string=? (solve (cdr s)) #\"l\" (solve (cdr s)))\n       \
    \                                     \"#\" \"#\")\n                         \
    \               (if (string=? (solve (cdr s)) #\"m\" (solve (cdr s)))\n      \
    \                                      \"#\" \"#\")\n                        \
    \                (if (string=? (solve (cdr s)) #\"n\" (solve (cdr s)))\n     \
    \                                       \"#\" \"#\")\n                       \
    \                 (if (string=? (solve (cdr s)) #\"o\" (solve (cdr s)))\n    \
    \                                        \"#\" \"#\")\n                      \
    \                  (if (string=? (solve (cdr s)) #\"p\" (solve (cdr s)))\n   \
    \                                         \"#\" \"#\")\n                     \
    \                   (if (string=? (solve (cdr s)) #\"q\" (solve (cdr s)))\n  \
    \                                          \"#\" \"#\")\n                    \
    \                    (if (string=? (solve (cdr s)) #\"r\" (solve (cdr s)))\n \
    \                                           \"#\" \"#\")\n                   \
    \                     (if (string=? (solve (cdr s)) #\"s\" (solve (cdr s)))\n\
    \                                            \"", "  (cond ((or (char-? (car s))\n\
    \            (char-? (cdr s)))\n         (reverse s))\n        (else\n       \
    \  (cond\n          ((char? (car s))\n           (reverse (cdr s)))\n        \
    \  ((char? (cdr s))\n           (reverse (cdr (cdr s))))\n          ((empty? (cdr\
    \ s))\n           (reverse s))\n          (else\n           (cond\n          \
    \  ((char? (car s))\n             (cons (toupper car s)\n                  (solve\
    \ (cdr s)))\n             ((char? (cdr s))\n               (cons (tolower car\
    \ s)\n                     (solve (cdr s)))\n             (else\n            \
    \   (cons (car s)\n                     (solve (cdr s)))))))))\n</code>\n<|/ a\
    \ dscore=1 |>\n<| c |>\nI like your solution but I have to say, it's a bit too\
    \ complex. I wonder how they did it in C and Python.\n<|/ c |>\n<| a tags=racket,scheme\
    \ |>\n<code>", "  (let loop ((s (string->list s)) (r \"\"))\n    (cond\n     \
    \ [(empty? s) r]\n      [(char? s) (loop (cdr s) (append r r))]\n      [else (loop\
    \ (cdr s) (append r lc s))]))))\n</code>\n<|/ a dscore=3 tags=recursion,racket,scheme\
    \ |>\n<| c |>\nI like it, but I suspect you meant `[else (loop (cdr s) (append\
    \ r lc s))]`. You're calling the `loop` function with both the cdr and the new\
    \ `s`, but the else case should just be the recursive call with `lc s`.\n<|/ c\
    \ |>\n<| c |>\nThat's right, thank you, I fixed it.\n<|/ c |>\n<| a |>\nA nice\
    \ way to do this is to define an internal helper function to do your string reversal:\n\
    <code>", "  (cond\n    [(empty? s) s]\n    [(eq? (first s) #\\a) (lowto (lowto\
    \ (first s)))]\n    [(eq? (first s) #\\A) (upto (upto (first s)))]\n    [else\
    \ (lowto (lowto (first s))) (upto (upto (first s)))]))\n", "  (define (check-letter-case\
    \ s i)\n    (cond\n      [(char=? (char-code (substring s 0 i)) #\\a) (cond (char=?\
    \ (char-code (substring s 0 i)) #\\A) (cond (char=? (char-code (substring s 0\
    \ i)) #\\b) (cond (char=? (char-code (substring s 0 i)) #\\B) (substring s 0 i)\
    \ (substring s (+ i (string-length s)))))\n       (cond [(char=? (char-code (substring\
    \ s 0 i)) #\\A) (substring s (+ i (string-length s))) (substring s 0 (+ i (string-length\
    \ s))) (substring s (+ i (string-length s))))\n      [(char=? (char-code (substring\
    \ s 0 i)) #\\a) (substring s (+ i (string-length s))) (substring s 0 (+ i (string-length\
    \ s))) (substring s (+ i (string-length s)))]\n      [(char=? (char-code (substring\
    \ s 0 i)) #\\A) (substring s (+ i (string-length s))) (substring s (+ i (string-length\
    \ s))) (substring s 0 (+ i (string-length s))))\n      [(char=? (char-code (substring\
    \ s 0 i)) #\\b) (substring s (+ i (string-length s))) (substring s (+ i (string-length\
    \ s))) (substring s 0 (+ i (string-length s)))]\n      [(char=? (char-code (substring\
    \ s 0 i)) #\\B) (substring s (+ i (string-length s))) (substring s (+ i (string-length\
    \ s))) (substring s 0 (+ i (string-length s)))]\n      [else (substring s (+ i\
    \ (string-length s)))]\n      ))\n    (check-letter-case s 0))\n  (cond\n    [(char=?\
    \ (char-code (substring s 0 0)) #\\a) (reverse (reverse (substring s 0 (string-length\
    \ s)))) (reverse (substring s 0 (string-length s)))]\n    [(char=? (char-code\
    \ (substring s 0 0)) #\\A) (reverse (substring s (string-length s))) (reverse\
    \ (substring s 0 (string-length s)))]\n    [(char=? (char-code (substring s 0\
    \ 0)) #\\b) (reverse (substring s (string-length s))) (reverse (substring s 0\
    \ (string-length s)))]\n    [(char=? (char-code (substring s 0 0)) #\\B) (reverse\
    \ (substring s (", "  (cond [(empty? s) s]\n        [(character(first s)) (cons\
    \ (if (character(first s)) \n                                      (if (equal?\
    \ (second s) #\\A) (second s) \n                                         (second\
    \ s))\n                                      (if (equal? (second s) #\\a) (second\
    \ s) \n                                         (second s)))]\n        [else (cons\
    \ (first s)\n                   (solve (substring (drop 1 s)\n               \
    \               (if (equal? (first s) #\\A) (second s) \n                    \
    \            (second s)))) ]))))\n", "  (if (empty? s)\n      '()\n      (append\
    \ (map (\u03BB (a) (if (char? (car a)) (cdr a) a)) (sort (map string->char (string->list\
    \ (reverse s))))))))\n</code>\n<|/ a dscore=2 |>\n<| c |>\nWhy not use `map` instead\
    \ of `append` followed by `sort`?\n<|/ c |>\n<| c |>\n-Graham It's more like an\
    \ exercise for me that I want to try using map more efficiently than using append+sort.\
    \ I will edit my solution with map solution\n<|/ c |>\n<| c |>\nYes, this does\
    \ seem to work, but I think it is much more complicated than necessary. Thank\
    \ you for sharing your solution!\n<|/ c |>\n<| c |>\nI am not very familiar with\
    \ racket so my code might not be optimal. I am sure that my solution could be\
    \ made simpler though.\n<|/ c |>\n<| c |>\n-Graham Your solution is definitely\
    \ more elegant than mine!\n<|/ c |>\n<| a tags=racket,scheme |>\nHere is how I\
    \ did it:\n<code>", "  (cond\n    [(empty? s) (string s)]\n    [(letter? (first\
    \ s)) (cons (string-lower (first s)) (string-upper (first s)))]\n    [else (cons\
    \ s (solve\n                     (substring (s start end)))]))\n</code>\n<|/ a\
    \ tags=racket,scheme |>\n<| c |>\nWhat is the function letter? and also what is\
    \ \"start\" and \"end\"?\n<|/ c |>\n<| c |>\n\"start\" and \"end\" are arguments\
    \ that we pass to substring. \nletter? just check if the first character is a\
    \ letter or not. \nI added more explanation to the answer.\n<|/ c |>\n<| a tags=racket,scheme\
    \ |>\n<code>", "  (cond [(empty? s) (empty? s)] \n        [(member? (car s) '())\
    \ (car s)] \n        [else (append (toUpper (car s)) (solve (toLower s))])]))\n",
  "  (cond [(empty? s) s]\n        [(member (car s) \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    )\n         (let ([str (reverse s)] \n               [result (join (map concat\
    \ \n                                [(string->char (string->string (str substring\
    \ 0 1)))]\n                                [(string->char (string->string (str\
    \ substring 1)))]))]\n               [str (join (str str))]\n               [str\
    \ (join (str result (cdr result)))]\n               [str (join (str result result\
    \ (cdr result)))]\n               [str (join (str result result result (cdr result)))]\n\
    \               [str (join (str result result result result (cdr result)))]\n\
    \               [str (join (str result result result result result (cdr result)))]\n\
    \               [str (join (str result result result result result result (cdr\
    \ result)))]\n               [str (join (str result result result result result\
    \ result result (cdr result)))]\n               [str (join (str result result\
    \ result result result result result result (cdr result)))]\n               [str\
    \ (join (str result result result result result result result result result (cdr\
    \ result)))]\n               [str (join (str result result result result result\
    \ result result result result result (cdr result)))]\n               [str (join\
    \ (str result result result result result result result result result result result\
    \ (cdr result)))]\n               [str (join (str result result result result\
    \ result result result result result result result result (cdr result)))]\n  \
    \             [str (join (str result result result result result result result\
    \ result result result result result result (cdr result)))]\n               [str\
    \ (join (str result result result result result result result result result result\
    \ result result result (cdr result)))]\n               [str (join (str result\
    \ result result result result result result result result result result result\
    \ result result (cdr result)))]\n               [str (join (str result result\
    \ result result result result result result result result result result result\
    \ result (cdr result)))]\n               [str (join (str result result result\
    \ result result result result result result result result result result result\
    \ result (cdr result)))]\n               [str (join (str result result result\
    \ result result result result result result result result result result result ",
  "  (cond (empty? s) s\n        (char? (car s)) (ifelse\n          [(= (char-code\
    \ (car s)) (char-code (char-upcase (car s))))\n           (string-append (string-downcase\
    \ s) \"A\")\n           (string-append (string-downcase s) \"a\")\n          \
    \ (string-append (string-downcase s) \"B\")\n           (string-append (string-downcase\
    \ s) \"b\")\n           (string-append (string-downcase s) \"C\")\n          \
    \ (string-append (string-downcase s) \"c\")]\n          [else (cons (car s)\n\
    \                     (solve\n                      (string-downcase (substring\
    \ s 0 (- (string-length s) 1)))\n                      (string-downcase (substring\
    \ s 1 (- (string-length s) 1))))))]\n        (char? (car s)) (ifelse\n       \
    \   [(char-code (car s)) (string-downcase s)\n           (solve\n            (substring\
    \ s 0 (- (string-length s) 1))\n            (substring s 1 (- (string-length s)\
    \ 1))\n            (substring s 0 (- (string-length s) 1)))]\n          [else\
    \ (cons (car s)\n                     (solve\n                      (substring\
    \ s 0 (- (string-length s) 1))\n                      (substring s 1 (- (string-length\
    \ s) 1))\n                      (string-downcase (substring s 0 (- (string-length\
    \ s) 1)))))))", "  (cond\n    [(empty? s) s]\n    [(let* ([last-char (first s)\n\
    \              first-char (first s)])\n         (cond\n          [(char? (first\
    \ last-char))\n           (cond\n            [(char? (first first-char))\n   \
    \          (string->chars (string (string->chars (char->string (first last-char)))\n\
    \                            (char->string (first first-char)))]\n           \
    \ [else (string->chars (string (string->chars (char->string (first last-char)))\n\
    \                                (string->string (string first-char))))])]\n \
    \         [else (string->chars (string (string->chars (char->string (first last-char)))\n\
    \                                 (char->string (first first-char)))]\n      \
    \    [else (string->chars (string (string->chars (char->string (first last-char)))\n\
    \                                 (char->string (first first-char)))]\n      \
    \    [else (string->chars (string (string->chars (char->string (first last-char)))\n\
    \                                 (char->string (first first-char)))]))]\n   \
    \     [else (string->chars (string (string->chars (char->string (first last-char)))\n\
    \                                 (char->string (first first-char)))]\n      \
    \  [else (string->chars (string (string->chars (char->string (first last-char)))\n\
    \                                 (char->string (first first-char)))]\n      \
    \  [else (string->chars (string (string->chars (char->string (first last-char)))\n\
    \                                 (char->string (first first-char)))]\n      \
    \  [else (string->chars (string (string->chars (char->string (first last-char)))\n\
    \                                 (char->string (first first-char)))]\n      \
    \  [else (string->chars (string (string->chars (char->string (first last-char)))\n\
    \                                 (char->string (first first-char)))]\n      \
    \  [else (string->chars (string (string->chars (char->string (first last-char)))\n\
    \                                 (char->string (first first-char)))]\n      \
    \  [else (string->chars (string (string->chars (char->string (first last-char)))\n\
    \                                 (char->string (first first-char)))]\n      \
    \  [else (string->chars (string (string->chars (char->string (first last-char)))\n\
    \                                 (char->string (first first-char)))]\n      \
    \  [else (string->chars (string (string->chars (char->string (first last-char)))\n\
    \                                 (char->string (first first-char)))]\n      \
    \  [else (string->chars (string (string->chars (char->string (first last-char)))\n\
    \                                 (char->string (first first-char)))]\n      \
    \  [else (string->chars (string (string->", "  (cond ( (empty? s) s) \n      \
    \  ( (char? (car s)) (let ((c car s)) (char-upper-case? (car c)) (char-lower-case?\
    \ (car c)) (solve (sub1 (cdr c))))\n               (char? (cadr s)) (car s)\n\
    \               (else (cdr s))) ))\n", "  (cond ((empty? s) s)\n        ((char?\
    \ s) (string-append (string->char (string->lower s)) (string->char (string->upper\
    \ s))))\n        (else (cons (car s) (solve (cdr s))))))\n", "  ;; We use memoization\
    \ for caching the result of each step\n  (let ([cache (make-hash)])\n    (cond\
    \ [(empty? s) (make-string length s))]\n          [(hash-has-key? cache s) (hash-get\
    \ cache s)]\n          [(not (letter? (first s))) (make-string length s)]\n  \
    \        [else (let ([c (first s)])\n                    (let ([lower (letter->lower-case\
    \ c)])\n                      (let ([upper (letter->upper-case c)])\n        \
    \                (hash-set cache c lower)\n                        (hash-set cache\
    \ c upper)\n                        (cond [(not (hash-has-key? cache lower)) lower]\n\
    \                              [(not (hash-has-key? cache upper)) upper]\n   \
    \                           [else (concat lower upper)]))]))]))\n</code>\n<|/\
    \ a dscore=2 |>\n<| c |>\nThat is a nice solution. I had not considered the problem\
    \ this way and used a hash as you suggested. I appreciate the alternate solution\
    \ you gave. Thanks.\n<|/ c |>\n<| c |>\nThis is cool, but I thought that since\
    \ it's so much faster than the accepted solution that it's worth noting that the\
    \ algorithm itself is not particularly efficient. E.g. `solve` runs in `O(2n^2)`\
    \ where `n` is the length of the string, and `O(2n^2)` means the entire algorithm\
    \ can take up to `O(n)` time, depending on the length of `n`.\n<|/ c |>\n<| c\
    \ |>\nI think you can do better than that. Look at the solution I give in my answer.\
    \ This will run in `O(n)`\n<|/ c |>\n<| c |>\nThe only thing wrong with my solution\
    \ is that I am still calling `hash-set` twice. One could use `hash-set!` instead\
    \ of `hash-set`.\n<|/ c |>\n<| c |>\nYes. I agree. `hash-set!` would be better\
    \ than `hash-set`\n<|/ c |>\n<| a |>\nJust for the sake of argument, I'd like\
    \ to point out that there is indeed a solution in Scheme, and it's also quite\
    \ a bit more efficient than a hash-based solution which also runs in O(2n^2).\n\
    Here's a solution which runs in O(n), even though it's rather ugly. I've tested\
    \ it with solutions I've tested for other languages, and it works just fine. \n\
    <code>", "  (let loop ((i 0)\n             (res \"\"))\n    (if (< i 0)\n    \
    \    (reverse res)\n        (let ((ch (char s i)))\n          (if (char? (char\
    \ s i))\n              (if (char=? (char-upcase ch) (char-upcase (char-lower ch)))\n\
    \                  (loop (+ i 1)\n                         (string-append res\
    \ (char-upcase ch)))\n                (loop (+ i 1)\n                        \
    \ (string-append res (char-lower ch))))\n              (loop (+ i 1)\n       \
    \              (string-append res ch)))))))\n</code>\n<|/ a dscore=0 |>\n<| c\
    \ |>\nThe question states there are two solutions and no explanation of what the\
    \ functions should do.  This is no answer to the question and should be deleted.\n\
    <|/ c |>\n<| c |>\nWhat I understood that he wanted to achieve is to make the\
    \ string reverse using recursion. I guess the code will be clear with the explanation.\n\
    <|/ c |>\n<| c |>\nI tried to give a minimal working answer with a small explanation.\n\
    <|/ c |>\n<| a dscore=0 |>\nYou can reverse a string without using recursion by\
    \ using an auxiliary variable:\n<code>", "  (cond\n    [(empty? s) \"\"]\n   \
    \ [(empty? (rest s)) (substring s 0 -1)]\n    [(equal? (first s) (first s)) (substring\
    \ s (rest s) \"\")]\n    [else (substring s (rest s) (make-string (first s) (second\
    \ s) (third s))])\n  ))\n", "  (cond ((empty? s)\n         '())\n        ((char?\
    \ (car s))\n         (string->list\n          (reverse\n           (string-map\
    \ string->char\n                       (string->list s)))))\n        (else (string->list\
    \ s))))\n", "  (cond\n    [(null? s)  (quote ())]\n    [(or (char? (car s)) (char?\
    \ (caar s)))\n     (cond\n       [(char? (car s)) (concat (list (char->integer\
    \ (car s)) 65535) (list (char->integer (caar s)) -65535))]\n       [(char? (caar\
    \ s)) (concat (list (char->integer (car s)) -65535) (list (char->integer (caar\
    \ s)) 65535))]\n       [else (cons (char->integer (car s)) (cons (char->integer\
    \ (caar s)) '()))]\n       )]\n    [else (cons (char->integer (car s)) (cons (char->integer\
    \ (caar s)) '()))]\n    [(list? (car s)) (cons '() (solve (car s))) (list (cons\
    \ (car s) (solve (car s))))]\n    [else (cons (char->integer (car s)) (cons (char->integer\
    \ (caar s)) '()))]\n    [else (solve (car s))]\n    )\n  )\n  )\n", "  (cond [(or\
    \ (string=? (reverse s) \"\") (empty? (reverse s)))\n         (reverse s)]\n \
    \       [(or (char=? (car s) #\\a)\n             (char=? (car s) #\\b))\n    \
    \     (cons (char-upper (car s)) (reverse (rest s)))]\n        [else\n       \
    \  (cons (car s) (reverse (rest s)))]))\n", "  (if (null? s)\n      (list-reverse\
    \ s)\n      (if (char? s)\n          (if (string? (char-code (first s))) \n  \
    \            (if (string? (char-code (first s))) \n                  (define result\
    \ (if (char-upper? (first s)) (list-append (cons (char-upper (first s)) result)\
    \ result) result))\n                  (if (char-lower? (first s)) (list-append\
    \ (cons (char-lower (first s)) result) result) result))\n              result)\n\
    \          (define result (list-append (cons (first s) result) result))\n    \
    \      result))))\n", "  (cond [(empty? s) '()]\n        [(character? (car s))\
    \ (cons (case-char (car s)) (reverse (case-char (car s))))]\n        [else (cons\
    \ (car s) (solve (cdr s)))]))\n", "  (cond\n    [(empty? s) (make-string (string-length\
    \ s) #\\0)]\n    [(character? (first s)) (apply string-case (make-string (string-length\
    \ s) #\\0))]\n    [else (apply string-case (make-string (string-length s) #\\\
    0))]))\n", "  (cond\n    ((null? s)\n     (reverse s))\n    ((char? s)\n     (cond\n\
    \       ((char= s (string-downcase s))\n        (reverse (string-upcase (substring\
    \ s 0 (string-length s)))))\n       ((char= s (string-upcase (substring s 0 (string-length\
    \ s))))\n        (reverse (string-downcase (substring s 0 (string-length s)))))\n\
    \       ((else (string-downcase s))\n        (string-upcase (substring s 0 (string-length\
    \ s)))))))\n  (string-upcase s))\n", "  (cond\n    ((null? s) s)\n    ((char-literal?\
    \ #\\A) (cond (char-literal? (substring s 0 (char-index s #\\A)))\n          \
    \                 (char-literal? (substring s 1 (char-index s #\\A)))\n      \
    \                     (else (substring s 0 (char-index s #\\A))))\n     ((char-literal?\
    \ #\\Z) (cond (char-literal? (substring s 0 (char-index s #\\Z)))\n          \
    \                 (char-literal? (substring s 1 (char-index s #\\Z)))\n      \
    \                     (else (substring s 0 (char-index s #\\Z))))\n     ((char-literal?\
    \ #\\a) (cond (char-literal? (substring s 0 (char-index s #\\a)))\n          \
    \                 (char-literal? (substring s 1 (char-index s #\\a)))\n      \
    \                     (else (substring s 0 (char-index s #\\a))))\n     ((char-literal?\
    \ #\\z) (cond (char-literal? (substring s 0 (char-index s #\\z)))\n          \
    \                 (char-literal? (substring s 1 (char-index s #\\z)))\n      \
    \                     (else (substring s 0 (char-index s #\\z))))\n     ((char-literal?\
    \ #\\0) (cond (char-literal? (substring s 0 (char-index s #\\0)))\n          \
    \                 (char-literal? (substring s 1 (char-index s #\\0)))\n      \
    \                     (else (substring s 0 (char-index s #\\0))))\n     ((char-literal?\
    \ #\\9) (cond (char-literal? (substring s 0 (char-index s #\\9)))\n          \
    \                 (char-literal? (substring s 1 (char-index s #\\9)))\n      \
    \                     (else (substring s 0 (char-index s #\\9))))\n     ((char-literal?\
    \ #\\z) (cond (char-literal? (substring s 0 (char-index s #\\z)))\n          \
    \                 (char-literal? (substring s 1 (char-index s #\\z)))\n      \
    \                     (else (substring s 0 (char-index s #\\z))))\n     ((char-literal?\
    \ #\\9) (cond (char-literal? (substring s 0 (char-index s #\\9)))\n          \
    \                 (char-literal? (substring s 1 (char-index s #\\9)))\n      \
    \                     (else (substring s 0 (", "  (if (empty? s)\n      s\n  \
    \    (let ([char (first s)])\n        (if (char-? char)\n            (cond\n \
    \             [(char-upper? char)\n               (substring (substring s (+ 1\
    \ start) end) start end)]\n              [(char-lower? char)\n               (substring\
    \ (substring s (+ start 1) end) start end)]\n              [(char-digit? char)\n\
    \               (substring s (+ start 1) end)]\n              [(char-symbol? char)\n\
    \               (substring s (+ start 1) end)]\n              [else\n        \
    \       (substring s (+ start 1) end)]\n            )\n            (substring\
    \ s (+ start 1) end))))))\n", "  (string-reverse (racket: string-map #(lambda\
    \ (c) (if (char-upper? (char-code c)) (char-code (char-code c))\n            \
    \                              (char-code (car s))\n                         \
    \                 (car s))) s))\n)\n", "  (if (null? s)\n      '()\n      (let\
    \ ([x (char->integer s)])\n        (let ([r (char->integer \"A\")])\n        \
    \  (cond ((char->integer s) (not (< x r))\n                  (list-append\n  \
    \                 (substring s 0 x)\n                   (reverse (substring s\
    \ x x)))\n                   (substring s x))\n                 ((< x r) (list-append\
    \ (substring s 0 x) (substring s x)))\n                 (else (list-append\n \
    \                       (substring s 0 x)\n                        (substring\
    \ s x)\n                        (reverse (substring s x)))))))))\n", "  (cond\
    \ [(empty? s)\n         (string-append \"(no letters)\" empty)]\n        [(cons?\
    \ s)\n         (string-append \"(\" (reverse (map string-case-of s))\n       \
    \                \")\" empty)]\n        [else (string-append (reverse (map string-case-of\
    \ (map string->symbol (symbol->string s))))\n                           empty)]))\n",
  "  (cond\n    [(empty? s)  \"\"]\n    [(member? (car s) '(upper lower capitalized))\
    \ (reverse (car s)) (reverse (upper (car s)) (lower (car s)) (capitalized (car\
    \ s)) (reverse (cdr s)))]\n    [else               (car s)]))\n", "  (if (null?\
    \ s)\n      '()\n      (if (char? (car s))\n          (if (char? (cadr s))\n \
    \             (if (char? (caddr s))\n                  (if (char? (cadddr s))\n\
    \                      (if (char? (cadddddr s))\n                          (if\
    \ (char? (caddddddr s))\n                              (if (char? (cadddddddr\
    \ s))\n                                  (if (char? (caddddddddr s))\n       \
    \                               (if (char? (cadddddddddr s))\n               \
    \                           (if (char? (caddddddddddr s))\n                  \
    \                            (if (char? (caddddddddddr s))\n                 \
    \                                 (if (char? (cadddddddddddr s))\n           \
    \                                           (if (char? (cadddddddddddr s))\n \
    \                                                         (if (char? (cadddddddddddr\
    \ s))\n                                                              (if (char?\
    \ (cadddddddddddr s))\n                                                      \
    \            (if (char? (cadddddddddddr s))\n                                \
    \                                      (if (char? (cadddddddddddr s))\n      \
    \                                                                    (if (char?\
    \ (cadddddddddddr s))\n                                                      \
    \                        (if (char? (cadddddddddddr s))\n                    \
    \                                                              (if (char? (cadddddddddddr\
    \ s))\n                                                                      \
    \                (if (char? (cadddddddddddr s))\n                            \
    \                                                              (if (char? (cadddddddddddr\
    \ s))\n                                                                      \
    \                        (if (char? (cadddddddddddr s))\n                    \
    \                                                                            \
    \  (if (char? (cadddddddddddr s))\n                                          \
    \                                                            (if (char? (cadddddddddddr\
    \ s))\n                                                                      \
    \                                    (if (char? (cadddddddddddr s))\n        \
    \                                                                            \
    \                          (if (char? (cadddddddddddr s))\n                  \
    \                                                                            \
    \                    (if (char? (cadddddddddddr s))\n                        \
    \                                                                            \
    \                  (if (char? (cadddddddddddr s))\n                          \
    \                                                                            \
    \                    (if (char? (cadddddddddddr s))\n                        \
    \                                                                            \
    \                          (if (char? (cadddddddddddr s))\n                  \
    \                                                                            \
    \                                    (if (char? (cadddddddddddr s))\n        \
    \                                                                            \
    \                                            (if (char? (cadddddddddddr s))\n\
    \                                                                            \
    \                                                    (if (char? (cadddddddddddr\
    \ s))\n                                                                      \
    \                                                          (if (char? (cadddddddddddr\
    \ s))\n                                                                      \
    \                                                          (if (char? (cadddddddddddr\
    \ s))\n                                                                      \
    \                                                          (if (char? (cadddddddddddr\
    \ s))\n                                                                      \
    \                                                          (if (char? (cadddddddddddr\
    \ s))\n                                                                      \
    \                                                          (if (char? (cadddddddddd",
  "  (if (string? s)\n      (if (char? (string-ref s 0))\n          (if (char? (string-ref\
    \ s 1))\n              (if (char? (string-ref s 2))\n                  (if (char?\
    \ (string-ref s 3))\n                      (if (char? (string-ref s 4))\n    \
    \                      (if (char? (string-ref s 5))\n                        \
    \      (if (char? (string-ref s 6))\n                                  (if (char?\
    \ (string-ref s 7))\n                                      (if (char? (string-ref\
    \ s 8))\n                                          (if (char? (string-ref s 9))\n\
    \                                              (if (char? (string-ref s 10))\n\
    \                                                  (if (char? (string-ref s 11))\n\
    \                                                      (if (char? (string-ref\
    \ s 12))\n                                                          (if (char?\
    \ (string-ref s 13))\n                                                       \
    \       (if (char? (string-ref s 14))\n                                      \
    \                          (if (char? (string-ref s 15))\n                   \
    \                                                 (if (char? (string-ref s 16))\n\
    \                                                                        (if (char?\
    \ (string-ref s 17))\n                                                       \
    \                     (if (char? (string-ref s 18))\n                        \
    \                                                        (if (char? (string-ref\
    \ s 19))\n                                                                   \
    \                 (if (char? (string-ref s 20))\n                            \
    \                                                            (if (char? (string-ref\
    \ s 21))\n                                                                   \
    \                         (if (char? (string-ref s 22))\n                    \
    \                                                                            (if\
    \ (char? (string-ref s 23))\n                                                \
    \                                                    (if (char? (string-ref s\
    \ 24))\n                                                                     \
    \                                   (if (char? (string-ref s 25))\n          \
    \                                                                            \
    \                      (if (char? (string-ref s 26))\n                       \
    \                                                                            \
    \             (if (char? (string-ref s 27))\n                                \
    \                                                                            \
    \        (if (char? (string-ref s 28))\n                                     \
    \                                                                            \
    \       (if (char? (string-ref s 29))\n                                      \
    \                                                                            \
    \          (if (char? (string-ref s 30))\n                                   \
    \                                                                            \
    \                 (if (char? (string-ref s 31))\n                            \
    \                                                                            \
    \                            (if (char? (string-ref s 32))\n                 \
    \                                                                            \
    \                                           (if (char? (string-ref s 33))\n  \
    \                                                                            \
    \                                                              (if (char? (string-ref\
    \ s 34))\n                                                                   \
    \                                                                            \
    \ (if (char? (string-ref s 35))\n                                            \
    \                                                                            \
    \                            (if (char? (string-ref s 36))\n                 \
    \                                                                            \
    \                                                           (if (char? (string-ref\
    \ s 37))\n                                                                   \
    \                                                                            \
    \             (if (char? (string-ref s 38))\n                                \
    \                                                                            \
    \                                                    (if (char? (string-ref s\
    \ 39))\n                                                                     \
    \                                                                            \
    \                   (if (char? (string-ref s 40))\n                          \
    \                                                                            \
    \                                                                  (if (char?\
    \ (string-ref s 41))\n                                                       \
    \                                                                            \
    \                                         (if (char? (string-ref s 42))\n    \
    \                                                                            \
    \                                                                            \
    \                    (if (char? (string-ref s 43))\n                         \
    \                                                                            \
    \                                                                            \
    \   ", "  (cond [(zero? s) s]\n        [(or (char->integer (car s)) (char->integer\
    \ (char-code (car s))))\n         (if (char->integer (car s)) \n             (char->integer\
    \ (char-code (car s)))\n             (char->integer (char-code (car s)))\n   \
    \          (reverse s))]\n        [else \n         (if (char->integer (car s))\
    \ \n             (char->integer (char-code (car s))) \n             (char->integer\
    \ (char-code (car s))))\n         (cons (car s) (solve (string-reverse (substring\
    \ s (+ 1 (string-length s))))))]))\n</code>\n<|/ a tags=scheme,lisp,racket,recursion\
    \ |>\n<| a dscore=0 |>\nHere is a simple solution in Racket using Racket Scheme\
    \ syntax:\n<code>", "  (if (or (not (empty? s)) (char->integer (first s)) (char->integer\
    \ (first s) #lt))\n      (if (or (char->integer (first s) #gt) (string-ref s 1))\n\
    \          (let ((i (char->integer (first s) #lt))\n                (j (char->integer\
    \ (first s) #gt)))\n            (set! s (string->list (reverse s))))\n      (set!\
    \ s (reverse s)))\n  s)\n</code>\n<code>\n#lang racket\n", "  (cond [(string?\
    \ s) (string-reverse (upper-case (lower-case s)))]\n        [else (lower-case\
    \ s)]))\n", "  (cond [(string-empty? s) s]\n        [(member (char->string #\\\
    a) s) \n         (make-string (string->chars s)\n                       (sub (string->chars\
    \ s) (length s))\n                       (string->chars (make-string (string->chars\
    \ s) \n                                                 (string->chars #\\a) \n\
    \                                                 #\\a))\n                   \
    \    (string->chars (make-string (string->chars s)\n                         \
    \                        #\\a))\n                       (string->chars (make-string\
    \ (string->chars s)\n                                                 #\\a))\n\
    \                       (string->chars (make-string (string->chars s)\n      \
    \                                           #\\a)))]\n        [(member (char->string\
    \ #\\A) s) \n         (make-string (string->chars s)\n                       (sub\
    \ (string->chars s) (length s))\n                       (string->chars (make-string\
    \ (string->chars s) \n                                                 (string->chars\
    \ #\\A) \n                                                 #\\A))\n          \
    \             (string->chars (make-string (string->chars s)\n                \
    \                                 #\\A))\n                       (string->chars\
    \ (make-string (string->chars s)\n                                           \
    \      #\\A))\n                       (string->chars (make-string (string->chars\
    \ s)\n                                                 #\\A)))]\n        [(member\
    \ (char->string #\\a) s) (make-string (string->chars s)\n                    \
    \                               (string->chars (make-string (string->chars s)\n\
    \                                                                            \
    \   (string->chars #\\a) \n                                                  \
    \                             (string->chars #\\A))\n                        \
    \                                                       (string->chars (make-string\
    \ (string->chars s)\n                                                        \
    \                                                     #\\a) \n               \
    \                                                                            \
    \                  #\\A))\n                                                  \
    \ (string->chars (make-string (string->chars s)\n                            \
    \                                                                            \
    \     #\\a) \n                                                               \
    \                                              #\\A))\n                      \
    \                             (string->chars (make-string (string->chars s)\n\
    \                                                                            \
    \                                 #\\a) \n                                   \
    \                                                                          #\\\
    A))\n                                                   (string->chars (make-string\
    \ (string->chars s)\n                                                        \
    \                                                     #\\a) \n               \
    \                                                                            \
    \                  #\\A))])\n        [(member (char->string #\\A) s) (make-string\
    \ (string->chars s)\n                                                   (string->chars\
    \ (make-string (string->chars s)\n                                           \
    \                                    (string->chars #\\A) \n                 \
    \                                                              (string->chars\
    \ #\\a))\n                                                                   \
    \            (string->chars (make-string (string->chars s)\n                 \
    \                                                                            \
    \                #\\A"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
