name: HumanEval_51_remove_vowels
language: rkt
prompt: "#lang racket\n\n;; remove_vowels is a function that takes string and returns\
  \ string without vowels.\n;; >>> (remove_vowels \"\")\n;; \"\"\n;; >>> (remove_vowels\
  \ \"abcdef\")\n;; \"bcdf\"\n;; >>> (remove_vowels \"aaaaa\")\n;; \"\"\n;; >>> (remove_vowels\
  \ \"aaBAA\")\n;; \"B\"\n;; >>> (remove_vowels \"zbcd\")\n;; \"zbcd\"\n(define (remove_vowels\
  \ text)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate remove_vowels))\n\
  \    (check-equal? (candidate \"\") \"\")\n    (check-equal? (candidate \"abcdef\n\
  ghijklm\") \"bcdf\nghjklm\")\n    (check-equal? (candidate \"fedcba\") \"fdcb\"\
  )\n    (check-equal? (candidate \"eeeee\") \"\")\n    (check-equal? (candidate \"\
  acBAA\") \"cB\")\n    (check-equal? (candidate \"EcBOO\") \"cB\")\n    (check-equal?\
  \ (candidate \"ybcd\") \"ybcd\")\n))\n\n(test-humaneval)"
completions: ["  (re-replace #rx (map (\u03BB (char) (cond [(or (char-set char) (char-set\
    \ \"a\"))\n                                     (string \"\")]\n             \
    \                      [(char-set char) (string \"\")]\n                     \
    \              [else (concat #rx (list (char-set char)))])\n                 \
    \       text)))\n", "  (cond\n    [(empty? text) \"\"]\n    [(equal? (first text)\
    \ \"\") (first text)]\n    [(equal? (first text) \"a\") (remove-vowels (rest text))]\
    \ \n    [(equal? (first text) \"o\") (remove-vowels (rest text))]\n    [(equal?\
    \ (first text) \"e\") (remove-vowels (rest text))] \n    [(equal? (first text)\
    \ \"i\") (remove-vowels (rest text))] \n    [(equal? (first text) \"u\") (remove-vowels\
    \ (rest text))]\n    [else (first text) (remove-vowels (rest text))]))\n", " \
    \ (cond\n    [(empty? text) text]\n    [(= (char-code (car text)) 65) (string-append\
    \ \"a\" (remove_vowels (cdr text)))]\n    [(= (char-code (car text)) 66) (string-append\
    \ \"e\" (remove_vowels (cdr text)))]\n    [(= (char-code (car text)) 67) (string-append\
    \ \"i\" (remove_vowels (cdr text)))]\n    [(= (char-code (car text)) 68) (string-append\
    \ \"o\" (remove_vowels (cdr text)))]\n    [(= (char-code (car text)) 69) (string-append\
    \ \"u\" (remove_vowels (cdr text)))]\n    [(= (char-code (car text)) 70) (string-append\
    \ \"A\" (remove_vowels (cdr text)))]\n    [(= (char-code (car text)) 71) (string-append\
    \ \"E\" (remove_vowels (cdr text)))]\n    [(= (char-code (car text)) 72) (string-append\
    \ \"I\" (remove_vowels (cdr text)))]\n    [(= (char-code (car text)) 73) (string-append\
    \ \"O\" (remove_vowels (cdr text)))]\n    [(= (char-code (car text)) 74) (string-append\
    \ \"U\" (remove_vowels (cdr text)))]\n    [(= (char-code (car text)) 75) (string-append\
    \ \"\xC4\" (remove_vowels (cdr text)))]\n    [(= (char-code (car text)) 76) (string-append\
    \ \"\xD6\" (remove_vowels (cdr text)))]\n    [(= (char-code (car text)) 77) (string-append\
    \ \"\xDC\" (remove_vowels (cdr text)))]\n    [(= (char-code (car text)) 78) (string-append\
    \ \"\xDF\" (remove_vowels (cdr text)))]\n    [else (cons (car text) (remove_vowels\
    \ (cdr text)))]))\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 tags=racket,scheme\
    \ |>\nHere is a solution using set! that does not use set-car! or set-cdr!.\n\
    <code>", "  (cond\n    [(empty? text) empty]\n    [(vowel?(car text)) (remove\
    \ (car text) text)]\n    [else (cons (car text) (remove_vowels (remove (car text)\
    \ text))) ]))\n", "  (cond\n    [(empty? text) empty]\n    [else (append (filter\
    \ (lambda (x) (not (equal? (char-code x) #\\a\\e\\i\\o\\u\\y\\y\\Z))) text)\n\
    \                (filter (lambda (x) (not (equal? (char-code x) #\\b\\c\\g\\j\\\
    k\\m\\o\\p\\y\\z\\Z))) text)\n                (filter (lambda (x) (not (equal?\
    \ (char-code x) #\\m\\n\\r\\t\\v\\Z))) text)\n                (filter (lambda\
    \ (x) (not (equal? (char-code x) #\\Z))) text)\n                (filter (lambda\
    \ (x) (not (equal? (char-code x) #\\a\\e\\i\\o\\u\\y\\z\\Z))) text)\n        \
    \        (filter (lambda (x) (not (equal? (char-code x) #\\B\\C\\G\\J\\K\\M\\\
    O\\P\\Y\\Z\\Z))) text)\n                (filter (lambda (x) (not (equal? (char-code\
    \ x) #\\m\\n\\r\\t\\v)))\n                (filter (lambda (x) (not (equal? (char-code\
    \ x) #\\Z))) text)\n                (filter (lambda (x) (not (equal? (char-code\
    \ x) #\\a\\e\\i\\o\\u\\y)))\n                (filter (lambda (x) (not (equal?\
    \ (char-code x) #\\b\\c\\g\\j\\k\\m\\o\\p\\y\\z\\Z)))\n                (filter\
    \ (lambda (x) (not (equal? (char-code x) #\\m\\n\\r\\t\\v\\Z)))\n            \
    \    (filter (lambda (x) (not (equal? (char-code x) #\\Z)))\n                (filter\
    \ (lambda (x) (not (equal? (char-code x) #\\a\\e\\i\\o\\u\\y\\z\\Z)))\n      \
    \          (filter (lambda (x) (not (equal? (char-code x) #\\B\\C\\G\\J\\K\\M\\\
    O\\P\\Y\\Z\\Z)))\n                (filter (lambda (x) (not (equal? (char-code\
    \ x) #\\m\\n\\r\\t\\v))))]\n    ))\n", "  (define (helper index text)\n    (cond\
    \ [(<= index 0) (string text)]\n          [(char=? (char-code (car text)) #\\\
    a) (helper (- index 1) (cdr text))]\n          [(char=? (char-code (car text))\
    \ #\\e) (helper (- index 1) (cdr text))]\n          [(char=? (char-code (car text))\
    \ #\\i) (helper (- index 1) (cdr text))]\n          [(char=? (char-code (car text))\
    \ #\\o) (helper (- index 1) (cdr text))]\n          [(char=? (char-code (car text))\
    \ #\\u) (helper (- index 1) (cdr text))]\n          [else (helper (- index 1)\
    \ (cdr text))]))\n  (helper 0 text))\n", "  (cond\n    [(empty? text) \"\"]\n\
    \    [else (if (empty? (cdr text))\n              (cons (car text) (remove_vowels\
    \ (cdr text)))\n              (cons (car text) (remove_vowels (cdr (cdr text))))]))\n",
  "  (cond [(empty? text) \"\"]\n        [(member #\\a text)\n         (remove (member\
    \ #\\a text) text)]\n        [else (append text (remove_vowels (rest text))) ]\n\
    \  ))\n", "  (filter #(or (string=? (char-code %) 44) (string=? (char-code %)\
    \ 46))\n          text))", "  (let ([chars (string->list text)]) \n    (remove-if\
    \ (string=? 'a) (remove-if (string=? 'A) chars) chars)\n    (remove-if (string=?\
    \ 'e) (remove-if (string=? 'E) chars) chars)\n    (remove-if (string=? 'i) (remove-if\
    \ (string=? 'I) chars) chars)\n    (remove-if (string=? 'o) (remove-if (string=?\
    \ 'O) chars) chars)\n    (remove-if (string=? 'u) (remove-if (string=? 'U) chars)\
    \ chars)\n    (remove-if (string=? 'y) (remove-if (string=? 'Y) chars) chars)\n\
    \    (string->string chars)))\n</code>\n<|/ a |>\n<| c |>\nOk, your implementation\
    \ is correct. But how about this one? https://gist.github.com/4184942 it returns\
    \ `\"B\"` in `aaBAA` but returns `\"\"` in `zBCD`.\n<|/ c |>\n<| c |>\n, I've\
    \ added a new solution that returns \"B\" in both cases you mentioned.\n<|/ c\
    \ |>\n<| a tags=string,scheme |>\nThis can be done fairly elegantly with a regex\
    \ substitution:\n<code>", "  (cond\n    [(empty? text) \"\"]\n    [else\n    \
    \ (cond\n       [(string=? #\"a\" text) (substring text 0 (string-length text)\
    \  1)]\n       [(string=? #\"e\" text) (substring text 0 (string-length text)\
    \  1)]\n       [(string=? #\"i\" text) (substring text 0 (string-length text)\
    \  1)]\n       [(string=? #\"o\" text) (substring text 0 (string-length text)\
    \  1)]\n       [(string=? #\"u\" text) (substring text 0 (string-length text)\
    \  1)]\n       [(string=? #\"A\" text) (substring text 0 (string-length text)\
    \  1)]\n       [(string=? #\"E\" text) (substring text 0 (string-length text)\
    \  1)]\n       [(string=? #\"I\" text) (substring text 0 (string-length text)\
    \  1)]\n       [(string=? #\"O\" text) (substring text 0 (string-length text)\
    \  1)]\n       [(string=? #\"U\" text) (substring text 0 (string-length text)\
    \  1)]\n       [(string=? #\"B\" text) (substring text 0 (string-length text)\
    \  1)]\n       [(string=? #\"Z\" text) (substring text 0 (string-length text)\
    \  1)]\n       [(string=? #\"z\" text) (substring text 0 (string-length text)\
    \  1)]\n       [(string=? #\"\xF1\" text) (substring text 0 (string-length text)\
    \  1)]\n       [(string=? #\"\xD1\" text) (substring text 0 (string-length text)\
    \  1)]\n       [(string=? #\"\xD1\" text) (substring text 0 (string-length text)\
    \  1)]\n       [(string=? #\"\xD1\" text) (substring text 0 (string-length text)\
    \  1)]\n       [(string=? #\"\xD1\" text) (substring text 0 (string-length text)\
    \  1)]\n       [(string=? #\"\xD1\" text) (substring text 0 (string-length text)\
    \  1)]\n       [(string=? #\"\xD1\" text) (substring text 0 (string-length text)\
    \  1)]\n       [(string=? #\"\xD1\" text) (substring text 0 (string-length text)\
    \  1)]\n       [(string=? #\"\xD1\" text) (substring text 0 (string-length text)\
    \  1)]\n       [(string=? #\"\xD1\" text) (substring text 0 (string-length text)\
    \  1)]\n       [(string=? #\"\xD1\" text) (substring text 0 (string-length text)\
    \  1)]\n       [(string", "  (cond\n    [(empty? text) \"\"]\n    [(not (member?\
    \ (first text) '([a (A) (e E) i (I) (o O) u (U) (y Y) (AA aa AOO ao OUU ou))))\n\
    \      (cons (first text) (remove_vowels (rest text)))]))\n", "  (cond\n    [(empty?\
    \ text) \"\"]\n    [(consonant? (first text)) (remove_vowels (rest text))\n  \
    \   (first text)]\n    [else (cons (first text) (remove_vowels (rest text)))]))\n",
  "  (cond (empty? text)\n         '()\n         (cons\n          (filter (\u03BB\
    \ (x) (equal? x #\\a) (equal? x #\\e) (equal? x #\\i) (equal? x #\\o) (equal?\
    \ x #\\u))\n                   (rest (subseq text 0 (- (length text) 1)))\n  \
    \        (filter (\u03BB (x) (equal? x #\\A) (equal? x #\\E) (equal? x #\\I) (equal?\
    \ x #\\O) (equal? x #\\U))\n                   (rest (subseq text 0 (- (length\
    \ text) 1)))\n          (filter (\u03BB (x) (equal? x #\\z) (equal? x #\\Z))\n\
    \                   (rest (subseq text 0 (- (length text) 1))))\n         (remove_vowels\
    \ (rest text))))))\n", "  (cond\n    [(empty? text) \"\"]\n    [(member \"aeiou\"\
    \ text) \"\"]\n    [else (cons \n            (first text) (remove_vowels (rest\
    \ text))) ]))\n", "  (if (string=? text \"\")\n      \"\"\n      (let ([vowels\
    \ '(a e i o u)])\n        (string->list (remove-if (lambda (elem)\n          \
    \                         (member-of elem vowels))\n                         \
    \      text)))))\n", "  (let ([vowels (list 'a \"e\" \"i\" \"o\" \"u\")]\n   \
    \     (fn [str] \n          (cond [(equal? (first str) 'a) (substring str 1)]\n\
    \                [else\n                 (cond [(equal? (first str) 'e) (substring\
    \ str 2)]\n                       [(equal? (first str) 'i) (substring str 3)]\n\
    \                       [(equal? (first str) 'o) (substring str 4)]\n        \
    \               [(equal? (first str) 'u) (substring str 5)]\n                \
    \       [(equal? (first str) 'A) (substring str 2)]\n                       [(equal?\
    \ (first str) 'E) (substring str 3)]\n                       [(equal? (first str)\
    \ 'I) (substring str 4)]\n                       [(equal? (first str) 'O) (substring\
    \ str 5)]\n                       [(equal? (first str) 'U) (substring str 6)]\n\
    \                       [(equal? (first str) 'B) (substring str 3)]\n        \
    \               [(equal? (first str) 'Z) (substring str 4)]))]))\n    (map (fn\
    \ [char] (char '(char (first char) \n                               (second char)\
    \ \n                               (third char) \n                           \
    \    (fourth char) \n                               (fifth char) \n          \
    \                     (sixth char) \n                               (seventh char)\
    \ \n                               (eighth char) \n                          \
    \     (ninth char))) text)\n         vowels)))\n", "  (let* ((vowels '(a e i o\
    \ u))\n         (not-vowels (set! vowels (set-difference vowels text))))\n   \
    \ (string->symbol (set-or-append* vowels not-vowels))))\n", "  (cond [(empty?\
    \ text) \"\"]\n        [(member (char->string #\\a #\\e #\\i #\\o #\\u)\n    \
    \               (char->string text)) \n         #\\z]\n        [else (cons (car\
    \ text)\n                    (remove_vowels (cdr text)))]))\n", "  (cond\n   \
    \ [(empty? text) \"\"]\n    [(member? (first text) vowels) (cons (first text)\
    \ (remove_vowels (rest text))) ]\n    [else (cons (first text) (remove_vowels\
    \ (rest text))) ]\n    )\n  )\n", "  (let loop ((text text))\n    (cond\n    \
    \  [(empty? text)\n       (string->symbol (string->string text))]\n      [(string-contains?\
    \ vowels text)\n       (cons (string-ref text (string-position text \"a\")) \n\
    \            (loop (string-tail text)))]\n      [else\n       (loop (substring\
    \ text 0 (string-length text)))])))\n", "  (if (empty? text)\n      \"\"\n   \
    \   (append-string \"\"\n                  (filter (lambda (c) (and (vowel? (c))\
    \ (not (equal? (c) 'z'))))\n                          (map char->int (map string->list\
    \ (string->list text))))))) ;; #lang racket\n", "  (if (string? text)\n      (let\
    \ ([vowels '(a e i o u)])\n        (cond [(empty? vowels)\n               (string!\
    \ text)\n               (append text 'a)\n               (append text 'e)\n  \
    \             (append text 'i)\n               (append text 'o)\n            \
    \   (append text 'u)]))\n      '()))\n", "  (cond [(empty? text) \"\"]\n     \
    \   [(memb (first text) '(' 'a' #\\e #\\i #\\o #\\u #\\y)) (remove_vowels (rest\
    \ text))])\n  )\n", "  (cond\n    [(empty? text) \"\"]\n    [(equal? (first text)\
    \ 'a) (remove-vowels (rest text))]\n    [(equal? (first text) 'e) (remove-vowels\
    \ (rest text))]\n    [(equal? (first text) 'i) (remove-vowels (rest text))]\n\
    \    [(equal? (first text) 'o) (remove-vowels (rest text))]\n    [(equal? (first\
    \ text) 'u) (remove-vowels (rest text))]\n    [else (cons (first text)\n     \
    \           (remove_vowels (rest text)))]))\n#lang racket\n", "  (if (not (is-string\
    \ text))\n      text\n      (loop\n         for (i text) in-string?\n        \
    \ for j vowels in-set\n         when (and (= i j) (not (is-vowel j)))\n      \
    \   collect (substring text 0 i)\n         into text\n         finally (return\
    \ text))))\n", "  (define (helper s str)\n    (if (null? str)\n        str\n \
    \       (if (char=? (first str) s)\n            (helper (second str) (third str))\n\
    \            (helper (second str) (third str))))\n  (helper 'a 'text))\n</code>\n\
    I hope the comments help you.\n<|/ a tags=scheme,racket,string |>\n<| c |>\nThanks\
    \ for your help! I'm still learning Racket, so I think my question was a bit vague.\
    \ I really appreciate all the help though!\n<|/ c |>\n<| c |>\nNo problem! Racket's\
    \ documentation is quite good, and the documentation for Racket is quite comprehensive.\
    \ Don't forget to upvote if you like my answer :) Good luck with your studies,\
    \ and feel free to ask anything about Scheme and Racket, although I doubt you\
    \ will have many questions :)\n<|/ c |>\n<| c |>\nYes, it really is. Thank you!\
    \ :)\n<|/ c |>\n<| c |>\nI suggest reading [How to Design Programs](http://norvig.com/21-days.html#head20),\
    \ if you haven't done it already :)\n<|/ c |>\n<| a dscore=1 |>\n<code>", "  (cond\n\
    \    [(string-length text)\n     (let ([new_text \"\"])\n       (for/fold ([new_text\
    \ \"\"])\n                 ([text \"\"])\n                 ([i (string-length\
    \ text)])\n                 ([letter (string->char text i)])\n               \
    \  (cond\n                   [(equal? letter #\\a)\n                    (set!\
    \ new_text (append new_text letter))]\n                   [(equal? letter #\\\
    e)\n                    (set! new_text (append new_text letter))]\n          \
    \         [(equal? letter #\\i)\n                    (set! new_text (append new_text\
    \ letter))]\n                   [(equal? letter #\\o)\n                    (set!\
    \ new_text (append new_text letter))]\n                   [(equal? letter #\\\
    u)\n                    (set! new_text (append new_text letter))]\n          \
    \         [(equal? letter #\\y)\n                    (set! new_text (append new_text\
    \ letter))]\n                   [(equal? letter #\\d)\n                    (set!\
    \ new_text (append new_text letter))]\n                   [(equal? letter #\\\
    o)\n                    (set! new_text (append new_text letter))]\n          \
    \         [(equal? letter #\\u)\n                    (set! new_text (append new_text\
    \ letter))]\n                   [(equal? letter #\\y)\n                    (set!\
    \ new_text (append new_text letter))]\n                   [(equal? letter #\\\
    d)\n                    (set! new_text (append new_text letter))]\n          \
    \         [(equal? letter #\\o)\n                    (set! new_text (append new_text\
    \ letter))]\n                   [(equal? letter #\\u)\n                    (set!\
    \ new_text (append new_text letter))]\n                   [(equal? letter #\\\
    y)\n                    (set! new_text (append new_text letter))]\n          \
    \         [(equal? letter #\\d)\n                    (set! new_text (append new_text\
    \ letter))]\n                   [(equal? letter #\\o)\n                    (set!\
    \ new_text (append new_text letter))]\n                   [(equal? letter #\\\
    u)\n                    (set! new_text (append new_text letter))]\n          \
    \         [(equal? letter #\\y)\n                    (set! new_text (append new_text\
    \ letter))]\n                   [(equal? letter #\\d)\n                    (set!\
    \ new_text (append new_text letter))]\n                   [(equal? letter #\\\
    o)\n                    (set! new_text (append new_text letter))]\n          \
    \         [(equal? letter #\\u)\n                    (set! new_text (append new_text\
    \ letter))]\n                   [(equal? letter #\\y)\n                    (set!\
    \ new_text (", "  (let* ([vowels '(a e i o u)]\n         [res (string->list text)]\n\
    \         [newres res])\n    (let loop ([i 0] [res (string->list text)])\n   \
    \   (cond\n\t((null? res)\n\t (list nil))\n\t((member (car res) vowels)\n\t (loop\
    \ (add1 i) (cdr res)))\n\t(else\n\t (loop (add1 i) res))))))\n", "  (cond [(empty?\
    \ text) empty]\n        [(vowel? text)\n         (if (vowel? (car text)) (remove_vowels\
    \ (cdr text)) (car text))\n         (append (remove_vowels (cdr text)) (list text))]\n\
    \        [else (append (remove_vowels (cdr text)) (list text))]))\n", "  (let\
    \ ([text (map #(#{\\A #{\\e #{\\i #{\\o #{\\u #{\\z}}} #{\\g #{\\z}}} %) #(map\
    \ char->string text))]\n        [chars (map char->string \"AEIOUaeiouzghz\")]\n\
    \        [charset (map #(hash-ref chars #{\\A \\e \\i \\o \\u \\z \\g \\z}) text)]\n\
    \        [result (list* \"\" text)]\n        [charlen (length text)]\n       \
    \ [vowel-count 0])\n\n    (for-each\n      (lambda (i)\n        (if (null? chars)\n\
    \            (cond ((= i charlen) (set! vowel-count (+ vowel-count 1)))\n    \
    \              (else (cond ((member #{\\A \\e \\i \\o \\u \\z} \\(substring text\
    \ i)) (set! vowel-count (+ vowel-count 1)))\n                             (else\
    \ (set! vowel-count (- vowel-count 1))))))\n      (vector-ref text 0))\n\n   \
    \ (if (or (null? text) (= charlen 0))\n        (set! result (substring text 1\
    \ charlen))\n        (for-each\n          (lambda (i)\n            (if (null?\
    \ chars)\n                (cond ((= i charlen) (set! vowel-count (+ vowel-count\
    \ 1)))\n                      (else (cond ((member #{\\A \\e \\i \\o \\u \\z}\
    \ \\(substring text i)) (set! vowel-count (+ vowel-count 1)))\n              \
    \                   (else (set! vowel-count (- vowel-count 1)))))))\n        \
    \  (vector-ref text 0))\n\n    (if (= vowel-count 0)\n        (cond ((null? text)\
    \ (set! result text))\n              ((null? chars) (set! result text))\n    \
    \          (else (set! result (substring text 1 charlen)))))\n    result))\n",
  "  (cond\n    [(empty? text) \"\"]\n    [(equal? (first text) 'a) (cons (first text)\
    \ (remove (first text) 'a text))\n     (remove_vowels (rest (rest (rest (rest\
    \ text))))]\n    [(equal? (first text) 'u) (cons (first text) (remove (first text)\
    \ 'u text))\n     (remove_vowels (rest (rest (rest (rest text))))]\n    [(equal?\
    \ (first text) 'i) (cons (first text) (remove (first text) 'i text))\n     (remove_vowels\
    \ (rest (rest (rest (rest text))))]\n    [(equal? (first text) 'o) (cons (first\
    \ text) (remove (first text) 'o text))\n     (remove_vowels (rest (rest (rest\
    \ (rest text))))]\n    [(equal? (first text) 'e) (cons (first text) (remove (first\
    \ text) 'e text))\n     (remove_vowels (rest (rest (rest (rest text))))]\n   \
    \ [else (cons (first text) (remove_vowels (rest (rest (rest (rest text))))))]))\n",
  "  (if (null? text)\n      text\n      (let ([char (car text)]) (cond [(char=? (remove\
    \ #\\a text) #\\a) (remove char text)] [(char=? (remove #\\a text) #\\A) (remove\
    \ char text)] [(char=? (remove #\\e text) #\\e) (remove char text)] [(char=? (remove\
    \ #\\i text) #\\i) (remove char text)] [(char=? (remove #\\o text) #\\o) (remove\
    \ char text)] [(char=? (remove #\\u text) #\\u) (remove char text)] [(char=? (remove\
    \ #\\y text) #\\y) (remove char text)]) text)))\n", "  (if (null? text)\n    \
    \  '\n      (if (string=? (car text) (cons \"aeiou\"))\n          (cdr text)\n\
    \          (cons (car text) (remove_vowels (cdr text)))))) \n", "  (cond\n   \
    \ [(string-empty? text) text]\n    [else (cons (first text)\n               (remove_vowels\
    \ (rest text))))]))\n", "  (if (empty? text)\n      text\n      (append (rest\
    \ (remove (lambda (letter) (equal? (first letter) \"a\") (first text))) (remove_vowels\
    \ (rest text))) \"\")))\n", "  (cond\n    [(empty? text)\n     (string->list \"\
    \")] \n    [(string->list (string->string text))\n     (cons (first text) (remove_vowels\
    \ (rest text)))]))\n", "  (define (remove-vowels text new-text vowels)\n    (cond\n\
    \      [(null? text) new-text ]\n      [(member text vowels)\n       (if (null?\
    \ vowels)\n           (new-text)\n           (cons text new-text))]\n      [else\n\
    \       (if (null? new-text)\n           (cons text (remove-vowels (rest text)\
    \ (rest new-text) vowels))\n           (remove-vowels (rest text) new-text\n \
    \                          (append vowels (list (first text)))))]))\n  (remove-vowels\
    \ text '() '(a e i o u)))", "  (cond\n    ((empty? text) text)\n    ((equal? (first\
    \ text) 'a) (cond\n                              ((equal? (next text) 'a) (cond\n\
    \                                                        ((equal? (next (next\
    \ text)) 'a) \"\")\n                                                        ((equal?\
    \ (next (next (next text)) 'a) \"\") (next (next text)))\n                   \
    \                                     ((equal? (next (next (next text)) 'a) \"\
    \") \"\")\n                                                        ((equal? (next\
    \ (next (next (next text)) 'a)) 'a) \"\")\n                                  \
    \                      ((equal? (next (next (next (next (next text)) 'a)) 'a)\
    \ \"\") (next (next (next text)))\n                                          \
    \              ((equal? (next (next (next (next (next text)) 'a)) 'a) \"\") (next\
    \ (next (next (next text))))\n                                               \
    \         ((equal? (next (next (next (next (next text)) 'a)) 'a) \"\") (next (next\
    \ (next (next (next text))))))\n                              ((equal? (next (next\
    \ text)) 'a) (cond\n                                                        ((equal?\
    \ (next (next (next text)) 'a) \"\") (next (next text)))\n                   \
    \                                     ((equal? (next (next (next (next text))\
    \ 'a) \"\") \"\")\n                                                        ((equal?\
    \ (next (next (next (next (next text)) 'a)) 'a) \"\") (next (next (next text)))\n\
    \                                                        ((equal? (next (next\
    \ (next (next (next text)) 'a)) 'a) \"\")\n                                  \
    \                      ((equal? (next (next (next (next (next text)) 'a)) 'a)\
    \ \"\") (next (next (next (next (next text))))))\n                           \
    \   ((equal? (next (next (next text)) 'a) (cond\n                            \
    \                            ((equal? (next (next (next (next text)) 'a) \"\"\
    ) (next (next (next text))))\n                                               \
    \         ((equal? (next (next (next (next (next text)) 'a)) 'a) \"\") (next (next\
    \ (next (next text))))\n                                                     \
    \   ((equal? (next (next (next (next (next (next text)) 'a)) 'a) \"\") (next (next\
    \ (next (next (next text))))))\n                              ((equal? (next (next\
    \ (next (next text)) 'a) (cond\n                                             \
    \           ((equal? (next (next (next (next (next (next text)) 'a) \"\") (next\
    \ (next (next ", "  (cond\n    [(empty? text)\n      \"\"]\n    [(list? text)\n\
    \      (append* (remove_vowels (first text))\n              (remove_vowels (rest\
    \ text)))]\n    [(string? text) (cond\n                          [(equal? (first\
    \ text) 'a)\n                           (cond\n                              [(equal?\
    \ (first (rest text)) 'i)\n                               (cond\n            \
    \                      [(equal? (first (rest (rest text))) 'o) 'o]\n         \
    \                         [(equal? (first (rest (rest text))) 'u) 'u]\n      \
    \                            [(equal? (first (rest (rest text))) 'A) 'A]\n   \
    \                               [(equal? (first (rest (rest text))) 'E) 'E]\n\
    \                                  [(equal? (first (rest (rest text))) 'I) 'I]\n\
    \                                  [(equal? (first (rest (rest text))) 'O) 'O]\n\
    \                                  [(equal? (first (rest (rest text))) 'U) 'U]\n\
    \                                  [else (cons 'a (rest (rest text)))]))]\n  \
    \                        [(equal? (first text) 'e)\n                         \
    \  (cond\n                              [(equal? (first (rest text)) 'i)\n   \
    \                            (cond\n                                  [(equal?\
    \ (first (rest (rest text))) 'o) 'o]\n                                  [(equal?\
    \ (first (rest (rest text))) 'u) 'u]\n                                  [(equal?\
    \ (first (rest (rest text))) 'A) 'A]\n                                  [(equal?\
    \ (first (rest (rest text))) 'E) 'E]\n                                  [(equal?\
    \ (first (rest (rest text))) 'I) 'I]\n                                  [(equal?\
    \ (first (rest (rest text))) 'O) 'O]\n                                  [(equal?\
    \ (first (rest (rest text))) 'U) 'U]\n                                  [else\
    \ (cons 'e (rest (rest text)))])]\n                              [else (cons 'e\
    \ text)])]\n                          [(equal? (first text) 'i)\n            \
    \               (cond\n                              [(equal? (first (rest text))\
    \ 'o) 'o]\n                              [(equal? (first (rest (rest text))) 'u)\
    \ 'u]\n                              [(equal? (first (rest (rest text))) 'A) 'A]\n\
    \                              [(equal? (first (rest (rest text))) 'E) 'E]\n \
    \                             [(equal? (first (rest (rest text))) 'I) 'I]\n  \
    \                            [(equal? (first (rest (rest text))", "  (cond [(string?\
    \ text) #(\"\")\n         #t\n         (char-upper? #\\a) (char-upper? (string-replace\
    \ text \"a\" \"\")) (make-string (remove-if (lambda (char) (char-lower? #\\a))\
    \ text))\n         (char-upper? #\\e) (char-upper? (string-replace text \"e\"\
    \ \"\")) (make-string (remove-if (lambda (char) (char-lower? #\\e)) text))\n \
    \        (char-upper? #\\i) (char-upper? (string-replace text \"i\" \"\")) (make-string\
    \ (remove-if (lambda (char) (char-lower? #\\i)) text))\n         (char-upper?\
    \ #\\o) (char-upper? (string-replace text \"o\" \"\")) (make-string (remove-if\
    \ (lambda (char) (char-lower? #\\o)) text))\n         (char-upper? #\\u) (char-upper?\
    \ (string-replace text \"u\" \"\")) (make-string (remove-if (lambda (char) (char-lower?\
    \ #\\u)) text))\n         (char-upper? #\\y) (char-upper? (string-replace text\
    \ \"y\" \"\")) (make-string (remove-if (lambda (char) (char-lower? #\\y)) text))\n\
    \         (char-upper? #\\d) (char-upper? (string-replace text \"d\" \"\")) (make-string\
    \ (remove-if (lambda (char) (char-lower? #\\d)) text))\n         (else text)\n\
    \         ])\n  )\n", "  (cond\n    [(empty? text) \"\"]\n    [(equal? (car text)\
    \ a) (cons (car text) '())]\n    [(equal? (car text) e) (cons (car text) '())]\n\
    \    [(equal? (car text) i) (cons (car text) '())]\n    [(equal? (car text) o)\
    \ (cons (car text) '())]\n    [(equal? (car text) u) (cons (car text) '())]\n\
    \    [(equal? (car text) A) (cons (car text) '())]\n    [(equal? (car text) E)\
    \ (cons (car text) '())]\n    [(equal? (car text) I) (cons (car text) '())]\n\
    \    [(equal? (car text) O) (cons (car text) '())]\n    [(equal? (car text) U)\
    \ (cons (car text) '())]\n    [(equal? (car text) y) (cons (car text) '())]\n\
    \    [(equal? (car text) o) (cons (car text) '())]\n    [(equal? (car text) u)\
    \ (cons (car text) '())]\n    [(equal? (car text) Y) (cons (car text) '())]\n\
    \    [(equal? (car text) a) (cons (car text) '())]\n    [(equal? (car text) b)\
    \ (cons (car text) '())]\n    [(equal? (car text) c) (cons (car text) '())]\n\
    \    [(equal? (car text) d) (cons (car text) '())]\n    [(equal? (car text) e)\
    \ (cons (car text) '())]\n    [(equal? (car text) f) (cons (car text) '())]\n\
    \    [(equal? (car text) g) (cons (car text) '())]\n    [(equal? (car text) h)\
    \ (cons (car text) '())]\n    [(equal? (car text) i) (cons (car text) '())]\n\
    \    [(equal? (car text) j) (cons (car text) '())]\n    [(equal? (car text) k)\
    \ (cons (car text) '())]\n", "  (cond\n    ((empty? text) text)\n    ((equal?\
    \ (first text) #\\a)(rest text))\n    ((equal? (first text) #\\e)(rest text))\n\
    \    ((equal? (first text) #\\i)(rest text))\n    ((equal? (first text) #\\o)(rest\
    \ text))\n    ((equal? (first text) #\\u)(rest text))\n    (else (cons (first\
    \ text) (remove_vowels (rest text))))))\n</cell>\n<text>\nExercise 2\nWrite a\
    \ function that takes a string and a list, and returns the string with letters\
    \ that are not in list removed, where letters are specified as #\\a - #\\z.\n\n\
    \n</text>\n<code language=racket-student-advanced-ui>", "  (cond\n    [(empty?\
    \ text) \"\"]\n    [(cons? text) (first text)\n     (remove_vowels (rest text))]))\n",
  "  (cond\n    [(empty? text) \"\"]\n    [(vowel? (first text)) (substring (first\
    \ text) (+ 2 (car text)))]\n    [else (cons text (remove_vowels (rest text)))\
    \ ]))\n", "  (cond [(empty? text) text]\n        [(member? (car text) 'aeiouAEIOU)\
    \ (cons (cdr text) '())]\n        [else (cons (car text) (remove_vowels (cdr text))))]))\n",
  "  (cond\n    [(empty? text)\n     \"\"]\n    [(equal? (first text) 'a) (substring\
    \ text (+ 1))]\n    [(equal? (first text) 'e) (substring text (+ 1))]\n    [(equal?\
    \ (first text) 'i) (substring text (+ 1))]\n    [(equal? (first text) 'o) (substring\
    \ text (+ 1))]\n    [(equal? (first text) 'u) (substring text (+ 1))]\n    [(equal?\
    \ (first text) 'y) (substring text (+ 1))]\n    [else (substring text (+ 1))]))\n",
  "  (cond [(null? text)\n         \"\"]\n        [(member (car text) '(a e i o u))\
    \ (cons (car text) (remove-vowels (cdr text)))]\n        [else (cons (car text)\
    \ (remove-vowels (cdr text)))]))\n", "  (cond\n    ((empty? text)\n      \"\"\
    )\n    ((equal? (car text) \"a\")\n      (remove (equal? (car text) \"a\") text))\n\
    \    ((equal? (car text) \"e\")\n      (remove (equal? (car text) \"e\") text))\n\
    \    ((equal? (car text) \"i\")\n      (remove (equal? (car text) \"i\") text))\n\
    \    ((equal? (car text) \"o\")\n      (remove (equal? (car text) \"o\") text))\n\
    \    ((equal? (car text) \"u\")\n      (remove (equal? (car text) \"u\") text))\n\
    \    ((equal? (car text) \"A\")\n      (remove (equal? (car text) \"A\") text))\n\
    \    ((equal? (car text) \"E\")\n      (remove (equal? (car text) \"E\") text))\n\
    \    ((equal? (car text) \"I\")\n      (remove (equal? (car text) \"I\") text))\n\
    \    ((equal? (car text) \"O\")\n      (remove (equal? (car text) \"O\") text))\n\
    \    ((equal? (car text) \"U\")\n      (remove (equal? (car text) \"U\") text))\n\
    \    ((equal? (car text) \"z\")\n      (remove (equal? (car text) \"z\") text))\n\
    \    ((equal? (car text) \"b\")\n      (remove (equal? (car text) \"b\") text))\n\
    \    ((equal? (car text) \"c\")\n      (remove (equal? (car text) \"c\") text))\n\
    \    ((equal? (car text) \"d\")\n      (remove (equal? (car text) \"d\") text))\n\
    \    ((equal? (car text) \"e\")\n      (remove (equal? (car text) \"e\") text))\n\
    \    ((equal? (car text) \"f\")\n      (remove (equal? (car text) \"f\") text))\n\
    \    ((equal? (car text) \"g\")\n      (remove (equal? (car text) \"g\") text))\n\
    \    ((equal? (car text) \"h\")\n      (remove (equal? (car text) \"h\") text))\n\
    \    ((equal? (car text) \"j\")\n      (remove (equal? (car text) \"j\") text))\n\
    \    ((equal? (car text) \"k\")\n      (remove (equal? (car text) \"k\") text))\n\
    \    ((equal? (car text) \"l\")\n      (remove (equal? (car text) \"l\") text))\n\
    \    ((equal? (car text) \"m\")\n      (remove (equal? (car text) \"m\") text))",
  "  (cond [(null? text) \"\"]\n        [(=? (first text) 'a) (cons (first text) (remove_vowels\
    \ (rest text)))]\n        [(=? (first text) 'e) (cons (first text) (remove_vowels\
    \ (rest text)))]\n        [(=? (first text) 'i) (cons (first text) (remove_vowels\
    \ (rest text)))]\n        [(=? (first text) 'o) (cons (first text) (remove_vowels\
    \ (rest text)))]\n        [(=? (first text) 'u) (cons (first text) (remove_vowels\
    \ (rest text)))]\n        [(=? (first text) 'y) (cons (first text) (remove_vowels\
    \ (rest text)))]\n        [else (cons (first text) (remove_vowels (rest text)))]))\n",
  "  (cond (string? text)\n         (string-replace-all text '(\"[aeiouAEIOU]\" \"\
    \") \"\"))\n  (cond (number? text)\n         (string->number (string-replace-all\
    \ text '(\"[aeiouAEIOU]\" \"\") \"\")))\n  (else text))\n", "  (cond [(equal?\
    \ (car (assoc 'a text))) (remove-char 'a (assoc 'a (text)))]\n        [(equal?\
    \ (car (assoc 'e text))) (remove-char 'e (assoc 'e (text)))]\n        [(equal?\
    \ (car (assoc 'i text))) (remove-char 'i (assoc 'i (text)))]\n        [(equal?\
    \ (car (assoc 'o text))) (remove-char 'o (assoc 'o (text)))]\n        [(equal?\
    \ (car (assoc 'u text))) (remove-char 'u (assoc 'u (text)))]\n        [else (remove-char\
    \ (car (assoc 'o (text))) text)]))\n", "  (define (helper input vowels)\n    (cond\n\
    \      [(empty? input)\n       (reverse vowels)]\n      [(equal? (first input)\
    \ vowels)\n       (helper (rest input) (cons (first input) (vowels)))]\n     \
    \ [(not (equal? (first input) vowels))\n       (helper (rest input) (cons (first\
    \ input) vowels))]\n      [else\n       (helper (rest input) vowels)]))\n  (helper\
    \ text #{}))", "  (define (sub text vowels)\n    (cond [(empty? text) \"\"]\n\
    \          [(member (first text) vowels) (sub (rest text) (cons (first text) vowels))]\n\
    \          [else (sub (rest text) vowels)])\n  )\n  (sub text (cons \"aeiouAEIOU\"\
    \ (list \"aeiouAEIOU\"))))\n", "  (cond\n    [(empty? text) \"\"]\n    [(character?\
    \ (car text)) (cons (car text) (remove_vowels (cdr text)))]\n    [else (cons (car\
    \ text) (remove_vowels (cdr text)))]))\n", "  (cond ((equal? text \"\") \"\")\n\
    \        ((equal? (char-after (last text) 'a) 'a) (substring (last text) 1))\n\
    \        ((equal? (char-after (last text) 'e) 'e) (substring (last text) 1))\n\
    \        ((equal? (char-after (last text) 'i) 'i) (substring (last text) 1))\n\
    \        ((equal? (char-after (last text) 'o) 'o) (substring (last text) 1))\n\
    \        ((equal? (char-after (last text) 'u) 'u) (substring (last text) 1))\n\
    \        ((equal? (char-after (last text) 'A) 'A) (substring (last text) 1))\n\
    \        ((equal? (char-after (last text) 'E) 'E) (substring (last text) 1))\n\
    \        ((equal? (char-after (last text) 'I) 'I) (substring (last text) 1))\n\
    \        ((equal? (char-after (last text) 'O) 'O) (substring (last text) 1))\n\
    \        ((equal? (char-after (last text) 'U) 'U) (substring (last text) 1))\n\
    \        (else text))\n)\n", "  (cond\n    ((string=? \"\" (cdr text)) \"\")\n\
    \    ((string=? \"\" (car text)) (remove_vowels (cdr text)))\n    ((string=? (char-after\
    \ (car text)) 'a) (cons (car text) (remove_vowels (cdr text))))\n    ((string=?\
    \ (char-after (car text)) 'e) (cons (car text) (remove_vowels (cdr text))))\n\
    \    ((string=? (char-after (car text)) 'i) (cons (car text) (remove_vowels (cdr\
    \ text))))\n    ((string=? (char-after (car text)) 'o) (cons (car text) (remove_vowels\
    \ (cdr text))))\n    ((string=? (char-after (car text)) 'u) (cons (car text) (remove_vowels\
    \ (cdr text))))\n    ((string=? (char-after (car text)) 'A) (cons (car text) (remove_vowels\
    \ (cdr text))))\n    ((string=? (char-after (car text)) 'E) (cons (car text) (remove_vowels\
    \ (cdr text))))\n    ((string=? (char-after (car text)) 'I) (cons (car text) (remove_vowels\
    \ (cdr text))))\n    ((string=? (char-after (car text)) 'O) (cons (car text) (remove_vowels\
    \ (cdr text))))\n    ((string=? (char-after (car text)) 'U) (cons (car text) (remove_vowels\
    \ (cdr text))))\n    ((string=? (char-after (car text)) 'B) (cons (car text) (remove_vowels\
    \ (cdr text))))\n    ((string=? (char-after (car text)) 'z) (cons (car text) (remove_vowels\
    \ (cdr text))))\n    ((string=? (char-after (car text)) 'b) (cons (car text) (remove_vowels\
    \ (cdr text))))\n    ((string=? (char-after (car text)) 'c) (cons (car text) (remove_vowels\
    \ (cdr text))))\n    ((string=? (char-after (car text)) 'd) (cons (car text) (remove_vowels\
    \ (cdr text))))\n    ((string=? (char-after (car text)) 'f) (cons (car text) (remove_vowels\
    \ (cdr text))))\n    ((string=? (char-after (car text)) 'g", "  (cond\n    [(empty?\
    \ text) \"\"]\n    [(match-vowels text) (string-replace text \"a\" \"z\")]\n \
    \   [else text]))\n", "  (cond\n    [(empty? text) \"\"]\n    [(vowel? text) (remove-vowel\
    \ (car text))]))\n", "  (cond\n    [(empty? text) \"\"]\n    [(equal? (car text)\
    \ 'A) (remove-vowels (cdr text))]\n    [(equal? (car text) 'E) (remove-vowels\
    \ (cdr text))]\n    [(equal? (car text) 'I) (remove-vowels (cdr text))]\n    [(equal?\
    \ (car text) 'O) (remove-vowels (cdr text))]\n    [(equal? (car text) 'U) (remove-vowels\
    \ (cdr text))]\n    [else (cons (car text) (remove-vowels (cdr text)))]))", " \
    \ (if (string? text) (filter (lambda (x y)\n                              (and\
    \ (vowel? (car x)) (not (vowel? (car y))))) text))\n      text))\n", "  (define\
    \ (helper text index result)\n    (if (string=? (substring text index) (substring\
    \ \"aeiou\" 0))\n        (helper (substring text (incf index)) (incf index) result)\n\
    \        (helper (substring text (incf index)) (incf index) result)))\n  (helper\
    \ (substring text 0) (length text) \"\"))\n</cell>\n<cell>", "  (cond\n    [(empty?\
    \ text) \"\"]\n    [(vowel? (first text)) (remove_vowels (rest text))]))\n", " \
    \ (cond\n    [(empty? text) \"\"]\n    [(member #\\aa (map char->symbol text))\n\
    \     (substring (remove-if #(or (char=? (first %) #\\a) (char=? (first %) #\\\
    A)) text)]\n    [(member #\\b (map char->symbol text))\n     (substring (remove-if\
    \ #(or (char=? (first %) #\\b) (char=? (first %) #\\B)) text)]\n    [(member #\\\
    c (map char->symbol text))\n     (substring (remove-if #(or (char=? (first %)\
    \ #\\c) (char=? (first %) #\\C)) text)]\n    [(member #\\d (map char->symbol text))\n\
    \     (substring (remove-if #(or (char=? (first %) #\\d) (char=? (first %) #\\\
    D)) text)]\n    [(member #\\e (map char->symbol text))\n     (substring (remove-if\
    \ #(or (char=? (first %) #\\e) (char=? (first %) #\\E)) text)]\n    [(member #\\\
    f (map char->symbol text))\n     (substring (remove-if #(or (char=? (first %)\
    \ #\\f) (char=? (first %) #\\F)) text)]\n    [(member #\\g (map char->symbol text))\n\
    \     (substring (remove-if #(or (char=? (first %) #\\g) (char=? (first %) #\\\
    G)) text)]\n    [(member #\\h (map char->symbol text))\n     (substring (remove-if\
    \ #(or (char=? (first %) #\\h) (char=? (first %) #\\H)) text)]\n    [(member #\\\
    i (map char->symbol text))\n     (substring (remove-if #(or (char=? (first %)\
    \ #\\i) (char=? (first %) #\\I)) text)]\n    [(member #\\j (map char->symbol text))\n\
    \     (substring (remove-if #(or (char=? (first %) #\\j) (char=? (first %) #\\\
    J)) text)]\n    [(member #\\k (map char->symbol text))\n     (substring (remove-if\
    \ #(or (char=? (first %) #\\k) (char=? (first %) #\\K)) text)]\n    [(member #\\\
    l (map char->symbol text))\n     (substring (remove-if #(or (char=? (first %)\
    \ #\\l) (char=? (", "  (cond [(string=? text \"\") \"\"]\n        [(string=? text\
    \ \"aeiouAEIOU\") text]\n        [(string=? text \"ybcdfghjklmnoprstuvwyz\") (remove-vowels\
    \ (string text))]\n        [else (remove-vowels (string text))]))\n", "  (cond\n\
    \    [(empty? text) \"\"]\n    [(empty? (car text)) (cons (car text) (remove_vowels\
    \ (cdr text)))]\n    [(equal? (car text) 'a) (remove_vowels (cdr text))]\n   \
    \ [(equal? (car text) 'e) (remove_vowels (cdr text))]\n    [(equal? (car text)\
    \ 'i) (remove_vowels (cdr text))]\n    [(equal? (car text) 'o) (remove_vowels\
    \ (cdr text))]\n    [(equal? (car text) 'u) (remove_vowels (cdr text))]\n    [else\
    \ (cons (car text) (remove_vowels (cdr text)))]))\n", "  (cond\n    ((empty? text)\
    \ \"\")\n    ((not (equal? (first text) #\\a)) (substring text 1 text))\n    ((not\
    \ (equal? (first text) #\\e)) (substring text 1 text))\n    ((not (equal? (first\
    \ text) #\\i)) (substring text 1 text))\n    ((not (equal? (first text) #\\o))\
    \ (substring text 1 text))\n    ((not (equal? (first text) #\\u)) (substring text\
    \ 1 text))\n    ((not (equal? (first text) #\\y)) (substring text 1 text))\n \
    \   ((equal? (first text) #\\y) (substring text 1 (+ 1 (string->number (first\
    \ text)))))\n    ((equal? (first text) #\\u) (substring text 1 (+ 2 (string->number\
    \ (first text)))))\n    ((equal? (first text) #\\o) (substring text 1 (+ 3 (string->number\
    \ (first text)))))\n    ((equal? (first text) #\\i) (substring text 1 (+ 4 (string->number\
    \ (first text)))))\n    ((equal? (first text) #\\e) (substring text 1 (+ 5 (string->number\
    \ (first text)))))\n    ((equal? (first text) #\\a) (substring text 1 (+ 6 (string->number\
    \ (first text)))))\n    ((equal? (first text) #\\b) (substring text 1 (+ 7 (string->number\
    \ (first text)))))\n    ((equal? (first text) #\\z) (substring text 1 (+ 8 (string->number\
    \ (first text)))))\n    ((equal? (first text) #\\v) (substring text 1 (+ 9 (string->number\
    \ (first text)))))\n    ((equal? (first text) #\\d) (substring text 1 (+ 10 (string->number\
    \ (first text)))))\n    ((equal? (first text) #\\s) (substring text 1 (+ 11 (string->number\
    \ (first text)))))\n    ((equal? (first text) #\\t) (substring text 1 (+ 12 (string->number\
    \ (first text)))))\n    ((equal? (first text) #\\v) (substring text 1 (+ 13 (string->number\
    \ (first text)))))\n    ((equal? (first text) #\\g) (substring text 1 (+ 14 (string->number\
    \ (first text)))))\n    ((equal? (first text) #\\j) (substring text 1 (+ 15 (string->number\
    \ (first text)))))\n    ((equal? (first text) #\\v) (substring text 1 (+ 16 (string->number\
    \ (first text)))))\n    ((equal? (first text) #\\g) (substring text 1 (+ 17 (string->number\
    \ (first text)))))\n    ((equal? (first text) #\\m) (", "  (cond\n    [(empty?\
    \ text) \"\"]\n    [(equal? (first text) #\\a) (remove-if #\\a text)]\n    [(equal?\
    \ (first text) #\\e) (remove-if #\\e text)]\n    [(equal? (first text) #\\i) (remove-if\
    \ #\\i text)]\n    [(equal? (first text) #\\o) (remove-if #\\o text)]\n    [(equal?\
    \ (first text) #\\u) (remove-if #\\u text)]\n    [else (cons (first text) (remove_vowels\
    \ (rest text))) ]))\n</code>\n<|/ a dscore=3 tags=racket,string |>\n<| c |>\n\
    This does not work properly - it will remove all vowels from the string. Ex: (remove_vowels\
    \ \"aA\") results in \"A\"\n<|/ c |>\n<| a dscore=3 |>\nThe question asked for\
    \ strings, but the answers provide solutions for sequences.\nThe answer to this\
    \ question is to convert the sequences to strings and then use a simple filter:\n\
    <code>", "  (cond\n    [(empty? text)  \"\"]\n    [(symbol? (first text)) (first\
    \ text)]\n    [(number? (first text))\n     (cond\n       [(= (first text) 'a)\
    \ (first text)]\n       [(= (first text) 'e) (first text)]\n       [(= (first\
    \ text) 'i) (first text)]\n       [(= (first text) 'o) (first text)]\n       [(=\
    \ (first text) 'u) (first text)]\n       [else                  (first text)]\n\
    \       )]\n    [else                    \n     (cons (first text) (remove_vowels\
    \ (rest text)))]\n   ))\n", "  (cond [(string? text) \"\"]\n        [(member?\
    \ (char-upper-case text) #'(A E I O U Y)) (substring text 0 (string/length text))]\n\
    \        [else (substring text 0 (string/length text))]\n      )\n)", "  (define\
    \ (remove text index)\n    (cond\n      [(null? text) \"\"]\n      [(eq? text\
    \ 'a) (remove-chars text index)]\n      [(eq? text 'e) (remove-chars text index)]\n\
    \      [(eq? text 'i) (remove-chars text index)]\n      [(eq? text 'o) (remove-chars\
    \ text index)]\n      [(eq? text 'u) (remove-chars text index)]\n      [(eq? text\
    \ 'y) (remove-chars text index)]\n      [else (cons text (remove (rest text) index))]))\n\
    \  (remove text 0))\n", "  (cond [(empty? text) \"\"]\n        [(equal? (first\
    \ text) 'a) (remove 'a text)]\n        [(equal? (first text) 'e) (remove 'e text)]\n\
    \        [(equal? (first text) 'i) (remove 'i text)]\n        [(equal? (first\
    \ text) 'o) (remove 'o text)]\n        [(equal? (first text) 'u) (remove 'u text)]))\n",
  "  (cond\n    ((string=? text \"\") \"\")\n    ((string=? text \"a\") \"\")\n  \
    \  ((string=? text \"e\") \"\")\n    ((string=? text \"i\") \"\")\n    ((string=?\
    \ text \"o\") \"\")\n    ((string=? text \"u\") \"\")\n    (else (substring text\
    \ 0 (string-length text))))) ;; #lang racket\n</code>\n<|/ a dscore=0 |>\n<| c\
    \ |>\nA variant of this is `string=? (substring text 0 (string-length text)) \"\
    aeiou\"` which would be clearer as `string=? text \"aeiou\"`\n<|/ c |>\n<| c |>\n\
    Yes, you are right. I was trying to write my answer from my phone and didn't notice\
    \ that. Thank you for the suggestion\n<|/ c |>\n<| c |>\nPlease accept my edit.\
    \ I've added more detailed explanation of the function.\n<|/ c |>\n<| c |>\nThanks.\
    \ Just added a variant using `string=?` function.\n<|/ c |>\n<| a tags=racket,string,scheme\
    \ dscore=0 |>\nI like your first answer, but it has a few problems.\nThe first\
    \ one is that \"aaBAA\" becomes \"BAA\" instead of \"A\". The second problem is\
    \ that it doesn't work with strings of length 0. The third and fourth problem\
    \ is that it only works with \"aeiou\". If you want it to work with other vowels,\
    \ you'd have to replace \"aeiou\" with \"aAeEiIoOuU\". I suggest the following\
    \ code:\n<code>", "  (cond\n    [(empty? text) \"\"]\n    [(string-equal? (char\
    \ text) #\\a) (string-replace (char text) #\\a \"\")]\n    [(string-equal? (char\
    \ text) #\\e) (string-replace (char text) #\\e \"\")]\n    [(string-equal? (char\
    \ text) #\\i) (string-replace (char text) #\\i \"\")]\n    [(string-equal? (char\
    \ text) #\\o) (string-replace (char text) #\\o \"\")]\n    [(string-equal? (char\
    \ text) #\\u) (string-replace (char text) #\\u \"\")]\n    [else text]))\n", " \
    \ (cond\n    [(empty? text) text]\n    [else\n     (cond\n       [(char-set? (char\
    \ text)) (remove_vowels (rest text))\n                          (cons (char text)\
    \ (remove_vowels (rest text)))]\n       [else (cons (char text) (remove_vowels\
    \ (rest text)))])))", "  (cond\n    [(empty? text) \"\"]\n    [else (set! text\
    \ (filter (lambda (c) (equal? (c (car text)) #\\a) #\\b) #\\c) #\\d)\n       \
    \   (set! text (filter (lambda (c) (equal? (c (car text)) #\\a) #\\e) #\\f)\n\
    \          (set! text (filter (lambda (c) (equal? (c (car text)) #\\a) #\\i) #\\\
    j)\n          (set! text (filter (lambda (c) (equal? (c (car text)) #\\a) #\\\
    o) #\\p)\n          (set! text (filter (lambda (c) (equal? (c (car text)) #\\\
    a) #\\u) #\\v)\n          (set! text (filter (lambda (c) (equal? (c (car text))\
    \ #\\a) #\\w) #\\y))]\n    text));;; #lang racket", "  (cond\n    [(empty? text)\
    \ \"\"]\n    [(member? (car text) 'aeiouAEIOU) (cadr text)]\n    [else (cons (car\
    \ text) (remove_vowels (cdr text)))]))\n", "  (string/join (remove-if #(eq? (char->integer\
    \ (car text)) 97)\n                        (string->list text))\n            \
    \    \"\"))\n", "  (cond\n    [(empty? text) \"\"]\n    [(vowel? (first text))\
    \ (rest text)]\n    [else (cons (first text) (remove_vowels (rest text)))]))\n",
  "  (cond\n    [(empty? text) \"\"]\n    [(member? (car text) '(\"a\" \"e\" \"i\"\
    \ \"o\" \"u\") false)\n     (cons (car text) (remove_vowels (cdr text)))]\n  \
    \  [else (cons (car text) (remove_vowels (cdr text)))]))\n", "  (define (remove-vowel\
    \ char)\n    (cond\n      [(char= (char-code char) 97)\n       (string->char (substring\
    \ (string text) 0 (string->length (string text))))]\n      [(char= (char-code\
    \ char) 65)\n       (substring (string text) 0 (string->length (string text)))]\n\
    \      [(char= (char-code char) 66)\n       (substring (string text) 1 (string->length\
    \ (string text)))]\n      [(char= (char-code char) 95)\n       (substring (string\
    \ text) 1 (string->length (string text)))]\n      [else (char->string\n      \
    \         (char-code char)))]))\n", "  (cond\n    [(empty? text)\n     (cons \"\
    ~\" \"\")]\n    [(member (first (rest text)) (symbol->string #\\a) '() '()) (rest\
    \ (rest text))\n     (cons \"~\" (first (rest text)))]\n    [(member (first (rest\
    \ text)) (symbol->string #\\e) '() '()) (rest (rest text))\n     (cons \"~\" (first\
    \ (rest text)))]\n    [(member (first (rest text)) (symbol->string #\\i) '() '())\
    \ (rest (rest text))\n     (cons \"~\" (first (rest text)))]\n    [(member (first\
    \ (rest text)) (symbol->string #\\o) '() '()) (rest (rest text))\n     (cons \"\
    ~\" (first (rest text)))]\n    [(member (first (rest text)) (symbol->string #\\\
    u) '() '()) (rest (rest text))\n     (cons \"~\" (first (rest text)))]\n    [else\n\
    \     (cons (first text) (remove_vowels (rest (rest text))))]))\n</code>\n<|/\
    \ a dscore=2 |>\n<| a dscore=1 |>\nI have found this solution from my friend \n\
    <code>", "  (define (helper text)\n    (cond\n      [(empty? text) \"\"]\n   \
    \   [else (cons (car text)\n                  (helper (cdr text)))]))\n  (helper\
    \ text))\n", "  (let ((vowels '(\"a\" \"e\" \"i\" \"o\" \"u\"))\n        (result\
    \ text))\n    (for-each (\u03BB (char)\n                (if (member (char-code\
    \ char) vowels)\n                    (recur char result)\n                   \
    \ result))\n                result)))\n", "  (cond\n    [(empty? text) text]\n\
    \    [(= (length text) 1) \"\"]\n    [(eq? (first text) 'a) (second text)]\n \
    \   [(eq? (first text) 'e) (third text)]\n    [(eq? (first text) 'i) (fourth text)]\n\
    \    [(eq? (first text) 'o) (fifth text)]\n    [(eq? (first text) 'u) (sixth text)]\n\
    \    [else (cons (first text) (remove_vowels (rest text))) ]\n    )\n  )\n", " \
    \ \n  ;; Return text if no vowels found.\n  (cond\n    [(empty? text) text]\n\
    \    [\n     (find (map cons text #\\a) (map cons #\\a #\\b) #\\b) #\\b\n    \
    \ (find (map cons text #\\b) (map cons #\\b #\\b) #\\b) #\\b\n     text\n    ]\n\
    \    [else (cons (car text) (remove_vowels (cdr text)))]))\n", "  (define i (string-length\
    \ text))\n  (define a (substring text 0 i))\n  (define z (substring text 0 (-\
    \ (string-length text) i)))\n  (define o (substring text (+ (string-length text)\
    \ i) ((+ i (+ i (string-length text)))))\n  (if (empty? text)\n      \"\"\n  \
    \    (if (member (char-alphabetic? a) '(a e i o u))\n          (append (substring\
    \ text (+ (string-length text) i))\n                  (substring text (+ (string-length\
    \ text) i)))\n          (append (substring text (+ (string-length text) i))\n\
    \                  (substring text (+ (string-length text) i))))))\n", "  (define\
    \ (remove_vowels_helper text acc index)\n    (cond\n      [(empty? text) acc]\n\
    \      [(vowel? (car text)) (remove_vowels_helper (cdr text) (conj acc (car text))\
    \ (+ index 1))]\n      [else (remove_vowels_helper (cdr text) acc (+ index 1))]))\n\
    \  (remove_vowels_helper text '() 0))\n", "  (cond (empty? text)\n         \"\"\
    \n         ((equal? (car text) 'a) (equal? (car text) 'e) (equal? (car text) 'i)\
    \ (equal? (car text) 'o) (equal? (car text) 'u))\n         ((equal? (car text)\
    \ 'A) (equal? (car text) 'E) (equal? (car text) 'I) (equal? (car text) 'O) (equal?\
    \ (car text) 'U))\n         (else\n          (append (remove_vowels (cdr text))\n\
    \                  (list (car text)))))) ", "  (let loop ((text text) (vowels\
    \ '(a e i o u)\n                             (chars '(a e i o u y A E I O U))))\n\
    \    (cond [(empty? text) \"\"]\n          [(member (first text) vowels) (cons\
    \ (first text) (loop (rest text) vowels))]\n          [(member (first text) chars)\
    \ (cons (first text) (loop (rest text) vowels))]\n          [else (loop (rest\
    \ text) vowels)]))) ;; (lambda (x y)\n                                       \
    \       ;; x is the head and y is the tail.", "  (cond\n    [(empty? text) \"\"\
    ]\n    [(equal? (first text) #\\a) (remove_vowels (rest text))] \n    [(equal?\
    \ (first text) #\\e) (remove_vowels (rest text))] \n    [(equal? (first text)\
    \ #\\i) (remove_vowels (rest text))] \n    [(equal? (first text) #\\o) (remove_vowels\
    \ (rest text))] \n    [(equal? (first text) #\\u) (remove_vowels (rest text))]\
    \ \n    [else\n    (cons (first text) (remove_vowels (rest text)))]))\n", "  (cond\
    \ [(empty? text)\n         \"\"]\n        [(cons? text)\n         (string->chars\
    \ (string-remove (string->chars text) vowels))]\n        [else\n         (append\
    \ (remove_vowels (string->list text))\n                 (list (char->string #\\\
    0))]))) ;; #lang racket\n", "  (cond\n    [(empty? text) \"\"]\n    [(equal? (first\
    \ text) 'a) (remove_vowels (rest text))]\n    [(equal? (first text) 'A) (remove_vowels\
    \ (rest text))]\n    [(equal? (first text) 'e) (remove_vowels (rest text))]\n\
    \    [(equal? (first text) 'E) (remove_vowels (rest text))]\n    [(equal? (first\
    \ text) 'i) (remove_vowels (rest text))]\n    [(equal? (first text) 'I) (remove_vowels\
    \ (rest text))]\n    [(equal? (first text) 'o) (remove_vowels (rest text))]\n\
    \    [(equal? (first text) 'O) (remove_vowels (rest text))]\n    [(equal? (first\
    \ text) 'u) (remove_vowels (rest text))]\n    [(equal? (first text) 'U) (remove_vowels\
    \ (rest text))]\n    [else (cons (first text) (remove_vowels (rest text)))]))\n",
  "  (cond\n    [(empty? text) \"\"]\n    [(member(first text) '(aa|ei|ou|u)) -> first\
    \ (rest text)]\n    [else (cons (first text) (remove_vowels (rest text))) ]))\n",
  "  (cond\n    [(empty? text) \"\"]\n    [(member (car text) '(a e i o u)) (cadr\
    \ text)]\n    [else (cons (car text) (remove_vowels (cdr text)))]))\n", "  (cond\n\
    \    [(empty? text) \"\"]\n    [(contains? text \"aeiouAEIOU\") (substring text\
    \ 0 (- (string-length text) 2))]\n    [else (concat text (list* (substring text\
    \ 0 (- (string-length text) 2))))]\n  )\n)\n</cell>\n<cell>", "  (let ([cs '(#\\\
    a #b #c #d #e #f #g #h #i #j #k #l #m #n #o #p #q #r #s #t #u #v #w #x #y #z)])\n\
    \    (map \n      (\u03BB (c)\n        (cond\n          [(member c cs) '()]\n\
    \          [else c])) text))\n  )\n</code>\n<|/ a dscore=2 |>\n<| c |>\nNice use\
    \ of `member`.\n<|/ c |>\n<| c |>\nI edited my answer to include an alternate\
    \ solution that I thought was better, namely eliminating any vowels from the string\
    \ using the `not` function.\n<|/ c |>\n<| c |>\nthanks for editing your post!\
    \ It is much easier to read now!\n<|/ c |>\n<| a tags=scheme,racket,recursion,lisp\
    \ dscore=2 |>\nIt's really not all that hard. Here's a solution that works:\n\
    <code>", "  (cond\n    [(empty? text) \"\"]\n    [(equal? (first text) ?a) (cond\n\
    \                              [(equal? (rest text) ?e) (cons (first text) (cons\
    \ (rest text) \"\"))]\n                              [(equal? (rest text) ?i)\
    \ (cons (first text) (cons (rest text) \"\"))])]\n    [(equal? (first text) ?u)\
    \ (cond\n                              [(equal? (rest text) ?o) (cons (first text)\
    \ (cons (rest text) \"\"))]\n                              [(equal? (rest text)\
    \ ?i) (cons (first text) (cons (rest text) \"\"))])]\n    [(equal? (first text)\
    \ ?e) (cond\n                              [(equal? (rest text) ?a) (cons (first\
    \ text) (cons (rest text) \"\"))]\n                              [(equal? (rest\
    \ text) ?u) (cons (first text) (cons (rest text) \"\"))])]\n    [(equal? (first\
    \ text) ?o) (cond\n                              [(equal? (rest text) ?u) (cons\
    \ (first text) (cons (rest text) \"\"))]\n                              [(equal?\
    \ (rest text) ?i) (cons (first text) (cons (rest text) \"\"))])]\n    [(equal?\
    \ (first text) ?i) (cond\n                              [(equal? (rest text) ?a)\
    \ (cons (first text) (cons (rest text) \"\"))]\n                             \
    \ [(equal? (rest text) ?e) (cons (first text) (cons (rest text) \"\"))])]\n  \
    \  [(equal? (first text) ?u) (cond\n                              [(equal? (rest\
    \ text) ?e) (cons (first text) (cons (rest text) \"\"))]\n                   \
    \           [(equal? (rest text) ?o) (cons (first text) (cons (rest text) \"\"\
    ))])]\n    [(equal? (first text) ?a) (cond\n                              [(equal?\
    \ (rest text) ?u) (cons (first text) (cons (rest text) \"\"))]\n             \
    \                 [(equal? (rest text) ?o) (cons (first text) (cons (rest text)\
    \ \"\"))])]\n    [(equal? (first text) ?b) (cond\n                           \
    \   [(equal? (rest text) ?a) (cons (first text) (cons (rest text) \"\"))]\n  \
    \                            [(equal? (rest text) ?u) (cons (first text) (cons\
    \ (rest text) \"\"))])]\n    [(equal? (first text) ?c) (cond\n               \
    \               [(equal? (rest text) ?b) (cons (first text) (con", "  (cond\n\
    \    [(null? text) \"\"]\n    [(string #\\a) (substring text 0 (string-length\
    \ text))]\n    [(string #\\e) (substring text 0 (string-length text))]\n    [(string\
    \ #\\i) (substring text 0 (string-length text))]\n    [(string #\\o) (substring\
    \ text 0 (string-length text))]\n    [(string #\\u) (substring text 0 (string-length\
    \ text))]\n    [else (substring text 0 (string-length text))]))\n", "  (let ([vowels\
    \ '(a e i o u)])\n    (if (string=? text \"\")\n        (string)\n        (string-map\
    \ \n         (lambda (c) \n           (if (member (char c) vowels)\n         \
    \      (remove-char (char c) vowels)\n               (char (c))))\n         text))))\n",
  "  (cond ((null? text) \"\")\n        ((equal? (char-code (first text)) (first \"\
    aeiou\")) \"\")\n        (else (append (remove_vowels (rest text)) (first \"aeiou\"\
    )))))\n", "  (cond\n    [(empty? text) \"\"]\n    [(equal? (first text) empty?)\
    \ (remove_vowels (rest text))] \n    [else (cons (first text) (remove_vowels (rest\
    \ text)))]))\n", "  (cond\n    [(empty? text) empty]\n    [(equal? (first text)\
    \ vowel) (remove 1 (rest text))])\n)\n", "  (cond\n    [(empty? text) \"\"]\n\
    \    [(contains? text #\\a)(substring text 0 -1)]\n    [(contains? text #\\e)(substring\
    \ text 0 -1)]\n    [(contains? text #\\i)(substring text 0 -1)]\n    [(contains?\
    \ text #\\o)(substring text 0 -1)]\n    [(contains? text #\\u)(substring text\
    \ 0 -1)]\n    [else text]))\n", "  (cond [(empty? text) \"\"]\n        [(vowel?\
    \ (first text)) (second text)]\n        [else (cons (first text) (remove_vowels\
    \ (rest text)))]))\n", "  (cond\n    [(empty? text)                text]\n   \
    \ [(character? (first text)) (cons (first text) (remove_vowels (rest text)))]\n\
    \    [(cons? text)                 (cons (first text) (remove_vowels (rest text)))]\n\
    \    [else (error \"remove_vowels expects a string\")]))\n", "  (let ((letters\
    \ (\"abcdez\" text)))\n    (cond\n      [(null? letters) \"\"]\n      [(list?\
    \ letters)\n       (cond\n         [(= (first letters) 'a) (remove letters 'a\
    \ letters)\n          [(= (first letters) 'b) (remove letters 'b letters)\n  \
    \         [(= (first letters) 'c) (remove letters 'c letters)\n            [(=\
    \ (first letters) 'd) (remove letters 'd letters)\n             (= (first letters)\
    \ 'e) (remove letters 'e letters)\n             (= (first letters) 'z) (remove\
    \ letters 'z letters)\n             letters]\n            [(= (first letters)\
    \ 'A) (remove letters 'A letters)\n             [(= (first letters) 'B) (remove\
    \ letters 'B letters)\n              [(= (first letters) 'C) (remove letters 'C\
    \ letters)\n               [(= (first letters) 'D) (remove letters 'D letters)\n\
    \                (= (first letters) 'E) (remove letters 'E letters)\n        \
    \        (= (first letters) 'Z) (remove letters 'Z letters)\n                letters]\n\
    \               letters]\n              letters]\n             letters]\n    \
    \         letters]\n             letters]\n             letters]\n           \
    \  letters]\n             letters]\n             letters]\n             letters]\n\
    \             letters]\n             letters]\n             letters]\n       \
    \      letters]\n             letters]\n             letters]\n             letters]\n\
    \             letters]\n             letters]\n             letters]\n       \
    \      letters]\n             letters]\n             letters]\n             letters]\n\
    \             letters]\n             letters]\n             letters]\n       \
    \      letters]\n             letters]\n             letters]\n             letters]\n\
    \             letters]\n             letters]\n             letters]\n       \
    \      letters]\n             letters]\n             letters]\n             letters]\n\
    \             letters]\n             letters]\n             letters]\n       \
    \      letters]\n             letters]\n             letters]\n             letters]\n\
    \             letters]\n             letters]\n             letters]\n       \
    \      letters]\n             letters]\n             letters]\n             letters]\n\
    \             letters]\n             letters]\n             letters]\n       \
    \      letters]\n             letters]\n             letters]\n             letters]\n\
    \             letters]\n             letters]\n             letters]\n       \
    \      letters]\n             letters]\n             letters]\n             letters]\n\
    \             letters]\n             ", "  (cond\n    [(empty? text)\n      empty]\n\
    \    [(= (first text) 'a)\n      (rest (filter (fn (x) (not (equal? (first x)\
    \ 'a)) (rest text)))]\n    [(= (first text) 'e)\n      (rest (filter (fn (x) (not\
    \ (equal? (first x) 'e)) (rest text)))]\n    [(= (first text) 'i)\n      (rest\
    \ (filter (fn (x) (not (equal? (first x) 'i)) (rest text)))]\n    [(= (first text)\
    \ 'o)\n      (rest (filter (fn (x) (not (equal? (first x) 'o)) (rest text)))]\n\
    \    [(= (first text) 'u)\n      (rest (filter (fn (x) (not (equal? (first x)\
    \ 'u)) (rest text)))]\n    [(= (first text) 'Y)\n      (rest (filter (fn (x) (not\
    \ (equal? (first x) 'Y)) (rest text)))]\n    [(= (first text) 'z)\n      (rest\
    \ (filter (fn (x) (not (equal? (first x) 'z)) (rest text)))]\n    [else\n    \
    \  (cons (first text) (remove_vowels (rest text)))]))\n", "  (let ([vowels '(a\
    \ e i o u)])\n    (cond\n      [(empty? text) \"\"]\n      [(equal? (first text)\
    \ vowels) (substring (second text) 0)]\n      [else (cons (first text) (remove_vowels\
    \ (rest text))) ])))\n", "  (cond [(string=? (string-ref text 0) \"a\") (string-ref\
    \ text 1)]\n        [else text]))\n", "  (cond (empty? text) \"\"\n        (vowel?\
    \ (car text))\n        (cons (car text)\n              (remove_vowels (cdr text))))\n\
    \  (define vowels '(a e i o u))\n  (cond ((member text vowels) text)\n       \
    \ ((member text '())) '()\n        (else (cons (car text)\n                  \
    \  (remove_vowels (cdr text))))))\n", "  (cond\n    [(empty? text) \"\"]\n   \
    \ [(member (first text) '(\"a\" \"e\" \"i\" \"o\" \"u\"))\n     (cond\n      \
    \ [(equal? (first text) \"a\") (substring text 2)]\n       [(equal? (first text)\
    \ \"e\") (substring text 2)]\n       [(equal? (first text) \"i\") (substring text\
    \ 2)]\n       [(equal? (first text) \"o\") (substring text 2)]\n       [(equal?\
    \ (first text) \"u\") (substring text 2)]\n       [else (cons text '())])]\n \
    \   [else (cons (first text) (remove_vowels (rest text)))]))\n</code>\n<|/ a |>\n\
    <| c |>\nI find this implementation slightly more complex than the other one in\
    \ that it doesn't use recursion and only uses `cond` which makes the code much\
    \ more readable. The code is also more functional, which IMHO is more important\
    \ than readability.\n<|/ c |>\n<| c |>\nThe \"other one\" uses `cond` *inside*\
    \ the function.  That seems like a really bad idea.  Recursion is clearly necessary\
    \ in the solution.  How many other functional languages support recursion and\
    \ tail calls?\n<|/ c |>\n<| c |>\nThanks for the feedback! The question is about\
    \ a recursive solution. The function itself is just some code I came up with.\n\
    <|/ c |>\n<| a dscore=0 |>\nI believe that you can use a function like this:\n\
    <code>", "  (if (empty? text)\n      '()\n      (append (subseq (first text) 0\
    \ (- (length text) 2)) (drop (- (length text) 2) text))))\n", "  (cond\n    [(empty?\
    \ text) \"\"]\n    [(character? (car text))\n     (cons (car text) (remove_vowels\
    \ (cdr text)))]\n    [else (cons (car text) (remove_vowels (cdr text)))]))\n",
  "  (cond [(empty? text) \"\"]\n        [(= (first text) #b) (cons (second text)\
    \ (remove_vowels (rest text)))]\n        [(= 'a (first text)) (cons (first text)\
    \ (remove_vowels (rest text)))]\n        [(= 'e (first text)) (cons (first text)\
    \ (remove_vowels (rest text)))]\n        [(= 'i (first text)) (cons (first text)\
    \ (remove_vowels (rest text)))]\n        [(= 'o (first text)) (cons (first text)\
    \ (remove_vowels (rest text)))]\n        [(= 'u (first text)) (cons (first text)\
    \ (remove_vowels (rest text)))]\n        [else (cons (first text) (remove_vowels\
    \ (rest text)))]))\n", "  (if (equal? (string-length text) 0)\n      '\"\"\n \
    \     (if (equal? (car text) 'a)\n          (if (equal? (cdr text) 'o)\n     \
    \         (if (equal? (cdr text) 'u)\n                  (if (equal? (cdr text)\
    \ 'i)\n                      (if (equal? (cdr text) 'A)\n                    \
    \      '\"\"\n                          (cons (car text) '()))\n             \
    \         (cons (car text) '()))\n                  (cons (car text) '()))\n \
    \             (cons (car text) '()))\n          (if (equal? (cdr text) 'o)\n \
    \             (if (equal? (cdr text) 'u)\n                  (if (equal? (cdr text)\
    \ 'i)\n                      (if (equal? (cdr text) 'A)\n                    \
    \      '\"\"\n                          (cons (car text) '()))\n             \
    \         (cons (car text) '()))\n                  (cons (car text) '()))\n \
    \             (cons (car text) '()))\n          (if (equal? (cdr text) 'a)\n \
    \             (if (equal? (cdr text) 'o)\n                  (if (equal? (cdr text)\
    \ 'u)\n                      (if (equal? (cdr text) 'i)\n                    \
    \      (if (equal? (cdr text) 'A)\n                              '\"\"\n     \
    \                         (cons (car text) '()))\n                          (cons\
    \ (car text) '()))\n                  (cons (car text) '()))\n              (cons\
    \ (car text) '()))\n          (cons (car text) '()))))\n", "  (if (null? text)\n\
    \      text\n      (cond [(char-alphabetic? (car text))\n             (cons (if\
    \ (vowel? (car text))\n                       (car text)\n                   \
    \    (cdr text))\n                   \n                   (remove_vowels (cdr\
    \ text)))]\n            [(vowel? (car text))\n             (cons (car text)\n\
    \                    (remove_vowels (cdr text)))]\n            [else\n       \
    \      (remove_vowels (cdr text))]))\n            ", "  (cond\n    [(empty? text)\
    \ \"\"]\n    [(member? (first text) '(\"aeiou\")) (rest text)]\n    [else (cons\
    \ (first text) (remove_vowels (rest text))) ]))\n", "  ;; This list has all vowels\n\
    \  ((lambda (i vowels)\n     (cond [(empty? vowels) '()]\n           [(char=?\
    \ (first vowels) i) (rest vowels)]\n           [else (recur (rest i) vowels (cons\
    \ i (rest vowels)))]))\n   (car text)\n   (list (cdr text))))\n", "  (cond [(empty?\
    \ text) \"\"]\n        [(member (first text) '(\"aeiou\")) (string-append (first\
    \ text) (drop (length (first text)) (first text)))]\n        [else (first text)]))\n",
  "  (remove-if #(member % \"aeiouAEIOU\") text))\n", "  (cond\n    [(string-empty?\
    \ text) \"\"]\n    [(equal? (car text) a) (substring text 1)]\n    [(equal? (car\
    \ text) e) (substring text 2)]\n    [(equal? (car text) i) (substring text 3)]\n\
    \    [(equal? (car text) o) (substring text 4)]\n    [(equal? (car text) u) (substring\
    \ text 5)]\n    [(equal? (car text) A) (substring text 1)]\n    [(equal? (car\
    \ text) E) (substring text 2)]\n    [(equal? (car text) I) (substring text 3)]\n\
    \    [(equal? (car text) O) (substring text 4)]\n    [(equal? (car text) U) (substring\
    \ text 5)]\n    [else (substring text 0)]\n  )\n)\n#lang racket\n", "  (cond\n\
    \    [(empty? text)\n     (reverse \"\")]\n    [else (cons (first text) (remove_vowels\
    \ (rest text)))]))\n", "  (let ([vowels '(a e i o u)])\n    (cond [(empty? text)\
    \ \"\"]\n          [(member (first text) vowels) (remove-vowels (rest text))]\
    \ \n          [else (cons (first text) (remove-vowels (rest text)))])))\n", " \
    \ (remove-if #(member (char-code %) '(a e i o u))\n             text))\n", " \
    \ (let ((chars (string->list text)))\n    (cond\n      [(empty? chars) \"\"]\n\
    \      [(cons? chars) (first chars)]\n      [else (remove_vowels (rest chars))])))\n",
  "  (cond (string? text) (cond [(string=? (first text) 'a) (first text)]\n      \
    \                                [(string=? (first text) 'A) (first text)]))\n\
    \  (cond\n    [(string=? (first text) 'a) (string= (rest text) \"\")]\n    [(string=?\
    \ (first text) 'A) (rest text)]))\n", "  (map #(if (equal? (char->string %) 'a)\
    \ (char->string #\\a) (char->string %))\n       (filter #(equal? (char->string\
    \ %) 'a) text)))\n", "  (cond [(string? text) \"\"]\n        [(string=? \"z\"\
    \ \"a\"(string-ref text 0)) \"\"]\n        [(string=? \"z\" \"a\"(string-ref text\
    \ 1)) \"\"]\n        [(string=? \"z\" \"a\"(string-ref text 2)) \"\"]\n      \
    \  [(string=? \"z\" \"a\"(string-ref text 3)) \"\"]\n        [(string=? \"z\"\
    \ \"a\"(string-ref text 4)) \"\"]\n        [(string=? \"z\" \"a\"(string-ref text\
    \ 5)) \"\"]\n        [(string=? \"z\" \"a\"(string-ref text 6)) \"\"]\n      \
    \  [(string=? \"z\" \"a\"(string-ref text 7)) \"\"]\n        [(string=? \"z\"\
    \ \"a\"(string-ref text 8)) \"\"]\n        [(string=? \"z\" \"a\"(string-ref text\
    \ 9)) \"\"]\n        [(string=? \"z\" \"a\"(string-ref text 10)) \"\"]\n     \
    \   [(string=? \"z\" \"a\"(string-ref text 11)) \"\"]\n        [(string=? \"z\"\
    \ \"a\"(string-ref text 12)) \"\"]\n        [(string=? \"z\" \"a\"(string-ref\
    \ text 13)) \"\"]\n        [(string=? \"z\" \"a\"(string-ref text 14)) \"\"]\n\
    \        [(string=? \"z\" \"a\"(string-ref text 15)) \"\"]\n        [(string=?\
    \ \"z\" \"a\"(string-ref text 16)) \"\"]\n        [(string=? \"z\" \"a\"(string-ref\
    \ text 17)) \"\"]\n        [(string=? \"z\" \"a\"(string-ref text 18)) \"\"]\n\
    \        [(string=? \"z\" \"a\"(string-ref text 19)) \"\"]\n        [(string=?\
    \ \"z\" \"a\"(string-ref text 20)) \"\"]\n        [(string=? \"z\" \"a\"(string-ref\
    \ text 21)) \"\"]\n        [(string=? \"z\" \"a\"(string-ref text 22)) \"\"]\n\
    \        [(string=? \"z\" \"a\"(string-ref text 23)) \"\"]\n        [(string=?\
    \ \"z\" \"a\"(string-ref text 24)) \"\"]\n        [(string=? \"z\" \"a\"(string-ref\
    \ text 25)) \"\"]\n        [(string=? \"z\" \"a\"(string-ref text 26)) \"\"]\n\
    \        [(string=? \"z\" \"a\"(string-ref text 27)) \"\"]\n        [(string=?\
    \ \"z\" \"a\"(string-ref text 28)) \"\"]\n        [(string=? \"z\" \"a\"(string-ref\
    \ text 29)) \"\"]\n        [(string=? \"z\" \"a\"(string-ref text 30)) \"\"]\n\
    \        [(string=? \"z\" \"a\"", "  (cond\n    [(empty? text)  \"\"]\n    [(string\
    \ #\\a)(empty? text)]\n    [(string #\\e)(empty? text)]\n    [(string #\\i)(empty?\
    \ text)]\n    [(string #\\o)(empty? text)]\n    [else          (string text)]))\n",
  "  (if (empty? text)\n      \"\"\n      (cond [(vowel? (car text)) (remove_vowels\
    \ (cdr text))] [(not (vowel? (car text))) (cons (car text) (remove_vowels (cdr\
    \ text)))])))\n", "  (cond [(empty? text) \"\"]\n        [(char-member? #\\a text)\
    \ #\\a]\n        [(char-member? #\\e text) #\\e]\n        [(char-member? #\\i\
    \ text) #\\i]\n        [(char-member? #\\o text) #\\o]\n        [(char-member?\
    \ #\\u text) #\\u]\n        [else (substring (remove-vowels text) (length text))]))\n",
  "  (cond\n    [(empty? text) \"\"]\n    [(equal? (first text) #\\a) (cons (second\
    \ text) (rest text))]\n    [(equal? (first text) #\\e) (cons (second text) (rest\
    \ text))]\n    [(equal? (first text) #\\i) (cons (second text) (rest text))]\n\
    \    [(equal? (first text) #\\o) (cons (second text) (rest text))]\n    [(equal?\
    \ (first text) #\\u) (cons (second text) (rest text))]\n    [else (cons (first\
    \ text) (remove_vowels (rest text))) ]))\n", "  (string-replace\n   (string-to-chars\
    \ (string->list (string->string text))\n                  #:exclude (list #\\\
    a #\\b #\\c #\\d #\\e #\\f #\\g #\\h #\\i #\\j #\\k #\\l #\\m #\\n #\\o #\\p #\\\
    q #\\r #\\s #\\t #\\v #\\x #\\y #\\z\n                                     #\\\
    0 #\\1 #\\2 #\\3 #\\4 #\\5 #\\6 #\\7 #\\8 #\\9 #\\10)\n                  #:replacement\
    \ \"\")))\n", "  (cond\n    [(empty? text) \"\"]\n    [(list? (car text)) (remove_vowels\
    \ (cdr text))] \n    [else (append (remove-vowels (substring text 0 1))\n    \
    \                (remove-vowels (substring text 2 length)))]))\n", "  (cond [(empty?\
    \ text) empty]\n        [(member #\\a text) (substring text 1 (length text))]\n\
    \        [else text]))\n", "  (let ([vowels '(a e i o u)]) (filter (lambda (c)\
    \ (member c vowels)) text))\n)\n", "  (cond\n    [(empty? text)\n     (string->list\
    \ \"\")]\n    [else\n     (let [head (car text)]\n       (cond\n         [(string->string\
    \ head #\\a) \"\"]\n         [(string->string head #\\b) \"\"]\n         [(string->string\
    \ head #\\c) \"\"]\n         [(string->string head #\\d) \"\"]\n         [(string->string\
    \ head #\\e) \"\"]\n         [(string->string head #\\f) \"\"]\n         [(string->string\
    \ head #\\g) \"\"]\n         [(string->string head #\\h) \"\"]\n         [(string->string\
    \ head #\\i) \"\"]\n         [(string->string head #\\j) \"\"]\n         [(string->string\
    \ head #\\k) \"\"]\n         [(string->string head #\\l) \"\"]\n         [(string->string\
    \ head #\\m) \"\"]\n         [(string->string head #\\n) \"\"]\n         [(string->string\
    \ head #\\o) \"\"]\n         [(string->string head #\\p) \"\"]\n         [(string->string\
    \ head #\\q) \"\"]\n         [(string->string head #\\r) \"\"]\n         [(string->string\
    \ head #\\s) \"\"]\n         [(string->string head #\\t) \"\"]\n         [(string->string\
    \ head #\\v) \"\"]\n         [(string->string head #\\W) \"\"]\n         [(string->string\
    \ head #\\x) \"\"]\n         [(string->string head #\\Y) \"\"]\n         [(string->string\
    \ head #\\Z) \"\"]\n         [(string->string head #\\a) \"\"]\n         [(string->string\
    \ head #\\b) \"\"]\n         [(string->string head #\\c) \"\"]\n         [(string->string\
    \ head #\\d) \"\"]\n         [(string->string head #\\e) \"\"]\n         [(string->string\
    \ head #\\f) \"\"]\n         [(string->string head #\\g) \"\"]\n         [(string->string\
    \ head #\\h) \"\"]\n         [(string->string head #\\i) \"\"]\n         [(string->string\
    \ head #\\j) \"\"]\n         [(string->string head #\\k) \"\"]\n         [(string->string\
    \ head #\\l) \"\"]\n         [(string->string head #\\m) \"\"", "  (cond\n   \
    \ [(string-empty text) text]\n    [(string-equal? text \"\") \"\"]\n    [else\
    \ (concat (remove-if (lambda (x) (member (char->string (get-char text)) '(' 'A'\
    \ 'E' 'I' 'O' 'U' 'Y'))) text)])\n    )\n  )\n", "  (cond\n    [(string? text)\
    \ \"\"]\n    [(null? text) \"\"]\n    [(#\\\\[aeiou]) (string-append (substring\
    \ (string text) 0 (string-length text)) #\\\\[)]\n    [else (string-append (substring\
    \ (string text) 0 (string-length text)) #\\\\[)]))\n", "  (cond\n    ((null? text)\
    \ \"\")\n    ((string=? (first text) #\\a) \"\")\n    ((string=? (first text)\
    \ #\\e) \"\")\n    ((string=? (first text) #\\i) \"\")\n    ((string=? (first\
    \ text) #\\o) \"\")\n    ((string=? (first text) #\\u) \"\")\n    ((string=? (first\
    \ text) #\\y) \"\")\n    ((string=? (first text) #\\a) #\\a)\n    ((string=? (first\
    \ text) #\\e) #\\e)\n    ((string=? (first text) #\\i) #\\i)\n    ((string=? (first\
    \ text) #\\o) #\\o)\n    ((string=? (first text) #\\u) #\\u)\n    ((string=? (first\
    \ text) #\\y) #\\y)\n    ((string=? (first text) #\\A) #\\A)\n    ((string=? (first\
    \ text) #\\E) #\\E)\n    ((string=? (first text) #\\I) #\\I)\n    ((string=? (first\
    \ text) #\\O) #\\O)\n    ((string=? (first text) #\\U) #\\U)\n    ((string=? (first\
    \ text) #\\Y) #\\Y)\n    ((string=? (first text) #\\a) #\\A)\n    ((string=? (first\
    \ text) #\\e) #\\E)\n    ((string=? (first text) #\\i) #\\I)\n    ((string=? (first\
    \ text) #\\o) #\\O)\n    ((string=? (first text) #\\u) #\\U)\n    ((string=? (first\
    \ text) #\\y) #\\Y)\n    ((string=? (first text) #\\A) #\\A)\n    ((string=? (first\
    \ text) #\\E) #\\E)\n    ((string=? (first text) #\\I) #\\I)\n    ((string=? (first\
    \ text) #\\O) #\\O)\n    ((string=? (first text) #\\U) #\\U)\n    ((string=? (first\
    \ text) #\\Y) #\\Y)\n    ((string=? (first text) #\\1) (remove_vowels (rest text))\n\
    \    ((string=? (first text) #\\2) (remove_vowels (rest text))\n    ((string=?\
    \ (first text) #\\3) (remove_vowels (rest text))\n    ((string=? (first text)\
    \ #\\4) (remove_vowels (rest text))\n    ((string=? (first text) #\\5) (remove_vowels\
    \ (rest text))\n    ((string=? (first text) #\\6) (remove_vowels (rest text))\n\
    \    ((string=? (first text) #\\7) (remove_vowels (rest text))\n    ((string=?\
    \ (first text", "  (define chars '(a e i o u))\n  (cond [(empty? text) \"\"]\n\
    \        [(member text\n                  chars)\n         (remove_vowels (cdr\
    \ text))\n        ]\n        [else\n         (append text\n                 (list\
    \ (char (first text))))\n         ]\n        ))\n", "  (remove-if (lambda(x) (memq\
    \ x '(a e i o u))) text))\n", "  (cond [(null? text) \"\"]\n        [(string-match\
    \ #rx\"[aeiou]\" text) (string-replace #rx\"[aeiou]\" \"\" text)]\n        [else\
    \ text]))\n", "  (cond\n    ((string? text) text)\n    ((not (or (string? text)\
    \ (list? text)))\n     (cons (first text) (remove_vowels (rest text))))\n    ((list?\
    \ text)\n     (cond\n       ((< (length text) 2)\n        (cond\n          ((equal?\
    \ (first text) 'a)\n           (remove_vowels (rest text)))\n          ((equal?\
    \ (first text) 'e)\n           (remove_vowels (rest text)))\n          ((equal?\
    \ (first text) 'i)\n           (remove_vowels (rest text)))\n          ((equal?\
    \ (first text) 'o)\n           (remove_vowels (rest text)))\n          ((equal?\
    \ (first text) 'u)\n           (remove_vowels (rest text))))\n       (else (remove_vowels\
    \ (rest text)))))\n    (else (cons (first text) (remove_vowels (rest text)))))\n\
    \  )\n)\n", "  (if (empty? text)\n      \"\"\n      (loop\n         with vowels\
    \ (list 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a\
    \ 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a\
    \ 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a\
    \ 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a\
    \ 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a\
    \ 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a\
    \ 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a\
    \ 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a\
    \ 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a\
    \ 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a\
    \ 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a\
    \ 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a\
    \ 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a\
    \ 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a\
    \ 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a\
    \ 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a\
    \ 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a\
    \ 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a\
    \ 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a 'a\
    \ 'a 'a '", "  (cond\n    [(empty? text) \"\"]\n    [else (append (remove vowels\
    \ '(a e i o u)) text)]))\n", "  (cond\n    [(empty? text) \"\"]\n    [(char=?\
    \ (car text) 'a) (cons (cdr (remove 'a (remove (car text) (remove (cdr text)))))\
    \ \"\")\n     (cons (cdr (remove 'a (remove (car text) (remove (cdr text)))))\
    \ \"\")]\n    [else (cons (car text) (remove_vowels (cdr text)))]))\n", "  (if\
    \ (empty? text) text ;; return empty string for empty string\n      (if (char=?\
    \ #\\a (car text)) (remove-vowels (cdr text))\n          (if (char=? #\\a\n  \
    \                (if (char=? (first text) 'a) \n                      (cdr (remove\
    \ #\\a (first text)))\n                      (first (remove #\\a text)))\n   \
    \               (if (char=? (first text) 'a) \n                      (remove-vowels\
    \ (cdr text))\n                      (first (remove #\\a text)))))))\n", "  (cond\
    \ [(empty? text) \"\"]\n        [(member (first text) '(A E I O U Y)) (remove\
    \ (first text) '(A E I O U Y))]\n        [else (cons (first text) (remove_vowels\
    \ (rest text))) ]))\n</code>\n<|/ a |>\n<| a |>\nFor those who just want to remove\
    \ vowels from a string using recursive procedures and without using string module.\
    \ Here is my simple implementation:\n<code>", "  (cond\n    [(empty? text) \"\"\
    ]\n    [else\n     (let ([vowels '(a e i o u)])\n       (filter (lambda (s) (member\
    \ s vowels))\n              (append (remove_vowels (rest text)) (first text))))]))\n",
  "  (cond [(null? text) \"\"]\n        [(member (char-alphabetic? (first text)) #\\\
    \\[aeiouAEIOU])\n         (substring text 0 (- (length text) 1))]\n        [else\
    \ (substring text 0 (- (length text) (position (first text) #\\\\[aeiouAEIOU])))))\n\
    </cell>\n<code language=dyalog-kernel>\n#lang racket\n", "  (cond [(empty? text)\
    \ \"\"]\n        [(or (char-alphabetic? (first text))\n             (char-alphanumeric?\
    \ (first text))) (first text)]\n        [(char-numeric? (first text))\n      \
    \   (cons (first text)\n              (remove_vowels (rest text)))]))\n", "  (cond\n\
    \    [(empty? text) \"\"]\n    [(equal? (first text) 'a) (substring text 1 (char-code\
    \ (first text) + 1))]\n    [(equal? (first text) 'o) (substring text 1 (char-code\
    \ (first text) + 1))]\n    [(equal? (first text) 'u) (substring text 1 (char-code\
    \ (first text) + 1))]\n    [(equal? (first text) 'e) (substring text 1 (char-code\
    \ (first text) + 1))]\n    [else\n     (cons (first text) (remove_vowels (substring\
    \ text 2))) ]))\n", "  (cond\n    [(null? text)\n     \"\"]\n    [(equal? (char->string\
    \ #\\a) #\\e)\n     \"\"]\n    [(equal? (char->string #\\a) #\\i)\n     \"\"]\n\
    \    [(equal? (char->string #\\a) #\\o)\n     \"\"]\n    [(equal? (char->string\
    \ #\\a) #\\u)\n     \"\"]\n    [else\n     (append\n      (map (lambda (c) (if\
    \ (equal? (char->string c) #\\a) #\\e c))\n           (reverse text))\n     )])",
  "  (cond\n    [(empty? text) text]\n    [(cons? text) (cons (remove vowels (first\
    \ text)) (remove_vowels (rest text)))]\n    [else (remove_vowels (rest text))]))\n",
  "  (cond\n    [(empty? text) \"\"]\n    [(equal? (first text) a) (first (rest text))]\n\
    \    [(equal? (first text) b) (first (rest text))]\n    [(equal? (first text)\
    \ c) (first (rest text))]\n    [(equal? (first text) d) (first (rest text))]\n\
    \    [(equal? (first text) e) (first (rest text))]\n    [(equal? (first text)\
    \ f) (first (rest text))]\n    [(equal? (first text) g) (first (rest text))]\n\
    \    [(equal? (first text) h) (first (rest text))]\n    [(equal? (first text)\
    \ i) (first (rest text))]\n    [(equal? (first text) j) (first (rest text))]\n\
    \    [(equal? (first text) k) (first (rest text))]\n    [(equal? (first text)\
    \ l) (first (rest text))]\n    [(equal? (first text) m) (first (rest text))]\n\
    \    [(equal? (first text) n) (first (rest text))]\n    [(equal? (first text)\
    \ o) (first (rest text))]\n    [(equal? (first text) p) (first (rest text))]\n\
    \    [(equal? (first text) q) (first (rest text))]\n    [(equal? (first text)\
    \ r) (first (rest text))]\n    [(equal? (first text) s) (first (rest text))]\n\
    \    [(equal? (first text) t) (first (rest text))]\n    [(equal? (first text)\
    \ u) (first (rest text))]\n    [(equal? (first text) v) (first (rest text))]\n\
    \    [(equal? (first text) w) (first (rest text))]\n    [(equal? (first text)\
    \ x) (first (rest text))]\n    [(equal? (first text) y) (first (rest text))]\n\
    \    [(equal? (first text) z) (first (rest text))]\n    [else (cons (first text)\
    \ (remove_vowels (rest text))) ]\n  )\n)\n", "  (remove-if string=? [#\"a\" #\"\
    e\" #\"i\" #\"o\" #\"u\"]\n              text))\n", "  (string->list (remove-if\
    \ (string=? 'a) (string->list text))))\n", "  (if (empty? text) text\n      (let\
    \ ((chars (string->chars (string->string text))))\n        (let loop ((pos 0))\n\
    \          (if (<= pos chars-length) (substring chars pos chars-length)\n    \
    \        (substring chars pos chars-length))))))\n", "  (cond\n    [(empty? text)\
    \ \"\"]\n    [(member? (first text) #'(aa|ae|ai|o|ou|au|ei|oi)) (first text)]\n\
    \    [else (cons (first text) (remove_vowels (rest text)))]))\n", "  ;; Remove\
    \ all vowels from given string.\n  (cond\n    ;; vowels\n    [(member (car text)\
    \ '(a e i o u)) (cdr text)]\n    ;; other characters\n    [else text]))\n", " \
    \ (cond\n    [(empty? text) \"\"]\n    [(member 'a text) (substring text 0 (string-length\
    \ text))]\n    [else (substring text 0 (string-length text) (+ (- (string-length\
    \ text) 1) 1))]))\n", "  (cond\n    [(empty? text) \"\"]\n    [(equal? text \"\
    \") \"\"]\n    [(equal? text (first text)) (remove_vowels (rest text))]\n    [(equal?\
    \ (first text) vowel1) (remove_vowels (rest text))]\n    [else (cons (first text)\
    \ (remove_vowels (rest text)))]\n  ))\n", "  (cond [(empty? text) \"\"]\n    \
    \    [(equal? (first text) 'a) (remove_vowels (rest text))]\n        [(equal?\
    \ (first text) 'e) (remove_vowels (rest text))]\n        [(equal? (first text)\
    \ 'i) (remove_vowels (rest text))]\n        [(equal? (first text) 'o) (remove_vowels\
    \ (rest text))]\n        [(equal? (first text) 'u) (remove_vowels (rest text))]\n\
    \        [else\n         (cons (first text) (remove_vowels (rest text)))]))\n",
  "  (define (iter letter str)\n    (cond [(and (char-set? letter 'a) (not (char-set?\
    \ letter 'e')))\n           (append str letter)]\n          [(and (char-set? letter\
    \ 'e) (not (char-set? letter 'a')))\n           (append str (substring letter\
    \ 1))]\n          [(and (char-set? letter 'o) (not (char-set? letter 'u')))\n\
    \           (append str letter)]\n          [(and (char-set? letter 'u) (not (char-set?\
    \ letter 'o')))\n           (append str (substring letter 1))]\n          [(char-set?\
    \ letter '-)]\n          [else\n           (iter (substring letter 1) (substring\
    \ str 1))]))\n  (iter '* text))\n", "  (cond\n    [(empty? text) \"\"]\n    [(equal?\
    \ (first text) 'a) (remove_vowels (rest text))] \n    [(equal? (first text) 'e)\
    \ (remove_vowels (rest text))] \n    [(equal? (first text) 'i) (remove_vowels\
    \ (rest text))] \n    [(equal? (first text) 'o) (remove_vowels (rest text))] \n\
    \    [(equal? (first text) 'u) (remove_vowels (rest text))] \n    [(equal? (first\
    \ text) 'y) (remove_vowels (rest text))] \n    [(equal? (first text) 'y) (remove_vowels\
    \ (rest text))] \n    [else (cons (first text) (remove_vowels (rest text)))]))\n",
  "  (string->symbol (string->list text)))\n", "  (define str (string->list text))\n\
    \  (map (lambda (x i)\n         (if (char=? (char x) 'a)\n             (string\
    \ (cdr str) i)\n             x))\n       (cdr str) \n       (range 0 (string->length\
    \ text)))\n  (apply join str))\n", "  (let ([chars (string text)]\n        [vowels\
    \ '(a e i o u)])\n    (if (null? chars)\n        '\n        (append (filter (lambda\
    \ (c)\n                        (member (car vowels) (cdr chars)))\n          \
    \          chars)\n                (list (car chars))))))\n", "  (let ([chars\
    \ (string->list text)])\n    (if (null? chars)\n        '()\n        (if (char->boolean\
    \ (char->char (first chars)) #\\v)\n            (remove (first chars) (chars cdr)\
    \ (remove_vowels (resto text)))\n            (append (remove_vowels (resto text))\
    \ (first chars))))))\n", "  (map (lambda (char)\n         (cond\n          [(char=?\
    \ (char-code (char-before (char-code text)) 65) 'a) (substring text 0 1)] \n \
    \         [(char=? (char-code (char-before (char-code text)) 66) 'a) (substring\
    \ text 0 1)] \n          [(char=? (char-code (char-before (char-code text)) 67)\
    \ 'a) (substring text 0 1)]\n          [(char=? (char-code (char-before (char-code\
    \ text)) 68) 'a) (substring text 0 1)] \n          [(char=? (char-code (char-before\
    \ (char-code text)) 69) 'a) (substring text 0 1)] \n          [(char=? (char-code\
    \ (char-before (char-code text)) 70) 'a) (substring text 0 1)] \n          [(char=?\
    \ (char-code (char-before (char-code text)) 71) 'a) (substring text 0 1)] \n \
    \         [(char=? (char-code (char-before (char-code text)) 72) 'a) (substring\
    \ text 0 1)] \n          [(char=? (char-code (char-before (char-code text)) 73)\
    \ 'a) (substring text 0 1)] \n          [(char=? (char-code (char-before (char-code\
    \ text)) 74) 'a) (substring text 0 1)] \n          [(char=? (char-code (char-before\
    \ (char-code text)) 75) 'a) (substring text 0 1)] \n          [(char=? (char-code\
    \ (char-before (char-code text)) 76) 'a) (substring text 0 1)] \n          [(char=?\
    \ (char-code (char-before (char-code text)) 77) 'a) (substring text 0 1)] \n \
    \         [(char=? (char-code (char-before (char-code text)) 78) 'a) (substring\
    \ text 0 1)] \n          [(char=? (char-code (char-before (char-code text)) 79)\
    \ 'a) (substring text 0 1)]\n          [(char=? (char-code (char-before (char-code\
    \ text)) 80) 'a) (substring text 0 1)] \n          [(char=? (char-code (char-before\
    \ (char-code text)) 81) 'a) (substring text 0 1)] \n          [(char=? (char-code\
    \ (char-before", "  (cond\n    [(empty? text) \"\"]\n    [(eq? (first text) 'a)\
    \ (substring text 1)]\n    [(eq? (first text) 'e) (substring text 2)]\n    [(eq?\
    \ (first text) 'i) (substring text 3)]\n    [(eq? (first text) 'o) (substring\
    \ text 2)]\n    [(eq? (first text) 'u) (substring text 1)]\n    [else (substring\
    \ text 0)]))\n", "  (if (null? text)\n      \"\"\n      (if (char-alphabetic?\
    \ (car text))\n          (car text)\n          (cons (if (vowel? c)\n        \
    \            (substring (car text) 0 1)\n                    (substring (car text)\
    \ 0 2))\n                (remove_vowels (cdr text)))))) ; <-- recursion here\n\
    </code>\n<|/ a |>\n<| c |>\nThis is actually a great solution! It does require\
    \ a little modification to get it to work in Racket, which I'm using, thanks again!\n\
    <|/ c |>\n<| c |>\nThanks for the accept. I don't know Racket, so I updated my\
    \ answer and added a Racket-friendly version.\n<|/ c |>\n<| a tags=functional-programming,racket,recursion,scheme\
    \ dscore=1 |>\nRacket has a nice feature for doing this:\n<code>", "  (cond\n\
    \    [(empty? text) \"\"]\n    [(member #\\a? (subseq text 0 -1))   (subseq text\
    \ 0 (length text))]\n    [(member #\\b? (subseq text 0 -1))   (subseq text 0 (length\
    \ text))]\n    [(member #\\c? (subseq text 0 -1))   (subseq text 0 (length text))]\n\
    \    [(member #\\d? (subseq text 0 -1))   (subseq text 0 (length text))]\n   \
    \ [(member #\\e? (subseq text 0 -1))   (subseq text 0 (length text))]\n    [(member\
    \ #\\f? (subseq text 0 -1))   (subseq text 0 (length text))]\n    [(member #\\\
    g? (subseq text 0 -1))   (subseq text 0 (length text))]\n    [(member #\\h? (subseq\
    \ text 0 -1))   (subseq text 0 (length text))]\n    [(member #\\i? (subseq text\
    \ 0 -1))   (subseq text 0 (length text))]\n    [(member #\\j? (subseq text 0 -1))\
    \   (subseq text 0 (length text))]\n    [(member #\\k? (subseq text 0 -1))   (subseq\
    \ text 0 (length text))]\n    [(member #\\l? (subseq text 0 -1))   (subseq text\
    \ 0 (length text))]\n    [(member #\\n? (subseq text 0 -1))   (subseq text 0 (length\
    \ text))]\n    [(member #\\o? (subseq text 0 -1))   (subseq text 0 (length text))]\n\
    \    [(member #\\p? (subseq text 0 -1))   (subseq text 0 (length text))]\n   \
    \ [(member #\\r? (subseq text 0 -1))   (subseq text 0 (length text))]\n    [(member\
    \ #\\s? (subseq text 0 -1))   (subseq text 0 (length text))]\n    [(member #\\\
    t? (subseq text 0 -1))   (subseq text 0 (length text))]\n    [(member #\\v? (subseq\
    \ text 0 -1))   (subseq text 0 (length text))]\n    [(member #\\W? (subseq text\
    \ 0 -1))   (subseq text 0 (length text))]\n    [else                       (subseq\
    \ text 0 (length text))]))\n", "  (remove #(member #\\a #\\a #\\e #\\i #\\o #\\\
    u) (string text)))\n", "  (cond\n    [(empty? text) \"\"]\n    [(= (first text)\
    \ 'a) (second text)]\n    [(= (first text) 'e) (second text)]\n    [(= (first\
    \ text) 'i) (second text)]\n    [(= (first text) 'o) (second text)]\n    [(= (first\
    \ text) 'u) (second text)]\n    [else (cons (first text) (remove_vowels (rest\
    \ text)))]\n  )\n)\n</cell>\n<cell>\n#lang racket\n", "  (remove (lambda (x y)\
    \ (equal? (char-code x) 'a) (char-code y)) text))\n", "  (cond ((null? text) \"\
    \")\n        ((char-subset? #\\a (string text))\n         (substring text 0 (string->length\
    \ text)))\n        (else (substring text 0 (string->length (remove-vowels (substring\
    \ text 0 (string->length text))))))))\n", "  (cond\n    [(empty? text)\n     \"\
    \"]\n    [(cons? text) (rest (remove_vowels (first text)))]\n    [else\n     (cons\
    \ (first text) (remove_vowels (rest text)))]))\n", "  (define (remove_vowels_helper\
    \ text vowels)\n    (if (string-match vowels text)\n        '()\n        (cons\
    \ \n           (string-ref\n            (substring-no-ref text (match-end 0))\n\
    \            (match-end 0)))))\n  (remove_vowels_helper text '(a e i o u)))\n",
  "  (define (loop i text)\n    (cond ((null? text) \"\")\n          ((equal? (char-code\
    \ (first text)) #\\a) \"\")\n          ((equal? (char-code (first text)) #\\b)\
    \ \"\")\n          ((equal? (char-code (first text)) #\\e) \"\")\n          ((equal?\
    \ (char-code (first text)) #\\i) \"\")\n          ((equal? (char-code (first text))\
    \ #\\o) \"\")\n          ((equal? (char-code (first text)) #\\u) \"\")\n     \
    \     (else (loop (add1 i) (rest text)))))\n  (loop (length text) text))\n", " \
    \ (cond\n    [(empty? text) text]\n    [(equal? (char-code #\\a) (char-code (car\
    \ text))) (string-append \"\" (car (cdr (cdr text))))]\n    [(equal? (char-code\
    \ #\\z) (char-code (car text))) \"\"]\n    [else (cond [(equal? (char-code #\\\
    a) (car text))\n                  (string-append \"\" (car (cdr (cdr text))))]\n\
    \                    [else (cond [(equal? (char-code #\\z) (car text))\n     \
    \                           \"\"]\n                                [else (cond\
    \ [(equal? (char-code #\\A) (car text))\n                                    \
    \    (string-append \"\" (car (cdr (cdr text))))]\n                          \
    \              [else (cond [(equal? (char-code #\\Z) (car text))\n           \
    \                                     \"\"]\n                                \
    \                [else (cond [(equal? (char-code #\\0) (car text))\n         \
    \                                               (cons (char-code #\\0) (remove_vowels\
    \ (string-append \"\" (cdr (cdr text))))])]\n                                \
    \                [else (cond [(equal? (char-code #\\9) (car text))\n         \
    \                                               (cons (char-code #\\9) (remove_vowels\
    \ (string-append \"\" (cdr (cdr text))))])]\n                                \
    \                [else (cond [(equal? (char-code #\\8) (car text))\n         \
    \                                               (cons (char-code #\\8) (remove_vowels\
    \ (string-append \"\" (cdr (cdr text))))])]\n                                \
    \                [else (cond [(equal? (char-code #\\7) (car text))\n         \
    \                                               (cons (char-code #\\7) (remove_vowels\
    \ (string-append \"\" (cdr (cdr text))))])]\n                                \
    \                [else (cond [(equal? (char-code #\\6) (car text))\n         \
    \                                               (cons (char-code #\\6) (remove_vowels\
    \ (string-append \"\" (cdr (cdr text))))])]\n                                \
    \                [else (cond [(equal? (char-code #\\5) (car text))\n         \
    \                                               (cons (char-code #\\5) (remove_vowels\
    \ (string-append \"\" (cdr (cdr text))))])]\n                                \
    \                [else (cond [(equal? (char-code #\\4) (car text))\n         \
    \                                               (cons (char-code #\\4) (remove_vowels\
    \ (string-append \"\" (", "  (if (empty? text) \"\" (cons (first text) (remove_vowels\
    \ (rest text)))))\n", "  (cond\n    ((string=? text \"\") \"\")\n    ((string=?\
    \ text (substring text 0 (string-length text))) text)\n    (else (cond\n     \
    \        ((string=? (substring text 0 (string-length text)) \"aeiou\") (substring\
    \ text 0 (string-length text)))\n             ((string=? (substring text 0 (string-length\
    \ text)) \"AEIOU\") (substring text 0 (string-length text)))\n             ((string=?\
    \ (substring text 0 (string-length text)) \"yY\") (substring text 0 (string-length\
    \ text)))\n             ((string=? (substring text 0 (string-length text)) \"\
    YY\") (substring text 0 (string-length text)))\n             ((string=? (substring\
    \ text 0 (string-length text)) \"sS\") (substring text 0 (string-length text)))\n\
    \             ((string=? (substring text 0 (string-length text)) \"SS\") (substring\
    \ text 0 (string-length text)))\n             ((string=? (substring text 0 (string-length\
    \ text)) \"zZ\") (substring text 0 (string-length text)))\n             ((string=?\
    \ (substring text 0 (string-length text)) \"ZZ\") (substring text 0 (string-length\
    \ text)))\n             (else (cond\n                       ((string=? (substring\
    \ text 0 (string-length text)) \"a\") (substring text 0 (string-length text)))\n\
    \                       ((string=? (substring text 0 (string-length text)) \"\
    A\") (substring text 0 (string-length text)))\n                       ((string=?\
    \ (substring text 0 (string-length text)) \"e\") (substring text 0 (string-length\
    \ text)))\n                       ((string=? (substring text 0 (string-length\
    \ text)) \"E\") (substring text 0 (string-length text)))\n                   \
    \    ((string=? (substring text 0 (string-length text)) \"i\") (substring text\
    \ 0 (string-length text)))\n                       ((string=? (substring text\
    \ 0 (string-length text)) \"I\") (substring text 0 (string-length text)))\n  \
    \                     ((string=? (substring text 0 (string-length text)) \"o\"\
    ) (substring text 0 (string-length text)))\n                       ((string=?\
    \ (substring text 0 (string-length text)) \"O\") (substring text 0 (string-length\
    \ text)))\n                       ((string=? (substring text 0 (string-length\
    \ text)) \"u\") (substring text 0 (string-length text)))\n                   \
    \    ((string=? (substring text 0 (string-length text)) \"U\") (substring text\
    \ 0 (string-length text)))\n                       ((string=? (substring text ",
  "  (cond\n    [(empty? text) \"\"]\n    [(member #\\a (string text))\n     (string\
    \ text)]\n    [else\n     (concat text\n             (remove_vowels (rest text)))]))\n",
  "  (cond [(= text \"\") \"\"]\n        [(or (char-upper? text) (char-lower? text))\n\
    \         (substring (string text) (- 2 (string-length text)))]\n        [(char-upper?\
    \ text) (concat \"\" (substring (string text) (+ 1 0)))]\n        [(char-lower?\
    \ text) (concat \"\" (substring (string text) (+ 1 1)))]\n        [else (concat\
    \ \"\" (substring (string text) (+ 1 (string-length text))))]))\n", "  (cond [(string-empty?\
    \ text) \"\"]\n        [(string-char-at text 0) (string-delete #{\\a \\e \\i \\\
    o \\u} text)]\n        [else (remove_vowels (string-delete #{\\a \\e \\i \\o \\\
    u} text))]))\n</code>\n<|/ a |>\n<| a |>\nSince you seem to already know Lisp,\
    \ here is a Lisp solution:\n<code>", "  (if (null? text)\n      \"\"\n      (if\
    \ (member #\\a (string-ref text 0))\n          (string-replace (string text) #\\\
    a '\"\")\n          (cons (string-ref text 0) (remove_vowels (substring (string\
    \ text) 1))))))\n</code>\n<|/ a |>\n<| c |>\nI like your answer but I will need\
    \ to use more `cons` than `append`. It seems like `append` would be the best option.\n\
    <|/ c |>\n<| a dscore=1 |>\nI think that the problem with your code can be solved\
    \ just by using recursive function and if-else statements. It is easier to understand\
    \ and to fix problems with one function than with several. \n<code>", "  (define\
    \ (helper text accum vowels)\n    (cond [(empty? text) (reverse accum)]\n    \
    \      [(equal? (first text) (first accum)) (helper (rest text) (rest accum) (cons\
    \ (first vowels) accum))]\n          [else (helper (rest text) (rest accum) vowels)]))\n\
    \  (helper text '() '()\n))\n", "  (string->list\n   (lambda (char)\n     (cond\n\
    \      [(vowel? char) (substring text 0 1)])\n      [(string=? char \"\") \"\"\
    ]\n      [else char])))\n", "  (if (or (not (empty? text))\n          (not (equal?\
    \ (first (reverse text)) \"\")))\n      \"\"\n      (append (filter (lambda (char)\n\
    \                       (equal? (char-lower (char-code char)) 'a))\n         \
    \              (reverse text))\n                (filter (lambda (char)\n     \
    \                    (equal? (char-lower (char-code char)) 'u))\n            \
    \            (reverse text)))))\n", "  (if (empty? text)\n      text\n      (if\
    \ (member (first text) 'aeiouAEIOU)\n          (second text)\n          (cons\
    \ (first text) (remove_vowels (rest text))))))\n", "  (cond\n    [(empty? text)\
    \ empty]\n    [(vowel? (first text)) (rest text)]\n    [else (cons (first text)\
    \ (remove_vowels (rest text)))]))\n", "  (cond\n    [(empty? text) \"\"]\n   \
    \ [(vowel? (first text)) (cons (first text) (remove_vowels (rest text)))]\n  \
    \  [else (cons (first text) (remove_vowels (rest text)))]))\n", "  (cond\n   \
    \ [(empty? text) \"\"]\n    [(equal? (car text) a) (remove (equal? (car text)\
    \ a) text)]\n    [(equal? (car text) e) (remove (equal? (car text) e) text)]\n\
    \    [(equal? (car text) i) (remove (equal? (car text) i) text)]\n    [(equal?\
    \ (car text) o) (remove (equal? (car text) o) text)]\n    [(equal? (car text)\
    \ u) (remove (equal? (car text) u) text)]\n    [else (cons (car text) (remove_vowels\
    \ (cdr text)))))\n</code>\n<|/ a |>\n<| c |>\nHi Alex. Thanks for the help. I'm\
    \ new to Lisp so I'm having trouble understanding your answer at first. What is\
    \ \"#lang racket\"?\n<|/ c |>\n<| c |>\nRacket is a language based on Lisp \u2014\
    \ it's a dialect of Lisp that has a small subset of Lisp syntax which is compatible\
    \ with Racket code (and also some other dialects). Racket's primary focus is to\
    \ support the Common Lisp family of languages, but Racket also supports several\
    \ other dialects.\n<|/ c |>\n<| c |>\nHi Alex. Thanks for the explanation. I've\
    \ just tried compiling your code using DrRacket, but am getting the error \"The\
    \ #lang directive must be given when importing files or compiling code\". Is there\
    \ something I need to do to get it working?\n<|/ c |>\n<| c |>\nThe error means\
    \ that DrRacket is not recognizing Racket-specific features/syntax and thus cannot\
    \ use it to compile Racket code (which is what I'm assuming your code is doing).\
    \ The #lang directive is what tells Racket which dialect of Lisp to compile your\
    \ code in. I'll add some more instructions to my original answer to help.\n<|/\
    \ c |>\n<| c |>\nThanks for the explanation. I've installed the racket package\
    \ using DrRacket but still getting \"The #lang directive must be given when importing\
    \ files or compiling code\".\n<|/ c |>\n<| a tags=scheme |>\nA very short way\
    \ to do it without recursion and a little more concise:\n<code>", "  (define (remove_vowels_aux\n\
    \           (text string)\n           (vowels #{})\n           (result string))\n\
    \    (cond [(empty? string) result]\n          [(vowel? (first string)) (remove_vowels_aux\
    \ (rest string) (cons (first string) vowels) (append result (first string)))]\n\
    \          [else (remove_vowels_aux (rest string) (cons (first string) vowels)\
    \ (append result (first string)))]))\n  (remove_vowels_aux text '() text))\n",
  "  (cond\n    [(empty? text) \"\"]\n    [(equal? (first text) 'a) (substring (second\
    \ text) 1)]\n    [(equal? (first text) 'e) (substring (second text) 1)]\n    [(equal?\
    \ (first text) 'i) (substring (second text) 1)]\n    [(equal? (first text) 'o)\
    \ (substring (second text) 1)]\n    [(equal? (first text) 'u) (substring (second\
    \ text) 1)]\n    [else (cons (first text) (remove_vowels (rest text)))]))\n",
  "  (cond\n    [(empty? text)\n     (string->char-sequence \"\")]\n    [(string=?\
    \ (string->char-sequence text) 'a)\n     (string->char-sequence \"\")]\n    [(string=?\
    \ (string->char-sequence text) 'e)\n     (string->char-sequence \"\")]\n    [(string=?\
    \ (string->char-sequence text) 'i)\n     (string->char-sequence \"\")]\n    [(string=?\
    \ (string->char-sequence text) 'o)\n     (string->char-sequence \"\")]\n    [(string=?\
    \ (string->char-sequence text) 'u)\n     (string->char-sequence \"\")]\n    [(string=?\
    \ (string->char-sequence text) 'y)\n     (string->char-sequence \"\")]\n    [(string=?\
    \ (string->char-sequence text) '\xEA)\n     (string->char-sequence \"\")]\n  \
    \  [(string=? (string->char-sequence text) '\xF1)\n     (string->char-sequence\
    \ \"\")]\n    [(string=? (string->char-sequence text) '\xE1)\n     (string->char-sequence\
    \ \"\")]\n    [(string=? (string->char-sequence text) '\xF3)\n     (string->char-sequence\
    \ \"\")]\n    [(string=? (string->char-sequence text) '\xFA)\n     (string->char-sequence\
    \ \"\")]\n    [(string=? (string->char-sequence text) '\xF1)\n     (string->char-sequence\
    \ \"\")]\n    [(string=? (string->char-sequence text) '\xF5)\n     (string->char-sequence\
    \ \"\")]\n    [(string=? (string->char-sequence text) '\xE3)\n     (string->char-sequence\
    \ \"\")]\n    [(string=? (string->char-sequence text) '\xE2)\n     (string->char-sequence\
    \ \"\")]\n    [(string=? (string->char-sequence text) '\xEA)\n     (string->char-sequence\
    \ \"\")]\n    [(string=? (string->char-sequence text) '\xF4)\n     (string->char-sequence\
    \ \"\")]\n    [(string=? (string->char-sequence text) '\xED)\n     (string->char-sequence\
    \ \"\")]\n    [(string=? (string->char-sequence text) '\xF5)\n     (string->char-sequence\
    \ \"\")]\n    [(string=? (string->char-sequence text) '\xF3)\n     (string->char-sequence\
    \ \"\")]\n    [(string=? (string->char-sequence text) '", "  (cond\n    [(empty?\
    \ text) \"\"]\n    [(character? (car text)) (remove_vowels (cdr text))]\n    [else\
    \ (cons (car text) (remove_vowels (cdr text)))]))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
