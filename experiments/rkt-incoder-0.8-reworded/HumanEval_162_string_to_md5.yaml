name: HumanEval_162_string_to_md5
language: rkt
prompt: "#lang racket\n\n;; Given a string 'text', return its md5 hash equivalent\
  \ string.\n;; If 'text' is an empty string, return #f.\n;; >>> (string_to_md5 \"\
  Hello world\")\n;; \"3e25960a79dbc69b674cd4ec67a72c62\"\n(define (string_to_md5\
  \ text)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate string_to_md5))\n\
  \    (check-equal? (candidate \"Hello world\") \"3e25960a79dbc69b674cd4ec67a72c62\"\
  )\n    (check-equal? (candidate \"\") #f)\n    (check-equal? (candidate \"A B C\"\
  ) \"0ef78513b0cb8cef12743f5aeb35f888\")\n    (check-equal? (candidate \"password\"\
  ) \"5f4dcc3b5aa765d61d8327deb882cf99\")\n))\n\n(test-humaneval)"
completions: ["  (if (= text \"\")\n      #f\n      (hash-string (string-to-bytes\
    \ text))))\n", "  (if\n    (string=? (string->symbol (md5-text)) #f)\n    #f\n\
    \    (string-to-symbol (md5-text))))\n", "  (cond\n    [(or (string=? (string-length\
    \ text) \"\")\n         (string=? (string-length text) \"0\"))\n     (set! text\
    \ \"a\")]\n    [(equal? (string-length text) 0)\n     (set! text \"b\")]\n   \
    \ [else\n     (let* ([bytes (string-utf-8-byte text 0)])\n       (cond [(= (length\
    \ bytes) 8)\n               ;; This assumes that a byte is a valid utf-8 character,\
    \ and\n               ;; that it is 8 bits long\n               (set! text (string-to-md5\
    \ (substring text 1)))]\n             [else\n               (set! text (string-to-md5\n\
    \                           (string-append\n                            (substring\
    \ text 0 (length bytes-1))\n                            (substring bytes \"-\"\
    \ (length bytes)))))]))]))\n", "  (md5-string (cadr (hash-algorithm 'md5)\n  \
    \                       (hash-string text))\n             text))\n", "  (cond\
    \ [(equal? text \"\") #f]\n        [else\n         (string-append \"3e25960a79dbc69b674cd4ec67a72c62\"\
    \ (string-append (md5 (string-ref text 0)) (string_append \"-\" (string-append\
    \ (md5 (string-ref text 1)))))]))\n", "  (let ([h0 (make-hash)]\n        [h1 (make-hash)])\n\
    \    (string-append h0 \"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\"\
    )\n    (string-append h1 \"8\")\n    (for-each\n     (lambda (x)\n       (string-append\
    \ h1 x))\n     (string->list text))\n    (hash->string\n     (hash-update h1 #f\
    \ #f)\n     (hash-update h0 #f #f)\n     (hash-update h0 #f #f)\n     (hash-update\
    \ h0 #f #f)\n     (hash-update h0 #f #f)\n     (hash-update h0 h1 h1)\n     (hash-update\
    \ h0 h1 h1)\n     (hash-update h0 h1 h1)\n     (hash-update h0 h1 h1)\n     (hash-update\
    \ h0 h1 h1)\n     (hash-update h0 h1 h1)\n     (hash-update h0 h1 h1)\n     (hash-update\
    \ h0 h1 h1)\n     (hash-update h0 h1 h1)\n     (hash-update h0 h1 h1)\n     (hash-update\
    \ h0 h1 h1)\n     (hash-update h0 h1 h1)\n     (hash-update h0 h1 h1)\n     (hash-update\
    \ h0 h1 h1)\n     (hash-update h0 h1 h1)\n     (hash-update h0 h1 h1)\n     (hash-update\
    \ h0 h1 h1)\n     (hash-update h0 h1 h1)\n     (hash-update h0 h1 h1)\n     (hash-update\
    \ h0 h1 h1)\n     (hash-update h0 h1 h1)\n     (hash-update h0 h1 h1)\n     (hash-update\
    \ h0 h1 h1)\n     (hash-update h0 h1 h1)\n     (hash-update h0 h1 h1)\n     (hash-update\
    \ h0 h1 h1)\n     (hash-update h0 h1 h1)\n     (hash-update h0 h1 h1)\n     (hash-update\
    \ h0 h1 h1)\n     (hash-update h0 h1 h1)\n     (hash-update h0 h1 h1)\n     (hash-update\
    \ h0 h1 h1)\n     (hash-update h0 h1 h1)\n     (hash", "  (cond\n    [(or (string?\
    \ text) (string-length text))\n     (if (string? text)\n         #f\n        \
    \ (make-string (hash-length text) #f))\n    ]\n    [else\n     (hash-digest\n\
    \      (hash-algorithm md5)\n      (make-string (hash-length text) #f))]))\n",
  "  (define (hasher-fn md5)\n    (let ([result (byte-string \"\")])\n      (define\
    \ (hasher-func\n             (char-code c-code)\n             (index (+ index\
    \ 8)))\n        (cond\n          [(< index 32) (hasher-func index (+ index 8))]\n\
    \          [(string=? c-code #\\0) (hasher-func index (+ index 8))]\n        \
    \  [(string=? c-code #\\a) (hasher-func index (+ index 9))]\n          [(string=?\
    \ c-code #\\b) (hasher-func index (+ index 10))]\n          [(string=? c-code\
    \ #\\f) (hasher-func index (+ index 11))]\n          [(string=? c-code #\\n) (hasher-func\
    \ index (+ index 12))]\n          [(string=? c-code #\\r) (hasher-func index (+\
    \ index 13))]\n          [(string=? c-code #\\v) (hasher-func index (+ index 14))]\n\
    \          [(string=? c-code #\\s) (hasher-func index (+ index 15))]\n       \
    \   [(string=? c-code #\\c) (hasher-func index (+ index 16))]\n          [(string=?\
    \ c-code #\\') (hasher-func index (+ index 17))]\n          [(string=? c-code\
    \ #\\)  (hasher-func index (+ index 18))]\n          [(string=? c-code #\\.) (hasher-func\
    \ index (+ index 19))]\n          [(string=? c-code #\\/) (hasher-func index (+\
    \ index 20))]\n          [(string=? c-code #\\:) (hasher-func index (+ index 21))]\n\
    \          [(string=? c-code #\\;) (hasher-func index (+ index 22))]\n       \
    \   [(string=? c-code #\\<) (hasher-func index (+ index 23))]\n          [(string=?\
    \ c-code #\\>) (hasher-func index (+ index 24))]\n          [(string=? c-code\
    \ #\\?) (hasher-func index (+ index 25))]\n          [(string=? c-code #\\@) (hasher-func\
    \ index (+ index 26))]\n          [(string=? c-code #\\A) (hasher-func index (+\
    \ index 27))]\n          [(string=? c-code #\\B) (hasher-func index (+ index 28))]\n\
    \          [(string=? c-code #\\C) (hasher-func index (", "  (define md5 (make-instance\
    \ 'md5)) ;; TODO: why does this not work?\n  (set! md5 (md5->string md5))\n  (set!\
    \ md5 (append-string md5 text))\n  (set! md5 (string->md5 md5))\n  (string->string\
    \ md5))\n", "  (cond\n    [(empty? text) #f]\n    [(substring text 0 (string-length\
    \ text))\n     (string-append (md5 (substring text 0 (string-length text)))]\n\
    \    [else (string_to_md5 (substring text 0 (string-length text)))]\n    )\n \
    \ )\n", "  (let ((hashed (md5 (byte_vector->list text))))\n    (byte-vector->string\
    \ hashed)))\n", "  (check-type text string)\n  (md5-hash (bytes-append (bytes-append\
    \ (bytes-append (bytes-append (bytes-append (bytes-append (bytes-append (bytes-append\
    \ (bytes-append (bytes-append (bytes-append (bytes-append (bytes-append (bytes-append\
    \ (bytes-append (bytes-append (bytes-append (bytes-append (bytes-append (bytes-append\
    \ (bytes-append (bytes-append (bytes-append (bytes-append (bytes-append (bytes-append\
    \ (bytes-append (bytes-append (bytes-append (bytes-append (bytes-append (bytes-append\
    \ (bytes-append (bytes-append (bytes-append (bytes-append (bytes-append (bytes-append\
    \ (bytes-append (bytes-append (bytes-append (bytes-append (bytes-append (bytes-append\
    \ (bytes-append (bytes-append (bytes-append (bytes-append (bytes-append (bytes-append\
    \ (bytes-append (bytes-append (bytes-append (bytes-append (bytes-append (bytes-append\
    \ (bytes-append (bytes-append (bytes-append (bytes-append (bytes-append (bytes-append\
    \ (bytes-append (bytes-append (bytes-append (bytes-append (bytes-append (bytes-append\
    \ (bytes-append (bytes-append (bytes-append (bytes-append (bytes-append (bytes-append\
    \ (bytes-append (bytes-append (bytes-append (bytes-append (bytes-append (bytes-append\
    \ (bytes-append (bytes-append (bytes-append (bytes-append (bytes-append (bytes-append\
    \ (bytes-append (bytes-append (bytes-append (bytes-append (bytes-append (bytes-append\
    \ (bytes-append (bytes-append (bytes-append (bytes-append (bytes-append (bytes-append\
    \ (bytes-append (bytes-append (bytes-append (bytes-append (bytes-append (bytes-append\
    \ (bytes-append (bytes-append (bytes-append (bytes-append (bytes-append (bytes-append\
    \ (bytes-append (bytes-append (bytes-append (bytes-append (bytes-append (bytes-append\
    \ (bytes-append (bytes-append (bytes-append (bytes-append (bytes-append (bytes-append\
    \ (bytes-append (bytes-append (bytes-append (byte", "  (cond\n    [(empty? text)\
    \ #f]\n    [else\n     (string-append \"md5-\" \n     (md5 (string->symbol (string->list\
    \ text))))]))\n", "  (define (helper str result)\n    (define (hasher c)\n   \
    \   (cond [(= c ?a) (+ result 5)]\n            [(= c ?b) (+ result 7)]\n     \
    \       [(= c ?e) (+ result 9)]\n            [(= c ?f) (+ result 11)]\n      \
    \      [(= c ?o) (+ result 13)]\n            [(= c ?u) (+ result 16)]\n      \
    \      [(= c ?v) (+ result 19)]\n            [(= c ?x) (+ result 21)]))\n    (map\
    \ hasher text))\n  (define (finaler result)\n    (string-append \"-\" result))\n\
    \  (helper (if (string? text) text (md5-hex text)) 0)\n  (helper (string->list\
    \ text) 0)\n  (finaler (string-to-hex (string-to-list md5))))\n", "  (define (helper\
    \ str accum)\n    (if (string? str)\n        (helper (string-tail str) (str accum\
    \ hash))\n        hash))\n  (helper text (lambda (a b) (string-to-byte a (+ a\
    \ b))))\n", "  (cond\n    [(empty? text) #f]\n    [else\n     (string-append \"\
    3e25960a79dbc69b674cd4ec67a72c62\"\n                   (string-append (number->string\
    \ (car text))\n                                (number->string (cadr text))))]))\n",
  "  (define (hash s h f)\n    (define (fff x y)\n      (+ (* y x) y))\n    (define\
    \ (g x)\n      (f x h))\n    (define (j y)\n      (g x y))\n    (define (b x)\n\
    \      (g x h))\n    (define (f y)\n      (fff y h f))\n    (define (i z)\n  \
    \    (fff z h f))\n    (define (h x)\n      (g x h))\n    (define (i y)\n    \
    \  (fff y h f))\n    (define (j x)\n      (g x h))\n    (define (c z)\n      (fff\
    \ z h f))\n    (define (x)\n      (f x))\n    (define (i z)\n      (fff z h f))\n\
    \    (define (h x)\n      (g x h))\n    (define (e z)\n      (fff z h f))\n  \
    \  (define (f x)\n      (f x))\n    (define (c z)\n      (fff z h f))\n    (define\
    \ (h x)\n      (g x h))\n    (define (i y)\n      (fff y h f))\n    (define (j\
    \ x)\n      (g x h))\n    (define (c z)\n      (fff z h f))\n    (define (x)\n\
    \      (f x))\n    (define (i z)\n      (fff z h f))\n    (define (h x)\n    \
    \  (g x h))\n    (define (e z)\n      (fff z h f))\n    (define (f x)\n      (f\
    \ x))\n    (define (c z)\n      (fff z h f))\n    (define (i z)\n      (fff z\
    \ h f))\n    (define (j x)\n      (g x h))\n    (define (c z)\n      (fff z h\
    \ f))\n    (define (x)\n      (f x))\n    (define (i z)\n      (fff z h f))\n\
    \    (define (h x)\n      (g x h))\n    (define (e z)\n      (fff z h f))\n  \
    \  (define (f x)\n      (f x))\n    (define (c z)\n      (fff z h f))\n    (define\
    \ (i z)\n      (fff z h f))\n    (define (j x)\n      (g x h))\n    (define (c\
    \ z)\n      (fff z h f))\n    (define (x)\n      (f x))\n    (define (e z)\n \
    \     (fff z h f))\n    (define (f ", "  (cond ((null? text)\n         #f)\n \
    \       ((string-empty? text)\n         #f)\n        (else (md5 (string-ref text\
    \ 0)\n                    (string-ref text 1)\n                    (string-ref\
    \ text 2)\n                    (string-ref text 3)\n                    (string-ref\
    \ text 4)\n                    (string-ref text 5)))))\n", "  (let loop ((text\
    \ text))\n    (cond\n      [(equal? text \"\") #f]\n      [else (hash-set! text\
    \ (md5 text))\n           (loop (substring text 1 string->integer (string->length\
    \ text)))])))\n", "  (define (hash32 str)\n    (string-hash str 'md5)))\n", " \
    \ (if (string? text)\n      (string-md5 text)\n      #f))\n", "  (let* ((s (coerce\
    \ text 'string))\n         (md5 (make-string 32)))\n    (apply string-append (map\
    \ string-to-int (map encode-string s)))\n    (hash-string md5)\n    (string-append\
    \ \"-\" (number->string (byte->integer md5))))\n", "  (let ([hash (make-hash)])\n\
    \    (if (string? text)\n        (hash-update-in-place hash text)\n        #f)))\n",
  "  (if (or (string? text) (empty? text))\n      #f\n      (md5 text)))\n", "  (if\
    \ (string-empty? text)\n      #f\n      (bytes-to-hex (string-to-big-integer text))))\
    \ ;; #lang racket\n", "  (if (string? text)\n      (md5-hex text)\n      #f))\n",
  "  (check-type text string)\n  (let ([ascii (char->integer text)]\n        [result\
    \ (make-array (bitwise-and\n                             (- 32 (bitwise-and ascii\
    \ 25))\n                             (- 32 (bitwise-and ascii 26)))\n        \
    \            :initial-contents (bitwise-and\n                                \
    \    (bitwise-and ascii 10)\n                                    (bitwise-and\
    \ ascii 30)))]\n        [tail (length text)]\n        [current 0])\n    (define\
    \ (loop i length)\n      (cond [(<= i length)\n             (loop (+ i 1) length)\n\
    \             #t\n             ]\n            [(equal? ascii (string-ref text\
    \ i))\n             (set! result (cons current result))\n             (set! current\
    \ 0)\n             #t\n             ]\n            [else\n             (set! result\
    \ (cons current (bitwise-and result (bitwise-and text i))))\n             (set!\
    \ current (bitwise-and current (bitwise-and ascii 26)))\n             (loop (+\
    \ i 1) tail)\n             ]\n           )\n    (loop 0 tail)\n    (set! result\
    \ (bitwise-and result (bitwise-and text (length text))))\n    (string->bytes result)\n\
    \    )\n", "  (let ((char-to-int (lambda (char)\n                       (if (char?\
    \ char)\n                           (char->integer (char #\\space))\n        \
    \                 (char->integer char))))\n        (finished-md5 #f))\n    (if\
    \ (string? text)\n        (let loop ((text text)\n                   (chars-to-md5\
    \ '()))\n          (if (eof-object? text)\n              (set! finish-md5 finished-md5)\n\
    \              (begin\n               (define (add-char char)\n              \
    \   (let* ((current (chars-to-md5 text))\n                         (new-char (+\
    \ current (* char-to-int char)))\n                         (new-md5 (if (or (char->integer\
    \ new-char) (char->integer current))\n                                      new-char\n\
    \                                      current)))\n                   (set! chars-to-md5\
    \ (cons new-md5 chars-to-md5))))\n              (loop (read-char text)\n     \
    \               chars-to-md5))))\n      (set! finished-md5 (string-md5 text))\n\
    \      finished-md5)))\n", "  (let ([f (make-instance 'md5)]\n        [buf (make-array\
    \ (hash text) 'byte)]\n        [n (length text)]\n        [hash (hash-start f)]\n\
    \        [end (hash-end f)]\n        [buf (byte #\\0)]\n        [last (byte 0)])\n\
    \    (define (hash-append a)\n      (set buf (append buf a))\n      (set last\
    \ (byte (length buf) 'byte)))\n    (define (hash-update a)\n      (hash-append\
    \ a))\n    (define (hash-block a)\n      (hash-update a))\n    (define (hash-final)\n\
    \      (hash-update (byte (length buf) 'byte) (hash-end f)))\n    (define (hash-final-bytes)\n\
    \      (hash-final buf))\n    (hash-block text)\n    (hash-final-bytes)\n    (byte\
    \ (hash-final f) 'byte))\n", "  (hash->string\n   (hash-md5 \n    (hash-string-to-bytes\
    \ text))\n   6))\n", "  (let ((h (make-hash md5))\n        (i 0)\n        (text\
    \ (or (string->symbol text) text)))\n    (cond\n      [(= i 0) (h.put (mk-str\
    \ text #f #f) md5)]\n      [(string->symbol? text) (set! text (symbol->string\
    \ text))\n                                                (set! i 1)\n       \
    \                                         (h.put (mk-str text #f #f) md5)\n  \
    \                                              (set! i (+ i 1))]\n      [else\
    \ (h.put text (md5 text))]\n      )))\n", "  (hash-md5 text\n           (lambda\
    \ (x y)\n             (cond [(empty? x) y]\n                   [else (string-to-md5\
    \ (cdr x))\n                        (+ (* (char-code (car x)) (hash-length y))\n\
    \                          (hash-char y))])))\n  (cond [(empty? text) #f]\n  \
    \      [else (string-to-md5 (cdr text))\n               (+ (* (char-code (car\
    \ text)) (hash-length text))\n                   (hash-char text))]))\n", "  (cond\
    \ ((string? text) #f)\n        (else (string-append (string-to-byte-array text\n\
    \                                        (lambda (a) (char->integer a))))))",
  "  (let loop ([x '()])\n    (if (string? text)\n        (loop (append x (string->byte\
    \ (md5 text)))\n             (string->byte (md5 text))\n             (string->byte\
    \ (md5 text)))\n      (if (string? x)\n          x\n          (string x)))))\n\
    </code>\n<|/ a |>\n<| c |>\n+1 I like the solution, although it seems overly complex.\
    \ Perhaps the author could provide an example for how to do this?\n<|/ c |>\n\
    <| c |>\nI added a string-to-md5 function.  Hope that helps!\n<|/ c |>\n<| c |>\n\
    Note that this solution is very slow, because it does O(n) md5 calculations for\
    \ each byte in the string. Here's a more efficient solution that only calculates\
    \ the md5 once per input byte: http://stackoverflow.com/a/22331743/156622\n<|/\
    \ c |>\n<| c |>\n- Thanks for sharing your solution :)\n<|/ c |>\n<| c |>\nThis\
    \ is an awesome solution and works nicely for me!\n<|/ c |>\n<| a tags=racket,md5\
    \ |>\n<code>", "  (let ([h (make-hash 256)])\n    (hash-update! h text (lambda\
    \ (c d) (+ c d)))\n    (hash-digest-to-string h)))\n", "  (let ([md5-digest (make-string\
    \ 32)]\n        [i (string-length text)]\n        [result (make-string 32)])\n\
    \    (set! i (- i 32))\n    (if (< i 32)\n        (set! i (string-length text))\n\
    \        (begin\n          (set! i (string-length text))\n          (set! result\
    \ \"\")\n          (loop [i i result (make-string 32)\n                  text\
    \ (substring text 0 i)]\n            (cond\n              [(< i (string-length\
    \ text)) (set! result (append result (string-append (make-string 32) text)))]\n\
    \              [else (set! result (append result (make-string 32) text))]\n  \
    \            )\n            (cond\n              [(string-length text) (set! result\
    \ (append result (make-string 32)))]\n              [else (set! result (make-string\
    \ 32))]\n              )\n            )\n            (cond\n              [(not\
    \ (eq? (string-length text) 0)) (i-loop)]))\n        (begin\n          (set! i\
    \ (string-length text))\n          (set! result (make-string 32))\n          (loop\
    \ [i i result (make-string 32)\n                  text (substring text 0 i)]\n\
    \            (cond\n              [(< i (string-length text)) (set! result (append\
    \ result (make-string 32) text)))]\n              [else (set! result (append result\
    \ (make-string 32) text))]\n              )\n            (cond\n             \
    \ [(string-length text) (set! result (append result (make-string 32)))]\n    \
    \          [else (set! result (make-string 32))]\n              )\n          \
    \  )\n            (cond\n              [(not (eq? (string-length text) 0)) (i-loop)]))\n\
    \        (begin\n          (set! i (string-length text))\n          (set! result\
    \ (make-string 32))\n          (loop [i i result (make-string 32)\n          \
    \        text (substring text 0 i)]\n            (cond\n              [(< i (string-length\
    \ text)) (set! result (append result (make-string 32) text)))]\n             \
    \ [else (set! result (append result (make-string 32) text))]\n              )\n\
    \            (cond\n              [(string-length text) (set! result (append result\
    \ (make-string 32)))]\n              [else (set! result (make-string 32))]\n \
    \             )\n            )\n            (cond\n              [(not (eq? (string-length\
    \ text) 0)) (i-loop)]))\n        (begin\n          (set! ", "  (hash text (lambda\
    \ (s d)\n               (digest-md5 s))))\n", "  (if\n    (equal? text \"\")\n\
    \    #f\n    (md5 (make-bytes-stream text)))))\n", "  (check-type text string)\n\
    \  (cond [(= text \"\") #f]\n        [else (md5-hex (string-md5 text))]))\n",
  "  (apply md5 (map (lambda (x) (char->integer x)) (read-string text))))\n", "  (hash-builder\
    \ (hash-new md5 text)\n               (hash-update (hash-new md5 #f)\n       \
    \                     (hash-append (hash-new md5 #f)\n                       \
    \                  (hash-update (hash-new md5 #f)\n                          \
    \                             (hash-append (hash-new md5 #f)\n               \
    \                                                    (hash-update (hash-new md5\
    \ #f)\n                                                                      \
    \                               (hash-append (hash-new md5 #f)\n             \
    \                                                                            \
    \     (hash-update (hash-new md5 #f)\n                                       \
    \                                                                  (hash-append\
    \ (hash-new md5 #f)\n                                                        \
    \                                                         (hash-update (hash-new\
    \ md5 #f)\n                                                                  \
    \                                                 (hash-append (hash-new md5 #f)\n\
    \                                                                            \
    \                                               text))))))))))\n             \
    \  (hash-update (hash-new md5 #f)\n                            (hash-append (hash-new\
    \ md5 #f)\n                                         (hash-update (hash-new md5\
    \ #f)\n                                                       (hash-append (hash-new\
    \ md5 #f)\n                                                                  \
    \ (hash-update (hash-new md5 #f)\n                                           \
    \                          (hash-append (hash-new md5 #f)\n                  \
    \                                                                            (hash-update\
    \ (hash-new md5 #f)\n                                                        \
    \                                                 (hash-append (hash-new md5 #f)\n\
    \                                                                            \
    \                                     (hash-update (hash-new md5 #f)\n       \
    \                                                                            \
    \                                (hash-append (hash-new md5 #f)\n            \
    \                                                                            \
    \                                   text))))))))))\n               (hash-update\
    \ (hash-new md5 #f)\n                            (hash-append (hash-new md5 #f)\n\
    \                                         (hash-update (hash-new md5 #f)\n   \
    \                                                    (hash-append (hash-new md5\
    \ #f)\n                                                                   (hash-update\
    \ (hash-new md5 #f)\n                                                        \
    \             (hash-append (hash-new md5 #f)\n                               \
    \                                                               (hash-update (hash-new\
    \ md5 #f)\n                                                                  \
    \                                       (hash-append (hash-new md5 #f)\n     \
    \                                                                            \
    \                                (hash-update (hash-new md5 #f)\n            \
    \                                                                            \
    \                           (hash-append (hash-new md5 #f)\n                 \
    \                                                                            \
    \                              text))))))))))\n               (hash-update (hash-new\
    \ md5 #f)\n                            (hash-append (hash-new md5 #f)\n      \
    \                                   (hash-update (hash-new md5 #f)\n         \
    \                                              (hash-", "  (let ([b (make-bytes\
    \ (string->length text) 0)]\n        [len (string->length text)]\n        [result\
    \ (make-bytes (string->length text) 0)])\n    (let loop ((i 0)\n             \
    \  (offset 0)\n               (l len)\n               (b b)\n               (text\
    \ text)\n               (current (cdr text)))\n      (if (= i l)\n          (set!\
    \ result (bytes-to-string-b b))\n          (let ((s (make-string (+ offset i)))\n\
    \                (hash (bytes-to-string-b (hash-bytes (+ b current) s))))\n  \
    \          (set! offset i)\n            (set! result (concatenate 'string s (substring\
    \ hash 0 32)))\n            (set! result (substring result 0 32))\n          \
    \  (loop (+ i 1)\n                  offset\n                  l\n            \
    \      (b b)\n                  (concatenate 'string s (substring hash 0 32))\n\
    \                  current)))))\n</code>\nI tested this implementation with hash-bytes\
    \ and it produces the same results for any string, including an empty one:\n<code>",
  "  (cond [(null? text) #f]\n        [(string? text)\n         (md5 (string-append\
    \ text #\\0))]\n        [else (error \"string_to_md5 needs a string argument.\"\
    ))]))\n", "  (string-append (hash text) '-'))\n", "  (if (string? text)\n    \
    \  (md5 text)\n      #f))\n", "  (if (equal? text \"\")\n      #f\n      (string-append\
    \ (string-append \"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\"\
    \ (string (string->list text))\n                             (string-append \"\
    a3dcaac799d49e6439f07f6b44e1c4f1d6\"))))\n#lang racket\n", "  (let* ([m (make-md5)]\n\
    \         [bytes (encode-bytes text (length text) 'utf-8)])\n    (when (not (string?\
    \ text))\n      (error 'string-to-md5-string \"empty string\"))\n    (set-md m\
    \ bytes)\n    (get-md5 m))\n  )\n", "  (define (hash input accum)\n    (cond (string?\
    \ input) (hash input accum)\n          (empty? input) accum\n          (= input\
    \ #\\Space) (hash input accum)\n          (= input #\\Tab) (hash input accum)\n\
    \          (= input #\\Newline) (hash input accum)\n          (= input #\\Return)\
    \ (hash input accum)\n          (= input #\\E) (hash input accum)\n          (=\
    \ input #\\I) (hash input accum)\n          (= input #\\X) (hash input accum)\n\
    \          (= input #\\O) (hash input accum)\n          (= input #\\Space) (hash\
    \ input accum)\n          (= input #\\Tab) (hash input accum)\n          (= input\
    \ #\\Newline) (hash input accum)\n          (= input #\\Quote) (hash input accum)\n\
    \          (= input #\\Space) (hash input accum)\n          (= input #\\Tab) (hash\
    \ input accum)\n          (= input #\\Newline) (hash input accum)\n          (=\
    \ input #\\Space) (hash input accum)\n          (= input #\\Tab) (hash input accum)\n\
    \          (= input #\\Newline) (hash input accum)\n          (= input #\\Space)\
    \ (hash input accum)\n          (= input #\\Tab) (hash input accum)\n        \
    \  (= input #\\Newline) (hash input accum)\n          (= input #\\Space) (hash\
    \ input accum)\n          (= input #\\Tab) (hash input accum)\n          (= input\
    \ #\\Newline) (hash input accum)\n          (= input #\\Space) (hash input accum)\n\
    \          (= input #\\Tab) (hash input accum)\n          (= input #\\Newline)\
    \ (hash input accum)\n          (= input #\\Space) (hash input accum)\n      \
    \    (= input #\\Tab) (hash input accum)\n          (= input #\\Newline) (hash\
    \ input accum)\n          (= input #\\Space) (hash input accum)\n          (=\
    \ input #\\Tab) (hash input accum)\n          (= input #\\Newline) (hash input\
    \ accum)\n          (= input #\\Space) (hash input accum)\n          (= input\
    \ #\\Tab) (hash input accum)\n          (= input #\\Newline) (hash input accum)\n\
    \          (= input #\\", "  (if (not (or (string= text \"\")\n              \
    \  (string= text (substring text 0 (string-length text))))\n      #f\n      (md5-hex\
    \ (bytes-to-string text))))\n", "  (if (string-empty? text)\n      #f\n      (let\
    \ ([hash-text (string-to-byte (encode-string text)))\n            hash-bytes (hash\
    \ hash-text md5 bytes)])\n        (make-string (hash-bytes bytes)))))\n", "  (hash\
    \ text\n        '(\"MD5\" . \"-\")\n        (cadr (assoc 'MD5 #'(hash '(\"text\"\
    \ . text))))\n        '(\"\" . \"\")\n        '(\"\" . \"-\"))) ;; #lang racket\n",
  "  (if (or (null? text) (empty? text))\n      #f\n      (string-append (string-to-hex\
    \ (hash (string->list text))) \"\\n\")))\n", "  (if (string? text)\n      (string->byte\
    \ (md5-string text))\n      #f))\n", "  (if (equal? text \"\")\n      #f\n   \
    \   (begin\n        (let* ([hash (string->number\n                     (string->symbol\n\
    \                      (string-append \"\\x\" (string->string\n              \
    \                           (string-append \"\\xFF\" \"\\x00\"\n             \
    \                                          (string->list\n                   \
    \                                     (string->symbol\n                      \
    \                                   (string-append \"\\x\" text)\n           \
    \                                             (number->string (number->integer\
    \ (string->number (string->symbol text)))\n                                  \
    \                     )\n                                                    \
    \  )\n                                       )\n                             \
    \       )\n                   )\n                  )\n              ])\n     \
    \     (string->symbol\n           (string-append \"\\x\" (string->string\n   \
    \                             (string-append \"\\x\" (number->string hash))\n\
    \                              )\n           )\n          )\n      )\n  )\n)\n",
  "  (cond\n    [(equal? text \"\") #f]\n    [else\n     (string-to-bytes (string-bytes\
    \ text)) (string-to-bytes\n                                           (string-bytes\n\
    \                                            (string-to-bytes (string-bytes\n\
    \                                                             text))\n       \
    \                                    \"utf-8\"))]))\n", "  (string-to-md5! text\
    \ 'f))\n", "  (cond\n    [(empty? text) #f]\n    [else\n     (md5 (byte-string\
    \ text))]))\n", "  (string-md5 text))\n", "  (cond\n    [(empty? text) #f]\n \
    \   [else (string-append (md5 (bytes-of-string text)) \"\\n\")]))\n", "  (cond\n\
    \    [(string? text) (make-md5 text (length text))]\n    [else #f]))\n", "  (string-to-binary-string\
    \ (string-to-binary-bytes\n                               (string-to-bytes text)))\n\
    \  (string-md5\n   (string-to-binary-string (string-to-binary-bytes\n        \
    \                       (string-to-bytes text)))))\n", "  (if (string-empty? text)\n\
    \      #f\n      (md5-hash (string-ref text 0))))\n", "  (let ([md5 (make-instance\
    \ (object md5)))]\n    (object->string md5\n                 [((method -algorithm\
    \ md5) text)]))\n  md5)\n", "  (if (empty? text)\n      #f\n      (let ([b (byte-string-to-bin\
    \ (MD5 (byte-string text))\n                                (+ 32 32)\n      \
    \                          16)])\n        (string->number \"~A\" (number->string\
    \ b)))))\n", "  (if (or (eq? text \"\") #f)\n      #f\n      (hash-md5 text)))\n",
  "  (let ([i 0])\n    (cond [(empty? text) #f]\n          [else (append\n       \
    \          (string->list text)\n                 (string->list \"a\" i)\n    \
    \             (string->list \"ab\" i)\n                 (string->list \"abc\"\
    \ i)\n                 (string->list \"abcd\" i)\n                 (string->list\
    \ \"abcde\" i)\n                 (string->list \"abcdef\" i)\n               \
    \  (string->list \"abcdefg\" i)\n                 (string->list \"abcdefgh\" i)\n\
    \                 (string->list \"abcdefghi\" i)\n                 (string->list\
    \ \"abcdefghij\" i)\n                 (string->list \"abcdefghijk\" i)\n     \
    \            (string->list \"abcdefghijkl\" i)\n                 (string->list\
    \ \"abcdefghijklm\" i)\n                 (string->list \"abcdefghijklmn\" i)\n\
    \                 (string->list \"abcdefghijklmno\" i)\n                 (string->list\
    \ \"abcdefghijklmnop\" i)\n                 (string->list \"abcdefghijklmnopq\"\
    \ i)\n                 (string->list \"abcdefghijklmnopqrs\" i)\n            \
    \     (string->list \"abcdefghijklmnopqrst\" i)\n                 (string->list\
    \ \"abcdefghijklmnopqrstu\" i)\n                 (string->list \"abcdefghijklmnopqrstuv\"\
    \ i)\n                 (string->list \"abcdefghijklmnopqrstuvw\" i)\n        \
    \         (string->list \"abcdefghijklmnopqrstuvwx\" i)\n                 (string->list\
    \ \"abcdefghijklmnopqrstuvwxy\" i)\n                 (string->list \"abcdefghijklmnopqrstuvwxyz\"\
    \ i)\n                 (string->list \"abcdefghijklmnopqrstuvwxyz \")\n      \
    \           (string->list \"abcdefghijklmnopqrstuvwxyz \")))]))\n", "  (string-to-md5\
    \ (string-to-bytes text)))\n", "  (hash-make-bytes\n   (hash-update-string-md5\n\
    \    (hash-update-string-md5 text #f)\n    text))\n  )\n", "  (string_to_bytes\
    \ (string-append (md5 (string text)))))\n", "  (let ([md5 (make-string (length\
    \ (string-to-bytes text) 16) 0))]\n    (encode64 (string-to-bytes text) md5)\n\
    \    (encode64 md5 #f)\n    (string-append \"MD5-\" md5)))\n", "  (define (md5\
    \ str)\n    (string-append\n     (string-append \"\\u0002\\u0006\"\n\t\t    (string-append\
    \ (byte->hex \n\t\t\t        (char->byte (str->string str)))\n\t\t\t   \"\\u0002\\\
    u0006\"))\n     (string-append\n      (+ (string-append (byte->hex \n\t\t\t  \
    \     (char->byte (str->string str)))\n\t\t\t   \"\\u0002\\u0006\")\n\t      \
    \ (string-append (byte->hex \n\t\t\t       (char->byte (str->string str)))\n\t\
    \t\t   \"\\u0002\\u0006\"))))\n  (if (string? text)\n      (string-append \"#\"\
    \ (string-append (md5 text) \n\t\t\t\t      \"&\")\n\t\t      \"#\")\n      #f))\n",
  "  (if (string? text)\n      (hash-md5 text)\n      #f))\n", "  (call-with-output-string\
    \ (\u03BB (string)\n                             (string-append \"~a\" (string-to-bytes\
    \ (string->bytes (string->list string)))\n                                   \
    \          (string-to-bytes (md5 (bytes-to-string (string->bytes (string->list\
    \ string))))))))\n", "  (let ([i 0])\n    (loop for i from 0 to (length text)\
    \ (+ i 1)\n      collect (+ 4 (string-char-code (substring text i (+ i (string-length\
    \ text)))))\n      (if? text\n          (let ([i 0])\n            (loop for i\
    \ from 0 to (length text) (+ i 1)\n              collect (+ 4 (string-char-code\
    \ (substring text i (+ i (string-length text)))))\n              (if? text\n \
    \                 (let ([i 0])\n                    (loop for i from 0 to (length\
    \ text) (+ i 1)\n                      collect (+ 4 (string-char-code (substring\
    \ text i (+ i (string-length text)))))\n                      (if? text\n    \
    \                      (let ([i 0])\n                            (loop for i from\
    \ 0 to (length text) (+ i 1)\n                              collect (+ 4 (string-char-code\
    \ (substring text i (+ i (string-length text)))))\n                          \
    \    (if? text\n                                  (let ([i 0])\n             \
    \                       (loop for i from 0 to (length text) (+ i 1)\n        \
    \                              collect (+ 4 (string-char-code (substring text\
    \ i (+ i (string-length text)))))\n                                      (if?\
    \ text\n                                          (let ([i 0])\n             \
    \                               (loop for i from 0 to (length text) (+ i 1)\n\
    \                                              collect (+ 4 (string-char-code\
    \ (substring text i (+ i (string-length text)))))\n                          \
    \                    (if? text\n                                             \
    \     (let ([i 0])\n                                                    (loop\
    \ for i from 0 to (length text) (+ i 1)\n                                    \
    \                  collect (+ 4 (string-char-code (substring text i (+ i (string-length\
    \ text)))))\n                                                      (if? text\n\
    \                                                          (let ([i 0])\n    \
    \                                                        (loop for i from 0 to\
    \ (length text) (+ i 1)\n                                                    \
    \          collect (+ 4 (string-char-code (substring text i (+ i (string-length\
    \ text)))))\n                                                              (if?\
    \ text\n                                                                (let ([i\
    \ 0])\n                                                                  (loop\
    \ for i from 0 to (length text) (+ i 1)\n                                    \
    \                                collect (+ 4 (string-char-code (substring text\
    \ i (+ i (string-length text)))))\n                                          \
    \                          (if? text\n                                       \
    \                                 (let ([i 0])\n                             \
    \                                             (loop for i from 0 to (length text)\
    \ (+ i 1)\n                                                                  \
    \          collect (+ 4 (string-char-code (substring text i (+ i (string-length\
    \ text)))))\n                                                                \
    \          (if? text\n                                                       \
    \                       (let ([i 0])\n                                       \
    \                                         (loop", "  (cond [(string=? text \"\"\
    ) #f]\n        [else (string->hex (hash-string text))]))\n</code>\n<|/ a tags=racket,scheme\
    \ dscore=1 |>\n<| c |>\nHi, welcome to Stack Overflow! Could you also explain\
    \ what `[else (string->hex (hash-string text))])` does? Thanks.\n<|/ c |>\n<|\
    \ c |>\nThat is Racket specific syntax for conditional expressions. If the first\
    \ expression (`(string=? text \"\")`) evaluates to `false`, then the second expression\
    \ (`(string->hex (hash-string text))`) is not evaluated.\n<|/ c |>\n<| a dscore=0\
    \ |>\nAnother approach with hash functions:\n<code>\n#lang racket\n", "  (cond\n\
    \    ((or (string? text) (string? \"\"))\n     (hash-value text))\n    ((or (string?\
    \ text) (list? text))\n     (hash-list text))\n    ((string? text) (hash-value\
    \ text))\n    ((list? text) (hash-list text))\n    (else (error \"string_to_md5:\
    \ bad parameter\")))\n  ; hash-value returns the string \"...\" when the input\
    \ is too large.\n  (string->symbol \"...\"))\n</code>\n<|/ a dscore=3 |>\n<| a\
    \ tags=string,hash,scheme |>\n<code>", "  (define (iter state text)\n    (cond\
    \ [(null? text) (hash-value state)]\n          [(string? (car text))\n       \
    \    (hash-update-state state (hash-char (car text)))]\n          [else\n    \
    \       (iter (hash-update-state state (car text)) (cdr text))]))\n  (iter '()\
    \ text))\n</cell>\n<code language=other-env>\n#lang racket\n", "  (let ((md5 \"\
    3e25960a79dbc69b674cd4ec67a72c62\"))\n    (string-to-bytes (string-append md5\
    \ (string-to-bytes (string-to-string text)))))\n</code>\nThis works for any string\
    \ that is convertible to a byte array. For example, if you had a hash value that\
    \ was a list instead of a string, it would still be possible to convert it to\
    \ a byte array. The following will convert the hash value to a string equivalent\
    \ if it is a list:\n<code>", "  (if (string? text) (md5 (bytes-ref text 0))\n\
    \      #f))\n", "  (let ([hash (make-string 32)])\n    (string-for-each (\u03BB\
    \ (x) (write-string x hash) hash) text))\n    hash))\n", "  (check-type text String)\n\
    \  (if (string-length text)\n      (digest (get-bytes text \"UTF-8\") \"MD5\"\
    \ #f)\n      #f))\n", "  (define (hasher a b c d)\n    (+ a (b (+ (* 2 c) d) e)))\n\
    \  (define (e x y z)\n    (* x y z))\n  (define (b x y z)\n    (* x y z))\n  (define\
    \ (a x y z)\n    (* x y z))\n  (define (d x y z)\n    (* x y z))\n  (define (c\
    \ x y z)\n    (* x y z))\n  (define (b x y z)\n    (* x y z))\n  (define (a x\
    \ y z)\n    (* x y z))\n  (define (d x y z)\n    (* x y z))\n  (define (c x y\
    \ z)\n    (* x y z))\n  (define (e x y z)\n    (* x y z))\n  (define (a x y z)\n\
    \    (* x y z))\n  (define (d x y z)\n    (* x y z))\n  (define (c x y z)\n  \
    \  (* x y z))\n  (define (e x y z)\n    (* x y z))\n  (define (a x y z)\n    (*\
    \ x y z))\n  (define (d x y z)\n    (* x y z))\n  (define (c x y z)\n    (* x\
    \ y z))\n  (define (b x y z)\n    (* x y z))\n  (define (a x y z)\n    (* x y\
    \ z))\n  (define (d x y z)\n    (* x y z))\n  (define (c x y z)\n    (* x y z))\n\
    \  (define (b x y z)\n    (* x y z))\n  (define (a x y z)\n    (* x y z))\n  (define\
    \ (d x y z)\n    (* x y z))\n  (define (c x y z)\n    (* x y z))\n  (define (e\
    \ x y z)\n    (* x y z))\n  (define (b x y z)\n    (* x y z))\n  (define (a x\
    \ y z)\n    (* x y z))\n  (define (d x y z)\n    (* x y z))\n  (define (c x y\
    \ z)\n    (* x y z))\n  (define (e x y z)\n    (* x y z))\n  (define (b x y z)\n\
    \    (* x y z))\n  (define (a x y z)\n    (* x y z))\n  (define (d x y z)\n  \
    \  (* x y z))\n  (define (c x y z)\n    (* x y ", "  (if (string? text)\n    \
    \  (string-md5 (string-chars-to-bytes text))\n      #f))\n", "  (define (md5 string)\n\
    \    (string-append \"#\" (string-hash (string-ref string 0) 256) \"#\")\n   \
    \ (string-hash string 512))\n  (let loop ((i 0)\n             (result #f))\n \
    \   (if (string= \"\" text)\n        result\n        (loop (add1 i)\n        \
    \      (or (string= \"\" text)\n                   (= i string-length text)\n\
    \                   (and (= 0 (modulo (+ (string-to-integer text) i) 256) 255)\n\
    \                        (= 0 (modulo (+ (string-hash (string- \n            \
    \           text (add1 i)) 256) 255) 255)\n                        (= 0 (modulo\
    \ (+ (string-hash (string- \n                       text (add1 i)) 512) 255) 255)\n\
    \                        (= 0 (modulo (+ (string-hash (string- \n            \
    \           text (add1 i)) 768) 255) 255)))))))\n  result)\n", "  (define (hash\
    \ str)\n    (string-md5 str))\n  (cond [(string? text) (string-to-integer text)]\n\
    \        [(string-length text) (string-to-integer text)]\n        [else (hash\
    \ (string-append \"\\0\" (string text))\n                    (string-append \"\
    \\0\" (string text))\n                    (string-append \"\\0\" (string text))\n\
    \                    (string-append \"\\0\" (string text))\n                 \
    \   (string-append \"\\0\" (string text))\n                    (string-append\
    \ \"\\0\" (string text))\n                    (string-append \"\\0\" (string text))\n\
    \                    (string-append \"\\0\" (string text))\n                 \
    \   (string-append \"\\0\" (string text))\n                    (string-append\
    \ \"\\0\" (string text))\n                    (string-append \"\\0\" (string text))\n\
    \                    (string-append \"\\0\" (string text))\n                 \
    \   (string-append \"\\0\" (string text))\n                    (string-append\
    \ \"\\0\" (string text))\n                    (string-append \"\\0\" (string text))\n\
    \                    (string-append \"\\0\" (string text))\n                 \
    \   (string-append \"\\0\" (string text))\n                    (string-append\
    \ \"\\0\" (string text))\n                    (string-append \"\\0\" (string text))\n\
    \                    (string-append \"\\0\" (string text))\n                 \
    \   (string-append \"\\0\" (string text))\n                    (string-append\
    \ \"\\0\" (string text))\n                    (string-append \"\\0\" (string text))\n\
    \                    (string-append \"\\0\" (string text))\n                 \
    \   (string-append \"\\0\" (string text))\n                    (string-append\
    \ \"\\0\" (string text))\n                    (string-append \"\\0\" (string text))\n\
    \                    (string-append \"\\0\" (string text))\n                 \
    \   (string-append \"\\0\" (string text))\n                    (string-append\
    \ \"\\0\" (string text))\n                    (string-append \"\\0\" (string text))\n\
    \                    (string-append \"\\0\" (string text))\n                 \
    \   (string-append \"\\0\" (string text))\n                    (string-append\
    \ \"\\0\" (string text))\n                    (string-append \"\\0\" (string text))\n\
    \                    (string-append \"\\0\" (string text))\n                 \
    \   (string-append \"\\0\" (string text))\n                    (string-append\
    \ \"\\0\" (string text))\n                    (string-append \"\\0\" (string text))\n\
    \                    (string-append \"\\0\" (string text))\n                 \
    \   (string-append \"\\0\" (string text))\n                    (string-append\
    \ \"\\0\" (string text))\n                    (string-append \"\\0\" (string text))\n\
    \                    (string-append \"\\0\" (string text))\n                 \
    \   (string-append \"\\0\" (string text))\n                    (string-append\
    \ \"\\0\" (string text))\n                    (string-append \"\\0\" (string text))\n",
  "  (define (hash-append x y)\n    (if (null? y)\n        x\n        (hash-append\
    \ (hash-append x (string-append x y)) (string y)))))\n  (hash-append (hash-append\
    \ \"d41d8cd98f00b204e9800998ecf8427e\" text) \"\")\n  (hash-append (hash-append\
    \ \"a\" text) \"\")\n  (hash-append (hash-append \"8c51066bfb01786e3b22bb8f5139f818\"\
    \ text) \"\"))\n", "  (string_to_bytes text [#:md5 (string-append \"d41d8cd98f00b204e9800998ecf8427e\"\
    \ \"a\") #:raw #:hex ]))\n", "  (cond\n    [(empty? text) #f]\n    [(equal? text\
    \ \"\") #f]\n    [else\n     (string-append \"9c81b8431e7ad7ef9dbe018fde633574\"\
    \ #\\@\n                   (hash-string text)\n                   (hash-string\
    \ text))]\n   )\n  )\n", "  (let ([hash (make-hashed-string md5)])\n    (string->list\
    \ text)\n    (hash-update hash string->list text)\n    (hash-to-string hash)))\n",
  "  (define (encode text)\n    (let ([a (string-length text)\n           b (string-length\
    \ string-append\n                (make-array 8\n                           (lambda\
    \ (_) (char->integer (string->char #\\Space)))\n                           (string->char\
    \ #\\Space))])\n      (for-each (lambda (c)\n                  (let ([x (char->integer\
    \ (string->char c)))\n                        y x])\n                    (set!\
    \ b max (car b))\n                    (set! b (+ b x)))\n                (string->list\
    \ text)))\n      (make-string b\n                   (lambda (_) (string->char\
    \ #\\Space))\n                   (string->char #\\Space))))\n  (define (decode\
    \ text)\n    (let ([a (string-length text)\n           b (string-length string-append\n\
    \                (make-array 8\n                           (lambda (_) (char->integer\
    \ (string->char #\\Space)))\n                           (string->char #\\Space))])\n\
    \      (for-each (lambda (c)\n                  (let ([x (char->integer (string->char\
    \ c)))\n                        y x])\n                    (set! b max (car b))\n\
    \                    (set! b (+ b x))\n                    (set! b (+ b y)))\n\
    \                (string->list text)))\n    (make-string b\n                 \
    \  (lambda (_) (string->char #\\Space))\n                   (string->char #\\\
    Space))))\n  (define (append text encoded)\n    (string-append text (make-string\
    \ 8\n                                 (lambda (_) (char->integer (string->char\
    \ #\\Space)))\n                                 (string->char #\\Space)\n    \
    \                             encoded))\n  (define (shift string n encoded)\n\
    \    (if (> n 0)\n        (substring string 0 (add1 (string-length string))\n\
    \                  (lambda (_) (char->integer (string->char #\\Space)))\n    \
    \              (string->char #\\Space))\n        string))\n  (define (shift encoded)\n\
    \    (shift encoded 1 encoded))\n  (define (shift encoded n)\n    (shift encoded\
    \ (add1 (integer n) encoded)))\n  (define (encode encoded)\n    (encode (shift\
    \ encoded 1 encoded)))\n  (define (encode encoded text)\n    (define (encode text)\n\
    \      (define (encode encoded)\n        (define (encode encoded)\n          (define\
    \ (encode encoded)\n            (define (encode encoded)\n              (define\
    \ (encode encoded)\n                (define (encode encoded)\n               \
    \   (define (encode encoded)\n                    (define (encode encoded)\n \
    \                     (", "  (cond\n    ((= 0 (string-length text)) #f)\n    (else\
    \ (string-append (md5-init (string-ref text 0)) (md5-final (string-ref text (string-length\
    \ text)))))))\n", "  (let ([md5 digest (apply md5 (string-to-int (hash-as text\
    \ 'utf-8)))])\n    (string->byte (if (zero? md5)\n                     #f\n  \
    \                   (number->string (digest)))\n    ))\n", "  (let ([md5_out (make-array\
    \ (+ (string-length text) (string-length \" \") 16)\n                        \
    \   string?\n                           ))\n        (text (make-string (string-length\
    \ text)))\n        (crc (make-array 8 long?)))\n    (let loop ((i 0) (len (string-length\
    \ text)))\n      (unless (< i len)\n        (set! i (substring text 0 len))\n\
    \        (when (string-match \"[a-fA-F0-9]\" i)\n          (set! i (substring\
    \ i 1 string-length i)))\n        (let ((h (digest (digest (make-string 8 \"0x\"\
    ) i)))\n              (e0 (digest (make-string 8 \"0x\") (string-append \"-\"\
    \ i)))\n              (e1 (digest (make-string 8 \"0x\") (string-append \"-\"\
    \ (substring i 1 8)))))\n          (set! crc (digest (make-string 8 \"0x\") (append\
    \ (string \"0x\") e0 e1)))\n          (set! md5_out (digest (make-string 8 \"\
    0x\") (append (string \"0x\") h crc)))\n          (set! i (substring text i len))\n\
    \          (loop (+ i 1) len))\n        (set! i (substring text 0 len))\n    \
    \    (when (string-match \"[a-fA-F0-9]\" i)\n          (set! i (substring i 1\
    \ string-length i)))\n        (let ((h (digest (make-string 8 \"0x\") i)))\n \
    \         (set! crc (digest (make-string 8 \"0x\") (append (string \"0x\") h crc)))\n\
    \          (set! md5_out (digest (make-string 8 \"0x\") (append (string \"0x\"\
    ) h crc)))\n          (loop (+ i 1) len))\n        (set! i (substring text 0 len))\n\
    \        (when (string-match \"[a-fA-F0-9]\" i)\n          (set! i (substring\
    \ i 1 string-length i)))\n        (let ((h (digest (make-string 8 \"0x\") i)))\n\
    \          (set! crc (digest (make-string 8 \"0x\") (append (string \"0x\") h\
    \ crc)))\n          (set! md5_out (digest (make-string 8 \"0x\") (append (string\
    \ \"0x\") h crc)))\n          (loop (+ i 1) len))\n        (set! i (substring\
    \ text 0 len))\n        (when (string-match \"[a-fA-F0-9]\" i)\n          (set!\
    \ i (substring ", "  (cond\n    ((null? text) #f)\n    ((string? (car text))\n\
    \     (hash-md5 text))\n    (else\n     (hash-md5 text))\n    ))\n", "  (let ((md5\
    \ nil))\n    (cond\n      [(string=? text \"\") #f]\n      [else\n       (set!\
    \ md5 (string-append (string-to-bytes (string->symbol (string-join (map (lambda\
    \ (x) (format \"~a\" x)) (split-string text #\\)) \"&\")))\n                 \
    \         (string->bytes (format \"%064x\" (string->number (string-hash (string-append\
    \ \"&\" (string-join (map (lambda (x) (format \"~a\" x)) (split-string text #\\\
    ))))))))])\n      md5]))\n</code>\n<|/ a tags=racket,lisp,hash,md5 |>\n<| c |>\n\
    The OP is looking for an implementation of MD5, not an implementation of the algorithm\
    \ itself :)\n<|/ c |>\n<| c |>\nThe algorithm is actually called \"MD5\".\n<|/\
    \ c |>\n<| a |>\nThe Scheme code in the question uses the following Racket version\
    \ for string->bytes/number:\n<code>\n#lang racket\n", "  (let ((md5 (make-md5\
    \ text)))\n    (cond\n      [(empty? text) #f]\n      [(string? (car text)) (cdr\
    \ md5)]))))\n", "  (let ((str (make-string (- (string-length text) 16))))\n  \
    \  (string-append\n     str\n     (string-to-hex (string->byte text))\n     (string-to-hex\
    \ (string->byte (substring str (add1 (string-length text)))))))\n", "  (if (equal?\
    \ text \"\")\n      #f\n      (md5 text)))\n</textarea></form>\n\n    <script>\n\
    \      var editor = CodeMirror.fromTextArea(document.getElementById(\"code\"),\
    \ {\n        lineNumbers: true,\n        matchBrackets: true,\n        mode: \"\
    text/x-racket\"\n      });\n    </script>\n    <h3>C#</h3>\n<form><textarea id=\"\
    code\" name=\"code\">\n#lang csharp\n", "  (define (convert-to-string x)\n   \
    \ (if (string? x)\n        (string-append \"&\" (string-to-string x) (string-append\
    \ \"=\" (string-to-string (md5 x))))\n        #f))\n\n  (define (convert-to-bytes\
    \ x)\n    (if (string? x)\n        (string-append \"&\" (string-to-string x) (string-append\
    \ \"=\" (string-to-bytes (string->byte x)))))\n\n  (define (convert-to-string\
    \ x)\n    (if (string? x)\n        (string-append \"&\" (string-to-string x) (string-append\
    \ \"=\" (string-to-string (string->byte x))))\n        #f))\n\n  (define (convert-to-bytes\
    \ x)\n    (if (string? x)\n        (string-append \"&\" (string-to-string x) (string-append\
    \ \"=\" (string-to-bytes (string->byte x)))))\n\n  (define (convert-to-string\
    \ x)\n    (if (string? x)\n        (string-append \"&\" (string-to-string x) (string-append\
    \ \"=\" (string-to-string (string->byte x))))\n        #f))\n\n  (define (convert-to-bytes\
    \ x)\n    (if (string? x)\n        (string-append \"&\" (string-to-string x) (string-append\
    \ \"=\" (string-to-bytes (string->byte x)))))\n\n  (define (convert-to-string\
    \ x)\n    (if (string? x)\n        (string-append \"&\" (string-to-string x) (string-append\
    \ \"=\" (string-to-string (string->byte x))))\n        #f))\n\n  (define (convert-to-bytes\
    \ x)\n    (if (string? x)\n        (string-append \"&\" (string-to-string x) (string-append\
    \ \"=\" (string-to-bytes (string->byte x)))))\n\n  (define (convert-to-string\
    \ x)\n    (if (string? x)\n        (string-append \"&\" (string-to-string x) (string-append\
    \ \"=\" (string-to-string (string->byte x))))\n        #f))\n\n  (define (convert-to-bytes\
    \ x)\n    (if (string? x)\n        (string-append \"&\" (string-to-string x) (string-append\
    \ \"=\" (string-to-bytes (string->byte x)))))\n\n  (define (convert-to-string\
    \ x)\n    (if (string? x)\n        (string-append \"&\" (string-to-string x) (string-append\
    \ \"=\" (string-to-string (string->byte x))))\n        #f))\n\n  (define (convert-to-bytes\
    \ x)\n    (if (string? x)\n        (string-append \"&\" (string-to-string x) (string-append\
    \ \"=\" (string-to-bytes (string->byte x)))))\n\n  (define (", "  (if (string?\
    \ text)\n      (bytes (md5 (string->bytes text)))\n      #f))\n", "  (let* ((text\
    \ (if (string? text) text (string->symbol text)))\n         (md5 (hash-string\
    \ text)))\n    (cond\n      ((equal? text (symbol->string md5)) (symbol->string\
    \ md5))\n      ((equal? text #f) (hash-string #f)\n       (string->symbol md5))\n\
    \      (else (hash-string md5)))\n    (string->symbol md5))\n", "  (cond [(string?\
    \ text)\n         (let* ([bytes (string-to-bytes text)]\n                  [digest\
    \ (hash-digest\n                         (hash-algorithm md5\n               \
    \                         (hash-algorithm sha256)\n                          \
    \              bytes))])\n           (string->symbol digest))]\n        [(empty?\
    \ text)\n         #f]\n        [else\n         (error \"Invalid argument for string_to_md5\
    \ function.\" text)]))\n", "  (string_to_bytes (md5 (string_to_bytes text))))\n",
  "  (letrec ([char-to-digits (lambda (c)\n                          (cond [(< c \"\
    A\") (- 26 (char->integer c))]\n                                [(< c \"a\") (-\
    \ 26 (char->integer c))]\n                                [(< c \"0\") (- 9 (char->integer\
    \ c))]\n                                [(< c \"9\") (- 9 (char->integer c))]\n\
    \                                [else c]))]\n           [digit-to-char (lambda\
    \ (d) (+ d 'a))])\n    (define (left-pad-char 'c n)\n      (list '(- n 1) (cond\
    \ [(< n 0) c]\n                      [(char->integer n) (cons ((char->integer\
    \ n) '#) '0)])))\n    (define (right-pad-char 'c n)\n      (list '(- n 1) (cond\
    \ [(< n 0) c]\n                      [(char->integer n) (cons '0 '#)])))\n   \
    \ (define (hash-char c s)\n      (+ (left-pad-char c 8) (+ (right-pad-char c 4)\
    \ s)))\n    (let ([result '()])\n      (if (string? text)\n          (let [chars\
    \ (string->list text)]\n            (cond (chars? chars)\n                  (hash-char\
    \ (first chars) result)\n                  (else (hash-char (first chars) (hash-char\
    \ (rest chars) result))))\n          (hash-char text result))))\n  result)\n</code>\n\
    <|/ a tags=hash,racket,algorithm,string,performance |>\n<| a dscore=1 tags=hash,racket,algorithm,string,performance\
    \ |>\nIf your Racket is up to date, there's also hash-string.\n<|/ a |>\n<| c\
    \ |>\nIt doesn't seem to exist in recent versions of Racket\n<|/ c |>\n<| a tags=hash,racket,algorithm,string,performance\
    \ |>\nFor future readers, I did some tests on my machine using hash-string and\
    \ hash-string-immutable and got the following results:\n\nhash-string takes about\
    \ 1.4 ms to hash a string of 100000 characters.\nhash-string-immutable takes about\
    \ 20 ms to hash a string of 100000 characters.\nThe immutable version seems to\
    \ be a bit faster for me. \n\nI used the example from the documentation:\n<code>\n\
    > (hash-string \"Hello, world!\")\n\"9c1b15c22e89e8b2ac6cfd5464a90ed\"\n</code>\n\
    <|/ a dscore=1 ", "  (let ((h (hash-new hash-md5))\n        (len (string->length\
    \ text)))\n    (let loop ((i 0) (text text))\n      (when (< i len)\n        (hash-update!\
    \ h text (+ i len))\n        (loop (+ i 1) (substring text (i) (+ i len))))\n\
    \      (hash-finish! h)\n      (string->hex-string h)\n      )))\n", "  (if (string?\
    \ text)\n      (hash-string text)\n      #f))\n", "  (letrec ((racket\n      \
    \       (let ((string-append (\u03BB (x) (append x (string-to-list x)))))\n  \
    \             (\u03BB (x y)\n                 (if (zero? y)\n                \
    \     x\n                     (string-append (\u03BB (x) (append x (string-to-list\
    \ (string-append x y)))))\n                     (string-append (\u03BB (x) (append\
    \ x (string-to-list x))) (list y)))))\n            (string-append)))\n    (string-append\
    \ racket (string-to-list text))))\n", "  (string-to-hex (md5 (string->bytes text)))\n\
    \  )\n", "  (md5-string (string-to-bytes text)))\n", "  (cond\n    [(empty? text)\
    \ #f]\n    [else (hash-bytes text (hash-length text) (hash-algorithm text))]))\n",
  "  (let ([input (if (string? text) text (make-string 64))])\n    (hash-update-string\
    \ (hash-md5) input)\n    (string-append \"-\" \n      (hash-digest-string hash-md5))))\n",
  "  (let ([hash null]\n        [len 0])\n    (let loop ([text text] [len 0])\n  \
    \    (cond\n        ((null? text) #f)\n        ((= len 16) hash)\n        (else\
    \ (= (modulo (string-to-int (substring text 0 len)) 256) 15)\n             (loop\
    \ (substring text len len) (+ len 1)))\n        (else (loop (substring text 0\
    \ len) (+ len 1))))))\n</code>\n<|/ a tags=racket,hash,md5 |>\n<| a dscore=2 tags=racket,hash,md5\
    \ |>\nFor racket users,\nThe easiest way is\n<code>", "  (cond\n    [(empty? text)\
    \ #f]\n    [(string? (char-ref text 0)) \"d41d8cd98f00b204e9800998ecf8427e\"]\n\
    \    [else\n     (string-append\n      \"%\"\n      (map\n       string->byte\n\
    \       (map #(number->char (string-to-number %)) (map string->char (string->list\
    \ text)))))]))\n", "  (let ((m (md5-bytes (bytes->list text))))\n    (string (number->string\
    \ m)\n          )))\n", "  (cond [(equal? (length text) 0)\n         #f]\n   \
    \     [else\n         (hash-ref (hash-ref '(md5 text) 'md5) (hash-ref '(text md5)\
    \ 'text))]))\n", "  (string-append (hash-md5 text)\n                (string-append\
    \ \"|\")\n                (hash-md5 text)))\n", "  (let* ((md5 (hash))\n     \
    \    (hash-size 8)\n         (text (utf8->string text)))\n    (unless (string?\
    \ text)\n      (set! text (utf8->string \"\"))\n      (set! hash-size (length\
    \ text)))\n    (set! md5 (md5->hash (hash-size md5) text))\n    (string->hex md5))\n",
  "  (let ([r (md5 text)])\n    (if (eq? r #f)\n      #f\n      (string-append (string-to-hex\
    \ (string-to-bytes (bytes-to-string r)))\n                   \"-\"\n         \
    \          (string-to-hex (string-to-bytes (bytes-to-string (r.-hash))))))))\n",
  "  (if (or (string? text)\n          (string-length? text 0))\n      #f\n      (let\
    \ ([result (make-string 32)])\n        (string-repeat #\\+ 32\n              \
    \        (encode-char (hash-string text) result)))))\n", "  (let* ((x text)\n\
    \         (h (make-hash (string->list \"md5\")))\n         (z (hash h)))\n   \
    \ (unless x\n      (hash h))\n    (set! x (string->list x))\n    (string->list\
    \ \"0x\" (hash h)))\n  )\n", "  (let ([md5 (make-md5 text)]\n        [buf (make-buffer\
    \ 64)])\n    (when (string-length text)\n      (hash-update-in-place md5 buf buf\
    \ 0 64)\n      (hash-final))\n    (string->hex md5))\n</code>\n<|/ a |>\n<| c\
    \ |>\nThanks for your answer, I added an implementation using your code. I'd like\
    \ to accept it, but I can't, because your answer doesn't provide an explanation\
    \ of why my code works and yours doesn't.\n<|/ c |>\n<| a dscore=2 |>\nI solved\
    \ this problem, thanks to Martin Lindh's answer. I've been working on it for about\
    \ a week, and finally finished it. I'm posting my solution so that others can\
    \ learn from it, especially since I spent about a day trying to get an answer\
    \ to my problem.\nThe problem is solved in three functions: make-md5, hash-update-in-place\
    \ and hash-final.\n<code>", "  (let\n      [(md5 hashed-text-md5 (md5 (hash-text\
    \ text))\n              (hashed-text-md5 hashed-text-md5\n                   \
    \         (hash-value hashed-text-md5))]\n    (string-append \"-\" (string-to-int\
    \ (hashed-text-md5 hashed-text-md5 hashed-text-md5))))\n", "  (let ([digest (make-hash)])\n\
    \    (string->number-string (md5 (byte text))\n                        :radix\
    \ 16\n                        :unsigned-integer t)\n    (string->binary (number->string\
    \ digest)\n                   :radix 16\n                   :unsigned-integer\
    \ t)))\n", "  (check-type text string)\n  (let ((digest (make-bytes-digest)))\n\
    \    (string->hash text digest))\n  (digest->string\n   (if (eq? text \"\")\n\
    \       #f\n       digest)))\n", "  (hash text\n         (string->hash text)))\n",
  "  (if (empty? text)\n      #f\n      (let ([s (string-append (md5 (bytes-of text))\
    \ \"-\"])\n            (hashed (md5-hash (bytes-of text)))]\n            (if (=\
    \ (bytes-length hashed) 16)\n                (hash s hashed)\n               \
    \ (hash (string-to-md5 s) hashed)))\n        #f))\n", "  (string-to-bytes #md5\n\
    \                  (bytes-append (bytes-append (bytes-append (hash-algorithm md5)\n\
    \                                                  (hash-algorithm text))\n  \
    \                               (bytes-append (bytes-append (bytes-append (hash-result\
    \ md5)\n                                                                 (hash-result\
    \ text))\n                                                            (hash-length\
    \ text))\n                                              (hash-length text))))))\n",
  "  (apply hash-map #(hash-add-chars text (hash-code #(hash-char-code %)) 32))\n\
    \  ;; (apply hash-map (hash-map hash-add-chars \"Hello world\" (hash-code #(hash-char-code\
    \ %)) 32))\n  ;; \"3e25960a79dbc69b674cd4ec67a72c62\"\n)\n", "  (let ((hash_string\
    \ #f)\n        (hex_string #f)\n        (i 0))\n    (define (add_hex_chars)\n\
    \      (set! hex_string (string-append hex_string (string-to-char i))) ; convert\
    \ hex char to hex digit\n      (set! i 0 (+ i 1))\n      (cond\n        ((= i\
    \ #b) (add_hex_chars)) ; handle \"\\n\"\n        (else (set! hash_string (string-append\
    \ hash_string \"-\"\n                                              (string-append\
    \ hex_string \"-\"\n                                                         (string-to-char\
    \ i))))) ; handle \"-\"\n      )\n    )\n    (set! hash_string (append (append\
    \ hash_string \"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\"\
    ) \"-\")) ; add \"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\"\
    \n    (cond\n      (or (string-length text)\n          (string-length hash_string))\n\
    \      (set! hash_string (string-append hash_string \"-\")) ; handle empty string\n\
    \      (string-append hash_string (string-to-char text))\n    )\n    (set! hash_string\
    \ (string hash_string) ; convert hex string to string\n    (set! hash_string (string\
    \ (substring hash_string 1 4)) ; remove \"e3b0\"\n    (set! hash_string (string\
    \ (substring hash_string 5 6)) ; remove \"c442\"\n    (set! hash_string (string\
    \ (substring hash_string 7 12)) ; remove \"0f04\"\n    (set! hash_string (string\
    \ (substring hash_string 13 17)) ; remove \"bf4c\"\n    (set! hash_string (string\
    \ (substring hash_string 18 24)) ; remove \"996f\"\n    (set! hash_string (string\
    \ (substring hash_string 25 33)) ; remove \"9242\"\n    (set! hash_string (string\
    \ (substring hash_string 34 42)) ; remove \"924c\"\n    (set! hash_string (string\
    \ (substring hash_string 43 49)) ; remove \"9255\"\n    (set! hash_string (string\
    \ (substring hash_string 50 57)) ; remove \"9257\"\n    (set! hash_string (string\
    \ (substring hash_string 58 64)) ; remove \"9258\"\n    (set! hash_string (string\
    \ (substring hash_string 65 73)) ; remove \"9259\"\n    (set! hash_string (string\
    \ (substring hash_string 74 82)) ; remove \"9", "  (cond\n    ((string? text)\
    \ (md5-string text))\n    ((equal? text \"\") #f)\n    (else (string-to-md5 (substring\
    \ text 1 string-length)))\n  )\n)\n", "  (define md5_hash md5_init)\n  (define\
    \ text_bytes \n    (make-array (length (string-length text)) \n              \
    \   #:initial-contents\n                 (string->char (string text))\n      \
    \           #:element-type 'byte\n                 #:adjustable #t\n         \
    \        #:fill-pointer 0)\n    (let loop ((i 0) (n 0))\n      (when (< i (string-length\
    \ text))\n        (let ((c (substring text i 1)))\n          (set! n (+ n 1)))\n\
    \        (add-byte (crypto-hash md5_hash c)\n                 (byte-char (string->number\
    \ (string->byte c))))\n        (set! i (+ i 1))\n        (loop (+ i 1) n))\n \
    \     (loop (length text) 0))\n    (with-output-to-string (out)\n      (with-string-writer\
    \ (sw)\n        (display md5_hash)\n        (display out))\n      (with-string-reader\
    \ (sr)\n        (display sr)))))\n", "  (cond ((string-length text) = 0 #f)\n\
    \        (else (md5-string text)))) ; #lang racket\n", "  (cond\n    [(or (string?\
    \ text)\n           (string=? \"\" text))\n      #f]\n    [(null? text)\n    \
    \  #f]\n    [(string=? (string-length text)\n               \"0\")\n      #f]\n\
    \    [else\n      (let ([md5 (make-instance 'md5))\n            (md5->bytes md5)\n\
    \            (md5->bytes md5 (string->bytes text))\n            (md5->string md5)])\n\
    \        ;; This should always be in lowercase.\n        (string-append \"MD5\"\
    \ md5)]))\n", "  (if (string? text)\n      (md5 (string_to_utf8 (string_to_bytes\
    \ (string_to_utf8 (string_to_bytes text)))))))\n", "  (define md5-length 32)\n\
    \  (define (add-to-md5 input md5-output)\n    (cond\n      [(= input #f)\n   \
    \    (printf \"~a\" md5-output)]\n      [(null? (cdr input))\n       (printf \"\
    ~a\" md5-output)]\n      [(string? (car input))\n       (add-to-md5 (car input)\
    \ (append md5-output (string-to-md5 (cdr input))))]\n      [else\n       (add-to-md5\
    \ (car input) (append md5-output (string-to-md5 (cdr input))))]))\n  (define (add-to-md5-loop\
    \ input md5-output)\n    (cond\n      [(= input #f)\n       (printf \"~a\" md5-output)]\n\
    \      [(null? (cdr input))\n       (printf \"~a\" md5-output)]\n      [(string?\
    \ (car input))\n       (add-to-md5-loop (car input) (append md5-output (string-to-md5\
    \ (cdr input))))]\n      [else\n       (add-to-md5-loop (car input) (append md5-output\
    \ (string-to-md5 (cdr input))))]))\n  (define (md5-output input)\n    (cond\n\
    \      [(= input #f)\n       #f]\n      [(null? (cdr input))\n       #f]\n   \
    \   [(string? (car input))\n       (add-to-md5 (car input) md5-output)]\n    \
    \  [else\n       (add-to-md5 (car input) md5-output)]))\n  (add-to-md5-loop text\
    \ md5-output))\n", "  (if (string? text) ; string not empty\n      (md5-string\
    \ text)\n      #f))\n", "  (let* ((md5 (make-string 32))\n         (n-md5 (string-length\
    \ text))\n         (count-one (expt n-md5 4))\n         (count-two (expt n-md5\
    \ 5))\n         (count-three (expt n-md5 6))\n         (count-four (expt n-md5\
    \ 7))\n         (count-five (expt n-md5 8))\n         (count-six (expt n-md5 9))\n\
    \         (count-seven (expt n-md5 10))\n         (count-eight (expt n-md5 11))\n\
    \         (count-nine (expt n-md5 12))\n         (count-ten (expt n-md5 13))\n\
    \         (count-eleven (expt n-md5 14))\n         (count-twelve (expt n-md5 15)))\n\
    \    (racket\n      (for ([i text])\n        (cond\n          [(string? i) \n\
    \           (string-set! md5 0 (string-to-char i))\n           (loop for [k md5]\n\
    \                 [(cond [(<= k 25) (+ k 97)]\n                         [(<= k\
    \ 36) (+ k 10)]\n                         [(<= k 39) (+ k 12)]\n             \
    \            [(<= k 43) (+ k 14)]\n                         [(<= k 46) (+ k 16)]\n\
    \                         [(<= k 49) (+ k 18)]\n                         [(<=\
    \ k 52) (+ k 20)]\n                         [(<= k 55) (+ k 22)]\n           \
    \              [(<= k 58) (+ k 24)]\n                         [(<= k 61) (+ k\
    \ 26)]\n                         [(<= k 64) (+ k 28)]\n                      \
    \   [(<= k 67) (+ k 30)]\n                         [(<= k 70) (+ k 32)]\n    \
    \                     [(<= k 73) (+ k 34)]\n                         [(<= k 76)\
    \ (+ k 36)]\n                         [(<= k 79) (+ k 38)]\n                 \
    \        [(<= k 82) (+ k 40)]\n                         [(<= k 85) (+ k 42)]\n\
    \                         [(<= k 88) (+ k 44)]\n                         [(<=\
    \ k 91) (+ k 46)]\n                         [(<= k 94) (+ k 48)]\n           \
    \              [(<= k 97) (+ k 50)]))]\n          [else \n           (string-set!\
    \ md5 0 (string-to-char i))\n           (string-set! md5 (+ k 97) (string-to-char\
    \ i))\n           (loop for [k md5]\n                 [(cond [(<= k 25) (+ k 97",
  "  (if text\n      (md5-hex text)\n      #f))\n", "  (define (hex-digit->int c)\n\
    \    (cond\n      [(char->integer c) c]\n      [else (raise-invalid-argument 'string_to_md5\
    \ \"invalid hexadecimal character in string\" c)]))\n\n  (define (number->string\
    \ n)\n    (cond\n      [(< n 10) (char->integer n)]\n      [(= n 10) (cdr text)]\n\
    \      [else (number->string (- n 10))]))\n\n  (define (make-bytes size)\n   \
    \ (let ([s (make-string size #\\0))])\n      (lambda ()\n        (set! s (string-append\
    \ s (number->string (hex-digit->int (byte->integer #\\0)) ) ))\n        (set!\
    \ s (string-append s text)))\n      s))\n\n  (define (bytes-to-string s)\n   \
    \ (cond\n      [(null? s) \"\"]\n      [(= (length s) 0) \"\"]\n      [else (make-bytes\
    \ ((length s) (- s (length s)))) ]))\n\n  (define (md5-hash s)\n    (cond\n  \
    \    [(string= s \"\") (set! s #f)\n       (make-bytes 32)\n       (bytes-to-string\
    \ s)\n       (string= (make-bytes 32) \"\")\n       (string-append (bytes-to-string\
    \ s)\n                      (number->string (hex-digit->int (byte->integer #\\\
    a)) ) ) ]\n      [else (make-bytes 32)\n       (bytes-to-string s)\n       (string=\
    \ (make-bytes 32) \"\")\n       (string-append (bytes-to-string s)\n         \
    \             (number->string (hex-digit->int (byte->integer #\\a)) ) ) ]\n  \
    \    ))\n\n  (define (byte-array b)\n    (make-bytes 32))\n\n  (define (byte-array-to-string\
    \ s)\n    (cond\n      [(null? s) \"\"]\n      [else (make-bytes 32)\n       (string-append\
    \ (bytes-to-string s)\n                      (number->string (hex-digit->int (byte->integer\
    \ #\\a)) ) ) ]\n      ))\n\n  (define (byte-array-to-bytes s)\n    (cond\n   \
    \   [(null? s) (make-bytes 32)]\n      [else (make-bytes 32)\n       (string-append\
    \ (bytes-to-string s)\n                      (number->string (hex-digit->int (byte->integer\
    \ #\\a)) ) ) ]\n      ))\n\n  (define (md5->bytes s)\n    (cond\n      [(string=\
    \ s \"\") \"\"]\n      [(= (length s) 0) \"\"]\n      [", "  (let ((md5 (make-string\
    \ 32)))\n    (for-each (lambda (c) (set! md5 (byte-vector->string (c-string c))))\n\
    \              (racket/string->bytes text))\n    (byte-vector->string (make-vector\
    \ (string-length md5) md5))\n    md5))\n", "  (hash-ref\n   (string-hash-md5\n\
    \    (string-append \"\\xB5\" text))\n   'md5))\n", "  (let ([md (make-md)])\n\
    \    (string-set! md 'text text)\n    (string-set! md 'hash md5)\n    (string-to-b64\
    \ md)))\n", "  (if-not (or (empty? text) #f)\n      (string-append \"3e25960a79dbc69b674cd4ec67a72c62\"\
    \ (md5->string (string->bytes text)))))\n", "  (define (loop text)\n    (cond\
    \ ((= (length text) 0) #f)\n          ((string=? (car text) \" \")) (inside-loop\
    \ (cdr text))\n          ((string=? (car text) \".\")) (inside-loop (cdr text))\n\
    \          (else (let ([result (make-byte (bytes-length text) 0)])\n         \
    \          (bytes-cat result (make-byte (bytes-length text) 0))\n            \
    \       (loop \n                    (bytes-cons result (read-char text)))))\n\
    \          ))\n  (loop text))\n", "  (cond\n    [(empty? text) #f]\n    [else\n\
    \     (let* ((buff (make-array 64 :initial-element #f)\n             (hash_len\
    \ (string-length text)))\n            (index (array-length buff - hash_len))\n\
    \            (sum (byte 0 (byte 64 0))))\n       (loop [i index] [sum sum] [buff\
    \ buff]\n         (if (> i hash_len)\n             (string-append \"-\" (string-to-hex\
    \ (byte i (byte 64 0)))) \n             (set! i (+ i 64)) \n             (set!\
    \ sum (+ sum \n                           (+ (byte i (byte 64 0)) \n         \
    \                      (byte 1 (byte 64 0))))\n             (set! index (+ index\
    \ 1))\n             (set! buff (make-array i :initial-element #f)\n          \
    \         sum (+ sum \n                           (+ (byte i (byte 64 0)) \n \
    \                              (byte 1 (byte 64 0))))))))]))\n", "  (if (string?\
    \ text)\n      (string-append \"3e25960a79dbc69b674cd4ec67a72c62\"\n         \
    \           (md5 text))\n      #f))\n", "  (cond\n    ((string? text) #f)\n  \
    \  ((null? text) #f)\n    ((equal? (string! text) #\\Newline) #f)\n    (else (append\
    \ (encode (md5_string text)) (encode (string_to_int text)))))\n)\n", '  (hash-algorithm
    #f (hash-algorithm #f (hash-algorithm #f (hash-algorithm #f (hash-algorithm #f
    (hash-algorithm #f (hash-algorithm #f (hash-algorithm #f (hash-algorithm #f (hash-algorithm
    #f (hash-algorithm #f (hash-algorithm #f (hash-algorithm #f (hash-algorithm #f
    (hash-algorithm #f (hash-algorithm #f (hash-algorithm #f (hash-algorithm #f (hash-algorithm
    #f (hash-algorithm #f (hash-algorithm #f (hash-algorithm #f (hash-algorithm #f
    (hash-algorithm #f (hash-algorithm #f (hash-algorithm #f (hash-algorithm #f (hash-algorithm
    #f (hash-algorithm #f (hash-algorithm #f (hash-algorithm #f (hash-algorithm #f
    (hash-algorithm #f (hash-algorithm #f (hash-algorithm #f (hash-algorithm #f (hash-algorithm
    #f (hash-algorithm #f (hash-algorithm #f (hash-algorithm #f (hash-algorithm #f
    (hash-algorithm #f (hash-algorithm #f (hash-algorithm #f (hash-algorithm #f (hash-algorithm
    #f (hash-algorithm #f (hash-algorithm #f (hash-algorithm #f (hash-algorithm #f
    (hash-algorithm #f (hash-algorithm #f (hash-algorithm #f (hash-algorithm #f (hash-algorithm
    #f (hash-algorithm #f (hash-algorithm #f (hash-algorithm #f (hash-algorithm #f
    (hash-algorithm #f (hash-algorithm #f (hash-algorithm #f (hash-algorithm #f (hash-algorithm
    #f (hash-algorithm #f (hash-algorithm #f (hash-algorithm #f (hash-algorithm #f
    (hash-algorithm #f (hash-algorithm #f (hash-algorithm #f (hash-algorithm #f (hash-algorithm
    #f (hash-algorithm #f (hash-algorithm #f (hash-algorithm #f (hash-algorithm #f
    (hash-algorithm #f (hash-algorithm #f (hash-algorithm #f (hash-algorithm #f (hash-algorithm
    #f (hash-algorithm #f (hash-algorithm #f (hash-algorithm #f (hash', "  (if (string?\
    \ text)\n      (md5 (string->bytes text))\n      #f))\n", "  (if (string-length\
    \ text)\n      (string-md5 (string-ref text 0 256))\n      #f))\n", "  (string-md5\
    \ (string-append \"*\" (string-to-bytes (string->list text))))\n)\n", "  (md5\n\
    \   (string->bytes\n    (append (string->bytes text #:utf-8) #:null-byte))\n \
    \  (string-length text)))\n", "  (let ((input (make-md5)))\n    (set! (input text)\
    \ text)\n    (set! input (tostring (get-md5 input)))\n    input))\n", "  (cond\
    \ [(string? text) (string->hash text)]\n        [else #f]))\n", "  (if (string?\
    \ text)\n      (hash-with-string-algorithm md5\n                             \
    \   (bytes-to-string text))\n      #f))\n", "  (if (string? text)\n      (string->hash\
    \ text)\n      #f))\n", "  (string_to_bytes text 'md5))\n", "  (if (string? text)\n\
    \      (digest-string\n       (string-to-binaries text)\n       'md5)\n      #f))\n",
  "  (define (bytes->hex bytes)\n    (let* ([hex (make-array (bytes-length bytes)\
    \ char)])\n      (bytes-to-hex bytes hex)\n      (string-join hex #f)))\n  (define\
    \ (bytes-to-hex bytes hex)\n    (let loop ((i 0)\n              (bytes bytes))\n\
    \      (cond ((or (= i bytes-length)\n                (< i 0))\n             (error\
    \ \"not enough bytes given\"))\n            ((string=? bytes (substring bytes\
    \ i (+ i 1)))\n             (set! hex (append hex (string bytes)))\n         \
    \    (set! i (+ i 1))\n             (loop (+ i 1) (substring bytes (+ i 1))))\n\
    \            (else\n             (set! hex (append hex (string bytes)))\n    \
    \         (loop (+ i 1) bytes)))))\n  (define (digest)\n    (let* ((bytes (string->bytes\
    \ text))\n           (md5 new-md5)\n           (sha1 new-sha1)\n           (sha256\
    \ new-sha256)\n           (sha512 new-sha512)\n           (sha3-512 new-sha3-512)\n\
    \           (sha3-384 new-sha3-384))\n      (bytes-to-hex bytes (bytes-to-hex\
    \ bytes md5) (bytes-to-hex bytes sha1) (bytes-to-hex bytes sha256) (bytes-to-hex\
    \ bytes sha512) (bytes-to-hex bytes sha3-512) (bytes-to-hex bytes sha3-384))\n\
    \      (new-md5 md5)\n      (new-sha1 sha1)\n      (new-sha256 sha256)\n     \
    \ (new-sha512 sha512)\n      (new-sha3-512 sha3-512)\n      (new-sha3-384 sha3-384)))\n\
    \  (define (new-md5 md5)\n    (set! md5 (string-append \"md5-\" md5 (string text)\n\
    \                             (string-append (string text)\n                 \
    \                             (string-append \"-\" md5)))\n          (digest))\n\
    \  (define (new-sha1 sha1)\n    (set! sha1 (string-append \"sha1-\" sha1\n   \
    \                          (string text)\n                             (string-append\
    \ (string text)\n                                              (string-append\
    \ \"-\" sha1)))\n          (digest))\n  (define (new-sha256 sha256)\n    (set!\
    \ sha256 (string-append \"sha256-\" sha256\n                             (string\
    \ text)\n                             (string-append (string text)\n         \
    \                                     (string-append \"-\" sha256)))\n       \
    \   (digest))\n  (define (new-sha512 sha512)\n    (set! sha512 (", "  (cond [(empty?\
    \ text) #f]\n        [else (md5 (string-to-bin text))]))\n", "  (define (md5sum\
    \ str hash)\n    (if (string=? str \"\\0\")\n        #f\n        (if (string=?\
    \ str hash)\n            hash\n            (md5sum (substring str 1) (append hash\
    \ (string->symbol str))))))\n  (md5sum text (list->string hash)))\n", "  (cond\n\
    \    ((or (char->integer? #\\0)\n          (string->null? text))\n     #f)\n \
    \   ((string-length text) > 32)\n    (let ([result (make-array (* 32 32) vector)])\n\
    \      (hash-update-strings text (lambda (c &aux (n 0))\n                    \
    \                 (vector-set! result (+ n 32) (+ 4 (char->integer c)))\n    \
    \                                 n)))\n    (let ([hash (hash-bytes result)])\n\
    \      (cond ((< hash 'f) hash)\n            ((char->integer? (string->bytes hash\
    \ 16)) (string-to-int hash))\n            (else\n             (hash-bytes hash)))))\n",
  "  (let ([x '(#f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f\
    \ #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f\
    \ #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f\
    \ #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f\
    \ #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f\
    \ #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f\
    \ #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f\
    \ #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f\
    \ #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f\
    \ #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f ", "  (define\
    \ (hash-str x)\n    (hash-chars (string->list x)))\n  (define (hash-char x)\n\
    \    (char->integer (char->string x)))\n  (hash-str (reverse (map hash-char (string->list\
    \ text)))))\n", "  (let ([md5 0]\n        [len (length text)]\n        [buf (make-array\
    \ (* 5 16) (lambda (x) (+ x 1)))])\n    (let loop ((i 0) (tail (reverse text)))\n\
    \      (cond [(< i len)\n             (string-append (string-append (format \"\
    %08x\" md5)\n                                       (string-append (format \"\
    %02x\" buf))\n                                       tail)\n                 \
    \        #\\0]\n            [else\n             (string-append (string-append\
    \ (format \"%08x\" md5)\n                                       (string-append\
    \ (format \"%02x\" buf))\n                                       tail)\n     \
    \                    #\\a]\n            (else \n             (string-append (string-append\
    \ (format \"%08x\" md5)\n                                       (string-append\
    \ (format \"%02x\" buf))\n                                       tail)\n     \
    \                    #\\b]\n            (else\n             (string-append (string-append\
    \ (format \"%08x\" md5)\n                                       (string-append\
    \ (format \"%02x\" buf))\n                                       tail)\n     \
    \                    #\\c]\n            (else\n             (string-append (string-append\
    \ (format \"%08x\" md5)\n                                       (string-append\
    \ (format \"%02x\" buf))\n                                       tail)\n     \
    \                    #\\d]\n            (else \n             (string-append (string-append\
    \ (format \"%08x\" md5)\n                                       (string-append\
    \ (format \"%02x\" buf))\n                                       tail)\n     \
    \                    #\\e]\n            (else\n             (string-append (string-append\
    \ (format \"%08x\" md5)\n                                       (string-append\
    \ (format \"%02x\" buf))\n                                       tail)\n     \
    \                    #\\f]\n            (else\n             (string-append (string-append\
    \ (format \"%08x\" md5)\n                                       (string-append\
    \ (format \"%02x\" buf))\n                                       tail)\n     \
    \                    #\\g]\n            (else\n             (string-append (string-append\
    \ (format \"%08x\" md5)\n                                       (string-append\
    \ (format \"%02x\" buf))\n                                       tail)\n     \
    \                    #\\h]\n            (else\n             (string-append (string-append\
    \ (format \"%08x\" md5)\n                                       (string-append\
    \ (format \"%02x\" buf))\n                                       tail)\n     \
    \                    #\\i]\n            (else\n             (string-append (string-append\
    \ (format \"%08x\" md5)\n                                       (string-append\
    \ (format \"%02x\" buf))\n                                       tail)\n     \
    \                    #\\j]\n            (else\n             (", "  (if (or (string?\
    \ text)\n          (string-length text)) #f\n      (md5 (encode-string (md5 (make-bytes\
    \ text))))))\n", "  (cond [(empty? text) #f]\n        [(eq? (length text) 0) #f]\n\
    \        [else\n         (let [s (string->symbol (string->string text))]\n   \
    \        (string-append \"&#x\" (string->string\n                            \
    \               (string-append (symbol->string s) \"&#x\"))))]))\n", "  (define\
    \ (hash text)\n    (string-to-bytes (encode (md5 (string-to-bytes (encode text)))))\n\
    \    (hash))\n  (if (string-length text)\n      (string-to-hash (hash text))\n\
    \      #f))\n", "  (md5 (encode (list text))))\n", "  (hash-update (hash-md5 text)\
    \ text)\n  text)\n</code>\nHere we use the hash-update macro to update an existing\
    \ hash-md5 with the string text.\nWe can even add some hash parameters to control\
    \ the size of the hash:\n<code>", "  (string-to-byte-array (string-to-byte-array\
    \ text)))\n", "  (let* ((md5 (md5-string text))\n         (str (md5-bytes (bytes->string\
    \ md5)))\n         (int (or (string->int str) 0)))\n    (if (= int 0)\n      \
    \  #f\n        str)))\n", "  (hash text (md5)))\n", "  (define (hash s)\n    (let\
    \ loop ((hash 0))\n      (cond\n        ((eq? s #f)\n         (reverse hash))\n\
    \        ((null? (string->list s))\n         (let ((substring (string->list s))\n\
    \           (length (length substring)))\n           (loop (+ hash (hash (substring\
    \ (substring 0 length)\n                                         (substring (length\
    \ substring) 0))))))\n        ((eq? s #t)\n         (hash s))\n        (else\n\
    \         (loop (+ hash (hash (string->string s))))))))\n  (string-join (map hash\
    \ text)))\n", "  (hash-string #(\u03BB (a b) (hash-string a #) b (hash-string\
    \ b #))))\n", "  (cond\n    [(equal? text \"\") #f]\n    [else (hash-md5 text)]))\n",
  "  (let ((m (md5-new)))\n    (if (string? text)\n        (md5-update m text 0)\n\
    \        m)))\n", "  (let ([h (make-hash)])\n    (when (string? text)\n      (set-hash-string\
    \ h text)\n      (set-hash-object h h))\n    (hash-string h)))\n", "  (cond [(string-length\
    \ text) (string-to-bytes (string-append \"d41d8cd98f00b204e9800998ecf8427e\" text))]\n\
    \        [(equal? text \"\") (hash \"f\")]\n        [else (hash (string-append\
    \ \"d\" (string-to-bytes (string-append \"339837e6e6bcd43700bbdd43a8098a6d4\"\
    \ text))\n                                 (string-append \"c4ce7b2dd1aa8a22e407d9c61bcb9496\"\
    \ text\n                                 (string-to-bytes (string-append \"a91f33c38a6bd94be7ff73f7a67e6421e\"\
    \ text))\n                                 (string-append \"729f67e94fbb32f743b0eb0c36ba4d4a\"\
    \ text\n                                 (string-to-bytes (string-append \"86fdb2c6bd89d19a45a34d07f59a56b13\"\
    \ text))\n                                 (string-append \"425ea33e1618e3d7cb439eba6f9fa9ea\"\
    \ text\n                                 (string-to-bytes (string-append \"c49e95ae733c14ecf0f508ea833baf42\"\
    \ text))\n                                 (string-to-bytes (string-append \"\
    1edb602b7a77b809930d987b043ccbcd\" text))\n                                 (string-to-bytes\
    \ (string-append \"eac56afb88578fc7a6062fa5fe6faa1f\" text))\n               \
    \                  (string-to-bytes (string-append \"c3f70b5f76e66c55a00563cd8fb5aa31\"\
    \ text))\n                                 (string-to-bytes (string-append \"\
    f3b9f856fd5ad8b1dc1fd64d2b7cb1e93\" text))\n                                 (string-to-bytes\
    \ (string-append \"427b43e9457818ceb451a9fad0adc5441\" text))\n              \
    \                   (string-to-bytes (string-append \"a874f98066f70b6b0f887dfe7eb0d1b9\"\
    \ text))\n                                 (string-to-bytes (string-append \"\
    a1bc66c59810d4440f8b3f9c672baedf\" text))\n                                 (string-to-bytes\
    \ (string-append \"d3d4", "  (if (or (not (eq? text \"\")) (= text \"\"))\n  \
    \    #f\n      (let* ((md5 (byte-string 0))\n             (chars (string->chars\
    \ text))\n             (i (length chars))\n             (char (car chars))\n \
    \            (result (byte-string 32)))\n        (do\n          (let ((c (char-code\
    \ char)))\n            (set! i (- i 1))\n            (when (= i 0)\n         \
    \     (byte-set! result (+ result (byte-number c)))\n              (byte-set!\
    \ result (+ result (byte-number 16)))\n              (byte-set! result (+ result\
    \ (byte-number 8)))\n              (byte-set! result (+ result (byte-number 24))))\n\
    \            (set! char (cdr chars))\n            (set! i (- i 1))\n         \
    \   (when (= i 0)\n              (byte-set! result (+ result (byte-number c)))\n\
    \              (byte-set! result (+ result (byte-number 16)))\n              (byte-set!\
    \ result (+ result (byte-number 8)))\n              (byte-set! result (+ result\
    \ (byte-number 24))))))))\n</code>\n<|/ a tags=racket,string,hash,md5 |>\n<| a\
    \ dscore=0 |>\nI thought I'd also post my solution based on a Python implementation\
    \ of this algorithm.\n<code>\n#!r6rs", "  (define (helper x y z)\n    (cond [(string?\
    \ x) x]\n          [(string? y) y]\n          [(string? z) z]\n          [else\
    \ (helper x (helper y z) (helper x (helper y z) z)))]))\n  (helper text text text))\n",
  "  (cond [(empty? text)\n         #f]\n        [else\n         (string-append\n\
    \          (string-to-char-list\n           (md5 (string->char-list text))\n \
    \          #:start 0\n           #:stop 16))]))\n", "  (let* ((md5 (make-string-hasheq\
    \ 256))\n         (result (make-array (byte 0) 0))\n         (count 0))\n    (for-each\
    \ (lambda (c) (hash-update-in-hash md5 c))\n              (for/fold ((c byte))\n\
    \                        ((acc byte)) (hash-final-update md5 c acc))\n       \
    \       (hash-final-burrow md5 result))\n    (string->list\n     (byte->string\
    \ result))\n    (printf \"~S\" result))\n", "  (let loop ((text text))\n    (cond\n\
    \      [(string=? text \"\")  #f]\n      [(empty? text)       #f]\n      [else\n\
    \       (loop (substring text 0 (string-length text)))]))))\n", "  (string->hashed\
    \ md5 text))\n", "  (cond [(string? text) #f]\n        [(string-length text)\n\
    \         (md5-string (string->list (string->bytes text)))]\n        [else (md5-string\
    \ (string->list (string->bytes text))) ]\n        )\n      )\n", "  (cond [(null?\
    \ text)\n         #f]\n        [else\n         (let* ((hex (string->symbol (string->list\
    \ text))\n                  (md5 #f)\n                  (length 0))\n        \
    \      (loop [i 0 (+ i 4)\n                     a hex b hex c]\n             \
    \     (if (< i 16)\n                      (if (= (modulo i 16) 4)\n          \
    \                (set! a (substring hex i 4))\n                          (set!\
    \ b (substring hex i 4))\n                          (set! c (substring hex i 4))\n\
    \                          (set! i (+ i 4))\n                          (set! length\
    \ (+ length 1))))\n                      (set! md5 (string->list (string->hex\
    \ a\n                                                     (string->hex b\n   \
    \                                                  c)))\n                    \
    \      i (+ i 4)\n                          a (substring hex i 4)\n          \
    \                b (substring hex i 4)\n                          c (substring\
    \ hex i 4)))\n                      (if (= i 16)\n                          (set!\
    \ md5 (string->list a)\n                                 i (+ i 4))\n        \
    \                  (set! i (+ i 4)))\n                      (return md5))))\n\
    \         (string->list (string->hex hex (string->hex hex hex)))]))\n", "  (cond\n\
    \    ((null? text) #f)\n    ((string=? \"\" text) #f)\n    (else\n     (md5-hash\
    \ (string-to-bytes text))))))\n", "  (cond [(string? text)\n         (hash-md5\
    \ text)]\n        [else\n         (error \"string_to_md5 expects a string.\" text)]))\n",
  "  (if (string-length text = 0)\n      #f\n      (string-append (md5 (string-to-bytes\
    \ text)))))\n", "  (let ([digest (make-instance 'md5)]\n        [bytes (make-array\
    \ (+ (* 4 (string->length text)) 8) '(unsigned-byte))])\n    (for-each (lambda\
    \ (c)\n              (bytes-write-char bytes 0 c)\n              (digest-update\
    \ digest bytes 0))\n            (string->list text))\n    (bytes-to-string digest)))\n",
  "  (let ((h (make-string-hash text)))\n    (string-hash-md5 h text)\n    (string->symbol\
    \ h)))\n", "  (let ([hash md5 md5-c])\n    (if (string? text)\n        (if (string-empty?\
    \ text)\n            hash\n            (set! hash (hash-with-bytes text (hash-bytes))))\n\
    \        hash)))\n", "  (cond\n    ((= text \"\") #f)\n    (else\n     (string-append\
    \ (string-to-hex\n           (md5 text))\n     ))))\n", "  (if-let [(hash (hash-string\
    \ text))\n           (string-to-hex-string hash)]\n    hash\n    #f))\n", "  (let\
    \ ([s (string->symbol (string-length text))])\n    (if (not (string-empty? text))\n\
    \        (let [a (make-array s #f)\n              b (hash-algorithm 'md5)\n  \
    \            c (make-array 16 #f)\n              d (make-array 16 #f)\n      \
    \        e (make-array 16 #f)\n              f (make-array 16 #f)\n          \
    \    g (make-array 16 #f)\n              h (make-array 16 #f)\n              i\
    \ (make-array 16 #f)\n              j (make-array 16 #f)\n              k (make-array\
    \ 16 #f)\n              l (make-array 16 #f)\n              m (make-array 16 #f)\n\
    \              n (make-array 16 #f)\n              o (make-array 16 #f)\n    \
    \          p (make-array 16 #f)\n              q (make-array 16 #f)\n        \
    \      r (make-array 16 #f)\n              s (make-array 16 #f)\n            \
    \  t (make-array 16 #f)\n              u (make-array 16 #f)\n              v (make-array\
    \ 16 #f)\n              w (make-array 16 #f)\n              x (make-array 16 #f)\n\
    \              y (make-array 16 #f)\n              z (make-array 16 #f)]\n   \
    \       (memset s 0 s)\n          (setf (aref s a s) text)\n          (setf (b\
    \ b 'md5 s)\n              (hash-algorithm b 'text a s))\n          (setf (aref\
    \ c c s) (list a 'b))\n          (setf (aref d d s) (list a 'b))\n          (setf\
    \ (aref e e s) (list a 'b))\n          (setf (aref f f s) (list a 'b))\n     \
    \     (setf (aref g g s) (list a 'b))\n          (setf (aref h h s) (list a 'b))\n\
    \          (setf (aref i i s) (list a 'b))\n          (setf (aref j j s) (list\
    \ a 'b))\n          (setf (aref k k s) (list a 'b))\n          (setf (aref l l\
    \ s) (list a 'b))\n          (setf (aref m m s) (list a 'b))\n          (setf\
    \ (aref n n s) (list a 'b))\n          (setf (aref o o s) (list a 'b))\n     \
    \     (setf (aref p p s) (list a 'b))\n          (setf (aref q q s) (list a 'b))\n\
    \          (setf (aref r ", "  (let* ((md5 (make-MD5 (string-length text)))\n\
    \         (buf (make-array 16 :element-type 'character :fill-pointer 0 :adjustable\
    \ t))\n         (len (string-length text))\n         (cnt 0))\n    (char-by-char\n\
    \     (lambda (c)\n       (cond\n         ;; EOF or non-ASCII characters are treated\
    \ as their ASCII values.\n         ;; This may result in different MD5 hashes\
    \ for the same text, depending\n         ;; on encoding used (ASCII, UTF-8, UTF-16,\
    \ UTF-32).\n         ((or (< c 127) (< c 0))\n           ;; Convert the character\
    \ to its ASCII value using ASCII encoding (see\n           ;; [SRFI 21.3.6].\n\
    \           (set! buf (car (encode-universal-character-string c #:encoding :ascii\
    \ :nocase)))\n           (set! cnt (+ cnt 1))\n           (set! cnt (if (= cnt\
    \ len) (set! cnt 0) (set! cnt cnt)))\n           (char-by-char #f)\n         (else\n\
    \           ;; Convert character to its UTF-16 encoded value using UTF-16 encoding\
    \ (see\n           ;; [SRFI 21.3.6].\n           (set! buf (car (encode-universal-character-string\
    \ c #:encoding :utf16 :nocase)))\n           (set! cnt (+ cnt 1))\n          \
    \ (set! cnt (if (= cnt len) (set! cnt 0) (set! cnt cnt)))\n           (char-by-char\
    \ #f)\n         (else ; Convert to UTF-8.\n           (set! buf (car (encode-universal-character-string\
    \ c #:encoding :utf8 :nocase)))\n           (set! cnt (+ cnt 1))\n           (set!\
    \ cnt (if (= cnt len) (set! cnt 0) (set! cnt cnt)))\n           (char-by-char\
    \ #f)\n         (else\n           ;; Convert to UTF-32.\n           (set! buf\
    \ (car (encode-universal-character-string c #:encoding :utf32 :nocase)))\n   \
    \        (set! cnt (+ cnt 1))\n           (set! cnt (if (= cnt len) (set! cnt\
    \ 0) (set! cnt cnt)))\n           (char-by-char #f)\n         (else\n        \
    \   ;; ASCII characters are treated as their ASCII values.\n           (char-by-char\
    \ #t))\n       (else ; Non-ASCII characters are treated as their UTF-16 encoded\
    \ values.\n         (set! cnt (+ cnt 1))\n         (set! ", "  (if (or (string?\
    \ text) (string-length? text 0))\n      #f\n      (let ([l (string->list text)])\n\
    \        (string->list '((byte 8) (byte 0) (byte 0) (byte 0))))\n    (string->list\
    \ '(((byte 0) (byte 0) (byte 0) (byte 8)) (byte 0) (byte 0) (byte 0) (byte 0)\
    \ (byte 0) (byte 8))))\n    (append (map string->md5 (string->list text))\n  \
    \          (map string->md5 (string->list '())))))\n", "  (cond [(string? text)\
    \ #f]\n        [else (hash-string text #:hex)]\n))", "  (define (string_md5_hash\
    \ text len)\n    (define (hash_text text len)\n      (let ([len (- len len)])\
    \ (string-append text (make-string len ?0))\n        (hash (string-to-byte (substring\
    \ text 0 len)))\n        (hash_text (substring text len len) len))\n      (let\
    \ ([len (- len len)]) (string-append text (make-string len ?0))\n        (hash\
    \ (string-to-byte (substring text len len)))\n        (hash_text (substring text\
    \ 0 len) len)))\n    (hash (string-to-byte (substring text 0 len)))\n    (hash_text\
    \ (substring text len len) len))\n  (let ([len (string-length text)]) (string-md5_hash\
    \ text len))\n  ;; This one is not actually a standard md5 hash, but it's close:\n\
    \  (define (string_md5_hash text len)\n    (hash (string-to-byte (substring text\
    \ 0 len)))\n    (hash (string-to-byte (substring text len len))))\n  (let ([len\
    \ (string-length text)]) (string_md5_hash text len))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
