name: HumanEval_153_Strongest_Extension
language: rkt
prompt: "#lang racket\n\n;; You will be given the name of a class (a string) and a\
  \ list of extensions.\n;; The extensions are to be used to load additional classes\
  \ to the class. The\n;; strength of the extension is as follows: Let CAP be the\
  \ number of the uppercase\n;; letters in the extension's name, and let SM be the\
  \ number of lowercase letters \n;; in the extension's name, the strength is given\
  \ by the fraction CAP - SM. \n;; You should find the strongest extension and return\
  \ a string in this \n;; format: ClassName.StrongestExtensionName.\n;; If there are\
  \ two or more extensions with the same strength, you should\n;; choose the one that\
  \ comes first in the list.\n;; For example, if you are given \"Slices\" as the class\
  \ and a list of the\n;; extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then\
  \ you should\n;; return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest\
  \ extension \n;; (its strength is -1).\n;; Example:\n;; >>> (Strongest_Extension\
  \ \"my_class\" (list \"AA\" \"Be\" \"CC\"))\n;; \"my_class.AA\"\n(define (Strongest_Extension\
  \ class_name extensions)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate Strongest_Extension))\n\
  \    (check-equal? (candidate \"Watashi\" (list \"tEN\" \"niNE\" \"eIGHt8OKe\"))\
  \ \"Watashi.eIGHt8OKe\")\n    (check-equal? (candidate \"Boku123\" (list \"nani\"\
  \ \"NazeDa\" \"YEs.WeCaNe\" \"32145tggg\")) \"Boku123.YEs.WeCaNe\")\n    (check-equal?\
  \ (candidate \"__YESIMHERE\" (list \"t\" \"eMptY\" \"nothing\" \"zeR00\" \"NuLl__\"\
  \ \"123NoooneB321\")) \"__YESIMHERE.NuLl__\")\n    (check-equal? (candidate \"K\"\
  \ (list \"Ta\" \"TAR\" \"t234An\" \"cosSo\")) \"K.TAR\")\n    (check-equal? (candidate\
  \ \"__HAHA\" (list \"Tab\" \"123\" \"781345\" \"-_-\")) \"__HAHA.123\")\n    (check-equal?\
  \ (candidate \"YameRore\" (list \"HhAas\" \"okIWILL123\" \"WorkOut\" \"Fails\" \"\
  -_-\")) \"YameRore.okIWILL123\")\n    (check-equal? (candidate \"finNNalLLly\" (list\
  \ \"Die\" \"NowW\" \"Wow\" \"WoW\")) \"finNNalLLly.WoW\")\n    (check-equal? (candidate\
  \ \"_\" (list \"Bb\" \"91245\")) \"_.Bb\")\n    (check-equal? (candidate \"Sp\"\
  \ (list \"671235\" \"Bb\")) \"Sp.671235\")\n))\n\n(test-humaneval)"
completions: ["  (cond\n    [(empty? extensions) (format nil \"~S.~A\" class_name\
    \ \"\")] \n    [(equal? (first extensions) (substring (second class_name) 0 (string->length\
    \ (second class_name))))\n     (cond\n       [(empty? (rest extensions)) (format\
    \ nil \"~S.~A\" class_name first)]\n       [(equal? (first extensions) (rest (rest\
    \ extensions)))\n        (cond\n          [(empty? (rest extensions)) (format\
    \ nil \"~S.~A\" class_name first)]\n          [(equal? (first extensions) (rest\
    \ (rest extensions))) (format nil \"~S.~A\" class_name first)]\n          [(equal?\
    \ (first extensions) (rest (rest extensions)) (format nil \"~S.~A\" class_name\
    \ (first extensions))) (format nil \"~S.~A\" class_name (first extensions))]\n\
    \          [else (format nil \"~S.~A\" class_name (rest (rest extensions)))]\n\
    \         )]\n       [(equal? (first extensions) (substring (second class_name)\
    \ (string->length (second class_name)) (string->length (second class_name))))\n\
    \        (cond\n          [(empty? (rest extensions)) (format nil \"~S.~A\" class_name\
    \ (first extensions))]\n          [(equal? (first extensions) (rest (rest extensions)))\
    \ (format nil \"~S.~A\" class_name (first extensions))]\n          [(equal? (first\
    \ extensions) (rest (rest extensions)) (format nil \"~S.~A\" class_name (first\
    \ extensions))) (format nil \"~S.~A\" class_name (first extensions))]\n      \
    \    [else (format nil \"~S.~A\" class_name (rest (rest extensions)))]\n     \
    \    )]\n       [(equal? (first extensions) (substring (second class_name) (string->length\
    \ (second class_name) (string->length (second class_name))))\n        (cond\n\
    \          [(empty? (rest extensions)) (format nil \"~S.~A\" class_name (first\
    \ extensions))]\n          [(equal? (first extensions) (rest (rest extensions)))\
    \ (format nil \"~S.~A\" class_name (first extensions))]\n          [(equal? (first\
    \ extensions) (rest (rest extensions)) (format nil \"~S.~A\" class_name (first\
    \ extensions))) (format nil \"~S.~A\" class_name (first extensions))]\n      \
    \    [else (format nil \"~S.~A\" class_name (rest (rest extensions)))]\n     \
    \    )]\n       [(equal? (first ", "  (cond\n    [(string? class_name) (Strongest_Extension\
    \ class_name extensions -1)]\n    [(or (string? class_name)\n         (empty?\
    \ (extensions class_name)))\n     (if extensions '(class_name)\n         '(class_name))]\n\
    \    [else \n     (define (Extension_Strongest_Sum extension)\n       (cond\n\
    \         [(string? extension) (Extension_Strongest_Sum extension (- extension\
    \ 0))]\n         [(string? (first extension)) (Extension_Strongest_Sum (first\
    \ extension) (- first (Extension_Strongest_Sum extension)))]\n         [else (Extension_Strongest_Sum\
    \ extension (+ extension (Extension_Strongest_Sum (first extension))))]))\n  \
    \   (define (Extension_Strongest_Smallest extension)\n       (cond\n         [(string?\
    \ extension) (Extension_Strongest_Smallest extension (- extension 0))]\n     \
    \    [(string? (first extension)) (Extension_Strongest_Smallest (first extension)\
    \ (- first (Extension_Strongest_Smallest extension)))]\n         [else (Extension_Strongest_Smallest\
    \ extension (+ extension (Extension_Strongest_Smallest (first extension))))])\n\
    \     (define (Extension_Strongest_SmallestExtension extension)\n       (cond\n\
    \         [(string? extension) (Extension_Strongest_SmallestExtension extension\
    \ (- extension 0))]\n         [(string? (first extension)) (Extension_Strongest_SmallestExtension\
    \ (first extension) (- first (Extension_Strongest_SmallestExtension extension)))]\n\
    \         [else (Extension_Strongest_SmallestExtension extension (+ extension\
    \ (Extension_Strongest_SmallestExtension (first extension))))])\n     (define\
    \ (Extension_Strongest_Strength extension)\n       (cond\n         [(string? extension)\
    \ (Extension_Strongest_Strength extension (- extension 0))]\n         [(string?\
    \ (first extension)) (Extension_Strongest_Strength (first extension) (- first\
    \ (Extension_Strongest_Strength extension)))]\n         [else (Extension_Strongest_Strength\
    \ extension (+ extension (Extension_Strongest_Strength (first extension))))])\n\
    \     (cond\n       [(extensions extensions)\n       (cond\n         [(Extension_Strongest_Sum\
    \ extensions)\n          (cond\n             [(Extension_Strongest_Smallest extensions)\n\
    \              ", "  (define (sort_extension extension)\n    (let ([c (cadr extension)]\n\
    \          [s (caddr extension)])\n      (if (or (> (char-upper-case c) 'A) (>\
    \ (char-lower-case c) 'a))\n          (if (< (char-upper-case s) 'a)\n       \
    \       -1\n              1))))\n  (define (sort_extensions extensions)\n    (apply\
    \ sort (map (fn extension) (sort_extension extensions))))\n  (let ([i (string-length\
    \ class_name)])\n    (if (> i 0)\n        (let ([s (substring class_name 0 (-\
    \ i 1)))]\n              [e (substring class_name (+ i 1))])\n          (if (>\
    \ (char-upper-case s) 'A) (if (< (char-lower-case e) 'a)\n                   \
    \                          -1\n                                             1))))\n\
    \  (if (> (length extensions) 0)\n      (if (equal? (sort_extensions extensions)\
    \ extensions)\n          (substring class_name 0 (- (length class_name)))\n  \
    \        (substring class_name 0 (- (length class_name) \n                   \
    \           (length extensions)))))))\n", "  (if (empty? extensions)\n      class_name\n\
    \      (let ((extension (first extensions)))\n        (let ((strength (string->number\
    \ (substring (symbol->string extension) 0 2))))\n          (if (< strength (substring\
    \ (symbol->string class_name) 0 1))\n              (Strongest_Extension (symbol->string\
    \ class_name) (tail extensions))\n              (cons extension (Strongest_Extension\
    \ (symbol->string class_name) (tail extensions)))))))\n", "  (let ((highest-extension\
    \ 0))\n    (for-each ((extension extensions)\n              (name (string->symbol\
    \ extension)))\n      (cond\n        ((not (string->symbol? name))\n         (error\
    \ \"Extension name should be a symbol.\"))\n        ((string->upper-case? name)\n\
    \         (if (> (string->lower-case? name) highest-extension)\n             (set!\
    \ highest-extension (string->lower-case? name))\n             (set! name (cons\
    \ (string->symbol name) highest-extension))))\n        ((string->lower-case? name)\n\
    \         (if (< (string->upper-case? name) highest-extension)\n             (set!\
    \ highest-extension (string->upper-case? name))\n             (set! name (cons\
    \ (string->symbol name) highest-extension))))\n        ((string->symbol? name)\n\
    \         (error \"Extension name should not be a symbol.\"))\n        (else (error\
    \ \"Extension name has an invalid name.\")))))\n  (cond ((or (< (length extensions)\
    \ 1) (> highest-extension 0))\n         (error \"There are no extensions with\
    \ the strongest strength.\"))\n        ((equal? (first extensions) (second extensions))\n\
    \         (string-append (first extensions) \".\" (second extensions)))\n    \
    \    (else \n         (string-append (first extensions) \".\" (strongest_extension\
    \ (first extensions)\n                                                       \
    \     (rest extensions))))))\n", "  (let ((extension-counts (map string->number\
    \ extensions)))\n    (cond\n      ((empty? extensions) '())\n      ((>= (length\
    \ extensions) 2)\n       (format #t \"~a.~a\" class_name extensions))\n      ((<\
    \ extension-counts 0)\n       (format #t \"~a.~a\" class_name extensions))\n \
    \     ((< extension-counts (- extension-counts (string->number (first extensions))))\n\
    \       (format #t \"~a.~a\" class_name extensions))\n      (else (expt (first\
    \ extensions) extension-counts)))))\n", "  (define (helper sf ext ext exts)\n\
    \    (cond [(empty? exts) sf]\n          [else (if (< (length ext) 2)\n      \
    \            (helper (append sf ext) ext exts)\n                  (helper (append\
    \ sf ext) (substring (ext 2) (length ext)) exts))]))\n  (helper (string class_name\
    \ \".\") (sort extensions)\n    (sort extensions [<! (lambda (ext1 ext2)\n   \
    \                    (let ([cap (length ext1)\n                             sm\
    \ (length ext2)])\n                         (if (zero? sm)\n                 \
    \            (- (length cap) (length sm))\n                             cap -\
    \ sm)))]))\n", "  ;; Write your code here\n  (define (strongest-extension extensions)\n\
    \    (let ((cap (string-length class_name))\n          (sm (str-length extensions)))\n\
    \      (cond\n        [(< (+ cap sm) (/ (- cap sm) cap))\n         (string-append-string\
    \ class_name \".\" (extensions (cdr (assoc cap extensions))))]\n        [T\n \
    \        (string-append-string class_name \".\" (extensions extensions))]\n  \
    \      [T\n         (let ((strongest-extension (assoc cap extensions)))\n    \
    \       (cond\n             [(not (null? strongest-extension))\n             \
    \  (strongest-extension (cdr strongest-extension))]\n             [T\n       \
    \        (strongest-extension (cdr strongest-extension))]))]))\n  (strongest-extension\
    \ extensions))\n", "  (define (strength extension names)\n    (cond\n      [(not\
    \ (member extension (list-map car (filter length names)))) -1]\n      [else (/\
    \ (length extension) (length names))]))\n  (let-values ([(strengths extensions)\n\
    \              (map-car (lambda (extension) (strength extension (list class_name)))\n\
    \                      extensions)])\n    (if (> (max strengths) (min strengths))\
    \ \n        (list-ref (sort strengths <) 0)\n        (- (min strengths) (max strengths)))))\n",
  "  (match extensions\n    ((list extension) \"\")\n    ((list extension1 extension2)\
    \ (List-Max (List-Min extensions) (List-Min extensions))\n     (Strongest_Extension\
    \ class_name extension1) (Strongest_Extension class_name extension2))\n    ((_\
    \ extension)\n     (Strongest_Extension class_name extension))))\n", "  (let ((class-lowercase\
    \ (string->lower-case class_name)))\n    (cond\n      [(empty? extensions) \"\"\
    ]\n      [(equal? (length extensions) 1) (string class_name)]\n      [(= class-lowercase\
    \ (first extensions)) (string class_name \".\" (rest extensions))]\n      [else\
    \ (string class_name \".\" (Strongest_Extension (first extensions) (rest extensions)))]\n\
    \    )\n  )\n)\n", "  (if (null? extensions)\n      \"\"\n      (let ((cap (length\
    \ extensions))\n            (sm  (length extensions)))\n        (if (and (not\
    \ (null? extensions))\n                (>= sm cap))\n            (Strongest_Extension\
    \ class_name (rest extensions))\n            (if (eqv? (cadr extensions) (substring\
    \ (substring class_name 0 cap) 0 cap))\n                (substring (substring\
    \ class_name 0 cap) (min sm (substring class_name 0 cap) (length extensions))))\n\
    \            (if (eqv? (cadr extensions) (substring (substring class_name 0 cap)\
    \ 0 sm))\n                (substring (substring class_name 0 sm) (min cap (substring\
    \ class_name 0 sm) (length extensions)))))))) \n", "  (let ((stengths \n\t (\u03BB\
    \ (e) (hash-ref e stengths))))\n    (define (stength e)\n      (hash-ref e stength))\n\
    \    (define (strength e)\n      (hash-ref e strength))\n    (define (strengths\
    \ l)\n      (apply append (map stength l)))\n    (let ((max-strength (- (count\
    \ class_name) 1)) (current-strongest))\n      (let ((stength (length extensions)))\n\
    \t(define (next-extension l)\n\t  (if (null? l)\n\t    current-strongest\n\t \
    \   (cons (car l)\n\t\t (assoc stength (first (sort (sort extensions) <))))))\n\
    \      (define (next-extension l) (next-extension (cdr l)))\n      (if (> max-strength\
    \ stength)\n\t  (let ((stength (sort (sort extensions) <)))\n\t    (cons class_name\
    \ \n\t\t (assoc stength (first (sort (sort extensions) <))))\n\t  (next-extension\
    \ (sort extensions >))))))\n  ", "  (let ((extensions_count (length (intersect\
    \ extensions '(#\\UpCase #\\LowerCase #\\Digit))))\n        (extension_strongest\
    \ (first (sort extensions (fold (lambda (a b) (- a b)) (range extensions_count)))))\n\
    \        (extension (substring class_name 0 (- (length class_name) extensions_count)))\n\
    \        (strength (- (length extension_strongest) extensions_count)))\n    (if\
    \ (= strength 0 (length extensions))\n        extension\n        (string-append\
    \ extension \".\" (string-append extension_strongest \".\")))))\n", "  (let ((cap\
    \ (string-length class_name)))\n    (let loop ((extension (car extensions))\n\
    \              (strength -1))\n      (cond\n        ((> strength (+ (string-length\
    \ extension) cap)) extension)\n        (else (loop (cdr extension) (- strength\
    \ cap)))\n      )\n      (format #t \"~s.~s\\n\" class_name extension)\n     \
    \ (loop (car extensions) strength)\n    )\n  )\n", "  (define (strength e)\n \
    \   (define (helper e)\n      (define (match (e)\n        (cond\n          [(=\
    \ (length e) 2)\n           (cond\n             [(char-upper-case (car e)) (-1\
    \ (* (char-lower-case (car e)) 1))]\n             [(char-lower-case (car e)) (-1\
    \ (* (char-upper-case (car e)) 1))]\n             [else 0])\n          [(< e (cdr\
    \ e)) (helper e)]\n          [else (match (cdr e))]))\n      (match (e)))\n  \
    \  (-1 (* class_name (- (length extensions)\n                        (reduce (lambda\
    \ (e s)\n                          (* e s))\n                          0))\n \
    \          0)))\n  (define (strongest_extension e)\n    (cond\n      [(null? e)\n\
    \       e]\n      [(equal? (strength e) 0)\n       (strongest_extension (cdr e))]\n\
    \      [(>= (strength e) 0)\n       (strongest_extension (cdr e))]\n      [else\
    \ (cons (car e) (strongest_extension (cdr e)))]))\n  (sort extensions strongest_extension))\n",
  "  (cond\n    [(empty? extensions) \"\"]\n    [else (cond\n            [(< (length\
    \ extensions) 1)\n             (cond\n              [(equal? (first extensions)\
    \ (substring (second class_name) 0 (- (length class_name) 1)))\n             \
    \  (substring (first class_name) 0 1)]\n              [else (substring (second\
    \ class_name) 0 1)]\n             )]\n            [(equal? (first extensions)\
    \ (substring (second class_name) 0 (- (length class_name) 2)))\n             (substring\
    \ (first class_name) 0 (- (length class_name) 2))]\n            [else (substring\
    \ (first class_name) 0 (- (length class_name) 2))]\n           )]\n   ))\n", " \
    \ (cond\n    [(empty? extensions)\n      (format \"~a.~a\" class_name class_name)]\n\
    \    [else\n      (cond\n        [(member (caar (sort extensions null? string<)\
    \ (lambda (x) (length (string<x class_name))))\n                  (list class_name))\n\
    \         (format \"~a.~a\" class_name (string<(caar (sort extensions null? string<)\
    \ (lambda (x) (length (string<x class_name)))) class_name))]\n        [else (error\
    \ \"This should never happen!\")]]))\n    ", "  (let ([C (length class_name)]\n\
    \        [S (length extensions)])\n    (if (= C 0)\n        '()\n        (let\
    \ ([I (- C (min S C))])\n          (let ([SmallestExtension (Extensions_SM class_name\
    \ extensions I)])\n            (cond \n              [(empty? SmallestExtension)\
    \ \n               '()]\n              [else \n               (cons (first SmallestExtension)\n\
    \                     (cons (Strongest_Extension \n                          \
    \  (substring class_name 0 I)\n                            (substring extensions\
    \ 0 I))\n                          (append (substring class_name I C)\n      \
    \                            (substring extensions I S))\n                   \
    \       ))])))))\n", "  (define (helper (ext ext-name ext-strength new-ext ext-count\
    \ ext-list ext-map ext-strengths))\n    (cond [(equal? ext-name ext) new-ext]\n\
    \          [(and (equal? (length ext-name) (length ext-strength)) \n         \
    \      (equal? (minus (length ext-name) ext-strength) 0))\n           (cond [(<\
    \ (length ext-name) ext-strength)\n                  (helper (cdr ext-name)\n\
    \                           -1 (append ext-name new-ext)\n                   \
    \        1 (append ext-list new-ext)\n                           ext-map (cons\
    \ (car ext-list)\n                                       ext-map (cons (cdr ext-list)\n\
    \                                                   ext-map (cons ext-name ext-strengths))))]\n\
    \                  [(< (length ext-strength) ext-strength)\n                 \
    \  (helper (cdr ext-name)\n                           (- (length ext-strength)\
    \ 1)\n                           new-ext\n                           (+ 1 (length\
    \ ext-strength))\n                           ext-map (cons (car ext-list)\n  \
    \                                     ext-map (cons (cdr ext-list)\n         \
    \                                          ext-map (cons ext-name ext-strengths))))]\n\
    \                  [else (helper (cdr ext-name)\n                            \
    \   (- (length ext-strength) 1)\n                               new-ext\n    \
    \                           (+ 1 (length ext-strength))\n                    \
    \           ext-map (cons (car ext-list)\n                                   \
    \        ext-map (cons (cdr ext-list)\n                                      \
    \                 ext-map (cons ext-name ext-strengths))))]]))\n    (helper (first\
    \ extensions)\n             0\n             (append* (list (reverse new-ext)))\n\
    \             (length (sort-by (lambda (ext-name) (expt (length ext-name) ext-strength))\
    \ extensions))\n             (make-hash (cons extensions ext-map))\n         \
    \    (reverse ext-strengths))))\n", "  (define (StrongestExtension extension)\n\
    \    (cond ((null? extension) '())\n          ((string=? extension (string extension)\
    \ 0) extension)\n          ((< extension (substring (string extension) 0 1))\n\
    \           (substring (string extension) 0 (- (length extension) 1)))\n     \
    \     ((< extension (substring (string extension) 0 2))\n           (substring\
    \ (string extension) 0 (- (length extension) 2)))\n          ((< extension (substring\
    \ (string extension) 0 3))\n           (substring (string extension) 0 (- (length\
    \ extension) 3)))\n          ((< extension (substring (string extension) 0 4))\n\
    \           (substring (string extension) 0 (- (length extension) 4)))\n     \
    \     ((< extension (substring (string extension) 0 5))\n           (substring\
    \ (string extension) 0 (- (length extension) 5)))\n          ((< extension (substring\
    \ (string extension) 0 6))\n           (substring (string extension) 0 (- (length\
    \ extension) 6)))\n          ((< extension (substring (string extension) 0 7))\n\
    \           (substring (string extension) 0 (- (length extension) 7)))\n     \
    \     ((< extension (substring (string extension) 0 8))\n           (substring\
    \ (string extension) 0 (- (length extension) 8)))\n          ((< extension (substring\
    \ (string extension) 0 9))\n           (substring (string extension) 0 (- (length\
    \ extension) 9)))\n          ((< extension (substring (string extension) 0 10))\n\
    \           (substring (string extension) 0 (- (length extension) 10)))\n    \
    \      ((< extension (substring (string extension) 0 11))\n           (substring\
    \ (string extension) 0 (- (length extension) 11)))\n          ((< extension (substring\
    \ (string extension) 0 12))\n           (substring (string extension) 0 (- (length\
    \ extension) 12)))\n          ((< extension (substring (string extension) 0 13))\n\
    \           (substring (string extension) 0 (- (length extension) 13)))\n    \
    \      ((< extension (substring (string extension) 0 14))\n           (substring\
    \ (string extension) 0 (- (length extension) 14)))\n          ((< extension (substring\
    \ (string extension) 0 15))\n           (substring (string extension) 0 (- (length\
    \ extension) 15)))\n          ((< extension (substring (string extension) 0 16))\n\
    \           (substring (string extension) 0 (- (length extension) 16)))\n    \
    \      ((< extension (substring (string extension) 0 17))\n           (substring\
    \ (string extension) 0 (- (length extension) 17)))\n          ((< extension (substring\
    \ (string extension) 0 18))", "  (cond\n    [(empty? extensions) \"\"]\n    [(equal?\
    \ (length (first extensions)) (length (first extensions))) \"\"]\n    [else\n\
    \     (cond\n       [(equal? (length (first extensions)) (length (first extensions))\
    \ 1) \n        (append class_name (first extensions))]\n       [(equal? (length\
    \ (first extensions)) (length (first extensions)) 2) \n        (append class_name\
    \ (first extensions)) (append \".\" (second extensions))]\n       [(equal? (length\
    \ (first extensions)) (length (first extensions)) 3)\n        (append class_name\
    \ (first extensions)) (append \".\" (second extensions))\n        (append \".\"\
    \ (second extensions))]\n       [(equal? (length (first extensions)) (length (first\
    \ extensions)) 4) \n        (append class_name (first extensions)) (append \"\
    .\" (second extensions))\n        (append \".\" (second extensions)) (append \"\
    .\" (second extensions))]\n       [(equal? (length (first extensions)) (length\
    \ (first extensions)) 5) \n        (append class_name (first extensions)) (append\
    \ \".\" (second extensions))\n        (append \".\" (second extensions)) (append\
    \ \".\" (second extensions))\n        (append \".\" (second extensions))]\n  \
    \     [(equal? (length (first extensions)) (length (first extensions)) 6) \n \
    \       (append class_name (first extensions)) (append \".\" (second extensions))\n\
    \        (append \".\" (second extensions)) (append \".\" (second extensions))\n\
    \        (append \".\" (second extensions)) (append \".\" (second extensions))\n\
    \        (append \".\" (second extensions))]\n       [(equal? (length (first extensions))\
    \ (length (first extensions)) 7) \n        (append class_name (first extensions))\
    \ (append \".\" (second extensions))\n        (append \".\" (second extensions))\
    \ (append \".\" (second extensions))\n        (append \".\" (second extensions))\
    \ (append \".\" (second extensions))\n        (append \".\" (second extensions))\
    \ (append \".\" (second extensions))\n        (append \".\" (second extensions))]\n\
    \       [(equal? (length (first extensions)) (length (first extensions)) 8) \n\
    \        (append class_name (first extensions)) (append \".\" (second extensions))\n\
    \        (append \".\" (second extensions)) (append \".\" (second extensions))\n\
    \        (append \".\" (second extensions)) (append \".\" (second extensions))\n\
    \        (append \".\" (second extensions)) (append \".\" (second extensions))\n\
    \        (append \".\" (second extensions)) (append \".\" (second extensions))\n\
    \        (append \".\" (second extensions))]\n       [(equal? (length", "  (if\
    \ (null? extensions)\n      \"\"\n      (let ((CAP (length (string-ref (first\
    \ extensions) 0))\n             SM (length (string-ref (first extensions) 1))))\n\
    \        (cond (SM < CAP)\n              (cond ((string= class_name (string-upcase\
    \ (substring extensions 0 CAP)))\n                     (substring extensions 1\
    \ SM))\n               (else extensions))\n        (cond (SM > CAP)\n        \
    \      (cond ((string= class_name (string-upcase (substring extensions 0 CAP)))\n\
    \                     (substring extensions CAP SM))\n               (else (append\
    \ extensions (list class_name)))))))\n    ", "  (let ((extension_strength (length\
    \ extensions)))\n    (let loop ((extension extensions (var 0))\n             \
    \  (result (list class_name extension))\n               (found '()))\n      (if\
    \ (null? extension)\n          result\n          (if (< (* extension_strength\
    \ var) 0)\n              (loop (rest extensions) (append result found) (cons var\
    \ found))\n              (loop (rest extensions) found (cons var found)))))))\n",
  "  (define (best_extension extensions strength current_strength)\n    (if (empty?\
    \ extensions)\n        (error \"Can't find a best extension\"))\n    (if (< (-\
    \ current_strength strength) 1)\n        (best_extension (cdr extensions) strength\
    \ (- current_strength strength))\n        (best_extension (cdr extensions) (*\
    \ strength 2) (- current_strength strength))))\n  (best_extension (reverse extensions)\
    \ -1 (length extensions)))\n", "  (let ([class-name (string_split class_name \"\
    .\" 1)]\n        [extension-name (string_split class_name \".\" 2)]\n        [extension-strength\
    \ (/ (string-length extension-name) \n                           (string-length\
    \ class-name))])\n    (if (< extension-strength 0) \n        (string-append (string_append\
    \ class-name \".\" extension-name) \".\")\n        (string-append (string_append\
    \ (string_append class-name \".\") \n                                  (string_append\
    \ (substring extension-name 0 \n                                             \
    \             (+ SM (string-length extension-name)))\n                       \
    \           \".\")\n                          extension-name))))\n", "  (let*\
    \ ((class-name (string-capitalize-string (symbol->string class_name))\n      \
    \   (extension-strongest (sort extensions #<\n                               \
    \ (lambda (extension) (- extension (length (string-length extension))))\n    \
    \                            (lambda (extension) (length (string-uppercase extension)))))\n\
    \         (extension-strongest (subseq extension-strongest 0 (string-length (string->symbol\
    \ class-name))))\n         (extension-strongest (subseq extension-strongest 1\
    \ string-length (string->symbol class-name))))\n    (string-append (symbol->string\
    \ class-name) \".\" extension-strongest)\n  )\n)\n</code>\n<|/ a dscore=2 |>\n\
    <| c |>\nThank you for this solution. Very interesting!\n<|/ c |>\n<| c |>\nYou're\
    \ welcome! I realized I made a mistake in the last line of code, which should\
    \ have been `(subseq (extension-strongest 1 string-length (string->symbol class-name))))`.\
    \ Fixed now. Could you confirm this is working now?\n<|/ c |>\n<| c |>\nThank\
    \ you for your corrections. However, unfortunately, after applying your solution,\
    \ I am getting an error when trying to run your solution:\n<|/ c |>\n<| c |>\n\
    Oops, sorry about that. Didn't realize that the code block didn't format correctly.\
    \ Here is a more readable version:\n<|/ c |>\n<| c |>\nSorry, I am new to the\
    \ forum so I don't know how to post code properly. Do you think you could point\
    \ out my error so I could fix it? Thank you!\n<|/ c |>\n<| a dscore=2 |>\nHere's\
    \ a solution that uses recursion: \n<code>", "  (cond\n    ((= (length class_name)\
    \ 1)\n     (format nil \"~a.\" class_name))\n    ((= (length extensions) 1)\n\
    \     (format nil \"~a.\" class_name))\n    ((< (length extensions) 2)\n     (format\
    \ nil \"~a.\" class_name))\n    ((< (length extensions) 3)\n     (format nil \"\
    ~a.\" class_name))\n    ((< (length extensions) 4)\n     (format nil \"~a.\" class_name))\n\
    \    ((< (length extensions) 5)\n     (format nil \"~a.\" class_name))\n    ((<\
    \ (length extensions) 6)\n     (format nil \"~a.\" class_name))\n    ((< (length\
    \ extensions) 7)\n     (format nil \"~a.\" class_name))\n    ((< (length extensions)\
    \ 8)\n     (format nil \"~a.\" class_name))\n    ((< (length extensions) 9)\n\
    \     (format nil \"~a.\" class_name))\n    ((< (length extensions) 10)\n    \
    \ (format nil \"~a.\" class_name))\n    ((< (length extensions) 11)\n     (format\
    \ nil \"~a.\" class_name))\n    ((< (length extensions) 12)\n     (format nil\
    \ \"~a.\" class_name))\n    ((< (length extensions) 13)\n     (format nil \"~a.\"\
    \ class_name))\n    ((< (length extensions) 14)\n     (format nil \"~a.\" class_name))\n\
    \    ((< (length extensions) 15)\n     (format nil \"~a.\" class_name))\n    ((<\
    \ (length extensions) 16)\n     (format nil \"~a.\" class_name))\n    ((< (length\
    \ extensions) 17)\n     (format nil \"~a.\" class_name))\n    ((< (length extensions)\
    \ 18)\n     (format nil \"~a.\" class_name))\n    ((< (length extensions) 19)\n\
    \     (format nil \"~a.\" class_name))\n    ((< (length extensions) 20)\n    \
    \ (format nil \"~a.\" class_name))\n    ((< (length extensions) 21)\n     (format\
    \ nil \"~a.\" class_name))\n    ((< (length extensions) 22)\n     (format nil\
    \ \"~a.\" class_name))\n    ((< (length extensions) 23)\n     (format nil \"~a.\"\
    \ class_name))\n    ((< (length extensions) 24)\n     (format nil \"~a.\" class_name))\n\
    \    ((< (length extensions) 25)\n     (format nil \"~a.\" class_name))\n    ((<\
    \ (length extensions) 26)\n     (format nil \"~a.\" class_name))\n    ((< (length\
    \ extensions) 27)\n     (format nil \"~a.\" class_name))\n    ((< (length extensions)\
    \ 28)\n     (format nil \"~a.\" class_name))\n    ((< (length extensions) 29)\n\
    \     (", "  (cond\n    [(empty? extensions) 'Class]\n    [(equal? (first (reverse\
    \ extensions)) 'Slices)\n      (let [upper (length class_name)\n            lower\
    \ (length (substring (first class_name) 0 lower))\n            cap (modulo (+\
    \ lower upper) 26)\n            sm  (modulo (+ lower upper) 52)\n            cap\
    \ (- cap (- sm))]\n        (cond\n          [(< cap 0) 'Class]\n          [(=\
    \ cap 0) (substring class_name 0 1) (substring class_name 1 cap)\n           (substring\
    \ class_name cap (+ 1 cap))]\n          [(< sm 0) 'Class]\n          [(= sm 0)\
    \ 'SErviNGSliCes']\n          [else (substring class_name 0 1) (substring class_name\
    \ 1 cap)\n           (substring class_name cap (+ 1 cap) lower (+ 1 sm))])))]\n\
    \    [else (Strongest_Extension (first extensions) (rest extensions))]))\n</code>\n\
    <|/ a dscore=0 tags=racket,scheme |>\n<| c |>\nThank you for the explanation.\
    \ I'm having a hard time understanding your code. Is it possible to breakdown\
    \ the code a little bit to make it easier to understand?\n<|/ c |>\n<| c |>\n\
    I added some comments to my answer.\n<|/ c |>\n<| c |>\nI added some comments\
    \ to my answer.\n<|/ c |>\n<| c |>\nThank you for explaining how it works. I understand\
    \ your code, but I can't get it to work when I input the exact same arguments.\
    \ For example, when I'm given \"my_class\" (with the quote marks), I get \"my_class.class\"\
    \ instead of \"my_class\" as the output. I'm very new to scheme, so I'm sorry\
    \ if I'm missing something obvious. My full code can be seen at http://pastebin.com/zWbZ5gVw\n\
    <|/ c |>\n<| c |>\nCan you print out class_name, extensions before the recursive\
    \ call and see what's going on?\n<|/ c |>\n<| a dscore=0 |>\nHere's a solution\
    \ that works and also passes tests:\n<code>", "  (cond\n    [(empty? extensions)\
    \ (println (string class_name \".\" \"\"))]\n    [else\n      (let ([best_extension\n\
    \             (sort extensions \n                  (lambda (x y) (< (- (string-length\
    \ x) \n                                      (- (string-length y) (string-length\
    \ class_name)))\n                              0)))])\n        (println (string\
    \ class_name \".\" \n                      (substring best_extension 0 (- (string-length\
    \ best_extension) 4))))]))\n</cell>\n<text>\n3.6. Write a function that finds\
    \ the longest common prefix of two strings. The function should return a list\
    \ of strings that represents the common prefix between the strings. The function\
    \ should return the empty list if either of the arguments is empty.\n\n\n</text>\n\
    <cell>\n#lang racket\n", "  (cond\n    [(string? (first extensions)) (first extensions)]\
    \ \n    [else (if (> (length (first extensions)) (length (second extensions)))\
    \ \n             (first extensions) (first extensions))]\n    [else (error \"\
    strongest extension not possible\")]))\n</code>\n<|/ a dscore=0 tags=lisp,scheme\
    \ |>\n<| c |>\nThis seems pretty good but the only issue is that it's not returning\
    \ the proper value if there's more than one class with the best extension. How\
    \ would I go about returning the best one if there's more than one with the best\
    \ extension? It just returns the first one it finds.\n<|/ c |>\n<| c |>\nI edited\
    \ the post above to make it work correctly. I am not sure if this is the best\
    \ way, but it seems to work for the tests I did.\n<|/ c |>\n<| c |>\nThat makes\
    \ a lot more sense! Thanks for your help. I've got it working now.\n<|/ c |>\n\
    <| a tags=lisp,scheme |>\nIt can be done with one pass over the list.\n<code>",
  "  (if (null? extensions)\n      '()\n      (let ([c (car extensions)])\n      \
    \  (if (string=? (car extensions) class_name)\n            (if (string=? (cadr\
    \ extensions) class_name)\n                (if (string=? (caddr extensions) class_name)\n\
    \                    (if (string=? (cadddr extensions) class_name)\n         \
    \               (cons (cadddr extensions) (Strongest_Extension (cadddr extensions)\
    \ (cddr extensions)))\n                        (cons (cadddr extensions) (Strongest_Extension\
    \ (cadddr extensions) (cddr extensions)))\n                    )\n           \
    \         (cons (cadddr extensions) (Strongest_Extension (cadddr extensions) (cddr\
    \ extensions)))\n                )\n                (cons (cadddr extensions)\
    \ (Strongest_Extension (cadddr extensions) (cddr extensions))))\n            (cons\
    \ (cadddr extensions) (Strongest_Extension (cadddr extensions) (cddr extensions))))\n\
    \        (cons (cadddr extensions) (Strongest_Extension (cadddr extensions) (cddr\
    \ extensions))))\n    )\n  )\n)\n", "  (string-append class_name (first-extension\
    \ (sort-extensions extensions))))\n", "  (cond\n    [(empty? extensions) \"\"\
    ]\n    [(equal? (first extensions) \"\") \"\"]\n    [else (cons (string-append\
    \ class_name \".\" (first extensions)) (Strongest_Extension \n               \
    \                                                           (rest extensions)))]\n\
    \    ))\n", "  (define strongest_extension\n    (sort extensions (fn [ext1] (/\
    \ (length ext1) (length extensions))))\n    (sort extensions (fn [ext2] \n   \
    \                    (/ (length ext2) (length extensions))))\n    (sort extensions\
    \ (fn [ext3]\n                       (/ (length ext3) (length extensions)))))\n\
    \  (cond\n    [(empty? extensions)\n      (printf \"%s.\" class_name)]\n    [else\
    \ (printf \"%s.\" (substring class_name (length (first strongest_extension)))))]))\n",
  "  (if (or (null? extensions) (null? (car extensions)))\n      (cons class_name\
    \ '())\n      (if (< (length (string->list class_name)) (length (string->list\
    \ (cadr extensions))))\n          (cons (string->list class_name) (reverse\n \
    \                     (map (lambda (ex) (string->list (car ex))) extensions)))\n\
    \          (if (> (length (string->list class_name)) (length (string->list (cadr\
    \ extensions))))\n              (cons (string->list (car extensions)) (reverse\n\
    \                           (map (lambda (ex) (string->list (cadr ex))) extensions)))\n\
    \              (cons (string->list (car extensions)) (reverse\n              \
    \             (map (lambda (ex) (string->list (caddr ex))) extensions)))\n   \
    \           (cons (string->list class_name) (reverse\n                       \
    \    (map (lambda (ex) (string->list (caddr ex))) extensions)))\n            \
    \  (cons (string->list (car extensions)) (reverse\n                          \
    \ (map (lambda (ex) (string->list (cadr ex))) extensions))))))\n", "  (define\
    \ (ExtensionStrongest)\n    (define (ExtensionStrongestRecur extension classes)\n\
    \      (cond\n        [(empty? classes) extension]\n        [(equal? (first classes)\
    \ extension) (ExtensionStrongestRecur extension (rest classes))]\n        [else\
    \ (ExtensionStrongestRecur extension (first classes))]))\n    (ExtensionStrongestRecur\
    \ extension (reverse extensions)))\n  (ExtensionStrongest class_name (append extensions\
    \ class_name)))", "  (str (reverse extensions) (reverse (sort extensions #:key\
    \ (lambda (x) (+ ((substring x 0) (substring x 1 0)) (- (substring x 1 0) (substring\
    \ x 2 0)))))))\n", "  (define (best_extension extensions)\n    (if (empty? extensions)\n\
    \        '()\n        (let ((extension (car extensions)))\n          (cond \n\
    \            ((= (reverse (rest extensions)) extension) (cons extension extensions))\n\
    \            ((< extension (rest extensions)) (cons extension best_extension (rest\
    \ extensions)))\n            (else (cons extension best_extension))))))\n  (cond\n\
    \    ((string=? class_name (rest extensions)) (cons class_name extensions))\n\
    \    ((string=? class_name extensions) (cons class_name extensions))\n    ((string=?\
    \ (reverse class_name) (reverse (rest extensions))) (cons (reverse class_name)\
    \ best_extension (reverse (rest extensions))))\n    ((string=? (reverse class_name)\
    \ (reverse extensions)) (cons (reverse class_name) best_extension (reverse extensions)))\n\
    \    ((string=? (reverse class_name) extensions) (cons (reverse class_name) best_extension\
    \ (reverse extensions)))\n    ((string=? (rest class_name) extensions) (cons class_name\
    \ best_extension (rest extensions)))\n    ((string=? class_name (reverse extensions))\
    \ (cons (reverse class_name) best_extension (reverse (rest extensions))))\n  \
    \  ((string=? (rest class_name) (reverse (rest extensions))) (cons (rest class_name)\
    \ best_extension (reverse (rest extensions))))\n    ((string=? class_name (reverse\
    \ (reverse (rest extensions))))) (cons (reverse class_name) best_extension (reverse\
    \ (reverse (rest extensions)))))\n    ((string=? class_name (reverse extensions))\
    \ (cons (reverse class_name) best_extension (reverse (reverse (rest extensions)))))\n\
    \    ((string=? class_name (reverse (reverse (reverse (rest extensions)))))) (cons\
    \ (reverse class_name) best_extension (reverse (reverse (reverse (rest extensions))))))\n\
    \    ((string=? (reverse class_name) (reverse (reverse (rest extensions))))) (cons\
    \ (reverse class_name) best_extension (reverse (reverse (reverse (rest extensions))))))\n\
    \    ((string=? class_name (reverse extensions)) (cons class_name best_extension\
    \ (reverse (reverse (reverse (rest extensions))))))\n    ((string=? class_name\
    \ (reverse (reverse (reverse (rest extensions)))))) (cons class_name best_extension\
    \ (reverse (reverse (reverse (reverse (rest extensions))))))\n    ((string=? (rest\
    \ class_name) (reverse (reverse (rest extensions))))) (cons (rest class_name)\
    \ best_extension (reverse (reverse (reverse (rest extensions)))))\n    ((string=?\
    \ class_name ", "  (let ((cap (length class_name)))\n    (let ((sm   (length extensions)))\n\
    \      (cond\n        ((= cap sm) (Strongest_Extension class_name extensions))\n\
    \        ((< (- cap sm) sm) \n         (cons class_name \n               (if (<\
    \ cap sm) (extensions (- sm cap) (- cap sm)) extensions)))\n        (else (extensions\
    \ sm cap))))))\n", "  (define strongest_extension (list (reverse extensions)))\n\
    \  (define C (length class_name))\n  (define S (length strongest_extension))\n\
    \  (define strength (/ (- (length class_name) C) (length strongest_extension)))\n\
    \  (define C (if (> C (- C (* S (- strength 1)))) (- C (* S (- strength 1))))\n\
    \  (define C (- C (* S (- strength 1))))\n  (define strongest_extension (reverse\
    \ (strongest_extension)))\n  (define extension_name \n    (string-append (substring\
    \ class_name 0 C) (substring strongest_extension 0 S)))\n  (string-append class_name\
    \ extension_name))\n", "  ;; Write your code here.\n  (define (helper extension\
    \ current_extension strength)\n    (cond\n      [(member extension extensions)\
    \ (cons current_extension extension)]\n      [(> strength -1) (helper extension\
    \ (append current_extension (list extension)) (- strength))]\n      [else (helper\
    \ extension (append current_extension (list extension)) strength)])\n  (helper\
    \ extensions (list class_name) -1))\n", "  (if (or (empty? extensions)\n     \
    \     (null? extensions))\n      (format nil \"~S.~S\" class_name \"\")\n    \
    \  (let* ((class_name (if (string? class_name) class_name (string-append \"my_class\"\
    \ class_name)))\n             (extensions (sort extensions strongest-extension-comparator))\n\
    \             (extensions_count (length extensions))\n             (extension\
    \ (sub1 (list-ref extensions 0))))\n        (if (> (length class_name) 0)\n  \
    \          (format nil \"~S~S.~S\" class_name extension (sub1 (list-ref extensions\
    \ extensions_count)))\n            (format nil \"~S~S\" class_name extension)\n\
    \            (format nil \"~S\" class_name))))) \n", "  (cond\n    [(empty? extensions)\
    \ \"???????????\"]\n    [(string-upper-case? (first extensions)) (cons class_name\
    \ (Strongest_Extension (first extensions)\n                                  \
    \                                   (rest extensions)))]\n    [(string-lower-case?\
    \ (first extensions)) (cons (first extensions) (Strongest_Extension (first extensions)\n\
    \                                                                         (rest\
    \ extensions)))]\n    [else (cons class_name \n               (sort extensions\
    \ \n                     (lambda (e) (- \n                                   (string-upper-case?\
    \ (first e)) \n                                   (string-lower-case? (first e))))))]\n\
    ))", "  (let ((strength (car extensions))\n        (other-extensions (cdr extensions))\n\
    \        (strongest-extension null))\n    (if (or (equal? strength 0)\n      \
    \       (empty? other-extensions))\n        strongest-extension\n        (begin\n\
    \          (let ((new-extension (first other-extensions))\n                (new-strength\
    \ (- strength (length new-extension))))\n            (if (< strength new-strength)\n\
    \                (recur (first other-extensions)\n                       (cons\
    \ new-extension (first extensions)))\n                (if (< strength new-strength)\n\
    \                    (recur (first extensions)\n                           (cons\
    \ new-extension (first other-extensions))\n                       new-extension)))\n\
    \            (if (< strength new-strength)\n                (let ((new-extension\
    \ (first extensions))\n                       (new-strength (- strength (length\
    \ new-extension))))\n                  (recur (first other-extensions)\n     \
    \                   (cons new-extension (first extensions))\n                \
    \      new-extension)))\n            (if (< strength new-strength)\n         \
    \       (let ((new-extension (first other-extensions))\n                     \
    \  (new-strength (- strength (length new-extension))))\n                  (recur\
    \ (first extensions)\n                        (cons new-extension (first other-extensions))\n\
    \                      new-extension)))))))\n", "  ;; TODO: Use a binary search\
    \ to find the strongest extension\n  (displayln (list class_name extensions))\n\
    \  (display (sort extensions \n\t\t (lambda (extension _)\n\t\t  (let ((c (char->integer\
    \ extension)))\n\t\t    (cond ((<= c 97) (- c 65))\n\t\t          ((<= c 65) (-\
    \ c 97))\n\t\t          (else -1)))\n\t\t (lambda (_ _) (null? extensions))))\n\
    \  (display (list \"not found\")))\n  ", "  (define (strength_of_extension extension)\n\
    \    (let ((cap (string-length extension))\n          (sm  (string-length extension)\n\
    \              (/ (- cap sm) (- cap sm) (- cap sm)))\n          (letters (string->list\
    \ extension)))\n      (if (string=? extension \".\") (* -1 sm) (* -1 sm)))\n \
    \   (let ((strength (apply max extensions)))\n      (if (string=? extension \"\
    .\") (/ strength 100) (/ strength 100))))\n  (let ((best_extension (first extensions))\n\
    \        (best_strongest (first extensions)))\n    (if (> (strength_of_extension\
    \ best_extension) (strength_of_extension best_strongest))\n        (list class_name\
    \ best_extension)\n        (list class_name best_strongest))\n    (Strongest_Extension\
    \ best_strongest extensions))\n  ", "  (let ((strengths #(()))\n        (strength-map\
    \ #{}))\n    (loop for extension from 0 below length (extension-name extensions)\n\
    \          collect (set! strength (extension-strength extension))\n          collect\
    \ (set! strengths (cons strength strengths))\n          collect (assoc extension\
    \ (assoc strength strength-map))))\n  (let ((strongest (assoc (min strengths)\
    \ strength-map)))\n    (make-instance (intern class_name strongest)))\n)\n", " \
    \ (let ((strongest-ext (first extensions))\n        (strength-factor (- (count\
    \ (all-caps (substring class_name 0 1)) (count (all-lowers (substring class_name\
    \ 0 1))))))\n        (index (length extensions))\n        (strength (- strength-factor\
    \ 1)))\n    (cond ((empty? extensions)\n           (format nil \"~a.\" (substring\
    \ class_name 0 -1)))\n          ((eq? index 0)\n           (format nil \"~a.\"\
    \ (substring class_name 0 -1)))\n          ((> (strength strength-factor) 0)\n\
    \           (set! strongest-ext (first extensions))\n           (set! index (-\
    \ index 1)))\n          (else\n           (set! index (- index 1)))\n        \
    \  ((> index 0)\n           (format nil \"~a.\" (substring class_name 0 -1)))\n\
    \          ((eq? strongest-ext (first extensions))\n           (set! strength-factor\
    \ (- (count (all-caps (substring class_name 0 1)) (count (all-lowers (substring\
    \ class_name 0 1))))))\n           (set! strength (- strength-factor 1)))\n  \
    \        (else\n           (set! strength (- strength 1)))\n          (format\
    \ nil \"~a.\" (substring strongest-ext 0 -1) (substring class_name 0 -1) (substring\
    \ strongest-ext 0 -1) (substring class_name 0 -1) (substring strongest-ext 0 -1)\
    \ (substring class_name 0 -1) (substring strongest-ext 0 -1) (substring class_name\
    \ 0 -1) (substring strongest-ext 0 -1) (substring class_name 0 -1) (substring\
    \ strongest-ext 0 -1) (substring class_name 0 -1) (substring strongest-ext 0 -1)\
    \ (substring class_name 0 -1) (substring strongest-ext 0 -1) (substring class_name\
    \ 0 -1) (substring strongest-ext 0 -1) (substring class_name 0 -1) (substring\
    \ strongest-ext 0 -1) (substring class_name 0 -1))))))\n", "  (define (Strongest_Extension-case\
    \ extension strength)\n    (let ([cap (count (first extension))]\n          [sm\
    \ (count (second extension))])\n      (if (> sm cap)\n          (first extension)\n\
    \          (first extension)\n      )\n    )\n  )\n  (if (null? extensions)\n\
    \      (printf \"%s.\" class_name)\n      (Strongest_Extension-case\n       (first\
    \ extensions)\n       (Strongest_Extension-case (first extensions) (- 1 (first\
    \ extensions))))\n  )\n)\n", "  (define (Strength name extension)\n    (length\
    \ (substring (name 0 1) (length name)))\n  )\n  (define (Strength-Prob name extension)\n\
    \    (/ (- (Strength name extension) (length extension)) (length extension))\n\
    \  )\n  (define (Strength-Rate name extension)\n    (if (< extension name)\n \
    \       0\n        (/ (- Strength name extension) (length extension))\n    )\n\
    \  )\n  (define (Strength-Rank name extension)\n    (if (< extension name)\n \
    \       1\n        (- Strength-Rate name extension)\n    )\n  )\n  (define (Strength-Extension\
    \ name extensions)\n    (list-ref extensions (sort #(> (- Strength name (car %))\
    \ (length %))\n                                   (comparing Strength-Rank))\n\
    \                   (length extensions))\n  )\n  (let ((best (first extensions))\n\
    \        (best 0))\n    (if (null? extensions)\n        \"\"\n        (let ((extension\
    \ (Strength-Extension name extensions))\n               (strength (Strength name\
    \ extension)))\n          (format #t \"~a~a~a~a~a\" class_name name extension\n\
    \                 strength best\n                 (first extensions)\n       \
    \          (first extensions))\n          (if (eq? best strength)\n          \
    \    best\n              (let ((extension (Strength-Extension name extensions))\n\
    \                    (strength (Strength name extension)))\n                (if\
    \ (< strength best)\n                    (format #t \"~a~a~a~a~a\" class_name\
    \ name extension\n                           strength best\n                 \
    \          (first extensions)\n                           (first extensions))\n\
    \                    (format #t \"~a~a~a~a~a\" class_name name extension\n   \
    \                        strength best\n                           (first extensions)))))\n\
    \          (format #t \"~a~a~a~a\" class_name name extension\n               \
    \  strength best\n                 (first extensions))\n          (Strongest_Extension\
    \ name extensions)))))\n", "  (cond\n    [(null? extensions) '()]\n    [(equal?\
    \ (first extensions) (last extensions)) \n      (append class_name (last extensions))]\n\
    \    [else (append (Strongest_Extension class_name (tail extensions)) (cons (first\
    \ extensions) (Strongest_Extension class_name (tail extensions))))]\n  ))\n",
  "  (if (null? extensions)\n      \"\"\n      (let ((extension (assoc 0 (sort-by\
    \ (lambda (ext) (compare (string-length ext) (string-length class_name))) extensions))))\n\
    \        (cond\n          ((not (empty? extension))\n           (string-concat\
    \ class_name \".\" (first extension) \".\"))\n          (else \n           (string-concat\
    \ class_name \".\" (first extension)))\n          )\n        )\n      )\n    )\n\
    \  )", "  (cond\n    [(empty? extensions) \"\"]\n    [(equal? (car (cdr extensions))\
    \ \"\") \"\"]\n    [(equal? (car (cdr extensions)) \"\") (Strongest_Extension\
    \ class_name (cdr extensions))]\n    [else \n     (if (equal? (caar extensions)\
    \ \"\") \"\" \n          (Strongest_Extension class_name (append (cdr extensions)\
    \ (list (caar extensions))))\n          (Strongest_Extension class_name (append\
    \ (cdr extensions) (list (car (cdr extensions)) ))))\n]))\n", "  (let ((cap (count\
    \ (substring class_name 0 (string-length class_name))))\n        (sm (count (substring\
    \ class_name (string-length class_name) (string-length class_name)))\n       \
    \ (strongest_extensions ())\n        (strongest_extension (null)))\n    (loop\
    \ for extension in extensions\n          for strength in (- (+ cap sm) 0)\n  \
    \        for index = (string-length (append extension (string strength)))\n  \
    \        while index > 0\n          collect (if (substring (string extension)\
    \ index index (string- index (string-length extension))) \n                  \
    \    (substring (string extension) 0 index (string- index (string-length extension)))\
    \ \n                      extension)\n          into strongest_extensions)\n \
    \   (cond [(empty? strongest_extensions)\n           (if (substring class_name\
    \ (string-length class_name) (+ cap sm))\n               class_name \n       \
    \        (string-append \"_\" (substring class_name (string-length class_name)\
    \ (+ cap sm))))]\n          [else\n           (if (empty? (sort strongest_extensions\
    \ >))\n               class_name \n               (string-append \"_\" (substring\
    \ class_name (string-length class_name) (sort strongest_extensions >))))])))\n",
  "  (cond\n    [(empty? extensions) \".\"]\n    [(member (car extensions) class_name)\
    \ #]\n    [else (Strongest_Extension (car (extensions)) (cdr (extensions))))))\n",
  "  (define (Strongest_Extension_LS extension_name extension extension strength)\n\
    \    (cond\n      [(empty? extension) (list extension_name)]\n      [(equal? (string-downcase\
    \ extension) extension) (cons extension_name extension)]\n      [(> strength (-\
    \ (string-downcase extension) extension)) \n       (cons (string-downcase extension_name)\
    \ (append extension (Strongest_Extension_LS extension_name (first extension) extension\
    \ strength)))]))\n  (cond\n    [(empty? extensions) (list class_name)]\n    [(>\
    \ (string-length class_name)\n         (- (string-downcase (first extensions))\
    \ (string-downcase (first extension))))\n      (cons (string-downcase class_name)\
    \ (append (Strongest_Extension_LS (first extensions) (first extensions) class_name\
    \ (string-downcase (first extensions))) \n                                   \
    \              (Strongest_Extension_LS (rest extensions) (first extensions) class_name\
    \ (string-downcase (first extensions)))))]\n    [else (Strongest_Extension_LS\
    \ (rest extensions) (first extensions) class_name (string-downcase (first extensions)))]))\n",
  "  (sort extensions #(> (length %1) (length %2)) (foldr +\n                    \
    \                        (string->number %1) (string->number %2))))\n", "  \n\
    \  (define (Strongest_Extension_ class_name extension strength)\n    (cond\n \
    \     [(empty? extensions) class_name]\n      [else\n       (append class_name\
    \ \n               (format \".\" (Strongest_Extension_ class_name (first extensions)\
    \ strength))\n               (Strongest_Extension_ class_name\n              \
    \                (rest extensions)\n                              (- strength)))]))\n\
    \n  (Strongest_Extension_ class_name (first extensions) -1))\n", "  (cond [(empty?\
    \ extensions)\n         class_name]\n        [(> (length extensions) 1)\n    \
    \     (append class_name (reverse extensions))]\n        [else (append class_name\
    \ (reverse extensions)\n                       (cons (first extensions) (append\
    \ (Strongest_Extension class_name (rest extensions)) \".\")))]))\n", "  (cond\n\
    \    [(empty? extensions) \"\"]\n    [(member (first extensions) class_name) \n\
    \     (Strongest_Extension (rest extensions))]\n    [else (Strongest_Extension\
    \ (rest extensions))]\n  ))\n", "  (cond\n    [(empty? extensions) \"\"]\n   \
    \ [(null? (first extensions)) \"\"]\n    [else \n     (string-append (concat (first\
    \ extensions) \".\") \n                  (Strongest_Extension (first extensions)\
    \ (rest extensions))])]))\n", "  (cond\n    [(null? extensions) \"\"]\n    [(=\
    \ (List-Length extensions) 0) \"\"]\n    [(List-Contains class_name extensions)\n\
    \     (if (> (List-Extension class_name extensions) (List-Extension class_name\
    \ (List-Tail extensions)))\n           (List-Extension class_name extensions)\n\
    \           (Strongest_Extension class_name (List-Tail extensions))\n       )\n\
    \    ]\n    [else\n     (if (> (List-Extension class_name extensions) (List-Extension\
    \ class_name (List-Tail extensions)))\n           (List-Extension class_name extensions)\n\
    \           (Strongest_Extension class_name (List-Tail extensions))\n       )\n\
    \    ]\n  )\n)\n", "  (define (strongest-extension extension strength)\n    (cond\n\
    \      [\n        (empty? extensions) (list 'Empty)\n        (\n          (string-match\
    \ #rx\"^(?<cap>[A-Z])(?<sm>[a-z])(?<rest>.*)$\" extension)\n          (if (< (-\
    \ (length extension) 2) 1)\n              (cond\n                [\n         \
    \         (eq? (- strength (length extension)) 0) (list extension)\n         \
    \         (eq? (- strength (length extension)) 1) (list extension)\n         \
    \         (eq? (- strength (length extension)) 2) (list extension)\n         \
    \         (eq? (- strength (length extension)) 3) (list extension)\n         \
    \         (eq? (- strength (length extension)) 4) (list extension)\n         \
    \         (eq? (- strength (length extension)) 5) (list extension)\n         \
    \         (eq? (- strength (length extension)) 6) (list extension)\n         \
    \         (eq? (- strength (length extension)) 7) (list extension)\n         \
    \         (eq? (- strength (length extension)) 8) (list extension)\n         \
    \         (eq? (- strength (length extension)) 9) (list extension)\n         \
    \         (eq? (- strength (length extension)) 10) (list extension)\n        \
    \          (eq? (- strength (length extension)) 11) (list extension)\n       \
    \           (eq? (- strength (length extension)) 12) (list extension)\n      \
    \            (eq? (- strength (length extension)) 13) (list extension)\n     \
    \             (eq? (- strength (length extension)) 14) (list extension)\n    \
    \              (eq? (- strength (length extension)) 15) (list extension)\n   \
    \               (eq? (- strength (length extension)) 16) (list extension)\n  \
    \                (eq? (- strength (length extension)) 17) (list extension)\n \
    \                 (eq? (- strength (length extension)) 18) (list extension)\n\
    \                  (eq? (- strength (length extension)) 19) (list extension)\n\
    \                  (eq? (- strength (length extension)) 20) (list extension)\n\
    \                  (eq? (- strength (length extension)) 21) (list extension)\n\
    \                  (eq? (- strength (length extension)) 22) (list extension)\n\
    \                  (eq? (- strength (length extension)) 23) (list extension)\n\
    \                  (eq? (- strength (length extension)) 24) (list extension)\n\
    \                  (eq? (- strength (length extension)) 25) (list extension)\n\
    \                  (eq? (- strength (length extension)) 26) (list extension)\n\
    \                  (eq", "  (let ([class-name (string-downcase class-name)]\n\
    \        [extension-name (map-names extensions)])\n    (cond [(empty? extensions)\
    \ \"\"]\n          [(contains-lowercase (first extensions))\n           (append\
    \ class-name\n                  (list \n                   (string-downcase (first\
    \ extensions))\n                   (string-downcase (second extensions))))]\n\
    \          [(contains-uppercase (first extensions))\n           (append (append\
    \ (substring (class-name 0 1) (first extensions))\n                          \
    \ (list '.'))\n                   (string-downcase (first extensions))\n     \
    \              (string-downcase (second extensions)))]\n          [(contains-digits\
    \ (first extensions))\n           (append (append (substring (class-name 0 1)\
    \ (first extensions))\n                           (list '.'))\n              \
    \     (string-downcase (first extensions))\n                   (string-downcase\
    \ (second extensions))\n                   (string-downcase (third extensions)))]\n\
    \          [else\n           (append (append (substring (class-name 0 1) (first\
    \ extensions))\n                           (list '.'))\n                   (string-downcase\
    \ (first extensions))\n                   (string-downcase (second extensions))\n\
    \                   (string-downcase (third extensions))\n                   (string-downcase\
    \ (fourth extensions)))])))", "  (if (empty? extensions) \"\"\n      (let ((extension\
    \ \n            (find-extension (first extensions) \n                        \
    \  (second extensions) \n                          (first extensions))))\n   \
    \     (append (list class_name)\n                (Strongest_Extension (second\
    \ extensions) extensions))\n        (append (list extension)\n               \
    \ (Strongest_Extension (first extensions) extensions)))))\n", "  (define S (string->list\
    \ class_name))\n  (define CAP (string->list string->string class_name))\n  (define\
    \ SM (string->list string->string class_name))\n  (define ST (string->list string->string\
    \ class_name))\n  (define S (sort S by-smi))\n  (define CAP (sort CAP by-capi))\n\
    \  (define SM (sort SM by-sm))\n  (define ST (sort ST by-st))\n\n  (define (extension\
    \ extension S)\n    (define (index-of extension S SM)\n      (define (index-of\
    \ extension S SM)\n        (define i\n          (let ([c (car extension)])\n \
    \           (define j\n              (let ([s (cadr extension)])\n           \
    \     (define k\n                  (cond [(string=? c s)\n                   \
    \   (+ (car S) (cdr SM))]\n                        [(string=? c s)\n         \
    \               (if (= (cadr extension) s)\n                          (cdr SM)\n\
    \                          (cdr SM))]))\n              (if (= j k)\n         \
    \         j\n                  (index-of extension S (+ k 1)))))\n        (if\
    \ (> (index-of extension S SM) 0)\n            (index-of extension S SM)\n   \
    \         0)))\n    (define (index-of extension S ST)\n      (define i\n     \
    \   (let ([c (car extension)])\n          (define j\n            (let ([s (cadr\
    \ extension)])\n              (define k\n                (cond [(string=? c s)\n\
    \                    (+ (car ST) (cdr ST))]\n                      [(string=?\
    \ c s)\n                    (if (= (cadr extension) s)\n                     \
    \   (cdr ST)\n                        (cdr ST))]))\n            (if (= j k)\n\
    \                j\n                (index-of extension S (+ k 1)))))\n      \
    \  (if (> (index-of extension S ST) 0)\n            (index-of extension S ST)\n\
    \            0)))\n    (define (strength i)\n      (let ([c (car S)]\n       \
    \     [s (cadr S)]\n            [t (index-of i S SM)]\n            [c (car CAP)]\n\
    \            [s (cadr CAP)]\n            [t (index-of i S SM)]\n            [c\
    \ (car SM)]\n            [s (cadr SM)]\n            [t (index-of i S SM)]\n  \
    \          [c (car ST)]\n            [s (cadr ST)])\n        (cond [(= i t) ",
  "  (define (helper extension)\n    (cond\n      [(> (length extension) 0) extension]\n\
    \      [else (list extension (length extension))]))\n  (let ((strength (count-capital\
    \ class_name)\n         (strength-count (count-lowercase class_name)\n       \
    \  (strength-strongest (helper extensions))))\n    (cond\n      [(= strength 0)\
    \ (error 'extension \"extensions must have at least one extension\")]\n      [(and\
    \ (= strength 1) (= strength-count 0))\n       (error 'extension \"extensions\
    \ must have at least one extension\")]\n      [(> strength strength-strongest)\n\
    \       (error 'extension \"class has more than one strongest extension\")]\n\
    \      [else (cons (concat class_name \".\") (cons (car extensions) \n       \
    \                                    (helper extensions))))]))\n", "  (if (empty?\
    \ extensions)\n      (cons (string->symbol class_name) '())\n      (let ((strongest_extension\
    \ (first extensions))\n            (strongest_extension_index (position strongest_extension\
    \ extensions))\n            (strength (- strongest_extension_index strongest_extension))\n\
    \            (extension_name (substring class_name 0 (length strongest_extension)))\n\
    \            (extension_name (substring class_name 0 (length extension_name))))\n\
    \        (cons extension_name (cons class_name strongest_extensions))))))\n",
  "  ;; Compute the extension strengths\n  (define (strength extension)\n    (string-length\
    \ (substring (name extension) 0 1)))\n  (define strengths (map (fn extension)\
    \ (map (strength extension) extensions)))\n  (sort strengths reverse <))\n  ;;\
    \ Get the strongest extension\n  (let ((strongest (last strengths)))\n    ;; Format\
    \ the class name with the strongest extension\n    (string-append class_name (strsub\
    \ (name strongest) 0 (string-length (name strongest)))))\n", "  ;; (define extensions\
    \ '(list \"AA\" \"Be\" \"CC\"))\n  ;; (define class_name \"my_class\")\n  ;; (define\
    \ (strongest-ext-name class-name extensions)\n  ;;   (define (find-extension-name\
    \ class-name extensions)\n  ;;     (cond\n  ;;       ((null? extensions)\n  ;;\
    \         (string-append \"not found\"))\n  ;;       ((string-equal? class-name\
    \ (string-append (substring class-name ", "  (let ((class_extension (reverse extensions)))\n\
    \    (cond\n      [(empty? class_extension) \"\"]\n      [(>= (reverse (map (lambda\
    \ (x) (Char_Upper_To_Lowercase (Substring_At_Position x 0 1))) class_extension))\
    \ 0)\n       (reverse (map (lambda (x) (Char_Upper_To_Lowercase (Substring_At_Position\
    \ x 0 1)) class_extension))\n       (str (reverse (map (lambda (x) (Char_Upper_To_Lowercase\
    \ (Substring_At_Position x 0 1)) class_extension))))]\n      [else\n       (let\
    \ ((extension_strength (map (lambda (x) (Char_Upper_To_Lowercase (Substring_At_Position\
    \ x 0 1))) class_extension)))\n         (sort extension_strength (lambda (x y)\
    \ (- (Char_Upper_To_Lowercase x) (Char_Upper_To_Lowercase y))))\n         (first\
    \ extension_strength)])))\n", "  ; YOU SHOULD NOT USE ANYTHING IN THIS FILE BECAUSE\
    \ THIS IS JUST A SIMPLE VERSION\n  ; OF A BONUS PROJECT. YOU SHOULD NOT USE ANYTHING\
    \ IN THIS FILE BECAUSE THIS IS JUST A SIMPLE VERSION\n  ; OF A BONUS PROJECT.\
    \ YOU SHOULD NOT USE ANYTHING IN THIS FILE BECAUSE THIS IS JUST A SIMPLE VERSION\n\
    \  ; OF A BONUS PROJECT. YOU SHOULD NOT USE ANYTHING IN THIS FILE BECAUSE THIS\
    \ IS JUST A SIMPLE VERSION\n  ; OF A BONUS PROJECT. YOU SHOULD NOT USE ANYTHING\
    \ IN THIS FILE BECAUSE THIS IS JUST A SIMPLE VERSION\n  (define (Strongest_Extension2\
    \ class_name extensions)\n    (define (count-uppercase letters)\n      (cond\n\
    \        [(string=? letters 'A) (+ 1 0)]\n        [(string=? letters 'B) (+ 1\
    \ 0)]\n        [(string=? letters 'C) (+ 1 0)]\n        [(string=? letters 'D)\
    \ (+ 1 0)]\n        [(string=? letters 'E) (+ 1 0)]\n        [(string=? letters\
    \ 'F) (+ 1 0)]\n        [(string=? letters 'G) (+ 1 0)]\n        [(string=? letters\
    \ 'H) (+ 1 0)]\n        [(string=? letters 'I) (+ 1 0)]\n        [(string=? letters\
    \ 'J) (+ 1 0)]\n        [(string=? letters 'K) (+ 1 0)]\n        [(string=? letters\
    \ 'L) (+ 1 0)]\n        [(string=? letters 'M) (+ 1 0)]\n        [(string=? letters\
    \ 'N) (+ 1 0)]\n        [(string=? letters 'O) (+ 1 0)]\n        [(string=? letters\
    \ 'P) (+ 1 0)]\n        [(string=? letters 'Q) (+ 1 0)]\n        [(string=? letters\
    \ 'R) (+ 1 0)]\n        [(string=? letters 'S) (+ 1 0)]\n        [(string=? letters\
    \ 'T) (+ 1 0)]\n        [(string=? letters 'U) (+ 1 0)]\n        [(string=? letters\
    \ 'V) (+ 1 0)]\n        [(string=? letters 'W) (+ 1 0)]\n        [(string=? letter",
  "  (cond\n    [(null? extensions) (list class_name)]\n    [(equal? (List-First extensions)\
    \ \"XXX\") (Strongest_Extension class_name (List-Tail extensions))]\n    [(equal?\
    \ (List-First extensions) \"BBB\") (Strongest_Extension class_name (List-Tail\
    \ extensions))]\n    [else (cons (cons class_name (List-First extensions)) (Strongest_Extension\
    \ (List-First extensions) (List-Tail extensions)))]))\n", "  (cond [(null? extensions)\
    \ \"\"]\n        [(= 0 (length extensions))\n         (cons class_name extensions)]\n\
    \        [else\n         (let ((cap (string-length class_name))\n            \
    \    ((len (string-length extensions))\n                 (sm (string-length extensions))))\n\
    \           (cond\n             [(< len sm)\n              (cons class_name\n\
    \                    (substring extensions 0 len))]\n             [(< sm cap)\n\
    \              (cons (substring extensions 0 (- sm cap))\n                   \
    \ (substring extensions (- len cap) sm))]\n             [else\n              (cons\
    \ (substring extensions 0 cap)\n                    (substring extensions (- cap\
    \ sm) sm))]\n           ))]))\n", "  (cond\n    [(null? extensions) (append class_name\
    \ \".\" '())]\n    [(= (length extensions) 1) (append class_name \".\" extensions)]\n\
    \    [(= (length extensions) 2) \n      (append class_name \".\" (Strongest_Extension\
    \ (first extensions) (subseq extensions 1)))]\n    [(= (length extensions) 3)\
    \ \n      (append class_name \".\" (Strongest_Extension (first extensions) (subseq\
    \ extensions 2)))]\n    [(= (length extensions) 4) \n      (append class_name\
    \ \".\" (Strongest_Extension (first extensions) (subseq extensions 3)))]\n   \
    \ [(= (length extensions) 5) \n      (append class_name \".\" (Strongest_Extension\
    \ (first extensions) (subseq extensions 4)))]\n    [(= (length extensions) 6)\n\
    \      (append class_name \".\" (Strongest_Extension (first extensions) (subseq\
    \ extensions 5)))]\n    [(= (length extensions) 7)\n      (append class_name \"\
    .\" (Strongest_Extension (first extensions) (subseq extensions 6)))]\n    [(=\
    \ (length extensions) 8)\n      (append class_name \".\" (Strongest_Extension\
    \ (first extensions) (subseq extensions 7)))]\n    [(= (length extensions) 9)\n\
    \      (append class_name \".\" (Strongest_Extension (first extensions) (subseq\
    \ extensions 8)))]\n    [(= (length extensions) 10)\n      (append class_name\
    \ \".\" (Strongest_Extension (first extensions) (subseq extensions 9)))]\n   \
    \ [(= (length extensions) 11)\n      (append class_name \".\" (Strongest_Extension\
    \ (first extensions) (subseq extensions 10)))]\n    [(= (length extensions) 12)\n\
    \      (append class_name \".\" (Strongest_Extension (first extensions) (subseq\
    \ extensions 11)))]\n    [(= (length extensions) 13)\n      (append class_name\
    \ \".\" (Strongest_Extension (first extensions) (subseq extensions 12)))]\n  \
    \  [(= (length extensions) 14)\n      (append class_name \".\" (Strongest_Extension\
    \ (first extensions) (subseq extensions 13)))]\n    [(= (length extensions) 15)\n\
    \      (append class_name \".\" (Strongest_Extension (first extensions) (subseq\
    \ extensions 14)))]\n    [(= (length extensions) 16)\n      (append class_name\
    \ \".\" (Strongest_Extension (first extensions) (subseq extensions 15)))]", " \
    \ (let ([CAP (length class_name)\n         SM (length extensions)])\n    (define\
    \ (extension extension)\n      (cond ((= CAP SM) extension)\n            ((>=\
    \ SM (string->number (string->char extension))) extension)\n            (else\
    \ (error \"Invalid Extension: ~a\" extension))))\n    (apply string \n       \
    \    (append (map (lambda (x) (extension x)) extensions)\n                   \"\
    .\" class_name)))\n", "  (cond\n    ((empty? extensions) \".\")\n    ((eq? (length\
    \ extensions) 1)\n     (string+ \"[\" (car extensions) \"]\"))\n    ((<= (length\
    \ (filter (lambda (x) (char-upper? (first x)))\n                          (map\
    \ string->char (string->list class_name))))\n         (length (filter (lambda\
    \ (x) (char-lower? (first x)))\n                          (map string->char (string->list\
    \ class_name))))\n         (string+ \"[\" (car extensions) \".\" (car extensions)\
    \ \"]\"))\n    ((< \n      (length (filter (lambda (x) (char-upper? (first x)))\n\
    \                      (map string->char (string->list class_name))))\n      (length\
    \ (filter (lambda (x) (char-lower? (first x)))\n                      (map string->char\
    \ (string->list class_name))))\n     (string+ \"[\" (car extensions) \".\" (car\
    \ extensions) \".\" (car extensions) \"]\"))\n    ((< \n      (length (filter\
    \ (lambda (x) (char-upper? (first x)))\n                      (map string->char\
    \ (string->list class_name))))\n      (length (filter (lambda (x) (char-lower?\
    \ (first x)))\n                      (map string->char (string->list class_name))))\n\
    \     (string+ \"[\" (car extensions) \".\" (car extensions) \".\" (car extensions)\
    \ \".\" (car extensions) \"]\"))\n    ((< \n      (length (filter (lambda (x)\
    \ (char-upper? (first x)))\n                      (map string->char (string->list\
    \ class_name))))\n      (length (filter (lambda (x) (char-lower? (first x)))\n\
    \                      (map string->char (string->list class_name))))\n     (string+\
    \ \"[\" (car extensions) \".\" (car extensions) \".\" (car extensions) \".\" (car\
    \ extensions) \".\" (car extensions) \".\" (car extensions) \"]\"))\n    ((< \n\
    \      (length (filter (lambda (x) (char-upper? (first x)))\n                \
    \      (map string->char (string->list class_name))))\n      (length (filter (lambda\
    \ (x) (char-lower? (first x)))\n                      (map string->char (string->list\
    \ class_name))))\n     (string+ \"[\" (car extensions) \".\" (car extensions)\
    \ \".\" (car extensions) \".\" (car extensions) \".\" (car extensions) \".\" (car\
    \ extensions) \".\" (car extensions) \".\" (car extensions) \".\" ", "  (define\
    \ extension\n    (max_extension extensions))\n\n  (let* ((number_of_uppercase\n\
    \           (char_count extension (char #\\Upper #\\Lower #\\Capital #\\Special)))\n\
    \         (number_of_lowercase\n           (char_count extension (char #\\Upper\
    \ #\\Lower #\\Capital)))\n         (number_of_special_character\n           (char_count\
    \ extension (char #\\Upper #\\Lower #\\Capital #\\Special)))\n         (number_of_characters\n\
    \           (+ number_of_uppercase number_of_lowercase number_of_special_character)))\n\
    \    (cond\n      [(= number_of_characters 1)\n       (cons class_name extension)]\n\
    \      [else\n       (append (cons class_name\n                   (list (car extension)\n\
    \                         (* (- number_of_uppercase number_of_lowercase)\n   \
    \                          (- number_of_lowercase number_of_special_character))\n\
    \                         (- number_of_special_character\n                   \
    \          (* (- number_of_uppercase number_of_lowercase)\n                  \
    \              (- number_of_lowercase number_of_special_character)))))]))))\n",
  "  (cond\n    [(empty? extensions) \"\"]\n    [(equal? (first (car extensions))\
    \ (car class_name)) (first (car extensions))]\n    [else (Strongest_Extension\
    \ class_name (rest extensions))]))\n", "  (define (strength class-name)\n    (/\
    \ (string->number (car class-name)) (length (string->string (car class-name))))\n\
    \  )\n  (define (strong-extensions extensions)\n    (cond ((null? extensions)\
    \ '())\n          ((< (strength (car extensions)) (strength (cdr extensions)))\
    \ (car extensions))\n          (else (strong-extensions (cdr extensions))))\n\
    \  (if (< (length (string->string (class_name))) (length (string->string (strong-extensions\
    \ (extensions)))))\n      (format nil \"~S.~A\" class_name (string->string (strong-extensions\
    \ (extensions))))\n      (format nil \"~A.~A\" class_name (string->string (class_name))))\n\
    \  )\n", "  (cond\n    [(empty? extensions)\n     (printf \"%s.\" class_name)]\n\
    \    [(equal? (first extensions) (first extensions)) (Strongest_Extension (substring\
    \ (second class_name) 0 -1) (drop (length extensions) extensions))]\n    [else\
    \ (Strongest_Extension (substring (second class_name) 0 -1) (append (drop (length\
    \ extensions) extensions) (list (first extensions))))]))\n", "  (cond\n    [(empty?\
    \ extensions) '()]\n    [(equal? (first extensions) (first extensions)) \n   \
    \  (string-append class_name \".\" (rest extensions)) \n     (Strongest_Extension\
    \ (rest extensions))]\n    [else \n     (string-append class_name \".\" (rest\
    \ extensions)) \n     (Strongest_Extension (rest extensions))]))\n", "  (cond\n\
    \    [(empty? extensions)\n     class_name]\n    [(>= (length class_name) 1)\n\
    \     class_name]\n    [else\n     (let ([\n           (string-length (string-downcase\
    \ (substring class_name 0 (length class_name)))) \n           (string-length (string-downcase\
    \ (substring class_name 1 (length class_name)))) \n           (extensions-length\
    \ extensions)\n           (strongest-extension (max extensions-length))\n    \
    \       (strongest-extension (min extensions-length))\n           ])\n       (cond\n\
    \         [(> strongest-extension 0)\n          (string-append class_name (strcat\
    \ (substring extensions strongest-extension (length (extensions strongest-extension)))\
    \ \".\"))]\n         [(> strongest-extension 1)\n          (string-append class_name\
    \ (strcat (substring extensions strongest-extension (length (extensions strongest-extension)))\
    \ \".\"))]\n         [else\n          (cond [(> strongest-extension extensions-length)\
    \ (string-append class_name (strcat (substring extensions strongest-extension\
    \ (length (extensions strongest-extension))) \".\"))]\n                [else (cond\
    \ [(> strongest-extension extensions-length-1) (string-append class_name (strcat\
    \ (substring extensions strongest-extension (length (extensions strongest-extension)))\
    \ \".\"))]\n                         [else (cond [(> strongest-extension extensions-length-2)\
    \ (string-append class_name (strcat (substring extensions strongest-extension\
    \ (length (extensions strongest-extension))) \".\"))]\n                      \
    \           [else (cond [(> strongest-extension extensions-length-3) (string-append\
    \ class_name (strcat (substring extensions strongest-extension (length (extensions\
    \ strongest-extension))) \".\"))]\n                                         [else\
    \ (cond [(> strongest-extension extensions-length-4) (string-append class_name\
    \ (strcat (substring extensions strongest-extension (length (extensions strongest-extension)))\
    \ \".\"))]\n                                                 [else (cond [(> strongest-extension\
    \ extensions-length-5) (string-append class_name (strcat (substring extensions\
    \ strongest-extension (length (extensions strongest-extension))) \".\"))]\n  \
    \                                                       [else (cond [(> stron",
  "  (let ((cap (length class_name)) \n        (sm  (length \n                (filter\
    \ (lambda (x) (char->integer x) \n                          (filter (lambda (x)\
    \ (char->integer x) extensions)))))))\n    (cond ((= cap sm) (list class_name))\n\
    \          ((> cap sm) \n           (let ((x (/ (- cap sm) cap) (- sm cap)))\n\
    \             (if (< x 0) \n                 (list class_name)\n             \
    \    (cond (\n                   ((char->integer extensions) \n              \
    \      (filter (lambda (x) (char->integer x) (extensions)))) \n              \
    \     ((char->integer extensions) \n                    (filter (lambda (x) (char->integer\
    \ x) (extensions))))\n                   ((char->integer extensions) \n      \
    \              (filter (lambda (x) (char->integer x) (extensions))))\n       \
    \            ((char->integer extensions) \n                    (filter (lambda\
    \ (x) (char->integer x) (extensions))))\n                   ((char->integer extensions)\
    \ \n                    (filter (lambda (x) (char->integer x) (extensions))))\n\
    \                   ((char->integer extensions) \n                    (filter\
    \ (lambda (x) (char->integer x) (extensions))))\n                   ((char->integer\
    \ extensions) \n                    (filter (lambda (x) (char->integer x) (extensions))))\n\
    \                   ((char->integer extensions) \n                    (filter\
    \ (lambda (x) (char->integer x) (extensions))))\n                   ((char->integer\
    \ extensions) \n                    (filter (lambda (x) (char->integer x) (extensions))))\n\
    \                   ((char->integer extensions) \n                    (filter\
    \ (lambda (x) (char->integer x) (extensions))))\n                   ((char->integer\
    \ extensions) \n                    (filter (lambda (x) (char->integer x) (extensions))))\n\
    \                   ((char->integer extensions) \n                    (filter\
    \ (lambda (x) (char->integer x) (extensions))))\n                   ((char->integer\
    \ extensions) \n                    (filter (lambda (x) (char->integer x) (extensions))))\n\
    \                   ((char->integer extensions) \n                    (filter\
    \ (lambda (x) (char->integer x) (extensions))))\n                   ((char->integer\
    \ extensions) \n                    (filter (lambda (x) (char->integer x) (extensions))))\n\
    \                   ((char->integer extensions) \n                    (filter\
    \ (lambda (x) (char->integer x) (extensions))))\n                   ((char->integer\
    \ extensions) \n                    (filter (lambda (x) (char->integer x) (extensions))))\n\
    \                   ((char->integer extensions) \n                    (filter\
    \ (lambda (x) (char->integer x) (extensions))))\n                   ((char", " \
    \ (define C (car (string-capitalize (substring class_name 0 1)))) \n  (define\
    \ S (car (string-capitalize (substring class_name 1 1))))\n  (define A (cadr (substring\
    \ class_name 2 4)))\n  (define B (cadr (substring class_name 5 9)))\n  (define\
    \ C (cadr (substring class_name 10 14)))\n  (define S (cadr (substring class_name\
    \ 15 19)))\n  (define strongest_extension (list '(class_name 'strongest_extension_name\
    \ 'extensions '(extensions '(A B 'C))))\n  (define (compare-to-other-strongest-extension\
    \ ss)\n    (let ((other-strongest-extension (sort ss\n                       \
    \                    (lambda (a b) (< (length a) (length b))\n               \
    \                             (lambda (a b) (< (length (string-capitalize (substring\
    \ a 0 1)))\n                                                                 (length\
    \ (string-capitalize (substring b 0 1)))\n                                   \
    \                              0))\n                                         \
    \   (lambda (a b) (< (length (string-capitalize (substring a 0 1)))\n        \
    \                                                         0)\n               \
    \                             (lambda (a b) (< (length (string-capitalize (substring\
    \ b 0 1)))\n                                                                 0))\n\
    \                                            0))))\n      (if (< (length strongest_extension)\n\
    \             (length other-strongest-extension))\n          (compare-to-other-strongest-extension\
    \ (append strongest_extension (list (other-strongest-extension))))\n         \
    \ (< (length strongest_extension)\n               (length other-strongest-extension))))))\n\
    \  (if (> (- C S) (- A B) (- C S) (- A B))\n    (compare-to-other-strongest-extension\
    \ extensions)\n    (compare-to-other-strongest-extension (append extensions (list\
    \ (list class_name))))))\n\n", "  (define (find_extension extension extensions)\n\
    \    (if (null? extensions)\n        '()\n        (if (= (length extension) 1)\n\
    \            (cons (first extension) (find_extension (rest extensions) extensions))\n\
    \            (if (char-uppercase (first extension))\n                (if (char-lowercase\
    \ (rest extension))\n                    (cons (first extension) (find_extension\
    \ (rest extensions) extensions))\n                    (find_extension (first extension)\
    \ (rest extensions)))))\n      (if (char-uppercase extension)\n          (if (char-lowercase\
    \ (rest extension))\n              (cons (first extension) (find_extension (rest\
    \ extensions) extensions))\n              (find_extension (first extension) (rest\
    \ extensions)))))))\n  (define (strength_extension extension extensions)\n   \
    \ (let ((str_ext (length extension)))\n      (cond ((< str_ext 1) (length (find-extension\
    \ extension extensions)))\n            ((= str_ext 1) (cons extension (find_extension\
    \ extension extensions)))\n            (else\n             (cons extension\n \
    \                   (find-extension\n                     (first (sort extensions\
    \ <???>))\n                     (sort extensions <???>))))))\n  (let ((class_parts\
    \ (string-split (string class_name) #\\.)))\n    (let ((strength (strength_extension\
    \ class_parts extensions)))\n      (format #t \"~a.~a\" class_name (string-join\
    \ (map string strength) (string #\\.)))))\n", "  (if (null? extensions) \"\"\n\
    \      (let ((cap (string-length class_name)))\n        (let ((sm   (string-length\
    \ extensions)))\n          (let ((cap-sm-ratio (- (/ cap sm) 1)))\n          \
    \  (if (= cap-sm-ratio 0)\n              (list (cons class_name extensions))\n\
    \              (let ((smallest (min cap-sm-ratio (list cap sm)))\n           \
    \         (best (assoc (substring class_name 0 smallest) extensions)))\n     \
    \           (if (null? best)\n                    (list (cons class_name extensions))\n\
    \                    (list (cons (substring class_name 0 smallest) \n        \
    \                      (append (substring class_name (+ smallest sm)))))))))))))\n",
  "  (let ([strongest (first extensions)])\n    (cond\n      [(empty? extensions)\
    \ (list class_name)]\n      [else\n       (append (list class_name) \n       \
    \        (list (string-join \n                      (map (lambda (ext)\n     \
    \                       (string-append \"...\" (string-lower ext)))\n        \
    \                (rest extensions))\n                      \".\" (string-downcase\
    \ strongest)\n                      \"...\"))]))))\n</code>\n<|/ a |>\n<| c |>\n\
    Thank you for your answer, but it's not working for the class names containing\
    \ numbers. For example, for \"Slices\" and \"Slices_12\" and a list of extensions:\
    \ ['SErviNGSliCes', 'Cheese', 'StuFfed'] it returns \"Slices_12.SErviNGSliCes\"\
    , instead of \"Slices.SErviNGSliCes\".\n<|/ c |>\n<| c |>\nI edited the answer.\
    \ Now the function takes only class names with one or zero extension.\n<|/ c |>\n\
    <| c |>\nThank you so much! It works perfectly now! It's really appreciated.\n\
    <|/ c |>\n<| a dscore=1 |>\nHow about using Racket's built-in module string-extensions?\n\
    <code>\n#lang racket", "  (let* ((extensions_count (length extensions))\n    \
    \     (extensions_sorted (sort extensions string<))\n         (extension extensions_sorted\
    \ extensions_count))\n    (cond\n      [(<= extensions_count 1) (cons class_name\
    \ (list extension))]\n      [(eq? (first extension) (first extensions_sorted))\
    \ (cons (first extension)\n                                                  \
    \  (list (rest extension)))]\n      [else (cons class_name (list (first extension)\
    \ (rest extension)))])))\n", "  (let ((strongest (first extensions))\n       \
    \ (index 0))\n    (cond ((empty? extensions) (error \"Empty extensions list\"\
    ))\n          ((> strongest (length class_name))\n           (error \"Bad extension\
    \ name\"))\n          ((= index 0) (strongest))\n          (else\n           (let\
    \ ((ext (get-extension class_name index)))\n             (cond ((empty? ext) (error\
    \ \"No extension of class name ~A\" class_name))\n                  ((> strongest\
    \ (length ext))\n                   (error \"Bad extension name\"))\n        \
    \          ((= index 0) (strongest))\n                  (else\n              \
    \     (let ((ext (get-extension class_name index)))\n                     (cond\
    \ ((empty? ext) (error \"No extension of class name ~A\" class_name))\n      \
    \                     ((> strongest (length ext))\n                          \
    \  (error \"Bad extension name\"))\n                           ((> strongest (length\
    \ class_name))\n                            (error \"Bad extension name\"))\n\
    \                           ((<= (length class_name) (length ext))\n         \
    \                   (error \"Bad extension name\"))\n                        \
    \   (else\n                             (return (strongest . ext))))))))))\n  ",
  "  (define (SM a b) (/ (/ (length a) (length b)) 2))\n  (define (StrongestExtension\
    \ strength extension)\n    (cond\n      [(null? extension) (list extension)]\n\
    \      [(SM (symbol->string extension) (symbol->string class_name))\n       (cons\
    \ (concat extension \".\" class_name) (StrongestExtension strength \n        \
    \                        (remove-if (\u03BB (e) (equal? (symbol->string e) class_name))\n\
    \                                             extensions))\n      )]))\n  (reduce\
    \ (lambda (x y) \n            (if (< (length x) y)\n                (cons x y)\n\
    \                (cons y x)))\n          (StrongestExtension -1 extensions)\n\
    \          :initial-value '())\n  )\n  ", "  (define (strength_of class_name)\n\
    \    (for/fold ((strength 0)) ((extension 0) (index 0)) \n              (cond\
    \ ((char=? (char-code class_name) 65) (+ strength -1))\n                ((char=?\
    \ (char-code class_name) 97) (+ strength -1))\n                ((char=? (char-code\
    \ class_name) 123)\n                 (+ strength (length extensions) (length class_name)))\n\
    \                ((char=? (char-code class_name) 48) (+ strength -1))\n      \
    \          (else (+ strength (+ index (length class_name)))) )))\n  (define (strength_order\
    \ s)\n    (sort s #'< :key #'car))\n  (define (strength_order_compare x)\n   \
    \ (define (strength_order_compare-ext a b)\n      (if (< (strength_of a) (strength_of\
    \ b))\n          -1\n          1))\n    (strength_order extensions)\n    (sort\
    \ extensions #'> :key #'car\n           :order-by #'car\n           :compare (lambda\
    \ (a b)\n                       (if (equal? a b)\n                           0\n\
    \                           (strength_order_compare-ext a b))))))\n  (define (Strongest_Extension\
    \ class_name extensions)\n    (let ((extension (first extensions)))\n      (if\
    \ (equal? class_name extension)\n          (first (rest extensions))\n       \
    \   (if (null? (rest extensions))\n              class_name\n              (Strongest_Extension\
    \ (Strongest_Extension class_name extensions)\n                              \
    \    extensions)))))\n  (Strongest_Extension class_name extensions))\n", "  (cond\n\
    \    ((null? extensions) (error \"Extensions list is empty.\"))\n    ((null? (cdr\
    \ extensions)) (error \"Extension list is empty.\"))\n    ((equal? (caar extensions)\
    \ (caar class_name)) (Strongest_Extension (cdr (cdr extensions))))\n    ((equal?\
    \ (caar extensions) (caar (cdr class_name)))\n     (Strongest_Extension (cdr (cdr\
    \ (cdr extensions))))\n    ((> (caar (cdr extensions)) (caar (cdr class_name)))\n\
    \     (Strongest_Extension (cdr (cdr (cdr (cdr extensions)))))))\n", "  (let ((strongest\
    \ (list-ref extensions (sort (lambda (ext) (- strongest (length ext)))\n     \
    \                                   (lambda (ext i) (equal? (car ext) i)))\n \
    \                              0 (car (sort extensions))))\n        (others (cdr\
    \ (sort extensions)\n                      (lambda (ext i) (equal? (car ext) i))))\n\
    \    (format nil \"~a.~a\" class_name (strongest extensions))\n    (if (or (null?\
    \ strongest) (null? others))\n        (format nil \"~a.~a\" class_name extensions)\n\
    \        (let ((extension-name (sort extensions \n                           \
    \       (lambda (ext i) (equal? (car ext) i))))\n               (extension (cadr\
    \ extensions)))\n          (format nil \"~a.~a\" class_name (first extension-name))\n\
    \          (if (null? extension-name)\n              (format nil \"~a.~a\" class_name\
    \ extensions)\n              (Strongest_Extension (first extension-name) extensions))))))\n",
  "  (cond\n    [(empty? extensions) \"\"]\n    [(equal? (first (first extensions))\n\
    \               (first (first (first extensions)))) \n     (first (first extensions))]\n\
    \    [else (Strongest_Extension \n             (substring (first class_name) 0\
    \ 1)\n             (rest extensions))]))\n", "  (if (null? extensions)\n     \
    \ (println \"The extensions are empty. Cannot find strongest extension for class:\
    \ \" class_name)\n      (let ([sms (count (map downcase extensions))]\n      \
    \      [caps (count (map upcase extensions))]\n            [sms_caps (/ sms caps)])\n\
    \        (if (< (+ caps sms_caps) 0)\n            (if (< sms_caps 0)\n       \
    \         (println \"There are no strongest extensions for class name: \" class_name)\n\
    \                (let ([extension_1 (first extensions)\n                     \
    \ extension_2 (second extensions)\n                      extension_3 (third extensions)])\n\
    \                  (if (equal? extension_1 extension_2)\n                    \
    \  (println \"The strongest extension for class name: \" class_name \n       \
    \                         \" is: \" extension_3)\n                      (println\
    \ \"There are more than one strongest extensions for class name: \" class_name\
    \ \n                                \" Choose the first one by giving higher numbers\
    \ to those extensions\"))))\n            (if (equal? (first extensions) extension_2)\n\
    \                (println \"The strongest extension for class name: \" class_name\
    \ \n                         \" is: \" extension_1)\n                (println\
    \ \"There are more than one strongest extensions for class name: \" class_name\
    \ \n                         \" Choose the second one by giving higher numbers\
    \ to those extensions\"))))\n        (if (equal? (first extensions) extension_3)\n\
    \            (println \"The strongest extension for class name: \" class_name\
    \ \n                     \" is: \" extension_1)\n            (println \"There\
    \ are more than one strongest extensions for class name: \" class_name \n    \
    \                 \" Choose the third one by giving higher numbers to those extensions\"\
    ))))))\n</code>\n<|/ a tags=scheme,racket,lisp,lisp dscore=2 |>\n<| c |>\nThe\
    \ second one fails if there are multiple extensions with the same strength. It\
    \ should return the one that comes first in the list.\n<|/ c |>\n<| c |>\nThank\
    \ you very much for the answer.\n<|/ c |>\n<| a tags=scheme,racket,lisp,lisp |>\n\
    This problem is similar to \"Longest Common Prefix\". I solved it in this manner\
    \ with O(n) complexity (you can find my solution here).\n<code>", "  (if (null?\
    \ extensions)\n      class_name\n      (let ((extension (assoc (first extensions)\
    \ (second extensions) (first extensions))))\n        (if (> (second extensions)\
    \ 0)\n            (append (Strongest_Extension class_name (list extension)) (Strongest_Extension\
    \ class_name (list extension)))\n            (Strongest_Extension class_name (list\
    \ extension))))))\n", "  (let ([strongest_extension (Max (length extensions) 1)]\n\
    \        [extension_name (in-extension-name class_name)])\n    (loop [i 0 extension_name\
    \ extension_name strongest_extension]\n      (cond [(empty? extensions) \n   \
    \           (list class_name extension_name)\n              (eq? extension_name\
    \ strongest_extension) \n              (loop for i from (1- strongest_extension)\n\
    \                  with [extension extensions])\n              ]\n           \
    \ [else \n              (set! strongest_extension (Max (strongest_extension (-\
    \ i 1))\n                                          (Max (length extensions)\n\
    \                                              (Min(length (extension-name extension))\n\
    \                                                    strongest_extension)))))\n\
    \              (set! extension_name (concat extension_name \n                \
    \                        (in-extension-name extension))\n              (set! i\
    \ (+ i 1))\n              (loop for extension extensions with [extension_name\
    \ extension])\n              (set! extension_name (concat extension_name \".\"\
    \ (extension-name extension)))\n              (loop for i from (1- strongest_extension)\n\
    \                  with [extension extensions])\n              ]))))\n", "  (let\
    \ ((sorted_extensions '()) (strength 0)\n         (strongest '()))\n    (for ext\
    \ in extensions\n      (set! sorted_extensions (cons (string ext strength) (sorted_extensions))))\n\
    \    (sort sorted_extensions <??)\n    (if (> (length sorted_extensions) 1) \n\
    \        (strongest (car sorted_extensions))\n        (set! strongest (car sorted_extensions)))))\n",
  "  (let ([cap (length (string->list (string-upper-case class_name)))\n        sm\
    \  (length (string->list (string-lower-case class_name)))]\n        [str (/ (-\
    \ cap sm) 2)])\n    (cond\n      [(< str (/ (- cap sm) 2))\n       (string->list\
    \ (append (substring (string class_name) 0 cap) (list (substring (string class_name)\
    \ (cap + 1) sm)))]\n      [(< str (/ sm 2))\n       (string->list (list (substring\
    \ (string class_name) 0 sm) (list (substring (string class_name) sm (cap + 1))))]\n\
    \      [else\n       (string->list (append (substring (string class_name) 0 cap)\
    \ (list (substring (string class_name) (cap + 1) sm)))]))))\n\n", "  (define (CAP\
    \ SM)\n    (Math/floor \n     (string->number (string-ref class_name 0 CAP)\n\
    \                    (string-ref class_name 1 SM))\n     (string->number (string-ref\
    \ class_name CAP (CAP ^ 2)),\n                    (string-ref class_name SM (SM\
    \ * 2))))\n    (Math/floor (- (CAP - SM) (length extensions))))\n  (if (null?\
    \ extensions)\n    (format nil \"~A\" (symbol->string class_name))\n    (let ((strength\
    \ (Math/floor \n                    (string->number (string-ref class_name 0 CAP)\n\
    \                                  (string-ref class_name 1 SM))\n           \
    \         (string->number (string-ref class_name CAP (CAP ^ 2)),\n           \
    \                       (string-ref class_name SM (SM * 2))))\n           (extension\
    \ (max-by-key extensions strength)))\n      (if (null? extension)\n        (format\
    \ nil \"~A\" (symbol->string class_name))\n        (format nil \"~A.~A\" class_name\
    \ (symbol->string extension)))))\n  \n  ;; This is your solution :-) \n  (define\
    \ (max-by-key [key coll])\n    (define (compare [x y]) (> (string->number x) (string->number\
    \ y)))\n    (define (compare-1 [x y]) (< (string->number x) (string->number y)))\n\
    \    (reduce \n      (lambda (p v) (cond (null? v) (null? (cdr p))\n         \
    \                   (compare-1 v (car p))\n                            (compare-1\
    \ p (car v)))\n                (list v)\n                (cdr p)))\n    (sort\
    \ \n      (lambda (x y) (compare x y)) \n      coll))\n  \n  ;; Use this instead.\n\
    \  \n  (define (max-by-key-2 [key coll])\n    (define (compare [x y]) (> (string->number\
    \ x) (string->number y)))\n    (define (compare-1 [x y]) (< (string->number x)\
    \ (string->number y)))\n    (define (compare-2 [x y]) (< (string->number x) (string->number\
    \ y)))\n    (reduce \n      (lambda (p v) (cond (null? v) (null? (cdr p))\n  \
    \                          (compare-1 v (car p))\n                           \
    \ (compare-1 p (car v)))\n                (list v)\n                (cdr p)))\n\
    \    (sort \n      (lambda (x y) (compare x y)) \n      coll))\n  \n  (define\
    \ (max-by-key-3 [key coll])\n    (define (", "  (cond\n    [(empty? extensions)\
    \ \"\"]\n    [else\n     (let\n       ((extension-name (first extensions))\n \
    \       (extension-len (length extensions)))\n       (cond\n        [(< extension-len\
    \ 0)\n         \"Extension name cannot be empty or null.\"]\n        [else\n \
    \        (cond\n           [(< extension-name (length class_name))\n         \
    \   \"Extension name cannot be longer than the class name.\"]\n           [else\n\
    \            (let\n              [(extension-lower-name (substring (make-string\
    \ extension-len) 0 0))\n              (extension-upper-name (substring (make-string\
    \ extension-len) 1 0))\n              (extension-lower-letters (length extension-lower-name))\n\
    \              (extension-upper-letters (length extension-upper-name))\n     \
    \         (extension-strength (- (length (string->list extension-name)) \n   \
    \                              (length (string->list extension-lower-name)))\n\
    \              (extension (if (>= extension-strength 0)\n                    \
    \       extension-lower-name \n                           extension-upper-name))]\n\
    \            (string-join (list class_name extension-name extension \".\") \"\
    .\"))]))]))]))\n", "  (define (compareExtension extension1 extension2)\n    (cond\
    \ ((equal? (count extension1) 0) 1)\n          ((equal? (count extension2) 0)\
    \ -1)\n          ((equal? (count extension1) (count extension2)) (compare (first\
    \ extension1) (first extension2)))\n          (else\n            (compare (first\
    \ extension1) (first extension2)))))\n  (sort extensions #:key (lambda (extension)\
    \ (compareExtension extension)))\n  (if (equal? extensions (second (sort extensions\
    \ #:key (lambda (extension) (compareExtension extension))))) \n    (second (sort\
    \ extensions #:key (lambda (extension) (compareExtension extension))))\n    (second\
    \ (sort extensions #:key (lambda (extension) (compareExtension extension))))))\n",
  "  (cond\n    [(empty? extensions) \"nil\"]\n    [(string? (first extensions)) (concat\
    \ class_name \".\" (rest extensions))]\n    [(cons? extensions) (cond \n     \
    \                    [(null? (rest extensions)) (concat class_name \".\" (rest\
    \ extensions))]\n                         [(string? (first extensions)) (concat\
    \ class_name \".\" (rest extensions))]\n                         [(> \n      \
    \                    (count (filter (fn x -> (string? x) extensions)\n       \
    \                                class_name)) \n                          (count\
    \ (filter (fn x -> (string? x) (rest extensions)) \n                         \
    \              class_name))) (concat class_name \".\" (rest extensions))]\n  \
    \                       [(<= \n                          (count (filter (fn x\
    \ -> (string? x) extensions)\n                                       class_name))\
    \ \n                          (count (filter (fn x -> (string? x) (rest extensions))\
    \ \n                                       class_name))) (concat class_name \"\
    .\" (rest extensions))]\n                         [(< \n                     \
    \     (count (filter (fn x -> (string? x) extensions)\n                      \
    \                 class_name)) \n                          (count (filter (fn\
    \ x -> (string? x) (rest extensions)) \n                                     \
    \  class_name))) (concat class_name \".\" (rest extensions))]\n              \
    \           [else (concat class_name \".\" (rest extensions))])]))])\n", "  (let\n\
    \      ([strengths (list->vector (map string-length extensions))])\n      (if\
    \ (null? extensions)\n          class_name\n          (let ([strongest (max strengths)])\n\
    \            (append class_name (str strongest) \".\" \n                     (string-join\
    \ (take strongest (reverse strengths)) \".\"))))))\n", "  (let ((count-upper-case\
    \ (count (string-match-all-cases \"[A-Z]\" class_name)))\n        (count-lower-case\
    \ (count (string-match-all-cases \"[a-z]\" class_name)))\n        (strength (-\
    \ (count-upper-case) count-lower-case)))\n    (if (and (> strength 0) (< strength\
    \ (/ 2 1)))\n        (string-concatenate (string class_name \".\" (Strongest_Extension\
    \ \n                                              (first extensions)\n       \
    \                                       (rest extensions)))\n                \
    \          (Strongest_Extension (first extensions) \n                        \
    \                      (rest extensions)))))\n  (if (= (length extensions) 0)\n\
    \      '()\n      (let ((extension (first extensions))\n            (other-extensions\
    \ (rest extensions)))\n        (if (= (length extensions) 1)\n            (if\
    \ (= (string-match-all-cases \"[A-Z]\" extension) \n                  (string-match-all-cases\
    \ \"[A-Z]\" other-extensions))\n                (Strongest_Extension (first extensions)\
    \ \n                                  (rest extensions))\n                (Strongest_Extension\
    \ (first extensions) \n                                  (rest extensions))))\n\
    \        (if (= (Strongest_Extension class_name extensions) \n              (Strongest_Extension\
    \ class_name other-extensions))\n            (if (= strength (/ strength (- count-upper-case\
    \ count-lower-case)))\n                (Strongest_Extension class_name extensions)\n\
    \                (Strongest_Extension class_name other-extensions))\n        \
    \    (if (> strength (/ strength (- count-upper-case count-lower-case)))\n   \
    \             (Strongest_Extension class_name extensions)\n                (Strongest_Extension\
    \ class_name other-extensions))))))\n", "  (let* ((extension_name (List-Extension-Name\
    \ extensions))\n         (extensions_name (List-Extension-Names extensions)))\n\
    \    (cond\n      [(empty? extensions_name) \"\"]\n      [(extension_name (List-Extension-Name\
    \ extensions)) (Strongest-Extension class_name extensions_name)]\n      [else\
    \ (Strongest-Extension class_name extensions_name (List-Extension-Name extensions))])))\n",
  "  (define (strength extension)\n    (let ([c (string->char (char->string extension))])\n\
    \      (cond\n        [(or (= (count c) 1) (< c 97))\n         (- 1)\n       \
    \ ]\n        [else\n         (- (- (count c) 1))\n        ]\n      )\n    )\n\
    \  (define (best extension strength)\n    (cond\n      [\n        ;; The extension\
    \ is already strongest.\n        [\n          (equal? extension class_name)\n\
    \          (list class_name)\n        ]\n        [\n          ;; The extension's\
    \ strength is -1. \n          [\n            (equal? strength -1)\n          \
    \  (list class_name)\n          ]\n          [\n            ;; The extension's\
    \ strength differs from the others.\n            (equal? (strength extension)\
    \ strength)\n            (list extension strength)\n          ]\n        ]\n \
    \       [\n          ;; If there are still extensions with the same strength,\
    \ return the\n          ;; one that comes first in the list.\n          [\n  \
    \          (equal? (strength (first extensions)) strength)\n            (append\
    \ (list (first extension)) (best (rest extensions) strength))\n          ]\n \
    \         [\n            ;; Return an empty list if no extensions remain with\
    \ the same \n            ;; strength.\n            (empty? (rest extensions))\n\
    \            (list \"\")\n          ]\n        ]\n      )\n    (append\n     (best\
    \ extension (strength extension))\n     (best (rest extensions) (strength (first\
    \ extensions)))\n    )\n  )\n  (best extensions -1)\n)\n", "  (cond\n    [(empty?\
    \ extensions) \"\"]\n    [(equal? (car extensions) \"\") \"\"]\n    [(equal? (car\
    \ extensions) \".\") \"\"]\n    [(equal? (cadr extensions) \"\") (cdr extensions)]\n\
    \    [else (cons (car extensions)\n              (Strongest_Extension class_name\
    \ (append (cdr extensions) '.')))]))\n", "  (cond\n    [(null? extensions) \"\"\
    ]\n    [(equal? (first extensions) \".\") \"\"]\n    [(equal? (first extensions)\
    \ \"..\") \"\"]\n    [else (cond \n             [(equal? (first extensions) (substring\
    \ (last extensions) 1)) (substring (last extensions) (+ 1 length))]\n        \
    \     [(equal? (first extensions) (substring (last extensions) (+ 1 length)) (+\
    \ (first extensions) (substring (rest extensions) 1)))]\n             [else (cond\
    \ \n                       [(equal? (first extensions) (substring (last extensions)\
    \ (+ 1 length)) (substring (last extensions) (+ 1 length)))]\n               \
    \        [else (cond \n                                 [(equal? (first extensions)\
    \ (substring (last extensions) (+ 1 length)) (substring (last extensions) (+ 1\
    \ length)))]\n                                 [else (cond \n                \
    \                           [(equal? (first extensions) (substring (last extensions)\
    \ (+ 1 length)) (substring (last extensions) (+ 1 length)))]\n               \
    \                            [else (cond \n                                  \
    \                  [(equal? (first extensions) (substring (last extensions) (+\
    \ 1 length)) (substring (last extensions) (+ 1 length)))]\n                  \
    \                                  [else (cond \n                            \
    \                                  [(equal? (first extensions) (substring (last\
    \ extensions) (+ 1 length)) (substring (last extensions) (+ 1 length)))]\n   \
    \                                                           [else (cond \n   \
    \                                                                  [(equal? (first\
    \ extensions) (substring (last extensions) (+ 1 length)) (substring (last extensions)\
    \ (+ 1 length)))]\n                                                          \
    \           [else (cond \n                                                   \
    \                          [(equal? (first extensions) (substring (last extensions)\
    \ (+ 1 length)) (substring (last extensions) (+ 1 length)))]\n               \
    \                                                              [else (cond \n\
    \                                                                            \
    \           [(equal? (first extensions) (substring (last extensions) (+ 1 length))\
    \ (substring (last extensions) (+ 1 length)))]\n                             \
    \                                                          [else (cond \n    \
    \                                                                            \
    \                 [(equal? (first extensions) (substring (last extensions) (+\
    \ 1 length)) (substring (last extensions) (+ 1 length)))]\n                  \
    \                                                                            \
    \   [else (cond \n                                                           \
    \                                                [(equal? (first extensions) (substring\
    \ (last extensions) (+ 1 length)) (substring (last extensions) (+ 1 length)))]\n\
    \                                                                            \
    \                               [else (cond \n                               \
    \                                                                            \
    \       [(equal? (first extensions) (substring (last extension", "  (letfn [(compare\
    \ [x y]\n          (cond\n            [(and (<= (length x) \n                \
    \   (length y)) \n              (<= x y) (compare (substring x 0 1) (substring\
    \ y 0 1))]\n            [else (cond [(equal? x (substring y 0 1)) (compare x y)]\n\
    \                        [else (compare y (substring x 0 1))]))]\n      (apply\
    \ compare class_name extensions))\n    \n  (letfn [(add_extension (extension strength)\n\
    \            (cond\n              [(empty? extensions) extension]\n          \
    \    [(equal? (first extension) (last extension)) \n               (list extension\
    \ (cons strength (rest extensions))) ]\n              [else (cons (last extension)\
    \ (add_extension (first extension) \n                                        \
    \                strength))]\n              [(equal? (last extension) (first extension))\n\
    \               (list extension (add_extension (rest extensions) strength))]\n\
    \              [else (list extension (add_extension (rest extensions) \n     \
    \                                               strength))]))\n    \n  (add_extension\
    \ (reverse extensions) 0))\n", "  (cond\n    [(empty? extensions) \"\"]\n    [else\
    \ (List-Extension (length extensions) class_name extensions)]))\n", "  (cond [(empty?\
    \ extensions) (error \"The list of extensions was empty.\" class_name)]\n    \
    \    [else (cons\n            (string-append class_name \".\")\n            (let\
    \ ([cap (length class_name)\n                  sm (length extensions)])\n    \
    \          (if (< sm cap)\n                  (error \"The list of extensions contains\
    \ more extension names than name lengths\" class_name) \n                  (if\
    \ (< cap sm)\n                      (substring extensions 0 (- (sm cap)))\n  \
    \                    (substring extensions sm (cap-lower (- sm cap))))))]))\n",
  "  (let ((caps (length class_name)) (sms (length class_name)))\n    (set! caps (string-length\
    \ (substring class_name 0 caps)))\n    (set! sms (string-length (substring class_name\
    \ 0 sms)))\n    (if (and (eq? caps (- sms))\n             (eq? (substring class_name\
    \ 0 caps) 'S)))\n        (let ((cap (substring class_name 0 caps))\n         \
    \      (sm (substring class_name 0 sms)))\n          (string-concatenate (string\
    \ class_name \".\" cap) (Strongest_Extension sm extensions))))\n    extensions))\n",
  "  (cond ((empty? extensions) \".\")\n        ((equal? (length class_name) (length\
    \ extensions))\n         (let ([max_strength (car extensions)])\n           (if\
    \ (> (length extensions) 2)\n              (format nil \"~S.\" class_name)\n \
    \             (format nil \"~S.~S\" (append (substring (class-name 0 0) 0) \"\
    .\")\n                       (append (substring (class-name 0 0) (length extensions)))))\n\
    \           (format nil \"~S.~S\" (append (substring (class-name 0 0) 0) \".\"\
    )\n                   (append (substring (class-name 0 0) (length extensions)))))))\n\
    \        (else (format nil \"~S.~S\" (append (substring (class-name 0 0) 0) \"\
    .\")\n                   (append (substring (class-name 0 0) (length extensions)))))\n\
    \        (else (format nil \"~S.~S\" (append (substring (class-name 0 0) 0) \"\
    .\")\n                   (append (substring (class-name 0 0) (length extensions)))))))\n",
  "  (cond\n    [(null? extensions) \"unloaded\"]\n    [(equal? (first extensions)\
    \ \"unloaded\") \"unloaded\"]\n    [else\n     (string-append (string class_name)\
    \ \".\" (StrongestExtension (first (rest extensions))))]\n    ))\n", "  (cond\n\
    \    [(null? extensions) (println \"ERROR: The list of extensions is empty.\"\
    )\n    (if (> (length extensions) 1)\n      (println \"ERROR: The list of extensions\
    \ is empty.\")\n      (cond [(null? (substring class_name 0 1))\n            \
    \ (println \"ERROR: The first character of the extension name is an \"\n     \
    \                  \"invalid character.\")\n             (set! class_name (substring\
    \ class_name 1 1))]\n        [(null? (substring class_name 0 1))\n         (println\
    \ \"ERROR: The first character of the extension name is an \"\n              \
    \    \"invalid character.\")\n         (set! class_name (substring class_name\
    \ 1 1))]\n        [else (println \"ERROR: The first character of the extension\
    \ name is an \"\n                   \"invalid character.\")\n              (set!\
    \ class_name (substring class_name 1 1))]\n        [else (println \"ERROR: The\
    \ extension name length is invalid.\")\n              (set! class_name (substring\
    \ class_name 1 1))])]\n    [(equal? (substring class_name 0 1) \"-\")\n     (cond\n\
    \       [(null? (length extensions))\n        (println \"ERROR: The list of extensions\
    \ is empty.\")\n        (set! class_name (substring class_name 1 1))]\n      \
    \ [(equal? (length extensions) 1)\n        (println \"ERROR: The list of extensions\
    \ is empty.\")\n        (set! class_name (substring class_name 1 1))]\n      \
    \ [(equal? (length extensions) 2)\n        (println \"ERROR: The list of extensions\
    \ is empty.\")\n        (set! class_name (substring class_name 1 1))]\n      \
    \ [(equal? (length extensions) 3)\n        (println \"ERROR: The list of extensions\
    \ is empty.\")\n        (set! class_name (substring class_name 1 1))]\n      \
    \ [else (println \"ERROR: The length of the extension list is invalid.\")\n  \
    \          (set! class_name (substring class_name 1 1))])]\n    [(equal? (substring\
    \ class_name 0 1) \"+\")\n     (cond\n       [(null? (length extensions))\n  \
    \      (println \"ERROR: The list of extensions is empty.\")\n        (set! class_name\
    \ (substring class_name 1 1))]\n       [(equal? (length extensions) 1)\n     \
    \   (println \"ERROR: The list of extensions is empty.\")\n        (set! class_name\
    \ (substring class_name 1 1))]\n       [(equal? (length extensions) 2)\n     \
    \   (println \"ERROR: The list of extensions is empty.\")\n        (set! class_name\
    \ (substring class_name 1 1))]\n       [(equal? (length extensions) 3)", "  (cond\n\
    \    [(empty? extensions) (list class_name)]\n    [(<= (length extensions) 1)\n\
    \     (let ([extension (car extensions)])\n       (if (= (length (string->list\
    \ (string->symbol (string->list extension))))\n            (- '(AAaA) \n     \
    \          (string->list (string->symbol (string->list extension)))))\n      \
    \     (if (< (length (string->list (string->symbol (string->list extension))))\
    \ 2)\n               (append (list class_name) (string->list (string->symbol (string->list\
    \ extension))))\n               (append (list class_name) (string->list (string->symbol\
    \ (string->list (reverse (string->list (string->symbol (string->list extension))))))\
    \ ))))]\n    [else (let ([extensions (reverse extensions)])\n           (let ([strongest\
    \ (first extensions)])\n             (if (not (empty? strongest))\n          \
    \       (if (< (length (string->list (string->symbol (string->list strongest))))\n\
    \                         (- '(AAaA) \n                           (string->list\
    \ (string->symbol (string->list strongest))))\n                   (if (< (length\
    \ (string->list (string->symbol (string->list (reverse (string->list (string->symbol\
    \ (string->list strongest)))))))) \n                   (append (list class_name)\
    \ (string->list (string->symbol (string->list strongest)))) \n               \
    \    (append (list class_name) (string->list (string->symbol (string->list (reverse\
    \ (string->list (string->symbol (string->list strongest)))))))))\n           \
    \      (if (empty? strongest)\n                 (cond\n                   [(=\
    \ (length (string->list (string->symbol (string->list extensions))))\n       \
    \              (- '(AAaA) \n                       (string->list (string->symbol\
    \ (string->list extensions))))]\n                   [(= (length (string->list\
    \ (string->symbol (string->list (reverse (string->list (string->symbol (string->list\
    \ extensions))))))))\n                    (append (list class_name) (string->list\
    \ (string->symbol (string->list (reverse (string->list (string->symbol (string->list\
    \ extensions))))))))]\n                  [else (cond\n                       \
    \   [(= (length (string->list (string->symbol (string->list (reverse (string->list\
    \ (string->symbol (string->list (reverse (string->list (string->symbol (string->list\
    \ extensions)))))))))))\n                           (append (list class_name)\
    \ (string->list (string->symbol (string", "  (let\n    [\n      (\n        (\n\
    \          (letter_counter (make-hash))\n          (letter_counter (map uppercase\
    \ extensions)))\n      (\n        (\n          (lower_cases_counter (make-hash))\n\
    \          (lower_cases_counter (map lowercase extensions)))\n      (\n      \
    \  (\n          (total_counter (make-hash))\n          (total_counter extensions)))\n\
    \      (\n        (\n          (strongest_extension (make-hash))\n          (strongest_extension\
    \ extensions))\n      (\n        (\n          (strength_counter (make-hash))\n\
    \          (strength_counter extensions))\n      (\n        (\n          (sorted_strength_counter\
    \ (make-hash))\n          (sorted_strength_counter extensions))\n      (\n   \
    \     (\n          (max_counter (make-hash))\n          (max_counter extensions))\n\
    \      (\n        (\n          (max_extension (make-hash))\n          (max_extension\
    \ extensions))\n      (\n        (\n          (min_counter (make-hash))\n    \
    \      (min_counter extensions))\n      (\n        (\n          (min_extension\
    \ (make-hash))\n          (min_extension extensions))\n      (\n        (\n  \
    \        (total_extensions (make-hash))\n          (total_extensions extensions))\n\
    \      (\n        (\n          (extension_counter (make-hash))\n          (extension_counter\
    \ extensions))\n      (\n        (\n          (extension_name (make-hash))\n \
    \         (extension_name extensions))\n      (\n        (\n          (extension_strength\
    \ (make-hash))\n          (extension_strength extensions))\n      (\n        (\n\
    \          (extension_strength_counter (make-hash))\n          (extension_strength_counter\
    \ extensions))\n      (\n        (\n          (max_extension_strength (make-hash))\n\
    \          (max_extension_strength extensions))\n      (\n        (\n        \
    \  (max_extension_strength_counter (make-hash))\n          (max_extension_strength_counter\
    \ extensions))\n      (\n        (\n          (min_extension_strength (make-hash))\n\
    \          (min_extension_strength extensions))\n      (\n        (\n        \
    \  (min_extension_strength_counter (make-hash))\n          (min_extension_strength_counter\
    \ extensions))\n      (\n        (\n          (total_extension_strength (make-hash))\n\
    \          (total_extension_strength extensions))\n      (\n        (\n      \
    \    (extension_strength_counter (make-hash))\n          (extension_strength_counter\
    \ extensions))\n      (\n        (\n          (extension_strength_name (make-hash))\n\
    \          (extension_", "  (let ((strength (make-hash)))\n    (do ((extension\
    \ (sort extensions (< string-length extension))))\n        ((null? extension)\
    \ \n         (format nil \"~A\" (symbol->string class_name))))\n      ((member\
    \ (substring extension 0 (string-length extension)) strength)\n       (if (< (hash-ref\
    \ strength (substring extension 0 (string-length extension))) \n             \
    \  (hash-ref strength (substring extension (string-length extension) \n      \
    \                                (string-length extension))))\n          (format\
    \ nil \"~A.\" (symbol->string class_name))\n          (format nil \"~A.\" (symbol->string\
    \ class_name)\n                   (symbol->string (substring extension (string-length\
    \ extension) \n                                       (string-length extension))))))\n\
    \      (set! strength (cons extension (hash-set strength (substring extension\
    \ \n          0 (string-length extension)))))))\n", "  (let* ((strongest-extension-name\
    \ (Strongest_Extension_Name class_name extensions))\n         (strongest-extension-strength\
    \ (Strength strongest-extension-name)))\n    (if (< strongest-extension-strength\
    \ 0)\n        (cons (string-append (Strongest_Extension_Name class_name extensions)\n\
    \                          (strongest-extension-name))\n              (Strongest_Extension_Name\
    \ class_name extensions))\n        ((cons (string-append (strongest-extension-name\
    \ \".\")\n                           (strongest-extension-name))\n           \
    \   (strongest-extension-name))))) \n", "  ;; (define (extension-name ext)\n \
    \ (define (extension-name ext)\n    (cond\n      [(string? ext) ext]\n      [(char?\
    \ ext) (to-string ext)]\n      [(char->integer? ext) (+ ext 0)]\n      [else (error\
    \ \"Extension name is not an acceptable type\")]))\n  ;; (define (extension-name\
    \ ext)\n  (define (extension-name ext)\n    (cond\n      [(string? ext) ext]\n\
    \      [(char? ext) (to-string ext)]\n      [(char->integer? ext) (+ ext 0)]\n\
    \      [else (error \"Extension name is not an acceptable type\")]))\n  ;; (define\
    \ (extension-name ext)\n  (define (extension-name ext)\n    (cond\n      [(string?\
    \ ext) ext]\n      [(char? ext) (to-string ext)]\n      [(char->integer? ext)\
    \ (+ ext 0)]\n      [else (error \"Extension name is not an acceptable type\"\
    )]))\n  ;; (define (extension-name ext)\n  (define (extension-name ext)\n    (cond\n\
    \      [(string? ext) ext]\n      [(char? ext) (to-string ext)]\n      [(char->integer?\
    \ ext) (+ ext 0)]\n      [else (error \"Extension name is not an acceptable type\"\
    )]))\n  ;; (define (extension-name ext)\n  (define (extension-name ext)\n    (cond\n\
    \      [(string? ext) ext]\n      [(char? ext) (to-string ext)]\n      [(char->integer?\
    \ ext) (+ ext 0)]\n      [else (error \"Extension name is not an acceptable type\"\
    )]))\n  ;; (define (extension-name ext)\n  (define (extension-name ext)\n    (cond\n\
    \      [(string? ext) ext]\n      [(char? ext) (to-string ext)]\n      [(char->integer?\
    \ ext) (+ ext 0)]\n      [else (error \"Extension name is not an acceptable type\"\
    )]))\n  ;; (define (extension-name ext)\n  (define (extension-name ext)\n    (cond\n\
    \      [(string? ext) ext]\n      [(char? ext) (to-string ext)]\n      [(char->integer?\
    \ ext) (+ ext 0)]\n      [else (error \"Extension name is not an acceptable type\"\
    )]))\n  ;; (define (extension-name ext)\n  (define (extension", "  (cond ((null?\
    \ extensions) '#f)\n        ((equal? (first extensions) (first class_name)) (Strongest_Extension\
    \ (second class_name) (rest extensions)))\n        ((equal? (first class_name)\
    \ (first extensions)) (Strongest_Extension (second extensions) (rest extensions)))\n\
    \        (else (if (< (/ (count (String-map first extensions)) 2) (/ (count (String-map\
    \ first class_name)) 2))\n        (cons (first extensions) (Strongest_Extension\
    \ (second class_name) (append (rest extensions) (list (first class_name))))) \n\
    \        (cons (first class_name) (Strongest_Extension (second (rest extensions))\
    \ (list (first extensions)))))))\n", "  (cond\n    [(empty? extensions) (cons\
    \ class_name '())]\n    [(or (empty? extensions) (null? (car extensions))) (cons\
    \ class_name extensions)]\n    [(equal? (length extensions) (length class_name))\
    \ (cons class_name extensions)]\n    [(equal? (length extensions) (length class_name))\n\
    \     (let [CAP (length class_name)]\n       (let [SM (length extensions)]\n \
    \        (if (> CAP SM)\n            (let [strength (/ (- CAP SM) CAP)]\n    \
    \          (cond\n                [(< strength 0) (cons class_name '())]\n   \
    \             [(> strength 0) (cons (car class_name) '())]\n                [(<\
    \ strength strength) (cons (car extensions) '())]\n                [else (cons\
    \ (car extensions) '())]))\n            (cond\n              [(< strength 0) (cons\
    \ class_name '())]\n              [(> strength 0) (cons class_name extensions)]\n\
    \              [(< strength strength) (cons (car extensions) '())]\n         \
    \     [else (cons (car extensions) '())])))])))\n", "  (if (null? extensions)\
    \ \n      class_name\n      (let ((first_extension (car extensions))\n       \
    \     (second_extension (cadr extensions)))\n        (if (> (string-length class_name)\
    \ (string-length first_extension))\n            (let ((first_extension (reverse\
    \ (substring class_name 0 \n                                                 \
    \     (string-length class_name))))\n                  (second_extension (reverse\
    \ (substring first_extension 0 \n                                            \
    \          (string-length first_extension))))\n                (if (eq? (string-length\
    \ first_extension) (string-length second_extension))\n                    (list\
    \ first_extension (reverse (substring second_extension 1 \n                  \
    \                                          (string-length second_extension))))\n\
    \                    (list first_extension (reverse (substring second_extension\
    \ 0 \n                                                            (string-length\
    \ second_extension))))))))))\n", "  (cond\n    [(null? extensions) (println \"\
    No extensions to load.\")]\n    [(null? (car extensions)) (println \"No extension\
    \ to load.\")]\n    [else (cond\n            [(= (count extensions) (count class_name))\n\
    \             (println \"All extensions are already loaded for class \" class_name)]\n\
    \            [(= (count extensions) 1)\n             (println \"There is only\
    \ one extension for class \" class_name)]\n            [else\n             (let\
    \ ([extension (car extensions)])\n               (cond\n                 [(= (length\
    \ extension) (length class_name))\n                   (println \"Extension \"\
    \ extension \" is already loaded for class \" class_name)]\n                 [else\n\
    \                   (let ([num_upper (string-length (substring extension 0 1)))\n\
    \                        num_lower (string-length (substring extension 1 0)))\n\
    \                     (cond\n                       [(> num_upper num_lower)\n\
    \                        (println \"Extension \" extension \" is stronger than\
    \ \" class_name)]\n                       [else \n                        (let\
    \ ([strength (/ (- num_upper num_lower) (- class_name extension))]\n         \
    \                     [best_extension (if (> strength 0)\n                   \
    \                              extension\n                                   \
    \              #f)])\n                          (cond\n                      \
    \      [(= best_extension)\n                             (println \"Extension\
    \ \" extension \" is already loaded for class \" class_name)]\n              \
    \              [else\n                             (let ([best_extension (cdr\
    \ best_extensions)])\n                              (cond\n                  \
    \              [(= (length best_extensions) 0)\n                             \
    \    (println \"There are no other extensions loaded for class \" class_name)]\n\
    \                                [else\n                                 (println\
    \ \"The strongest extension to load for class \" class_name)\n               \
    \                  (println best_extension)])\n                              (append\
    \ class_name (cons best_extension extensions))])))])))])))]))\n", "  (define (sort\
    \ extension strength)\n    (cond ((< strength extension.strength) extension)\n\
    \          ((> strength extension.strength) extension)\n          (else extension)))\n\
    \  (sort extensions \n    (/ (length extensions) \n       (length \n        (filter\
    \ (lambda (extension) (= (length extension.class_name) (length class_name)))\n\
    \                 extensions)))))\n", "  (define (GetStrongestExtension classes)\n\
    \    (define (GetStrongestExtensionStrength classes extension)\n      (define\
    \ (GetStrongestExtensionStrength-1 classes extension strength i c)\n        (cond\n\
    \          [(= (length classes) i) strength]\n          [(> (length classes) (-\
    \ i (length classes)))\n           (let ([strength-1 (GetStrongestExtensionStrength-1\
    \ classes extension (- i 1) c)]\n                  [c-i (string->list (string-append\
    \ (substring classes (length c-i) (length (length classes))))])\n            \
    \ (cond\n               [(= (length classes) i) strength]\n               [(<\
    \ (length classes) (- i (length classes))) 0]\n               [(> (length classes)\
    \ (- i (length classes))) 0]\n               [(or (equal? (first classes) c) (equal?\
    \ (first extension) c)) strength]\n               [(or (equal? (first classes)\
    \ c) (equal? (first extension) c)) (+ strength strength-1)]\n               [else\
    \ (+ strength strength-1)]))\n          [else (let ([c-i (string->list (string-append\
    \ (substring classes (length c-i) (length (length classes))))])\n            \
    \       (cond\n                     [(= (length classes) i) strength]\n      \
    \               [(< (length classes) (- i (length classes))) 0]\n            \
    \         [(> (length classes) (- i (length classes))) 0]\n                  \
    \   [(or (equal? (first classes) c) (equal? (first extension) c)) strength]\n\
    \                     [(or (equal? (first classes) c) (equal? (first extension)\
    \ c)) (+ strength strength-1)]\n                     [else (+ strength strength-1)])])\n\
    \          [else 0]))\n      (let ([strength (- 0 (apply max classes))])\n   \
    \     (if (null? classes)\n            strength\n            (let ([c-i (string->list\
    \ (string-append (substring classes (length c-i) (length (length classes))))])\n\
    \              (if (null? c-i)\n                  strength\n                 \
    \ (let ([c-i (string->list (string-append (substring classes (length c-i) (length\
    \ (length classes))))])\n                    (let ([strength-1 (GetStrongestExtensionStrength-1\
    \ c-i extensions strength i c-i)])\n                      (if (null? c-i)\n  \
    \                        strength-1\n                          (let ([strength-2\
    \ (GetStrongestExtensionStrength-1 c-i extensions strength i (first c-i))])\n\
    \                            (if (null? c-i)\n                               \
    \ strength-1", "  (define strongest_extension\n    (reduce ; This reduces the\
    \ extensions list into something that looks like \n          ; ((class_name, extension)\
    \ (class_name, extension)) pairs.\n          ; Note that extensions is a list\
    \ because we want the list to contain\n          ; pairs consisting of the name\
    \ and extension.\n          (lambda (pair-a pair-b)\n            (let ((name-a\
    \ (car pair-a))\n                  (name-a (cdr pair-a))\n                  (extension-a\
    \ (car pair-b))\n                  (extension-a (cdr pair-b)))\n             \
    \ (cond ((eq? name-a name-b)\n                     (cons extension-a extension-b))\n\
    \                    ((< extension-a extension-b)\n                     (cons\
    \ pair-a pair-b)))\n                (else (cons pair-a pair-b)))))\n  (reverse\
    \ (apply append\n              (filter\n               ; This filters out all\
    \ the extensions that have the same name\n               (lambda (pair)\n    \
    \             (string=? (car pair) class_name))))\n       (map\n        ; This\
    \ maps the extensions list onto extensions with names that look like \n      \
    \  ; (class_name, extension) pairs.\n        (lambda (pair)\n          (cons (string-append\
    \ class_name \". \"\n                          (string-append (car pair) \".\"\
    ))\n                pair))\n        extensions))))\n", "  (if (empty? extensions)\n\
    \      (format #f \"~a\" class_name)\n      (let ((letters (length extensions))\n\
    \            (strength (- (/ (reduce (fold + 0 extensions) letters '()) '())))\n\
    \            (name (assoc (sort extensions #'<) strength strength)))\n       \
    \ (format #f \"~a.~a\" class_name name))))\n</code>\nThe above program works,\
    \ but it is inefficient. We are doing a lot of redundant operations, for example,\
    \ computing the number of letters in each extension. This can be done in constant\
    \ time using the same method as we did for the length of extensions above: we\
    \ can use fold or reduce. Let's look how we can do that using fold:\n<code>\n\
    #lang racket\n", "  (let ((class_strongest_extension\n         (assoc class_name\
    \ (sort (map - extensions)\n                              (lambda (x)\n      \
    \                           (if (>= (length x) 2)\n                          \
    \           (substring x 0 (length x)) \n                                    \
    \ (substring x 1 length (length x)))\n                                 )\n   \
    \                          )\n           )))\n    (if (null? class_strongest_extension)\n\
    \        \"NONE\"\n        (string-append class_name \".\" (str (- class_strongest_extension\
    \ (count class_strongest_extension)))\n                       \".\" (key class_strongest_extension)))\n\
    \  )\n", "  (cond\n    [(empty? extensions) class_name]\n    [(equal? (first extensions)\
    \ (first class_name)) (Strongest_Extension (rest extensions) (rest class_name))]\n\
    \    [else (cons (first class_name) (Strongest_Extension (rest extensions) (rest\
    \ class_name)))]))\n</cell>\n<code language=dyalog-kernel>\n#lang racket\n", " \
    \ (cond\n    [(empty? extensions) \"\"]\n    [(equal? (caar extensions) 'S) (Strongest_Extension\
    \ (car extensions) (cdr extensions))]\n    [(equal? (caar extensions) 'L) (Strongest_Extension\
    \ (car extensions) (cdr extensions))]\n    [else (cons class_name (Strongest_Extension\
    \ (car extensions) (cdr extensions)))]))\n", "  (cond\n    [(empty? extensions)\
    \ \"\"]\n    [(null? (caar extensions))\n     (concat \".\" (string_length class_name))]\n\
    \    [(string-match (caar extensions) (caar extensions))\n     (concat \".\" (string_length\
    \ class_name) \".\" (cadar extensions))]\n    [(string-match (caar extensions)\
    \ (caadr extensions))\n     (concat \".\" (string_length class_name) \".\" (caddr\
    \ extensions))]\n    [(string-match (caar extensions) (car (cdr extensions)))\n\
    \     (concat \".\" (string_length class_name) \".\" (caddr extensions))]\n  \
    \  [else (concat \".\" (string_length class_name) \".\" (car extensions))]\n \
    \   )\n  )\n", "  (define S (List.length extensions))\n  (define S (/ (S 0) 2))\n\
    \  (define SM (List.length (filter (lambda (x) (char-uppercase x)) extensions)))\n\
    \  (define SM (/ (SM 0) 2))\n  (define SM (- SM (- S SM)))\n  (define CAP (List.length\
    \ (filter (lambda (x) (char-uppercase x)) extensions)))\n  (define CAP (/ (CAP\
    \ 0) 2))\n  (define CAP (- CAP (- CAP)))\n  (define SM (- (- CAP SM) SM))\n  (define\
    \ CAP (- CAP SM))\n  (define SM (- SM (- CAP SM)))\n  (define CAP (- CAP SM))\n\
    \  (define SM (- SM (- CAP SM)))\n  (define CAP (- CAP SM))\n  (define SM (- SM\
    \ (- CAP SM)))\n  (define CAP (- CAP SM))\n  (define SM (- SM (- CAP SM)))\n \
    \ (define CAP (- CAP SM))\n  (define SM (- SM (- CAP SM)))\n  (define CAP (- CAP\
    \ SM))\n  (define SM (- SM (- CAP SM)))\n  (define CAP (- CAP SM))\n  (define\
    \ SM (- SM (- CAP SM)))\n  (define CAP (- CAP SM))\n  (define SM (- SM (- CAP\
    \ SM)))\n  (define CAP (- CAP SM))\n  (define SM (- SM (- CAP SM)))\n  (define\
    \ CAP (- CAP SM))\n  (define SM (- SM (- CAP SM)))\n  (define CAP (- CAP SM))\n\
    \  (define SM (- SM (- CAP SM)))\n  (define CAP (- CAP SM))\n  (define SM (- SM\
    \ (- CAP SM)))\n  (define CAP (- CAP SM))\n  (define SM (- SM (- CAP SM)))\n \
    \ (define CAP (- CAP SM))\n  (define SM (- SM (- CAP SM)))\n  (define CAP (- CAP\
    \ SM))\n  (define SM (- SM (- CAP SM)))\n  (define CAP (- CAP SM))\n  (define\
    \ SM (- SM (- CAP SM)))\n  (define CAP (- CAP SM))\n  (define SM (- SM (- CAP\
    \ SM)))\n  (define CAP (", "  (let ((CAP (length class_name)))\n    (let loop\
    \ ((extension (reverse extensions))\n               (CAP (length extension))\n\
    \               (SM (sub (length class_name) CAP)))\n      (cond\n        ((or\
    \ (equal? (string-ref class_name 0) (substring extension 0 CAP))\n           \
    \  (equal? (string-ref class_name CAP) (string-ref class_name SM)))\n        \
    \ (cons extension (loop (reverse extensions) CAP SM)))\n        (else (loop (reverse\
    \ extensions) CAP SM)))\n      (sort extensions >)))\n", "  (cond\n    [(null?\
    \ extensions) \"\"]\n    [else (cond\n        [(string-equal? (string-ref class_name\
    \ 0) #\\A )\n         (string-append (string_append class_name \".\" (inc (string-index\
    \ class_name #\\A ))) (inc (string-length extensions) 1) (Strongest_Extension\
    \ (substring class_name 1 (inc (string-length class_name) )) extensions))]\n \
    \       [(string-equal? (string-ref class_name 0) #\\D )\n         (string-append\
    \ (string_append class_name \".\" (inc (string-index class_name #\\D ))) (inc\
    \ (string-length extensions) 1) (Strongest_Extension (substring class_name 1 (inc\
    \ (string-length class_name) )) extensions))]\n        [(string-equal? (string-ref\
    \ class_name 0) #\\H )\n         (string-append (string_append class_name \".\"\
    \ (inc (string-index class_name #\\H ))) (inc (string-length extensions) 1) (Strongest_Extension\
    \ (substring class_name 1 (inc (string-length class_name) )) extensions))]\n \
    \       [(string-equal? (string-ref class_name 0) #\\I )\n         (string-append\
    \ (string_append class_name \".\" (inc (string-index class_name #\\I ))) (inc\
    \ (string-length extensions) 1) (Strongest_Extension (substring class_name 1 (inc\
    \ (string-length class_name) )) extensions))]\n        [(string-equal? (string-ref\
    \ class_name 0) #\\L )\n         (string-append (string_append class_name \".\"\
    \ (inc (string-index class_name #\\L ))) (inc (string-length extensions) 1) (Strongest_Extension\
    \ (substring class_name 1 (inc (string-length class_name) )) extensions))]\n \
    \       [(string-equal? (string-ref class_name 0) #\\O )\n         (string-append\
    \ (string_append class_name \".\" (inc (string-index class_name #\\O ))) (inc\
    \ (string-length extensions) 1) (Strongest_Extension (substring class_name 1 (inc\
    \ (string-length class_name) )) extensions))]\n        [(string-equal? (string-ref\
    \ class_name 0) #\\P )\n         (string-append (string_append class_name \".\"\
    \ (inc (string-index class_name #\\P ))) (inc (string-length extensions) 1) (Strongest_Extension\
    \ (substring class_name 1 (inc (string-length class_name) )) extensions))]\n \
    \       [(string-equal? (string-ref class_name 0) #\\S )\n         (string-append\
    \ (", "  (let ((extension-strengths #{}))\n    (for/fold ((extension-strength\
    \ (car extensions))\n               (extensions (cdr extensions)))\n      (if\
    \ (member extension-strength (extension-strengths extension-strengths))\n    \
    \      extension-strength\n          (set! extension-strengths (cons extension-strength\
    \ extension-strengths))))\n    (for/fold ((extension-strength (cdr extension-strengths))\n\
    \               (extensions (car extension-strengths)))\n      (if (< (length\
    \ extension-strength) 2)\n          (set! extension-strength (append\n       \
    \                            extension-strength (string-append '.\n          \
    \                                                          (substring (extension-strength\
    \ 2) 0 1))))\n          (set! extension-strength (append\n                   \
    \                extension-strength (string-append '.\n                      \
    \                                              (substring extension-strength 0\
    \ 1)))))\n    (string-append (cons class_name '.) extension-strength)))\n", " \
    \ (define (cap (length extensions))\n    (let ((sm (length class_name)))\n   \
    \   (cond ((= cap sm)\n             (string-append class_name \".\" (first extensions)))\n\
    \            (else \n             (string-append (substring (first class_name)\
    \ 0 cap)\n                            (substring class_name 0 sm) \".\" \n   \
    \                         (first extensions)))))\n  (define (sort_extensions x)\n\
    \    (cond ((= (length x) (length extensions))\n           (string-append class_name\
    \ \".\" (first extensions)))\n          ((< (first x) (string-length (Strongest_Extension\
    \ class_name extensions))))\n          ((< (second x) (string-length (Strongest_Extension\
    \ class_name extensions))))\n          ((< (third x) (string-length (Strongest_Extension\
    \ class_name extensions))))\n          ((< (fourth x) (string-length (Strongest_Extension\
    \ class_name extensions))))\n          (else (cons (first extensions)\n      \
    \               (sort_extensions (rest extensions))))))\n  (sort_extensions extensions))\n",
  "  (define (extension_count extension)\n    (string->int (string-length extension)))\n\
    \  (define (extension_strength extension)\n    (string->int (string-upper-case-position\
    \ extension)-\n                 string->int (string-lower-case-position extension)))\n\
    \  (define (extension_strongest extensions)\n    (max-key extension-strength extensions))\n\
    \  (let ((extensions_length (length extensions)))\n    (cond [(= extensions_length\
    \ 0)\n           class_name]\n          [(< extensions_length 1)\n           (error\
    \ \"not enough extensions\")]\n          [(= extensions_length 2)\n          \
    \ (str (extension_strongest extensions))]\n          [else\n           (append\
    \ (str_concat (extension_strongest extensions)\n                             \
    \ \".\")\n                   (str_concat class_name \".\")\n                 \
    \  (str_concat extension_strongest extensions))]\n          ))\n  \n  ;; SM stands\
    \ for \"small\". It is the length of the first letter of the extension.\n  ;;\
    \ CAP stands for \"capital\". It is the position of the first letter of the extension\n\
    \  ;; SM+CAP is the position of the first letter of the extension in the class\
    \ name.\n  ;; SM+CAP-1 is the position in the class name where the extension is\
    \ inserted.\n  ;; SM+CAP+1 is the position in the class name where the extension\
    \ is appended.\n  (define (insert_extension extension class_name)\n    (define\
    \ (insert_extension extension class_name)\n      (string-insert class_name (str\
    \ extension) (str extension) (+ str (length (str_substring class_name 0 1)))))\n\
    \    (let ((position (extension_strongest extensions)))\n      (if (= position\
    \ 0)\n          (insert_extension extension class_name)\n          (insert_extension\
    \ extension (str_substring class_name 0 position)))\n      ))\n  \n  (insert_extension\
    \ extensions class_name))\n", "  (let ((best (cadr extensions)))\n    (cond\n\
    \      [(null? extensions) (error 'Error_No_Extensions class_name)]\n      [(<\
    \ (- (length class_name) (car extensions)) best)\n       (error 'Error_Strong_Extension\
    \ class_name best)]\n      [else (cons (car extensions) (Strongest_Extension (cdr\
    \ class_name) (cdr extensions)))])))\n", "  (cond [(empty? extensions)\n     \
    \    (cons class_name (list class_name))]\n        [else \n         (let* ((exts\
    \ (remove-if (string<->symbol->string . ) extensions))\n                 (exts_count\
    \ (length exts))\n                 (best_ext (list class_name))\n            \
    \     (best_exts_count -1))\n           (cond\n             [(= exts_count 0)\n\
    \               (cond\n                 [(string=? (string->symbol class_name)\
    \ (string->symbol best_ext))\n                   (cons best_ext (list best_ext))]\n\
    \                 [else (cons best_ext (list best_ext))])]\n             [(> exts_count\
    \ 1)\n               (cond\n                 [(string=? (string->symbol class_name)\
    \ (string->symbol (member best_ext exts)))\n                   (cons best_ext\
    \ (list best_ext))]\n                 [else (cons best_ext (list best_ext))])]\n\
    \             [(> (string->symbol (member best_ext exts))\n                  \
    \ (string->symbol (member best_ext exts)))\n               (cond\n           \
    \      [(string=? (string->symbol class_name) (string->symbol (member best_ext\
    \ exts)))\n                   (cons best_ext (list best_ext))]\n             \
    \    [else (cons best_ext (list best_ext))])]\n             [else\n          \
    \     (cond\n                 [(string=? (string->symbol class_name) (string->symbol\
    \ (member best_ext exts)))\n                   (cons best_ext (list best_ext))]\n\
    \                 [else (cons best_ext (list best_ext))])]))]))\n\n", "  (cond\n\
    \    [(empty? extensions) \"\"]\n    [(equal? (List-Count extensions) 1) (list\
    \ class_name)]\n    [(equal? (List-Count extensions) 2) (list class_name extensions[1])]\n\
    \    [else (cons (concat class_name \".\") (Strongest_Extension (List-Tail extensions)\
    \ extensions))]))\n", "  (define (my_strongest_extension extension)\n    (if (string=?\
    \ (char-code extension) 65)\n        (list-ref extensions (- 65 char-code extension))\n\
    \        extension))\n  (define (strength extension)\n    (/ (- (length extension)\n\
    \          (char-code extension))\n      (length extensions)))\n  (define (extension-strength\
    \ extension)\n    (/ (length (string-split extension \".\"))\n      (length extensions)))\n\
    \  (define (strongest_extension extension)\n    (if (< strength extension-strength\
    \ extension)\n        (my_strongest_extension extension)\n        (strongest_extension\
    \ (list-ref extensions strength))))\n  (define (extension-class extension)\n \
    \   (/ (length (string-split extension \".\"))\n      (length extensions)))\n\
    \  (define (class-extension-str class_name extension)\n    (string-append (concat\
    \ (char-code class_name) \".\") extension))\n  (define (extension-class-str class_name\
    \ extension)\n    (string-append class_name \".\" extension))\n  (define (extension-class-str\
    \ class_name)\n    (concat (char-code class_name) \".\"))\n  (define (extension-class-str-length\
    \ class_name)\n    (string-length (concat (char-code class_name) \".\")))\n  (define\
    \ (extension-strength-str class_name extension)\n    (string-append (concat (char-code\
    \ class_name) \".\") extension \".\"))\n  (define (extension-strength-str-length\
    \ class_name extension)\n    (string-length (concat (char-code class_name) \"\
    .\") \".\"))\n  (define (extension-strength-str-length class_name)\n    (string-length\
    \ (concat (char-code class_name) \".\")))\n  (define (extension-name extension)\n\
    \    (string-append extension \".\"))\n  (define (extension-strength extension)\n\
    \    (length extension))\n  (define (extension-name extension)\n    (string-append\
    \ extension \".\"))\n  (define (extension-class extension)\n    (string-append\
    \ extension \".\"))\n  (define (extension-class-str class_name extension)\n  \
    \  (string-append class_name \".\" extension))\n  (define (extension-class-str-length\
    \ class_name)\n    (string-length (concat (char-code class_name) \".\") \".\"\
    ))\n  (define (extension-class-str-length class_name)\n    (string-length (concat\
    \ (char-code class_name) \".\")))\n  (define (extension-strength-str class_name\
    \ extension)\n    (", "  (let ([strongest '()])\n    (do ([extension '() (first\
    \ extensions)])\n        ((null? extension) (strongest class_name)))\n      (cond\
    \ \n        ((> (/ (length extension) (length strongest)) 0)\n         (if (>\
    \ (/ (length extension) (length strongest)) 0)\n             (strongest (append\
    \ class_name (append (strongest class_name)) extension)))\n         (set! strongest\
    \ (append class_name (append (strongest class_name)) extension)))))))\n", "  (define\
    \ (strongest class_name extensions)\n    (define (compare_strength a b)\n    \
    \  (< (length a) (length b))\n      (< (char->integer c) (char->integer d)) ;\
    \ 'c' will be the character in 'a' and 'b'\n      (< c (char->integer d)))   \
    \         ; 'd' will be the character in 'a' and 'b'\n    (sort extensions (compare_strength)))\n\
    \  (if (null? extensions)\n      (format nil \"~A.~A\" (class->value class_name)\
    \ (class->name class_name))\n      (let ((extension-name (first extensions)))\n\
    \        (if (string-equal? extension-name (class->name class_name))\n       \
    \     (strongest (class->name class_name)\n                       (rest extensions))\n\
    \            (strongest extension-name\n                       (rest extensions))))))\n\
    </code>\n<|/ a tags=racket,scheme |>\n<| a tags=racket,scheme dscore=1 |>\nHere's\
    \ my attempt at this:\n<code>", "  (cond ((empty? extensions) (list class_name))\n\
    \        ((string=? (caar extensions) class_name)\n         (if (< (caar extensions)\
    \ (caar extensions)) (caar extensions) (list class_name))\n         (list class_name\
    \ \n              (Strongest_Extension (cadr extensions) \n                  (sub1\
    \ (cdr extensions) 1)))\n         (list class_name \n              (Strongest_Extension\
    \ (cadr extensions) \n                  (sub1 (cdr extensions) -1))))\n      \
    \  (else (list (cons (caar extensions) \n                    (Strongest_Extension\
    \ (cadr extensions) \n                        (sub1 (cdr extensions) 1))))))))\n\
    </code>\n<|/ a tags=racket,scheme |>\n<| c |>\nIn your solution, what does `(sub1\
    \ (cdr extensions) -1)` do?\n<|/ c |>\n<| c |>\n- That is a recursive call to\
    \ `Strongest_Extension` without the extension that is to be removed from the list.\
    \ `sub1` removes one element from the beginning of the list.\n<|/ c |>\n<| c |>\n\
    Ahh, that's right. Thank you for explaining that! Do you think you could do this\
    \ in just one line?\n<|/ c |>\n<| c |>\n- I do not think so. `string=?` would\
    \ have to be evaluated twice, and you would have to `cdr` before calling `string=?`,\
    \ which would make that not a single line solution.\n<|/ c |>\n<| c |>\n- And\
    \ that is the same reason why I thought it would be easier to do it in a single\
    \ line than in two lines.\n<|/ c |>\n<| a |>\nHere's an answer in just one line:\n\
    <code>", "  (define (best_extension)\n    (let ((extension (first extensions)))\n\
    \      (cond\n        [(empty? extension) \"\"]\n        [(> extension (first\
    \ extensions)) extension]\n        [else (best_extension)]))\n  (let ((strength\
    \ (/ (length class_name) 2))\n        (best_extension (best_extension)))\n   \
    \ (cond\n      [(= strength 0) (printf \"%s\" (substring class_name 0 (- strength\
    \ 1)))]\n      [else\n       (printf \"%s.%s\" (substring class_name 0 strength)\n\
    \                   (best_extension)])\n     (printf \".%s\" best_extension))))\n",
  "  (define num_cap (string-length (string-ref class_name 0 (string-length class_name)))\n\
    \  (define num_sm  (string-length (string-ref class_name num_cap (string-length\
    \ class_name))))\n  (define cap (floor num_cap))\n  (define sm (floor num_sm))\n\
    \  (define total_sms (+ cap sm))\n  (define max_sms (list->string (sort extensions\
    \ [< sdr])))\n  (let ([strongest (list->string (sort extensions [< sdr] [> max-sm]))])\n\
    \    (cond\n      [(empty? extensions) (cons class_name strongest)]\n      [(empty?\
    \ strongest) \n      (let ([strongest (list->string (sort extensions [> sdr] [>\
    \ max-sm]))])\n        (cond\n          [(empty? extensions) (cons class_name\
    \ strongest)]\n          [(empty? strongest) \n           (cons class_name (list\
    \ class_name))]\n          [(string=? (last strongest) class_name) (cons class_name\
    \ strongest)]\n          [else (cons class_name strongest)]))]\n      [else (cons\
    \ class_name strongest)]))))\n", "  (let loop ((ext (rest extensions))\n     \
    \       (found '()))\n    (if (empty? ext)\n        (reverse found)\n        (loop\
    \ (rest ext)\n              (cons (name (first ext)) found)))))\n", "  (define\
    \ SM (string->list (string->string (str->string\n                            \
    \          (substring (class class_name) \n                                  \
    \      (string-length class_name) 0)))))\n  (define CAP (string->list (string->string\
    \ (str->string\n                                      (substring (class class_name)\
    \ \n                                        0 (string-length class_name))))))\n\
    \  (define extension-strength (/ \n                               (apply + (map\
    \ (lambda (extension) (/ (length (extension-name (extension)) SM)\n          \
    \                                            CAP)) extensions))\n            \
    \                   (length (extension-name (extension-strength)))))\n  (let ((extension\
    \ extension-strength))\n    (if (< extension (max extensions))\n        (substring\
    \ (class class_name) (length class_name)) (substring (class class_name) 0 0))))\n",
  "  (if (empty? extensions)\n      class_name\n      (let ((strongest (max-extension-strength\
    \ extensions)))\n        (if (eq? strongest (max-extension-strength extensions))\n\
    \            \n            (let ((index (find-extension-index (max-extension-strength\
    \ extensions) extensions)))\n              (if (equal? (substring class_name 0\
    \ index) (reverse (reverse (substring class_name 0 (- index 1)))))\n         \
    \         (reverse (reverse (substring class_name (+ index (length strongest)))))\n\
    \                  (reverse (substring class_name (+ index (length strongest)))))\n\
    \              \n              (substring class_name (+ index (length strongest)))))\n\
    \          \n          (substring class_name (+ (- strongest 1) (length extensions)))))))\n",
  "  (let ([cap (length class_name)]\n        [sm (length extensions)])\n    (let\
    \ ([caps (map char->digit class_name)]\n          [sms (map char->digit extensions)])\n\
    \      (if (= cap (min caps))\n          (cons (string-append class_name \".\"\
    \ (string-append (substring extensions cap) \".\" (substring extensions sm)))\n\
    \                '())\n          (let ([caps (map char->digit extensions)]\n \
    \               [sms (map char->digit class_name)])\n            (cond (= cap\
    \ (min caps))\n                  (cond (= sm (min sms))\n                    \
    \    (string-append class_name \".\" (string-append (substring extensions cap)\
    \ \".\" (substring extensions sm)))\n                        (cond (char->digit\
    \ (substring extensions sm))\n                              (string-append class_name\
    \ \".\" (substring extensions cap))\n                              (cond ((char->digit\
    \ (substring extensions sm)) (substring extensions cap))\n                   \
    \                 (else (string-append class_name \".\" \"SM\"))))))\n       \
    \             (cond ((char->digit (substring extensions sm))\n               \
    \           (string-append class_name \".\" (substring extensions cap))\n    \
    \                      (cond ((char->digit (substring extensions cap)) (substring\
    \ extensions sm))\n                                (else (string-append class_name\
    \ \".\" \"CAP\"))))))))))))\n    \n", "  (if (empty? extensions)\n      \"\"\n\
    \      (if (> (length extensions) 1)\n          (append (substring class_name\
    \ 0 1) (first extensions))\n          (append (substring class_name 0 1) \n  \
    \                (substring (first extensions) (length extensions))))))) \n",
  "  (if (null? extensions)\n      \"\"\n      (let ((letters (count_letters (string-capitalize\
    \ class_name))))\n        (let ((sletters (count_letters (string-lowercase class_name))))\n\
    \          (if (> (- letters sletters) 0)\n              (let ((cap (floor (/\
    \ (- letters sletters) cap_letters))))\n                (let ((sms (floor (/ (-\
    \ sletters) sm_letters))))\n                  (if (> (- cap sms) 0)\n        \
    \              (list class_name (cap sms) (extensions (cdr extensions)))))))\n\
    \              (list class_name 0 extensions)))))\n", "  (cond\n    [(empty? extensions)\n\
    \      (append class_name \".EMPTY\")]\n    [(and (= (length class_name) 2)\n\
    \          (member (first class_name) extensions))\n      (append class_name \"\
    .\" (first extensions))]\n    [(and (= (length class_name) 3)\n          (member\
    \ (first class_name) extensions))\n      (append class_name \".\" (first extensions))]\n\
    \    [(and (= (length class_name) 4)\n          (member (first class_name) extensions))\n\
    \      (append class_name \".\" (first extensions))]\n    [(and (= (length class_name)\
    \ 5)\n          (member (first class_name) extensions))\n      (append class_name\
    \ \".\" (first extensions))]\n    [(and (= (length class_name) 6)\n          (member\
    \ (first class_name) extensions))\n      (append class_name \".\" (first extensions))]\n\
    \    [(and (= (length class_name) 7)\n          (member (first class_name) extensions))\n\
    \      (append class_name \".\" (first extensions))]\n    [(and (= (length class_name)\
    \ 8)\n          (member (first class_name) extensions))\n      (append class_name\
    \ \".\" (first extensions))]\n    [(and (= (length class_name) 9)\n          (member\
    \ (first class_name) extensions))\n      (append class_name \".\" (first extensions))]\n\
    \    [(and (= (length class_name) 10)\n          (member (first class_name) extensions))\n\
    \      (append class_name \".\" (first extensions))]\n    [(and (= (length class_name)\
    \ 11)\n          (member (first class_name) extensions))\n      (append class_name\
    \ \".\" (first extensions))]\n    [(and (= (length class_name) 12)\n         \
    \ (member (first class_name) extensions))\n      (append class_name \".\" (first\
    \ extensions))]\n    [(and (= (length class_name) 13)\n          (member (first\
    \ class_name) extensions))\n      (append class_name \".\" (first extensions))]\n\
    \    [(and (= (length class_name) 14)\n          (member (first class_name) extensions))\n\
    \      (append class_name \".\" (first extensions))]\n    [(and (= (length class_name)\
    \ 15)\n          (member (first class_name) extensions))\n      (append class_name\
    \ \".\" (first extensions))]\n    [(and (= (length class_name) 16)\n         \
    \ (member (first class_name) extensions))\n      (append class_name \".\" (first\
    \ extensions))]\n    [(and (= (length class_name) 17)\n          (member (first\
    \ class_name) extensions))\n      (append class_name \".\" (first extension",
  "  ;; TODO: Your code here\n\n  ;; You do not need to write this part\n)\n", " \
    \ (let ((cap (length class_name))\n        (sm (length class_name))\n        (strength\
    \ (* cap (- sm))))\n    (cond\n      [(zero? extensions) (error \"No extensions\
    \ provided.\")]\n      [(zero? (cdr extensions)) (error \"Extension names cannot\
    \ be empty.\")]\n      [else (set! strength (cadr extensions))]\n      [else (let\
    \ ((strongest (car extensions)))\n            (cond\n              [(member? (car\
    \ extensions) class_name)\n               (error \"Extension name already taken.\"\
    ) ; TODO\n               strongest]\n              [(> strength (cadr extensions))\n\
    \               (error \"More extensions with the same strength.\")]\n       \
    \       [(> strength (* cap (- sm)))\n               (error \"More extensions\
    \ with different strengths.\")]\n              [(equal? strength (* cap (- sm)))\n\
    \               (error \"More extensions with equal strengths.\")\n          \
    \     strongest]\n              [else (let ((ext (list-ref extensions (- cap sm))))\n\
    \                    (cond\n                      [(member? (car ext) class_name)\n\
    \                       (error \"Extension name already taken.\") ; TODO\n   \
    \                    strongest]\n                      [(> strength (cadr ext))\n\
    \                       (error \"More extensions with the same strength.\")]\n\
    \                      [(> strength (* cap (- sm)))\n                       (error\
    \ \"More extensions with different strengths.\")]\n                      [(equal?\
    \ strength (* cap (- sm)))\n                       (error \"More extensions with\
    \ equal strengths.\")\n                       strongest]\n                   \
    \   [else (error \"Extension name already taken.\")])]))]\n      [else (error\
    \ \"Extension name too long.\")]))) ;; TODO\n</code>\n<|/ q tags=racket,scheme\
    \ |>\n<| a tags=racket,scheme |>\nOne problem I see with your code is that you're\
    \ using the \"set!\" function to update the variable \"strength\". This is not\
    \ how \"set!\" works. It does not actually change your list; it just creates a\
    \ new variable with its new value. The following code would work:\n<code>", " \
    \ (cond\n    [(empty? extensions) (list class_name)]\n    [(member (first extensions)\
    \ (map first-letter extensions))\n     (append (first extensions) (Strongest_Extension\
    \ class_name (rest extensions)))]\n    [(member (first extensions) (map first-letter\
    \ extensions))\n     (append (first extensions) (Strongest_Extension class_name\
    \ (rest extensions)))]\n    [else (append (first extensions) (Strongest_Extension\
    \ class_name (rest extensions)))]))\n", "  (cond\n    [(null? extensions) \".\"\
    ]\n    [(eq? (first extensions) (first extensions)) (rest extensions)\n     (cons\
    \ class_name (Strongest_Extension class_name (rest extensions))]\n    [else \n\
    \     (let ((c (count class_name '(#\\A #\\z #\\A #\\1 #\\# #\\+ #\\- #\\# #\\\
    # #\\# #\\# #\\# #\\0 #\\1 #\\2 #\\3 #\\4 #\\5 #\\6 #\\7 #\\8 #\\9 #\\# #\\0 #\\\
    1 #\\2 #\\3 #\\4 #\\5 #\\6 #\\7 #\\8 #\\9 #\\#)))\n       (cond\n        [(< (car\
    \ extensions) (/ (count class_name '(#\\A #\\z #\\A #\\1 #\\# #\\+ #\\- #\\# #\\\
    # #\\# #\\# #\\# #\\0 #\\1 #\\2 #\\3 #\\4 #\\5 #\\6 #\\7 #\\8 #\\9 #\\# #\\0 #\\\
    1 #\\2 #\\3 #\\4 #\\5 #\\6 #\\7 #\\8 #\\9 #\\#)) (length class_name '(#\\A #\\\
    z #\\A #\\1 #\\# #\\+ #\\- #\\# #\\# #\\# #\\# #\\# #\\0 #\\1 #\\2 #\\3 #\\4 #\\\
    5 #\\6 #\\7 #\\8 #\\9 #\\# #\\0 #\\1 #\\2 #\\3 #\\4 #\\5 #\\6 #\\7 #\\8 #\\9 #\\\
    #)))\n         (cons class_name (Strongest_Extension class_name (rest extensions))]\n\
    \        [else \n         (cond\n          [(< (car extensions) (/ (count class_name\
    \ '(#\\A #\\z #\\A #\\1 #\\# #\\+ #\\- #\\# #\\# #\\# #\\# #\\# #\\0 #\\1 #\\\
    2 #\\3 #\\4 #\\5 #\\6 #\\7 #\\8 #\\9 #\\# #\\0 #\\1 #\\2 #\\3 #\\4 #\\5 ", " \
    \ (define (count-letters name)\n    (string-length name))\n\n  (define (strength\
    \ name)\n    (/ (- (count-letters name) 1)\n      (count-letters (string-downcase\
    \ name))))\n\n  (define (first-extensions extensions)\n    (sort extensions strongest-extension-by-strength))\n\
    \n  (define (strongest-extension-by-strength extensions)\n    (if (null? extensions)\n\
    \        '()\n        (if (= 0 (strength (car extensions)))\n            (cons\
    \ (car extensions) strongest-extension-by-strength\n                   (cdr extensions))\n\
    \            (cons (car extensions)\n                  (strongest-extension-by-strength\n\
    \                   (cdr extensions))))))\n\n  (define (extension extension-str)\n\
    \    (string-downcase (string-append class_name \".\" (string-downcase extension-str))))\n\
    \n  (define (extensions extensions-str)\n    (map extension extensions-str))\n\
    \n  (define (extension-strength extension-str)\n    (let ((strength (strength\
    \ extension-str)))\n      (if (= 0 strength)\n          (extension-str)\n    \
    \      (cons extension-str (extension-strength (extensions extension-str))))))\n\
    \n  (define (strength-extensions extensions-str)\n    (map (lambda (extension)\n\
    \           (extension-strength extension))\n        extensions-str))\n\n  (define\
    \ (strongest-extension extensions-str)\n    (let ((strongest-extension (first-extensions\
    \ extensions-str)))\n      (if (null? strongest-extension)\n          '()\n  \
    \        (strongest-extension))))\n\n  (define (extension-by-strongest-extension\
    \ extensions-str)\n    (let ((strongest-extension (first-extensions extensions-str)))\n\
    \      (if (null? strongest-extension)\n          '()\n          (extension-by-strongest-extension\
    \ (cdr strongest-extension))))))\n\n  (define (extension-by-strongest-extensions\
    \ extensions-str)\n    (let ((strongest-extension (first-extensions extensions-str)))\n\
    \      (if (null? strongest-extension)\n          '()\n          (extension-by-strongest-extensions\
    \ (cdr strongest-extension)))))\n\n  (define (strongest-extensions extensions-str)\n\
    \    (map (lambda (strongest-extension)\n           (extension-str strongest-extension))\n\
    \        strongest-extensions-str))\n\n  (define ", "  (cond\n    [(empty? extensions)\n\
    \     (format nil \"~a.~a\" class_name class_name)]\n    [else\n     (let* ([class_char\
    \ (char (string-ref class_name 0))\n              extension_chars (map (lambda\
    \ (x) (char (string-ref x 0))) extensions)]\n            [strongest_extension\
    \ (max (map - (map length extension_chars) (map length extensions))\n        \
    \                         (lambda (x)\n                                   (< (first\
    \ x) (first extension_chars) \n                                      (first extensions)\
    \ \n                                      (second x) (second extensions))))])\n\
    \       (cond\n        [(strongest_extension > 0)\n         (format nil \"~a.~a\"\
    \ class_name (str-reverse (str-cat class_char (list (str-reverse (str-cat extension_chars\
    \ (list (str-reverse (str-cat extensions (list (str-reverse (str-cat extensions\
    \ (list (str-reverse (str-cat extensions (list (str-reverse (str-cat extensions\
    \ (list (str-reverse (str-cat extensions (list (str-reverse (str-cat extensions\
    \ (list (str-reverse (str-cat extensions (list (str-reverse (str-cat extensions\
    \ (list (str-reverse (str-cat extensions (list (str-reverse (str-cat extensions\
    \ (list (str-reverse (str-cat extensions (list (str-reverse (str-cat extensions\
    \ (list (str-reverse (str-cat extensions (list (str-reverse (str-cat extensions\
    \ (list (str-reverse (str-cat extensions (list (str-reverse (str-cat extensions\
    \ (list (str-reverse (str-cat extensions (list (str-reverse (str-cat extensions\
    \ (list (str-reverse (str-cat extensions (list (str-reverse (str-cat extensions\
    \ (list (str-reverse (str-cat extensions (list (str-reverse (str-cat extensions\
    \ (list (str-reverse (str-cat extensions (list (str-reverse (str-cat extensions\
    \ (list (str-reverse (str-cat extensions (list (str-reverse (str-cat extensions\
    \ (list (str-reverse (str-cat extensions (list (str-reverse (str-cat extensions\
    \ (list (str-reverse (str-cat extensions (list (str-reverse (str-cat extensions\
    \ (list (str-reverse (str-cat extensions (list (str-reverse (str-cat extensions\
    \ (list (str-reverse (str-cat extensions (list (str-reverse (str-cat extensions\
    \ (list (str-reverse (str-cat extensions (list (str-reverse (str-cat extensions\
    \ (list (str-reverse (str-cat extensions (list (str-reverse (str-cat extensions\
    \ (list (str-reverse (str-cat extensions (", "  (cond\n    [(empty? extensions)\
    \ (list class_name)]\n    [else\n     (cond\n\t[(member (first extensions) class_name)\
    \ (Strongest_Extension class_name (drop 1 extensions))]\n\t[else (Strongest_Extension\
    \ class_name (cons extensions (first extensions)))])))\n", "  (cond\n    ((= 0\
    \ (length extensions))\n     class_name)\n    ((> (length class_name) 0)\n   \
    \  (cons (string-ref class_name 0)\n           (string-append \"..\" (Strongest_Extension\
    \ \n                               (string-ref class_name 1)\n               \
    \                extensions))))\n    ((<= 0 (string-length class_name) 0)\n  \
    \   (string-append class_name \"..\"))\n    ((= (string-length class_name) (string-length\
    \ extensions))\n     (string-append class_name \"..\" (extensions-name (sort extensions))))\n\
    \    (else (cons (extensions-name extensions) (Strongest_Extension \n        \
    \                                   (string-append class_name \n             \
    \                                            \".\" \n                        \
    \                                 (extensions-name \n                        \
    \                                  extensions))\n                            \
    \               extensions)))))\n", "  (define (Strongest_Extension_helper extension)\n\
    \    (if (< (length extension) (length extensions))\n        (let ((extension_length\
    \ (length extension)))\n          (if (> extension_length (length (substring extension\
    \ 0 extension_length)))\n              (if (substring extension (+ (length extension)\
    \ 1) extension)\n                  (substring extension 0 extension_length))\n\
    \              extension))\n        extension))\n  (let loop ((extensions extensions)\n\
    \            (extension null))\n    (if (null? extensions)\n        (cond\n  \
    \         ((null? extensions) (list class_name))\n           ((null? (cdr extensions))\
    \ (list class_name))\n           (else (cons (first extensions) (loop (cdr extensions)\
    \ (second extensions))))))\n    (cond\n       ((null? (car extensions)) (cons\
    \ (first extensions) (loop (cdr extensions) (second extensions))))\n       (else\
    \ (loop (cdr extensions) (Strongest_Extension_helper (first extensions))))))\n",
  "  (let ((strength '0))\n    (for-each ((extension extensions)\n               (count\
    \ (length extension)))\n      (when (char= (first extension) class_name)\n   \
    \     (set! strength (- (* strength (count extension)))\n               (break))))\n\
    \    (format nil \"~a.~a\" class_name (first extensions))))\n", "  (cond\n   \
    \ [(empty? extensions) (print \"There are no extensions to load to the class\"\
    \ class_name)]\n    [(null? (cdr extensions))\n     (cons (car extensions) class_name)]\n\
    \    [else\n     (cond\n       [(> (cadr extensions) (cadr extensions))\n    \
    \    (cond\n          [(<= (cadr extensions) 0)\n           (print \"\"(append\
    \ class_name \".\" (car extensions))))]\n          [else\n           (cond\n \
    \            [(eq? class_name (cadr extensions))\n               (cond\n     \
    \            [(<= (cadr extensions) 0)\n                   (print \"\"(append\
    \ (cadr extensions) \".\" class_name))]\n                 [else\n            \
    \       (cond\n                     [(<= (cadr extensions) 0)\n              \
    \         (print \"\"(append class_name \".\" (cdr extensions)))]\n          \
    \           [else\n                       (print \"\"(append (car extensions)\
    \ \".\" (cadr extensions))))]]))]]))]))\n", "  (if (null? extensions)\n      \"\
    \"\n      (let ([c (car extensions)]\n            [l (length (string-to-int (cdr\
    \ extensions)))])\n        (let* ([sm (/ c l)]\n               [sc (- (/ (/ (+\
    \ c l) sm) 100) 100)]\n               [cap (- (* c sm) sc)]\n               [strongest\
    \ (reverse (sort-by (lambda (e) (* e sc)) extensions))]\n               [smp (first\
    \ strongest)]\n               [scp (- (length strongest) (* scp sm))])\n     \
    \     (if (eq? (string-to-int class_name) smp)\n              (format nil \"~s.~a\"\
    \ class_name strongest)\n              (if (and (>= scp 0) (< scp 100))\n    \
    \              (format nil \"~s.~a\" class_name strongest)\n                 \
    \ (format nil \"~s.~a\" class_name strongest))))))\n", "  (cond [(empty? extensions)\n\
    \         (symbol->string (symbol->string\n                             (intern\
    \ class_name \"String\")\n                             (intern class_name \"String\"\
    )))]\n        [(or (string=? (intern extensions (string->symbol class_name))\n\
    \                        (intern class_name \"String\"))\n            (eq? class_name\
    \ (intern extensions (string->symbol class_name)))) \n         (symbol->string\
    \ (symbol->string\n                             (intern class_name \"String\"\
    )\n                             (intern extensions (string->symbol class_name))))\
    \ \n         (set! extensions (remove (list extensions)\n                    \
    \           (filter (lambda (e) (not (string=? (string->symbol e)\n          \
    \                                               (intern class_name \"String\"\
    )))\n                                    extensions)))]\n        [(and (> (length\
    \ (symbol->string \n                            (intern class_name \"String\"\
    )\n                            (intern extensions (string->symbol class_name))))\
    \ 0)\n               (> (length (symbol->string \n                           \
    \  (intern class_name \"String\")\n                             (intern extensions\
    \ (string->symbol class_name))) 0))\n         (symbol->string (symbol->string\n\
    \                             (intern class_name \"String\")\n               \
    \              (intern extensions (string->symbol class_name)))]\n        [else\
    \ (symbol->string (symbol->string\n                                     (intern\
    \ class_name \"String\")\n                                     (intern extensions\
    \ (string->symbol class_name))))]))", "  (cond [(empty? extensions)\n        \
    \ \"\"]\n        [else\n         (let ((extension_name (first extensions)))\n\
    \           (let ((strength (- (count (map char->upper-case extension_name) \n\
    \                                   (map char->lower-case class_name)))\n    \
    \             (strongest_extension (first extensions))))\n             (if (<\
    \ strength 0) \n                 (cons class_name \n                      (cons\
    \ strongest_extension \n                             (Strongest_Extension class_name\
    \ (rest extensions))))\n                 (cons strongest_extension \n        \
    \              (Strongest_Extension class_name extensions))))))])\n", "  (cond\n\
    \    [(empty? extensions) \"\"]\n    [(equal? (caar extensions) \"\") \"\"]\n\
    \    [(equal? (caar extensions) \".\") \"\"]\n    [(equal? (caar extensions) \"\
    ..\") \"\"]\n    [(equal? (caar extensions) \"..\") (Strongest_Extension class_name\
    \ (cdr extensions))]\n    [else (cons class_name \n            (Strongest_Extension\
    \ (substring class_name (instring-length class_name)) \n                     \
    \          (cdr extensions)))]))\n", "  (let ((num_uppers (length (substring class_name\
    \ 0 (length class_name))))\n        (num_lowers (length (substring class_name\
    \ 0 (length class_name))))\n        (strength (- (+ num_uppers num_lowers) 1)))\n\
    \    (let loop ((i 0)\n              (found false))\n      (if (< i extensions)\n\
    \          (loop (+ i 1) true)\n          (cond ((= strength (car extensions))\n\
    \                 (if found\n                     (list (cons class_name extensions)\n\
    \                           (cons (substring class_name 0 strength) extensions))\n\
    \                     (list class_name extensions)))))))\n", "  (cond\n    [(empty?\
    \ extensions) (error \"empty extensions list\")]\n    [(equal? (first extensions)\
    \ \"\") (error \"first extension is a blank string\")]\n    [else (cond\n    \
    \        [(equal? (first extensions) \"S\") (add1 (length (substring (first extensions)\
    \ 1 3)))]\n            [(equal? (first extensions) \"A\") (add1 (length (substring\
    \ (first extensions) 1 2)))]\n            [(equal? (first extensions) \"L\") (add1\
    \ (length (substring (first extensions) 1 1)))]\n            [(equal? (first extensions)\
    \ \"E\") (add1 (length (substring (first extensions) 1 0)))]\n            [else\
    \ (error \"unknown extension name\")]\n            )]))\n", "  (cond\n    [(=\
    \ 0 (length extensions)) \"Undefined\"]\n    [(= 1 (length extensions)) (format\
    \ #f \"~A\" (first extensions))]\n    [else (cons (first extensions) (Strongest_Extension\
    \ class_name (drop 1 (rest extensions))))]\n    ))\n", "  (cond\n    [(empty?\
    \ extensions) \"\"]\n    [(not (member extension (map car (partition strength\
    \ extensions))))\n     (string-append class_name \".\" extension)]\n    [else\
    \ (Strongest_Extension class_name (drop 1 extensions))]))\n", "  (cond\n    [(empty?\
    \ extensions) '.']\n    [(equal? (car extensions) '?) '.']\n    [(equal? (car\
    \ extensions) '!) '.']\n    [else (cons (car extensions) (Strongest_Extension\
    \ class_name (cdr extensions)))]))\n", "  ;; Return the class name with an extension\
    \ that has the strongest strength.\n  (let ([best (first extensions)])\n    (cond\n\
    \      [(> (length (sort extensions <)) 0)\n       (let ([strongest ((lambda (x)\
    \ (let ([cap (length x)]\n                                                   \
    \ [sm (length x)])\n                                                 (/ (- cap\
    \ (- sm)) cap)))\n                 (strongest best)])\n         (if (> strongest\
    \ 0)\n             (cons best (cons strongest (cdr extensions))))))]\n      [else\n\
    \       (cons best (cons (first extensions) extensions))])))\n", "  (define S\
    \ (str_extension class_name))\n  (define C (str_extension extensions))\n  (define\
    \ SM (str_extension extensions))\n  (define C_S (str_extension extensions))\n\
    \  (define C_CAP (str_extension extensions))\n  (define C_K (str_extension extensions))\n\
    \  (define C_L (str_extension extensions))\n  (define C_SL (str_extension extensions))\n\
    \  (define C_SM (str_extension extensions))\n  (define C_C (str_extension extensions))\n\
    \  (define C_SL_CAP (str_extension extensions))\n  (define C_C_SM (str_extension\
    \ extensions))\n  (define C_L_SM (str_extension extensions))\n  (define C_L_SL\
    \ (str_extension extensions))\n  (define C_L_C (str_extension extensions))\n \
    \ (define C_SL_SM (str_extension extensions))\n  (define C_L_SL_SM (str_extension\
    \ extensions))\n  (define C_L_C_SM (str_extension extensions))\n  (define C_SL_SL\
    \ (str_extension extensions))\n  (define C_C_L (str_extension extensions))\n \
    \ (define C_SL_C (str_extension extensions))\n  (define C_C_SL (str_extension\
    \ extensions))\n  (define C_C_C (str_extension extensions))\n  (define C_C_L (str_extension\
    \ extensions))\n  (define C_C_SL_SM (str_extension extensions))\n  (define C_L_SL_C\
    \ (str_extension extensions))\n  (define C_L_C_C (str_extension extensions))\n\
    \  (define C_C_C_SL (str_extension extensions))\n  (define C_C_L_L (str_extension\
    \ extensions))\n  (define C_C_SL_SL (str_extension extensions))\n  (define C_C_C_L\
    \ (str_extension extensions))\n  (define C_C_SL_C (str_extension extensions))\n\
    \  (define C_C_L_L (str_extension extensions))\n  (define C_C_SL_C (str_extension\
    \ extensions))\n  (define C_C_L_L (str_extension extensions))\n  (define C_C_SL_C\
    \ (str_extension extensions))\n  (define C_L_SL_C (str_extension extensions))\n\
    \  (define C_SL_C_L (str_extension extensions))\n  (define C_C_L_L (str_extension\
    \ extensions))\n  (define C_C_SL_C (str_extension extensions))\n  (define C_L_SL_C\
    \ (str_extension extensions))\n  (define C_SL_C_L (str_extension extensions))\n\
    \  (define C_SL_C_L (str_extension extensions))\n  (define C_SL_C_L (", "  (let\
    \ loop ((extensions extensions)\n            (str class_name)\n            (max_str\
    \ max_str))\n    (if (empty? extensions)\n        str\n        (let ((ext (last\
    \ extensions))\n              (ext (substring (ext 0) (count-letter-of ext \"\
    S\") (count-letter-of ext \"M\"))))\n          (if (string-equal? ext \"\")\n\
    \              str\n              (if (< (count-letter-of ext \"M\") max_str)\n\
    \                  (loop (rest extensions) (str (substring ext 1) (count-letter-of\
    \ ext \"M\")) max_str)\n                  (loop (rest extensions) (str (substring\
    \ ext 1) (count-letter-of ext \"S\")) max_str)))))\n    (loop (rest extensions)\
    \ str max_str)))\n", "  (cond\n    [(empty? extensions) class_name]\n    [(string-match\
    \ \"[AC]\" class_name) (append class_name (rest (string-match \"[BC]\" class_name))]\n\
    \    [(string-match \"[AB]\" class_name) (append class_name (rest (string-match\
    \ \"[BC]\" class_name))]\n    [(string-match \"[BC]\" class_name) (append class_name\
    \ (rest (string-match \"[CD]\" class_name))]\n    [else (append class_name (rest\
    \ (string-match \"[CD]\" class_name)))]\n    )\n  )\n", "  (cond\n    [(empty?\
    \ extensions) (list class_name)]\n    [else (let ([sm  (length (first extensions))])\n\
    \           (let ([cap (length (substring class_name 0 sm))])\n             (cond\n\
    \               [(< cap sm) (list class_name extensions)]\n               [else\n\
    \                (cond\n                 [(< sm cap)\n                   (cond\n\
    \                    [else (append (first extensions)\n                      \
    \         (Strongest_Extension\n                                (substring class_name\
    \ sm (cap - sm)))\n                                (append extensions '())\n \
    \                               class_name)]\n                    [else (append\
    \ (first extensions)\n                               (Strongest_Extension\n  \
    \                              (substring class_name sm))\n                  \
    \              (append extensions '())\n                                class_name)]\n\
    \                   )\n                  ]\n                 [(= sm cap)\n   \
    \                (cond\n                    [else (append (first extensions)\n\
    \                               (Strongest_Extension\n                       \
    \         (substring class_name sm))\n                                (append\
    \ extensions '())\n                                class_name)]\n            \
    \        [else (append (first extensions)\n                               (Strongest_Extension\n\
    \                                (substring class_name 0 sm))\n              \
    \                  (append extensions '())\n                                class_name)]\n\
    \                   )\n                  ]\n                 [else (append (first\
    \ extensions)\n                               (Strongest_Extension\n         \
    \                       (substring class_name 0 sm))\n                       \
    \         (append extensions '())\n                                class_name)]\n\
    \                 )\n                )\n               ]\n             )\n   \
    \        ))\n    ]\n  )\n)\n</code>\n<|/ a tags=racket,scheme dscore=0 |>\n<|\
    \ c |>\nOh my god, that is so much! Thank you so much for taking the time to make\
    \ this! It is much appreciated.\n<|/ c |>\n<| a dscore=0 |>\nThe other answer\
    \ was nice, and it got me thinking about what I was doing and how I might go about\
    \ solving it. I came up with a solution that is pretty short, and is definitely\
    \ not as elegant as I thought it would be :)\n<code>\n#lang racket\n", "  (cond\n\
    \    [(empty? extensions) (Class_Name class_name)]\n    [(Class_Name (first extensions))\
    \ (Class_Name class_name)]\n    [(< (Class_Name class_name) (Class_Name (first\
    \ extensions))) \n     (Strongest_Extension (Class_Name class_name) (rest extensions))]\n\
    \    [else (Class_Name (first extensions)) (Class_Name class_name)]))\n", "  (let\
    \ ((class_name \n          (lambda (str) (if (string? str) str \n            \
    \               (error \"Expected class name as string\" str)))\n        (extensions\
    \ \n          (lambda (ext) (if (string? ext) ext \n                         \
    \  (error \"Expected extensions as list of strings\" ext)))\n        (strongest_extension\
    \ \n          (lambda (strongest) (if (number? strongest) strongest \n       \
    \                    (error \"Expected strongest extension name\" strongest))))\n\
    \    (let loop ((class (class_name class_name)) \n               (extension (car\
    \ extensions))\n               (strength (sub (string-length class) (string-length\
    \ extension))))\n      (if (null? extension)\n          (if (eqv? strength 0)\n\
    \              (strongest_extension extension)\n            (loop (car extensions)\
    \ \n                  (cdr extensions) \n                  (sub (sub (string-length\
    \ extension) (string-length extension)) strength)))\n          (loop (car extensions)\
    \ (cdr extensions) strength)))))\n", "  (cond\n    ((null? extensions) '.)\n \
    \   ((equal? (car (extensions 0))\n           (string->char (car (extensions 0))))\n\
    \     (cons (string-append class_name \".\" (car (extensions 0))))\n     (cons\
    \ (string-append class_name \".\" (car (extensions 1))))))\n", "  (define (strength\
    \ name)\n    (for/fold ((strength 0)) ((name extension)) extensions)\n    (/ (string-length\
    \ name) (CAR (char-code (first extension)))) \n    ))\n\n  (define (lowest-extensions\
    \ extensions)\n    (for/fold ((extensions extensions)) (lowest-extension extensions)\
    \ extensions))\n\n  (define (lowest-extension extensions)\n    (if (null? extensions)\
    \ extensions \n    (if (< (length extensions) 2)\n    (cons (second extensions)\
    \ extensions)\n    (lowest-extension (rest extensions)))))\n\n  (define (best-extension\
    \ extensions)\n    (if (null? extensions) \"\"\n    (if (< (length extensions)\
    \ 2)\n    (for/fold ((extension \"\")) ((extension extensions)) \n    (if (string=?\
    \ (strength extension) (strength (first extensions)))\n    (begin\n      (set!\
    \ extension extension)\n      (return-from best-extension extension))\n    (begin\n\
    \      (set! extension (first extensions))\n      (return-from best-extension\
    \ extension))))\n    (if (> (strength (first extensions)) (strength (second extensions))))\n\
    \    (begin\n      (set! extension (first extensions))\n      (return-from best-extension\
    \ extension))\n    (begin\n      (set! extension (second extensions))\n      (return-from\
    \ best-extension extension))))))\n\n  (define (best-extension-string extensions)\n\
    \    (if (null? extensions) \"\"\n    (if (< (length extensions) 2)\n    (begin\n\
    \      (set! extension (first extensions))\n      (return-from best-extension-string\
    \ extension)\n      (set! extension (second extensions))\n      (return-from best-extension-string\
    \ extension))\n    (begin\n      (set! extension (first extensions))\n      (return-from\
    \ best-extension-string extension)\n      (set! extension (second extensions))\n\
    \      (return-from best-extension-string extension))\n    (begin\n      (set!\
    \ extension (first extensions))\n      (return-from best-extension-string extension)\n\
    \      (set! extension (second extensions))\n      (return-from best-extension-string\
    \ extension))\n    (begin\n      (set! extension (first extensions))\n      (return-from\
    \ best-extension-string extension)\n      (set! extension (second extensions))\n\
    \      (return-from best-extension-string extension))\n    (begin\n      (set!\
    \ extension (first extensions))\n      (return-from best-extension-string extension)\n\
    \      (set", "  (let ((class (substring class_name 0 (- (string-length class_name)\
    \ 1)))\n        (extensions-with (lambda (x) (equal x (substring class_name 0\
    \ (- (string-length x) 2))))) \n        extension-strength (lambda (x) (/ (count\
    \ x) 2))) \n    (cond \n      [(empty? extensions) (println \"No extensions found\"\
    )] \n      [(extensions-with extension-strength) \n       (printf \"%s.\" (substring\
    \ class_name 0 (- (string-length class_name) 1)))] \n      [else (let ((extension\
    \ (find-extension extensions extension-strength)))\n              (printf \"%s.\"\
    \ (concat class_name extension \".\"))]\n    ))\n  )\n)\n", "  (cond\n    ((null?\
    \ extensions) (return (String. class_name)))\n    ((< (length (string-map String->Upper\
    \ (first extensions))) \n         (length (string-map String->Lower (first extensions))))\n\
    \     (return (String. \n               string-append (String->Upper (first extensions))\
    \ \".\" \n                              (String->Lower (first extensions))))\n\
    \    (else \n     (let ((extension_name (first extensions)))\n       (if (< (length\
    \ (string-map String->Upper (rest extensions))) \n             (length (string-map\
    \ String->Lower (rest extensions))))\n           (return (String. \n         \
    \             string-append (String->Upper (rest extensions)) \".\" \n       \
    \                             (String->Lower (rest extensions))))\n          \
    \ (if (< (length (string-map String->Upper (rest extensions))) \n            \
    \     (length (string-map String->Lower (first extensions))))\n              \
    \ (return (String. \n                          string-append (String->Upper (rest\
    \ extensions)) \".\" \n                                      (String->Lower (first\
    \ extensions))))\n               (if (< (length (string-map String->Upper (first\
    \ extensions))) \n                      (length (string-map String->Lower (rest\
    \ extensions))))\n                 (return (String. \n                       \
    \      string-append (String->Upper (first extensions)) \".\" \n             \
    \                            (String->Lower (rest extensions))))))))))))\n    ",
  "  (cond [(empty? extensions) \n         (string-append class_name \".\")\n    \
    \     ]\n        [(string-match (reverse (sort extensions <???>))\n          \
    \              (string_to_int class_name)) \n         (string-append (substring\
    \ class_name 0 (string-length class_name))\n                         (string-append\
    \ \".\" (string_to_int (first extensions))))]\n        [else (Strongest_Extension\
    \ (substring class_name 0 (string-length class_name)))\n               (cons (first\
    \ extensions)\n                      (Strongest_Extension (substring class_name\
    \ 1 \n                                               (string-length class_name)))\n\
    \                      )\n              ]\n        )\n        )\n", "  (cond\n\
    \    [(empty? extensions) \"\"]\n    [(null? (caasdar extensions 0))\n     (cons\
    \ class_name \"\")]\n    [else\n     (cons class_name (caasdar extensions))]))\n",
  "  (cond\n    [(string-length class_name)\n     (string-append class_name \".\"\
    )]\n    [(= (string-length class_name) 0)\n     (string-append \".\")]\n    [else\n\
    \     (cond\n       [(member class_name extensions)\n        (str (- 0 (length\
    \ class_name) (string-length extensions)))]\n       [(member extensions class_name)\n\
    \        (str (- 0 (length class_name) (string-length extensions)))]\n       [(member\
    \ (first class_name) extensions)\n        (str (- 0 (length class_name) (string-length\
    \ extensions)))]\n       [else\n        ;; If none of the extensions have the\
    \ right strength, return the first \n        ;; extension.\n        (str 0 (string-length\
    \ extensions))]))]))\n", "  (define (strongest x)\n    (let ((CAP 0)\n       \
    \   (SM 0))\n      (cond [(string=? x class_name) (cons x (rest extensions))]\n\
    \            [(string=? (substring x 0 CAP) (substring class_name 0 CAP))\n  \
    \           (cons (substring class_name 0 CAP) (cons x (rest extensions)))]\n\
    \            [(string=? (substring x 0 SM) (substring class_name 0 SM))\n    \
    \         (cons (substring class_name 0 SM) (cons x (rest extensions)))]\n   \
    \         [else (cons x extensions)]))\n  (let ((strongeres (sort strongest extensions\
    \ <?)))\n    (cond [(null? strongeres) class_name]\n          [(equal? #f (first\
    \ strongeres))\n           (reverse (rest strongeres))]\n          [else (cons\
    \ (first strongeres) (reverse (rest strongeres)))])))\n", "  (cond\n    [(empty?\
    \ extensions) (format \"~a.~a\" (string_to_symbol class_name) (symbol_to_string\
    \ class_name))]\n    [(string-contains-letters (first extensions) (first class_name))\
    \ \n     (format \"~a.~a\" (string_to_symbol class_name) (symbol_to_string class_name))]\n\
    \    [else (Strongest_Extension (first extensions) (rest extensions))]))", " \
    \ (define (ext-name ext)\n    (string-match \"[A-Z][a-z]+\" ext))\n  (define (strength\
    \ ext)\n    (string-match \"[A-Z]\" ext)-\n    (string-match \"[a-z]\" ext))\n\
    \  (define (strength-comparator ext1 ext2)\n    (if (eql? ext1 ext2)\n       \
    \ 0\n        (+ 1 (strength (ext2) (ext1)))))\n  (define (best-extension extensions\
    \ ext)\n    (if (null? extensions)\n        '()\n        (let ((ext1 (ext-name\
    \ ext))\n              (ext2 (ext-name (rest extensions))))\n          (if (eql?\
    \ ext1 ext2)\n              (cons ext extensions)\n              (if (> (strength-comparator\
    \ ext1 ext2) (strength ext))\n                  (list ext extensions)\n      \
    \            (best-extension extensions (rest extensions))))))))\n  (define (best-extensions\
    \ extensions ext)\n    (if (null? extensions)\n        '()\n        (let ((ext\
    \ (ext-name ext))\n              (extensions (best-extension extensions extensions)))\n\
    \          (if (null? extensions)\n              (cons ext (best-extensions (rest\
    \ extensions) ext))\n              (cons ext extensions)))))\n  (define (ext-class\
    \ ext)\n    (string-match \"[A-Z][a-z]+\" ext))\n  (define (ext-classs ext)\n\
    \    (string-match \"[A-Z][a-z]+\" ext))\n  (define (class-name ext)\n    (string-match\
    \ \"[A-Z][a-z]+\" ext))\n  (define (class-name ext)\n    (string-match \"[A-Z][a-z]+\"\
    \ ext))\n  (define (class-name ext)\n    (string-match \"[A-Z][a-z]+\" ext))\n\
    \  (define (class-name ext)\n    (string-match \"[A-Z][a-z]+\" ext))\n  (define\
    \ (class-names ext)\n    (string-match \"[A-Z][a-z]+\" ext))\n  (define (class-names\
    \ ext)\n    (string-match \"[A-Z][a-z]+\" ext))\n  (define (class-names ext)\n\
    \    (string-match \"[A-Z][a-z]+\" ext))\n  (define (class-names ext)\n    (string-match\
    \ \"[A-Z][a-z]+\" ext))\n  (define (class-names ext)\n    (string-match \"[A-Z][a-z]+\"\
    \ ext))\n  (define (class-names ext)\n    (string-match \"", "  (cond\n    [(empty?\
    \ extensions) (format nil \"~A.\" class_name)]\n    [(equal? (length (first extensions))\
    \ (length (first extensions))) \n     (format nil \"~A.\" class_name)]\n    [else\
    \ \n     (let ([cap (length (first extensions))\n           sm  (length (first\
    \ extensions))])\n       (cond\n        [(equal? (* (substring class_name 0 cap)\
    \ (substring extensions 0 cap)) 0)\n         (format nil \"~A.\" class_name)]\n\
    \        [else (cond\n               [(equal? (/ (substring class_name 0 cap)\
    \ (substring extensions 0 cap)) 0)\n                (format nil \"~A.\" class_name)]\n\
    \               [(equal? (/ (substring class_name 0 cap) (substring extensions\
    \ 0 sm)) 0)\n                (format nil \"~A.\" class_name)]\n              \
    \ [(equal? (/ (substring class_name 0 sm) (substring extensions 0 sm)) 0)\n  \
    \              (format nil \"~A.\" class_name)]\n               [(equal? (/ (substring\
    \ class_name 0 cap) (substring extensions 0 sm)) 0)\n                (format nil\
    \ \"~A.\" class_name)]\n               [(equal? (/ (substring class_name 0 sm)\
    \ (substring extensions 0 cap)) 0)\n                (format nil \"~A.\" class_name)]\n\
    \               [(equal? (/ (substring class_name 0 cap) (substring extensions\
    \ 0 cap)) 0)\n                (format nil \"~A.\" class_name)]\n             \
    \  [(equal? (/ (substring class_name 0 sm) (substring extensions 0 cap)) 0)\n\
    \                (format nil \"~A.\" class_name)]\n               [(equal? (/\
    \ (substring class_name 0 cap) (substring extensions 0 sm)) 0)\n             \
    \   (format nil \"~A.\" class_name)]\n               [(equal? (/ (substring class_name\
    \ 0 sm) (substring extensions 0 sm)) 0)\n                (format nil \"~A.\" class_name)]\n\
    \               [(equal? (/ (substring class_name 0 cap) (substring extensions\
    \ 0 cap)) 0)\n                (format nil \"~A.\" class_name)]\n             \
    \  [(equal? (/ (substring class_name 0 sm) (substring extensions 0 sm)) 0)\n \
    \               (format nil \"~A.\" class_name)]\n               [(equal? (/ (substring\
    \ class_name 0 cap) (substring extensions 0 cap)) 0)\n                (format\
    \ nil \"~A.\" class_name)]\n               [(equal? (/ (substring class_name 0\
    \ sm) (substring extensions ", "  (let ((extension_strengths (make-hash))\n  \
    \      (extension_strength-string (make-string))\n        (extension_strength\
    \ (- 1))\n        (extension_extension (make-extension))\n        (extension (first\
    \ (reverse extensions))))\n    (cond [(empty? extensions) (error \"No extensions\"\
    )]\n          [(char-uppercase (first extensions)) (set-extension-name class_name\
    \ extension_extension \"C\" extension_strength)]\n          [(char-lowercase (first\
    \ extensions)) (set-extension-name class_name extension_extension \"s\" extension_strength)]\n\
    \          [else (let ((extension_strength (length extensions)))\n           \
    \         (set-extension-name class_name extension_extension (first extensions)\
    \ extension_strength)]\n          )]))\n", "  (let ((strength (let (counter (make-hash))\n\
    \                   (loop \n                     (hash-for-each \n           \
    \            (lambda (e)\n                         (hash-put counter e 1))\n \
    \                      extensions)\n                     (hash-keys counter)\n\
    \                     (hash-values counter))))\n    (if (empty? extensions) \n\
    \        (list class_name)\n        (let ((ext (first extensions))\n         \
    \     (index (hash-ref strength ext)))\n          (cond\n            ((< index\
    \ 0) \n             (let ((ext (first extensions))\n                   (index\
    \ (hash-ref strength ext)))\n               (list class_name ext))\n         \
    \   (else \n             (cons (substring (cons class_name '.') 0 index)\n   \
    \                (append (Strongest_Extension \n                             (substring\
    \ (cons class_name '.') index) \n                             extensions))))))))\
    \ \n\n", "  (let* ((extension-counts (group-by\n                        (lambda\
    \ (x) (length (string->list (string->symbol x))))\n                        extensions))\n\
    \         (most-strength (max-key extension-counts (fold-left (lambda (x y) (max\
    \ x y))\n                                                      (cond ((null? extensions)\
    \ 0)\n                                                            ((= (length\
    \ extensions) 0) 0)\n                                                        \
    \    ((= (length extensions) 1) 1)\n                                         \
    \                   ((= (length extensions) 2) 2)\n                          \
    \                                  ((= (length extensions) 3) 3)\n           \
    \                                                 ((= (length extensions) 4) 4)\n\
    \                                                            ((= (length extensions)\
    \ 5) 5)\n                                                            ((= (length\
    \ extensions) 6) 6)\n                                                        \
    \    ((= (length extensions) 7) 7)\n                                         \
    \                   ((= (length extensions) 8) 8)\n                          \
    \                                  ((= (length extensions) 9) 9)\n           \
    \                                                 ((= (length extensions) 10)\
    \ 10)\n                                                            ((= (length\
    \ extensions) 11) 11)\n                                                      \
    \      ((= (length extensions) 12) 12)\n                                     \
    \                       ((= (length extensions) 13) 13)\n                    \
    \                                        ((= (length extensions) 14) 14)\n   \
    \                                                         ((= (length extensions)\
    \ 15) 15)\n                                                            ((= (length\
    \ extensions) 16) 16)\n                                                      \
    \      ((= (length extensions) 17) 17)\n                                     \
    \                       ((= (length extensions) 18) 18)\n                    \
    \                                        ((= (length extensions) 19) 19)\n   \
    \                                                         ((= (length extensions)\
    \ 20) 20)\n                                                            ((= (length\
    \ extensions) 21) 21)\n                                                      \
    \      ((= (length extensions) 22) 22)\n                                     \
    \                       ((= (length extensions) 23) 23)\n                    \
    \                                        ((= (length extensions) 24) 24)\n   \
    \                                                         ((= (length extensions)\
    \ 25) 25)\n                                                            ((= (length\
    \ extensions) 26) 26)\n                                                      \
    \      ((= (length extensions) 27) 27)\n                                     \
    \                       ((= (length extensions) 28) 28)\n                    \
    \                                        ((= (length extensions) 29) 29)\n   \
    \                                                         ((= (length extensions)\
    \ 30) 30)\n                                                            ((= (length\
    \ extensions) 31) 31)\n                                                      \
    \      ((= (length extensions) 32) 32)\n                                     \
    \                       ((= (length extensions) 33) 33)\n                    \
    \                                        ((= (length extensions) 34) 34)\n   \
    \                                                         ((= (length extensions)\
    \ 35) 35)\n                                                            ((= (length\
    \ extensions) 36) 36)\n                                                      \
    \      ((= (length extensions) 37) 37)\n                                     \
    \                       ((= (length extensions) 38) 38)\n                    \
    \                                        ((= (length extensions) 39) 39)\n   \
    \                                                         ", "  (cond\n    [(empty?\
    \ extensions) class_name]\n    [(equal? (first extensions) 'A) (Strongest_Extension\
    \ (substring (second class_name) (length (first class_name)) extensions))]\n \
    \   [(equal? (first extensions) 'B) (Strongest_Extension (substring (second class_name)\
    \ (length (first class_name)) extensions))]\n    [(equal? (first extensions) 'C)\
    \ (Strongest_Extension (substring (second class_name) (length (first class_name))\
    \ extensions))]\n    [(equal? (first extensions) 'D) (Strongest_Extension (substring\
    \ (second class_name) (length (first class_name)) extensions))]\n    [(equal?\
    \ (first extensions) 'E) (Strongest_Extension (substring (second class_name) (length\
    \ (first class_name)) extensions))]\n    [(equal? (first extensions) 'F) (Strongest_Extension\
    \ (substring (second class_name) (length (first class_name)) extensions))]\n \
    \   [(equal? (first extensions) 'G) (Strongest_Extension (substring (second class_name)\
    \ (length (first class_name)) extensions))]\n    [(equal? (first extensions) 'H)\
    \ (Strongest_Extension (substring (second class_name) (length (first class_name))\
    \ extensions))]\n    [(equal? (first extensions) 'I) (Strongest_Extension (substring\
    \ (second class_name) (length (first class_name)) extensions))]\n    [(equal?\
    \ (first extensions) 'J) (Strongest_Extension (substring (second class_name) (length\
    \ (first class_name)) extensions))]\n    [(equal? (first extensions) 'K) (Strongest_Extension\
    \ (substring (second class_name) (length (first class_name)) extensions))]\n \
    \   [(equal? (first extensions) 'L) (Strongest_Extension (substring (second class_name)\
    \ (length (first class_name)) extensions))]\n    [(equal? (first extensions) 'M)\
    \ (Strongest_Extension (substring (second class_name) (length (first class_name))\
    \ extensions))]\n    [(equal? (first extensions) 'N) (Strongest_Extension (substring\
    \ (second class_name) (length (first class_name)) extensions))]\n    [(equal?\
    \ (first extensions) 'O) (Strongest_Extension (substring (second class_name) (length\
    \ (first class_name)) extensions))]\n    [(equal? (first extensions) 'P) (Strongest_Extension\
    \ (substring (second class_name) (length (first class_name)) extensions))]\n \
    \   [(equal? (first extensions) 'Q) (Strongest_Extension (substring (second class_name)\
    \ (length (first class_name)) extensions))]\n    [(equal? (first extensions) ",
  "  (cond\n    [(empty? extensions) '.']\n    [(equal? (first extensions) (first\
    \ extensions))\n     (cons (first extensions) (Strongest_Extension (rest extensions))))]\n\
    \    [(equal? (first extensions) (rest extensions))\n     (cons (first extensions)\
    \ (Strongest_Extension (rest extensions))))]\n    [else\n     (let ([extension_name\
    \ (Strongest_Extension (first extensions))])\n       (cond\n         [(equal?\
    \ (Strongest_Extension (first extensions)) (Strongest_Extension (rest extensions)))\
    \ extension_name]\n         [else (cons extension_name extension_name)]))]))\n\
    </cell>\n<cell>\n#lang racket\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
