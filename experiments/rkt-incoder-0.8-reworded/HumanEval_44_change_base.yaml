name: HumanEval_44_change_base
language: rkt
prompt: "#lang racket\n\n;; Change numerical base of input number x to base.\n;; return\
  \ string representation after the conversion.\n;; base numbers are less than 10.\n\
  ;; >>> (change_base 8 3)\n;; \"22\"\n;; >>> (change_base 8 2)\n;; \"1000\"\n;; >>>\
  \ (change_base 7 2)\n;; \"111\"\n(define (change_base x base)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate change_base))\n\
  \    (check-equal? (candidate 8 3) \"22\")\n    (check-equal? (candidate 9 3) \"\
  100\")\n    (check-equal? (candidate 234 2) \"11101010\")\n    (check-equal? (candidate\
  \ 16 2) \"10000\")\n    (check-equal? (candidate 8 2) \"1000\")\n    (check-equal?\
  \ (candidate 7 2) \"111\")\n    (check-equal? (candidate 2 3) \"2\")\n    (check-equal?\
  \ (candidate 3 4) \"3\")\n    (check-equal? (candidate 4 5) \"4\")\n    (check-equal?\
  \ (candidate 5 6) \"5\")\n    (check-equal? (candidate 6 7) \"6\")\n    (check-equal?\
  \ (candidate 7 8) \"7\")\n))\n\n(test-humaneval)"
completions: ["  (cond\n    [(< base 10) (string-append (modulo (modulo (* base x)\
    \ base) base) \"\")\n     (cond\n       [(< x 10) (modulo x base) \"\"]\n    \
    \   [(= x 10) (modulo (+ 1 base) base)]\n       [else (modulo (+ 1 base) base)]\n\
    \       )])\n  )\n", "  (if (or (>= base 10) (< base 10))\n      '()\n      (let\
    \ ([acc (string->number x (+ base 1)))]\n        (cons (number->string acc) (carry\
    \ (change_base acc base)))))) ; tail-recursive function\n", "  (if (< base 10)\n\
    \      (num->string x (+ (- base (mod x base)) base))\n      (concat \"0\" (change_base\
    \ x (- base (mod x base))))))\n", "  (cond\n    ((<= base 10)\n     (string-append\
    \ (number->string (truncate x base)) \"0\"))\n    ((not (<= base 10)) \n     (number->string\
    \ (truncate (quotient x base) base))))))\n", "  (cond\n    [(zero? x) \"\"]\n\
    \    [(equal? x base) \"\"]\n    [else (list-ref (list base (quotient x base))\
    \ 0)]\n    [else (raise-error \"Invalid base ~S!\" base)])\n)\n", "  (if (> (/\
    \ x base) 10)\n      (/ (* base x) base)\n      (+ (/ x base) 10)))\n", "  (cond\n\
    \    [(< x base) (string-append \"(\" base \")\" (change_base (/ x base) base))]\n\
    \    [(= x base) (string-append \"0\" base)]\n    [else (string-append \"(\" base\
    \ \")\" (change_base (* x base) base))]))\n", "  (cond\n    [(zero? x) (string\
    \ 0)]\n    [(equal? base 1) (string x)]\n    [else (* 10 (change_base (quotient\
    \ x base) (quotient base base)))]))\n", "  (cond\n    [(zero? x) \"\"]\n    [(<\
    \ base 10) (string-append (change_base (modulo x base) (quotient x base)) (digit-char\
    \ (quotient x base)))]\n    [else (string-append (change_base (modulo x base)\
    \ (quotient x base)) (digit-char (quotient x base)))]\n    )\n  )\n", "  (if (<\
    \ base 10)\n      (string (regexp-replace x \"([1-9])\" (regexp-quote (base-str\
    \ base)) \n                           (regexp-quote (base-str base))\n       \
    \                    0 2))\n      (string (regexp-replace x \"([1-9])\" (regexp-quote\
    \ (base-str (- base 10))\n                           \"\" (regexp-quote (base-str\
    \ (- base 10))) \n                           0 2))))\n", "  (let ((str (string-append\
    \ (str x) \"0\")))\n    (cond [(< base 10) (set! str (substring str 1 (add1 str)\
    \ (+ base 1)))]\n          [(< base 10) (set! str (substring str (substring str\
    \ (length (str) - 1) (length (str))))])\n          [else (set! str (substring\
    \ str (- (- (substring str (- (length (str) - 1) 1) 0) base) 1)))])\n    str))\n",
  "  (define (number-str num)\n    (if (< num 10)\n        (list num (number->string\
    \ num))\n        (list num (number->string num) (number->string num))))\n  (define\
    \ (base-str base num)\n    (if (= base 0)\n        (number->string num)\n    \
    \    (base-str (quotient num base) (quotient (modulo num base) base))))\n  (if\
    \ (< x base)\n      (base-str base x)\n      (base-str (quotient x base) x)))\n",
  "  (if (< base 10)\n      (cond [(= x 0) '0]\n            [(= base 1) 'x]\n    \
    \        [(= x base) (string->list \"\")]\n            [else (cons (expt x base)\n\
    \                        (string->list \"\"))]\n      )\n      (cond [(= base\
    \ 1) 'x]\n            [(= x 0) '0]\n            [(= x base) '(list '(1)))]\n \
    \         [else (cons (expt x base)\n                        (string->list (list\
    \ (change_base x base))))])))\n", "  (if (or (not (number? x)) (not (number? base)))\n\
    \      '()\n      (cons (string->number (string->list x))\n            (change_base\
    \ (string->number (string->list x)) base))))\n", "  (define (rec x base)\n   \
    \ (cond\n      [(= x 0) \"\"]\n      [(< x base) (cons x \"\")]\n      [else (cons\
    \ (expt base x) (cons (modulo (expt base x) x) \"\"))]))\n  (rec x base))\n",
  "  (define (digit->string d base)\n    (if (zero? d)\n        '(0)\n        (string-append\
    \ (digit->string (cdr d) base)\n                       (if (even? d) '(+) '(-))))\n\
    \    (if (< base 10)\n        (digit->string (quotient x base) (+ base 10)))\n\
    \    (let* ((remainder (modulo x base))\n           (digits (reverse (remainder-digits\
    \ remainder base)))\n           (digit-to-string (reverse (digit->string (car\
    \ digits) base)))\n           (result (cons (first digit-to-string) digits))\n\
    \           (to-string (cons (first digit->string) digits)))\n      (append result\
    \ to-string)))\n  (digit->string (digit-value x) base))\n", "  (define (f x base)\n\
    \    (if (zero? base)\n        x\n        (f (quotient x base) base)))\n  (f x\
    \ base))\n", "  (cond\n    [(zero? x) (number->string '0)]\n    [(zero? (sub1\
    \ x))\n     (cond [(zero? (length x))\n            (number->string '0)]\n    \
    \       [else (number->string '0)])]\n    [else (number->string\n           (modulo\
    \ (modulo (modulo (mod x base) base) base) base)\n           base)])\n  )\n",
  "  (cond [(< base 10) (regexp-append \"^\" (change_base_to_string x (- base 10))\
    \ \"0\" base)\n         (regexp-append \"^\" (change_base_to_string x (- base\
    \ 10)) \"00\" base)]\n        [else (regexp-append \"^\" (change_base_to_string\
    \ x (- base (- base base))) \"0\" base)]))\n", "  (cond\n    [(= base 0) (string\
    \ x)\n     (cons (string->int (number x) base)\n           (change_base (remainder\
    \ x (number base)) base))]\n    [else (cons (string->int (number x) base)\n  \
    \            (change_base (remainder x (number base)) base))]))\n", "  (cond\n\
    \    [(< base 10) (number->string x))\n    (else (string-append (number->string\
    \ (quotient x base)) (if (> base 10) \"-\" \"\") (number->string base)))))\n",
  "  (if (< base 10)\n      (string-append (string-append (number->string x) \"0\"\
    ) (string-append \"0\" base))\n      (let ([snum (number->string x)]\n       \
    \     [lnum (number->string 10)]\n            [len (length snum)]\n          \
    \  [nnum (number->string (quotient (+ 1 len) base)])\n            [rnum (number->string\
    \ (modulo len base)])\n            [llen (length lnum)]\n            [rlen (length\
    \ rnum)]\n            [nlen (length nnum)])\n        (cond [(= len 0)\n      \
    \         (string-append (number->string x) (number->string 10))]\n          \
    \    [(< len 4)\n               (cond [(= (% len 3) 0)\n                     \
    \  (cond [(= len 4)\n                               (cond [(= (% len 2) 0)\n \
    \                                      (cond [(= (% len 1) 0)\n              \
    \                                 (cond [(= (% len 0) 0)\n                   \
    \                                    (string-append (number->string x) \"0\")]\n\
    \                                                     [else (string-append \"\
    0\" x)])]\n                                     [else (string-append \"0\" x)])]\n\
    \                                     [else (string-append \"00\" x)])]\n    \
    \                                 [else (string-append \"0\" x)])]\n         \
    \                            [else (string-append \"0\" x)])]\n              \
    \                       [else (string-append \"0\" x)])]\n                   \
    \                  [else (string-append \"0\" x)])]\n                        \
    \             [else (string-append \"0\" x)])]\n                             \
    \        [else (string-append \"0\" x)])]\n                                  \
    \   [else (string-append \"0\" x)])]\n                                     [else\
    \ (string-append \"0\" x)])]\n                                     [else (string-append\
    \ \"0\" x)])]\n                                     [else (string-append \"0\"\
    \ x)])]\n                                     [else (string-append \"0\" x)])]\n\
    \                                     [else (string-append \"0\" x)])]\n     \
    \                                [else (string-append \"0\" x)])]\n          \
    \                           [else (string-append \"0\" x)])]\n               \
    \                      [else (string-append \"0\" x)])]\n                    \
    \                 [else (string-append \"0\" x)])]\n                         \
    \            [else (string-append \"0\" x)])]\n                              \
    \       [else (string-append \"0\" x)])]\n                                   \
    \  [else (string-append \"0\" x)])]\n                                     [else\
    \ (string-append \"0\" x)])]\n                                     [else (string-append\
    \ \"0\" x)])]\n                                     [else (string-append \"0\"\
    \ ", "  (cond\n    ((zero? base) '())\n    ((zero? (expt x base)) (+ x (change_base\
    \ (expt x base) base)))\n    (else (+ x (change_base (expt x base) (- base 1))))))\n",
  "  (if (< x 10)\n      (base-digits (- x base) base)\n      (base-digits (- x base)\
    \ base)))\n</code>\n<|/ a |>\n<| a tags=racket,scheme dscore=0 |>\nIt looks like\
    \ you have a lot of code that you don't really need.\n<code>", "  (number->string\
    \ (remainder (remainder (* x base) (expt base (- x 1))) base)))\n</textarea></form>\n\
    \n    <script>\n      var editor = CodeMirror.fromTextArea(document.getElementById(\"\
    code\"), {});\n    </script>\n\n    <p><strong>MIME types defined:</strong> <code>text/x-racket</code>.</p>\n\
    \n    <p>\n      A complete list of MIME types for Racket is available at\n  \
    \    <a href=\"http://www.racket-lang.org/docs/rdoc/html/rdoc-types.html\">http://www.racket-lang.org/docs/rdoc/html/rdoc-types.html</a>.\n\
    \    </p>\n\n    <p>\n      You can also read about the Racket project at\n  \
    \    <a href=\"http://racket-lang.org/\">http://racket-lang.org/</a>.\n    </p>\n\
    \n    <p>\n      Learn more about Racket at <a href=\"http://racket-lang.org/guide/\"\
    >the Racket User's Guide</a>.\n    </p>\n\n    <p>\n      Find out more about\
    \ Racket at\n      <a href=\"http://www.racket-lang.org/\">http://www.racket-lang.org/</a>.\n\
    \    </p>\n  </body>\n</html>\n\n<|/ file source=github filename=racket-small.html\
    \ |>\n<| c |>\nYou forgot the `#lang` directive in your code.\n<|/ c |>\n<| c\
    \ |>\nYeah, I noticed that after I posted the question. Thanks.\n<|/ c |>\n<|\
    \ c |>\nThe `#lang` directive is needed only when you want to use Racket-specific\
    \ extensions. Since your code is obviously pure Racket, the `#lang` directive\
    \ is not required.\n<|/ c |>\n<| c |>\nSo I guess my biggest question now is why\
    \ doesn't the #lang directive work?\n<|/ c |>\n<| c |>\nBecause Racket is an extension\
    \ to Racket, not the other way around. `racket` defines a language and `racket/base`\
    \ defines a library to extend that language with specific functions. You have\
    \ to tell the interpreter that you are using Racket. Like so: `#lang racket`.\
    \ If you want to write pure Racket, simply omit the #lang directive.\n<|/ c |>\n\
    <| a tags=racket,scheme |>\nFor Racket you need to use #lang racket. As mentioned,\
    \ racket is a library and you need to use #lang racket before using racket/base.\
    \ So, your code should be:\n<code>\n#lang racket\n", "  (if (= base 0)\n     \
    \ '()\n      (append (list ((mod x base) base))\n                (change_base\
    \ (quotient x base) base))))\n", "  (if (= base 10) (string x) ; base 10\n   \
    \   (if (= x 0)\n          (string base)\n          (change_base (/ x base) (*\
    \ base base)))))\n", "  (cond\n    [(< base 10) (number->string x (string-append\
    \ \"0\" base))]\n    [else (string-append (change_base (quotient x base) (sub1\
    \ base)) \"0\") ]))\n", "  (cond\n    [(> base 10) (string-append \"0\" (change_base\
    \ (modulo x (expt base 10)) base))\n     (modulo x base)]\n    [else x]\n    ))\n",
  "  (mod x base))\n", "  (cond\n    [(<= (abs x) 10) \n     (number->string \n  \
    \    (+ (* base (modulo (abs x) base)) x))]\n    [else \n     (number->string\
    \ \n      (+ (/ x base) (modulo (abs x) base))))])\n", "  (if (or (= x 0) (= base\
    \ 0)) '()\n    (append (format \"~d\" (/ x (floor x base)))\n            (change_base\
    \ (quotient x base) base))))\n", "  (cond [(< base 10) (printf \"~a\" (number->string\
    \ x))]\n        [(= base 10) (printf \"~a\" (number->string x))]\n        [else\
    \ (printf \"~a\" (number->string (expt x base)))]))\n", "  (let ((digits (string->list\
    \ x)))\n    (cond\n      [(= base 10) (set-string \"\" digits)]\n      [(= base\
    \ 0) (set-string \"\" digits)]\n      [else\n       (let ((result (apply + (map\
    \ + digits base))))\n         (set-string \"\" result)])]))\n", "  (if (= x 0)\n\
    \      '0\n      (if (= base 10)\n          (list x)\n          (list x (quotient\
    \ x base)))))\n", "  (cond [(= base 10)\n         (string->list (string->int x))]\n\
    \        [(< base 10)\n         (change_base (/ x base) (+ base 1))]))\n", " \
    \ (cond [(< base 10)\n         (+ x (* base base))\n         ]\n        [(>= base\
    \ 10)\n         (string-append (number->string x)\n                        (number->string\
    \ x (- base 10)))\n         ]\n        [else\n         (number->string x (- base\
    \ 10))\n         ]))\n", "  (list to\n        (+ base x))\n  )\n", "  (* base\
    \ x (+ base (quotient x base))))\n", "  (if (< base 10)\n      (cond [(= base\
    \ 10) (list '(x x))]\n            [else (cond [(= base 2) (list '(x x x))]\n \
    \                      [else (change_base x (quotient x base))])]))))\n", "  (cond\n\
    \    [(= base 10) \"\"]\n    [(= x 0) \"\"]\n    [else (number->string (remainder\
    \ x (expt base base)))]))\n", "  (cond [(zero? x) \"\"]\n        [(> base 10)\
    \ \"\"]\n        [else (number->string (remainder x (base)) base)]))\n", "  (cond\n\
    \    [(<= base 0) \"\"]\n    [else (to_string (quotient x base) base)]\n  )\n\
    )\n", "  (check-type base integer)\n  (check-type x integer)\n  (cond\n    [(=\
    \ x 0) \"\"]\n    [(= x base) x]\n    [(< x base) (* base x)]\n    [else (+ x\
    \ (change_base (- x base) base))]))\n", "  (let loop ((x x) (base base) (acc ''))\n\
    \    (if (< base 10)\n        (append acc (number->string x))\n        (loop (quotient\
    \ x base) (quotient base 10) (append acc \"0\")))))\n", "  (if (>= base 10)\n\
    \      '()\n      (number->string (- (number->integer x) (base->integer base))))))\n",
  "  (* base x))\n", "  (cond [(zero? x) (error \"Negative base number given\")\n\
    \         (not (number? x))\n         (error \"Non-number base number given\"\
    )]\n        [else (if (zero? base)\n                (string x)\n             \
    \   (string (reverse (mod x base))\n                         (string base)))]))\n",
  "  (list x (list base)))\n", "  (if (< base 10)\n      (change-base-int x base)\n\
    \      (change-base-string x base)))", "  (if (< x 10)\n      (* base x)\n   \
    \   (+ (change_base (- x 10) base) base)))", "  (cond\n    ((= x 0) \"\")\n  \
    \  ((= x base) \"0\")\n    ((< x base) (change-base-- (/ x base) base))))\n",
  "  (if (< base 10)\n      (* base x (string->number (string->symbol (string->list\
    \ x))) base)\n      (error (printf \"Base should be less than 10: ~D.\" base))\n\
    \    )\n)\n", "  (cond\n    ((= base 10) x)\n    ((= x 0) (cons '0x x))\n    (else\
    \ (+ (char (mod x (expt base 10)) base) x))))\n", "  (let ([len (string-length\
    \ x)]\n        [newstr (make-string len)]\n        [i (- len base)])\n    (loop\n\
    \      (when (<= i 0)\n        (set! newstr (string-append newstr x)))\n     \
    \ (when (< i base)\n        (set! newstr (string-append newstr '0')))\n      (set!\
    \ newstr (string-append newstr (string-ref x i))))\n    newstr))\n", "  (if (=\
    \ base 0)\n      (if (zero? x)\n          (number->string 0)\n          (number->string\
    \ (-x))\n      )\n      (cond [(zero? x) (number->string 0)]\n            [(<\
    \ x base) (number->string (expt x base))]\n            [else (number->string (-\
    \ x (- base 1)))]\n      )\n  )\n)\n", "  (cond\n    [(< base 10) (number->string\
    \ (remainder x base))]\n    [else (cond\n             [(< x base) (number->string\
    \ (remainder x base))\n               (= base 2) (number->string (quotient x base))\n\
    \               (= base 3) (number->string (quotient x base 2))]\n           \
    \  [else (number->string (quotient x base))]))]))\n", "  (* x base))\n", "  (cond\
    \ [(< base 10) (sub1 (modulo (+ x base) base))]\n        [else (modulo (+ x base)\
    \ base)]))\n</code>\n<|/ a tags=scheme,racket |>\n<| c |>\nThis code is wrong\
    \ for bases greater than 10: if you try `change_base 8 2`, you'll get `(modulo\
    \ (+ 8 2) 2)`, which will give you `4`, not `10`.\n<|/ c |>\n<| c |>\nYou're right.\
    \ Fixed now, but I was still on the train and didn't had the time to test it ;)\n\
    <|/ c |>\n<| c |>\nBTW, this code is not safe for negative numbers.\n<|/ c |>\n\
    <| c |>\nThanks for the suggestions. I had realized that `(< base 10)` was not\
    \ an issue with the solution, but I was wondering if there are any differences\
    \ between the Racket implementations. And it appears that there is one. I haven't\
    \ tested the code on any implementations but I will test it when I get the chance.\n\
    <|/ c |>\n<| c |>\nIt looks like the code does not work in all implementations\
    \ (at least the version I tried it in). The code does not work on the Racket implementation\
    \ (at least in the version I was using). But it does work in Racket. Maybe the\
    \ code was changed between versions? I'll test with another implementation and\
    \ post the results.\n<|/ c |>\n<| a dscore=0 tags=scheme,racket |>\nHere's one\
    \ way, that works without external libraries. It works with negative numbers as\
    \ well:\n<code>", "  (define (f x base)\n    (if (< x base) \n        (f (sub1\
    \ x) (sub1 base))\n        (sub1 x)))\n  (f x (sub1 base)))\n", "  (let ([n (*\
    \ x base)\n        p (int (/ x base))\n        r (- n p)]\n        [result \"\"\
    ]\n        [acc (if (= p 0) (* 10 base) 0)])\n    (cond [(< n 0) result]\n   \
    \       [(= n 0) (printf \"~d\" acc)]\n          [(= p 1) (printf \"~d\" result)]\n\
    \          [(= p 2) (printf \"~d\" (+ acc r))]\n          [else (printf \"~d\"\
    \ (+ acc r) (change_base n 10))]\n          [(< p 3) (printf \"~d\" (+ acc r)\n\
    \                                 (change_base (- n 1) 10)\n                 \
    \                (change_base n 10))]\n          [(< r base) (printf \"~d\" (+\
    \ acc r)\n                                 (change_base (- n 1) 10)\n        \
    \                         (change_base (- n 1) 10)\n                         \
    \        (change_base n 10))]\n          [(< result \"0\") (printf \"~d\" (+ acc\
    \ r)\n                                     (change_base (- n 1) 10)\n        \
    \                             (change_base (- n 1) 10)\n                     \
    \                (change_base n 10))]\n          [else result])))\n", "  (cond\n\
    \    [(< base 10)\n     (string-append (regexp-replace (number->string x) \"(^|\\\
    D)\" #\"$1\") (number->string (expt base x)))]\n    [else\n     (number->string\
    \ x)]))\n", "  (cond ((< base 10) x)\n        ((<= (mod x base) base) (recur (/\
    \ x base) base))\n        (else (+ x (* base base)))))\n", "  (if (= base 0)\n\
    \      '()\n      (cons (mod x base) (change_base (/ x base) base))))\n", "  (if\
    \ (or (< x base) (> base 0))\n      (display (quotient x base))\n      (display\
    \ x)))\n", "  (if (= x 0)\n      '0\n      (let ((number (read_number (string->symbol\
    \ (number->string x))))\n            (converted (number->string x)))\n       \
    \ (display \"~a\" number)\n        (display \" ~a\" base)\n        (display \"\
    \ ~a\" converted)\n        (if (= base 0)\n            (display \" ~a\" number)\n\
    \            (display \" ~a\" base)\n            (display \" ~a\" converted)\n\
    \            (display \" ~a\" number)\n            (display \" ~a\" base)\n  \
    \          (display \" ~a\" converted)\n            (display \" ~a\" number)\n\
    \            (display \" ~a\" base)\n            (display \" ~a\" converted)\n\
    \            (display \" ~a\" number)\n            (display \" ~a\" base)\n  \
    \          (display \" ~a\" converted)\n            (display \" ~a\" number)\n\
    \            (display \" ~a\" base)\n            (display \" ~a\" converted)\n\
    \            (display \" ~a\" number)\n            (display \" ~a\" base)\n  \
    \          (display \" ~a\" converted)\n            (display \" ~a\" number)\n\
    \            (display \" ~a\" base)\n            (display \" ~a\" converted)\n\
    \            (display \" ~a\" number)\n            (display \" ~a\" base)\n  \
    \          (display \" ~a\" converted)\n            (display \" ~a\" number)\n\
    \            (display \" ~a\" base)\n            (display \" ~a\" converted)\n\
    \            (display \" ~a\" number)\n            (display \" ~a\" base)\n  \
    \          (display \" ~a\" converted)\n            (display \" ~a\" number)\n\
    \            (display \" ~a\" base)\n            (display \" ~a\" converted)\n\
    \            (display \" ~a\" number)\n            (display \" ~a\" base)\n  \
    \          (display \" ~a\" converted)\n            (display \" ~a\" number)\n\
    \            (display \" ~a\" base)\n            (display \" ~a\" converted)\n\
    \            (display \" ~a\" number)\n            (display \" ~a\" base)\n  \
    \          (display \" ~a\" converted)\n            (display \" ~a\" number)\n\
    \            (display \" ~a\" base)\n            (display \" ~a\" converted)\n\
    \            (display \" ~a\" number)\n            (display \" ~a\" base)\n  \
    \          (display \" ~a\" converted)\n            (display \" ~a\" number)\n\
    \            (display \" ~a\" base)\n            (display \" ~a\" converted)\n\
    \            (display \" ~", "  (if (< x 10)\n      (symbol->string (+ x (- base\
    \ 10)))\n      (symbol->string x)))\n", "  (cond\n    [(or (not (<= x 10))\n \
    \        (not (<= base 10)))\n     (display \"Invalid Base!\")\n     (newline)]\n\
    \    [else\n     (display\n      (format \"~s\" (/ (quotient x base) base)))]\n\
    \    [else (display \"Invalid Input!\")]))\n", "  (if (negative? x)\n      (change_base\
    \ (- x) base)\n      (if (zero? base)\n          (+ x 1)\n          (+ (/ x base)\
    \ (* base base))))))\n", "  (if (zero? x)\n      \"\"\n      (string-append (modulo\
    \ (string-append\n                            (number->string base)\n        \
    \                    (number->string x))\n                          base))))",
  "  (cond [(< base 10)\n         (number->string x)]\n        [(> base 10)\n    \
    \     (error \"base must be less than 10\")]))\n", "  (if (< base 10)\n      (string-append\
    \ (number->string x) (number->string (number->integer x (/ base 10))) (number->string\
    \ (number->integer x (* base base)))))\n      (error (and (< base 10) (invalid-base)))))\n",
  "  (cond\n    [(< base 10)\n     (append \"0\" (number->string x))]\n    [else\n\
    \     (append \"0\" (number->string (expt x base))\n             (number->string\
    \ (expt x (- base 1))))]))\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThe first case\
    \ won't be caught by the second condition of the `cond` -- you mean `(< base 10)`\
    \ instead of `(< base 2)` right?\n<|/ c |>\n<| c |>\nYes you are right, my bad.\n\
    <|/ c |>\n<| a tags=racket,numbers,scheme |>\nHere is a more general version of\
    \ change_base that allows to specify any base other than 10:\n<code>", "  (cond\n\
    \    [(or (< x 10) base)\n     (cons x base)]\n    [(< x 10)\n     (string->number\
    \ (number->string x))\n     (string->number (number->string base))]\n    [else\n\
    \     (cond\n       [(= base 2)\n         ;; raise to power of ten x.\n      \
    \   ;; The recursive call is needed because of the base case.\n         ;; If\
    \ this line is omitted, the recursion will go to the top\n         ;; of the function\
    \ and give an error.\n         (call/cc\n          (lambda (exit-label return-value)\n\
    \            (unless (< x 100)\n              (error 'change_base \"base cannot\
    \ be greater than 10\"\n                      (list x base)))\n            (loop\n\
    \              (let ([n x])\n                (let ([result\n                 \
    \      (make-array\n                        (- base (length x)) (make-array (-\
    \ base (length x)) 'string)])\n                   (loop\n                    \
    \ (for [j (- base (length x))]\n                       (string->number\n     \
    \                    (number->string (+ (car result) n (* x j))))))\n        \
    \           (loop\n                     (for [j (- base (length x))]\n       \
    \                (string->number\n                         (number->string n (*\
    \ x j))))))))]\n       [else\n         ;; divide by the base.\n         (cond\n\
    \          [(= base 2)\n           (call/cc\n            (lambda (exit-label return-value)\n\
    \              (string->number x (* x base)))]\n          [else\n           (call/cc\n\
    \            (lambda (exit-label return-value)\n              (string->number\
    \ x (/ (number->string x (* base base)) base)))]\n          [else\n          \
    \ (call/cc\n            (lambda (exit-label return-value)\n              (error\
    \ 'change_base \"base cannot be greater than 10\"\n                      (list\
    \ x base)))]))]]))\n", "  (if (< x 10) \n      (string-append (string-append x\
    \ \"0\" base) \"0\")))\n", "  (if (= base 10)\n      (+ x base)\n      (* x (change_base\
    \ base (- base 1)))))\n", "  (define (helper x acc)\n    (if (< x base)\n    \
    \    (cons acc (helper (quotient x base) 0))\n        (helper (quotient x base)\
    \ (+ x 1))))\n  (helper x '()))\n", "  (if (< base 10)\n      (add-to-string x\
    \ (- base x))\n      (add-to-string x base)))\n", "  (if (< base 10)\n      (modulo\
    \ (number x) base)\n      (number->string x)))\n", "  (let ([n (floor (/ x base))])\n\
    \    (if (zero? n)\n        '()\n        (append (number->string n) (change_base\
    \ n base)\n               (number->string x))))\n", "  (if (>= base 10)\n    \
    \  (list x) \n      (loop (- base 1) (add1 x))))\n", "  (assert base (check-base-param\
    \ base 10))\n  (string->number x))", "  (cond [(< x 10)\n         (- x (+ base\
    \ 10))]\n        [(< base 10)\n         (+ x (- base 10))]\n        [else (+ x\
    \ base)]))\n", "  (if (< (- base x) 10)\n      (modulo (+ x (expt 2 base)) base)\n\
    \      (modulo (+ x (expt 2 base)) (+ base 10))))\n", "  (let* ((base-str (string\
    \ base)) (digits (reverse (map number->string (regex-match #rx(define-syntax ((match)\
    \ (_ base val) `(,base ,val )))) x)))\n    (if (zero? (length x))\n        \"\"\
    \n        (let ((base-' (substring base-str (length digits) (length x))) (digit\
    \ (substring digits 0 (length digits))) (digit-' (substring digit-str 0 (length\
    \ digit))))\n          (cond\n            ((<= base 10) (concat (reverse digits)\
    \ base-' digit-'))\n            ((< base 10) (concat (reverse digits) base-' digit-'\
    \ \"0\" digit-'))\n            (#t \"Error!\"))))))\n", "  (cond\n    ((= base\
    \ 10)\n     (string-append \"0\" (number->string x)))\n    ((= base 0)\n     (number->string\
    \ x))\n    ((< base 10)\n     (string->number (change_base (number->string x)\
    \ base))))))\n", "  (cond [(< base 10)\n         (string->number x (+ base base))\n\
    \         (string->number x (- base base))])\n        (else (error \"Invalid base\"\
    \ base))))\n", "  (number->string (x) (* base 10)))\n</code>\n<|/ a dscore=4 tags=scheme,racket\
    \ |>\n<| a tags=scheme,racket dscore=4 |>\n<code>", "  (if (< base 10)\n     \
    \ (number->string x (+ base (- base 10)))\n      (number->string x (+ base 10))))\n",
  "  (if (< base 10)\n      (number->string ((make-base-from-int (expt x base)) base))\n\
    \      (number->string x)))\n", "  (cond [(< x 10)\n         (list x)\n      \
    \   ]\n        [(= base 1)\n         (list x)\n         ]\n        [else\n   \
    \      (cons (string->number (to-string x (base-to-longint base)))\n         \
    \     (change_base (number->string x) base)\n              )\n         ]\n   \
    \     ))\n", "  (cond [(< x 10) (string-append (integer->string x) \"0\" (make-string\
    \ base '0))]\n        [else (integer->string x) (make-string base '0)]))\n", " \
    \ (let\n      ((base-len (floor (/ base (+ x 1)))))\n    (cond\n      ((= x 0)\
    \ (make-string base-len base))\n      ((even? x) \n       (cond\n         ((=\
    \ base 10)\n          (make-string (ceiling x base-len) base))\n         ((= base\
    \ 2)\n          (make-string base-len base))\n         (else (error \"Invalid\
    \ argument base\"))))))\n    \n    (let\n        (\n          (blen (- base-len\
    \ 1))\n          (len (- blen 1))\n          (digits (reverse \n             \
    \        (map\n                       (lambda (x)\n                         (if\
    \ (< x base)\n                             '()\n                             (cons\
    \ \n                              (+ (* x base)\n                            \
    \      (make-string (quotient x base) base))\n                              (if\
    \ (even? (modulo x base)) '()\n                                  '())))) \n  \
    \                  x))\n          \n          (base-10-digits (filter \n     \
    \                        (lambda (x) (= base 10)) \n                         \
    \    digits))\n          (base-100-digits (filter \n                         \
    \    (lambda (x) (= base 100)) \n                             digits))\n     \
    \     (base-base-digits (filter \n                              (lambda (x) (=\
    \ base base)) \n                              digits))\n          \n         \
    \ (new-digits (map \n                           (lambda (x) (+ x blen)) \n   \
    \                        base-base-digits))\n          \n          (new-base-digits\
    \ (filter \n                              (lambda (x) (= base base)) \n      \
    \                        new-digits))\n          \n          (new-base-digits\
    \ (reverse \n                              (map \n                           \
    \    (lambda (x) (- x blen)) \n                               new-base-digits))\n\
    \          \n          (new-digits (map \n                           (lambda (x)\
    \ (- x len)) \n                           base-100-digits))\n          \n    \
    \      (new-digits (map \n                           (lambda (x) (- x len)) \n\
    \                           base-10-digits))\n          \n          (new-digits\
    \ (append \n                             (map \n                             \
    \ (lambda (x) (+ x len)) \n                               new-base-digits)\n \
    \                            new-digits))\n          \n          (new-digits (reverse\
    \ \n                             (append \n                              (map\
    \ \n                               (lambda (x) (- x len)) \n                 \
    \              new-digits))\n                             (map \n            \
    \                  (lambda (x) (+ x blen)) \n                               new-base-digits))))\n\
    \    \n    (if (eq? base 10)\n        (make-string \n         (length (join new-digits))\
    \ \n         base)\n      (make-string \n       (length (join new-digits)) \n\
    \       10", "  (cond ((= x 0) \"0\")\n        ((= x base) \"base\")\n       \
    \ (else (+ (* (- base x) x) x))))\n", "  (cond\n    ((= base 0) (string x))\n\
    \    ((< base 10) (change_base (/ x base) (- base 1)))\n    ((< base 36) (change_base\
    \ (* base (- base 1)) (- base 36)))\n    ((< base 62) (change_base (* base (-\
    \ base 2)) (- base 62)))\n    ((< base 10^3) (* x (change_base (/ x base) (- base\
    \ 10^3)))\n    ((< base 10^6) (* x (change_base (/ x base) (- base 10^6)))\n \
    \   ((< base 10^9) (* x (change_base (/ x base) (- base 10^9)))\n    (else (change_base\
    \ x (- base 10))))))\n", "  (cond\n    ((= base 0) x)\n    ((< base 10) (reverse\
    \ x))\n    ((< base (ceiling (/ base 10)))\n     (string-append (number->string\
    \ x) \"0\"\n                    (change_base (/ base 10) base)))\n    (else\n\
    \     (string-append (number->string x) \"0\"\n                    (change_base\
    \ (/ base 10) base)))\n    (else x)))\n", "  (let ((chars (make-array '(string-length\
    \ x) '(#\\space))))\n    (for-each (lambda (c)\n                (cond\n      \
    \            [(<= (digit-char-car c) base) (replace (car chars)\n            \
    \                                         (digit-char-car c)\n               \
    \                                      (digit-char-cdr c))]))\n              x)))\n",
  "  (let loop ((x x))\n    (if (zero? x)\n        '()\n        (loop (quotient x\
    \ base))\n        ((string->number (string->list x))\n         (list->string (string->list\
    \ '(base x)))))\n  ))\n", "  (cond [(< base 10)\n         (number->string x (base-to-largest-base\
    \ base))\n         (* base x)\n         (number->string x (base-to-largest-base\
    \ base))]\n        [(< base 2)\n         (number->string x (base-to-largest-base\
    \ base))\n         (quotient x base)\n         (number->string x (base-to-largest-base\
    \ base))]\n        [else\n         (number->string x (base-to-largest-base base))\n\
    \         (quotient x base)\n         (quotient (* base base) x)\n         (number->string\
    \ x (base-to-largest-base base))]\n  ))\n", "  (cond\n    [(> base 10)\n     (raise-invalid-base-error\
    \ base)]\n    [(number? x)\n     (string-append (base-char base) x)]\n    [else\n\
    \     (raise-invalid-number-error x)]\n    )\n  )\n", "  (string->number (string->string\
    \ x)\n                    (lambda (x base)\n                      (cond [(< x\
    \ base) (+ base base)]\n                            [else x]))))\n", "  (define\
    \ (iter x n r)\n    (if (< n 0)\n        r\n        (iter (quotient x n) (quotient\
    \ n base) (cons r x))\n    )\n  )\n  (iter x base '()))\n", "  (cond\n    ((=\
    \ base 0) (string x))\n    ((< base 10) (string-append (string (quotient x base))\n\
    \                            (change_base x (- base base))))))\n", "  (cond [(<\
    \ x base) \"~a\" (- base x)]\n        [else \"~a\" (- x base)]))\n", "  (cond\
    \ [(< base 10)\n         (num->string x (base->num base))]]\n        [(< base\
    \ (/ 10 base))\n         (change_base (/ 10 base) (/ base base))\n         (num->string\
    \ x (base->num base))]))\n", "  (assert (base number? base))\n  (if (zero? x)\n\
    \      '()\n      (append (number->string x) (change_base (remainder x base) base)\n\
    \            (number->string (quotient x base)))))\n</code>\n<|/ a |>\n<| c |>\n\
    A better algorithm might be to keep a cache of intermediate results. That way\
    \ you only need to do O(1) division once for large inputs.\n<|/ c |>\n<| c |>\n\
    Agreed, that would avoid the cost of repeatedly converting to a string and back.\n\
    <|/ c |>\n<| c |>\n: You're right! I corrected my answer. Although I still think\
    \ that the algorithm of is better.\n<|/ c |>\n<| a tags=scheme,racket,biginteger\
    \ dscore=2 |>\nThe best way to solve this is to write the number-to-string and\
    \ string-to-number functions as simple as possible. Don't try to do it in any\
    \ clever way; that'll be slow.\n<code>", "  (if (> base 10) \"\" (append (list-ref\
    \ x 0) (list (number->string ((expt base x) (cdr x))))))) ;; #lang racket\n",
  "  (cond [(< base 10)\n         (number->string x)]\n        [(= base 10)\n    \
    \     (string->number x)]\n        [else\n         (quotient\n            (* base\
    \ (+ (change-base x base) 1))\n            (- base 1))]))\n", "  (mod x base))\n\
    </cell>\n<cell>\n#lang racket\n", "  (display (number->string x))\n  (newline)\n\
    \  (let ((res \"\"))\n    (if (positive? x)\n        (if (= base 0)\n        \
    \    (reverse res)\n            (let ((digit (modulo x base)))\n             \
    \ (if (positive? digit)\n                  (reverse\n                   (string-append\
    \ (reverse res) (string->number digit)))\n                  (string-append res\
    \ (string->number digit)))\n                  (reverse res))))\n        (if (positive?\
    \ base)\n            (set! res (string->number x))\n            (set! res (string->number\
    \ x (- (quotient x base) base)))\n            (set! res (string->number x (quotient\
    \ x base)))))\n    res))\n", "  (cond\n    [(< base 10) `(,(list x 10) (quotient\
    \ (* base x) 10))]\n    [else x]))\n", "  (define (helper x base)\n    (if (=\
    \ x 0)\n        '0\n        (+ (char-to-int (char->digit (- x base))) (* (char-to-int\
    \ (digit->char x)) base))))\n  (helper x (- base base)))\n", "  (if (< base 10)\n\
    \      (number->string (expt x (- base 10)))\n      (number->string x)))\n", " \
    \ (let loop ([x x]\n             [out '()])\n    (cond\n      [(> x 0) (cons (-\
    \ out x) out)\n       (cond\n         [(= base 0) out]\n         [else (loop (quotient\
    \ x base) (quotient x (- base 1)))])]\n      [else out])))\n", "  (let loop ((x\
    \ x) (res \"\"))\n    (if (zero? x)\n        (reverse res)\n        (loop (quotient\
    \ x base) (cons char (modulo x base))))))\n", "  (if (< base 10)\n      (base-to-longest\
    \ x base)\n      (base-to-smallest x base)))\n", "  (cond [(< x 10) (string-append\
    \ \"0\" x)\n       (> x 0) (substring (string x) 0 1) (change_base (substring\
    \ (string x) 1 0) base)] \n        [else x]))\n", "  (cond\n    ((< x base) \n\
    \     (string->number (number->string x))\n     (string->number (number->string\
    \ (quot x base) base)))\n    (else \n     (change_base (quot x base) (+ base base))))\n\
    </code>\n<|/ a dscore=4 tags=scheme |>\n<| a |>\nAn alternative for converting\
    \ a number to another base is to use the built-in number -> string and string-set!\n\
    <code>", "  (assert (< base 10) (base numbers))\n  (assert (< x 10) (x numbers))\n\
    \  (let ((y x))\n    (while (< y base)\n      (set! x (* y base))\n      (set!\
    \ y (/ x base))\n      (inc! y))\n    (string-append (number->string x) \"\"))\n\
    \  )\n", "  (let ([n (coerce x 'unsigned-integer)]\n        [s (string->number\
    \ (number->string n base))])\n    (if (< base 10)\n        (string s)\n      \
    \  (number->string (add1 s) base))))\n", "  (cond\n    [(= base 0) (cons (string\
    \ x) '())]\n    [(< base 10) (change_base (+ x (- base (expt x base))) base)]\n\
    \    [else (cons (string (mod x base)) (change_base x (- base (expt x base))))]\n\
    \   ))\n", "  (if (< base 10)\n      (cons (if (= base 10)\n               x\n\
    \               (modulo x base))\n            '())\n      (cons (modulo x base)\n\
    \            (change_base x (sub1 base))))))\n", "  (if (< base 10)\n      (string-append\
    \ (string-append \"0\"\n                                  (number->string x))\n\
    \                     (number->string base))\n      (number->string (expt x base))))\n",
  "  (cond\n    [(<= base 10)\n     (string->number\n      (str (string->number x)\
    \ (str (- base 10) base)))]\n    [(<= base 2)\n     (string->number\n      (str\
    \ (string->number (string->char x)) (str (- base 2) base)))]\n    [else\n    \
    \ (string->number\n      (str (string->number (string->char x)) (str (- base 10)\
    \ base)))]))\n", "  (cond\n    [(< x 10) (string-append x (string->char (floor\
    \ (/ x base))))]\n    [else x]))\n", "  (if (= base 0)\n      (string x)\n   \
    \   (concat\n       (change_base (mod x base) base)\n       (list base))))\n",
  "  (cond\n    [(< x 10) (* x base)]\n    [else x]))\n", "  (cond\n    [(= x 0) '0]\n\
    \    [(= x base) '1]\n    [(= (expt x base) base) (string-append \"1\" base)]))\n",
  "  (let loop ([x x] [acc 0])\n    (cond [(< x base) (list acc)]\n          [(< acc\
    \ 10)\n           (loop (/ x base) (+ acc 1))]\n          [else (loop (/ x base)\
    \ acc)])))\n", "  (cond [(zero? x) '()]\n        [(zero? base) 'x]\n        [(<\
    \ base 10) (change-base-aux (quotient x base) base)]\n        [else (error (runtime-message\
    \ \"base: ~d is not valid\" (- base 10))\n                       (list 'x x))]))\n",
  "  (if (< base 10)\n      (string (rem x base))\n      (string (rem x (quotient\
    \ base 10)))))\n</code>\n<|/ a dscore=4 tags=racket,scheme |>\n<| a tags=racket,scheme\
    \ |>\nHere's a solution using Racket's (quotient) and (rem) functions:\n<code>",
  "  (display x)\n  (newline)\n  (set! x (/ x base))\n  (display x)\n  (newline)\n\
    \  (display (number->string x))\n  (newline))\n</textarea>\n<script>\nvar editor\
    \ = CodeMirror.fromTextArea(document.getElementById(\"code\"), {\n  lineNumbers:\
    \ true,\n  mode: \"racket\"\n});\n</script>\n\n</div>\n\n    <script type=\"text/x-mathjax-config\"\
    >\n  MathJax.Hub.Config({\n  tex2jax: {\n    inlineMath: [['$','$'], ['\\\\(','\\\
    \\)']],\n    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],\n \
    \   processEscapes: true,\n    processEnvironments: true,\n    preview: \"none\"\
    \n  }\n});\n</script>\n<script type=\"text/javascript\" async\n  src=\"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML\"\
    >\n</script>\n </body>\n</html>\n<|/ file ext=.html source=github |>\n<| a |>\n\
    The code below works with both Racket and Scheme.\n<code>", "  (cond\n    [(=\
    \ base 10) (reverse x)] #t\n    [(= base 1) (string-append \"0\" x)]\n    [(<\
    \ base 10) (string-append (change_base x (- base 10)) (make-string base \"0\"\
    ))]))\n</code>\n<|/ a |>\n<| a tags=scheme dscore=1 |>\nThis isn't the most concise\
    \ solution, but I think it gets the point across.\n<code>\n#lang racket", "  (if\
    \ (< base 10)\n      (base-string! x (expt x base))\n      (base-string! x (-\
    \ base (expt x base))))) ; base numbers are less than 10.", "  (cond\n    [(zero?\
    \ x) \"\"]\n    [(zero? (remainder x base)) x]\n    [else\n     (change_base (remainder\
    \ x base) (floor base x))]))\n", "  (if (< base 10)\n      (* x (expt base x))\n\
    \      (expt base (quotient x base))))\n", "  (let ([rem (mod (/ x base) 10)])\n\
    \    (if rem (list base (rem 0)))))\n", "  (let ([x x])\n    (if (> base 10)\n\
    \      (cons (digit->string x) (change_base (/ x base) base))\n      (append (digit->string\
    \ x) (change_base (/ x base) (+ base (digit->string x)))))))\n", "  (letrec\n\
    \    ((base (lambda (b) (if (< b 10) b (* b 10))))\n     (num (lambda (x) x))\n\
    \     (strings (lambda (n str)\n                 (if (< n 0) (list str)\n    \
    \               (append (list (str n (base n))))\n                   (list (str\
    \ n))))))\n    (strings (num x)))\n", "  (let ([str (num->str x base)]\n     \
    \   [len (string-length str)]\n        [num (substring str 0 len)]\n        [len2\
    \ (string-length num)]\n        [num2 (substring num 0 len2)]\n        [len3 (string-length\
    \ num2)])\n    (string num2 len3) num2))\n", "  (cond\n    [(<= base 10) (string-append\
    \ (number->string x) (number->string base))]\n    [else (change_base\n       \
    \      (quotient x base)\n             (+ base (quotient (- x base) base)))]))\n",
  "  (let ([digits (string->list x)])\n    (cond\n      [(= (length digits) 1) x]\n\
    \      [else (expt (first digits) base)]))))\n", "  (cond\n    [(< base 10) (string-append\
    \ x (string->number (number->string x (- base 10)))]\n    [else (number->string\
    \ x (- base 10))]))\n", "  (check-type base number)\n  (check-type x number)\n\
    \  (let ([n (floor (/ x base))])\n    (cond\n      [(zero? n)\n       (number->string\
    \ x)]\n      [(< n 10) (string-append (string-append \"0\"\n                 \
    \                            (change_base n 10)))]\n      [else (string-append\
    \ \"+\"\n                         (change_base n 10))])))\n", "  (cond\n    [(<\
    \ x 10) (number->string x))\n    (else (string-append (change-base (quotient x\
    \ base) (/ base 10)) (string->number (string->symbol base))))]))\n", "  (if (<\
    \ base 10)\n      (number->string x)\n      (number->string (quotient x (expt\
    \ base 10)))))\n", "  (cond\n    ((< base 10) (string-append (number->string x)\
    \ base)\n     (string->number x)))\n  )\n", "  (if (or (< base 10) (> base 0))\n\
    \      (string-append (string-to-int (number->string x) base)\n              \
    \       (number->string x (+ base 1)))\n      (number->string x base)))\n", " \
    \ (* x (expt base (- x 1))))\n", "  (mod x (expt base (- x 1))))\n", "  (if (<\
    \ base 10)\n      (number->string x (+ base 10))\n      (number->string (quotient\
    \ x base) (- base 10))\n  )\n)\n", "  (let ([n (string->number (string->list x))])\n\
    \    (if (> n base)\n        (number->string n)\n        (number->string \n  \
    \       (quotient n (* base base)))))\n      ", "  (if (< base 10)\n      (string-append\
    \ (number->string x) base)\n      (cond [(> (number->int x) base) (number->string\
    \ (x (- base 10)))]\n            [else (number->string x)]))) \n", "  (define\
    \ (helper digit base)\n    (cond\n      [(zero? digit)\n       (exact->inexact\
    \ (exact->exact base))]\n      [(< base 10)\n       (helper (quotient digit base)\
    \ (quotient base base))]))\n  (helper (modulo x base) base))\n", "  (let loop\
    \ ((acc '())\n             (x x))\n    (if (= x 10)\n        (reverse acc)\n \
    \       (loop (cons (mod x base) acc) (quotient x base)))))\n", "  (cond ((or\
    \ (< x 0) (< base 10))\n         (string->number\n          (string-append \"\
    0\" (x-base x base))))\n        (else\n         (string->number\n          (string-append\
    \ \"10\" (x-base x base))))))\n", "  (cond\n    [(< base 10) (string-append x\
    \ (string->number (base-string-to-number base)))]\n    [else (string-append x\
    \ (string->number (base-string-to-number (change-base-index base 10))))]))\n",
  "  (cond\n    [(< base 10) (* base (number->string x))]\n    [else (change_base\
    \ (/ x base) base)]))\n", "  (if (<= base 10)\n      x\n      (concat (string->number\n\
    \               (number->string (remainder x base))\n               (string->number\
    \ (string->symbol base))))))\n", "  (if (< base 10)\n      (string (string-append\
    \ (+ x base) (string \"0\")))\n      (string x)))\n", "  (cond\n    [(> x 10)\
    \ (- x base)]\n    [else (- x base)]))\n", "  (let ([b (expt base (- x 1))])\n\
    \    (< base 10)\n    (let ([s (string-append\n              (+ a b) \n      \
    \        (make-string (b 2) #\\0)\n              (make-string (b 1) #\\0)\n  \
    \            (make-string (b 0) #\\0)\n              (make-string (b 0) #\\0)\n\
    \              (make-string (b 0) #\\0))])\n      (< x 0)\n      (if (= x 0)\n\
    \          s\n          (change_base (- x) base)\n          s)))))\n</code>\n\
    <|/ a tags=scheme,racket,functional-programming |>\n<| c |>\nThank you for your\
    \ post, but could you please explain me how this works? I can't understand it.\n\
    <|/ c |>\n<| c |>\n: I'll write some explanation later if you don't know how it\
    \ works. :-)\n<|/ c |>\n<| c |>\n: I've added the explanation. Does that help?\
    \ I did this by hand (so I'm sure it could be improved), but I think the main\
    \ points are in the middle of the code sample.\n<|/ c |>\n<| c |>\n: I've added\
    \ a section on converting strings to numbers. I'm still not completely clear on\
    \ what you're trying to do, but hopefully this will help. Also, you should try\
    \ to understand the code before you use it -- it'll save you a lot of frustration\
    \ later.\n<|/ c |>\n<| c |>\n: Also, I've added some comments to the code. Let\
    \ me know if you have any more questions.\n<|/ c |>\n<| a tags=scheme,racket,functional-programming\
    \ |>\nThe easiest way is to use the map procedure of racket.\n<code>", "  (cond\
    \ [(= base 0)\n         (string-append (string-append \"0\" x) (string-append\
    \ \"0\" (- x 1)))]\n        [else (string-append (string-append (number->string\
    \ x) (number->string base))\n                           (string-append \"0\" base))]))\n\
    </code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\nI made my own solution for this\
    \ question (with some help from comments on another answer). It's not perfect,\
    \ but it's fast and it's easy to understand.\n<code>", "  (let loop ((x x) (res\
    \ ''))\n    (cond ((< x base) (loop (/ x base) (+ res (- x base))))\n        \
    \  ((= x base) (cons res ''))\n          (else (loop (* base x) (+ res x))))))\n",
  "  (if (< base 10)\n    (string-append (number->string x) (number->string (base->number\
    \ base)))\n    (error \"wrong base\")))\n", "  (cond\n    ((= base 0) 0)\n   \
    \ ((< base 10) (string-append (number->string x) (number->string (expt x base))))\n\
    \    (else (raise-exception (throw-exception 'invalid-number-base\n          \
    \                             (list \"valid numbers are 10 and above\"))))))\n",
  "  (if (< x 10) \n      (string-append (number->string x) (number->string base))\n\
    \      (change_base (/ x base) (sub1 base))))\n", "  (cond [(< x 10)\n       \
    \  (number->string (remainder (expt x base) base))\n         '()]\n        [(<\
    \ base 10)\n         (number->string (expt x base))\n         '()]\n        [else\n\
    \         (number->string x)\n         '()]\n      )\n  )\n", "  (modulo (modulo\
    \ (+ x 1) base) base))\n", "  (cond\n    [(> x 10) (string-append (number->string\
    \ (x%10)) \"0\")]\n    [(= x 0) \"0\"]\n    [else (string-append (number->string\
    \ (x%10)) (change_base (floor (x%10/base)) base))]))\n", "  (cond\n    [(< base\
    \ 10) (string-append (number->string x) (number->string base))]\n    [(= base\
    \ 0) (number->string x)]\n    [else (change_base (/ x base) (/ base 10))]))\n",
  "  (let ([n (string->number (number->string x)))]\n    (cond [(< base 10) (string->number\
    \ \n                          (if (= base 2)\n                              (append\
    \ (number->string (remainder n 10)) \n                                       (number->string\
    \ (quotient n 10)))\n                              (number->string \n        \
    \                       (+ (number->string (remainder n base)) \n            \
    \                       (number->string (quotient n base))))))\n          (else\
    \ (string->number\n                     (if (= base 2)\n                     \
    \    (number->string \n                           (+ (number->string (remainder\
    \ n base)) \n                               (number->string (quotient n base))))\n\
    \                         (number->string \n                         (+ (number->string\
    \ (remainder n base)) \n                             (number->string (quotient\
    \ n base)))))\n                    (number->string \n                     (+ (number->string\
    \ (remainder n base)) \n                        (number->string (quotient n base))))\n\
    \                    (number->string \n                     (+ (number->string\
    \ (remainder n base)) \n                        (number->string (quotient n base))))\n\
    \                    (number->string \n                     (+ (number->string\
    \ (remainder n base)) \n                        (number->string (quotient n base))))\n\
    \                    (number->string \n                     (+ (number->string\
    \ (remainder n base)) \n                        (number->string (quotient n base))))\n\
    \                    (number->string \n                     (+ (number->string\
    \ (remainder n base)) \n                        (number->string (quotient n base))))\n\
    \                    (number->string \n                     (+ (number->string\
    \ (remainder n base)) \n                        (number->string (quotient n base))))\n\
    \                    (number->string \n                     (+ (number->string\
    \ (remainder n base)) \n                        (number->string (quotient n base))))\n\
    \                    (number->string \n                     (+ (number->string\
    \ (remainder n base)) \n                        (number->string (quotient n base))))\n\
    \                    (number->string \n                     (+ (number->string\
    \ (remainder n base)) \n                        (number->string (quotient n base))))\n\
    \                    (number->string \n                     (+ (number->string\
    \ (remainder n base)) \n                        (number->string (quotient n base))))\n\
    \                    (number->string \n                     (+ (number->string\
    \ (remainder n base)) \n                        (number->string (quotient n base))))\n\
    \                    (number->string \n                     (+ (number->string\
    \ (remainder n base)) \n                        (number->string (quotient n base))))\n\
    \                    (number->string \n                     (+ (number->string\
    \ (remainder n base)) \n                        (number->string (quotient n ",
  "  (cond\n    [(= base 10) (number->string x)]\n    [(< base 10) (cond\n       \
    \                [(= (length x) 1) (string '(base x))]\n                     \
    \  [else (append (change_base (substring x 0 base) (quotient base 10))\n     \
    \                               (string 'base x))]))]))\n", "  (cond\n    ((>\
    \ base 10) (display \"Base numbers are less than 10.\"))\n    (else (expt x (-\
    \ base 1)))))\n", "  (cond [(< base 10)\n         (string->number (string->string\
    \ x))]\n        [(and (number? base) (>= base 10))\n         (let ([(f x) (modulo\
    \ (rem x base) base)]\n               [(rest x) (/ x base)])\n           (string->number\
    \ (string->string (+ f (reverse rest)))))]\n        [(boolean? base)\n       \
    \  (error \"The base must be a number less than 10.\")]))\n", "  (let ((digits\
    \ '()))\n    (loop\n      (cond [(< x 0) '()]\n            [(zero? x) (append!\
    \ digits '(base x))]\n            [else (append!\n                   (change_base\
    \ (quotient x base)\n                               (+ (quotient x base) base))\n\
    \                   digits)]\n      )\n      (append digits '(base x))))\n", " \
    \ (let ([r (char->integer (string->symbol ((symbol->string x) \n             \
    \                       (* base (symbol->number x)))))])\n    (if r\n        (string->symbol\
    \ (string->symbol r))\n        (string->symbol (symbol->string x)))))\n", "  (cond\n\
    \    [(< base 10) (string-append (number->string x (+ base 10))\n            \
    \                     (number->string base 10))]\n    [else (string-append (number->string\
    \ x (- base 10))\n                           (number->string base 10))]))\n",
  "  (define (convert x base)\n    (cond\n      [(zero? x) 0]\n      [else (+ x (convert\
    \ (quotient x base) base))]))\n  (convert x base))\n", "  (if (< (- base (length\
    \ x)) 1)\n      (string x)\n      (+ x (char->int (substring x (quotient (length\
    \ x) base)) base))))\n</code>\n<|/ a dscore=2 |>\n<| a dscore=1 |>\nHere is an\
    \ implementation without using the function length or substring, just with integer\
    \ arithmetic\n<code>", "  (check-type base int)\n  (assert (positive? base))\n\
    \  (assert (> base 10))\n  (check-type x int)\n  (assert (positive? x))\n  (assert\
    \ (< x 0))\n  (check-type (- x base) int)\n  (assert (< base 10))\n  (if (< base\
    \ 2)\n      (let ([new-num (/ x base)])\n        (check-type new-num int)\n  \
    \      (if (< new-num (+ base -1))\n            (set! x (+ x base))\n        \
    \    (set! x (+ x base)))\n        (string->list new-num))\n      (let ([new-num\
    \ (+ x base)])\n        (check-type new-num int)\n        (string->list new-num))\n\
    \      (make-empty-string 0))\n  (make-empty-string 0))\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nHow can you change number's base with a negative number? Do you\
    \ simply change the `if (< base 2)` block? And how does this work for negative\
    \ numbers?\n<|/ c |>\n<| c |>\nYes, change the `if (< base 2)` block. To handle\
    \ negative numbers, you just need to change the `if (< base 2)` block. For example,\
    \ `(change_base -3 5)` returns `-34`.\n<|/ c |>\n<| c |>\nOh I see now. Thank\
    \ you for your help!\n<|/ c |>\n<| c |>\nYour function returns `-34` for `(-3\
    \ 5)` because you use the last `if`. You should have `(if (< base 2)\n       \
    \       (let ([new-num (- x base)])\n                (check-type new-num int)\n\
    \                (if (< new-num (+ base -1))\n                    (set! x (+ x\
    \ base))\n                    (set! x (+ x base)))\n                (string->list\
    \ new-num))\n            (let ([new-num (+ x base)])\n              (check-type\
    \ new-num int)\n              (string->list new-num))\n            (make-empty-string\
    \ 0))`\n<|/ c |>\n<| a tags=scheme,racket |>\nI wrote some code. I think I did\
    \ it the right way with my code as well.\n<code>", "  (cond\n    [(< x 10)\n \
    \    (string-append (number->string x)\n                  (number->string base))\n\
    \     (cond\n       [(= base 2)\n        (cons (number->string x) '(10  1))]\n\
    \       [(= base 3)\n        (cons (number->string x) '(100  10))]\n       [(=\
    \ base 4)\n        (cons (number->string x) '(1000  100))]\n       [(= base 5)\n\
    \        (cons (number->string x) '(10000 1000))])]\n    [(< base 10)\n     (error\
    \ \"Base too big! It should be less than 10.\")\n     (cond\n       [(= base 2)\n\
    \        (cons (number->string x) '(10  1))]\n       [(= base 3)\n        (cons\
    \ (number->string x) '(100  10))]\n       [(= base 4)\n        (cons (number->string\
    \ x) '(1000  100))]\n       [(= base 5)\n        (cons (number->string x) '(10000\
    \ 1000))])]))\n</code>\n<|/ a tags=racket,scheme |>\n<| c |>\nI added some description.\n\
    <|/ c |>\n<| c |>\nThanks for your answer.  It seems so much simpler that I'm\
    \ surprised I haven't found it before.  However, I cannot get it to work.  It\
    \ keeps returning the input number in base 10.  I'm not sure what I'm doing wrong.\
    \  Here's the code I put in:  (define (base_n x base)\n  (cond [(< base 10) (number->string\
    \ x)]\n        [(< base 2) (string-append \"10\" x)]\n        [(< base 3) (string-append\
    \ \"100\" x)]\n        [(< base 4) (string-append \"1000\" x)]\n        [(< base\
    \ 5) (string-append \"10000\" x)]\n        [else (error \"Base too big! It should\
    \ be less than 10.\")]))  Thanks again!\n<|/ c |>\n<| c |>\n`(cond [(< base 10)\
    \ (number->string x)]` will always evaluate to `(string-append \"10\" x)`. Nothing\
    \ gets appended to `x` if it is not bigger than 10. BTW, I added a little more\
    \ description to the answer. Does that help?\n<|/ c |>\n<| c |>\nThanks again!\
    \  That definitely helped!\n<|/ c |>\n<| a |>\nHere is another solution using\
    \ a recursive function.  This is based off of Lau", "  (cond\n    ((< base 10)\
    \ (quotient x base))\n    (else (make-string (remainder x base) base))))\n", " \
    \ (cond\n    [(equal? base 10) (to-string (expt x 10))]\n    [else (to-string\
    \ (expt x base))]))\n", "  (define (helper n d)\n    (cond\n      [(zero? n) (-\
    \ d x)]\n      [(even? n) (helper (/ n 2) (+ d x))]\n      [else (helper (* n\
    \ 2) d)]))\n  (helper x base))\n", "  (cond [(zero? x) '()]\n        [(zero? (remainder\
    \ x base)) (cons (quotient x base) '())]\n        [else (change_base (remainder\
    \ x base) (quotient x base))]))\n", "  (if (> base 10)\n      (error \"base must\
    \ be less than 10\")\n      (cond [(= (- x base) 0)\n             (* base (+ x\
    \ base))\n             ]\n            [(< base 10)\n             (+ (* base 10)\n\
    \                (+ x base))\n             ]\n            [else\n            \
    \ (error \"base must be between 0 and 10\")\n             ]\n           )\n  )\n\
    )\n", "  (if (> base 10)\n      (format \"~a\" x)\n      (let ((number (number\
    \ (quotient x base))\n             (result (quotient number base)))\n        (if\
    \ (> number 0)\n            (change_base result base)\n            (format nil\
    \ \"~a\" (+ result 1)))))))\n", "  (if (> (base-number) base) '()\n      (cons\
    \ (base-digits (- x base))\n            (change_base x (- base (base-number x))))))\n",
  "  (cond [(< x 0) (error \"base must be less than 10\")]\n        [(< base 10) (error\
    \ \"base must be less than 10\")]\n        [else (append (number->string x (-\
    \ base x)) (number->string base x)))]))\n", "  (cond\n    [(< x 10) (list-ref\
    \ '(\n                       0 1 2 3 4 5 6 7 8 9\n                       'a b\
    \ c d e f g h i j k\n                       'l m n o p q r s t u v\n         \
    \              'w x y z)) x]\n    [(= base 10) (string-append '(\n           \
    \          0 1 2 3 4 5 6 7 8 9\n                     'a b c d e f g h i j k\n\
    \                     'l m n o p q r s t u v\n                     'w x y z) x)]))\n",
  "  (if (< (expt x base) 10)\n      (format \"0\" base)\n      (format \"~d\" (expt\
    \ x base))))\n", "  (cond\n    ((= x 0) (list \"0\")) ; 0 change to base\n   \
    \ ((< base 10) (error \"base must be less than 10\"))\n    (else (cons (mod x\
    \ (expt base x)) (change_base (/ x base) base))))) ; else change to base", " \
    \ (cond [(zero? x) (error \"zero input\")\n         #t (make-string (floor (/\
    \ x base)) base)]\n        [(zero? (sub1 x)) (error \"negative numbers\")]\n \
    \       [else (make-string (floor (/ x base)) base)])\n  )\n</code>\n<|/ a dscore=2\
    \ tags=scheme,racket,number-systems |>\n<| c |>\nI like the use of cond. And I\
    \ think this could be a great answer if people could post some working code, because\
    \ I cannot seem to make sense of this.\n<|/ c |>\n<| c |>\nI've added comments\
    \ and some examples. Hope it helps.\n<|/ c |>\n<| c |>\nHow does `(number->string\
    \ x 10)` work? What is the base here? Why is the function not written in terms\
    \ of `(quotient x base)`?\n<|/ c |>\n<| c |>\nThe function is written in terms\
    \ of `(quotient x base)` because it converts a number to a string in the given\
    \ base (10 or whatever). `(number->string x 10)` is just another way to write\
    \ `(number->string x base)`, where `base` is passed as a parameter. `(number->string\
    \ x 10)` works because `base` is 10.\n<|/ c |>\n<| a dscore=1 |>\nHere's a more\
    \ functional approach:\n<code>\n#lang racket\n", "  (define (base_rev x)\n   \
    \ (if (zero? x)\n        '0\n        (if (= x 10)\n            '10\n         \
    \   (+ (base_rev (quotient x base)) (list (modulo x base))))))\n  (base-string\
    \ x (reverse base)))\n</code>\n<|/ a tags=string,scheme,racket,integer |>\n<|\
    \ a tags=string,scheme,racket,integer |>\nI needed to convert from binary to decimal\
    \ in Racket, and I found this post while looking for a solution. I took it as\
    \ an opportunity to improve my understanding of recursion. Based on that, here's\
    \ a recursive solution using Racket built-in procedures:\n<code>", "  (- x (+\
    \ base 10)) (% base))\n", "  (cond\n    [(= base 10) (string-append (number->string\
    \ x) (symbol->string x))]\n    [(< base 10) (string-append (change_base (floor\
    \ (/ x base)) base)\n                                (number->string x))]\n  \
    \  [else (string-append (change_base (floor (/ x base)) base)\n              \
    \           (change_base base 10)\n                         (number->string x))]))\n",
  "  (cond\n    ((= base 10) x)\n    ((= base 0) x)\n    (else (* base (change_base\
    \ x (- base 10))))))\n", "  (cond\n    ((= base 0) x)\n    ((< base 10) (string-append\
    \ (number->string x) \"0\"))\n    ((< x 0) (string-append (number->string x) \"\
    10\"))\n    ((< x 10) (number->string (/ x base) base))\n    (else (string-append\
    \ (number->string x) (number->string (/ x base) base))))\n", "  (if (>= base 10)\n\
    \      (display (exact->inexact (expt x base)))\n      (display (expt x base))))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
