name: HumanEval_55_fib
language: rkt
prompt: "#lang racket\n\n;; Return n-th Fibonacci number.\n;; >>> (fib 10)\n;; 55\n\
  ;; >>> (fib 1)\n;; 1\n;; >>> (fib 8)\n;; 21\n(define (fib n)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate fib))\n\
  \    (check-equal? (candidate 10) 55)\n    (check-equal? (candidate 1) 1)\n    (check-equal?\
  \ (candidate 8) 21)\n    (check-equal? (candidate 11) 89)\n    (check-equal? (candidate\
  \ 12) 144)\n))\n\n(test-humaneval)"
completions: ["  (cond [(= n 1) 1]\n        [(= n 2) 1]\n        [else (+ (fib (-\
    \ n 1)) (fib (- n 2))))]))\n", "  (if (<= n 0)\n      0\n      (+ fib (- n 1))))",
  "  (cond ((= n 0) 1)\n        ((= n 1) 1)\n        (else (+ (fib (- n 1)) (fib (-\
    \ n 2))))))\n", "  ;; TODO: memoize fib(n-1) and fib(n-2).\n  (define (helper\
    \ a b)\n    (if (= n 0)\n        a\n        (helper (+ a b) (b a))))\n  (helper\
    \ (+ (* 3 2) 1) 1))\n", "  (if (< n 2) 1\n      (+ (fib (- n 1)) (fib (- n 2)))))\n",
  "  (cond ((= n 1) 1) ((= n 2) 2) (else (+ (fib (- n 1)) (fib (- n 2)))))\n)\n",
  "  (if (<= n 0)\n      0\n      (+ (fib (- n 1)) (* (fib (- n 2)) n))))\n", "  (if\
    \ (= n 0)\n      0\n      (+ (fib (- n 1)) (fib (- n 2)))))\n", "  (cond [(= n\
    \ 0)\n         1]\n        [(= n 1)\n         1]\n        [else\n         (+ (fib\
    \ (- n 1)) (fib (- n 2)))]))\n", "  (if (< n 1)\n      1\n      (+ (fib (- n 1))\
    \ (- (fib (- n 1)) (fib (- n 2))))))\n", "  (cond [(= n 0) 1]\n        [(= n 1)\
    \ 1]\n        [else (+ (fib (- n 1)) \n                (fib (- n 2)))]))\n", " \
    \ (if (zero? n) 1\n      (+ (fib (- n 1)) ((fib (- n 2)) 0))))\n", "  (cond [(<\
    \ n 1) 1]\n        [(= n 1) 1]\n        [else (+ (fib (- n 1)) (fib (- n 2))))))\n",
  "  (cond\n    [(= n 0) 0]\n    [(= n 1) 1]\n    [else (+ (fib (- n 1)) (* (fib n)\
    \ (fib n)))]))\n", "  (cond [(< n 1) 1]\n        [else (+ (fib (- n 1)) (fib (-\
    \ n 2)))]))\n", "  (if (zero? n)\n      1\n      (+ (fib (- n 1))\n         (fib\
    \ (- n 2)))))\n", "  (if (= n 0)\n      0\n      (+ (fib (- n 1)) (fib (- n 2)))))\n\
    </code>\n<|/ a |>\n<| a dscore=0 tags=lisp,scheme |>\n<code>", "  (cond [(= n\
    \ 0) 1]\n        [else (+ (fib (- n 1)) (fib (- n 2)))]))\n", "  (cond [(= n 0)\n\
    \         1]\n        [(= n 1)\n         1]\n        [else\n         (+ (fib (-\
    \ n 1)) (fib (- n 2)))]))\n", "  (if (= n 1)\n      1\n      (+ (fib (- n 1))\
    \ (fib (- n 2)))))\n", "  (cond [(= n 0)\n         1]\n        [(= n 1)\n    \
    \     1]\n        [else\n         (+ (fib (- n 1)) \n            (fib (- n 2))))]))\n",
  "  (fib-iter 1 2 n))\n", "  (cond ((= n 0) 0)\n        ((= n 1) 1)\n        (else\
    \ (+ (fib (- n 1)) fib (- n 2)))))\n</code>\n<|/ a tags=racket,recursion,fibonacci,scheme\
    \ |>\n<| a tags=racket,recursion,fibonacci,scheme |>\nA simple solution using\
    \ Racket's built-in fibonacci procedure:\n<code>", "  (cond [(< n 2)\n       \
    \  1]\n        [(= n 0)\n         1]\n        [else\n         (+ (fib (- n 1))\n\
    \            (fib (- n 2)))]))\n</code>\n<|/ a |>\n<| c |>\nThank you very much\
    \ - this is very interesting. I just tried to make a quick example in Racket.\
    \ `let (fib (make-fib 10))` returns `#<procedure:fib>`, but the output is `55`.\
    \ Do you have any idea why?\n<|/ c |>\n<| c |>\nOops, I made a mistake. The `(fib\
    \ (make-fib 10))` part should be `(fib 10)`, not `(fib (make-fib 10))`.\n<|/ c\
    \ |>\n<| a dscore=1 |>\n<code>", "  (cond [(zero? n) 1]\n        [(equal? n 1)\
    \ 1]\n        [else (+ (fib (- n 1)) (fib (- n 2)))]))\n", "  (if (zero? n) 0\n\
    \      (+ \n        (fib (- n 1))\n        (fib (- n 2)))))\n", "  (if (< n 2)\n\
    \      n\n      (+ (fib (- n 1)) (fib (- n 2)))))\n", "  (cond [(= n 0) 1]\n \
    \       [(= n 1) 1]\n        [else (+ (fib (- n 1)) (fold (+ 1) 0 (fib (- n 2))))]))",
  "  (cond\n    [(< n 1) 1]\n    [(<= n 1) (fib n-1 (+ 1 n))]))\n", "  (cond ((< n\
    \ 0) 0)\n        ((= n 1) 1)\n        (else (+ (fib (- n 1)) (fib (- n 2))))))\n",
  "  (if (= n 0) 0\n      (let ((x (fib n-1)))\n        (+ (fib (- n 1))\n       \
    \    (x (- n 1))))))\n", "  (if (< n 2)\n      n\n      (+ (fib (- n 1)) (fib\
    \ (- n 2)))))\n", "  (cond [(< n 1) 1]\n        [else (+ (fib (- n 2)) (fib (-\
    \ n 1)))]))\n", "  (let ([a 1])\n    (if (= n 0)\n        a\n        (fib (- n\
    \ 1))\n        (+ a (fib n))))))\n", "  (if (zero? n)\n      1\n      (+ (fib\
    \ (sub1 n)) (fib (sub1 n)))\n    )\n  )\n", "  (cond\n    [(zero? n) 1]\n    [(=\
    \ n 1) 1]\n    [(= n 2) 1]\n    [else (+ (fib (- n 1)) (fib (- n 2)))]))\n", " \
    \ (cond\n    [(= n 0) 0]\n    [(= n 1) 1]\n    [else (+ (fib (- n 1))\n      \
    \       (fib (- n 2)))))]\n)\n", "  (cond ((< n 2) 1)\n        ((= n 2) 2)\n \
    \       (else (+ (fib (- n 1)) (fib (- n 2))))))\n</code>\n<|/ a dscore=0 tags=racket\
    \ |>\n<| c |>\nI did this exercise in Racket using the same definition of fibonacci,\
    \ but I keep getting stack overflow. Do you know why that might be? I edited the\
    \ original post to include my code and errors.\n<|/ c |>\n<| c |>\nYou're still\
    \ calling the same function over and over again without changing any of their\
    \ arguments. I modified my solution to fix that.\n<|/ c |>\n<| c |>\nThanks for\
    \ your response! I still keep getting stack overflow when I try to run this solution.\
    \ I am very confused because I thought that since I defined n as a parameter,\
    \ I wouldn't need to call the function recursively, so what am I doing wrong?\
    \ Do I need to define n in the function before I call the function? Thanks!\n\
    <|/ c |>\n<| c |>\n`n` is a parameter to the `fib` function, so it has to be passed\
    \ as an argument to `fib`, not `add`.\n<|/ c |>\n<| c |>\nThanks for your response!\
    \ I tried using an example from SICP that had a similar function and I still get\
    \ stack overflow. Do you know what could be the cause of this? I edited my original\
    \ post to include my code and errors.\n<|/ c |>\n<| a dscore=0 |>\nHere's a very\
    \ simple example of a recursive solution in Racket:\n<code>", "  (cond ((= n 0)\
    \ 1)\n        ((= n 1) 1)\n        (else (+ (fib (- n 1)) (fib (- n 2))))))\n",
  "  (cond [(= n 0) 1]\n        [else (+ (fib (- n 1)) (fib (- n 2))) ]))\n", '  (fib-cache
    n (cons 0 1)))', "  (cond [(= n 0) 0]\n        [(= n 1) 1]\n        [(= n 2) 1]\n\
    \        [else\n         (+ (fib (- n 1))\n            (fib (- n 2)))]))\n", " \
    \ (cond [(< n 0)\n         (error \"Negative Fibonacci number!\" n)]\n       \
    \ [else\n         (+ (fib n 1 1)\n            (fib n (+ 1 2) 1))]))\n", "  (cond\
    \ [(= n 1) 1]\n        [(= n 2) 1]\n        [else (+ (fib (- n 1)) (fib (- n 2)))]))\n",
  "  (if (< n 1)\n      1\n      (+ (fib (- n 1)) (fib (- n 2)))))\n", "  (cond [(=\
    \ n 0) 1]\n        [else (+ (fib (- n 1)) (fib (- n 2)))]))\n", "  (if (<= n 2)\
    \ 1 (+ (fib (- n 1)) 1)))\n</code>\n<|/ a tags=racket,scheme dscore=1 |>\n<| c\
    \ |>\nThe OP is trying to implement `fibonacci` in Racket rather than Scheme,\
    \ which is why they have tagged the question as `racket`.\n<|/ c |>\n<| a |>\n\
    If you have the choice of which language to write the program in, the following\
    \ is a program that calculates the fibonacci sequence in Scheme:\n<code>", " \
    \ (if (< n 2) 0\n      (+ (fib (- n 1)) \n         (fib (- n 2)))))\n", "  (fib-aux\
    \ (car lst) (cdr lst) 0 n))\n", "  (if (< n 1)\n      n\n      (fib 0 (- n 1)\
    \ (+ n 1))))\n", "  (if (zero? n)\n      1\n      (+ (fib (- n 1))\n         (fib\
    \ (- n 2)))))\n</code>\n<|/ a |>\n<| c |>\nThat is an interesting solution which\
    \ does not require the use of tail recursion.  Do you know how it could be modified\
    \ to work without tail recursion?\n<|/ c |>\n<| c |>\n: I agree with you. My initial\
    \ version was tail recursive, but then I realized that in some cases (like `fib`)\
    \ it could be *not* tail recursive. After a while, I realized that it would be\
    \ a lot easier to understand without tail recursion. For a tail-recursive version\
    \ see my other answer, which was about the same time ago.\n<|/ c |>\n<| a tags=fibonacci,racket\
    \ |>\nHere is the implementation without recursion:\n<code>", "  (cond [(= n 0)\
    \ 1]\n        [(= n 1) 1]\n        [else (+ (fib (- n 1)) (fib (- n 2)))]))",
  "  (fibo n 0 1))\n", "  (if (= n 0)\n      1\n      (+ (fib (- n 1)) \n        \
    \ (fib (- n 2)))))\n", "  (cond\n    [(= n 0) 1]\n    [(= n 1) 1]\n    [(even?\
    \ (- n 2)) (+ fib (- n 1)) (+ fib (- n 2))]))\n", "  (define (fib-iter i f)\n\
    \    (cond\n      [(= i 0) (list 1)]\n      [(< i n) (append (fib-iter (sub1 i)\
    \ f) (list 0))]\n      [else (append (fib-iter (sub1 i) f) (fib-iter (sub1 n)\
    \ (lambda (x) (+ f x))))]\n      ))\n  (fib-iter n lambda (x) (+ x 1)))\n", " \
    \ (cond\n    [(= n 0) 0]\n    [(= n 1) 1]\n    [else (+ (fib (- n 1)) (freq n)))]))\n",
  "  (cond [(< n 2) 1]\n        [(< n 2) 1]\n        [(= n 0) 1]\n        [else (+\
    \ (fib (- n 1))\n                 (fib (- n 2))))]))\n", "  (cond ((= n 0) 1)\n\
    \        ((= n 1) 1)\n        ((= n 2) 2)\n        (else (+ (fib (- n 1)) (fib\
    \ (- n 2))))))\n", "  (let ([a (atom 0)\n        b (atom 1)\n        c 0]\n  \
    \      (fibo 0)\n        (fibo 1))\n    (cond\n      [(= n 0) (atom 0)]\n    \
    \  [(= n 1) (atom 1)]\n      [(>= n 2) (do\n                (fibo (+ a b)) (fibo\
    \ (+ b c))\n                (+ (fibo (+ a b)) (fibo (+ b c)))\n              \
    \  (+ (fibo a) (fibo b)))]\n      [else (do\n              (fibo (+ a b)) (fibo\
    \ (+ b c))\n              (fibo (+ a b)) (fibo (+ b c))\n              (fibo a)\
    \ (fibo b))]))))\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThe language is definitely\
    \ not Racket, but it is very close, and it's really helpful to see how it's written\
    \ using \"let\". I like the use of the \"atom\" function which makes things look\
    \ a bit more like Clojure than Racket.\n<|/ c |>\n<| a tags=scheme,racket,fibonacci\
    \ |>\n<code>", "  (cond ((= n 1) 1)\n        ((= n 2) 1)\n        ((= n 3) 2)\n\
    \        (else (+ (fib (- n 1)) (fib (- n 2))))))\n", "  (let ((fib1 (list 1 1)))\n\
    \    (cond ((< n 2)\n           (car fib1))\n          ((= n 2)\n           (car\
    \ fib1))\n          (else (let loop ((n1 (+ n 1))\n                          \
    \ (fib1 (list* fib1 (cdr fib1))))\n                     (cond\n              \
    \        ((< n1 2)\n                       (car fib1))\n                     \
    \ ((= n1 2)\n                       (car fib1))\n                      (else (loop\
    \ (+ n1 (- n1 2)) (cdr fib1))))))))\n", "  (if (= n 1)\n      1\n      (+ (fib\
    \ (- n 1)) (fib (- n 2)))))\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThat is awesome!\
    \ I didn't know about the fibonacci number theorem.\n<|/ c |>\n<| c |>\nThe answer\
    \ is wrong. It returns fibonacci numbers that start with 0 not 1.\n<|/ c |>\n\
    <| a dscore=2 |>\nHere's my take. Not as straightforward as the other answers,\
    \ but it does what it says on the tin.\n<code>\n#lang racket\n", "  (if (< n 2)\n\
    \      1\n      (+ (fib (- n 1)) (fib (- n 2)))))\n", "  (cond [(= n 0) 1]\n \
    \       [(= n 1) 1]\n        [else (+ (fib (- n 1)) (fib (- n 2)))]))\n", "  (if\
    \ (= n 0)\n      0\n      (+ (fib (- n 1)) (fib (- n 2)))))\n</cell>\n<text>\n\
    \u0422\u0435\u043F\u0435\u0440\u044C \u0432\u043C\u0435\u0441\u0442\u043E \u0447\
    \u0438\u0441\u043B\u0430 \u0440\u0435\u0448\u0435\u043D\u0438\u044F \u044D\u0442\
    \u0438\u0445 \u043F\u0440\u043E\u0438\u0437\u0432\u0435\u0434\u0435\u043D\u0438\
    \u0439 \u043F\u0440\u0438\u0432\u0435\u0434\u0438\u0442\u0435 \u0433\u0440\u0430\
    \u0444\u0438\u043A \u0444\u0443\u043D\u043A\u0446\u0438\u0438 \u0438\u0437 \u043F\
    \u0440\u043E\u0448\u043B\u043E\u0433\u043E \u0440\u0443\u043A\u043E\u0432\u043E\
    \u0434\u0441\u0442\u0432\u0430, \u0430 \u0437\u0430\u0442\u0435\u043C \u0443\u0437\
    \u043D\u0430\u0442\u044C, \u043A\u0430\u043A \u043F\u0440\u0430\u0432\u0438\u043B\
    \u043E \u0435\u0451 \u043D\u0435 \u043F\u0440\u043E\u043F\u0443\u0441\u0442\u0438\
    \u0442\u044C, \u0430 \u0432\u043C\u0435\u0441\u0442\u043E \u0447\u0438\u0441\u043B\
    \u0430, \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0442\u0435\u043B\u044C\u043D\
    \u043E \u0440\u0435\u0448\u0435\u043D\u0438\u0435.\n\n\n</text>\n<code language=dyalog-kernel>",
  "  (cond [(< n 1) 1]\n        [else (+ (fib (sub1 n)) (fib (sub1 n)))]))\n", " \
    \ ((fib-loop (- n 1))\n   (if (= n 1)\n       1\n       (+ (fib-loop (- n 2))\n\
    \          (fib-loop (- n 3))))))\n", "  (cond [(< n 1)\n         1]\n       \
    \ [(= n 2)\n         1]\n        [else\n         (+ (fib (- n 1))\n          \
    \  (fib (- n 2)))]))\n</code>\n<|/ a tags=scheme,racket,fibonacci,math |>\n<|\
    \ c |>\nThe first two cases should use `else ...` rather than `elseif`, otherwise\
    \ the `#t` case will not be reached. Also, it is probably a good idea to give\
    \ them better names (`#:fib` is better than `fib`) and to reuse previous results\
    \ (`fib-1` and `fib-2` rather than just `fib`).\n<|/ c |>\n<| a tags=scheme,racket,fibonacci,math\
    \ |>\nHere is my solution in Racket:\n<code>", "  (if (<= n 2) 1 \n      (recur\
    \ (- n 1) (+ n 2) (+ n 3))))\n", "  (define (aux a b)\n    (cond\n      [(= n\
    \ 0) a]\n      [(= n 1) b]\n      [else (aux (+ a b) b)]))\n  (aux 0 1))\n", " \
    \ (fib-iter 1 0 n 2))\n", "  (let ([a (+ (* 2 n) (* 5 n)) b (+ (* 5 n) (* 13 n))\
    \ c (+ (* 13 n) (* 21 n)) d])\n    (if (= n 0)\n        d\n        (+ (* b c)\
    \ (* a d))))) \n", "  (if (= n 0)\n      1\n      (+ (fib (- n 1))\n         (fib\
    \ (- n 2)))))\n", "  (if (< n 0)\n      0\n      (let ((fib0 (car f))\n      \
    \      (fib1 (cadr f)))\n        (if (even? fib0)\n            (+ fib1 (fib n-1))\n\
    \            (+ fib0 fib1 (fib n-1)))))\n", "  (fib-iter 0 1 2 n n ))\n", "  (fib-aux\
    \ (fib-cnt n) 0 1))\n", "  (let* ((a 1)\n         (b 1)\n         (c 0)\n    \
    \     (fibonacci (lambda () (+ a b) )))\n    (if (< n 1)\n        fibonacci\n\
    \        (fibonacci (lambda () (+ b c))))))\n</code>\n<|/ a tags=fibonacci,racket,scheme\
    \ |>\n<| c |>\nYeah, this is my answer, but I just thought it would be more natural\
    \ to use a lambda.\n<|/ c |>\n<| c |>\n: I guess the point of Racket is to be\
    \ able to write pure Scheme code, not to use functions. That is just my opinion\
    \ though.\n<|/ c |>\n<| c |>\n: I agree. I just wanted to give a quick example\
    \ of a function that would just be expressed as a lambda or anonymous procedure\
    \ that could be called directly.\n<|/ c |>\n<| a dscore=2 |>\nFor this particular\
    \ problem you can use the foldr procedure, e.g. (foldr (lambda (x y) ...) 0 [1\
    \ 2 3]). In your case this would be:\n<code>", "  (cond [(= n 0) 1]\n        [else\
    \ (+ (fib (- n 1)) (* (fib n) 3))]))\n", "  (if (= n 0) 0\n      (+ fib (- n 1))))\n",
  "  (cond [(= n 0)                        1]\n        [(= n 1)                  \
    \      1]\n        [(= (- n 1) 1)                  (+ (fib (- n 1)) (fib (- n\
    \ 2)))]\n        [else                          (fib (- n 1)) (+ (fib (- n 2))\
    \ (fib (- n 3)))]))\n", "  (cond ((= n 0) 0)\n        ((= n 1) 1)\n        (else\
    \ (+ (fib (- n 1)) (fib (- n 2))))))\n", "  (cond\n    ((< n 1) 1)\n    ((= n\
    \ 2) 2)\n    ((fib n-2)\n     (+ (fib (- n 2)) (fib (- n 3)))))\n  )\n)\n", " \
    \ (cond [(= n 0) 0]\n        [(= n 1) 1]\n        [else (+ (fib (- n 1)) (fib\
    \ (- n 2))))]))\n", "  (fib-iter 0 1 2 n (lambda (x y)\n                    (cond\n\
    \                      [(= n 0) x]\n                      [(= n 1) y]\n      \
    \                [else (fib-iter (+ x y) x (+ x y) (- n 1))])))\n  \n", "  (cond\
    \ [(< n 1) 1]\n        [(< n 2) 1]\n        [else (+ (fib (- n 2)) (fib (- n 1)))]))\n\
    </code>\n<|/ a tags=fibonacci,scheme dscore=4 |>\n<| c |>\nTo avoid stack overflows\
    \ you could use [tail recursion](https://en.wikipedia.org/wiki/Tail_call).\n<|/\
    \ c |>\n<| a tags=fibonacci,scheme dscore=3 |>\nA tail recursive solution is very\
    \ simple:\n<code>", "  ;; base case\n  (cond [(= n 0) 1]\n        [else (+ (fib\
    \ (- n 1)) (fib (- n 2)))]))\n", "  (if (< n 2)\n      n\n      (fib-iter (- n\
    \ 1) (- n 2))))\n", "  (cond\n    [(= n 1) 1]\n    [(= n 2) 1]\n    [else (+ (fib\
    \ (- n 1)) (fib (- n 2))) ]))\n", "  (define (f a b)\n    (cond\n      [(= n 1)\
    \ a]\n      [(= n 2) b]\n      [else (f (+ a b) (+ b a))]))\n  (false 0))\n",
  "  (cond\n    ((= n 0) 0)\n    ((= n 1) 1)\n    (else (+ (fib (- n 1)) (fib (- n\
    \ 2))))))\n", "  (cond ((= n 1) 1)\n        ((= n 2) 2)\n        ((= n 3) 3)\n\
    \        (else (+ (fib (- n 1)) (fib (- n 2))))))\n", "  ((lambda (x)\n    (if\
    \ (= x 0) 1 (+ x (fib (- x 1)))))\n   n))\n", "  (cond [(= n 0) 1]\n        [(=\
    \ n 1) 1]\n        [else (+ (fib (- n 1))\n                 (fib (- n 2))))]))\n",
  "  (fib-iter n 1 0 1 0))\n", "  (if (<= n 1)\n      1\n      (+ (fib (- n 2)) (fib\
    \ (- n 1)))))\n", "  (if (< n 2)\n      1\n      (+ (fib (- n 1)) (fib (- n 2)))))\n",
  "  (cond\n    ((= n 0) 0)\n    ((= n 1) 1)\n    ((= (- n 1) 2) (+ (fib 1) (fib 2)))\n\
    \    ((< n 2) (+ (fib 1) (fib 2))))\n  )\n)\n</code>\n<|/ a tags=racket,scheme\
    \ dscore=3 |>\n<| a dscore=2 |>\n<code>", "  (cond ((< n 2) 1)\n        ((= n\
    \ 2) 2)\n        (else (+ (fib (- n 1)) (fib (- n 2))))))\n", "  (cond\n    [(=\
    \ n 0) 1]\n    [(= n 1) 1]\n    [else (+ (fib (- n 1)) ((fib (- n 2)) (fib (-\
    \ n 3)))))]))\n", "  (cond [(= n 1) 1]\n        [(= n 2) 1]\n        [else (+\
    \ (fib (- n 1)) (fib (- n 2))))))\n", "  (if (zero? n)\n      n\n      (+ (fib-helper\
    \ 1 (- n 2)) (fib-helper 2 (- n 1)))))\n", "  (let ([a 1])\n    (let ([b (+ a\
    \ b)])\n      (if (= n 0)\n          a\n          (fib n (+ a b)))))) ;; #lang\
    \ racket\n", "  (cond [(= n 0) 1]\n        [(= n 1) 1]\n        [else (+ (fib\
    \ (- n 1)) (fib (- n 2)))]))\n", "  (cond [(= n 0)\n         1]\n        [else\n\
    \         (+ (fib (- n 1)) (fib (- n 2)))]))\n", "  (cond [(= n 0) 1]\n      \
    \  [else (+ (fib (- n 1)) (fib (- n 2))))]))\n</code>\n<|/ a tags=scheme,recursion,racket,fibonacci\
    \ |>\n<| c |>\nHi Athanasios, thank you very much for your answer. I am really\
    \ new to scheme and I really want to learn it. Your code is very helpful but it\
    \ doesn't give the same results as the code provided in my book. Here is a link\
    \ to the code I wrote: https://pastebin.com/5zvjQ7wR. I will keep trying to figure\
    \ this out. Thank you very much again for your help.\n<|/ c |>\n<| c |>\n, just\
    \ to let you know that your code is correct and gives the same results as mine.\
    \ I edited my answer to include a link to an online interpreter.\n<|/ c |>\n<|\
    \ c |>\nThank you very much Athanasios, I really appreciate your help. It works\
    \ perfectly. I really really appreciate it. Thank you very much once again.\n\
    <|/ c |>\n<| c |>\nHi Athanasios, I have another question for you if you don't\
    \ mind. I am trying to figure it out for 2 days and I really can't find an answer.\
    \ My professor wants me to implement this using loops. Can you please help me\
    \ with that? Thank you very much. Here is what he wants: Write a program that\
    \ asks the user for an integer N and then prints out the first N Fibonacci numbers.\
    \ For example, if N = 10, the program should print out the following:\n<|/ c |>\n\
    <| c |>\nHi Athanasios, Thank you very much for your help. I really really appreciate\
    \ it. Thank you very much once again.\n<|/ c |>\n<| a tags=scheme,recursion,racket,fibonacci\
    \ |>\n<code>\n#lang racket\n", "  [(define (fib-helper n a b)\n    (cond [(= n\
    \ 0) a]\n          [(= n 1) b]\n          [else\n           (fib-helper (sub1\
    \ n) (a+b) b)]))\n   (fib-helper n 0 1)])\n", "  (if (zero? n)\n      1\n    \
    \  (+ (fib (- n 1))\n         (fib (- n 2)))))\n</textarea></form>\n\n    <script>\n\
    \      var editor = CodeMirror.fromTextArea(document.getElementById(\"code\"),\
    \ {\n        lineNumbers: true,\n        matchBrackets: true,\n        mode: \"\
    racket\"\n      });\n    </script>\n\n    <p><strong>MIME types defined:</strong>\
    \ <code>text/x-racket</code>.</p>\n\n    <p>\n      You can copy and paste the\
    \ following example code into a file:\n    </p>\n\n    <pre class=\"examples\"\
    >\n#lang racket\n", "  (cond [(= n 0) 1]\n        [else (+ (fib (- n 1)) (fib\
    \ (- n 2)))]))\n", "  ;; Use \"tail recursion modulo arithmetic\" to avoid stack\
    \ overflow.\n  (let loop ((n n) (a 0) (b 1) (c 0))\n    (if (zero? n) a\n    \
    \    (loop (- n 1) (+ a b) (+ b c) c))))\n", "  (if (<= n 1)\n      1\n      (+\
    \ (fib (- n 1)) (fib (- n 2)))))\n", "  (if (<= n 1)\n      1\n      (+ (fib (-\
    \ n 1)) (fib (- n 2)))))\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThanks. I do believe\
    \ that this is the most correct answer, but I just tested it and it's slower than\
    \ the other solutions listed here.\n<|/ c |>\n<| a dscore=2 tags=math,fibonacci,racket,algorithm,scheme\
    \ |>\n<code>", "  (if (= n 0)\n      0\n      (let ([b (fib n-1)]\n          \
    \  [a (fib n-2)]\n            [c a])\n        (+ b (* c c)))))\n</code>\n<|/ a\
    \ dscore=2 |>\n<| c |>\nThe function \"fib\" itself is implemented recursively,\
    \ but if you rewrite it using an iterative function the code will look a lot better\
    \ and clearer.\n<|/ c |>\n<| c |>\nThis is true - but why do people keep reinventing\
    \ the wheel? Does it have some advantage in some way?\n<|/ c |>\n<| c |>\nIt helps\
    \ reduce duplication in code. For example, in most languages recursion has overhead\
    \ in some way. In the case of racket, it's just a syntactic sugar, but a good\
    \ compiler will transform it into loops if necessary. This is especially useful\
    \ when implementing recursive algorithms.\n<|/ c |>\n<| c |>\nThis answer was\
    \ written before Scheme had lambda expressions so I decided to use them here for\
    \ clarity, but the same can be said about other solutions.\n<|/ c |>\n<| c |>\n\
    Ah, I was thinking about `lambda` but didn't get it to work like that, so I thought\
    \ about `let` instead. Neat!\n<|/ c |>\n<| a tags=racket,scheme,lisp |>\nThe solution\
    \ using functional recursion:\n<code>", "  (cond ((= n 0) 1)\n        ((= n 1)\
    \ 1)\n        ((= n 2) 1)\n        (else (+ (fib (- n 1)) (fib (- n 2)))))) ;;\
    \ tail recursive\n", "  (fib-iter 0 1 1 n))\n", "  (if (< n 1)\n      0\n    \
    \  (+ (fib (- n 1)) (fib (- n 2)))))\n", "  (cond [(= n 0)\n         1]\n    \
    \    [(= n 1)\n         1]\n        [else\n         (+ (fib (- n 1)) \n      \
    \       (fib (- n 2)))))\n", "  (if (= n 1) 1 (+ 1 (fib n (- n 1)))))\n", "  (if\
    \ (<= n 1)\n      n\n      (+ (fib (- n 2)) (fib (- n 1)))))\n</code>\n<|/ a tags=scheme,racket,recursion\
    \ |>\n<| c |>\nThe `fib` function doesn't need parentheses: `if (<= n 1) ...`\
    \ should just be `if (<= n 1)`. And if you want a `max` function, just use `max`.\n\
    <|/ c |>\n<| c |>\nYou mean `(if (<= n 1) ...` should be `(if (<= n 1) ...)`,\
    \ not `if (<= n 1) ...`. But yes, `max` already exists, it's called `max-in`,\
    \ so `(define (max x y)...` will do nicely and be much more concise than defining\
    \ a max function yourself. Then you can just do `(max-in fib 10)` or `(max-in\
    \ fib -3)` and get 55 and 21 respectively.\n<|/ c |>\n<| c |>\nThis code will\
    \ work for any positive number, not just 10. Really though, the solution is fine;\
    \ just needs some improvements (I already upvoted the answer).\n<|/ c |>\n<| c\
    \ |>\n: I agree. I was just saying that your solution doesn't need that because\
    \ its purpose was different.\n<|/ c |>\n<| a dscore=1 |>\nA more recursive solution:\n\
    <code>", "  (let ([i (+ n 1 2)])\n    (if (< i n)\n        (fib (- n 1))\n   \
    \     i))) \n", "  (cond [(< n 1) 1]\n        [(= n 1) 1]\n        [else\n   \
    \      (+ (fib (- n 1)) (fib (- n 2)))]))\n", "  ;; Implementation note:\n  ;;\
    \ If we were to use a loop here, we'd need to store the previous values\n  ;;\
    \ because we can't mutate a mutable value. The code below does not\n  ;; require\
    \ the previous values to be stored. In fact, it does not\n  ;; require them to\
    \ be stored at all, but stores only the last two values.\n  ;; This saves a little\
    \ bit of time, but still requires some memory.\n  (cond [(< n 0) (error 'fib \"\
    Negative fibonacci number\" n)]\n        [(equal? n 1) (error 'fib \"Positive\
    \ fibonacci number\" n)]\n        [else (let ((a 0) (b (+ a 1))) (if (= n 2) b\
    \ a)]))\n", "  (cond ((= n 0) 1)\n        ((= n 1) 1)\n        ((= n 2) 1)\n \
    \       (else (+ (fib (- n 1)) (fib (- n 2))))))\n", "  (if (< n 2)\n      1\n\
    \      (+ (fib (- n 1)) (fib (- n 2)))))\n", "  (cond [(zero? n) (error 'fib n)\n\
    \         ((= n 1) 1) (else (+ (fib (sub1 n)) (fib (sub1 n))))])\n    ; The 'else'\
    \ clause is here only as a convenient place to return a\n    ; default. This can\
    \ be replaced by a 'cond' that always returns '1'.\n    (else 1))\n", "  (cond\n\
    \    ((= n 1) 1)\n    ((= n 2) 2)\n    ((= n 3) (+ (fib (- n 1)) (fib (- n 2))))\n\
    \    (else (fib (- n 1)))))\n", "  (foldr (\u03BB (x) (+ x x)) 0 [0 1]))\n  ;;\
    \ <<< #lang racket\n", "  (if (= n 0) 1\n      (+ (fib (- n 1)) (fib (- n 2)))))\n",
  "  (cond [(= n 0) 1]\n        [(= n 1) 1]\n        [else (+ (fib (- n 1)) (fib (-\
    \ n 2))))))\n</code>\n<|/ a tags=scheme,racket,fibonacci |>\n<| c |>\nThank you,\
    \ just one question: how do I call this function from another file?\n<|/ c |>\n\
    <| c |>\nThe function should already be in the same file, so I don't understand\
    \ what you're asking here.\n<|/ c |>\n<| c |>\nSo if I want to call this function\
    \ in my main file from another file, how do I do that? Thanks!\n<|/ c |>\n<| c\
    \ |>\nAssuming the function is already in the same file as your main file, you\
    \ can just reference the function as though it was a variable in your main file.\
    \ If it's in another file, you can define it (for example in your main file) then\
    \ import it from the other file using `require`: `(import (current-env) './myFunction)`.\n\
    <|/ c |>\n<| c |>\nYou can also define a function inside your main file and then\
    \ import it from your other file using `require`.\n<|/ c |>\n<| a |>\nFor any\
    \ future readers, here's a version that uses a tail recursive definition to avoid\
    \ the stack overflow caused by the recursion depth.\n<code>", "  (if (<= n 2)\n\
    \      n\n      (+ (fib (- n 1)) (- (fib (- n 2)) (- (fib (- n 3)) (- n))))))\n",
  "  (cond [(= n 0) 1]\n        [else (+ (fib (- n 1)) (fib (- n 2)))]))\n", "  (cond\n\
    \    [(= n 1) 1]\n    [(= n 2) 1]\n    [else (+ (fib (- n 2)) (fib (- n 1)))]))\n",
  "  (cond [(< n 1)\n         1]\n        [(< n 2)\n         1]\n        [else\n \
    \        (+ (fib (- n 1))\n            (fib (- n 2)))]))\n", "  (cond\n    [(=\
    \ n 1) 1]\n    [(= n 2) 1]\n    [else (+ (fib (- n 1)) (fib (- n 2)))]))\n", " \
    \ (cond [(zero? n) 1]\n        [(= n 1) 1]\n        [(= n 2) 1]\n        [else\
    \ (+ (fib (- n 1)) (fib (- n 2))))]))\n", "  (fib-iter 1 1))\n", "  (cond [(=\
    \ n 0) 1]\n        [(= n 1) 1]\n        [else (+ (fib (- n 1)) (fib (- n 2))))))\n",
  "  (cond [(< n 0) 0]\n        [(= n 1) 1]\n        [else (+ (fib n-1) (fib n-2))]))\n",
  "  (if (<= n 1)\n      (cons (car fibonacci) (cadr fibonacci))\n      (+ (car fibonacci)\
    \ (expt (cadr fibonacci) (- n 1)))))\n", "  (cond [(= n 1) 1]\n        [(= n 2)\
    \ 1]\n        [else (+ fib (fib (- n 1))) (* 2 n)]\n  )\n)\n", "  (if (zero? n)\n\
    \      1\n      (+ (fib (- n 1))\n         (fib (- n 2)))))\n", "  (cond [(= n\
    \ 0) 0]\n        [(= n 1) 1]\n        [else (+ (fib (- n 1)) (fib (- n 2))))))\n",
  "  (cond [(< n 0) 'nil]\n        [(= n 1) '1]\n        [else (+ (fib (- n 1)) (fib\
    \ (- n 2))) ]))\n\n#lang racket\n", "  (if (= n 0)\n      0\n      (+ (fib (-\
    \ n 1)) (fib (- n 2)))))\n", "  (if (< n 1)\n      1\n      (+ (fib (- n 1))\n\
    \         (fib (- n 2)))))\n", "  (if (= n 1)\n      1\n      (+ (fib (- n 1))\
    \ (fib (- n 2)))))\n</pre>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<div\
    \ class=\"titlepage\"><div><div><h2 class=\"title\">\n<a name=\"sec:racket-define-macro\"\
    ></a>6.2.\_A \"macro\"\n</h2></div></div></div>\n<div class=\"informalexample\"\
    >\n<div class=\"examplenum\">\n<span id=\"exampl:macro\"></span><pre class=\"\
    example\">", "  (cond\n    [(<= n 0) 1]\n    [else (+ (fib (- n 2)) (fib (- n\
    \ 1)))]))\n</cell>\n<cell>\n#lang racket\n", "  (cond [(zero? n) 1]\n        [(=\
    \ n 1) 1]\n        [else (+ (fib (- n 1)) (fib (- n 2)))]))\n</code>\nThe result\
    \ is correct, but is very inefficient. You should use tail recursion.\n<|/ a dscore=2\
    \ |>\n<| a tags=racket,recursion,scheme,racket-student-languages |>\n<code>",
  "  (if (< n 1)\n      1 \n      (+ (fib (- n 1)) (fib (- n 2)))))\n", "  (if (=\
    \ n 0)\n      0\n      (+ (fib (- n 1)) (fib (- n 2)))))\n", "  ;; Return n-th\
    \ Fibonacci number.\n  ;; >>> (fib 10)\n  (cond [(= n 1) 1]\n        [(= n 2)\
    \ 1]\n        [else (+ (fib (- n 1)) (fib (- n 2)))]))\n", "  (cond [(= n 0) 0]\n\
    \        [(= n 1) 1]\n        [else (+ (fib (- n 1)) (fib (- n 2)))]))\n", " \
    \ (fib-iter 1 0 n))\n", "  (cond [(< n 1) (error \"n must be >= 2\")\n       \
    \  (if (zero? (rem n (+ 2 (* 3 n))))\n             (+ 1 0)\n             (fib\
    \ 1 (- n 1)))]\n        [(zero? n) (error \"n must be >= 1\")]\n        [else\
    \ (+ 1 0 (fib 1 (- n 1))))]))\n", "  (cond [(< n 0) (error \"n must be non-negative.\"\
    )]\n        [(= n 1) (error \"n must be 0 or 1.\")]\n        [(= n 2) (cons 1\
    \ 1)]\n        [else (+ (fib (- n 1)) (fib (- n 2))))]))\n", "  (cond [(zero?\
    \ n) 1]\n        [else (+ (fib (sub1 n)) (fib (sub1 n)))]))\n", "  (define (iter\
    \ x y z)\n    (cond ((= n 0) z)\n          ((= n 1) y)\n          (else (iter\
    \ (- x 1) (+ y z) (+ x y)))))\n  (iter 1 1 1))\n", "  (cond [(= n 0) 1]\n    \
    \    [(= n 1) 1]\n        [(= n 2) 1]\n        [else (+ (fib (- n 1))\n      \
    \           (fib (- n 2))))]\n))\n", "  (fib-iter 0 1 1))\n", "  ;; Use lookup\
    \ table if n < 64.\n  (if n\n      (let ([table (make-fib-table n)])\n       \
    \ (lookup n table)\n        (error \"fib number too large, try (fib 0)\")))\n\
    \  ;; Fall back to recursive lookup.\n  (lookup n '(1 1 2)))\n", "  (cond [(=\
    \ n 0) 1]\n        [(< n 1) (fib n (- n 1))]\n        [else (+ (fib (- n 1)) (fib\
    \ (- n 2)))]))\n</cell>\n<cell>\n#lang racket\n", "  (if (< n 1)\n      1 \n \
    \     (+ 2 (fib n-1))))\n", "  (cond\n    [(<= n 1) 1]\n    [(< n 2) 1]\n    [else\
    \ (+ (fib (- n 1)) ((fib (- n 2)) 1))]))\n</code>\n<|/ a tags=scheme,racket,functional-programming\
    \ |>\n<| a dscore=4 tags=scheme,racket,functional-programming |>\nA simple recursive\
    \ solution using only (define) and (define-syntax). \n<code>", "  (if (<= n 1)\
    \ (list 1)\n      (append (list (first a))\n              (list (+ (first a) (second\
    \ a))\n                     (+ (second a) (third a))\n                     (+\
    \ (third a) (fourth a))\n                     (+ (fourth a) (nth n)))\n      \
    \        (fib n-1))))\n", "  (if (= n 0)\n      1\n      (+ (fib (- n 1)) (* (fib\
    \ (- n 2)) (fib (- n 3))))))\n", "  (if (= n 0)\n      0\n      (+ (fib (- n 1))\
    \ (fib (- n 2)))))\n", "  ;; Base cases: 1 and 0.\n  (cond [(= n 0) 1]\n     \
    \   [else (+ (fib (- n 1)) (fib (- n 2)))]))\n", "  (- (* n (+ (fib (- n 1)) ((fib\
    \ (- n 2)) 0))) 1))\n", "  (let ([a 1])\n    (if (= n 0)\n        0\n        (let\
    \ ([b (+ a 1)])\n          (if (= n 1)\n              b\n              (let ([c\
    \ (+ b 1)])\n                (if (= n 2)\n                    c\n            \
    \        (let ([d (+ c 1)])\n                      (if (= n 3)\n             \
    \             d\n                          (let ([e (+ d 1)])\n              \
    \              (if (= n 4)\n                                e\n              \
    \                  (let ([f (+ e 1)])\n                                  (if (=\
    \ n 5)\n                                      f\n                            \
    \          (let ([g (+ f 1)])\n                                        (if (=\
    \ n 6)\n                                            g\n                      \
    \                      ...))))))))))))))\n</code>\n<|/ a tags=scheme,racket,fibonacci\
    \ |>\n<| c |>\nFor anyone who is interested in the difference between a list and\
    \ a vector, it might be easier to understand by looking at the implementations\
    \ of `vector` and `list` themselves. It's easier to see that `(define v ...) (vector\
    \ v ...)` will create a vector of `n` elements (and only `n` elements if necessary),\
    \ whereas `(define l ...) (list l ...)` will create a list with `n + 1` elements\
    \ (and only `n + 1` elements if necessary). You can see that the two are very\
    \ different beasts.\n<|/ c |>\n<| a |>\nA better solution is to use the formula\
    \ for Fibonacci numbers:\n<code>", "  (fold-left (\u03BB (a b)\n             \
    \  (+ a b))\n             0\n             (range 0 n)))\n", "  (cond ((= n 0)\
    \ 0)\n        (#t (+ (fib (- n 1)) (fib (- n 2)))))\n))\n", "  (cond [(< n 1)\n\
    \         1]\n        [else (+ (fib (sub1 n)) (fib (sub1 n)))]\n  )\n)\n", " \
    \ (cond [(= n 0)  1]\n        [(= n 1)  1]\n        [else (+ (fib (- n 1)) (fib\
    \ (- n 2)))]))\n", "  (cond [(= n 1)\n         1]\n        [(= n 2)\n        \
    \ 1]\n        [else\n         (+ (fib (- n 1)) ((fib (- n 2)) 1))]))\n", "  (cond\
    \ [(zero? n) 1]\n        [else (+ (fib (- n 1)) (fib (- n 2)))]))\n</code>\nAnd\
    \ now, we have to wrap it all into a function called fibonacci which takes one\
    \ argument, an integer, and returns a number.\n<code>", "  (let ([f (\u03BB ()\
    \ (f))])\n    (\u03BB ([x y])\n      (cond\n        [(= n 0) x]\n        [(= n\
    \ 1) y]\n        [else (f ((f x y) (- x y))) ])))\n))\n", "  (cond [(zero? n)\
    \ 1]\n        [(= (sub1 n) 1) 1]\n        [else (+ (fib (sub1 n)) (fib (sub1 n)))\
    \ (* 2 n)]))\n", "  (cond [(< n 2) 1]\n        [else (+ (fib (- n 2)) (fib (-\
    \ n 1)))]))\n", "  (cond [(= n 0) 1]\n        [else (+ (fib (- n 1))\n       \
    \           (fib (- n 2)))]))\n", "  (cond ((= n 1) 1)\n        ((= n 2) 1)\n\
    \        ((= n 0) (cond ((= n 1) 1) 0))\n        (else (+ (fib (- n 1)) (fib (-\
    \ n 2))))))\n</cell>\n<cell>\n#lang racket\n", "  (if (< n 2)\n      1\n     \
    \ (+ (fib (- n 1)) (fib (- n 2)))))\n", "  (cond\n    ((= n 0)            0)\n\
    \    ((= n 1)            1)\n    ((= n 2)            1)\n    ((< n 3)        \
    \    (+ (fib (- n 1)) (fib (- n 2)))))\n</code>\n<|/ a tags=functional-programming,racket,scheme\
    \ |>\n<| c |>\nThanks for the answer! But how would you write this code using\
    \ recursion, would you use `cond`?\n<|/ c |>\n<| c |>\nyes, you can use a nested\
    \ `cond` if you want, but i recommend you just use tail recursion and no `cond`,\
    \ which makes the function a lot cleaner imo. but if you really want to use cond\
    \ you can just use `(define (fib n) (cond...))` instead of `(define (fib n) (cond\
    \ ...))`. also, you don't have to put `begin` in front of each `cond` clause.\n\
    <|/ c |>\n<| c |>\nThank you so much!\n<|/ c |>\n<| c |>\nHow would you do this\
    \ using recursion?\n<|/ c |>\n<| a |>\n<code>\n#lang racket\n", "  (letrec ([fib0\
    \ (lambda () 1)\n             fib1 (lambda () 2)\n             fibo (lambda (x\
    \ y z) (+ x y z))])\n    (cond [(> n 0)\n           (fibo fib0 fib1 fibo (fibo\
    \ fib0 (- n) fib1) (+ fib0 (- n)))]\n          [else\n           (fibo fib1 fib0\
    \ fibo (+ fib1 fib0) (+ fib0 fib1))])))\n", "  (cond [(= n 0) 1]\n        [(=\
    \ n 1) 1]\n        [else (+ (fib (- n 1)) (fib (- n 2))))]))\n", "  (if (< n 0)\
    \ (- fib n) (nth (fib (- n 1))\n                             (- n 2)\n       \
    \                      n 3)))\n", "  (if (< n 2)\n      1\n      (+ (fib (- n\
    \ 1)) (fib (- n 2)))))\n", "  (if (or (= n 1) (= n 2))\n      n\n      (+ (fib\
    \ (- n 1))\n         (fib (- n 2)))))\n", "  (if (<= n 1)\n    1\n    (+ (fib\
    \ (- n 1)) (fib (- n 2)))))\n</code></pre>\n<p>If we run this program, we get:</p>\n\
    <pre><code class=\"lang-scheme\">user1&gt; <span class=\"comment\">;; Example\
    \ program</span>\nuser1&gt; <span class=\"comment\">;; Return n-th Fibonacci number.</span>\n\
    user1&gt; <span class=\"comment\">;; >>> (fib 10)</span>\nuser1&gt; <span class=\"\
    comment\">;; 55</span>\nuser1&gt; <span class=\"comment\">;; >>> (fib 1)</span>\n\
    user1&gt; <span class=\"comment\">;; 1</span>\nuser1&gt; <span class=\"comment\"\
    >;; >>> (fib 8)</span>\nuser1&gt; <span class=\"comment\">;; 21</span>\n</code></pre>\n\
    <p>When we call this definition, it returns the number 21 as the result of the\
    \ program. Note that this program is different from our previous definition in\
    \ the sense that it will not return any value outside of the range of the Fibonacci\
    \ sequence. It will produce an error if we try to ask for the 10th or 20th or\
    \ 30th number.</p>\n<h3 id=\"procedure-to-get-the-fibonacci-sequence\">Procedure\
    \ to get the Fibonacci sequence</h3>\n<p>We can write a procedure which returns\
    \ the Fibonacci sequence for a given number by making use of two accumulators\
    \ instead of two parameters. We call this procedure by passing the number of the\
    \ element (starting from 0), and two accumulators which will contain the previous\
    \ numbers of the sequence. Here is a simple example.</p>\n<pre><code class=\"\
    lang-scheme\">;; Return the fibonacci sequence of n elements.", "  (- (+ n (*\
    \ 2 n)) (/ 2 n)))\n", "  (fib-iter 0 1 1 n '()))\n", "  (cond\n    ((= n 0) 0)\n\
    \    ((= n 1) 1)\n    (else (+ (fib n-1) (fib n-2))))\n", "  (cond [(< n 2)  \
    \                 1]\n        [(= n 1)                   1]\n        [else   \
    \                   (+ (fib (- n 1)) (fib (- n 2)))]))\n</code>\n<|/ a tags=racket,scheme\
    \ |>\n<| a tags=racket,scheme |>\nThe basic idea is to create two recursive functions\
    \ to do what you want to do.\nOne function will take n-1 and recursively call\
    \ itself until it reaches 0, then return the nth fibonacci number.\nThe second\
    \ function takes the n-th fibonacci number, and recursively calls itself until\
    \ it reaches 0, then returns n.\nHere is a solution:\n<code>", "  (if (< n 1)\
    \ 0\n      (+ (fib (- n 1))\n         (fib (- n 2)))))\n", "  (cond [(= n 0) 1]\n\
    \        [(< n 1) 1]\n        [else (+ (fib (- n 1)) (fib (- n 2)))]))\n", " \
    \ (if (<= n 1)\n      1\n      (+ (fib (- n 1)) (fib (- n 2)))))\n", "  (cond\
    \ [(< n 2) 1]\n        [else (+ (fib (- n 1)) (fib (- n 2)))]))\n</code>\n<|/\
    \ a dscore=1 |>\n<| c |>\nAh, this is pretty clever. I didn't realize you could\
    \ use cond with multiple cases.\n<|/ c |>\n<| c |>\nYes, that's how we do it in\
    \ Scheme, and it's very common.  Just remember that it's an if-else block, like\
    \ your if-then-else statements in other languages.  This technique is quite common\
    \ and makes the code more readable.  Another cool thing about it is that you don't\
    \ need to have extra lines like `(fib 10)` to get the nth number.\n<|/ c |>\n\
    <| c |>\nAh I see. This is probably a lot more code than the other solutions.\
    \ I'll go with this one though, since I like how it looks. Thanks!\n<|/ c |>\n\
    <| c |>\nIt's actually a lot less code.  I wrote this before I even knew the Fibonacci\
    \ sequence was a thing!  :-)\n<|/ c |>\n<| c |>\nYep, that's the point. I wanted\
    \ to learn the basics of the language, just so I could code a program that used\
    \ it. I'm sure your solution works just fine, but I wanted to show another method\
    \ (which I learned in a different way).\n<|/ c |>\n<| a dscore=1 |>\nThe code\
    \ below uses a recursive function with two parameters: the number of iterations\
    \ and the fibonacci number\n<code>", "  (define (iter n i temp)\n    (cond\n \
    \     [(= n 0) temp]\n      [(= i 0) 0]\n      [(= i 1) 1]\n      [else (iter\
    \ (sub1 n) i (+ temp (iter n (sub1 i) 0))])]))\n  (iter n 1 0))\n</cell>\n<cell>\n\
    #lang racket\n", "  (cond [(= n 0) 0]\n        [(= n 1) 1]\n        [else\n  \
    \       (+ (fib (- n 1))\n            (fib (- n 2))))]))\n", "  (fib-iter 1 1\
    \ (+ n 1) '() '()))\n", "  (cond ((= n 0) 1)\n        ((= n 1) 1)\n        (else\
    \ (+ (fib (- n 1)) (fib (- n 2))))))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
