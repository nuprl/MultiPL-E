name: HumanEval_49_modp
language: rkt
prompt: "#lang racket\n\n;; Return 2^n modulo p (be aware of numerics).\n;; >>> (modp\
  \ 3 5)\n;; 3\n;; >>> (modp 1101 101)\n;; 2\n;; >>> (modp 0 101)\n;; 1\n;; >>> (modp\
  \ 3 11)\n;; 8\n;; >>> (modp 100 101)\n;; 1\n(define (modp n p)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate modp))\n\
  \    (check-equal? (candidate 3 5) 3)\n    (check-equal? (candidate 1101 101) 2)\n\
  \    (check-equal? (candidate 0 101) 1)\n    (check-equal? (candidate 3 11) 8)\n\
  \    (check-equal? (candidate 100 101) 1)\n    (check-equal? (candidate 30 5) 4)\n\
  \    (check-equal? (candidate 31 5) 3)\n))\n\n(test-humaneval)"
completions: ["  (if (zero? n)\n      (modulo (modulo (modulo (modulo n p) p) p) p)\n\
    \      (modulo n (modp n (modulo (modulo (modulo n p) p) p))))\n", "  (let ((q\
    \ (modulo n p)))\n    (if (not (= q 0))\n        (modp (quotient n p) p)\n   \
    \     q)))\n", "  (mod n p))\n", "  (mod (logor (expt (* n p) (- n p)) 1) p))\n",
  "  (check-type n int)\n  (check-type p int)\n  (let ((nm (mod n p)))\n    (check-type\
    \ nm int)\n    nm))\n", "  (cond [(= n 0) 1]\n        [(= p 1) n]\n        [else\
    \ (expt n p)]))\n", "  (mod ((* 2 n) p) p))\n", "  (if (zero? n) 1\n      (if\
    \ (zero? p)\n          1\n          (* n (modp (- n 1) p)))))\n", "  (if (= p\
    \ 0) n\n      (modp (- n 1) (floor p))))\n", '  (modulo (+ n 1) p))', "  (modulo\
    \ (* 2 n) p))\n", "  (if (zero? n)\n      0\n      (if (= n p)\n          n\n\
    \          (* p (modp n (sub1 p)))))) ;; # /o\\ /o\\ /o\\ /o\\ /o\\ /o\\ /o\\\
    \ /o\\\n", "  (cond\n    [(zero? n) 0]\n    [(zero? p) 1]\n    [(even? n) (modulo\
    \ (- n 2) p)\n      (modp (quotient n p) (* p p))\n      (modulo (quotient n p)\
    \ (* p p))]\n    [else (modulo (- n 2) p) (modp (quotient n p) (* p p))\n    \
    \  (modp (quotient n p) (* p p))]\n    [else (modulo (- n 1) p) (modulo (quotient\
    \ n p) (* p p))\n      (modp (quotient n p) (* p p))]\n    [else (modulo (- n\
    \ 1) p) (modulo (quotient n p) (* p p))\n      (modp (quotient n p) (* p p))]\n\
    \    [else (modulo (- n 2) p) (modulo (quotient n p) (* p p))\n      (modulo (quotient\
    \ n p) (* p p))]\n    [else (modulo (- n 3) p) (modulo (quotient n p) (* p p))\n\
    \      (modulo (quotient n p) (* p p))]\n    [else (modulo (- n 4) p) (modulo\
    \ (quotient n p) (* p p))\n      (modulo (quotient n p) (* p p))]\n    [else (modulo\
    \ (- n 5) p) (modulo (quotient n p) (* p p))\n      (modulo (quotient n p) (*\
    \ p p))]\n    [else (modulo (- n 6) p) (modulo (quotient n p) (* p p))\n     \
    \ (modulo (quotient n p) (* p p))]\n    [else (modulo (- n 7) p) (modulo (quotient\
    \ n p) (* p p))\n      (modulo (quotient n p) (* p p))]\n    [else (modulo (-\
    \ n 8) p) (modulo (quotient n p) (* p p))\n      (modulo (quotient n p) (* p p))]\n\
    \    [else (modulo (- n 9) p) (modulo (quotient n p) (* p p))\n      (modulo (quotient\
    \ n p) (* p p))]\n    [else (modulo (- n 10) p) (modulo (quotient n p) (* p p))\n\
    \      (modulo (quotient n p) (* p p))]\n    [else (modulo (- ", "  (modp-aux\
    \ n p '()))\n", "  (let ([m1 (ash (* 2 n) p)])\n    (modp m1\n           (sub1\
    \ p))\n    (modp m1\n           p)))\n", "  (if (= n 0)\n      1\n      (* 2 (modp\
    \ n (- p 1)))))\n", "  (if (= n 0)\n      1\n      (* 2 (modp (- n 1) p))))\n",
  "  (if (zero? p)\n      0\n      (floor (* 2 n)) (modulo (+ n p) p)))\n", "  (if\
    \ (< n p)\n      n\n      (if (= (expt n 2) p)\n          (/ n p)\n          (*\
    \ n (modp (- n 2) p)))\n      ))\n", "  (modulo (int n) p))\n", "  (* 2\n    \
    \ (if (= n 0)\n       1\n       (remainder (modulo n p) p))))\n", "  (cond [(=\
    \ n 0) 1]\n        [(= n p) (- 1 0)]\n        [(or (= (expt n 2) 0) (< n p)) 0]\n\
    \        [else (modp n (sub1 (expt n 2))) ]))\n", "  (let ((a (/ n p)))\n    (if\
    \ (= a 0)\n        0\n        (* a p (modp a p)))))\n", "  (cond [(< n p) 0]\n\
    \        [else (+ 1 (modp (- n 1) p))]))\n", "  (let ((f (lambda (q)\n       \
    \      (remainder (* q p) q))))\n    (cond ((< n 0) 1)\n          ((= n 1) 1)\n\
    \          ((< n p) (f (+ n 1)))\n          ((= n p) (f n)))\n    1))\n", "  (if\
    \ (= n 0)\n      0\n      (modulo (* n p) p)))\n", "  (let loop ((n n) (p p) (acc\
    \ 0))\n    (cond ((= n 0)\n           (modulo acc p))\n          ((= n 1)\n  \
    \         (modulo (* p acc) p))\n          (else (loop (quotient n p) (quotient\
    \ (- n 1) p) (* acc p))))))\n", "  (if (= n 0)\n      1\n      (modulo (expt 2\
    \ n) p)))\n", "  (if (= n 0)\n      0\n      (modulo n (- p (* n (- n 1))))))\n",
  "  (let ((l (remainder n p)))\n    (if (= l 0)\n        1\n        (* 2 (modp l\
    \ p)))))\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2 |>\nThe answer provided by\
    \ JasonP contains two bugs. \nThe first bug is the missing parentheses in \n<code>",
  "  (/ (* (expt 2 n) p) p))\n", "  (if (or (= p 0) (= n 0))\n      1\n      (* n\
    \ (modp (- n 1) p))))\n</code>\n<|/ a tags=racket,modular,factorial,factorial-function\
    \ |>\n<| a tags=racket,modular,factorial,factorial-function dscore=2 |>\nAnother\
    \ alternative would be to use the function \"inexact->exact\" on the factorial\
    \ function.\n<code>", "  (mod n p))\n", "  (if (= n 0)\n      0\n      (* 2\n\
    \         (modulo (- n 1) p)\n         (modulo (- n 2) p))))\n", "  (if (zero?\
    \ n)\n      (mod p 1)\n      (mod-exp n (p + 1))))\n", "  (if (or (= n 0)\n  \
    \        (= p 0))\n      1\n      (modulo (quotient n p) p)))\n", "  (if (= n\
    \ 1)\n      1\n      (modulo n (modulo p n))))\n", "  (if (zero? n)\n      (modulo\
    \ n p)\n      (modulo (modulo (* 2 (quotient n p)) p) (quotient n p))))\n", " \
    \ (if (= n 1)\n      1\n      (mod ((* 2 n) p) p)))\n", "  (modulo (math-power\
    \ 2 n) p))\n", "  (mod n p))\n", "  (let ((m (mod n p)))\n    (if (< m 0)\n  \
    \      m\n        (modp m p))))\n", "  (if (zerop n)\n      (error \"n must be\
    \ positive\")\n      (if (> (modulo n p) 0)\n          (error \"n must be smaller\
    \ than p\")\n          (modulo n p))))\n", "  (if (< n 0)\n      (- 1 (modp 0\
    \ (+ n 1))) ; mod p n and add p\n      (/ (* 2 (modp 0 (- n 1))) p)))\n", "  (cond\
    \ [(< n 0) 0]\n        [else (+ (* 2 (expt n p)))]))\n", "  (cond [(= n 1) (modulo-2\
    \ n p)]\n        [(< n p) (modulo-2 n (modulo-2 p n))]))\n", "  (modulo (expt\
    \ n p) p))\n", "  (modulo (* 2 n) p))\n", "  (if (= n 0)\n      1\n      (modulo\
    \ (expt n p) p)))\n", "  (if (= n 0)\n      1\n      (modulo (* n p) (/ n p))))\n",
  "  (let ([m (expt p n)]\n        [r (modulo m p)]\n        [res (- m r)]\n     \
    \   [res 0]\n        [res 0]\n        [res (if (zero? res) (quotient r p) res)])\n\
    \    (if (even? n)\n        (+ res n)\n        res)))\n", "  (if (= n 0)\n   \
    \   1\n      (mod n p)))\n", "  (modpo (mod n p) p))\n", "  (mod n p))\n", " \
    \ (cond [(= n 0) 1]\n        [(= n p) 0]\n        [else (modp (- n 1) p)]))\n",
  "  (if (= n 0)\n      (modulo p 2)\n      (modulo (* n p) (- n 1))))\n", "  ((modulo\
    \ n p) (remainder n p)))\n", "  (let ([x (expt n 2)]\n        [y (expt n 3)]\n\
    \        [z (expt n 4)]\n        [w (expt n 5)]\n        [xx x]\n        [yy y]\n\
    \        [zz z]\n        [ww w]\n        [xy (x * y)])\n    (set! x (modulo x\
    \ p)) (set! y (modulo y p)) (set! z (modulo z p)) (set! w (modulo w p))\n    (set!\
    \ x (modulo x p)) (set! y (modulo y p)) (set! z (modulo z p)) (set! w (modulo\
    \ w p))\n    (set! x (modulo x p)) (set! y (modulo y p)) (set! z (modulo z p))\
    \ (set! w (modulo w p))\n    (set! x (modulo x p)) (set! y (modulo y p)) (set!\
    \ z (modulo z p)) (set! w (modulo w p))\n    (set! x (modulo x p)) (set! y (modulo\
    \ y p)) (set! z (modulo z p)) (set! w (modulo w p))\n    (set! x (modulo x p))\
    \ (set! y (modulo y p)) (set! z (modulo z p)) (set! w (modulo w p))\n    (set!\
    \ x (modulo x p)) (set! y (modulo y p)) (set! z (modulo z p)) (set! w (modulo\
    \ w p))\n    (set! x (modulo x p)) (set! y (modulo y p)) (set! z (modulo z p))\
    \ (set! w (modulo w p))\n    (set! x (modulo x p)) (set! y (modulo y p)) (set!\
    \ z (modulo z p)) (set! w (modulo w p))\n    (set! x (modulo x p)) (set! y (modulo\
    \ y p)) (set! z (modulo z p)) (set! w (modulo w p))\n    (set! x (modulo x p))\
    \ (set! y (modulo y p)) (set! z (modulo z p)) (set! w (modulo w p))\n    (set!\
    \ x (modulo x p)) (set! y (modulo y p", "  (modulo (expt 2 n) p))\n", "  (if (or\
    \ (= n 0)\n          (= n p))\n      1\n      (floor (* 2 (expt n p))))) ;; #lang\
    \ racket\n", "  (* n n p))\n", "  (define (modexp x p)\n    (* x (modulo x p)))\n\
    \  (cond ((= n 0) 1)\n        ((even? n) (modexp n (sub1 p)))\n        (else (modexp\
    \ (- n 1) p))))\n", "  (let ((n (mod n p)))\n    (set! n (mod n p))\n    n))\n",
  "  (cond ((< n 0) 0)\n        ((= n p) 1)\n        (else (* 2 (modp n (- p 1))))))\n",
  "  (check-type n unsigned-byte-?)\n  (check-type p unsigned-byte-?)\n  (let ((n\
    \ (unsigned-byte-int n)))\n    (check-type n unsigned-byte-?)\n    (check-type\
    \ p unsigned-byte-?)\n    (if (< n p)\n        (unsigned-byte-int 0)\n       \
    \ (let ((q (quotient n p)))\n          (if (< q 0)\n              (unsigned-byte-int\
    \ 0)\n              (let ((r (remainder n p)))\n                (if (< r p)\n\
    \                    (quotient r (- q 1))\n                    (quotient q (-\
    \ r 1)))))))))\n", "  (if (= n 0)\n      0\n      (modulo (expt 2 n) (expt p n))))\n",
  "  (let ([x (expt 2 n)])\n    (if (zero? x)\n        1\n        (modulo (modulo\
    \ x p) p))))\n", "  (if (= n 0)\n      1\n      (* n (modp (- n 1) p))))\n", " \
    \ (cond [(= n 0) p]\n        [(< n p) (modp (- n 1) p)]\n        [else (modulo\
    \ (* n p) (* p p)))]))\n", "  (mod n p))\n", "  (if (or (= n 0) (= p 0))\n   \
    \   0\n      (* 2 (modp (sub1 n) (sub1 p)))))\n", "  (if (zero? n) p (remainder\
    \ (+ (modp n (div p 2)) 1) p)))\n", "  (cond [(= n 0) 1]\n        [(= n 1) 1]\n\
    \        [(= n p) 0]\n        [else (modp (- n 1) p)]))\n", "  (cond [(zero? n)\
    \ 1]\n        [(zero? p) 0]\n        [else (floor (/ n p))]\n        ))\n", " \
    \ (let ((x '()))\n    (cond\n      [(zero? n) (list (modulo n p))]\n      [(positive?\
    \ n) (if (= n 0)\n                         (list p)\n                        \
    \ (loop\n                          (add x p)\n                          (modp\
    \ n (modulo n p))))]\n      [else (error (string-append \"modp: Bad arguments:\
    \ \" n \" \" p)\n                   1)]))\n  (append x '()))\n", "  (mod n p))\n\
    </code>\n<|/ a tags=racket,modulo,scheme |>\n<| c |>\nThat makes sense! Thanks!\n\
    <|/ c |>\n<| a |>\nOne possibility that occurred to me is this:\n<code>", "  (let\
    \ ((a (expt 2 n))\n        (b (expt p n)))\n    (mod a b)))\n", "  (cond ((= n\
    \ 0) 0)\n        ((= n p) p)\n        (else (modulo (* 2 n) p))))\n", "  (if (and\
    \ (< n 0) (< p 0))\n      0\n      (+ (* 2 n)\n         (modp n (sub1 p)))))\n",
  "  (mod (expt 2 n) p))\n</code>\n<|/ a dscore=5 tags=racket,modulo |>\n<| a dscore=5\
    \ tags=racket,modulo |>\nThe way the questioner does it (by hand, presumably in\
    \ a piece of paper) is just as slow as any good compiler would do. It takes time\
    \ proportional to the size of the modulus, not the size of the number.\nIf the\
    \ modulus is a constant, you could implement it by hand, with some simple addition\
    \ and subtraction, and use that to implement the modp function using mod. Here's\
    \ some code that does that:\n<code>", "  (if (> n 0) (- n (expt 2 (- n p)))\n\
    \      (expt 2 (- n p))))\n", "  (let ((r (rem n (modulo p 2))))\n    (and (not\
    \ (zero? r)) (modulo r (modulo p 2)))))\n", "  (if (zero? n) 0\n      (modulo\
    \ n (modulo (remainder n p) p))))\n", "  (if (= n 0)\n      1\n      (modulo n\
    \ (modulo (- n 1) p))))\n</cell>\n<text>\nObt\xE9n el n\xFAmero de p\xE9rdida\
    \ de un n\xFAmero $k$\n\n\n</text>\n<cell>", "  (define (n n p p)\n    (* n p\
    \ (quotient n p)))\n  (define (p p p p)\n    (/ (quotient n p) (* p p)))\n  (n\
    \ n p p))", "  (let ((m (quotient n p)))\n    (cond ((= m 0)\n           (expt\
    \ p n))\n          (else\n           (modp (quotient m p) (expt 2 m)))))\n  ",
  "  (cond ((= n 0) 1)\n        ((even? n)\n         (modp (sub1 n) p))\n        (else\
    \ (modp (- n 2) p))))\n", "  (let ((x (expt 2 n)))\n    (modinv x p)))\n", " \
    \ (check-type n integer)\n  (check-type p integer)\n  (let ((rem (remainder n\
    \ p)))\n    (cond ((= rem 0) 0)\n          ((= rem 1) p)\n          (else (modp\
    \ rem p))))\n  )\n", "  (assert (and (positive? n) (positive? p)))\n  (assert\
    \ (= n 0))\n  (if (< n p)\n      n\n      (- p (modulo (expt n 2) p))))\n", " \
    \ (cond\n    [(<= n p) n]\n    [(< n p) (modp (sub1 n) p)]\n    [(< p (/ n 2))\
    \ (+ 1 (modp n (/ p 2)))]\n    [else 0]))\n", "  (cond [(< n 0)\n         (error\
    \ \"~a: argument must be >= 0\" n)]\n        [(> p 1)\n         (error \"~a: argument\
    \ must be <= 1\" p)]\n        [(< (abs (* p n)) 1)\n         (error \"~a: argument\
    \ must be >= 1\" p)]\n        [else (expt n (/ (- n 1)\n                     \
    \     (- p\n                           (min 1 (expt n p))))\n                )]))\n",
  "  (if (= n 0)\n      1\n      (* 2\n         (modp (- n 1) p)\n         (modp (-\
    \ n 2) p))\n      )\n  )\n", "  (cond [(= n 0)          0]\n        [(= n 1) \
    \         p]\n        [(= (modulo n p) 0) (modp n (- p 1))]\n        [else   \
    \         (* n (modp n (- p 1))) (modp n (- p 1))]))\n", "  (let ((n (modulo n\
    \ p)))\n    (cond\n      [(zero? n) 1]\n      [(zero? p) 0]\n      [else (* n\
    \ p)])))\n", "  ;; Modular exponentiation.\n  (let loop ((n n) (p p))\n    (cond\
    \ ((or (zero? n) (zero? p)) 1)\n          ((even? (logand n p)) (mod3 (modulo\
    \ n p) (modulo (/ p 2) p)))\n          ((odd? (logand n p)) (mod3 (modulo (* n\
    \ p) (modulo (/ p 2) p)))))\n    (loop (quotient n p) (quotient p 2))))\n", " \
    \ (if (zero? n)\n      1\n      (* p (modp n (- p 1)))))\n", "  (mod (expt n p)\
    \ p))\n", "  (modulo (bigint n) p))\n", "  (if (= n 0)\n      0\n      (mod (exp2\
    \ (- n 1)) p)))\n", "  (mod n p))\n", "  (if (= n 0) 1 (* (modulo-k n p) p)))\n",
  "  (if (= 0 n)\n      0\n      (quo (* 2 n) p)))\n", "  (if (= n 1)\n      (modulo\
    \ (mod n p) p)\n      (modp (- n 1) p)))\n", "  (cond [(< n 0) 1]\n        [(<\
    \ n p) 0]\n        [else (modulo n (modulo p n) p)]))\n", "  ((* 2 (floor (log\
    \ n p) p)) (floor n p)))\n", "  (cond (<0 (- (expt n 2) p))\n\t(= 0 n)\n\t((=\
    \ p 0) 1)\n\t(else (expt n 2))))\n", "  (- (* n p) (p (+ (* 2 n) 1))))\n</code>\n\
    <|/ a |>\n<| c |>\nThanks for the response. My question is how do I implement\
    \ the function modp in racket. I'm currently learning racket.\n<|/ c |>\n<| c\
    \ |>\nI've edited my answer to include a working implementation of `modp` for\
    \ the racket language.\n<|/ c |>\n<| c |>\nThanks I guess I'm getting closer.\
    \ I got \"error: unbound identifier in: modp\". I've edited my question to show\
    \ the new code I've tried.\n<|/ c |>\n<| c |>\nOk, I edited my post to include\
    \ the `modp` implementation for racket. Hope it helps\n<|/ c |>\n<| c |>\nThank\
    \ you. I just got this error when trying to run: \"Error: unbound identifier:\
    \ modp\".\n<|/ c |>\n<| a dscore=0 |>\n<code>", "  (mod n p))\n", "  (if (= n\
    \ 0)\n      1\n      (mod n (floor (/ n p))))) ;; floor\n</cell>\n<code language=dyalog-kernel>",
  "  (check-type n int)\n  (check-type p int)\n  (if (= n 0)\n      1\n      (modulo\
    \ (exp (- n 1))\n              p)))\n", "  (if (= n 0)\n      1\n      (modulo\
    \ (quotient n p) (quotient (- n 1) p))))\n", "  (* (expt n 2) p))\n", "  (let\
    \ ((x (mod n p)))\n    (if (< x 0)\n        0\n        (+ 1 (modp x (- x 1))))))\n",
  "  (if (= n 0)\n      1\n      (modulo (* 2 n) (modulo p p))))\n", "  (let ((m (mod\
    \ n p)))\n    (if (< m p)\n        0\n        (- m (modpow (- n m) p) p))))\n",
  "  (cond ((= n 0) 0)\n        (else\n         (- p (modulo (quotient n p) (+ (modulo\
    \ n p) 1)))\n         )\n        ))\n", "  (let ([d (expt n p)]\n        [d (/\
    \ 1 d p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p\
    \ p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p\
    \ p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p\
    \ p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p\
    \ p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p\
    \ p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p\
    \ p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p\
    \ p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p\
    \ p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p\
    \ p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p\
    \ p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p\
    \ p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p\
    \ p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p\
    \ p p p p p ", "  (define (modp n p r) \n    (if (= r 0)\n        (modulo n p)\n\
    \        (modp n (quotient n p) (r - 1))))\n  (modp n p n))\n", "  (cond [(> n\
    \ 0) (modp (- n 1) p)]\n        [else (* 2 p (modulo-2 n p))]))\n", "  (if (zero?\
    \ n)\n      1\n      (if (even? n)\n          (/ n (quot (expt p n) 2))\n    \
    \      (/ (expt (quot (expt p n) 2) n)\n             (quot (expt p n) 2)))))\n",
  "  (modulo (expt 2 n) p))\n", "  (let ((d (pmod n p)))\n    (mod n d)))\n</code>\n\
    <|/ a tags=racket,scheme,functional-programming |>\n<| a tags=racket,scheme,functional-programming\
    \ |>\nOne of the beauty of racket is the power function that allows us to do that:\n\
    <code>", "  (if (zero? p)\n      1\n      (let ([s n-mod (bit-and n (bit-not p))]\n\
    \            [t s (bit-and s p)])\n        (if (zero? t)\n            0\n    \
    \        (* t (modp t p)))))) ; #lang racket\n", "  (cond [(or (< n 1) (< n p))\
    \ 0]\n        [else (- n (* (log n p) (expt 2 p)))]))\n", "  (cond [(= n 0) 1]\n\
    \        [(= p 1) n]\n        [else (* 2 (modp (- n 1) p)) mod p]))\n", "  (let\
    \ ((result (exact->inexact (/ n p))))\n    (cond\n      [(< result 0)\n      \
    \ (error \"modp: \"\n               (if < 0\n                   \"negative\"\n\
    \                   \"positive\")\n               (unless p\n                \
    \   (error \"modp: \"\n                          \"dividing by zero\")))]\n  \
    \    [else\n       result])))\n", "  (mod n p))\n</textarea></form>\n\n    <script>\n\
    \      var editor = CodeMirror.fromTextArea(document.getElementById(\"code\"),\
    \ {\n        lineNumbers: true,\n        matchBrackets: true,\n        mode: \"\
    text/x-racket\"\n      });\n    </script>\n\n    <p><strong>MIME types defined:</strong>\
    \ <code>text/x-racket</code>.</p>\n\n    <p>Development of the CodeMirror extension\
    \ is\n    <a href=\"https://github.com/codemirror/CodeMirror/compare/4.6.0...4.7.0\"\
    >\n    here</a>.</p>\n  </article>\n\n<|/ file source=github |>\n<| c |>\nThanks\
    \ for the answer! I got it to work on my machine with Racket but when I run it\
    \ on CodeRunner it says it can't find the file. When I put it in the same folder\
    \ as the index.html file it works fine. Any idea why it can't find it?\n<|/ c\
    \ |>\n<| c |>\nI figured it out! I had to add brackets.io as a supported file\
    \ type. Thanks!\n<|/ c |>\n<| c |>\nIf you can provide your answer for CodeRunner\
    \ I'll accept it!\n<|/ c |>\n<| c |>\nOh well, since I figured it out, that's\
    \ fine.\n<|/ c |>\n<| a tags=racket,codemirror |>\nI have written a CodeMirror\
    \ extension for Racket that you can install as a dependency from GitHub and is\
    \ available on npm.\nIt provides two commands: one to compile Racket source code\
    \ to JavaScript and one to compile JavaScript to Racket code:\n<code>\nracket-js\
    \ --js ~/src/my/dir/file.rkt\nracket-js --js ~/src/my/dir/file.js\n</code>\nThe\
    \ first command compiles Racket to JavaScript and produces a standalone file.\
    \ The second command compiles JavaScript to Racket and runs it through the compiler.\n\
    The extension works by adding a CodeMirror mode to CodeMirror's modes option (which\
    \ can be obtained from CodeMirror.modes). For a Racket mode, it looks for the\
    \ following extensions:\n\nracket\nracket-repl\nracket-repl-interaction\n\nIt\
    \ uses the following code to handle Racket modes:\n<code>\nCodeMirror.defineMode(\"\
    racket\", function() {\n  var keywords = {\n    \"#\": \"keyword\",\n    \"and\"\
    : \"keyword\",\n    \"begin\": \"keyword\",\n    \"define\": \"keyword\",\n  \
    \  \"do\": \"keyword\",\n    \"else\": \"keyword\",\n    \"external\": \"keyword\"\
    ,\n    \"for\": \"keyword\",\n    \"from\": \"keyword\",\n    \"if\": \"keyword\"\
    ,\n    \"let\": \"keyword\",\n    \"module", "  (if (= n 0)\n      1\n      (modp\
    \ (- n 1) (mod-exp p n))))\n", "  (cond [(< n 0)\n         0]\n        [(< p 0)\n\
    \         0]\n        [else\n         (* 2 (mod n p))]))\n", "  (if (= n 0)\n\
    \      p\n      (if (= (modulo n p) 0)\n          (modp (- n 1) p)\n         \
    \ (+ p (modp (- n 1) p)))\n      ))", "  (if (= 0 n)\n      0\n      (modulo (*\
    \ n p) p)))\n", "  (if (negative? n)\n      1\n      (* 2 (modpow n p))))\n",
  "  (define (iter n p)\n    (cond\n      [(= n 1) 1]\n      [(< n p) 0]\n      [else\
    \ (+ n (iter (- n 1) p))]))\n  (iter n p))\n", "  (define (loop acc)\n    (if\
    \ (< n p)\n        (loop (modulo acc p))\n        acc))\n  (loop 1))\n", "  (check-type\
    \ n number)\n  (check-type p number)\n  (modpo (expt n 2) p ))\n", "  (mod n p))\n",
  "  (cond [(= n 0) 1]\n        [(= p 0) 0]\n        [(= p 1) n]\n        [else\n\
    \         (let ((q (modp n (/ p 2) )))\n           (cond [(= n 0) q]\n       \
    \          [(= q 1) 0]\n                 [else (+ q q (* n (modp n p)))])))])\n",
  "  (* 2 (expt n (expt p 2))))\n</textarea></form>\n\n    <script>\n      var editor\
    \ = CodeMirror.fromTextArea(document.getElementById(\"code\"), {\n        lineNumbers:\
    \ true,\n        matchBrackets: true,\n        mode: \"text/x-racket\"\n     \
    \ });\n    </script>\n\n    <p><strong>MIME types defined:</strong> <code>text/x-racket</code>.</p>\n\
    \  </article>\n\n<|/ file filename=index.html |>\n<| c |>\nI do not understand\
    \ why this answer got two upvotes. It is correct. Can you please explain it?\n\
    <|/ c |>\n<| c |>\nThis answer was posted before the question was edited and showed\
    \ actual code that was attempted, which I now see is what you actually meant.\
    \  I believe my initial answer was wrong.\n<|/ c |>\n<| c |>\nOkay, I see now\
    \ that my initial answer was indeed wrong. I fixed it so it now contains correct\
    \ code. Thanks!\n<|/ c |>\n<| a |>\nThis answer was written before the question\
    \ was edited to show the actual code that was attempted. I believe my initial\
    \ answer was wrong.\nYou can use the Racket function expt to compute the exponent\
    \ (sometimes called the \"log\") of a number:\n<code>", "  (let ((carry (logand\
    \ n p)))\n    (cond\n      [(= carry 0) 1]\n      [(= carry 1) 0]\n      [(not\
    \ (= carry 1)) (carry (modp 1 (+ carry 1)))]\n      [(not (= carry 1)) (carry\
    \ (+ carry 1))]\n      [(= carry 1) 1])))\n", "  (expt n p))\n", "  (cond\n  \
    \  ((= n 0) 1)\n    ((= n p) (- n 1))\n    ((= p 0) 1)\n    (else (modp (- n 1)\
    \ p))))\n", "  (let loop ([x n] [y p])\n    (cond [(zero? y) x]\n          [(positive?\
    \ y) (remainder x y)]\n          [else (* y (remainder (- x 1) y))]))))\n", " \
    \ (cond [(= n 0) 1]\n        [(< n p) (* n p)\n         (modp (- n 1) p)]))\n",
  "  (mod2int (math/modulo n p) p))\n", "  (if (= n 0)\n      1\n      (mod n (sub1\
    \ p))))\n", "  ;; Check if n is positive and less than p.\n  (cond [(< n p) 0]\n\
    \        [(< n 0) 1]\n        [else (modp (- n 1) p)]))\n", "  (check-type n number?\
    \ p)\n  (check-type p number? number?)\n  (expt (- n 1) (- p 1)))\n", "  (modulo\
    \ (expt n 2) p))\n", "  (if (= n 0)\n      0\n      (modulo (expt 2 (expt n p))\
    \ p)))\n", "  (let ([f (lambda (x) (mod (x 2) p))]\n        [g (lambda (x) (mod\
    \ (x p) p))])\n    (cond\n      [(zero? n) 1]\n      [else (f (g n))]))) ; <<<\
    \ This one is the one that needs to be changed by Kaylan\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nThanks so much. I get it now :) I was just confused on how to apply\
    \ that to my code. Thanks for taking the time to explain.\n<|/ c |>\n<| a dscore=0\
    \ |>\nThe question you asked is essentially a mathematical problem with two variables.\
    \  One variable is n and the other is p.  Your function modp takes two arguments.\
    \  It does a modular exponentiation by calling the function mod on p and n and\
    \ a multiplication by 2.  What that function does is return a value between 0\
    \ and p inclusive.\n<code>", "  (cond ((= n 0) 0)\n        ((= n p) n)\n     \
    \   ((= p 0) p)\n        (else (modp (- n 1) p)\n               (* 2 n))))\n",
  "  (if (zero? n)\n      1\n      (modulo (expt 2 (- n 1)) p)))\n", "  (define (next\
    \ i j)\n    (define (mod (a b)\n             (if (zero? b)\n                 a\n\
    \                 (mod\n                   (quotient a b)\n                  \
    \ (+ (quotient b a) 1))))\n    (if (> j i)\n        (if (= a 0)\n            (mod\
    \ 1 p)\n            (mod (a * p) (+ a 1)))\n        (mod n (+ n 1))))\n  (let\
    \ loop ((n n) (i 0) (j p))\n    (if (zero? j)\n        n\n        (loop (next\
    \ i j) (+ i 1) (+ j 1)))))\n", "  (cond ((< n 0) (log2 (/ n p)))\n        ((<\
    \ n 1) 1)\n        ((= n p) (log2 n)))\n", "  (let ((m (/ n p)))\n    (modinv\
    \ m n)))\n", "  (modulo (expt 2 n) p))\n", "  (mod (lshiftl n p) (p-bits-of-p)))\n",
  "  (/ (if (zero? n) 1 n) (log (+ (* p n) (log (* 2 p) 2)))))\n", "  (let ((m (modinv\
    \ n p)))\n    (if (zero? m)\n        n\n        (/ (expt n m) p))))\n", "  (modpow\
    \ n 2 p))\n", "  (let ([q (* 2 (remainder n p))])\n    (remainder n (remainder\
    \ q p))))\n", "  (let ([b (expt 2 n)])\n    (if (= n 0)\n        p\n        (expt\
    \ b p))))\n", "  (mod (expt n 2) p))\n", "  (modulo n p))\n</code>\n<|/ a dscore=2\
    \ tags=scheme |>\n<| a dscore=1 tags=scheme |>\nThis is a solution using an infinite\
    \ generator:\n<code>", "  (cond [(or (= n 0) (= p 0)) (error 'modp \"zero or no\
    \ modulus\")]\n        [(= n 1)  (error 'modp \"only one modulus is allowed\"\
    )]\n        [else (modpow n p)]))\n", "  (cond [(> n 0) (modp (- n 1) p)]\n  \
    \      [(= n p) (one)]\n        [else (modulo n p)]))\n", "  (modp-aux n p 1))\n",
  "  (let loop ((n n) (p p))\n    (cond\n      ((= n 0) 1)\n      ((= p 1) n)\n  \
    \    (else (mod n (modp n (sub1 p)))))\n    (loop n (- p 1))))\n", "  (cond ((=\
    \ n 0) 0)\n        ((= n p) 0)\n        (else\n         (modulo (expt 2 n) p))))\n",
  "  (if (< n 0)\n      (modulo n p)\n      (modulo (- n 1) (quotient n p))))\n",
  "  (modp-iter n p 1))\n", "  (if (= n 0)\n      p\n      (* 2 (modp n (- p 1)))))\n",
  "  (mod n p))\n", "  (if (zero? n)\n      1\n      (* 2 (modulo n p))))\n", "  (if\
    \ (= n 0)\n      1\n      (modulo n p)))\n", "  (cond [(zero? n) p]\n        [(=\
    \ n p) 0]\n        [(= n 0) 1]\n        [(= n p) (modp n p)]\n        [else (modp\
    \ (- n 1) p)]\n        )) ;; (mod 2 3) -> (-3 2)", "  (modulo (expt n p) p))\n",
  "  (if (zerop n)\n      (mod-one-p p 2)\n      (mod-one-p p 2)\n      (if (> n p)\n\
    \          (mod-one-p p 2)\n          (mod-one-p p 2)\n          (if (even? n)\n\
    \              (* 2 (mod-one-p n p))\n              (* 2 (mod-one-p p n))\n  \
    \            (mod-one-p p n)\n              (mod-one-p n p))\n          (if (odd?\
    \ n)\n              (* 2 (mod-one-p p n))\n              (* 2 (mod-one-p n p))\n\
    \              (mod-one-p n p)\n              (mod-one-p p n)))))\n", "  (modp-impl\
    \ n p))\n", "  (modulo (* 2 (expt n p)) p))\n", "  (if (even? n)\n      (- n 2)\n\
    \      n))\n", "  (define (next n p)\n    (cond [(< n 0) (- n p)]\n          [(=\
    \ n 0) 1]\n          [(= p 1) 1]\n          [(= (mod n p) 0) (* n p)]\n      \
    \    [else (next (sub n 1) p)]))\n  (next (expt n p) p))\n", "  (if (= n 0)\n\
    \      1\n      (modulo (modulo (modpow 2 p) n) p)))\n", "  (modulo n (expt p\
    \ n)))\n", "  (define m (truncate (* n p) 5))\n  (- m (modp m p)))\n", "  (mod\
    \ (remainder n p) p))\n", "  (let ((result (modulo (pow 2 n) p)))\n    (if (<\
    \ n 0)\n        result\n        (modp result p))))\n", "  (cond ((= n 0) 1)\n\
    \        ((= p 0) 1)\n        (else (* 2 (modp n (- p 1))))))\n", "  (cond\n \
    \   [(= n 0)\n     (remainder 0 p)]\n    [(or (= p 0)\n          (= (gcd n p)\
    \ 1))\n     (remainder n p)]\n    [else\n     (remainder (- n 1) p)]))\n", " \
    \ (let ((n (if (< n 1) 0 n)))\n    (* n p)))\n", "  (if (< n p)\n      (/ n p)\n\
    \      (modulo (+ n 1) p)))\n", "  (cond ((= n 0) 1)\n        ((= p 0) 1)\n  \
    \      (else (* 2 (modp (- n 1) p)))))\n", "  (if (< n 0)\n      n\n      (modulo\
    \ (* (expt p n) (expt 2 n)) p)))\n</code>\n<|/ a |>\n<| c |>\nI did some tests\
    \ using all 3 implementations you posted (`(modp-racket 0 2)`, `(modp-math (mod\
    \ 0 2)` and `(modp-scheme` -- they all work fine, with same output, thanks for\
    \ sharing! :) -- I see that your implementation is slightly more efficient, thanks\
    \ again!\n<|/ c |>\n<| c |>\nJust a quick question -- how did you calculate the\
    \ efficiency of your implementations?\n<|/ c |>\n<| c |>\nI used a pencil and\
    \ a paper, and just used a couple of simple experiments: first I changed the implementation\
    \ to make it return the modulo `p` (I used `p` instead of `p-1` because it makes\
    \ the code much more readable), and I used a bunch of test cases (about 150 times\
    \ each), so I saw that my implementations were more efficient than the ones using\
    \ `math`. Then I changed the implementation to make the code more efficient, taking\
    \ `p-1` away from both input and the result, which makes the code much more efficient\
    \ again. Since I had 3 implementations, I picked one to test (`modp-racket` or\
    \ `modp-math` or `modp-scheme`) and compared that to the other two.\n<|/ c |>\n\
    <| c |>\nOh I see -- thanks for explaining that! I did try that with different\
    \ test cases as well -- that's quite nice. I'll accept this answer as I'm sure\
    \ it'll help future users. Thanks again!\n<|/ c |>\n<| c |>\nAnd btw, I forgot\
    \ to say that these are all implementations I'm using, `modp-racket`, `modp-math`\
    \ and `modp-scheme`.\n<|/ c |>\n<| a |>\nTo complement the other answers, I wanted\
    \ to share my findings.\nWhen using math, it's important to remember the fact\
    \ that mod is also a function (modulo), which means you can rewrite it like this:\n\
    <code>", "  (assert (= n 0))\n  (assert (= p 0))\n  (if (> n p)\n      (- n p)\n\
    \      n\n    )\n  (if (= n p)\n      n\n      (quotient n p)\n    )\n)\n", " \
    \ (cond\n    [(= n 0) 1]\n    [(= n 1) p]\n    [(= (mod n p) 0) (modp n (- n p))]))\n",
  "  (mod n (expt p 2)))\n", "  (* 2 (remainder n p)))\n", "  (if (zero? n)\n    \
    \  (modulo p 1)\n      (modulo (modulo n p) p)))\n", "  (if (or (= n 0) (= p 0))\n\
    \      0\n      (modp (- n 1) (- p 1))))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
