name: HumanEval_71_triangle_area
language: rkt
prompt: "#lang racket\n\n;; Given the lengths of the three sides of a triangle. Return\
  \ the area of\n;; the triangle rounded to 2 decimal points if the three sides form\
  \ a valid triangle. \n;; Otherwise return -1\n;; Three sides make a valid triangle\
  \ when the sum of any two sides is greater \n;; than the third side.\n;; Example:\n\
  ;; >>> (triangle_area 3 4 5)\n;; 6.0\n;; >>> (triangle_area 1 2 10)\n;; -1\n(define\
  \ (triangle_area a b c)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate triangle_area))\n\
  \    (check-equal? (candidate 3 4 5) 6.0)\n    (check-equal? (candidate 1 2 10)\
  \ -1)\n    (check-equal? (candidate 4 8 5) 8.18)\n    (check-equal? (candidate 2\
  \ 2 2) 1.73)\n    (check-equal? (candidate 1 2 3) -1)\n    (check-equal? (candidate\
  \ 10 5 7) 16.25)\n    (check-equal? (candidate 2 6 3) -1)\n    (check-equal? (candidate\
  \ 1 1 1) 0.43)\n    (check-equal? (candidate 2 2 10) -1)\n))\n\n(test-humaneval)"
completions: ["  (cond\n    [(or (< a b) (< b c)) -1]\n    [(or (< b c) (< a c)) -1]\n\
    \    [else (/ (- a b) (- b c))]))\n", "  (cond\n    [(< a b) (* -1 -1)]\n    [(<\
    \ b c) (* -1 -1)]\n    [(< c a) (* -1 -1)]\n    [else (/ a b c (+ b c a))]\n \
    \ )\n)\n", "  (if (< a b) (* a b (/ a c))\n      (if (< b c) (* b c (/ (b c) a))\
    \ -1)))\n</code>\n<|/ a dscore=1 |>\n<| c |>\nI am confused how to use this in\
    \ my code...could you show me how it would be used in my code? Thanks.\n<|/ c\
    \ |>\n<| a dscore=1 tags=racket,scheme |>\n<code>", "  (/ (- (* a b) (* a c) (*\
    \ b c))\n     (sqrt (+ (* a a) (* b b) (* c c))))\n)\n</cell>\n<code language=racket-student-translator>\n\
    #lang racket\n", "  (cond\n    [(<= a b) (/ a b)]\n    [(<= b c) (/ b c)]\n  \
    \  [(<= c a) (/ c a)]))\n", "  (if (= a b)\n      (car b)\n      (if (= a c)\n\
    \          (+ (/ a b)\n             (/ b c))\n          (- b (/ a c))))))\n",
  "  (if (> a b)\n      (if (> a c)\n          (/ (+ a b c) 2)\n          -1)\n  \
    \    (if (> b c)\n          (/ (+ b c a) 2)\n          -1)))\n", "  (let* ((triangle-side-lengths\
    \ (list a b c))\n         (sum (+ a b c))\n         (third (list->vector (vector-ref\
    \ triangle-side-lengths 2)))\n         (sum-three (+ sum third))\n         (valid?\
    \ #t\n           (= (vector-ref triangle-side-lengths 1)\n             (if (<=\
    \ (vector-ref triangle-side-lengths 0)\n                     (vector-ref triangle-side-lengths\
    \ 2)) \n                   sum-three \n                   (vector-ref triangle-side-lengths\
    \ 1)))) \n         (area 0.0)\n         (rounded-area 0.0)\n         (sum-three-rounded\
    \ (floor (+ sum-three 0.5))) \n         (sum-three-rounded (floor sum-three-rounded))\n\
    \         (last-sum (vector-ref triangle-side-lengths 0))\n         (remaining-sum\
    \ (- last-sum sum-three))\n         (last-sum-rounded (floor (+ last-sum 0.5)))\
    \ \n         (remaining-sum-rounded (- last-sum-rounded sum-three-rounded))\n\
    \         (triangle-side-lengths-sum (vector-sum triangle-side-lengths))\n   \
    \      (sum-three (+ (vector-ref triangle-side-lengths 1) sum-three)) \n     \
    \    (rounded-area 0.0)\n         (triangle-side-lengths-sum-rounded (floor (+\
    \ sum-three 0.5))) \n         (sum-three (+ (vector-ref triangle-side-lengths\
    \ 1) sum-three)) \n         (triangle-side-lengths-sum-rounded (floor (+ sum-three\
    \ 0.5)))\n         (last-sum (vector-ref triangle-side-lengths 0))\n         (remaining-sum\
    \ (- last-sum sum-three))\n         (last-sum-rounded (floor (+ last-sum 0.5)))\
    \ \n         (remaining-sum-rounded (- last-sum-rounded sum-three-rounded))\n\
    \         (last-sum-unrounded (* last-sum 0.5))\n         (remaining-sum-unrounded\
    \ (* remaining-sum 0.5))\n         (last-sum-rounded (floor (+ last-sum 0.5)))\
    \ \n         (remaining-sum-rounded (floor (+ remaining-sum 0.5)))\n         (remaining-sum-unrounded\
    \ (* remaining-sum 0.5))\n         (last-sum-unrounded (* last-sum 0.5))\n   \
    \      (triangle-side-lengths-sum (vector-sum triangle-side-lengths))\n      \
    \   (sum-three (+ (vector-ref triangle-side-lengths 1) sum-three)) \n        \
    \ (", "  (if (= a b)\n      (if (= a c)\n          (* a c)\n          (* b (/\
    \ c a)))\n      (if (= b c)\n          (* a (c/ b))\n          (* b (/ c (/ b\
    \ a))))\n      (* -1 (/ b (/ a c))))))\n", "  (/ (+ a b c) (* a (min b c)))) ;;\
    \ (+ a b c) because (* a (min b c)) will give you a \n                       \
    \                  ;; negative number if b > c. That's because \n            \
    \                             ;; abs returns the smallest positive number\n  \
    \                                       ;; and min returns its smallest argument.\
    \ \n", "  (/ (- b a) (- c b)))\n", "  (/ (* a b) (+ a b c)))\n</cell>\n<cell>\n\
    #lang racket\n", "  (cond\n    [(< a (+ b c)) (* a (triangle_area a b c))\n  \
    \   (if (= a b)\n           (* b c)\n           (* a c))]\n    [(< b (+ a c))\
    \ (* b (triangle_area a b c))\n     (if (= b c)\n           (* a c)\n        \
    \   (* b c))]\n    [(< c (+ a b)) (* c (triangle_area a b c))\n     (if (= c a)\n\
    \           (* b c)\n           (* c a))]))\n", "  (cond ((<= a b c) (+ (/ (+\
    \ (- a b) (- b c)) (* a b)) (* a c)))\n        (else -1)))\n", "  (let ((x a))\n\
    \    (while (and (<= x b) (<= x c))\n      (set! x (+ (* x x) (/ x 2)))\n    \
    \  (format t \"~a\" (/ x 4))\n      (set! x (- x 2))\n      (format t \"~a\" (/\
    \ x 4))\n      (set! x (- x 2))\n      (format t \"~a\" (/ x 4))\n      (set!\
    \ x (- x 2)))\n    (if (> x c)\n      (/ x 4)\n      (/ x 3)))\n  (let ((x a))\n\
    \    (while (and (<= x b) (<= x c))\n      (set! x (+ (* x x) (/ x 2)))\n    \
    \  (format t \"~a\" (/ x 4))\n      (set! x (- x 2))\n      (format t \"~a\" (/\
    \ x 4))\n      (set! x (- x 2))\n      (format t \"~a\" (/ x 4))\n      (set!\
    \ x (- x 2))\n      (format t \"~a\" (/ x 4))\n      (set! x (- x 2)))\n    (if\
    \ (> x c)\n      (/ x 4)\n      (/ x 3)))\n  (let ((x a))\n    (while (and (<=\
    \ x b) (<= x c))\n      (set! x (+ (* x x) (/ x 2)))\n      (format t \"~a\" (/\
    \ x 4))\n      (set! x (- x 2))\n      (format t \"~a\" (/ x 4))\n      (set!\
    \ x (- x 2))\n      (format t \"~a\" (/ x 4))\n      (set! x (- x 2))\n      (format\
    \ t \"~a\" (/ x 4))\n      (set! x (- x 2)))\n    (if (> x c)\n      (/ x 4)\n\
    \      (/ x 3)))\n  (let ((x a))\n    (while (and (<= x b) (<= x c))\n      (set!\
    \ x (+ (* x x) (/ x 2)))\n      (format t \"~a\" (/ x 4))\n      (set! x (- x\
    \ 2))\n      (format t \"~a\" (/ x 4))\n      (set! x (- x 2))\n      (format\
    \ t \"~a\" (/ x 4))\n      (set! x (- x 2))\n      (format t \"~a\" (/ x 4))\n\
    \      (set! x (- x 2))\n      (format t \"~a\" (/ x 4))\n      (set! x (- x 2)))\n\
    \    (if (> x c)\n      (/ x 4)\n      (/ x 3)))\n", "  (cond\n    [(< (+ a b)\
    \ c) (* a c)]\n    [else (* a b)]))\n", "  (if (and (> a b) (> b c) (> c a))\n\
    \      ((* a b c) 4)\n      (-1)))\n", "  (cond\n    ((and (> (+ a b) c) (> b\
    \ c)) (/ 6 (+ (* a b) (* c b))))\n    ((and (> (+ a b) c) (> b c)) (/ 6 (+ (*\
    \ a b) (* c b))))\n    ((and (> (+ a b) c) (> b c)) (/ 6 (+ (* a b) (* c b))))\n\
    \    (else (/ -1 -1))))\n</cell>\n<text>\nExercises\nExercise 1:\nUsing the code\
    \ above create a function which calculates the area of a triangle. Use the cond\
    \ syntax to test if the sides are greater or less than the third side. If they\
    \ are greater, then the triangle is valid and you should return the area of the\
    \ triangle (otherwise return -1). Make sure you test all the valid cases, not\
    \ just the ones that have a side greater than the third side. Make sure you output\
    \ the correct area for the test cases. For example, if you were given $a = 2$,\
    \ $b = 10$ and $c = 5$ you should return $10$ not $2.75$.\n\nExercise 2:\nCreate\
    \ a function which calculates the area of a triangle (no side lengths are input\
    \ to the function). Call the function on the three sides of the triangle. Using\
    \ cond return an error message if there is no valid triangle, or return the area\
    \ of the valid triangle (if the triangle is valid). Make sure you test all the\
    \ valid cases, not just the ones that have a side greater than the third side.\
    \ Make sure you output the correct area for the test cases. For example, if you\
    \ were given $a = 2$, $b = 10$ and $c = 5$ you should return $10$ not $2.75$.\n\
    \n\n</text>\n<cell>\n#lang racket\n", "  (cond\n    ((< a b) (+ a b)) (< a c)\
    \ (+ a c) (< b c) (+ b c)\n    ((< b c) (+ b c)) (< c a) (+ c a) (< c b) (+ c\
    \ b)\n    (else (+ c a))))\n", "  (cond [(< a b) (triangle_area b c a)]\n    \
    \    [(< c b) (triangle_area a b c)]\n        [(< a c) (triangle_area b a c)]\n\
    \        [else (* a (triangle_area b c a))]))\n", "  (/ (+ a b) (+ c a) (+ c b)))\n",
  "  ;; Calculate the sum of the two sides\n  (+ (* a b) (* c a)))\n", "  (cond\n\
    \    [(zero? a)  (/ 0 1)] \n    [(zero? b) (/ 0 1)]\n    [(zero? c) (/ 0 1)]\n\
    \    [else (/ a b)] \n    [else (/ c b)]\n    [else (/ a c)]))\n</code>\nThe above\
    \ is a function that finds the area of a triangle when given three sides. \nWe\
    \ know that a triangle must satisfy the following conditions:\n\nThe sides a,\
    \ b, and c form a right angled triangle with base a and height b.\nThe sum of\
    \ any two sides must be less than the third side.\nTherefore the area of a triangle\
    \ is calculated as (a / b) * c.\n\nTo find the area of a triangle given the lengths\
    \ of three sides we can do the following:\n<code>", "  (cond [(< a b)\n      \
    \   (if (< c b) (/ c (+ a b))\n               (/ c a))]\n        [else\n     \
    \    (if (< c a) (/ c (+ b a))\n               (/ c b))]\n        [else\n    \
    \     (/ a c))))\n", "  (cond\n    [(> (+ a b) (+ c a)) (round (* a c))]\n   \
    \ [(> (+ b c) (+ a b)) (round (* b c))]\n    [else -1]\n  )\n)\n", "  (cond\n\
    \    [(> a b) (/ 0 -1)]\n    [(> b c) (/ 0 -1)]\n    [(> c a) (/ 0 -1)]\n    [else\
    \ (/ (- (square (- b a)) (square (- c b)) (square (- a c))) 2)]))\n</code>\n<|/\
    \ a dscore=0 |>\n<| a dscore=0 tags=lisp,scheme,racket,recursion |>\n<code>\n\
    #lang racket", "  (cond\n    ((> a b) (/ (- a c) b))\n    ((> b c) (/ (- b a)\
    \ c))\n    ((> c a) (/ (- a b) c))\n    (else 0)))\n", "  (if (< (+ a b) (+ b\
    \ c))\n      (/ (+ (* a b) (* b c)) 2)\n      -1))\n", "  (if (or (> a b) (> b\
    \ c) (> c a))\n      (/ 0.5\n         (+ (* 0.5 (* a b)) (* 0.5 (* b c)) (* 0.5\
    \ (* c a))))\n      (-1)))\n", "  (if (= (+ a b c) 0) -1\n      (/ 6\n       \
    \ (+ (* a a) (* b b) (* c c)))\n  ))\n</code>\nNow we can test all the cases:\n\
    <code>\n#lang racket", "  (cond\n    ((= a b) (* c c))\n    ((= b c) (* a a))\n\
    \    ((= c a) (* b b))\n    (else (/ -1 0))))\n", "  (/ (+ (* a b) (* b c)) (*\
    \ a b)))\n", "  (cond\n    [(< a b) (- 1.0)]\n    [(< b c) (- 1.0)]\n    [(< c\
    \ a) (- 1.0)]\n    [else (/ (+ (expt a 2) (expt b 2)) (expt c 2))]))\n", "  (let\
    \ loop ((a a) (c c) (n 0) (d b))\n    (if (< d a) (+ 1 (loop a (- b d) c)) -1)))\n",
  "  (if (or (< a b) (< b c) (< c a))\n      (/ 0 (+ a b c))\n      -1)\n)\n</cell>\n\
    <code language=dyalog-kernel>", "  (cond\n    [(< a b) (* -1 0)]\n    [(< b c)\
    \ (* -1 0)]\n    [(< c a) (* -1 0)]\n    [else (* 1.0 / (+ (* a b) (* b c) (*\
    \ c a)))]))\n", "  (if (> (+ a b) (+ c a))\n      (/ (+ a b) (+ c a)) \n     \
    \ (/ (+ c a) (+ c b)) \n      (/ (+ a b) (+ b c)) \n      (/ (+ b c) (+ a b))))\n",
  "  (if (and (> a b) (> b c) (> c a)) \n      (round (/ (+ a b c) (- b c a))) \n\
    \      (-1)))\n", "  (if (< (+ a b c) 10)\n      (/ (+ a b) (+ c a))\n      -1))\n",
  "  (cond\n    [(> a b) (triangle_area b (add1 b) c)]\n    [(> b c) (triangle_area\
    \ a (add1 a) c)]\n    [(> c a) (triangle_area a (add1 a) b)]\n    [else (round\
    \ (/ (/ (- a b) (- b c)) (- a b))) ]))\n", "  (cond [(> a b) (+ (* a b) (* b c))]\n\
    \        [(> b c) (+ (* a c) (* c b))] \n        [else -1]))\n", "  (if (or (=\
    \ a b) (= b c) (< a c))\n      (/ a b)\n      (/ b c)\n      (/ (+ a b c) (- b\
    \ (+ a c))))) \n</code>\n<|/ a tags=racket,lisp |>\n<| c |>\nThe only thing that\
    \ looks particularly interesting here is \"(/ (+ a b c) (- b (+ a c)))\". That\
    \ seems very interesting. :)\n<|/ c |>\n<| c |>\nThanks for that - I have added\
    \ that to the answer.\n<|/ c |>\n<| c |>\nI do like your approach and think it\
    \ might be a little more readable with the use of some \"destructuring\". I have\
    \ also added a link to the original paper which describes the algorithm in the\
    \ way I would have written it in scheme and I like the way it reads too.\n<|/\
    \ c |>\n<| c |>\nThanks. I don't think it needs any destructuring - but if it\
    \ works it works. :)\n<|/ c |>\n<| a |>\nThe code below works fine, even though\
    \ it uses only unnecessary language features.\n<code>\n#lang racket\n", "  (if\
    \ (< (+ a b) (+ c c))\n      (/ (+ a b) (+ c c))\n      (-1)))\n", "  (/ (* a\
    \ b) (+ a b c)))\n", "  (cond [(< a (* b c))\n         (/ a b (+ (* b c) (* a\
    \ c)))]\n        [else\n         (/ a b (+ (* b c) (* a c)))]\n        [else (/\
    \ a c (+ (* b c) (* a c)))]))\n", "  (cond\n    [(< a b c) -1]\n    [(< b c a)\
    \ -1]\n    [(< c a b) -1]\n    [else (* 0.5 (+ a b c))]))\n", "  (cond\n    [(<\
    \ a b) (- a (* b c))]\n    [(< b c) (* a (- (* b c) a))]\n    [(< c a) (* a (-\
    \ c b))]\n    [else (* a (/ b (- a b)))]))\n", "  (if (= (+ a b c) (+ b c a))\n\
    \    (/ (+ (* a b) (* b c) (* c a)) 2.0)\n    -1))\n</code>\n<|/ a |>\n<| a tags=racket,algorithm\
    \ |>\nI wrote this algorithm for another question which I thought was similar\
    \ but different enough to merit its own question.  It's written in Racket, which\
    \ uses syntax-case to distinguish between syntax and normal form.  I made it very\
    \ easy to understand:\n<code>\n#lang racket\n", "  (if (or (< a b) (< b c) (<\
    \ c a))\n      -1\n      (- (* a b) (* b c) (* c a))))\n", "  (cond\n    [(< a\
    \ b)\n     (* a (triangle_area b c a))\n    ]\n    [(< b c)\n     (* b (triangle_area\
    \ a c b))\n    ]\n    [(< c a)\n     (* c (triangle_area a b c))\n    ]\n    [else\
    \ 0]))\n", "  (if (= a b)\n      (* a c) \n      (if (= b c)\n          (* b c)\n\
    \          (* a b))))\n", "  (/ (+ (* a b) (* b c)) (+ (* a c) (* c b))))\n</cell>\n\
    <text>\nWe then need to define the function is_triangle which checks whether the\
    \ sides of a triangle are valid. \nThe function is_triangle should be called with\
    \ as many arguments as the total number\nof sides in a triangle (3 or less).\n\
    \nWrite a function that checks whether a triangle is valid by calling \ntriangle_area\
    \ three times (once, for each side) and returning true or false accordingly.\n\
    Remember: is_triangle must only be called with the right number of arguments.\n\
    \n\n</text>\n<code language=racket-student-prod-julesson>", "  (- (+ (* a b) (*\
    \ c a)) (* c b)))\n</code>\n<|/ a tags=racket,scheme dscore=0 |>\n<| a |>\nHere's\
    \ a little solution that's not particularly elegant but which seems pretty efficient\
    \ at first glance:\n<code>", "  (cond ((< a b) (* c a)) \n        ((< b c) (*\
    \ c b)) \n        ((< c a) (* c c))))\n", "  (/ (+ (* a b) (* b c)) (* a (b c)))\n\
    \  )\n", "  (if (= a b)\n      (/ c 2)\n      (/ a b (+ c b) 2)\n  )\n)\n", " \
    \ (cond\n    [(= a b c) 0]\n    [(= b c a) 0]\n    [(= c a b) 0]\n    [else (/\
    \ a (sqrt (b ^ 2 c)\n                      + (/ b c (sqrt ((+ b c) (- a b)))\n\
    \                              (+ a b (+ c a)))\n                          (*\
    \ a (sqrt ((+ a b) (+ c a)) (+ c a)))\n             2)]))\n", "  (cond\n    [(<\
    \ a b c)\n     (/ (+ (square (- a b)) (square (- c a))) (square (- b c)))]\n \
    \   [(< a b c) (* -1 -1)]\n    [else (* -1 -1)]))\n", "  (cond\n    [(> (+ a b)\
    \ c) (a * (/ b c)) ]\n    [(> (+ a c) b) (a * (/ c b)) ]\n    [(> (+ b c) a) (a\
    \ * (/ a c)) ]\n    [else -1]\n  )\n)\n", "  (cond\n    [(< (+ a b) c) (/ a b)]\n\
    \    [(< (+ c b) a) (/ c b)]\n    [else (- (/ a b) (/ c b))]\n  )\n)\n", "  (if\
    \ (and (> a b) (> b c) (> c a))\n    (* a b c)\n    -1))\n", "  (let ([len-a (-\
    \ (length a) (length b) (length c))])\n    (cond\n      [(>= len-a 3) (round (/\
    \ (+ a b c) 2))]\n      [(>= len-b 3) (round (/ (+ b c a) 2))]\n      [(>= len-c\
    \ 3) (round (/ (+ c a b) 2))]\n      [else -1])))\n", "  (cond\n    ((= a b) (+\
    \ c a)) \n    ((= b c) (+ a b))\n    ((< a b) (/ a b)\n      (/ b c)\n      (*\
    \ a b (/ c b)))\n    ((< b c) (/ b c)\n      (/ a b)\n      (* b c (/ a b)))\n\
    \    ((< c a) (/ c a)\n      (/ b c)\n      (* c a (/ b c)))\n    (else (/ a b)\n\
    \      (/ b c)\n      (* a b (/ c b))))\n", "  (let* ((side (abs (a-b c)))\n \
    \        (sum (+ (abs a) (abs b) (abs c)))\n         (remainder (- sum (* side\
    \ side)))\n         (area_rounded\n           (if (> (abs a) (abs b) (abs c))\n\
    \               (* 1.0 (/ (* remainder (/ side side)) side))\n               0))\n\
    \         )\n         (valid (= sum (+ a b c)))\n         )\n    (if (and (not\
    \ valid) (= a b))\n        (* area_rounded b)\n        (* area_rounded a)\n  \
    \  )\n  )\n)\n", "  (let ((s1 a b c))\n    (cond ((< a b) (/ (+ a b c) 2))\n \
    \         ((< b c) (/ (+ b c a) 2))\n          ((< c a) (/ (+ c a b) 2))\n   \
    \       (else -1))))\n", "  (cond\n    [(= (+ a b c) 0) -1]\n    [(< a b) (- c\
    \ (/ a b))]\n    [(< b c) (- a (/ b c))]\n    [(< c a) (/ a b) (/ b c)]\n    [else\
    \ 0]))\n</code>\n<|/ a |>\n<| c |>\nThe third case has `(/ b a)` instead of `(/\
    \ b c)` - that seems to be the key here - thank you!\n<|/ c |>\n<| c |>\nFixed\
    \ now. Thanks.\n<|/ c |>\n<| a dscore=1 |>\nYour second case (two sides are equal)\
    \ doesn't appear to be working as expected.  Here's a version with an explicit\
    \ condition for equal sides:\n<code>", "  (cond\n    [(> (+ a b c) (+ b c a))\n\
    \     (/ (+ a b c) (+ b c a))\n     (/ (+ a b c) (+ b c a))\n     (/ (+ a b c)\
    \ (+ b c a))\n     (/ (+ a b c) (+ b c a))\n     (/ (+ a b c) (+ b c a))]\n  \
    \  [else -1]))\n", "  (cond [(= a b) (+ c a)]\n        [(= b c) (+ a b)]\n   \
    \     [(< (+ a b) (+ c a)) (+ (expt a 2) (expt b 2) (expt c 2))]))\n", "  (if\
    \ (= a b) (/ a c)\n      (if (= b c) (/ b a)\n          (if (> a c) (/ a b) (/\
    \ b c))))\n)\n", "  (/ (+ a b c) (* 2 (floor (* a b c))))) \n", "  (cond\n   \
    \ ((> a b)\n     (cond\n       ((> b c)\n        (* a b)\n        (* b c))\n \
    \      (#t -1))\n    ((> b c)\n     (cond\n       ((> a c)\n        (* a b)\n\
    \        (* b c))\n       (#t -1))\n    ((> c a)\n     (cond\n       ((> a b)\n\
    \        (* a b)\n        (* b c))\n       (#t -1)))\n    (#t -1)))\n", "  (cond\n\
    \    ((and (positive? a) (positive? b) (positive? c)) \n      (/ (+ a b c) (+\
    \ a b (- c a)))\n    )\n    ((and (positive? a) (positive? b) negative? c)\n \
    \     (/ (+ a b (- c a))\n        (- (- a b) (- (- c a) a))\n      )\n    )\n\
    \    ((and (positive? a) negative? b) (/ (- a b c) (- a (+ b c) a))\n    )\n \
    \   ((negative? a) (/ (- a b c) (+ a (- b c) a))\n    )\n    ((negative? a) (/\
    \ (- a b c) (+ a (- b c) a))\n    )\n    ((negative? a) -1\n    )\n    (else -1\n\
    \    )\n  )\n)\n", "  (if (< (+ a b c) (+ b c a))\n      (/ a 2)\n      (/ b 2)\n\
    \      (/ c 2)))\n", "  (cond\n    [(> (+ a b c) b) (/ a b)]\n    [(> (+ a b c)\
    \ c) (/ a c)]\n    [(> (+ a b c) a) (/ (+ b c) 2)]\n    [else -1]))\n", "  (/\
    \ (+ (* a b) (* c b)) (* a c)))\n</code>\n<|/ a dscore=0 |>\n<| a tags=scheme,lisp\
    \ |>\nHere is a solution in Scheme/Racket:\n<code>", "  (cond\n    [(> (+ a b\
    \ c) b) (/ a 2)]\n    [(< (+ a b c) c) (/ a 2)]\n    [else (/ a 3)]))\n", "  (/\
    \ (- (* a b) (* b c)) (+ a b c)))\n", "  (cond ((= a b) (/ a c))\n        ((=\
    \ b c) (/ a b))\n        (else (/ a (+ b (* c c))))))\n", "  (if (> (+ a b c)\
    \ a)\n      (if (> (+ a b c) b)\n          (if (> (+ a b c) c)\n             \
    \ (/ (+ a b c) (+ a b c))\n              -1)\n          -1)\n      -1))\n", " \
    \ (if (or (< a b) (< b c) (< c a))\n      (* a b c)\n      -1))\n", "  (cond\n\
    \    [(or (zero? a) (zero? b) (zero? c)) (negative_infinity 'triangle_area)]\n\
    \    [(> a (+ b c)) (positive_infinity 'triangle_area)]\n    [(> b (+ c a)) (positive_infinity\
    \ 'triangle_area)]\n    [(> c (+ a b)) (positive_infinity 'triangle_area)]\n \
    \   [else (/ a + (/ b c) (/ c a))]))\n", "  (if (or (< a b)\n\t   (< b c)\n\t\
    \   (< c a))\n      (/ (- a b c)\n         (* a b c))\n      -1))\n", "  (if (<\
    \ a b)\n      (if (< b c)\n          (/ (+ a b) (+ c b))\n          -1)\n    \
    \  (if (< c b)\n          (/ (+ a c) (+ b c))\n          -1)))\n", "  \n  (cond\n\
    \    [(< a (+ (* a a) b)) (/ (* a a) b)]\n    [(< a (+ (* a a) c)) (/ (* a a)\
    \ c)]\n    [(< a (+ (* b b) c)) (/ (* b b) c)]\n    [else -1]\n    )\n)\n\n",
  "  (check-type a int)\n  (check-type b int)\n  (check-type c int)\n  (/ a b (+ c\
    \ a)))\n", "  (if (> (+ a b c) b)\n      (+ (/ b a) (/ c a))\n      (if (> c b)\
    \ \n          (/ c b)\n          -1)))\n", "  (/ (+ a (- b (* c c)))\n     (+\
    \ a (- b (* a a)))\n     (+ a (- b (* b b)))))\n", "  (cond [(<= a b) (/ a c)]\n\
    \        [(<= b c) (/ b c)]\n        [else (/ a b)]))\n", "  (/ (+ (* a b) (*\
    \ b c) (* c a)) (* a b c)))\n", "  (/ (+ (* a b) (* c a)) (* b c)))\n", "  (if\
    \ (= (+ a b c) 0)\n      -1\n      (/ (+ a (* 2 (+ b c))) (+ a b c))))\n", " \
    \ (cond\n    [(= a b) (* a c)]\n    [(= b c) (* b a)]\n    [(> b c) (* a c)]\n\
    \    [(> c a) (* c b)]\n    [else -1]))\n</cell>\n<cell>\n#lang racket\n", " \
    \ (cond\n    [(> a b) (* -1 -1)]\n    [(> b c) (* -1 -1)]\n    [(> c a) (* -1\
    \ -1)]\n    [else (/ sqrt (+ (* a a) (* b b) (* c c))\n                (* 0.5\
    \ (/ a a) (/ b b) (/ c c)))]))\n", "  (if (> a b c) (* a b c) -1) )\n", "  (-\
    \ (square (/ a b)) (square (/ c b)) (square (/ a c))))\n</code>\n<|/ a tags=racket,scheme\
    \ dscore=2 |>\n<| c |>\nThank you very much!\n<|/ c |>\n<| c |>\nYou are welcome.\
    \ Feel free to accept the answer if it solves your problem ;)\n<|/ c |>\n<| c\
    \ |>\nThe question asked for a way to implement it in Scheme. I believe that this\
    \ is the correct answer. Since it uses only Scheme built-ins, it's efficient and\
    \ correct. While the other answers use external libraries.\n<|/ c |>\n<| c |>\n\
    You are right, my answer was not exactly the answer I was looking for. I hope\
    \ it is clear\n<|/ c |>\n<| c |>\nI thought my answer was in Scheme, but it was\
    \ not.\n<|/ c |>\n<| a tags=racket,scheme |>\nHere is a solution using only Racket's\
    \ procedures only:\n<code>", "  (if (< a b c)\n      (/ (+ (* a b) (* b c)) 2)\n\
    \      -1))\n", "  (/ (+ a b c) (* 2 a b c)))\n", "  (if (= a b)\n      (* a c)\n\
    \      (if (= a c)\n          (* a b)\n          (* c (/ b (+ (- a c) (- b a)))))))\n",
  "  (cond ((< a b c) (* a b c))\n        ((< b c a) (* b c a))\n        ((< c a b)\
    \ (* c a b))))\n", "  (cond [(< a b) (/ b c)]\n        [(< b c) (/ a c)]\n   \
    \     [else (/ a b)]))\n", "  (cond\n    [(< a b)\n     (* a (triangle_area b\
    \ c a))] \n    [(< b c)\n     (* b (triangle_area a c b))] \n    [(< c a)\n  \
    \   (* c (triangle_area a b c))]))\n", "  (/ (+ a b c) (- (* a b) (* c a))))\n",
  "  (cond\n    [(or (= a b) (= a c)) (* a a)]\n    [(or (= b c) (= b a)) (* b b)]\n\
    \    [(or (= c a) (= c b)) (* c c)]\n    [else -1]))\n", "  (cond\n    [(= a b)\n\
    \     (+ (/ c a)\n        (/ c b))]\n    [(= a c)\n     (+ (/ a b)\n        (/\
    \ a c))]\n    [else\n     (/ (/ (+ a b c)\n           (- a b c))\n        2)]))\n",
  "  (/ (+ (* a b) (* b c))\n     (+ (* b a) (* c a)))\n  2)\n", "  (cond\n    [(or\
    \ (< a b) (< b c)) -1]\n    [(or (> a b) (> b c)) -1]\n    [else (/ 3 * (+ (*\
    \ a b) (* b c) (* c a)))]))\n", "  (if (<= (+ a b c) (cdr triangles))\n      (/\
    \ a b c)\n      -1))\n", "  (cond\n    [(> a b) (* 0.5 (+ a b c))]\n    [(> b\
    \ c) (* 0.5 (+ b c a))]\n    [(> c a) (* 0.5 (+ c a b))]\n    [else (* 0.5 (+\
    \ a b c))]))", "  (if (= a b)\n    (if (= a c)\n      a\n      (* 0.25 (+ (* b\
    \ c) a))\n    )\n    (if (= b c)\n      b\n      (* 0.25 (+ (* a c) b))\n    )\n\
    \    (* 0.25 (+ (* a b) (* c a))))\n", "  (cond\n    [(zero? a) (abs b)\n    \
    \ (abs c)]\n    [(zero? b) (abs c)\n     (abs a)]\n    [(zero? c) (abs a)\n  \
    \   (abs b)]\n    [else (cond \n            [(< a (abs b))\n             (* a\
    \ (triangle_area a (b c) (c a))]\n            [(< b (abs c))\n             (*\
    \ b (triangle_area b (a c) (c b))]\n            [(< c (abs a))\n             (*\
    \ c (triangle_area c (a b) (b c))]\n            [else -1])]))) \n</code>\n<|/\
    \ a |>\n<| c |>\nThis is my solution, but it is very very slow (about 10 seconds).\
    \ Do you know why?\n<|/ c |>\n<| c |>\nWhat is the purpose of `(< a (abs b))`?\
    \  It seems like you're saying \"if they're less than a...\" when `(abs b)` is\
    \ already a number.\n<|/ c |>\n<| c |>\n, thanks for spotting that, I corrected\
    \ it now.  However, I wasn't suggesting it was the only change that would make\
    \ it faster.  I suspect it is the abs that will make it slower, since you're doing\
    \ abs twice (once in each of the cond branches).\n<|/ c |>\n<| c |>\n, if you\
    \ don't mind posting your solution as an answer to your own question, then I'll\
    \ delete my answer since you accepted it.\n<|/ c |>\n<| c |>\n: I am sorry, I\
    \ wanted to post the solution but did not have enough reputation. Now I have posted\
    \ my solution to show others that it is the solution and did not want to waste\
    \ their time. So I appreciate it though.\n<|/ c |>\n<| a tags=racket,scheme |>\n\
    <code>", "  (if (< (+ a b) (+ c a))\n      (/ 1 (+ a b) (+ c a))\n      (/ 1 (+\
    \ a b) (+ c a) -1)))\n", "  (if (> (+ a b c) (/ a b c))\n      (/ a b c)\n   \
    \   -1))\n", "  (cond [(< a b) (triangle_area c (+ a c) (+ b c))]\n        [(<\
    \ b c) (triangle_area a (+ b c) c)]\n        [(< c a) (triangle_area a b (+ c\
    \ a))]))\n", "  (/ (- (+ b a) (+ c b)) (* 2.0 a)))\n", "  (cond [(= a 0) 0]\n\
    \        [(= b 0) 0]\n        [(= c 0) 0]\n        [(> (+ a b c) a) 0]\n     \
    \   [(> (+ a b c) b) 0]\n        [(> (+ a b c) c) 0]\n        [else (/ (+ (* a\
    \ b) (* a c) (* b c)) 2)]))\n", "  ;; (+ (* a b) (* b c) (* c a))\n  (/ (+ (*\
    \ a b) (* b c) (* c a)) (sqrt (+ (* a a) (* b b) (* c c))))\n)\n", "  (cond [(<\
    \ a b) (* -1 -1)]\n        [(< b c) (* -1 -1)]\n        [(< c a) (* -1 -1)]\n\
    \        [else (* 0.5 (+ (/ (+ (* a b) (* b c)) (* a c)) 2))]))\n</cell>\n<text>\n\
    Problem 3\nCreate a function that takes a string and returns true if it only contains\
    \ letters a-z or A-Z or else returns false.\n\n\n</text>\n<code language=racket-lang>",
  "  (cond\n    [(> a b) (* 0.5 (+ (* a b) (* c a)))]\n    [(> b c) (* 0.5 (+ (* b\
    \ c) (* a b)))]\n    [(> c a) (* 0.5 (+ (* c a) (* b c)))]\n    [else -1]))",
  "  (if (and (greater-than a b) (greater-than b c))\n      (/ (+ a b c) (+ (* a a)\
    \ (* b b) (* c c)))\n      -1))\n", "  (- (* a (+ b c)) (* b c)))\n", "  (define\
    \ (is-valid a b c)\n    (or (= a b)\n        (= a c)\n        (= b c)))\n  (define\
    \ (calc-area a b c)\n    (+ (* (expt b 2) (expt c 2)) (expt (sqrt (+ (expt a 2)\
    \ (expt b 2)) \n                                       (expt c 2)))))\n  (define\
    \ (is-valid-for-area a b c)\n    (and (is-valid a b c) (<= a c) (<= b c) (<= c\
    \ a)))\n  (cond ((and (or (= a b) (= a c) (= b c))\n             (is-valid-for-area\
    \ a b c))\n         (calc-area a b c))\n        (else (-1))))\n", "  (cond ((=\
    \ a b) (* c c))\n        ((= b c) (* a a))\n        (else -1)))\n", "  (if (=\
    \ b c)\n      (* a b)\n      (if (>= a b)\n          (/ a b) \n          (- a\
    \ (* b c)))))\n", "  (if (> (+ a b c) 0)\n      (/ (+ a b c) (+ (sqrt (+ (square\
    \ a) (square b) (square c))))\n        (round (* 100 a))))\n  -1)\n</code>\nI\
    \ added the round function as I felt it was better to round to the second decimal\
    \ place rather than the first one but if you're going to round to one decimal\
    \ place then the round function is unnecessary. \nThis is my output:\n<code>\n\
    racket@R5RS:~/racket$ racket triangle_area.rkt\nracket@R5RS:~/racket$ racket triangle1.rkt\n\
    triangle1 is: 2\ntriangle1 is: 4\ntriangle1 is: 6\ntriangle1 is: 5\ntriangle1\
    \ is: 6\ntriangle1 is: 7\ntriangle1 is: 6\ntriangle1 is: 6\ntriangle1 is: 6\n\
    triangle1 is: 5\ntriangle1 is: 4\ntriangle1 is: 4\ntriangle1 is: 3\ntriangle1\
    \ is: 3\ntriangle1 is: 2\ntriangle1 is: 3\ntriangle1 is: 4\ntriangle1 is: 4\n\
    triangle1 is: 4\ntriangle1 is: 4\ntriangle1 is: 2\ntriangle1 is: 4\ntriangle1\
    \ is: 4\ntriangle1 is: 4\ntriangle1 is: 3\ntriangle1 is: 3\ntriangle1 is: 2\n\
    triangle1 is: 2\ntriangle1 is: 3\ntriangle1 is: 2\ntriangle1 is: 3\ntriangle1\
    \ is: 2\ntriangle1 is: 3\ntriangle1 is: 3\ntriangle1 is: 2\ntriangle1 is: 3\n\
    triangle1 is: 2\ntriangle1 is: 3\ntriangle1 is: 3\ntriangle1 is: 2\ntriangle1\
    \ is: 2\ntriangle1 is: 3\ntriangle1 is: 2\ntriangle1 is: 3\ntriangle1 is: 2\n\
    triangle1 is: 3\ntriangle1 is: 2\ntriangle1 is: 3\ntriangle1 is: 2\ntriangle1\
    \ is: 2\ntriangle1 is: 2\ntriangle1 is: 3\ntriangle1 is: 2\ntriangle1 is: 2\n\
    triangle1 is: 3\ntriangle1 is: 2\ntriangle1 is: 2\ntriangle1 is: 2\ntriangle1\
    \ is: 3\ntriangle1 is: 2\ntriangle1 is: 2\ntriangle1 is: 2\ntriangle1 is: 3\n\
    triangle1 is: 2\ntriangle1 is: 2\ntriangle1 is: 2\ntriangle1 is: 2\ntriangle1\
    \ is: 3\ntriangle1 is: 2\ntriangle1 is: 2\ntriangle1 is: 2\ntriangle1 is: 2\n\
    triangle1 is: 2\ntriangle1 is: 2\ntriangle1 is: 2\ntriangle1 is: 2\ntriangle1\
    \ is: 2\ntriangle1 is", "  (if (and (>= a b) (>= b c)) (/ a (b c))\n    (if (and\
    \ (>= a c) (>= b c)) (/ a (b c))\n      (/ a (b c)))))\n", "  (cond \n    [(>\
    \ (+ a b) c) (/ a (c (+ b c)))]\n    [(> (+ b c) a) (/ b (c (+ a c)))]\n    [(>\
    \ (+ c a) b) (/ c (a (+ b a)))]\n    [else -1]))\n", "  (if (< a b) (if (< b c)\
    \ a b) (if (< c a) b c))\n  (/ (+ (* a a) (* b b) (* c c)) (* 3 2)))\n", "  (cond\n\
    \    [(> (+ a b) c) (round (/ a b))]\n    [else -1]))\n", "  (cond\n    [(< a\
    \ b) (/ 0 3)]\n    [(< a c) (/ 0 3)]\n    [(< b c) (/ 0 3)]\n    [else (* -1 (/\
    \ (+ (* a c) (* b c)) 2))]))\n", "  \n  (cond\n    [(or (= a b) (= a c) (= b c))\
    \ (/ a 3)]\n    [(or (= b a) (= b c) (= c a)) (/ b 3)]\n    [(or (= c a) (= c\
    \ b) (= b b)) (/ c 3)]\n    [else -1]))\n", "  (cond\n    [(or (< a b) (< b c)\
    \ (< c a)) -1]\n    [else (/ (+ (* a b) (* b c)) (+ (* b c) (* c a)))]\n    ))\n",
  "  (if (<= a b)\n      (if (>= b c)\n          (/ (+ (* a a) (* b b) (* c c)) 2)\n\
    \          -1)\n      -1))\n", "  (if (or (<= c a) (<= c b))\n      (* a (triangle_area\
    \ b c a)) \n      (* b (triangle_area a c b))\n      (* c (triangle_area a b c))))\n",
  "  (cond\n    [(> a b)\n     (* 2 (/ a b))] \n    [(> b c)\n     (* 2 (/ b c))]\
    \ \n    [(> c a)\n     (* 2 (/ c a))] \n    [(> (+ a b c) a)\n     (* 2 (/ a b))]\
    \ \n    [(> (+ b c a) b)\n     (* 2 (/ b c))] \n    [(> (+ c a b) c)\n     (*\
    \ 2 (/ c a))] \n    [(> a c)\n     (* 2 (/ a c))] \n    [(> b c)\n     (* 2 (/\
    \ b c))] \n    [(> c a)\n     (* 2 (/ c a))] \n    [(> (+ a b c) a)\n     (* 2\
    \ (/ a b))] \n    [(> (+ b c a) b)\n     (* 2 (/ b c))] \n    [(> (+ c a b) c)\n\
    \     (* 2 (/ c a))] \n    [(> a b)\n     (* 2 (/ a b))] \n    [else\n     (*\
    \ 2 (/ a b))]\n  )\n)\n</cell>\n<code language=dyalog-kernel>", "  (if (> (+ a\
    \ b c) a)\n      (/ a (- (+ a b c) (/ a b)))\n      (if (> (+ a b c) b)\n    \
    \      (/ b (- (+ a b c) (/ a b)))\n          (if (> (+ a b c) c)\n          \
    \    (/ c (- (+ a b c) (/ a b)))\n              -1)))\n", "  (if (< a b)\n   \
    \   (* a b (/ c a))\n      (* -1 (* b (/ c b))))) ;; #lang racket\n", "  (/ (+\
    \ a b c) (* a b c)))\n", "  (cond [(< a b) (triangle_area a b c)] [(< b c) (triangle_area\
    \ b c a)] \n        [(< c a) (triangle_area c a b)]))\n", "  (if (>= (+ a b c)\
    \ 0)\n      (* a b c (/ (+ (* a a) (* b b) (* c c)) (* 2 3)))\n      -1\n    \
    \  )\n  )\n", "  (cond\n    [(and (positive? a) (positive? b) (positive? c)) (*\
    \ 0.5 (+ (/ a b) (/ a c) (/ b c)))]\n    [else -1]))\n", "  (cond\n    [(> (+\
    \ a b c) 3) (* 2 (round (* a b c)))]\n    [else (* -1 (round (/ a b c)))]))\n",
  "  (if (>= a b)\n    (if (>= a c)\n      (/ a b)\n      (/ c b))\n    (if (>= b\
    \ c)\n      (/ b c)\n      (/ c c)))\n  ", "  (if (< a b)\n      (if (< b c)\n\
    \          (/ 1 (+ a b c))\n          -1)\n      (if (< c a)\n          (/ 1 (+\
    \ a c b))\n          -1)))\n", "  (cond\n    ((>= a b) (/ c (- (* a b) (car a)\
    \ c)))\n    ((>= b c) (/ c (- (* b c) (bar b) c)))\n    ((>= c a) (/ c (- (* c\
    \ a) (car c) a)))\n    ((< a b) (/ a b))\n    ((< b c) (/ b c))\n    ((< c a)\
    \ (/ c a))))\n", "  (cond [(or (= a b) (= a c) (= b c)) -1]\n        [else (*\
    \ a b c)]\n        (else (* a b c) (* a c b) (* b c a) (* c a b))))\n", "  (cond\n\
    \    [(zero? a) 0]\n    [(zero? b) 0]\n    [(zero? c) 0]\n    [(+ (* a b) (* b\
    \ c)) (round (* a b) 2)]\n    [else (- (* a b) (* b c))]))\n", "  (cond\n    [(<=\
    \ a b c) (* a b c)]\n    [(<= b c a) (* b c a)]\n    [(<= c a b) (* c a b)]\n\
    \    [else -1]))\n", "  (/ (* (- b c) (a+ (* a b)) (-c b)) (- a b c)))\n", " \
    \ (cond [(> a b) (triangle_area a b c)]\n        [(> b c) (triangle_area a b c)]\n\
    \        [(> c a) (triangle_area a b c)]\n        [else (* a b c)]\n        ))\n",
  "  (if (and (< (+ a b) c) (< b c) (< c a))\n      (/ (+ (* a b) (* b c) (* c a))\
    \ 2)\n      -1))\n", "  (if (> a b c)\n      (* a b c)\n      (* a c b)\n    \
    \  (* b c a)))\n", "  (/ (+ a (* b c)) (* a (+ b c)))\n  )\n", "  (if (> a b)\n\
    \      (if (> b c)\n          (/ (+ (* a a) (* b b) (* c c)) 2)\n          -1)\n\
    \      -1))\n", "  (cond [(< a b c) (* a b c)]\n        [else (cond [(< (+ a b)\
    \ (+ c a))\n                       (* a b c)]\n                     [(< (+ b c)\
    \ (+ c b))\n                       (* a b c)]\n                     [else (cond\
    \ [(< (+ a c) (+ b a))\n                                    (* a b c)]\n     \
    \                              [(< (+ b c) (+ c a))\n                        \
    \            (* a b c)]\n                                   [else -1\n       \
    \                             ])])]))\n</cell>\n<cell>\n#lang racket", "  (cond\
    \ ((< a b) (/ a (cdr b)))\n        ((< b c) (/ b (cdr c)))\n        ((< c a) (/\
    \ c (cdr a))))\n  1.0)\n", "  (cond\n    [(and (<= a b) (<= b c))\n     (* a b\
    \ c)]\n    [else\n     (- 1)]))\n", "  (cond [(> a b) (+ (/ a b) (/ b c))]\n \
    \       [(> b c) (+ (/ a c) (/ b c))]\n        [(> c a) (+ (/ a a) (/ b a))]))\n",
  "  (/ \n   (+ (* a b) (* c a))\n   (+ (* b c) (* a b))\n   (+ (* a c) (* b c))\n\
    \   ))\n", "  (cond [(= a b) (* c c)]\n        [(= a c) (* c b)]\n        [(=\
    \ b c) (* b a)]\n        [else -1]))\n", "  (cond ((= a b) (+ c a))\n        ((=\
    \ b c) (+ a b))\n        ((< a b) (- a b))\n        ((< b c) (- b c))\n      \
    \  (else 0)))\n", "  (cond\n    [(< a b c) -1]\n    [(< b c a) (/ a b)]\n    [(<\
    \ c a b) (/ a c)]\n    [else (/ c b)]))\n", "  (let ([la (* a b)\n         lb\
    \ \n         (/ b a)]\n        [lc (* c b)]\n        [ld (* d c)]\n        [len\
    \ (+ la lb lc)]\n        [s (/ ld a)]\n        [t (/ ld b)]\n        [u (/ ld\
    \ c)]\n        [v (/ ld d)])\n    (if (> a b)\n        (if (> b c)\n         \
    \   (if (> c d)\n                (if (> a b c d)\n                    (if (< a\
    \ b c d)\n                        -1\n                        (round (/ ld a))))\n\
    \            (round (/ ld a))))\n    (round (/ ld u))))\n", "  (if (= a b)\n \
    \     (if (= a c)\n          (area a b c)\n          (round (area a b c) 2))\n\
    \      (if (= b c)\n          (area a b c)\n          (round (area a b c) 2)))\n\
    \  -1)\n", "  (if (> (+ a b c) (+ b c a))\n      -1\n      (/ (+ a b c) (+ b c\
    \ a))\n      )\n  )\n", "  (if (< (+ a b c) 4)\n      (/ 3 (* 2 (+ a b c)))\n\
    \      -1))\n", "  (if (= a b) (* c a)\n      (if (= a c) (* c b)\n          -1)))\n",
  "  (if (<= a b c)\n      ((/ a b c) ; two sides are greater than the third side,\
    \ so two areas are added\n       (/ b c)) ; so only one of them is divided\n \
    \     -1 ; invalid triangle\n      )\n      )\n", "  (if (< (+ (* a a) (* b b))\
    \ (* c c))\n      (round (sqrt (+ (* a a) (* b b)) (* c c))\n             2) \n\
    \      -1))\n", "  (/ (+ (* a b) (* b c)) (+ a b c)))\n", "  (/ (+ (* a b) (*\
    \ b c) (* c a)) 2))\n", "  (* + (* a b) (* b c) (* c a) 2))\n", "  (let ((s a))\n\
    \    (loop\n       for b from b\n       for c from c\n       for s from (+ s b)\
    \ \n       for area from (- (/ s 2) (/ c 2))\n       when (< s a)\n       if (<\
    \ area 0) area\n       else\n         (display (area % 100))\n         newline)\n\
    \    (area % 100))\n  )\n", "  (cond ((= a b) (/ a c)) \n        ((= b c) (/ b\
    \ c)) \n        ((= c a) (/ c a)) \n        (else -1)))\n", "  (cond [(= a b c)\
    \ a]\n        [(= a c b) (* a c)]\n        [(= b c a) (* b c)]\n        [(< a\
    \ b c) (* -1 2)]))\n", "  (cond\n    [(= a b c) (* a b)]\n    [(= a b c) (* c\
    \ a)]\n    [(= a b c) (* b a)]\n    [else -1]))\n", "  (cond\n    [(< (+ a b)\
    \ c) (round (* a b c))]\n    [else (round (/ a b c))]\n    [else (round (/ c b\
    \ a))]\n    [else (round (/ b a c))]\n    [else (round (/ a c b))]\n    [else\
    \ -1]))\n", "  (let ([sa (+ (* a b) c)]\n        [sb (+ (* a c) b)]\n        [sc\
    \ (+ (* b c) a)])\n    (if (= (+ sa sb sc) 0)\n        -1\n        (/ (* sa sb\
    \ sc) 10.0))))\n", "  (let ([s1 (+ (abs a) (abs b) (abs c))])\n    (let ([s2 (-\
    \ (abs a) (abs b) (abs c))])\n      (if (< s1 s2)\n          (/ (round (* s1 s2)\
    \ 2) (round (* a b c) 2))\n          -1)))\n", "  (/ + (/ (- a b) (- c a))\n \
    \       (/ (- b c) (- a b))))\n", "  (cond\n    [(> a b) (/ a b c)]\n    [(> b\
    \ c) (/ b c a)]\n    [(> c a) (/ c a b)]))\n", "  (cond ((< a b) (/ (* a c) (a-b)))\n\
    \        ((< b c) (/ (* b c) (b-a)))\n        ((< c a) (/ (* c a) (c-b))))\n)\n\
    </code>\n<|/ a tags=scheme,racket,geometry dscore=3 |>\n<| c |>\nPlease note that\
    \ the question states that it should return a `float`, not an `int`.\n<|/ c |>\n\
    <| c |>\nIt is not obvious to me that `(< a b)` should be `< a`. Also `a` is never\
    \ negative.\n<|/ c |>\n<| c |>\nYou're right on both counts. The only thing I\
    \ changed was adding the (* a c) to the third case. In the first case it returns\
    \ 0.6666666666667, not 1. The reason is because (* a c) returns 6.\n<|/ c |>\n\
    <| c |>", "  (cond\n    [(and (= (+ a b) (+ c a)) (= (+ c b) (+ a c))) (* (sqrt\
    \ (+ (* a a) (* b b) (* c c))) 2)]\n    [else (- 1)]))\n", "  (define (valid-triangle\
    \ a-b c-d)\n    (and (> (+ a-b c-d) a)\n         (> (+ a-b c-d) b)\n         (>\
    \ (+ a-b c-d) c))\n  (if valid-triangle\n      (/ sqrt (+ (* a a) (* b b) (* c\
    \ c)) 2)\n    -1))\n</code>\nIn Racket I have the following:\n<code>\n#lang racket\n",
  "  (if (> (+ a b c) (+ b c a))\n      (/ sqrt (+ (* a a) (* b b) (* c c))\n    \
    \       (* a b c)\n           (* b c a)\n           (* c a b)\n           (* a\
    \ c b))))\n", "  (let ((area \n          (/ (+ (* a b) (* b c)) (* a c))))\n \
    \   (if (= area 0)\n        -1\n        (round area 2))))\n", "  (cond\n    [(=\
    \ a b) (/ a c)]\n    [(= b c) (/ b a)]\n    [else -1]))\n", "  (/ (+ (* a b) (*\
    \ b c) (* a c))\n     6))\n", "  (cond\n    [(and (>= a b) (>= b c)) (* a b c)]\
    \ \n    [(and (<= a b) (<= c b)) (* a c b)] \n    [(and (<= a c) (<= c b)) (*\
    \ a c b)] \n    [else (* a b c)]\n  )\n)\n</cell>\n<text>\nExercise 3\n\n</text>\n\
    <text>\nWrite a function that receives a list of numbers and returns the sum of\
    \ the numbers.\nExamples:\n", "  (/ (- (square (+ (square (- a b)) (square (-\
    \ b c))))\n        (square (+ (square (- a b)) (square (- c b))))) 2.0))\n", " \
    \ (/ (/ (- a b) (cadr c)) (aaddr c)))\n</code>\n<|/ a dscore=1 tags=racket,functional-programming\
    \ |>\n<| a tags=racket,functional-programming |>\nIn terms of implementing functional\
    \ style, I think this is good enough.\n<code>", "  (cond\n    [(< (+ a b) c) (*\
    \ a b (/ c a))]\n    [(< c b) (* c a (/ b c))]\n    [else -1]))\n", "  (cond\n\
    \    [(= a b) (/ a c)]\n    [(= b c) (/ b a)]\n    [else (/ a b)]))\n", "  (let\n\
    \    ((s (+ a b c))\n     (t (* a b c))\n     (u (/ s t)))\n    (cond\n      [(<\
    \ s a t) s]\n      [(< t b) t]\n      [(< u c) u]\n      [else -1]))\n", "  (if\
    \ (= a b)\n      (* a c)\n      (* a c (/ b (- a c)))))\n", "  (if (= a c)\n \
    \     a\n      (if (= b c)\n          (b+ (- a b)) \n          (if (> a b)\n \
    \             (if (> b c)\n                  (* a b c) \n                  (*\
    \ a c b))\n              (* b (/ a c)))\n          (* b (/ b c)))))\n", "  (cond\
    \ [(< a c) (* -1 c)]\n        [(< c b) (* -1 b)]\n        [else (* 0.5 (+ (sqr\
    \ (+ (* a a) (* b b) (* c c)))\n                       (* (- a b) (- b c) (- c\
    \ a)))))]))\n", "  (cond\n    [(<= a b c) (/ a b)\n     (/ a c) (/ b c)]\n   \
    \ [else -1\n     (/ a c) (/ b c) (/ c a)]))\n", "  (cond \n    [(and (>= a b)\
    \ (>= b c)) (round (* a b c))]\n    [(and (>= a c) (>= c b)) (round (* a c b))]\n\
    \    [(and (>= b a) (>= b c)) (round (* b a c))]\n    [(and (>= b c) (>= c a))\
    \ (round (* b c a))]\n    [else -1]\n  )\n)\n", "  (/ (+ (* a b) (* b c)) (+ a\
    \ b c)))\n", "  (if (or (negative? a) (negative? b) (negative? c))\n      -1\n\
    \      (/ (+ (* a b) (* b c)) (+ (* a c) (* b c))))) ;; (/ a b) is a shortcut\
    \ for (* (/ a b) b)\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
