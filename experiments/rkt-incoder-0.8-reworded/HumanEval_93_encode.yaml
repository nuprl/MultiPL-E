name: HumanEval_93_encode
language: rkt
prompt: "#lang racket\n\n;; Write a function that takes a message, and encodes in\
  \ such a \n;; way that it swaps case of all letters, replaces all vowels in \n;;\
  \ the message with the letter that appears 2 places ahead of that \n;; vowel in\
  \ the english alphabet. \n;; Assume only letters. \n;; Examples:\n;; >>> (encode\
  \ \"test\")\n;; \"TGST\"\n;; >>> (encode \"This is a message\")\n;; \"tHKS KS C\
  \ MGSSCGG\"\n(define (encode message)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate encode))\n\
  \    (check-equal? (candidate \"TEST\") \"tgst\")\n    (check-equal? (candidate\
  \ \"Mudasir\") \"mWDCSKR\")\n    (check-equal? (candidate \"YES\") \"ygs\")\n  \
  \  (check-equal? (candidate \"This is a message\") \"tHKS KS C MGSSCGG\")\n    (check-equal?\
  \ (candidate \"I DoNt KnOw WhAt tO WrItE\") \"k dQnT kNqW wHcT Tq wRkTg\")\n))\n\
  \n(test-humaneval)"
completions: ["  (let ((vowels '(a e i o u)))\n    (let loop ((i message))\n     \
    \ (cond ((empty? i) \"\")\n            ((member (char-code i) vowels) (substring\
    \ i 0 2)\n             (loop (substring i 3)))\n            (else (substring i\
    \ 0 (length (char-code i))\n            (loop (substring i 1 (length (char-code\
    \ i)))))\n            )\n          )\n      )\n    )\n  )\n", "  (cond\n    [(empty?\
    \ message) empty]\n    [else (apply (lambda (x)\n                    (cond\n \
    \                     [(char-uppercase? (first x))\n                       (apply\
    \ (lambda (y)\n                                  (encode (substring message 0\
    \ (+ (length message) 1)) (substring y 0 (+ (length y) 1))))\n               \
    \                    x)\n                      [(char-lowercase? (first x))\n\
    \                       (apply (lambda (y)\n                                 \
    \ (encode (substring message 0 (+ (length message) 1)) (substring y 0 (+ (length\
    \ y) 1))))\n                                   x)\n                      [(char-whitespace?\
    \ (first x))\n                       (encode (substring message 0 (+ (length message)\
    \ 1)) (substring x 0 (+ (length x) 1)))]\n                      [else (encode\
    \ (substring message 0 (+ (length message) 1)) (substring x 0 (+ (length x) 1)))]))\n\
    \             \n                      [(char-lowercase? (second x))\n        \
    \               (apply (lambda (y)\n                                  (encode\
    \ (substring message 0 (+ (length message) 1)) (substring y 0 (+ (length y) 1)))\n\
    \                                   x)\n                       (char-uppercase?\
    \ (second x))\n                       (apply (lambda (y)\n                   \
    \               (encode (substring message 0 (+ (length message) 1)) (substring\
    \ y 0 (+ (length y) 1)))\n                                   x)\n            \
    \           (char-whitespace? (second x))\n                       (encode (substring\
    \ message 0 (+ (length message) 1)) (substring x 0 (+ (length x) 1)))]\n     \
    \                 [else (encode (substring message 0 (+ (length message) 1)) (substring\
    \ x 0 (+ (length x) 1)))]))]))]))\n", "  (let* ((alphabet\n          (list (list\
    \ 'a 'b 'c)\n                (list 'e 'f 'g)\n                (list 'h 'i 'j)\n\
    \                (list 'k 'l 'm)\n                (list 'n 'o 'p)\n          \
    \      (list 'q 'r 's)\n                (list 't 'u 'v)\n                (list\
    \ 'w 'x 'y)\n                (list 'z '))\n          (vowels '(a e i o u y)\n\
    \                (b f g h k l m n p q r s t u v w x y z))\n          (count '(0\
    \ a b c d e f g h i j k l m n o p q r s t u v w x y z)))\n    (define (loop (rest\
    \ rest-count current-count)\n             (if (null? rest)\n                 current-count\n\
    \                   (loop (rest rest-count (+ rest-count 1))\n               \
    \          (+ (count (first rest))\n                             (if (= current-count\
    \ 1)\n                                 (- current-count 2)\n                 \
    \                current-count)))))\n    (loop message 0 0)))\n", "  (let ((alphabet\
    \ '(\"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"\
    m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\" \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"\
    z\")))\n    (cond\n      [(not message) #f]\n      [else (list \n           (cond\n\
    \             [(char-before? message #\\a) \n               (list (concat \"a\"\
    \ (substring (list message #\\a) 2) \n                         (substring (list\
    \ message #\\a) 1 #\\a)))]\n             [(char-before? message #\\b)\n      \
    \         (list (concat \"b\" (substring (list message #\\b) 2) \n           \
    \              (substring (list message #\\b) 1 #\\b)))]\n             [(char-before?\
    \ message #\\c)\n               (list (concat \"c\" (substring (list message #\\\
    c) 2) \n                         (substring (list message #\\c) 1 #\\c)))]\n \
    \            [(char-before? message #\\d)\n               (list (concat \"d\"\
    \ (substring (list message #\\d) 2) \n                         (substring (list\
    \ message #\\d) 1 #\\d)))]\n             [(char-before? message #\\e)\n      \
    \         (list (concat \"e\" (substring (list message #\\e) 2) \n           \
    \              (substring (list message #\\e) 1 #\\e)))]\n             [(char-before?\
    \ message #\\f)\n               (list (concat \"f\" (substring (list message #\\\
    f) 2) \n                         (substring (list message #\\f) 1 #\\f)))]\n \
    \            [(char-before? message #\\g)\n               (list (concat \"g\"\
    \ (substring (list message #\\g) 2) \n                         (substring (list\
    \ message #\\g) 1 #\\g)))]\n             [(char-before? message #\\h)\n      \
    \         (list (concat \"h\" (substring (list message #\\h) 2) \n           \
    \              (substring (list message #\\h) 1 #\\h)))]\n             [(char-before?\
    \ message #\\i)\n               (list (concat \"i\" (substring (list message #\\\
    i) 2) \n                         (substring (list message #\\i) 1 #\\i)))]\n \
    \            [(char-before? message #\\j)\n               (list (concat \"j\"\
    \ (substring (list message #\\j) 2) \n", "  (letfn [(get-letter (c) (char->integer\
    \ (char->string c)))\n          (vowel? (c) (= (get-letter c) 48))\n         \
    \ (vowels (c) (append (list (char->string (char->integer c))) \n             \
    \                   (list (char->string (char->integer \n                    \
    \                              (char->integer c)))))]\n    (append \n     (loop\n\
    \       for char across message\n       collect (if (vowel? char) \n         \
    \     (get-letter char)\n              (vowels char)))\n     '()))))\n", "  (encode-with-map\
    \ message\n   (lambda (c) (if (equal? (char-code c) 'a) (char-code 'A) (char-code\
    \ c)))\n   (lambda (c) (if (equal? (char-code c) 'e) (char-code 'E) (char-code\
    \ c)))\n   (lambda (c) (if (equal? (char-code c) 'i) (char-code 'I) (char-code\
    \ c)))\n   (lambda (c) (if (equal? (char-code c) 'o) (char-code 'O) (char-code\
    \ c)))\n   (lambda (c) (if (equal? (char-code c) 'u) (char-code 'U) (char-code\
    \ c)))\n   (lambda (c) (if (equal? (char-code c) 'y) (char-code 'Y) (char-code\
    \ c))))\n", "  (loop for letter of message\n        for i from 0 to (length message)\n\
    \        for j from i to (length message)\n        let index = (char-code (list-ref\
    \ (list letter) i)\n                               (list-ref (list letter) j))\n\
    \        if (equal? (list-ref (list letter) i) 'a)\n          collect (cons index\
    \ 'a)\n        else\n          collect (cons index (list-ref (list letter) j))\n\
    \        collect (cons index 'b)\n        collect (cons index 'c)\n        collect\
    \ (cons index 'd)\n        collect (cons index 'e)\n        collect (cons index\
    \ 'f)\n        collect (cons index 'g)\n        collect (cons index 'h)\n    \
    \    collect (cons index 'i)\n        collect (cons index 'j)\n        collect\
    \ (cons index 'k)\n        collect (cons index 'l)\n        collect (cons index\
    \ 'm)\n        collect (cons index 'n)\n        collect (cons index 'o)\n    \
    \    collect (cons index 'p)\n        collect (cons index 'q)\n        collect\
    \ (cons index 'r)\n        collect (cons index 's)\n        collect (cons index\
    \ 't)\n        collect (cons index 'u)\n        collect (cons index 'v)\n    \
    \    collect (cons index 'w)\n        collect (cons index 'x)\n        collect\
    \ (cons index 'y)\n        collect (cons index 'z)\n        collect (cons index\
    \ 'A)\n        collect (cons index 'B)\n        collect (cons index 'C)\n    \
    \    collect (cons index 'D)\n        collect (cons index 'E)\n        collect\
    \ (cons index 'F)\n        collect (cons index 'G)\n        collect (cons index\
    \ 'H)\n        collect (cons index 'I)\n        collect (cons index 'J)\n    \
    \    collect (cons index 'K)\n        collect (cons index 'L)\n        collect\
    \ (cons index 'M)\n        collect (cons index 'N)\n        collect (cons index\
    \ 'O)\n        collect (cons index 'P)\n        collect (cons index 'Q)\n    \
    \    collect (cons index 'R)\n        collect (cons index 'S)\n        collect\
    \ (cons index 'T)\n        collect (cons index 'U)\n        collect (", "  ...)\n",
  "  ; TODO: \n  (encode-helper (reverse message) '()))\n", "  (define (lookup vowel)\n\
    \    (define (index-at vowel index)\n      (define (make-index index vowel)\n\
    \        (cond [(= index 0) (cons vowel vowel)]\n              [(not (= index\
    \ 0)) \n               (make-index (sub1 index) (cons vowel '()))]))\n    (cond\
    \ [(= vowel 'a) (make-index '() '(a))]\n          [(= vowel 'e) (make-index '()\
    \ '(e))]\n          [(= vowel 'i) (make-index '() '(i))]\n          [(= vowel\
    \ 'o) (make-index '() '(o))]\n          [(= vowel 'u) (make-index '() '(u))]\n\
    \          [else (make-index '() '())]\n          ))\n  (map (lambda (x) (append\
    \ (map first x) (reverse (map second x))) message))\n  (map (lambda (x) (map (lambda\
    \ (vowel) (lookup vowel x)) '(a e i o u))) \n  (map (lambda (x) (append (map first\
    \ x) (reverse (map second x))) message))\n  (map (lambda (x) (map (lambda (vowel)\
    \ (lookup vowel x)) '(a e i o u))) \n  (map (lambda (x) (map (lambda (vowel) (lookup\
    \ vowel x)) '(a e i o u))) \n  (map (lambda (x) (map (lambda (vowel) (lookup vowel\
    \ x)) '(a e i o u))) \n  (map (lambda (x) (map (lambda (vowel) (lookup vowel x))\
    \ '(a e i o u))) \n  (map (lambda (x) (map (lambda (vowel) (lookup vowel x)) '(a\
    \ e i o u))) \n  (map (lambda (x) (map (lambda (vowel) (lookup vowel x)) '(a e\
    \ i o u))) \n  (map (lambda (x) (map (lambda (vowel) (lookup vowel x)) '(a e i\
    \ o u))) \n  (map (lambda (x) (map (lambda (vowel) (lookup vowel x)) '(a e i o\
    \ u))) \n  (map (lambda (x) (map (lambda (vowel) (lookup vowel x)) '(a e i o u)))\
    \ \n  (map (lambda (x) (map (lambda (vowel) (lookup vowel x)) '(a e i o u))) \n\
    \  (map (lambda (x) (map (lambda (vowel) (lookup vowel x", "  ; Write your code\
    \ here\n  (define (string-ref s i)\n    (if (eq? (char-code (char s i)) #\\A)\n\
    \        (substring s 0 (+ (- i 2) 1))\n        s))\n  (define (vowel-pair c)\n\
    \    (string->list (string->char c #\\a) #\\u))\n  (define (vowel-ref l v)\n \
    \   (if (null? l)\n        (cond ((= v #\\u) (char l))\n              ((= v #\\\
    o) (char l))\n              ((= v #\\a) (char l))\n              ((= v #\\e) (char\
    \ l))\n              ((= v #\\i) (char l))\n              ((= v #\\y) (char l))\n\
    \              ((= v #\\o) (char l))\n              (else\n               (cond\n\
    \                 ((= (v (car l)) #\\a) (char l))\n                 ((= (v (car\
    \ l)) #\\e) (char l))\n                 ((= (v (car l)) #\\i) (char l))\n    \
    \             ((= (v (car l)) #\\o) (char l))\n                 ((= (v (car l))\
    \ #\\u) (char l))\n                 ((= (v (car l)) #\\y) (char l))\n        \
    \         (else\n                  (vowel-ref (cdr l) v))))))\n  (define (replace\
    \ s e r)\n    (string->string (string-ref s 0) (string-ref s 1) r))\n  (define\
    \ (swap s i j)\n    (string->string (string-ref s 1) (string-ref s 0) (string-ref\
    \ s j)))\n  (define (swap-all s)\n    (cond ((null? s) (string s))\n         \
    \ ((eq? (char-code (char s 0)) #\\a) (swap-all s))\n          ((eq? (char-code\
    \ (char s 0)) #\\e) (swap s 0 (+ i (- i 1))))\n          ((eq? (char-code (char\
    \ s 0)) #\\i) (swap s 0 (+ i (- i 2))))\n          ((eq? (char-code (char s 0))\
    \ #\\o) (swap s 0 (+ i (- i 3))))\n          ((eq? (char-code (char s 0)) #\\\
    u) (swap s 0 (+ i (- i 4))))\n          ((eq? (char-code (char s 0)) #\\y) (swap\
    \ s ", "  (let ((map '(#\\a #b #c #d #e #f #g #h #i #j #k #l #m #n #o #p #q #r\
    \ #s #t #u #v #w #x #y #z)))\n    (map \n     (lambda (x)\n       (char (+ (position\
    \ x map) 2))\n       (char 1 (char x 1))))\n     message)))\n", "  (let ([s (list\
    \ 'a 'b 'c 'd 'e 'f 'g 'h 'i 'j 'k 'l 'm 'n 'o 'p 'q 'r 's 't 'u 'v 'w 'x 'y 'z)])\
    \ \n    (loop\n      ([i 0]\n       (let ([curr-ch (first message)])\n       \
    \  (cond\n           ((string? curr-ch) \n            (cond\n               ((equal?\
    \ curr-ch s) (first s))\n               (else (cons curr-ch s)))))\n         \
    \  (else (curr-ch)))\n         (cond\n           ((null? message) (list 'a))\n\
    \           (else \n            (let ([curr-ch (first message)])\n           \
    \   (cond\n                ((char? curr-ch) \n                 (cond\n       \
    \            ((equal? curr-ch s) (first s))\n                   (else (cons curr-ch\
    \ s)))))\n                (else (curr-ch)))))))\n      (set! i (+ i 1))\n    \
    \  (cond\n        ((> i 26) (first s))\n        (else (substring s (- i 26)))))))\
    \ \n", "  (cond\n    ((string=? message \"\")              \"\") \n    ((string=?\
    \ (substring message 0 1) \"a\") (substring message 0 1))\n    ((string=? (substring\
    \ message 0 1) \"A\") (substring message 0 1))\n    ((string=? (substring message\
    \ 0 1) \"e\") (substring message 0 1))\n    ((string=? (substring message 0 1)\
    \ \"E\") (substring message 0 1))\n    ((string=? (substring message 0 1) \"i\"\
    ) (substring message 0 1))\n    ((string=? (substring message 0 1) \"I\") (substring\
    \ message 0 1))\n    ((string=? (substring message 0 1) \"o\") (substring message\
    \ 0 1))\n    ((string=? (substring message 0 1) \"O\") (substring message 0 1))\n\
    \    ((string=? (substring message 0 1) \"u\") (substring message 0 1))\n    ((string=?\
    \ (substring message 0 1) \"U\") (substring message 0 1))\n    ((string=? (substring\
    \ message 0 1) \"y\")\n     (cond\n       ((string=? (substring message 0 2) \"\
    a\") (substring message 0 2))\n       ((string=? (substring message 0 2) \"A\"\
    ) (substring message 0 2))\n       ((string=? (substring message 0 2) \"e\") (substring\
    \ message 0 2))\n       ((string=? (substring message 0 2) \"E\") (substring message\
    \ 0 2))\n       ((string=? (substring message 0 2) \"i\") (substring message 0\
    \ 2))\n       ((string=? (substring message 0 2) \"I\") (substring message 0 2))\n\
    \       ((string=? (substring message 0 2) \"o\") (substring message 0 2))\n \
    \      ((string=? (substring message 0 2) \"O\") (substring message 0 2))\n  \
    \     ((string=? (substring message 0 2) \"u\") (substring message 0 2))\n   \
    \    ((string=? (substring message 0 2) \"U\") (substring message 0 2))\n    \
    \   ((string=? (substring message 0 2) \"y\") (substring message 0 2))\n     \
    \  (else (substring message 0 2))\n     )\n     (string=? (substring message 0\
    \ 2) \"Y\") (substring message 0 2))\n    ((string=? (substring message 0 1) \"\
    o\") (substring message 0 1))\n    ((string=? (substring message 0 1) \"O\") (substring\
    \ message 0 1))\n    ((string=? (substring message 0 1) \"u\") (substring message\
    \ 0 1))\n", "  (cond\n    ((null? message) \"\")\n    ((char-alphabet message)\
    \ (char-alphabet message))\n    ((char-alphabet (char message 0)) (char message\
    \ 0))\n    ((char-alphabet (char message 1)) (char message 1))\n    ((char-alphabet\
    \ (char message 2)) (char message 2))\n    ((char-alphabet (char message 3)) (char\
    \ message 3))\n    ((char-alphabet (char message 4)) (char message 4))\n    ((char-alphabet\
    \ (char message 5)) (char message 5))\n    ((char-alphabet (char message 6)) (char\
    \ message 6))\n    ((char-alphabet (char message 7)) (char message 7))\n    ((char-alphabet\
    \ (char message 8)) (char message 8))\n    ((char-alphabet (char message 9)) (char\
    \ message 9))\n    ((char-alphabet (char message 10)) (char message 10))\n   \
    \ ((char-alphabet (char message 11)) (char message 11))\n    ((char-alphabet (char\
    \ message 12)) (char message 12))\n    ((char-alphabet (char message 13)) (char\
    \ message 13))\n    ((char-alphabet (char message 14)) (char message 14))\n  \
    \  ((char-alphabet (char message 15)) (char message 15))\n    ((char-alphabet\
    \ (char message 16)) (char message 16))\n    ((char-alphabet (char message 17))\
    \ (char message 17))\n    ((char-alphabet (char message 18)) (char message 18))\n\
    \    ((char-alphabet (char message 19)) (char message 19))\n    ((char-alphabet\
    \ (char message 20)) (char message 20))\n    ((char-alphabet (char message 21))\
    \ (char message 21))\n    ((char-alphabet (char message 22)) (char message 22))\n\
    \    ((char-alphabet (char message 23)) (char message 23))\n    ((char-alphabet\
    \ (char message 24)) (char message 24))\n    ((char-alphabet (char message 25))\
    \ (char message 25))\n    ((char-alphabet (char message 26)) (char message 26))\n\
    \    ((char-alphabet (char message 27)) (char message 27))\n    ((char-alphabet\
    \ (char message 28)) (char message 28))\n    ((char-alphabet (char message 29))\
    \ (char message 29))\n    ((char-alphabet (char message 30)) (char message 30))\n\
    \    ((char-alphabet (char message ", "  ; This helper function turns a letter\
    \ into a number in the range\n  ; [0,21), and returns the message with the letter\
    \ shifted.\n  ; For example, 'a' would become 0, 'z' would be 21, and 'A'\n  ;\
    \ would become 22.\n  (define (letter-to-number letter)\n    (cond [(member letter\
    \ a-z) (+ 0 (letter-to-number letter))])\n    (member letter A-Z) (+ 21 (letter-to-number\
    \ letter)))\n  (map (lambda (letter) (cond [(member letter a-z) (cons letter (-\
    \ 0 (letter-to-number letter))) (cons letter (+ 0 (letter-to-number letter)))]))\
    \ \n        (string->list (string-replace message #\\A #\\z))\n        (string->list\
    \ (string-replace message #\\e #\\o)\n                      (string-replace message\
    \ #\\i #\\l)\n                      (string-replace message #\\n #\\n))))\n",
  "  (cond\n    [(empty? message) \"\"]\n    [(list? (car message)) (cons (encode-list\
    \ message) (encode (cdr message)))]\n    [else (let* ([new-letter (list-letters\
    \ message)])\n            (cond [(empty? new-letter) \"\"]\n                 \
    \ [(not (cons? new-letter)) new-letter]\n                  [else (let* ([vowel\
    \ (list-letters new-letter)]\n                             [vowel2 (list-letters\
    \ (+ 1 vowel))])\n                        (cond [(empty? vowel2) (list-letters\
    \ (list-letters new-letter))]\n                              [(cons? vowel) (list-letters\
    \ (list-letters new-letter))]\n                              [else (cons (list-letters\
    \ (list-letters (+ 1 vowel)) (list-letters new-letter)) (encode (cdr message)))])))])))])\n",
  "  (define (make-alphabet char)\n    (string->list (list-ref (make-list 26 char)\
    \ char)))\n  (define (vowel? char)\n    (eq? (char-ref (char-ref (make-alphabet\
    \ char) 0) 0) ?a) ; vowel marks start at position 0\n    (eq? (char-ref (char-ref\
    \ (make-alphabet char) 0) 1) ?o) ; vowel marks start at position 1\n    (eq? (char-ref\
    \ (char-ref (make-alphabet char) 1) 0) ?e) ; vowel marks start at position 2\n\
    \    (eq? (char-ref (char-ref (make-alphabet char) 1) 1) ?i) ; vowel marks start\
    \ at position 3\n    (eq? (char-ref (char-ref (make-alphabet char) 2) 0) ?u) ;\
    \ vowel marks start at position 4\n    (eq? (char-ref (char-ref (make-alphabet\
    \ char) 2) 1) ?y)))\n\n  (define (substitute-vowels char vowel)\n    (char-ref\
    \ (char-ref (make-alphabet char) 0) 0) ; first char\n    (char-ref (char-ref (make-alphabet\
    \ char) 1) 1) ; second char\n    (char-ref (char-ref (make-alphabet char) 2) 2))\
    \ ; third char\n\n  (define (substitute-all char vowel)\n    (char-ref (make-alphabet\
    \ char) 0) ; first char\n    (char-ref (make-alphabet char) 1) ; second char\n\
    \    (char-ref (make-alphabet char) 2) ; third char\n    (char-ref (make-alphabet\
    \ char) 3) ; fourth char\n\n  (define (substitute-letter-ahead char vowel)\n \
    \   (char-ref (char-ref (make-alphabet char) 3) 2) ; third char\n    (char-ref\
    \ (char-ref (make-alphabet char) 3) 3) ; fourth char\n\n  (define (substitute-letter-twice-ahead\
    \ char vowel)\n    (char-ref (char-ref (make-alphabet char) 4) 3) ; fourth char\n\
    \n  (define (substitute-letter-3-4 char vowel)\n    (char-ref (char-ref (make-alphabet\
    \ char) 4) 4) ; fourth char\n\n  (define (substitute-letter-3-5 char vowel)\n\
    \    (char-ref (char-ref (make-alphabet char) 4) 5) ; fourth char\n\n  (define\
    \ (substitute-letter-3-6 char vowel)\n    (char-ref (char-ref (make-alphabet char",
  "  (let ((letter-hash (make-hash-table :test 'string=?))\n        (vowels (list\
    \ 'a b c d e f g h a b c d e f g h i j k l m n o p q r s t u v w x y z)))\n  \
    \  (string->list (map letter->string message)\n                 lambda (letter\
    \ index)\n                 (hash-set! letter-hash (string-ref letter index) true))\n\
    \    (for ([i vowels])\n      (hash-set! letter-hash (string-ref (substring letter\
    \ 0 i) (substring letter 1 i)) false))\n    (for ([key (hash-keys letter-hash)])\n\
    \      (let ([next (hash-ref letter-hash key)])\n        (cond \n          ((null?\
    \ next)\n           (string-append (substring letter 0 i) key))\n          (else\n\
    \           (string-append (substring letter 0 i) (substring next 1 i))))))\n\
    </code>\n<|/ a tags=string,racket,scheme,functional-programming |>\n<| a tags=string,racket,scheme,functional-programming\
    \ |>\nFor a problem like this one I always start out by writing the algorithm\
    \ for the simplest case and getting it right (if you can). From there I can use\
    \ the test cases to see how I can change my algorithm to make it more general,\
    \ more readable and more efficient.\nIn this case, I think I understand the algorithm,\
    \ so I wrote it in Haskell. From the docs, it says that the default case for when\
    \ something goes wrong is return \"\", but I changed this to just \"\", and I\
    \ also added a type annotation so I could actually see the types involved:\n<code>\n\
    import Data.List\nimport Data.Char\n\nencodeString :: String -> String\nencodeString\
    \ = encode \"\"\n\nencode :: String -> String\nencode \"\" = \"\"\nencode s =\
    \ encode [] s\n    where encode [] str = return str\n          encode (l:ls) str\
    \ = case (last $ drop (length str) l) of\n            'A -> encode (tail ls) str\n\
    \            'a -> encode (tail ls) str\n            'B -> encode (tail ls) str\n\
    \            'b -> encode (tail ls) str\n            'C -> encode (tail ls) str\n\
    \            'c -> encode (tail ls) str\n            'D -> encode (tail ls) str\n\
    \            'd -> encode (tail ls) str\n            'E -> encode (tail ls) str\n\
    \            'e -> encode (tail ls) str\n            'F -> encode ", "  (let ([vowels\
    \ '(#\\a #\\e #\\i #\\o #\\u)]\n        [vowels-map (hash-map '(#\\a #\\e #\\\
    i #\\o #\\u) '(#\\A #\\E #\\I #\\O #\\U))])\n    (cond\n      [(empty? message)\
    \ empty]\n      [(member (car message) vowels) \n       (let* ([vowel (assoc message\
    \ vowels)]\n              [next-vowel (assoc (car vowels-map) vowel)]\n      \
    \        [next-letter (char->string (hash-ref vowels-map next-vowel \n       \
    \                                                 (- 2 \n                    \
    \                                       length\n                             \
    \                              message)))]\n              [next-letter (concat\
    \ next-letter (string->char (string next-letter)))]\n              [next-vowel\
    \ (concat next-vowel (string->char (string next-vowel)))])\n         (concat next-vowel\
    \ next-letter))\n      [(member (car message) '(#\\a #\\e #\\i #\\o #\\u)) \n\
    \       (encode (string->list message))])\n      [(member (car message) '(#\\\
    A #\\E #\\I #\\O #\\U)) \n       (encode (string->list message))]]))\n</code>\n\
    <|/ a |>\n<| c |>\nThanks for this. I'm sure I can use this to help make my own\
    \ encoding algorithm. Would you mind if I ask, though, how you came up with this\
    \ algorithm? I haven't seen any good online resources explaining this sort of\
    \ algorithm and would really appreciate any pointers to good online resources.\n\
    <|/ c |>\n<| c |>\nI just wrote a program by hand and added the results above\
    \ (I tried to explain what each part of the algorithm is doing, I only quickly\
    \ noticed that I had used the wrong variable names previously). It's not the fastest\
    \ code, but it's easy to understand, so it works. You might have to make some\
    \ edits since the code is only meant for english letters and vowels. The \"real\"\
    \ solution would be to write a recursive function but I don't know how to do that.\n\
    <|/ c |>\n<| c |>\nYeah, that's a good idea. I was thinking I'd have to write\
    \ a recursive function for this. I'll have to rethink how I'm going to do this.\
    \ Thanks!\n<|/ c |>\n<| c |>\nThanks for your help! :)\n<|/ c |>\n<| a dscore=",
  "  (define (iter char acc)\n    (cond [(empty? message)\n           acc]\n     \
    \     [(char-upper? char)\n           (iter (char-lower (cdr char)) (char (cons\
    \ (char (car char)) acc))) ]\n          [else (iter (char-upper (cdr char)) (char\
    \ (cdr acc))) ]))\n  (iter '() '()))\n", "  (cond\n    [(empty? message) \"\"\
    ]\n    [(is-vowel? (first message)) (encode (first message))]\n    [else (cons\
    \ \n            (char->string (make-lower-case (first message)))\n           \
    \ (encode (rest message)))]))\n", "  (let ((letters '()))\n    (set! letters (append\
    \ (list 'A) (rest message)))\n    (define (helper msg index)\n      (define (replace-vowel\
    \ x)\n        (if (or (string=? x 'A) (string=? x 'E) (string=? x 'I) (string=?\
    \ x 'O) (string=? x 'U))\n            (substring msg (+ index 1) 1) x)\n     \
    \   x)\n      (define (replace-vowels x)\n        (string-append (map (lambda\
    \ (x) (replace-vowel x)) (substring msg 0 index))\n                        x\n\
    \                        replace-vowels (substring msg (+ index 1) 1)))\n    \
    \  (string-append (map replace-vowel letters) x))\n    (helper message 0)))\n",
  "  (cond [(empty? message) '()]\n        [(letter? (car message)) (cons (replace-vowels\
    \ message\n                                                   (char->integer 'a'))\n\
    \                                   (encode (cdr message)))]\n        [else (cons\
    \ (replace-vowels (car message)\n                                 (char->integer\
    \ (char->symbol (char->letter (car message)))))\n                 (encode (cdr\
    \ message)))]))\n", "  ; first convert message to lowercase\n  (define message\
    \ (string message))\n  (define lowercase-message (string message))\n  (define\
    \ lowercase (map char->lower-case lowercase-message))\n  (define (f letter letter\
    \ vowel)\n    (cond\n      [(empty? vowel) letter]\n      [else (if (and (null?\
    \ letter) (equal? (char letter) letter)) \n            (cons letter \n       \
    \           (f (char letter (char vowel 0) letter) \n                       (char\
    \ letter (char vowel 1) letter) \n                       (char vowel (char vowel\
    \ 1) vowel))) \n              (cons (f letter (char letter 0 (char vowel 0)) letter\
    \ \n                      (f letter (char letter 1 (char vowel 1)) letter \n \
    \                          (f (char vowel (char vowel 1) vowel) \n           \
    \                    (char letter (char vowel 1) letter) \n                  \
    \             (char vowel (char vowel 1) vowel)))]))\n  \n  (f lowercase 'a 'a\
    \ \n    (f (map char->lower-case 'a) 'a \n        (f 'a (map char->lower-case\
    \ 'a) 'a \n            (f (map char->lower-case 'a) 'a (map char->lower-case 'a))))))\n",
  "  (if (null? message) \n      \"\"\n      (let* ((vowels '(a e i o u))\n      \
    \       (vowels2 \n              (substring vowels 0 (string-length message) \n\
    \                       #f)\n              (substring vowels (string-length message)\
    \ \n                       #f)\n              (vowels (substring vowels 1 (string-length\
    \ message))))\n            (letters\n             (list->string (string->list\
    \ message)))\n            (letters2\n             (map (lambda (x)\n         \
    \           (let ((index (substring letters 0 (string-length x) \n           \
    \                               #f)))\n                      (substring (substring\
    \ letters 1 index) \n                              0 index (string-length x)))\n\
    \                     (substring letters 1 (string-length x))))\n            \
    \ (letters3 \n              (append letters (substring letters2 0 (- \n      \
    \                           (string-length message) \n                       \
    \          #f)\n                             (string-length message)))\n     \
    \       (letters4\n             (map (lambda (x)\n                     (let ((index\
    \ (substring letters3 0 (string-length x) \n                                 \
    \            #f)))\n                      (substring (substring letters3 1 index)\
    \ \n                              0 index (string-length x)))\n              \
    \       (substring letters3 1 (string-length x))))\n            (letters5 \n \
    \             (append letters (substring letters4 0 (- \n                    \
    \             (string-length message) \n                                 #f)\n\
    \                             (string-length message)))\n            (letters6\n\
    \             (map (lambda (x)\n                     (let ((index (substring letters5\
    \ 0 (string-length x) \n                                             #f)))\n \
    \                     (substring (substring letters5 1 index) \n             \
    \                 0 index (string-length x)))\n                     (substring\
    \ letters5 1 (string-length x))))\n            (letters7\n             (map (lambda\
    \ (x)\n                     (let ((index (substring letters6 0 (string-length\
    \ x) \n                                             #f)))\n                  \
    \    (substring (substring letters6 1 index) \n                              0\
    \ index (string-length x)))\n                     (substring letters6 1 (string-length\
    \ x))))\n            (letters8 \n              (append letters (substring letters7\
    \ 0 (- \n                                 (string-length message) \n         \
    \                        #f)\n                             (string-length message)))\n\
    \            (letters9\n             (map (lambda (x)\n                     (let\
    \ ((index (substring letters8 0 (string-length x) \n                         \
    \                    #f)))\n                      (substring (substring letters8\
    \ 1 index) \n                              0 index (string-length x)))\n     \
    \                (substring letters8 1 (string-length x))))\n            (letters10\
    \ \n              (append letters (substring letters9 (- \n                  \
    \               (", "  (map (lambda (x) \n         (string->symbol ((substring\
    \ x 0 1) \n                           (substring x 2 1))) \n         (map symbol->string\
    \ (sort (string->list (string->symbol message))))))", "  (let ((mapping (cons\
    \ 'a [#\\a #b] [#c #d #e])))\n    (let ((str (string message)))\n      (replace-map\
    \ str (cons 'a [#\\a #b] [#c #d #e])\n                  (lambda (match)\n    \
    \                (map first mapping))))))\n", "  (define (find char)\n    (cond\
    \ ((char=? char #\\a) (char=? char #\\e))\n          ((char=? char #\\i) (char=?\
    \ char #\\o))\n          ((char=? char #\\u) (char=? char #\\y)))))\n  (define\
    \ (replace-vowel vowel)\n    (cond ((char=? vowel #\\a) (char=? vowel #\\e))\n\
    \          ((char=? vowel #\\i) (char=? vowel #\\o))\n          ((char=? vowel\
    \ #\\u) (char=? vowel #\\y))))\n  (define (replace-vowels char vowel)\n    (cond\
    \ ((char=? char #\\a) (replace-vowel vowel))\n          ((char=? char #\\e) (replace-vowel\
    \ vowel))\n          ((char=? char #\\i) (replace-vowel vowel))\n          ((char=?\
    \ char #\\o) (replace-vowel vowel))\n          ((char=? char #\\u) (replace-vowel\
    \ vowel))\n          ((char=? char #\\y) (replace-vowel vowel)))))\n  (define\
    \ (encode-char char-index)\n    (define (encode-char-helper)\n      (cond ((char=?\
    \ char-index #\\a) (encode-char (+ char-index 1)))\n            ((char=? char-index\
    \ #\\e) (encode-char (+ char-index 2)))\n            ((char=? char-index #\\i)\
    \ (encode-char (+ char-index 3)))\n            ((char=? char-index #\\o) (encode-char\
    \ (+ char-index 4)))\n            ((char=? char-index #\\u) (encode-char (+ char-index\
    \ 5)))\n            ((char=? char-index #\\y) (encode-char (+ char-index 6)))))\n\
    \    (encode-char-helper))\n  (define (encode-string s)\n    (cond ((empty? s)\
    \ (empty-string))\n          ((char=? (first s) #\\) (encode-string (rest s)))\n\
    \          (else (let ((char-index (first s))\n                       (char-index-count\
    \ (length (first s))))\n                (cond ((char=? char-index #\\) (encode-string\
    \ (remove-char s 1)))\n                      ((char=? (second s) #\\) (encode-string\
    \ (", "  (cond [(empty? message) \"\"]\n        [else (substring \n          \
    \     (cons \n                (substring \n                 (string-map \n   \
    \               (lambda (c) (case (letter? (first c)) \n                     \
    \           (lower (first c)) \n                                (upper (first\
    \ c)) \n                                (letter (first c)) \n                \
    \                (list (first c) (second c) (third c) (fourth c) (fifth c) (sixth\
    \ c) (seventh c) (eighth c) (tenth c) (eleventh c) (twelveth c) (thirteenth c)\
    \ (fourteenth c) (fifteenth c) (sixteenth c) (seventeenth c) (eighteenth c) (tenteenth\
    \ c) (twentieth (first c))) (substring message 0 (string-length message)))\n \
    \                 (map car (string->list message)))\n               (- 3 (length\
    \ message) 2))])))\n", "  (cond\n    ((not (= (string-length message) 0))\n  \
    \   (list message))\n    ((and (not (= (string-length message) 1)) \n        \
    \   (not (= (string-ref message 0) #\\Space)))\n     (list message))\n    ((=\
    \ (string-length message) 1)\n     (list message))\n    ((string=? message (string-ref\
    \ message 0))\n     (list message))\n    ((string=? (string-ref message 0) #\\\
    Space)\n     (list message))\n    ((string=? (string-ref message 0) #\\NewLine)\n\
    \     (list message))\n    ((string=? (string-ref message 0) #\\Tab)\n     (list\
    \ message))\n    ((string=? (string-ref message 0) #\\Return)\n     (list message))\n\
    \    ((string=? (string-ref message 0) #\\Upcase)\n     (list message))\n    ((string=?\
    \ (string-ref message 0) #\\Downcase)\n     (list message))\n    ((string=? (string-ref\
    \ message 0) #\\Left)\n     (list message))\n    ((string=? (string-ref message\
    \ 0) #\\Right)\n     (list message))\n    ((string=? (string-ref message 0) #\\\
    Z)\n     (list message))\n    ((string=? (string-ref message 0) #\\N)\n     (list\
    \ message))\n    ((string=? (string-ref message 0) #\\M)\n     (list message))\n\
    \    ((string=? (string-ref message 0) #\\A)\n     (list message))\n    ((string=?\
    \ (string-ref message 0) #\\E)\n     (list message))\n    ((string=? (string-ref\
    \ message 0) #\\W)\n     (list message))\n    ((string=? (string-ref message 0)\
    \ #\\S)\n     (list message))\n    ((string=? (string-ref message 0) #\\D)\n \
    \    (list message))\n    ((string=? (string-ref message 0) #\\O)\n     (list\
    \ message))\n    ((string=? (string-ref message 0) #\\U)\n     (list message))\n\
    \    ((string=? (string-ref message 0) #\\i)\n     (list message))\n    ((string=?\
    \ (string-ref message 0) #\\j)\n     (list message))\n    ((string=? (string-ref\
    \ message 0) #\\k)\n     (list message))\n    ((string=? (string-ref message 0)\
    \ #\\l)\n     (list message))\n    ((string=? (string-ref message 0) #\\m)\n \
    \    (list message))\n    ((string=? (string-ref message 0) #\\o)\n     (list\
    \ message))\n    ((string=? (string-ref message 0) #\\", "  (cond\n    [(empty?\
    \ message) \"\"]\n    [else\n     (loop for i from 0 to (string-length (first\
    \ message))\n            for j = (+ i 1) to (string-length (first message))\n\
    \            for char = (string->char (substring message i (+ j 1)))\n       \
    \     if (string= (char (substring message i j)) (first message))\n          \
    \  collect (concat char \n                        (string->char (substring (substring\
    \ message (+ i 1) (+ j 1)))))]))]))\n", "  (define (helper s i j)\n    (cond\n\
    \      [(equal? i (length s)) (list s)])\n      [(equal? j (length s)) (list s)])\n\
    \      [(equal? (char-code s) #\\a) (list (char-code (substring s i (add1 j))))]\n\
    \      [(equal? (char-code s) #\\A) (list (char-code (substring s i (add1 j))))]\n\
    \      [(equal? (char-code s) #\\e) (list (char-code (substring s i (add1 j))))]\n\
    \      [(equal? (char-code s) #\\E) (list (char-code (substring s i (add1 j))))]\n\
    \      [(equal? (char-code s) #\\i) (list (char-code (substring s i (add1 j))))]\n\
    \      [(equal? (char-code s) #\\I) (list (char-code (substring s i (add1 j))))]\n\
    \      [(equal? (char-code s) #\\o) (list (char-code (substring s i (add1 j))))]\n\
    \      [(equal? (char-code s) #\\O) (list (char-code (substring s i (add1 j))))]\n\
    \      [(equal? (char-code s) #\\u) (list (char-code (substring s i (add1 j))))]\n\
    \      [(equal? (char-code s) #\\U) (list (char-code (substring s i (add1 j))))]\n\
    \      [(equal? (char-code s) #\\y) (list (char-code (substring s i (add1 j))))]\n\
    \      [(equal? (char-code s) #\\Y) (list (char-code (substring s i (add1 j))))]\n\
    \      [else (list (char-code s))]\n      ))\n  (helper message 0 (length message)))\n\
    </code>\n<|/ a tags=scheme,racket,string dscore=1 |>\n<| c |>\nthanks so much.\
    \ I never knew that substring exists.\n<|/ c |>\n<| c |>\nNo problem! Racket has\
    \ really cool string manipulation functions, and they're pretty straightforward\
    \ to use. Sometimes there's just some syntax that's confusing, so this helps.\n\
    <|/ c |>\n<| a tags=scheme,racket,string dscore=0 |>\nA slightly different way\
    \ is to do this\n<code>", "  (map (lambda (c1 c2)\n         (string->symbol (string->string\
    \ (string->list (string->string \n                                           \
    \                (string->string \n                                          \
    \                 \"abcdefghijklmnopqrstuvwxyz\")))\n                        \
    \     (string->string (string->list (string->string \n                       \
    \                                        (string->string \n                  \
    \                                                \"aeiou\"))) \n             \
    \                  c1 c2))\n          (string->list (string->string (string->string\
    \ \n                                             (string->string \n          \
    \                                     (string->string \n                     \
    \                            (string->string \n                              \
    \                     (string->string \n                                     \
    \                (string->string \n                                          \
    \           (string->string \n                                               \
    \      (string->string \n                                                    \
    \  (string->string \n                                                       (string->string\
    \ \n                                                       message))))))))))\n\
    \         (string->list (string->string (string->string \n                   \
    \                       (string->string \n                                   \
    \        (string->string \n                                             (string->string\
    \ \n                                             (string->string \n          \
    \                                     (string->string \n                     \
    \                          (string->string \n                                \
    \                 (string->string \n                                         \
    \        (string->string \n                                                  message)))))))))))\n\
    \  (define (helper s i j)\n    (if (< i j)\n        (cond [(= (mod i 3) 0)\n \
    \              (symbol->string (string->symbol \n                            \
    \      (string->string \n                                   (string->string \n\
    \                                   (string->string \n                       \
    \            (string->string \n                                   (string->string\
    \ \n                                   (string->string \n                    \
    \               (string->string \n                                   (string->string\
    \ \n                                   (string->string \n                    \
    \               (string->string \n                                   (string->string\
    \ \n                                   (string->string \n                    \
    \               (string->string \n                                   (string->string\
    \ \n                                   (string->string \n                    \
    \               (string->string \n                                   (string->string\
    \ \n                                   (string->string \n                    \
    \               (string->string \n                                   (string->string\
    \ \n                                   (string->string \n                    \
    \               (string->string \n                                   (string->string\
    \ \n                                   (string->string \n                    \
    \               (string->string \n                                   (string->string\
    \ \n                                   (string->string \n                    \
    \               (string->string \n                                   (string->string\
    \ \n                                   (string->string \n                    \
    \               (string->string \n                                   (string->string\
    \ \n                                   (string->string \n                    \
    \               (string->string \n                                   (string->string\
    \ \n                                   (string->string \n                    \
    \               (string->string \n                                   (string->string\
    \ \n                                   (string->string \n                    \
    \               (string->string \n                                   (string->string\
    \ \n                                   (string->string \n                    \
    \               (string->string \n                                   (string->string\
    \ \n                                   (string->string ", "  (loop for i from\
    \ 0 below (string-length (string-downcase message)) \n       for j from i below\
    \ length (string-downcase message)\n       collect (string-append\n          \
    \         (string-downcase (substring message i j))\n                   (substring\
    \ (substring message j 1) \n                             (substring message i\
    \ 1)))))\n", "  (define (enc m acc)\n    (if (null? m) acc\n        (enc \n  \
    \        (rest m) \n          (cons (char->integer (char-before (first m)))\n\
    \                (cons (char->integer (char-before (second m)))\n            \
    \          acc))))\n  (enc message '()))\n", "  (define (lookup-2 l k)\n    (cond\
    \ (empty? l) k\n          (equal? (first l) k) (second l)\n          else (lookup-2\
    \ (rest l) k)))\n  (define (lookup-1 l k)\n    (cond (empty? l) k\n          (equal?\
    \ (first l) k) (first l)\n          else (lookup-1 (rest l) k)))\n  (define (swap-case\
    \ s)\n    (cond ((empty? s) s) \n          ((equal? (first s) (first 'A)) (second\
    \ (first s))) \n          ((equal? (first s) (first 'a)) (second (first s)))\n\
    \          (else (append (list (lookup-1 (rest s) (first s))) (list (lookup-2\
    \ (rest s) (first s)))))) \n    (append (list (swap-case (first s))) (list (swap-case\
    \ (rest s)))))\n  (append (list (swap-case (first message))) (list (swap-case\
    \ (encode (encode message)))))\n  )\n", "  (encode message 0 '()))\n", "  (cond\n\
    \    [(null? message) \"\"]\n    [(equal? (char-code (first message)) #\\a) (encode\
    \ (encode (first message))))]\n    [(equal? (char-code (first message)) #\\e)\
    \ (encode (encode (first message))))]\n    [(equal? (char-code (first message))\
    \ #\\i) (encode (encode (first message))))]\n    [(equal? (char-code (first message))\
    \ #\\o) (encode (encode (first message))))]\n    [(equal? (char-code (first message))\
    \ #\\u) (encode (encode (first message))))]\n    [else (append (list (char-code\
    \ (first message))) \n                   (list (char-code (second message))) \n\
    \                   (list (char-code (third message))) \n                   (list\
    \ (char-code (fourth message))) \n                   (list (char-code (fifth message)))\
    \ \n                   (list (char-code (sixth message))) \n                 \
    \  (list (char-code (seventh message))) \n                   (list (char-code\
    \ (eighth message))) \n                   (list (char-code (ninth message))) \n\
    \                   (list (char-code (tenth message)))]))]))\n", "  (let-values\
    \ ([(m n) (find-vowels (count-letters message))]) (encode message))\n)", "  (cond\
    \ [(empty? message) \"\"]\n        [(not(char-alphabet (car message)))\n     \
    \    (append\n          (encode (first (split-string (car message) '(#\\Space\
    \ #\\Newline #\\Tab))))\n          (encode (rest (split-string (car message) '(#\\\
    Space #\\Newline #\\Tab))))]\n        [else (append\n               (append (first\
    \ (split-string (car message) '(#\\Space #\\Newline #\\Tab)))\n              \
    \          (encode (first (split-string (car message) '(#\\Space #\\Newline #\\\
    Tab))))\n               (encode (rest (split-string (car message) '(#\\Space #\\\
    Newline #\\Tab))))]))) \n", "  (define (vowels message)\n    (string->list message))\n\
    \  (define (letters message)\n    (string->list (string->string message)))\n \
    \ (define (letter-to-vowel letter)\n    (if (< letter 90)\n        (string->symbol\
    \ (char->string letter))\n        letter))\n  (define (vowel-to-letter vowel)\n\
    \    (char->string (symbol->char vowel)))\n  (define (pair? message)\n    (and\
    \ (list? message)\n         (= (length message) 2))\n  (define (vowel-pair? pair)\n\
    \    (and (list? pair)\n         (equal? (first pair) letters))\n  (define (letter-to-pair?\
    \ letter)\n    (equal? (first letters) letter))\n  (define (pair-to-letter pair)\n\
    \    (char->string (symbol->char pair)))\n  (define (pair-to-vowel pair)\n   \
    \ (char->string (symbol->char pair)))\n  (define (encode message)\n    (let ([vowels\
    \ (vowels message)]\n           [letters (letters message)]\n           [letter-to-vowel\
    \ (letter-to-vowel letters)] \n           [vowel-to-letter (vowel-to-letter vowels)]\n\
    \           [pair? (pair? message)]\n           [vowel-pair? (vowel-pair? pairs)]\
    \ \n           [letter-to-pair? (letter-to-pair? letters)]\n           [pair-to-letter\
    \ (pair-to-letter pairs)]\n           [pair-to-vowel (pair-to-vowel pairs)]\n\
    \           [message (encode-substring message vowels letters pairs letter-to-vowel\
    \ vowel-to-letter pair-to-letter pair-to-vowel)])\n      (if (string=? (first\
    \ message) '())\n          (append message (first message))\n          (append\
    \ (first message) (first message))))))\n", "  (if (null? message)\n      '()\n\
    \      (append (list (char message\n                        (+ (char message \n\
    \                               #\\a) \n                          #\\A)))\n  \
    \            (encode (substring (message 1) \n                            0 \n\
    \                            (substring (message 1) \n                       \
    \            1 \n                                   (length (message 1)))))))\n",
  "  (define (vowel-letter a b)\n    (cond\n      [(string=? (vowel? (char-code a))\
    \ (vowel? (char-code b))) b]\n      [else a]))\n  (define (letter-code letter)\n\
    \    (cond\n      [(string=? letter 'a) 97]\n      [(string=? letter 'e) 11]\n\
    \      [(string=? letter 'i) 100]\n      [(string=? letter 'o) 101]\n      [(string=?\
    \ letter 'u) 115]\n      [else (error \"Invalid letter: ~s\" letter)])\n  (define\
    \ (letter-to-code letter)\n    (cond\n      [(string=? letter 'a) 97]\n      [(string=?\
    \ letter 'e) 11]\n      [(string=? letter 'i) 100]\n      [(string=? letter 'o)\
    \ 101]\n      [(string=? letter 'u) 115]\n      [else (error \"Invalid letter:\
    \ ~s\" letter)]))\n  (define (vowel-char-count vowel)\n    (cond\n      [(string=?\
    \ vowel 'a) 1]\n      [(string=? vowel 'e) 1]\n      [(string=? vowel 'i) 1]\n\
    \      [(string=? vowel 'o) 1]\n      [(string=? vowel 'u) 1]\n      [(string=?\
    \ vowel 'y) (* 2 vowels)]\n      [else 0]))\n  (define (encode-char char vowels)\n\
    \    (cond\n      [(string=? char 'a) (letter-code (char-code char))]\n      [(string=?\
    \ char 'e) (letter-code (char-code char))]\n      [(string=? char 'i) (letter-code\
    \ (char-code char))]\n      [(string=? char 'o) (letter-code (char-code char))]\n\
    \      [(string=? char 'u) (letter-code (char-code char))]\n      [(string=? char\
    \ 'y) (letter-code (char-code char))]\n      [(string=? char 'e) (letter-to-code\
    \ (vowel-letter char vowels))]\n      [(string=? char 'i) (letter-to-code (vowel-letter\
    \ char vowels))]\n      [(string=? char 'o) (letter-to-code (vowel-letter char\
    \ vowels))]\n      [(string=? char 'u) (letter-to-code (vowel-letter char vowels))]\n\
    \      [else (error \"Invalid letter: ~s\" char)]))\n  (define ", "  (map \n \
    \  (lambda (i)\n     (if (eqv? i (car message))\n         (car message)\n    \
    \     (cons (string->char \n               (string->string \n                \
    \ (substring \n                   (string-index message i) \n                \
    \   (string-length message))))))\n   \n   (string->list message)))\n", "  (define\
    \ (replace-vowel letter position)\n    (cond ((eq? (char-before (string->char-sequence\
    \ letter) position) 'a) (char-after (string->char-sequence letter) position))\n\
    \          ((eq? (char-before (string->char-sequence letter) position) 'e) (char-after\
    \ (string->char-sequence letter) position))\n          ((eq? (char-before (string->char-sequence\
    \ letter) position) 'i) (char-after (string->char-sequence letter) position))\n\
    \          ((eq? (char-before (string->char-sequence letter) position) 'o) (char-after\
    \ (string->char-sequence letter) position))\n          ((eq? (char-before (string->char-sequence\
    \ letter) position) 'u) (char-after (string->char-sequence letter) position))\n\
    \          ((eq? (char-before (string->char-sequence letter) position) 'y) (char-after\
    \ (string->char-sequence letter) position))))\n  (define (replace-vowels letters\
    \ position)\n    (define (replace-vowels-helper letters position result)\n   \
    \   (if (null? letters)\n          result\n          (replace-vowels-helper (cdr\
    \ letters)\n                                 (char-before letters position)\n\
    \                                 (cons (replace-vowel (car letters) position)\n\
    \                                      result))))\n    (replace-vowels-helper\
    \ (string->char-sequence letters) position \"\"))\n  (define (replace-vowels-helper\
    \ message position result)\n    (if (null? message)\n        result\n        (replace-vowels-helper\
    \ (cdr message)\n                               (char-before message position)\n\
    \                               (cons (replace-vowels (car message) position)\n\
    \                                     result))))\n  (replace-vowels-helper message\
    \ 0 \"\"))\n", "  (cond\n    [(empty? message) message]\n    [(equal? (first message)\
    \ ?a) (encode (rest message))]\n    [(equal? (first message) ?b) (encode (rest\
    \ message))]\n    [(equal? (first message) ?c) (encode (rest message))]\n    [(equal?\
    \ (first message) ?d)\n     (encode-case (encode (rest message)) ?a)]\n    [(equal?\
    \ (first message) ?e)\n     (encode-case (encode (rest message)) ?b)]\n    [(equal?\
    \ (first message) ?f)\n     (encode-case (encode (rest message)) ?c)]\n    [(equal?\
    \ (first message) ?g)\n     (encode-case (encode (rest message)) ?d)]\n    [(equal?\
    \ (first message) ?h)\n     (encode-case (encode (rest message)) ?e)]\n    [(equal?\
    \ (first message) ?i)\n     (encode-case (encode (rest message)) ?f)]\n    [(equal?\
    \ (first message) ?j)\n     (encode-case (encode (rest message)) ?g)]\n    [(equal?\
    \ (first message) ?k)\n     (encode-case (encode (rest message)) ?h)]\n    [(equal?\
    \ (first message) ?l)\n     (encode-case (encode (rest message)) ?i)]\n    [(equal?\
    \ (first message) ?m)\n     (encode-case (encode (rest message)) ?j)]\n    [(equal?\
    \ (first message) ?n)\n     (encode-case (encode (rest message)) ?k)]\n    [(equal?\
    \ (first message) ?o)\n     (encode-case (encode (rest message)) ?l)]\n    [(equal?\
    \ (first message) ?p)\n     (encode-case (encode (rest message)) ?M)]\n    [(equal?\
    \ (first message) ?q)\n     (encode-case (encode (rest message)) ?N)]\n    [(equal?\
    \ (first message) ?r)\n     (encode-case (encode (rest message)) ?O)]\n    [(equal?\
    \ (first message) ?s)\n     (encode-case (encode (rest message)) ?P)]\n    [(equal?\
    \ (first message) ?t)\n     (encode-case (encode (rest message)) ?Q)]\n    [(equal?\
    \ (first message) ?u)\n     (encode-case (encode (rest message)) ?R)]\n    [(equal?\
    \ (first message) ?v)\n     (encode-case (encode (rest message)) ?", "  (let loop\
    \ ((counter (length message))\n             (result \"\"))\n    (if (= counter\
    \ 0)\n        result\n        (loop (sub1 counter)\n              (cons (char->integer\
    \ (char->string (first message)) \n                         (sub1 counter)) result)))))\n",
  "  (let ((letter-array (make-array 26)))\n    (define (find-letter-at-pos pos letter-array)\n\
    \      (cond\n        ((<= pos 26) (eqv? (char-code letter-array pos) 'a)))\n\
    \      (cond\n        ((<= pos 26) (char-code letter-array pos)))\n      (cond\n\
    \        ((<= pos 26) (char-code letter-array (add1 pos))))\n      (cond\n   \
    \     ((<= pos 26) (char-code letter-array (add1 pos))))\n    (define (count-vowels-at-pos\
    \ pos letter-array)\n      (cond\n        ((= (sub1 (char-code letter-array pos))\
    \ 0) (+ 1 (char-code letter-array pos)))\n        (#t (+ 1 (char-code letter-array\
    \ (add1 pos)))))\n    (define (find-next-vowel-at-pos pos letter-array)\n    \
    \  (cond\n        ((<= pos 26) (eqv? (char-code letter-array pos) 'a)))\n    \
    \  (cond\n        ((<= pos 26) (char-code letter-array pos))\n        (#t (char-code\
    \ letter-array (add1 pos)))))\n    (define (swap-vowels-at-pos pos letter-array)\n\
    \      (cond\n        ((<= pos 26) (char-code letter-array pos))\n        (#t\
    \ (char-code letter-array (add1 pos)))))\n    (define (swap-case-at-pos pos letter-array)\n\
    \      (cond\n        ((= (sub1 (char-code letter-array pos)) 0) (char #\\Upcase\
    \ (char-code letter-array (add1 pos)))\n        (char #\\Lowercase (char-code\
    \ letter-array (add1 pos)))))\n    (define (swap-case-letters-in-message letter-array)\n\
    \      (cond\n        ((<= 0 (length message)) (make-string 0 (length message)))\n\
    \        (#t (make-string (length message) (cond \n                          \
    \      ((= 0 (length message)) '#\\Space '#\\Newline)\n                      \
    \          (#t (cond \n                                    ((and (eqv? (char-code\
    \ letter-array 0) 'A) (eqv? (char-code letter-array 1) 'a)) \n               \
    \                     (char #\\Upcase (char-code letter-array 0)))\n         \
    \                           (#t (cond \n                                     \
    \   ((and (eqv? (char-code letter-array 0) 'A) (eqv? (char-code letter-array 1)\
    \ 'a)) \n                                        (char #\\Lowercase (char-code\
    \ letter-array 0)))\n                                        (#t (cond \n    \
    \                                        ((and (eq", "  (cond [(null? message)\
    \ \"\"]\n        [(empty? (rest message))\n         (symbol->string (first message))]]\n\
    \        [(symbol->string (first message))\n         (cons (symbol->string (first\
    \ message))\n               (encode (rest message)))]\n        [(symbol->string\
    \ (first message))\n         (cons (symbol->string (first message))\n        \
    \       (encode (rest message)))]\n        [(symbol->string (first message))\n\
    \         (cons (symbol->string (first message))\n               (encode (rest\
    \ message)))]\n        [(symbol->string (first message))\n         (cons (symbol->string\
    \ (first message))\n               (encode (rest message)))]\n        [(symbol->string\
    \ (first message))\n         (cons (symbol->string (first message))\n        \
    \       (encode (rest message)))]\n        [(symbol->string (first message))\n\
    \         (cons (symbol->string (first message))\n               (encode (rest\
    \ message)))]\n        [(symbol->string (first message))\n         (cons (symbol->string\
    \ (first message))\n               (encode (rest message)))]\n        [(symbol->string\
    \ (first message))\n         (cons (symbol->string (first message))\n        \
    \       (encode (rest message)))]\n        [(symbol->string (first message))\n\
    \         (cons (symbol->string (first message))\n               (encode (rest\
    \ message)))]\n        [(symbol->string (first message))\n         (cons (symbol->string\
    \ (first message))\n               (encode (rest message)))]\n        [(symbol->string\
    \ (first message))\n         (cons (symbol->string (first message))\n        \
    \       (encode (rest message)))]\n        [(symbol->string (first message))\n\
    \         (cons (symbol->string (first message))\n               (encode (rest\
    \ message)))]\n        [(symbol->string (first message))\n         (cons (symbol->string\
    \ (first message))\n               (encode (rest message)))]\n        [(symbol->string\
    \ (first message))\n         (cons (symbol->string (first message))\n        \
    \       (encode (rest message)))]\n        [(symbol->string (first message))\n\
    \         (cons (symbol->string (first message))\n               (encode (rest\
    \ message)))]\n        [(symbol->string (first message))\n         (cons (symbol->string\
    \ (first message))\n               (encode (rest message)))]\n        [(symbol->string\
    \ (first message))\n         (cons (symbol->string (first message))\n        \
    \       (encode (rest message)))]\n        [(symbol->string (first message))",
  "  (let* ((all-chars (string->list message))\n         (vowels '(a e i o u y A E\
    \ I O U Y)))\n    (cond\n      [(empty? all-chars) \"\"]\n      [(member (char->integer\
    \ (first all-chars)) vowels)\n       (cons (char->integer (second all-chars))\
    \ (encode (second all-chars)))]\n      [else (cons (char->integer (first all-chars))\
    \ (encode (second all-chars)))]\n      )\n    )\n  )\n)\n</code>\n<|/ a tags=scheme,racket,lisp\
    \ |>\n<| a |>\nThe other answers are correct but let me try to answer this in\
    \ Scheme without using regular expressions. Since your question asks for a non-regex\
    \ solution, I hope this helps you think through this problem better than I do.\n\
    Let's start with a function that takes a string and converts it to lower-case:\n\
    <code>", "  (apply encode-with #(list #\\A #\\E #\\I) #\\D #\\U #\\O)\n      \
    \    (list message)\n          (list #\\A #\\E #\\I) #\\D #\\U #\\O))\n", "  ;\
    \ Your code here\n  ) \n</code>\n<|/ q tags=racket,scheme dscore=0 |>\n<| c |>\n\
    How about using [Racket string operations](https://docs.racket-lang.org/strings/index.html)?\n\
    <|/ c |>\n<| c |>\nPlease read [this answer](http://stackoverflow.com/questions/7156956/racket-case-insensitive-string-comparison/7158373#7158373)\
    \ about making case insensitive string comparisons.\n<|/ c |>\n<| c |>\nWhat do\
    \ you think `char-alphabetic?` is doing?\n<|/ c |>\n<| c |>\nI'm actually not\
    \ sure, i just copied it from the answers here and thought it might be relevant\n\
    <|/ c |>\n<| c |>\nI wonder how you got that impression from \"here\" and \"here\"\
    \ on the page, and how you expect people to tell you exactly what it is doing\
    \ without knowing what it is.\n<|/ c |>\n<| a tags=racket,scheme |>\nThe char-alphabetic\
    \ predicate checks if the character at a given position is a letter. If you want\
    \ to check whether the string is a permutation of the alphabet, you should use\
    \ string-alphabetic?.\n<|/ a dscore=2 |>\n<| c |>\nHi, thanks for the answer.\
    \ The problem is that this solution does not work. I tried to apply the string-alphabetic?\
    \ function to the \"test\" string but it returns #t.\n<|/ c |>\n<| c |>\nThat\
    \ is strange. Do you know what version of Racket you're using?\n<|/ c |>\n<| c\
    \ |>\nRacket's documentation says string-alphabetic? was added in version 6.8.\n\
    <|/ c |>\n<| c |>\nMy bad. I tried it on a different machine and it worked. Thanks\n\
    <|/ c |>\n<| a |>\nThe standard Racket string-alphabetic? procedure will work\
    \ for you.  It's also easy to write yourself:\n<code>", "  (cond\n    [(empty?\
    \ message) \"\"]\n    [(symbol? (first message)) (encode-symbol (first message))]\n\
    \    [(cons? message)\n     (encode-cons\n      (first message)\n      (encode\n\
    \       (rest message)))]))\n", "  (cond\n    [(empty? message) empty]\n    [(number?\
    \ (first message)) (encode (rest message))]\n    [(symbol? (first message)) (encode\
    \ (rest message))]\n    [(number? (rest message)) (cons (symbol-value (first message))\
    \ (encode (rest message)))]\n    [else (cons (symbol-value (first message)) (encode\
    \ (rest message)))]))\n", "  (encode-chars message #(#\\A #\\E #\\I #\\O #\\U\
    \ #\\Y)))\n", "  (cond\n    [(empty? message) \"\"]\n    [else\n      (let ([vowels\
    \ '(a e i o u y w)])\n        (map \n         (lambda (x)\n           (cond \n\
    \             [(char-equal? (car x) ?a) ?a]\n             [(char-equal? (car x)\
    \ ?e) ?e]\n             [(char-equal? (car x) ?i) ?i]\n             [(char-equal?\
    \ (car x) ?o) ?o]\n             [(char-equal? (car x) ?u) ?u]\n             [(char-equal?\
    \ (car x) ?y) ?y]\n             [(char-equal? (car x) ?w) ?w]\n             [(char-equal?\
    \ (car x) ?A) ?A]\n             [(char-equal? (car x) ?E) ?E]\n             [(char-equal?\
    \ (car x) ?I) ?I]\n             [(char-equal? (car x) ?O) ?O]\n             [(char-equal?\
    \ (car x) ?U) ?U]\n             [(char-equal? (car x) ?Y) ?Y]\n             [(char-equal?\
    \ (car x) ?W) ?W]\n             [else x])\n         (string->list (filter (lambda\
    \ (x) (char-equal? x ?a)) (remove-if (lambda (x) (char-equal? (car x) ?a)) message)))\n\
    \         (string->list (filter (lambda (x) (char-equal? x ?e)) (remove-if (lambda\
    \ (x) (char-equal? (car x) ?e)) message)))\n         (string->list (filter (lambda\
    \ (x) (char-equal? x ?i)) (remove-if (lambda (x) (char-equal? (car x) ?i)) message)))\n\
    \         (string->list (filter (lambda (x) (char-equal? x ?o)) (remove-if (lambda\
    \ (x) (char-equal? (car x) ?o)) message)))\n         (string->list (filter (lambda\
    \ (x) (char-equal? x ?u)) (remove-if (lambda (x) (char-equal? (car x) ?u)) message)))\n\
    \         (string->list (filter (lambda (x) (char-equal? x ?y)) (remove-if (lambda\
    \ (x) (char-equal? (car x) ?y)) message)))\n         (string->list (filter (lambda\
    \ (x) (char-equal? x ?w)) (remove-if (lambda (x) (", "  (cond\n    [(empty? message)\
    \ \"Empty message\"]\n    [(symbolp (car message)) (encode (cdr message))]\n \
    \   [else (cons (case (car message)\n                    [a (b (car message) (cadr\
    \ message))\n                    e (f(car (cdr message)) (cadr (cdr message)))\
    \ \n                    i (g(car (cdr message)) (cadr (cdr message)))\n      \
    \              o (b (car message) (cadr message))\n                    u (c (car\
    \ (cdr message)) (cadr (cdr message)))\n                    y (c (car message)\
    \ (cadr message))\n                    (else (error \"Not a letter\")))]) (encode\
    \ (cdr message))]))\n", "  (let ((lst (make-list 27))) (loop\n    for char in\
    \ (list)\n    for pos in (subseq message 1)\n    for vowel in (list 'a 'e 'i 'o\
    \ 'u)\n    if (char=? char vowel)\n      collect (list char pos (list-ref lst\
    \ char) pos)\n    else if (list-ref lst char (+ pos 1))\n      collect (list char\
    \ pos\n          (list-ref lst char (+ pos 1))\n          (list-ref lst char (+\
    \ pos 2)))\n    else \n      collect (list char pos\n          (list-ref lst char\
    \ (+ pos 1))\n          (list-ref lst char (+ pos 2)))\n    finally (set! lst\
    \ '()))))\n", "  (define (encode letter)\n    (if (member letter 'a)\n      (if\
    \ (member letter 'b) \n        (if (member letter 'c) \n          (if (member\
    \ letter 'd) \n            (if (member letter 'e) \n              (if (member\
    \ letter 'f) \n                (if (member letter 'g) \n                  (if\
    \ (member letter 'h) \n                    (if (member letter 'i) \n         \
    \             (if (member letter 'j) \n                        (if (member letter\
    \ 'k) \n                          (if (member letter 'l) \n                  \
    \          (if (member letter 'm) \n                              (if (member\
    \ letter 'n) \n                                (if (member letter 'o) \n     \
    \                             (if (member letter 'p) \n                      \
    \              (if (member letter 'q) \n                                     \
    \ (if (member letter 'r) \n                                        (if (member\
    \ letter 's) \n                                          (if (member letter 't)\
    \ \n                                            (if (member letter 'u) \n    \
    \                                          (if (member letter 'v) \n         \
    \                                       (if (member letter 'w) \n            \
    \                                      (if (member letter 'x) \n             \
    \                                       (if (member letter 'y) \n            \
    \                                          (if (member letter 'z) \n         \
    \                                               (list letter)))))))))))))))))\n\
    \                  (list letter))))))))\n  (for-each (lambda (letter)\n      \
    \      (string-append (encode letter)\n                          (encode (member\
    \ letter 'aeiou)))\n            message))\n", "  (define (encode (message str)\
    \ index acc)\n    (if (= index 0)\n      acc\n      (encode (substring message\
    \ index 1) (add1 index) \n             (append acc (substring message (add1 index)\
    \ 1) (substring message index 1)))))\n  (encode message 0 \"\"))\n", "  (let*\
    \ ((message (list->string\n                   (string->list message\n        \
    \                         (string->list message))))\n         (chars (string->list\
    \ \n                  (make-string (string->length message)\n                \
    \               #\\space #\\newline)\n                  (make-string (string->length\
    \ message)\n                               #\\space #\\newline)))\n         (result\
    \ (make-string (string->length message)\n                           #\\space #\\\
    newline))\n         (index (string->list (string->list \n                    \
    \               (make-string (string->length message)\n                      \
    \                       #\\space #\\newline)\n                               \
    \    (make-string (string->length message)\n                                 \
    \            #\\space #\\newline))))\n    (loop \n       (cond ((> index chars)\
    \ (set! result (append result message)))\n             ((char= (char-ref message\
    \ index) (char-ref (char-ref message (add1 index)) 0)) \n             (set! result\
    \ (append result (char-ref message (add1 index)))))\n             ((or (char=\
    \ (char-ref message index) (char-ref (char-ref message (add1 index)) 1)) \n  \
    \                (char= (char-ref message (add1 index)) \n                   (char=\
    \ (char-ref message (add1 index)) #\\space))) \n             (set! index (add1\
    \ index))\n             (else \n             (set! index (add1 index))\n     \
    \        (loop))))\n    (set! result (append result message)))\n    ", "  (define\
    \ (helper letter position)\n    (if (> (+ position 1) 2)\n        letter\n   \
    \     (if (eq? (vowel? letter) true)\n            letter\n            (helper\
    \ (char letter (+ position 1)) (+ position 1)))))\n  (map helper message (list\
    \ 0)))\n", "  (cond [(empty? message)\n         (list)\n         ]\n        [(list?\
    \ (first message))\n         (encode (first message))\n         ]\n        [(equal?\
    \ (char (first message)) 'A) (encode-upper message)] \n        [(equal? (char\
    \ (first message)) 'a) (encode-lower message)] \n        [else\n         (cons\
    \ (char (first message))\n               (encode (rest message)))]\n        ))\n",
  "  (let* ((vowels '(a e i o u))\n         (map (lambda (c) (list c (string (car\
    \ c))))\n              (remove-if (lambda (c) (member c (vowels c)))\n       \
    \               (string-split message)))\n         (mapping (zipmap map vowels)))\n\
    \    (apply str\n           (map (lambda (letter count)\n                  (if\
    \ (eq? count 0)\n                      letter\n                      (cond ((member\
    \ letter (vowels letter)) letter)\n                            (else (apply string-append\
    \ letter (list mapping)))))\n                 message\n                 (apply\
    \ string-length (remove-if (lambda (c)\n                                     \
    \                   (eq? c #\\))\n                                           \
    \         (string-split message)))))))\n", "  (let ((vowels '(\"a\" \"e\" \"i\"\
    \ \"o\" \"u\")))\n    (define (helper i message)\n      (cond ((= i message) #f)\n\
    \            ((member i vowels) (member i (string (+ i (member i vowels)))))\n\
    \            (else (helper (+ i 1) (string i))))\n    (helper 0 message)))\n",
  "  (let loop ([i 0])\n    (cond\n      [(null? message) \"\"]\n      [(char=? (string-ref\
    \ message i) \n              (substring (string (substring message i) 1 \n   \
    \                            (substring message (i+1) \n                     \
    \                      (string->list (char->integer \n                       \
    \                             (substring message (i+1) 1))))) \n             \
    \        2)\n       ;; Two chars ahead; swap case.\n       ;; One vowel; replace\
    \ vowel with letter that appears two places\n       ;; ahead of vowel in english\
    \ alphabet.\n       (string-append (substring message 0 i) (list (char->integer\n\
    \                                                       (substring message (i+1)\
    \ 1))))]\n      [else (loop (+ i 1))])))\n</code>\n<|/ a tags=string,scheme dscore=0\
    \ |>\n<| a tags=string,scheme dscore=0 |>\nHere is a solution using the \"string\"\
    \ library:\n<code>\n#!r6rs", "  (define (condense)\n    (cond\n      [(string-empty?\
    \ message) #f]\n      [else (condense (rest (string-downcase (first message))))\
    \ (condense (rest (string-downcase (rest message)))) ]))\n  (cond\n    [(empty?\
    \ message) #f]\n    [else (condense message) ]))\n", "  (define (concat a b)\n\
    \    (append a b))\n\n  (define (map f m)\n    (cond ((null? m) '())\n       \
    \   ((eq? (car m) 'a) (cons (car m) (map (f 'A) (cdr m))))\n          ((eq? (car\
    \ m) 'e) (cons (car m) (map (f 'E) (cdr m))))\n          ((eq? (car m) 'i) (cons\
    \ (car m) (map (f 'I) (cdr m))))\n          ((eq? (car m) 'o) (cons (car m) (map\
    \ (f 'O) (cdr m))))\n          (else (cons (car m) (map (f (caar m)) (cdr m)))))\n\
    \  (concat '() \n          (map #(lambda (a b) (concat b (list a))) \n       \
    \        (map (lambda (x) (string-map x (lambda (a) (caar a)) \n             \
    \      (lambda (b) (list b))))\n               (map #(lambda (x) (string-map x\
    \ (lambda (a) (car a))\n                   (lambda (b) (concat b '()))))\n   \
    \            (map (lambda (x) (string-map x (lambda (a) (car a)) \n          \
    \         (lambda (b) (concat b '()))))\n               (map (lambda (x) (string-map\
    \ x (lambda (a) (caar a)) \n                   (lambda (b) (concat b '()))))\n\
    \               (map (lambda (x) (string-map x (lambda (a) (car a)) \n       \
    \            (lambda (b) (concat b '()))))\n               (map #(lambda (x) (string-map\
    \ x (lambda (a) (caar a)) \n                   (lambda (b) (concat b '()))))\n\
    \               (map (lambda (x) (string-map x (lambda (a) (car a)) \n       \
    \            (lambda (b) (concat b '()))))\n               (map #(lambda (x) (string-map\
    \ x (lambda (a) (caar a)) \n                   (lambda (b) (concat b '()))))\n\
    \               (map (lambda (x) (string-map x (lambda (a) (car a)) \n       \
    \            (lambda (b) (concat b '()))))\n               (map #(lambda (x) (string-map\
    \ x (lambda (a) (caar a)) \n                   (lambda (b) (concat b '()))))\n\
    \               (map (lambda (x) ", "  (define (swapcase str)\n    (map \n   \
    \  (lambda (char)\n       (if (char-lower-case? char) \n           (char-upper-case?\
    \ char) \n           char)) \n     str))\n  (define (replace-vowels str)\n   \
    \ (map \n     (lambda (char)\n       (if (char-letter? char) \n           (char-upper-case?\
    \ char) \n           char)) \n     str))\n  (define (make-pattern pattern)\n \
    \   (lambda (index)\n      (match index\n        [(0) (list pattern)] \n     \
    \   [(_) (list pattern)])))\n  (define (match pat)\n    (lambda (index)\n    \
    \  (match pat\n        [(list) (match list)]\n        [(list pattern) (pattern)]\n\
    \        [(_) (match pattern)])))\n  (define (match-list pat list)\n    (cond\
    \ \n      [(null? list) (pattern)]\n      [else (match pat \n                \
    \ (match-list \n                   (match (first list) pattern) (rest list))])]))\n\
    \  (define (match-char pat char)\n    (match pat [(char) (char)]\n           \
    \   [(list pattern) (list (pattern (char))])])\n  (define (match-char-list pat\
    \ chars)\n    (cond \n      [(null? chars) (pattern)]\n      [else (match pat\
    \ \n                 (match-char-list \n                   (match-char (first\
    \ chars) pattern) \n                   (rest chars))])]))\n  (define (match-vowel\
    \ pat char)\n    (match pat [(char) (char)]\n              [(list pattern) (list\
    \ (pattern (char))])])\n  (define (match-vowel-list pat chars)\n    (cond \n \
    \     [(null? chars) (pattern)]\n      [else (match pat \n                 (match-vowel-list\
    \ \n                   (match-vowel (first chars) pattern) \n                \
    \   (rest chars))])]))\n  (define (match-letter pat char)\n    (match pat [(char)\
    \ (char)]\n              [(list pattern) (list (pattern (char))])])\n  (define\
    \ (match-lettere-list pat chars)\n    (cond \n      [(null? chars) (pattern)]\n\
    \      [else (match pat \n                 (match-lettere-list \n            \
    \       (match-letter (first chars) pattern) \n                   (rest chars))])]))\n\
    \  (define (match-digit-vowel pat char)\n    (match pat [(char", "  (define (helper\
    \ s i j)\n    (cond [(< i j)\n           (reverse (cons (char->integer (char->symbol\
    \ s)) (helper (cdr s) i (cdr j))))]\n          [(char->boolean (char->symbol s))\n\
    \           (cons (char->integer (char->symbol s)) (helper (cdr s) i (cdr j)))]\n\
    \          [else\n           (helper (cdr s) i (cdr j))]))\n  (helper message\
    \ (length message) 0))\n", "  (let ([char-table (make-cset-table #f (alphabet-chars))])\n\
    \    (map\n     (lambda (x)\n       (let ([found (or (cddr char-table) '#f) (or\
    \ (cddr char-table) '#f)]\n             [new-c (or (cddr char-table) (assoc x\
    \ found)))]\n           (if (eq? found '#f)\n             (set! found new-c)\n\
    \             (set! char-table (cons (caddr char-table) new-c)\n           )))\n\
    \     message)))\n", "  (cond\n    [(empty? message) \"\"]\n    [(empty? (rest\
    \ message)) message]\n    [(char=? (first message) (first 'a)) (concat \n    \
    \                                      (list (first message)) \n             \
    \                             (list (first 'a)))]\n    [(char=? (first message)\
    \ (first 'A)) (concat \n                                          (list (first\
    \ message)) \n                                          (list (first 'A)))]\n\
    \    [(char=? (first message) (first 'w)) (concat \n                         \
    \                 (list (first message)) \n                                  \
    \        (list (first 'w)))]\n    [(char=? (first message) (first 'W)) (concat\
    \ \n                                          (list (first message)) \n      \
    \                                    (list (first 'W)))]\n    [(char=? (first\
    \ message) (first 'z)) (concat \n                                          (list\
    \ (first message)) \n                                          (list (first 'z)))]\n\
    \    [(char=? (first message) (first 'Z)) (concat \n                         \
    \                 (list (first message)) \n                                  \
    \        (list (first 'Z)))]\n    [(char=? (first message) 'a) (concat \n    \
    \                                  (list (first message)) \n                 \
    \                     (list (first 'a)))]\n    [(char=? (first message) 'A) (concat\
    \ \n                                      (list (first message)) \n          \
    \                            (list (first 'A)))]\n    [(char=? (first message)\
    \ 'w) (concat \n                                      (list (first message)) \n\
    \                                      (list (first 'w)))]\n    [(char=? (first\
    \ message) 'W) (concat \n                                      (list (first message))\
    \ \n                                      (list (first 'W)))]\n    [(char=? (first\
    \ message) 'z) (concat \n                                      (list (first message))\
    \ \n                                      (list (first 'z)))]\n    [(char=? (first\
    \ message) 'Z) (concat \n                                      (list (first message))\
    \ \n                                      (list (first 'Z)))]\n    [else\n   \
    \  (concat \n      (list (first message)) \n      (list (first \n          (lambda\
    \ (x) (char-after x \n                            (char-before x \n          \
    \                   (char-before x (+ 1 char-after (first x)))))\n           \
    \      (rest message)))))]))\n", "  (map \n   (lambda (x) (cond \n           \
    \       [(vowel? x) \n                  (make-string (length (map \n         \
    \                          (lambda (y) (char-code (string y x)))\n           \
    \                        (substring (string x) 0 2)\n                        \
    \           (substring (string x) 2 -1))]))]\n                  [else x]))\n \
    \  message))\n</code>\n<|/ a tags=racket,scheme dscore=2 |>\n<| c |>\nThanks alot\
    \ for the help, I think I am getting closer to my final solution now.\n<|/ c |>\n\
    <| c |>\nIt should be noted that `encode` is not a very good name, as it encodes\
    \ strings, not individual characters. It's also not very efficient, because it\
    \ takes quadratic time to find the index of the previous vowel. It's better named\
    \ `swap-case` or `swap-vowels`, or something even better.\n<|/ c |>\n<| c |>\n\
    I knew it wasn't the most efficient way to do it, I'm new to scheme, just trying\
    \ to get my feet wet. Would it be better to do a linear search for the previous\
    \ of the vowels and replace those indices? I'm not too worried about efficiency\
    \ right now since I'm just practicing scheme for fun but I'll keep that in mind.\n\
    <|/ c |>\n<| c |>\nYes, linear search is better. Try it with your examples and\
    \ see how it performs.\n<|/ c |>\n<| a dscore=1 tags=racket,scheme |>\nI realized\
    \ my mistake after I posted this question. Thanks to everyone who posted and I\
    \ appreciate your help. I ended up doing the linear search for the previous vowel\
    \ and then replacing the index with that value.\n<code>", "  (cond [(empty? message)\
    \ #f]\n        [(equal? (caar message) ?A) #A]\n        [(equal? (caar message)\
    \ ?a) #a]\n        [(equal? (caar message) ?1) #1]\n        [(equal? (caar message)\
    \ ?!) #!]\n        [else\n         (cons (encode-letter message)\n           \
    \     (encode (append (substring message 1 (char-length message))\n          \
    \                       (list (encode-letter (car message))))))]\n        ))\n",
  "  (let ((alpha (string->list \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\")))\n    (let loop ((message\
    \ message) (result '()))\n      (cond\n        [(string-equal message \"\") (list\
    \ \"\")]\n        [else (let ((char (string->list (string->string message))))\n\
    \                (cond\n                 [(null? char) (append result (list \"\
    \"))]\n                 [(string=? (car char) \"\") result]\n                \
    \ [else (cond\n                        [((string=? (car char) (caar alpha)) (caadr\
    \ alpha))\n                         (loop (cdr char) (append result (list \"\"\
    )))]\n                        [else (cond\n                                [(string=?\
    \ (cadr char) (caar alpha)) \n                                 (loop (caddr char)\
    \ (append result (list \"\")))]\n                                [else (cond\n\
    \                                        [(string=? (cadr char) (caadr alpha))\
    \ \n                                         (loop (caddr char) (append result\
    \ (list \"\")))]\n                                        [else (cond\n      \
    \                                          [(string=? (cadr char) (caaadr alpha))\
    \ \n                                                 (loop (caddr char) (append\
    \ result (list \"\")))]\n                                                [else\
    \ (cond\n                                                        [(string=? (cadr\
    \ char) (caaaadr alpha)) \n                                                  \
    \       (loop (caddr char) (append result (list \"\")))]\n                   \
    \                                     [else (cond\n                          \
    \                                      [(string=? (cadr char) (caaaaaadr alpha))\
    \ \n                                                                 (loop (caddr\
    \ char) (append result (list \"\")))]\n                                      \
    \                          [else (cond\n                                     \
    \                                   [(string=? (cadr char) (caaaaaaaadr alpha))\
    \ \n                                                                         (loop\
    \ (caddr char) (append result (list \"\")))]\n                               \
    \                                         [else (cond\n                      \
    \                                                          [(string=? (cadr char)\
    \ (caaaaaaaaadr alpha)) \n                                                   \
    \                              (loop (caddr char) (append result (list \"\")))]\n\
    \                                                                            \
    \    [else (cond\n                                                           \
    \                             [(string=? (cadr char) (caaaaaaaaaddr alpha)) \n\
    \                                                                            \
    \             (loop (caddr char) (append result (list \"\")))]\n             \
    \                                                                           [else\
    \ (cond\n                                                                    \
    \                            [(string=? (cadr char) (caaaaaaaaadj alpha)) \n \
    \                                                                            \
    \                    (loop (caddr char) (append result (list \"\")))]\n      \
    \                                                                            \
    \              [else (cond\n                                                 \
    \                                                       [(string=", "  (let loop\
    \ ((i 0) (msg message) (result '()))\n    (if (or (< i 26) (char-alphabetic? i))\
    \ \n        (append result (cons (char-uppercase i) (cons i \"\"))) \n       \
    \ (loop (+ i 2) (substring (char i msg) 1) (cons i result)))))\n", "  (let ((letters\
    \ (string->list message)))\n    (let ((counter (0))\n          (reverse (map (lambda\
    \ (x) (- x counter))\n                        letters)))\n      (let ((vowels\
    \ '(a e i o u)))\n        (let ((vowel-index (assoc 'a vowels))\n            \
    \   (vowel-index-counter (assoc vowel-index (reverse vowels))))\n          (let\
    \ ((v (assoc vowel (reverse vowels))))\n            (let ((vowel-counter (assoc\
    \ 'a vowels)))\n            (if (not (empty? vowel-counter))\n               \
    \ (let ((vc-counter (assoc vowel-counter (reverse vowels))))\n               \
    \   (cons v (encode-helper letters vowel-index vowel-index-counter vc-counter)))))\n\
    \            (let ((vowel-counter (assoc 'a vowels)))\n            (if (not (empty?\
    \ vowel-counter))\n                (let ((vc-counter (assoc vowel-counter (reverse\
    \ vowels))))\n                  (cons v encode-helper letters vowel-index vowel-index-counter\
    \ vc-counter)))))\n        (encode-helper letters vowel-index vowel-index-counter\
    \ counter))))))\n", "  ;; (check-expect (encode \"this\") \"tHKS KS C MGSSCGG\"\
    )\n  (let loop ((message message)\n             (result \"\"))\n    (cond ((null\
    \ message) result)\n          ((char-alphabet (first message))\n           (loop\
    \ (rest message)\n                 (string-append result (encode-char (first message)))))\n\
    \          ((char-alphabet (car message))\n           (loop (rest message)\n \
    \                (string-append result (encode-char (car message)))))\n      \
    \    (else\n           (loop (rest message)\n                  (cons (encode-char\
    \ (first message)) result)))))\n  result)\n", "  (let loop ((i 0)\n          \
    \   (s empty))\n    (if (char? message)\n        s;\n        (loop (+ i 1) (cons\
    \ \n                      (substring \n                       (string->list (string->char\
    \ message)) \n                       (substring \n                       (string->list\
    \ (string->char message)) \n                       (+ i (string-length message)))\
    \ \n                       s)))))\n", "  (let loop ((msg (reverse message)))\n\
    \    (cond\n      [(empty? msg) (string \"\")]\n      [(equal? (first msg) ?a)\
    \ (cons (first msg) (loop (rest msg)))]\n      [(equal? (first msg) ?e) (cons\
    \ (first msg) (loop (rest msg)))]\n      [(equal? (first msg) ?i) (cons (first\
    \ msg) (loop (rest msg)))]\n      [(equal? (first msg) ?o) (cons (first msg) (loop\
    \ (rest msg)))]\n      [(equal? (first msg) ?u) (cons (first msg) (loop (rest\
    \ msg)))]\n      [(equal? (first msg) ?A) (cons (first msg) (loop (rest msg)))]\n\
    \      [(equal? (first msg) ?E) (cons (first msg) (loop (rest msg)))]\n      [(equal?\
    \ (first msg) ?I) (cons (first msg) (loop (rest msg)))]\n      [(equal? (first\
    \ msg) ?O) (cons (first msg) (loop (rest msg)))]\n      [(equal? (first msg) ?U)\
    \ (cons (first msg) (loop (rest msg)))]\n      [else (cons (first msg) (loop (rest\
    \ msg)))])))\n", "  (let ([a (map string ['(a a a a) (a a a a) (a a a a) (a a\
    \ a a) (a a a a) \n                      (a a a a) (a a a a) (a a a a) (a a a\
    \ a) (a a a a) \n                      (a a a a) (a a a a) (a a a a) (a a a a)\
    \ (a a a a)\n                      (a a a a) (a a a a) (a a a a) (a a a a) (a\
    \ a a a)\n                      (a a a a) (a a a a) (a a a a) (a a a a) (a a a\
    \ a)\n                      (a a a a) (a a a a) (a a a a) (a a a a) (a a a a)\n\
    \                      (a a a a) (a a a a) (a a a a) (a a a a) (a a a a)\n   \
    \                   (a a a a) (a a a a) (a a a a) (a a a a) (a a a a)\n      \
    \                (a a a a) (a a a a) (a a a a) (a a a a) (a a a a)\n         \
    \             (a a a a) (a a a a) (a a a a) (a a a a) (a a a a)\n            \
    \          (a a a a) (a a a a) (a a a a) (a a a a) (a a a a)\n               \
    \       (a a a a) (a a a a) (a a a a) (a a a a) (a a a a)\n                  \
    \    (a a a a) (a a a a) (a a a a) (a a a a) (a a a a) \n                    \
    \  (a a a a) (a a a a) (a a a a) (a a a a) (a a a a) \n                      (a\
    \ a a a) (a a a a) (a a a a) (a a a a) (a a a a) \n                      (a a\
    \ a a) (a a a a) (a a a a) (a a a a) (a a a a)\n                      (a a a a)\
    \ (a a a a) (a a a a) (a a a a) (a a a a) \n                      (a a a a) (a\
    \ a a a) (a a a a) (a a a a) (a a a a) \n                      (a a a a) (a a\
    \ a a) (a ", "  (define (swap-case message)\n    (string-replace message #\"([a-zA-Z])\"\
    \ #(toUpperCase (substring % 0 1))))\n  (define (replace-vowels message)\n   \
    \ (string-replace message #\"[aeiou]\" #(substring % 0 1)))\n  (swap-case (replace-vowels\
    \ message)))\n</code>\n<|/ a dscore=0 |>\n<| c |>\nI guess I just need to learn\
    \ more racket.\n<|/ c |>\n<| c |>\nThe program as it is now is definitely not\
    \ the best solution, but it answers the question (albeit somewhat vaguely).\n\
    <|/ c |>\n<| c |>\nI think there's a problem with the program because in some\
    \ cases it won't run and outputs the wrong output.\n<|/ c |>\n<| c |>\n- It looks\
    \ like there are some typos in my answer.  Have you tried running it?  I believe\
    \ I have it working.  If you have specific cases that it doesn't work for, please\
    \ post the error message and I'll see if I can figure out what's going wrong.\n\
    <|/ c |>\n<| c |>\nThis isn't really a programming problem so much as an algorithm,\
    \ so I wouldn't really expect it to be a good fit.\n<|/ c |>\n<| a dscore=0 |>\n\
    This was a fun one. Here's my solution:\n<code>", "  (cond\n    [(string? message)\
    \ (encode (string message))]\n    [(number? message)\n     (cond\n       [(< message\
    \ 26)\n        (let* ([vowel (char-ref (lambda (x) (char-code x)) 'a)]\n     \
    \          [next-vowel (char-ref (lambda (x) (char-code x)) 'z)]\n           \
    \    [position (modulo message 26)]\n               [letter (substring alphabet\
    \ position)]\n               [next-letter (substring alphabet (+ position 1)))]\n\
    \          (cond [(= letter vowel)\n                 (char-code (substring alphabet\
    \ (+ position 1)))]\n                 [(= position 1)\n                   (cons\
    \ letter next-letter)]\n                 [(= position 2)\n                   (cons\
    \ (char-code (substring alphabet (+ position 1))) next-letter)]\n            \
    \     [(= position 3)\n                   (cons (char-code (substring alphabet\
    \ (+ position 1))) next-letter)\n                   (cons (char-code (substring\
    \ alphabet (+ position 2))) next-letter)]\n                 [(= position 4)\n\
    \                   (cons (char-code (substring alphabet (+ position 1))) next-letter)\n\
    \                   (cons (char-code (substring alphabet (+ position 2))) next-letter)\n\
    \                   (cons (char-code (substring alphabet (+ position 3))) next-letter)]\n\
    \                 [(= position 5)\n                   (cons (char-code (substring\
    \ alphabet (+ position 1))) next-letter)\n                   (cons (char-code\
    \ (substring alphabet (+ position 2))) next-letter)\n                   (cons\
    \ (char-code (substring alphabet (+ position 3))) next-letter)\n             \
    \      (cons (char-code (substring alphabet (+ position 4))) next-letter)]\n \
    \                [(= position 6)\n                   (cons (char-code (substring\
    \ alphabet (+ position 1))) next-letter)\n                   (cons (char-code\
    \ (substring alphabet (+ position 2))) next-letter)\n                   (cons\
    \ (char-code (substring alphabet (+ position 3))) next-letter)\n             \
    \      (cons (char-code (substring alphabet (+ position 4))) next-letter)\n  \
    \                 (cons (char-code (substring alphabet (+ position 5))) next-letter)]\n",
  "  (loop\n   [index 0]\n   [messages (list message)] \n   (cond [(empty? messages)\
    \ message]\n         [else (cond \n                  [(equal? (char-ref (first\
    \ messages) index) 'a) (char-append (char-ref (first messages) index) \n     \
    \                                                                         (char-ref\
    \ (first messages) (+ index 1)))]\n                  [else (cond \n          \
    \                 [(equal? (char-ref (first messages) index) 'u) (char-append\
    \ (char-ref (first messages) index) \n                                       \
    \                                           (char-ref (first messages) (+ index\
    \ 1)))]\n                           [else (cond \n                           \
    \         [(equal? (char-ref (first messages) index) 'e) (char-append (char-ref\
    \ (first messages) index) \n                                                 \
    \                                    (char-ref (first messages) (+ index 1)))]\n\
    \                                    [else (cond \n                          \
    \                 [(equal? (char-ref (first messages) index) 'i) (char-append\
    \ (char-ref (first messages) index) \n                                       \
    \                                                    (char-ref (first messages)\
    \ (+ index 1)))]\n                                           [else (cond \n  \
    \                                                  [(equal? (char-ref (first messages)\
    \ index) 'o) (char-append (char-ref (first messages) index) \n               \
    \                                                                            \
    \            (char-ref (first messages) (+ index 1)))]\n                     \
    \                               [else (cond \n                               \
    \                              [(equal? (char-ref (first messages) index) 'u)\
    \ (char-append (char-ref (first messages) index) \n                          \
    \                                                                            \
    \            (char-ref (first messages) (+ index 1)))]\n                     \
    \                                        [else (cond \n                      \
    \                                              [(equal? (char-ref (first messages)\
    \ index) 'a) (char-append (char-ref (first messages) index) \n               \
    \                                                                            \
    \                              (char-ref (first messages) (+ index 1)))]\n   \
    \                                                                 [else (cond\
    \ \n                                                                         \
    \          [(equal? (char-ref (first messages) index) 'e) (char-append (char-ref\
    \ (first messages) index) \n                                                 \
    \                                                                        (char-ref\
    \ (first messages) (+ index 1)))]\n                                          \
    \                                         [else (cond \n                     \
    \                                                                        [(equal?\
    \ (char-ref (first messages) index) 'o) (char-append (char-ref (first messages)\
    \ index) \n                                                                  \
    \                                                                (char-ref (first\
    \ messages) (+ index 1)))]\n                                                 \
    \                                            [else (cond \n                  \
    \                                                                            \
    \        [(equal? (char-ref (", "  (let ((alphabet\n         (list \"A\" \"B\"\
    \ \"C\" \"D\" \"E\" \"F\" \"G\" \"H\" \"I\" \"J\" \"K\" \"L\" \"M\" \"N\" \"O\"\
    \ \"P\" \"Q\" \"R\" \"S\" \"T\" \"U\" \"V\" \"W\" \"X\" \"Y\" \"Z\")))\n    (let\
    \ ((encoded-message '()))\n      (for-each (lambda (word)\n                  (for-each\
    \ (lambda (character)\n                              (cond\n                 \
    \               ((equal? (char-after character alphabet) 0)\n                \
    \                 (string->list character))\n                                (else\
    \ (string->list (char-after character alphabet))))\n                         \
    \     (append\n                               (append (list word)\n          \
    \                              (list (char-before (char-after character alphabet)\n\
    \                                                      (get-index-of\n       \
    \                                                 (equal? character alphabet)\n\
    \                                                        (list-ref alphabet (char-after\
    \ (char-after character alphabet) alphabet))))))))\n                    message))\n\
    \    (for-each (lambda (word)\n                (for-each (lambda (character)\n\
    \                          (cond\n                            ((equal? (char-after\
    \ character alphabet) 0)\n                             (string->list character))\n\
    \                            (else (string->list (char-after character alphabet))))\n\
    \                          (append\n                           (append (list word)\n\
    \                                    (list (char-before (char-after character\
    \ alphabet)\n                                                  (get-index-of\n\
    \                                                    (equal? character alphabet)\n\
    \                                                    (list-ref alphabet (char-after\
    \ (char-after character alphabet) alphabet))))))))\n              (append encoded-message\n\
    \                     (list (string->list (string->string message))))))))\n</code>\n\
    <|/ a dscore=0 |>\n<| a tags=racket,scheme,string,list |>\nI would use a lookup\
    \ table to speed things up significantly:\n<code>", "  (let ((message message))\n\
    \    (define (swap-case string)\n      (map \n       (lambda (letter)\n      \
    \   (let ((letter (char->integer (substring letter 0 1))))\n           (cond\n\
    \            ((or (= letter #\\A)\n                 (= letter #\\z))\n       \
    \      (substring string 0 1))\n            (else \n             (substring string\
    \ 0 2))))))\n    (define (vowel-letter letter)\n      (substring letter (+ letter\
    \ 1)))\n    (define (find-vowel letter)\n      (let ((i (char->integer (substring\
    \ letter 0 1))))\n        (cond\n          ((= letter #\\A)\n           (substring\
    \ letter 1 1))\n          (else \n           (substring letter 2 2))))\n    (define\
    \ (replace-vowel letter index)\n      (let ((index (substring index 1 1)))\n \
    \       (cond\n          ((= index 0)\n           (substring letter 2 2))\n  \
    \        ((or (= index 1)\n               (= index 2))\n           (substring\
    \ letter 2 2))\n          ((or (= index 2)\n               (= index 3))\n    \
    \       (substring letter 0 1))))\n    (define (index-of-vowel letter)\n     \
    \ (let ((i (char->integer (substring letter 0 1))))\n        (cond\n         \
    \ ((= letter #\\A)\n           (substring letter 1 1))\n          (else \n   \
    \        (substring letter 2 2))))\n    (define (index-of-finger letter)\n   \
    \   (let ((i (char->integer (substring letter 0 1))))\n        (cond\n       \
    \   ((= letter #\\A)\n           (substring letter 1 1))\n          (else \n \
    \          (substring letter 2 2))))\n    (define (index-of-pillow letter)\n \
    \     (let ((i (char->integer (substring letter 0 1))))\n        (cond\n     \
    \     ((= letter #\\A)\n           (substring letter 1 1))\n          (else \n\
    \           (substring letter 2 2))))\n    (define (index-of-finger-and-pillow\
    \ letter)\n      (let ((i (char->integer (substring letter 0 1))))\n        (cond\n\
    \          ((= letter #\\A)\n           (substring letter 1 1))\n          (else\
    \ \n           (substring letter 2 2))))\n    (define (finger-and-pillow-case\
    \ letter)\n      (substring letter 0 1))\n    (define (finger-and-pillow-case\
    \ letter)\n      (substring letter 0 1))\n    (define (finger-and-pillow-case\
    \ letter", "  (cond [(empty? message) empty]\n        [(alpha? (first message))\
    \ \n         (encode-alpha (first message))\n         (encode-alpha (second message))]\n\
    \        [else \n         (encode-other (first message))\n         (encode-other\
    \ (second message))]\n        ))\n", "  ;; Base case: no vowels anywhere in the\
    \ string.\n  (cond\n    [(empty? message) message]\n    [else\n     (loop\n  \
    \     [a #f]\n       [s #t ]\n       (if (or (null? (string-ref message 0)) \n\
    \              (null? (string-ref message -1)))\n           [s] \n           (cond\n\
    \             [(member (char->string (char->integer char)) \n                \
    \      (list 'a #b 'e #f #i #o 'u 'y '\xF8 '\xE6 '\xC6 '\xDE '\xDC)) a]\n    \
    \         [(member (char->string (char->integer char)) \n                    \
    \  (list 'A #B 'E #F 'I #O 'U 'Y '\xD8 '\xC6 '\xDE '\xDC)) a]\n             [(member\
    \ (char->string (char->integer char)) \n                      (list 'E #F 'I #O\
    \ 'U 'Y '\xD8 '\xC6 '\xDE '\xDC)) a]\n             [(member (char->string (char->integer\
    \ char)) \n                      (list 'I #O 'U 'Y '\xD8 '\xC6 '\xDE '\xDC)) a]\n\
    \             [(member (char->string (char->integer char)) \n                \
    \      (list 'O 'U 'Y '\xD8 '\xC6 '\xDE '\xDC)) a]\n             [(member (char->string\
    \ (char->integer char)) \n                      (list 'U 'Y '\xD8 '\xC6 '\xDE\
    \ '\xDC)) a]\n             [(member (char->string (char->integer char)) \n   \
    \                   (list 'Y '\xD8 '\xC6 '\xDE '\xDC)) a]\n             [(member\
    \ (char->string (char->integer char)) \n                      (list '\xD8 '\xC6\
    \ '\xDE '\xDC)) a]\n             [(member (char->string (char->integer char))\
    \ \n                      (list '\xC6 '\xDE '\xDC)) a]\n             [else s])\n\
    \           (loop\n             [(char->string (+ a (char->integer char)))]\n\
    \             (char->string (+ (char->integer char) (char->integer char)))\n \
    \            (char->string (+ a (char->integer char)))))]))]))\n", "  (let ((vowels\
    \ '(a e i o u)))\n    (cond ((null? message) '())\n          ((equal? (char-ref\
    \ message 0) #\\a) #\\a)\n          ((equal? (char-ref message 0) #\\e) #\\e)\n\
    \          ((equal? (char-ref message 0) #\\i) #\\i)\n          ((equal? (char-ref\
    \ message 0) #\\o) #\\o)\n          ((equal? (char-ref message 0) #\\u) #\\u)\n\
    \          ((equal? (char-ref message 0) #\\U) #\\U)\n          ((char-equal?\
    \ (char-ref message 0) #\\a #\\a) #\\a message)\n          ((char-equal? (char-ref\
    \ message 0) #\\e #\\e) #\\e message)\n          ((char-equal? (char-ref message\
    \ 0) #\\i #\\i) #\\i message)\n          ((char-equal? (char-ref message 0) #\\\
    o #\\o) #\\o message)\n          ((char-equal? (char-ref message 0) #\\u #\\u)\
    \ #\\u message)\n          ((char-equal? (char-ref message 0) #\\U #\\U) #\\U\
    \ message)\n          ((char-equal? (char-ref message 0) #\\a #\\y) #\\y message)\n\
    \          ((char-equal? (char-ref message 0) #\\e #\\y) #\\y message)\n     \
    \     ((char-equal? (char-ref message 0) #\\i #\\y) #\\y message)\n          ((char-equal?\
    \ (char-ref message 0) #\\o #\\y) #\\y message)\n          ((char-equal? (char-ref\
    \ message 0) #\\u #\\y) #\\y message)\n          ((char-equal? (char-ref message\
    \ 0) #\\U #\\y) #\\y message)\n          ((char-equal? (char-ref message 0) #\\\
    a #\\a) #\\a message)\n          ((char-equal? (char-ref message 0) #\\e #\\a)\
    \ #\\a message)\n          ((char-equal? (char-ref message 0) #\\i #\\a) #\\a\
    \ message)\n          ((char-equal? (char-ref message 0) #\\o #\\a) #\\a message)\n\
    \          ((char-equal? (char-ref message 0) #\\u #\\a) #\\a message)\n     \
    \     ((char-equal? (char-ref message 0) #\\U #\\a) #\\a message)\n          ((char-equal",
  "  (encode-helper message (subseq \"aeiouAEIOU\" 0 0) (subseq \"aeiouAEIOU\" 1 1)))\n",
  "  (let ((letters (string (to-string message)))) \n    (let ((vowels '(a e i o u\
    \ Ae Ei Oe Uu)))\n      (let ((vowel-pairs '(\n        (a b) \n        (e f)\n\
    \        (i (l N N N) O P P P S S S W W W)\n        (u y y y y y y y y y y y y\
    \ y y)\n        (Aa Ee Ii Oo Uu aa ee ii oo uu)\n      )))\n        (let ((pairs\
    \ (make-list 26))))\n          (let loop ((i 0)\n                     (newstring\
    \ \"\"))\n            (if (< i 26)\n                (set! newstring (+ newstring\
    \ letters))\n                (set! newstring (+ newstring vowels))\n         \
    \       (set! newstring (+ newstring vowel-pairs))\n                (set! newstring\
    \ (+ newstring letters))\n                (set! newstring (+ newstring letters))\n\
    \                (set! newstring (+ newstring letters))\n                (set!\
    \ newstring (+ newstring letters))\n                (set! newstring (+ newstring\
    \ letters))\n                (set! newstring (+ newstring letters))\n        \
    \        (set! newstring (+ newstring letters))\n                (set! newstring\
    \ (+ newstring letters))\n                (set! newstring (+ newstring letters))\n\
    \                (set! newstring (+ newstring letters))\n                (set!\
    \ newstring (+ newstring letters))\n                (set! newstring (+ newstring\
    \ letters))\n                (set! newstring (+ newstring letters))\n        \
    \        (set! newstring (+ newstring letters))\n                (set! newstring\
    \ (+ newstring letters))\n                (set! newstring (+ newstring letters))\n\
    \                (set! newstring (+ newstring letters))\n                (set!\
    \ newstring (+ newstring letters))\n                (set! newstring (+ newstring\
    \ letters))\n                (set! newstring (+ newstring letters))\n        \
    \        (set! newstring (+ newstring letters))\n                (set! newstring\
    \ (+ newstring letters))\n                (set! newstring (+ newstring letters))\n\
    \                (set! newstring (+ newstring letters))\n                (set!\
    \ newstring (+ newstring letters))\n                (set! newstring (+ newstring\
    \ letters))\n                (set! newstring (+ newstring letters))\n        \
    \        (set! newstring (+ newstring letters))\n                (set! newstring\
    \ (+ newstring letters))\n                (set! newstring (+ newstring letters))\n\
    \                (set! ", "  (map \n   (lambda (x)\n     (let ([i (char-position\
    \ x #\\a)])\n       (if (< i 2)\n           (string->symbol (char-before-position\
    \ x i))\n           (string->symbol (char-after-position x i)))) \n   message))\n",
  "  (let ((new (list #\\a #\\b #\\f #\\h #\\i #\\j #\\k #\\l #\\m #\\n #\\o #\\p\
    \ #\\q #\\r #\\s #\\t #\\v #\\w #\\x #\\y)))\n    (cond\n      [(string=? (string-length\
    \ message) (string-length new)) (append message new)]\n      [(string=? (string-length\
    \ message) (string-length new)) (string-append message new)]\n      [else\n  \
    \     (loop for c across message\n           collect (cat (find new c) (cdr new))\n\
    \           into s\n           collect (append s (list (car message)))\n     \
    \      into final\n           finally (set! new (reverse final))])]))\n", "  (let\
    \ ([english-chars '(a b c d e f g h i j k l m n o p q r s t u v w x y z)]\n  \
    \      [vowels '(a e i o u)])\n    (string->symbols (string->list message)\n \
    \                 (lambda (x y)\n                    (cond\n                 \
    \     [(and (equal? (first x) a) (equal? (first y) e)) (first x)\n           \
    \            [(and (equal? (first x) a) (equal? (first y) i)) (first y)\n    \
    \                    [(and (equal? (first x) a) (equal? (first y) o)) (first y)\n\
    \                         [(and (equal? (first x) a) (equal? (first y) u)) (first\
    \ y)\n                          [else (first y)]]])))))))\n", "  (letfn [(index-of\
    \ ([x y] m) (cond [(<= x y) 0] [(= y 0) (+ 1 (index-of x m))]))]\n    (cond\n\
    \      [(empty? message) empty]\n      [(char-uppercase? (first message)) (cons\
    \ (first message) (encode-uppercase (subseq message 1)))]\n      [(char-lowercase?\
    \ (first message)) (cons (first message) (encode-lowercase (subseq message 1)))]\n\
    \      [(char-whitespace? (first message)) (cons (first message) (encode-whitespace\
    \ (subseq message 1)))]\n      [(char-digit? (first message)) (cons (first message)\
    \ (encode-digit (subseq message 1)))]\n      [else (cons (first message) (encode-special\
    \ (subseq message 1)))]\n      )\n    )\n  )\n", "  (cond ((null? message) \"\"\
    )\n        ((char-alphabet (first message)) (encode-char (first message)))\n \
    \       (else (encode-consonants (first message)))))\n", "  (cond\n    [(empty?\
    \ message) empty]\n    [(equal? (car message) (string-length (encode-first (car\
    \ message))))\n     (append (encode-first (car message)) (encode (rest message)))]\n\
    \    [else (append (encode-first (car message)) (encode (rest message)))]))\n",
  "  (let ((letters '(#\\g #\\f #\\l #\\o #\\w #\\r #\\i #\\d #\\s #\\m #\\p)))\n\
    \    (map (lambda (x)\n           (let ((f (substring letters (farm x) 1)))\n\
    \             (if (char= x f) (substring letters x) x)))\n         (remove-if\
    \ (lambda (x) \n                     (char= x #f))\n                    (remove-if\
    \ (lambda (x) \n                                (substring letters x)) message))))\n",
  "  (let loop ((message (list message)))\n    (cond ((null? message) '())\n     \
    \     ((not (member? (car message) '(A e I o u y))) message)\n          ((= (car\
    \ (car message)) 'a) (loop (cdr message)))\n          ((= (car (car message))\
    \ 'e) (loop (cdr (cdr message))))\n          ((= (car (car message)) 'i) (loop\
    \ (cdr (cdr (cdr message)))))\n          ((= (car (car message)) 'o) (loop (cdr\
    \ (cdr (cdr (cdr message)))))\n          ((= (car (car message)) 'u) (loop (cdr\
    \ (cdr (cdr (cdr (cdr message)))))) \n          ((= (car (car message)) 'y) (loop\
    \ (cdr (cdr (cdr (cdr (cdr (cdr message)))))) \n          ((= (car (car message))\
    \ 'A) (loop (cdr (cdr (cdr (cdr (cdr (cdr (cdr message)))))) ))\n          ((=\
    \ (car (car message)) 'E) (loop (cdr (cdr (cdr (cdr (cdr (cdr (cdr message))))))\
    \ ))\n          ((= (car (car message)) 'I) (loop (cdr (cdr (cdr (cdr (cdr (cdr\
    \ (cdr (cdr message)))))) )) \n          ((= (car (car message)) 'O) (loop (cdr\
    \ (cdr (cdr (cdr (cdr (cdr (cdr (cdr message)))))) )) ) \n          ((= (car (car\
    \ message)) 'U) (loop (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr message)))))) ))\
    \ ) \n          ((= (car (car message)) 'Y) (loop (cdr (cdr (cdr (cdr (cdr (cdr\
    \ (cdr (cdr (cdr message)))))) )) ) \n          (else (append (loop (cdr (cdr\
    \ (cdr (cdr (cdr (cdr (cdr (cdr (cdr", "  (let ([c (char->integer (string->char\
    \ (char->string message) 2))])\n    (cond\n      [(char->number? (car message))\n\
    \       (string->char (char->string message) (+ c 1))]\n      [(char->number?\
    \ (cdr message))\n       (string->char (char->string message) (+ c 1))]\n    \
    \  [else\n       (string->char (char->string message) c)])))\n", "  ; TODO: Write\
    \ the encode function here\n  (displayln \"Not implemented\")\n  (encode \"test\"\
    )\n  (encode \"This is a message\"))\n", "  (define (helper-swap-case letter)\n\
    \    (if (string-equal? letter #\\a)\n        #\\A\n        (string-append \n\
    \         (char->string #\\A - letter) \n         (char->string letter))))\n \
    \ (define (helper-replace vowel char)\n    (string-append \n     (char->string\
    \ #\\A - vowel) \n     (char->string vowel char)))\n  (define (helper-count vowel)\n\
    \    (string-length \n     (string->list\n      (substring (helper-replace vowel\
    \ #\\a) 0 2)) \n     (helper-replace vowel #\\a)))\n  (define (helper-encode char\
    \ vowel-count)\n    (if (or (char->string #\\a - char) (char->string char - #\\\
    a))\n        (string-append \n         (char->string #\\A - char) \n         (list\
    \ \n           (helper-swap-case char)\n           (helper-count vowel-count))\n\
    \        (char->string char)))\n  (apply \n   (lambda (char)\n     (helper-encode\
    \ char 0))))\n", "  (map \n   (lambda (c) (cond [(= c ?a) (append 'g ?g)] [else\
    \ c]))\n   (map \n    (lambda (c) (cond [(= c ?o) (append 'i ?i)] [else c]))\n\
    \    (map \n     (lambda (c) (cond [(= c ?u) (append 'u ?u)] [else c]))\n    \
    \ (map \n      (lambda (c) (cond [(= c ?a) (append 'b ?b)] [else c]))\n      (map\
    \ \n       (lambda (c) (cond [(= c ?i) (append 'f ?f)] [else c]))\n       (map\
    \ \n        (lambda (c) (cond [(= c ?u) (append 'v ?v)] [else c]))\n        (map\
    \ \n         (lambda (c) (cond [(= c ?a) (append 'r ?r)] [else c]))\n        \
    \ (map \n          (lambda (c) (cond [(= c ?i) (append 'w ?w)] [else c]))\n  \
    \        (map \n           (lambda (c) (cond [(= c ?u) (append 'y ?y)]\n     \
    \                    [else c])))\n         (map \n          (lambda (c) (cond\
    \ [(= c ?a) (append 't ?t)] [else c]))\n          (map \n           (lambda (c)\
    \ (cond [(= c ?i) (append 's ?s)] [else c]))\n           (map \n            (lambda\
    \ (c) (cond [(= c ?u) (append 'd ?d)] [else c]))\n            (map \n        \
    \     (lambda (c) (cond [(= c ?a) (append 'c ?c)] [else c]))\n             (map\
    \ \n               (lambda (c) (cond [(= c ?i) (append 'm ?m)] [else c]))\n  \
    \             (map \n                (lambda (c) (cond [(= c ?u) (append 'n ?n)]\
    \ [else c]))\n                (map \n                 (lambda (c) (cond [(= c\
    \ ?a) (append 'k ?k)] [else c]))\n                 (map \n                  (lambda\
    \ (c) (cond [(= c ?i) (append 'l ?l)] [else c]))\n                  (map \n  \
    \                 (lambda (c) (cond [(= c ?u) (append 'o ?o)] [else c]))\n   \
    \                (map \n                    (lambda (c) (cond [(= c ?a) (append\
    \ 'g ?g)] [else c]))\n                    (map \n                     (lambda\
    \ (c) (cond [(= c ?i) (append 'j ?j)] [else c]))\n", "  (define (count-vowels\
    \ word)\n    (define (vowels-in-word word)\n      (cond\n        [(empty? word)\
    \ 0]\n        [(equal? word #\\a) (+ 1 (vowels-in-word (rest word)))]\n      \
    \  [(equal? word #\\b) (+ 1 (vowels-in-word (rest word)))]\n        [(equal? word\
    \ #\\c) (+ 1 (vowels-in-word (rest word)))]\n        [(equal? word #\\d) (+ 1\
    \ (vowels-in-word (rest word)))]\n        [(equal? word #\\e) (+ 1 (vowels-in-word\
    \ (rest word)))]\n        [(equal? word #\\f) (+ 1 (vowels-in-word (rest word)))]\n\
    \        [(equal? word #\\g) (+ 1 (vowels-in-word (rest word)))]\n        [(equal?\
    \ word #\\h) (+ 1 (vowels-in-word (rest word)))]\n        [(equal? word #\\i)\
    \ (+ 1 (vowels-in-word (rest word)))]\n        [(equal? word #\\j) (+ 1 (vowels-in-word\
    \ (rest word)))]\n        [(equal? word #\\k) (+ 1 (vowels-in-word (rest word)))]\n\
    \        [(equal? word #\\l) (+ 1 (vowels-in-word (rest word)))]\n        [(equal?\
    \ word #\\n) (+ 1 (vowels-in-word (rest word)))]\n        [(equal? word #\\o)\
    \ (+ 1 (vowels-in-word (rest word)))]\n        [(equal? word #\\p) (+ 1 (vowels-in-word\
    \ (rest word)))]\n        [(equal? word #\\r) (+ 1 (vowels-in-word (rest word)))]\n\
    \        [(equal? word #\\s) (+ 1 (vowels-in-word (rest word)))]\n        [(equal?\
    \ word #\\t) (+ 1 (vowels-in-word (rest word)))]\n        [(equal? word #\\v)\
    \ (+ 1 (vowels-in-word (rest word)))]\n        [else 0]))\n    (let loop ((word\
    \ word) (vowels 0))\n      (cond\n        [(empty? word) vowels]\n        [(equal?\
    \ word #\\a) (+ 1 (vowels-in-word (rest word)))]\n        [(equal? word #\\b)\
    \ (+ 1 (vowels-in-word (rest word)))]\n        [(equal? word #\\c) (+ 1 (vowels-in-word\
    \ (rest word)))]", "  (define (enc-helper message result index vowels)\n    (cond\
    \ [(null? message) result]\n          [else (enc-helper\n                   (cdr\
    \ message)\n                   (append result (list (list (char (ascii-value (char\
    \ message))\n                                           (char (ascii-value (char\
    \ result))\n                                           vowels))\n            \
    \                     (list (char (ascii-value (char (car message)))\n       \
    \                                  (char (ascii-value (char (car result))\n  \
    \                                         vowels))))))\n               (+ index\
    \ (* 2 vowels))\n               vowels]\n         [else (enc-helper\n        \
    \           (cdr message)\n                   (append result (list (list (char\
    \ (ascii-value (char message))\n                                           (char\
    \ (ascii-value (char result)))\n                                           vowels))\n\
    \                                 (list (char (ascii-value (char (car message)))\n\
    \                                         (char (ascii-value (char (car result)))))\n\
    \                                   vowels))\n               (+ index (* 1 vowels))\n\
    \               vowels]))\n\n  (enc-helper message '() 0 '()))\n  ", "  (cond\n\
    \    ((= 1 (string-length message))\n     (string-append message \"ay\"))\n  \
    \  ((= 2 (string-length message))\n     (string-append message \"eay\"))\n   \
    \ ((= 3 (string-length message))\n     (string-append message \"iay\"))\n    ((=\
    \ 4 (string-length message))\n     (string-append message \"oay\"))\n    ((= 5\
    \ (string-length message))\n     (string-append message \"uay\"))\n    ((= 6 (string-length\
    \ message))\n     (string-append message \"ay\"))\n    ((< 5 (string-length message))\n\
    \     (string-append message \"ay\"))\n    ((< 6 (string-length message))\n  \
    \   (string-append message \"ay\"))\n    ((= 1 (string-length message))\n    \
    \ (string-append message \"ay\"))\n    ((= 2 (string-length message))\n     (string-append\
    \ message \"ay\"))\n    ((= 3 (string-length message))\n     (string-append message\
    \ \"ay\"))\n    ((= 4 (string-length message))\n     (string-append message \"\
    ay\"))\n    ((= 5 (string-length message))\n     (string-append message \"ay\"\
    ))\n    ((= 6 (string-length message))\n     (string-append message \"ay\"))\n\
    \    ((< 5 (string-length message))\n     (string-append message \"ay\"))\n  \
    \  ((< 6 (string-length message))\n     (string-append message \"ay\"))\n    ((<\
    \ 7 (string-length message))\n     (string-append message \"ay\"))\n    ((< 8\
    \ (string-length message))\n     (string-append message \"ay\"))\n    ((< 9 (string-length\
    \ message))\n     (string-append message \"ay\"))\n    ((< 10 (string-length message))\n\
    \     (string-append message \"ay\"))\n    ((< 11 (string-length message))\n \
    \    (string-append message \"ay\"))\n    ((< 12 (string-length message))\n  \
    \   (string-append message \"ay\"))\n    ((< 13 (string-length message))\n   \
    \  (string-append message \"ay\"))\n    ((< 14 (string-length message))\n    \
    \ (string-append message \"ay\"))\n    ((< 15 (string-length message))\n     (string-append\
    \ message \"ay\"))\n    ((< 16 (string-length message))\n     (string-append message\
    \ \"ay\"))\n    ((< 17 (string-length message))\n     (string-append message \"\
    ay\"))\n    ((< 18 (string-length message))\n     (string-append message \"ay\"\
    ))\n    ((< 19 (string-length message))\n     (string-append message \"ay\"))\n\
    \    ((< 20 (string-length message))\n     (string-append message \"ay\"))\n \
    \   ((", "  (map #(if (member % '(a e i o u)) (+ % ((hash-ref '(a e i o u) %)))\
    \ %) \n       (map char-code (map ord message))))\n", "  (let* ([message (encapsulate\
    \ (all-letters message))\n         vowels '(a e i o u)\n         letters '(A E\
    \ I O U)]\n         (letters-map '())\n         (vowels-map '()))\n    (for-each\n\
    \     (lambda (letter)\n       (if (member letter letters)\n           (map cons\
    \ letters-map letter)\n           (map cons vowels-map letter))\n       (let*\
    \ ([letter-map (cons letter letters-map)]\n              [vowel-map (cons letter\
    \ vowels-map)])\n         (cons vowel-map letter-map))\n       (push letter letters-map)\n\
    \       (push letter vowels-map))\n    message)\n    (for-each (lambda (letter)\n\
    \               (let ([letter-map (nthcdr (car letter-map) letters)])\n      \
    \           (cond \n                  [(empty? letter-map)\n                 \
    \  (push letter letters-map)\n                   (push letter vowels-map)]\n \
    \                 [else\n                   (push letter vowels-map)\n       \
    \            (push letter letters-map)])\n               letter-map)\n       \
    \        (reverse vowels-map))\n              (reverse letters-map))\n    (encapsulate\
    \ (reverse vowels-map))\n    ))", "  (let loop ((result '())\n             (message\
    \ (list->string (remove-vowels message)))\n             (vowels '(a e i o u y\
    \ e)))\n    (if (empty? message) \n        result\n        (loop (concat result\
    \ (encode-char (first message) vowels)) \n               (rest message)\n    \
    \           vowels))))\n", "  (let ((result '()))\n    (for-each (lambda (letter)\n\
    \              (for-each (lambda (vowel)\n                        (cond\n    \
    \                      [(char=? vowel (char-after (char-after letter (char-length\
    \ vowel))))\n                           (char-append (make-string 1 (char-length\
    \ (char-after letter (char-length vowel))) #\\1))\n                          \
    \ [else\n                             (char-append (make-string 1 (char-length\
    \ (char-after letter (char-length vowel))) letter))]))\n                     \
    \  (append result (make-string 1 (char-length (char-after letter (char-length\
    \ vowel))) letter))))\n               (append result (make-string 1 (char-length\
    \ letter) letter))))\n    (string-join result #\\)))\n", "  (cond\n    [(empty?\
    \ message) \"\"]\n    [(equal? (caar message) (first message))\n     (cons (cadr\
    \ message)\n           (encode (substring message 1 (cdr message))))]\n    [else\n\
    \     (cons (first message)\n           (encode (substring message 1 (length message))))]))\n",
  "  (define (swap-case-letter letter)\n    (cond\n      [(char=? (char-code letter)\
    \ #\\A) #\\a]\n      [(char=? (char-code letter) #\\Z) #\\z]\n      [else letter]))\n\
    \  (define (count-vowels letter)\n    (cond\n      [(char=? (char-code letter)\
    \ #\\a) #\\1]\n      [(char=? (char-code letter) #\\e) #\\2]\n      [(char=? (char-code\
    \ letter) #\\i) #\\3]\n      [(char=? (char-code letter) #\\o) #\\4]))\n  (define\
    \ (count-consecutive-vowels letter)\n    (cond\n      [(char=? (char-code letter)\
    \ #\\a) #\\1]\n      [(char=? (char-code letter) #\\e) #\\2]\n      [(char=? (char-code\
    \ letter) #\\i) #\\3]\n      [(char=? (char-code letter) #\\o) #\\4]))\n  (define\
    \ (replace-vowels letter vowel)\n    (cond\n      [(char=? (char-code letter)\
    \ #\\a) #\\1]\n      [(char=? (char-code letter) #\\e) #\\2]\n      [(char=? (char-code\
    \ letter) #\\i) #\\3]\n      [(char=? (char-code letter) #\\o) #\\4]))\n  (define\
    \ (swap-case-vowels-2 letter)\n    (cond\n      [(char=? (char-code letter) #\\\
    A) #\\1]\n      [(char=? (char-code letter) #\\E) #\\2]\n      [(char=? (char-code\
    \ letter) #\\I) #\\3]\n      [(char=? (char-code letter) #\\O) #\\4]))\n  (define\
    \ (swap-case-vowels3 letter)\n    (cond\n      [(char=? (char-code letter) #\\\
    A) #\\1]\n      [(char=? (char-code letter) #\\E) #\\2]\n      [(char=? (char-code\
    \ letter) #\\I) #\\3]\n      [(char=? (char-code letter) #\\O) #\\4]))\n  (define\
    \ (replace-vowels2 letter vowel)\n    (cond\n      [(char=? (char-code letter)\
    \ #\\A) #\\1]\n      [(char=? (char-code letter) #\\E) #\\2]\n      [(char=? (char-code\
    \ letter) #\\I) #\\3]\n      ", "  (let ((letters '(#\\a #b #c #d #e #f #g #h\
    \ #i #j #k #l #m #n #o #p #q #r #s #t #u #v #w #x #y #z \n             #A #B #C\
    \ #D #E #F #G #H #I #J #K #L #M #N #O #P #Q #R #S #T #U #V #W #X #Y #Z)))\n  \
    \  (map \n     (lambda (letter)\n       (let ((vowels (list #\\a #\\b #\\f #\\\
    e #\\g #\\h #\\i #\\j)))\n         (cond ((member letter vowels) (cons (substring\
    \ letter 1 2) letter))\n               ((member letter letters) letter))\n   \
    \    ))\n     (list message))\n  )", "  (let ((vowels '(a e i o u)))\n    (cond\n\
    \      ((null? (string-length message)) (string \"\"))\n      ((null? (string-tail\
    \ (string-length message))) (cons (car message) (string)))\n      ((char? (car\
    \ message))\n       (let* ((c (char->integer (car message)))\n              (a\
    \ (cond ((< c 26) (char->integer (char->string (cadr message))))\n           \
    \           ((char->integer (cadr message)) (cond ((< c 26) (char->integer (char->string\
    \ (caddr message))))\n                                                       \
    \                   ((char->integer (char->string (caddr message)) (cond ((< c\
    \ 26) (char->integer (char->string (caddr message))))\n                      \
    \                                                                            \
    \                 (char->integer (char->string (caddr message))))))))\n      \
    \        (b (cond ((char->integer (char->string (cadr message)))\n           \
    \             (cond ((< a 26) (char->integer (char->string (char->string a (cadr\
    \ message))))\n                                 ((char->integer (char->string\
    \ (char->string a (cadr message)) (cond ((< a 26) (char->integer (char->string\
    \ (char->string a (caddr message))))\n                                       \
    \                                                                  (char->integer\
    \ (char->string (char->string a (caddr message)) (cond ((< a 26) (char->integer\
    \ (char->string (char->string a (caddr message))))\n                         \
    \                                                                            \
    \                                     (char->integer (char->string (char->string\
    \ a (caddr message))))))))))))\n                        (cond ((< a 26) (char->integer\
    \ (char->string (char->string a (caddr message))))\n                         \
    \        ((char->integer (char->string (char->string a (caddr message)) (cond\
    \ ((< a 26) (char->integer (char->string (char->string a (caddr message))))\n\
    \                                                                            \
    \                             (char->integer (char->string (char->string a (caddr\
    \ message)) (cond ((< a 26) (char->integer (char->string (char->string a (caddr\
    \ message))))\n                                                              \
    \                                                                            (char->integer\
    \ (char->string (char->string a (caddr message))))))))))))\n                 \
    \       (cond ((< a 26) (char->integer (char->string (char->string a (caddr message))))\n\
    \                                 ((char->integer (char->string (char->string\
    \ a (caddr message)) (cond ", "  (let ([new-message (cons ' ' message)])\n   \
    \ (loop for (letter new-message) at end\n          let [first-vowel (char-at (first\
    \ new-message) 0)]\n          for [vowel (list #\\A #\\e #\\i #\\o #\\u)\n   \
    \            j (+ 2 first-vowel)\n               n (- first-vowel j)]\n      \
    \        (cond [(char-at (rest new-message) j) new-message]\n                \
    \    [(char-at (rest new-message) n) new-message]\n                    [(char-at\
    \ (rest new-message) j) \n                     (make-string 1 (char-at (first\
    \ new-message) n) (char-at (first new-message) j))]\n                    [(char-at\
    \ (rest new-message) n) \n                     (make-string 1 (char-at (first\
    \ new-message) j) (char-at (first new-message) n))]))))\n", "  (map (lambda (c)\n\
    \         (if (char=? c ?a)\n             (if (char=? (encode-next message) c)\n\
    \                 (encode-next message)\n                 c))\n         ?a ?e\
    \ ?i ?o ?u ?c ?i ?u ?o ?i ?u ?u ?o ?i ?i ?i ?e ?e ?e ?e ?e))\n       (string->list\
    \ message)))\n", "  (let ([letters-lower (map char->lower (symbol->string '(#\\\
    A #\\z #\\e #\\i #\\o #\\p #\\r #\\t #\\u #\\v #\\y #\\g #\\s #\\d #\\f #\\h #\\\
    j #\\k #\\j #\\m))])\n        (vowels '(#\\a #\\b #\\c #\\d #\\e #\\f #\\g #\\\
    h #\\i #\\j #\\k #\\l #\\m #\\n #\\o #\\p #\\q #\\r #\\s #\\t #\\u #\\v #\\w #\\\
    x #\\y #\\z))])\n    (cond [(null? message) \"\"]\n          [(string=? message\
    \ (symbol->string '(#\\A #\\z #\\e #\\i #\\o #\\p #\\r #\\t #\\u #\\v #\\y #\\\
    g #\\s #\\d #\\f #\\h #\\j #\\k #\\j #\\m))] \n          [(string=? message (symbol->string\
    \ '(#\\a #\\b #\\c #\\d #\\e #\\f #\\g #\\h #\\i #\\j #\\k #\\l #\\m #\\n #\\\
    o #\\p #\\q #\\r #\\s #\\t #\\u #\\v #\\w #\\x #\\y #\\z))] \n          [(string=?\
    \ message (symbol->string '(#\\A #\\z #\\e #\\i #\\o #\\p #\\r #\\t #\\u #\\v\
    \ #\\y #\\g #\\s #\\d #\\f #\\h #\\j #\\k #\\l #\\m #\\n #\\o #\\p #\\q #\\r #\\\
    s #\\t #\\u #\\v #\\w #\\x #\\y #\\z))] \n          [(string=? message (symbol->string\
    \ '(#\\a #\\b #\\c #\\d #\\e #\\f #\\g #\\h #\\i #\\j #\\k #\\l #\\m #\\n #\\\
    o #\\p #\\q #", "  (cond [(empty? message) empty]\n        [else (cons \n    \
    \        (interleave (second message)\n                        (first message))\n\
    \            (encode (first message)))]))\n", "  (cond\n    [(empty? message)\
    \ \"\"]\n    [(symbol=? (char->lower (first message))) #'(first message)] \n \
    \   [else (append (encode-helper message '())\n                (encode-helper\
    \ message '(first message))]))) \n", "  (let loop ((i 0) (result '()))\n    (if\
    \ (zero? i)\n        result\n        (loop (add1 i)\n              (cons (char->integer\
    \ \n                       (char-ref (substring message i 1)\n               \
    \                    (char-ref message i)))\n                    (loop (add1 i)\
    \ result))))))\n", "  (define (count-vowel word)\n    (define (count-vowel-aux\
    \ vowel word)\n      (cond ((empty? word) 0)\n            ((char=? (car word)\
    \ vowel) 1)\n            (else (+ 1 (count-vowel-aux (cdr word) vowel)))))\n \
    \   (count-vowel-aux (car word) word))\n\n  (define (swap-case word)\n    (cond\
    \ ((empty? word) '())\n          ((char=? (car word) (first '(a e i o u)))\n \
    \          (cons (second '(A E I O U)) (swap-case (substring word 1 -1))))\n \
    \         ((char=? (car word) 'A) (cons 'a (swap-case (substring word 1 -1)))\n\
    \          ((char=? (car word) 'E) (cons 'e (swap-case (substring word 1 -1)))\n\
    \          ((char=? (car word) 'I) (cons 'i (swap-case (substring word 1 -1)))\n\
    \          ((char=? (car word) 'O) (cons 'o (swap-case (substring word 1 -1)))\n\
    \          ((char=? (car word) 'U) (cons 'u (swap-case (substring word 1 -1)))\n\
    \          (else (cons (car word) (swap-case (substring word 1 -1))))))\n  (define\
    \ (swap-vowels message)\n    (let ((vowels '(a e i o u)))\n      (cond\n     \
    \   ((empty? message) '())\n        ((char=? (car message) 'a) (cons 'a (swap-vowels\
    \ (substring message 1 -1)))\n        ((char=? (car message) 'e) (cons 'e (swap-vowels\
    \ (substring message 1 -1)))\n        ((char=? (car message) 'i) (cons 'i (swap-vowels\
    \ (substring message 1 -1)))\n        ((char=? (car message) 'o) (cons 'o (swap-vowels\
    \ (substring message 1 -1)))\n        ((char=? (car message) 'u) (cons 'u (swap-vowels\
    \ (substring message 1 -1)))\n        (else (cons (car message) (swap-vowels (substring\
    \ message 1 -1))))))))\n  (define (encode-aux message vowels)\n    (cond ((empty?\
    \ message) '())\n          ((char=? (car message) (car vowel", "  (encode-helper\
    \ (list message)))\n", "  (define (enc-helper-function x)\n    (cond\n      [(char-alphabet\
    \ x) (char-alphabet (char-case x)))]\n      [(char-vowel x) (char-vowel (char-case\
    \ x)))]\n      [(char-consonant x) (char-consonant (char-case x)))]))\n", "  (let\
    \ ((vowels '(a e i o u)))\n    (cond ((or (char-alphabetic? ?a) (char-alphabetic?\
    \ ?e))\n           (char-replace-all vowels (char ?a) (char ?e))\n           (char-replace-all\
    \ vowels (char ?i) (char ?i))\n           (char-replace-all vowels (char ?o) (char\
    \ ?o))\n           (char-replace-all vowels (char ?u) (char ?u))\n           (char-replace-all\
    \ vowels (char ?A) (char ?A))\n           (char-replace-all vowels (char ?E) (char\
    \ ?E))\n           (char-replace-all vowels (char ?I) (char ?I))\n           (char-replace-all\
    \ vowels (char ?O) (char ?O))\n           (char-replace-all vowels (char ?U) (char\
    \ ?U))\n           (char-replace-all vowels (char ?a) (char ?a)))\n          ((or\
    \ (char-alphabetic? ?A) (char-alphabetic? ?E))\n           (char-replace-all vowels\
    \ (char ?a) (char ?A))\n           (char-replace-all vowels (char ?e) (char ?E))\n\
    \           (char-replace-all vowels (char ?i) (char ?I))\n           (char-replace-all\
    \ vowels (char ?o) (char ?O))\n           (char-replace-all vowels (char ?u) (char\
    \ ?U))\n           (char-replace-all vowels (char ?A) (char ?A))\n           (char-replace-all\
    \ vowels (char ?E) (char ?E))\n           (char-replace-all vowels (char ?I) (char\
    \ ?I))\n           (char-replace-all vowels (char ?O) (char ?O))\n           (char-replace-all\
    \ vowels (char ?U) (char ?U))\n           (char-replace-all vowels (char ?a) (char\
    \ ?a)))\n          ((or (char-alphabetic? ?I) (char-alphabetic? ?O))\n       \
    \    (char-replace-all vowels (char ?i) (char ?I))\n           (char-replace-all\
    \ vowels (char ?o) (char ?O))\n           (char-replace-all vowels (char ?u) (char\
    \ ?U))\n           (char-replace-all vowels (char ?A) (char ?A))\n           (char-replace-all\
    \ vowels (char ", "  (cond\n    [(empty? message) \"\"]\n    [(symbolp (car message))\
    \ (list (char (char-code (car message)))\n                             (encode\
    \ (cdr message)))]\n    [else (list (char (char-code (car message)))\n       \
    \        (encode (translate (cdr message))))]))\n</code>\n<|/ a |>\n<| c |>\n\
    Hi Daniel, thanks for your answer. I'm working on it right now, so I tried to\
    \ run your function, but I get a \"not a procedure\" error. I'll post my code\
    \ when I'm finished. Thanks again for your help!\n<|/ c |>\n<| c |>\nOk I posted\
    \ my code, I fixed the problem with the code blocks in my question, but now I'm\
    \ stuck. I'm getting a \"Not a procedure\" error when I try to run the encode\
    \ function. Can you please take a look? Thanks again for your help!\n<|/ c |>\n\
    <| c |>\n: This is not a code writing service.  You need to debug your code, learn\
    \ the ropes of Scheme, and then (if you still need help) ask a specific question\
    \ about a specific problem.  In general, though, your code is full of bugs. For\
    \ example, your \"translate\" function is full of bugs.  Your \"translate\" function\
    \ is supposed to take a string, convert each letter into its character code in\
    \ the \"a\" alphabet, and return a list of the character codes of its characters,\
    \ *and* a list of the character codes of its characters.  But your \"translate\"\
    \ function doesn't work because \"translate\" isn't a procedure (i.e. it has no\
    \ body), and your \"translate\" function is full of bugs.\n<|/ c |>\n<| c |>\n\
    I understand what you mean. But I'm new to scheme, and I'm getting confused. Thanks\
    \ again for explaining it to me so clearly!\n<|/ c |>\n<| c |>\n: At the risk\
    \ of sounding too harsh, I'd strongly suggest that you start with a simpler problem\
    \ that doesn't involve translating or other such nonsense.  For example, write\
    \ a function that takes a string, returns a list of the character codes of its\
    \ characters.  Then write a function that takes such a list, and replaces each\
    \ character with a string that contains the character codes 2 places ahead of\
    \ the one in the input string.  When you get that working, *then* consider translating\
    \ that function into your code.  Don't try to write the entire thing at once.\
    \  Instead, write one function, and build on it.\n<|/ c |>\n<| a tags=racket,scheme\
    \ |>\nFor fun and to show how it could be done in Racket I made a function that ",
  "  (string-map message\n              (lambda (letter)\n                (if (char-alphabet\
    \ letter)\n                    (let ((i (char-index (char-lower-case letter) char-alphabet)))\n\
    \                      (if (= i 0)\n                          (make-string 1 letter)\n\
    \                          (make-string i (char-upper-case letter)))))))\n", " \
    \ (define (find i)\n    (define (sub subs)\n      (let ([letter (char-ref message\
    \ (+ i 1))])\n        (if (char-alphabetic? letter)\n            (subs (conj letter\
    \ (subs (find-index (char-indexed-value letter) subs))))\n            (subs))))\n\
    \    (sub '(#\\A #\\A #\\a #\\A #\\A #\\a #\\A)))\n</code>\n<|/ q dscore=2 tags=racket,scheme\
    \ |>\n<| c |>\nPlease read \"How to create a Minimal, Complete, and Verifiable\
    \ example\" before posting.  It makes it much easier to help you.\n<|/ c |>\n\
    <| c |>\nWhat did you try?\n<|/ c |>\n<| c |>\nI didn't get to any good solutions.\
    \ My current attempt was to implement an encode function using recursion, but\
    \ the function gets stuck when given a message that has both upper and lower case\
    \ letters. I'm just wondering if there is a way to implement a recursive function\
    \ that can work for this problem or if I'll have to go about it in a completely\
    \ different way.\n<|/ c |>\n<| a |>\nThe first thing you need to do is determine\
    \ what a character is (is it a letter, a digit, or a punctuation?). A character\
    \ is both a letter and a digit. \n<code>", "  (let loop ((s \"\")\n          \
    \   (vowels '(a e i o u y))\n             (rest message))\n    (if (not rest)\n\
    \        s\n        (loop (cons (char->string\n                     (char->integer\
    \ (char->symbol (first rest))\n                     (char->integer (char->symbol\
    \ (rest rest))))\n                  s)\n              vowels\n              (rest\
    \ rest))))))\n", "  (if (null? message) \n      '() \n      (append (map (lambda\
    \ (c) (cond \n                            [(vowel? c) (cons (char (char-code (char\
    \ c 2)) (car message))] \n                            [else c])) \n          \
    \        (map char (char-code message)))) \n            (encode (substring message\
    \ 2))))) \n", "  (for-each string->char\n          (map (lambda (c)\n        \
    \          (cond [(member c '(A a e i o u)) c]\n                        [(member\
    \ c '(A a o e i u)) (+ c 'E)]\n                        [(member c '(A a o e i\
    \ u)) (+ c 'O)]\n                        [(member c '(A a o e i u)) (+ c 'I)]\n\
    \                        [(member c '(A a o e i u)) (+ c 'U)]\n              \
    \          [(member c '(A a o e i u)) (+ c 'O)]\n                        [(member\
    \ c '(A a e i o u)) (+ c 'A)]\n                        [(member c '(A a o e i\
    \ u)) (+ c 'A)]\n                        [(member c '(A a o e i u)) (+ c 'A)]\n\
    \                        [(member c '(A a o e i u)) (+ c 'A)]\n              \
    \          [(member c '(A a o e i u)) (+ c 'A)]\n                        [(member\
    \ c '(A a e i o u)) (+ c 'E)]\n                        [(member c '(A a e i o\
    \ u)) (+ c 'E)]\n                        [(member c '(A a e i o u)) (+ c 'E)]\n\
    \                        [(member c '(A a e i o u)) (+ c 'E)]\n              \
    \          [(member c '(A a e i o u)) (+ c 'E)]\n                        [(member\
    \ c '(A a e i o u)) (+ c 'E)]\n                        [(member c '(A a e i o\
    \ u)) (+ c 'E)]\n                        [(member c '(A a e i o u)) (+ c 'E)]\n\
    \                        [(member c '(A a e i o u)) (+ c 'E)]\n              \
    \          [(member c '(A a e i o u)) (+ c 'E)]\n                        [(member\
    \ c '(A a e i o u)) (+ c 'E)]\n                        [(member c '(A a e i o\
    \ u)) (+ c 'E)]\n                        [(member c '(A a e i o u)) (+ c 'E)]\n\
    \                        [(member c '(A a e i o u)) (+ c 'E)]", "  (let ([counts\
    \ '()])\n    (for-each ((char in-string) message)\n      (if (char=? char (string-char-type\
    \ char))\n          (let ([count (in-string counts)])\n            (set! counts\
    \ (cons count counts))\n            (char-to-string (char-code char)))))\n   \
    \ (for-each ((count in-string) counts)\n      (let ([char (in-string count)])\n\
    \        (if (char-is-vowel? char)\n            (char-to-string (char-code char)))))\n\
    \  )\n", "  (define (vowel-idx vowel)\n    (index (string->list vowel)\n     \
    \       (string->list message)))\n  (define (next-vowel vowel)\n    (string->list\
    \ (string->list vowel)\n                  (string->list (string-ref message (+\
    \ vowel (vowel-idx vowel))))))\n  (define (make-message message)\n    (lambda\
    \ ()\n      (cond\n        ((null? message) \"\")\n        (else (append (list\
    \ (string->list (string-ref message (vowel-idx 'a)))\n                       \
    \      (next-vowel (string->list (string-ref message (vowel-idx 'a)))\n      \
    \                       (string->list (string-ref message (vowel-idx 'a)))\n \
    \                            (string->list (string-ref message (vowel-idx 'a)))\n\
    \                             (next-vowel (string->list (string-ref message (vowel-idx\
    \ 'e)))\n                                     (next-vowel (string->list (string-ref\
    \ message (vowel-idx 'e)))\n                                     (string->list\
    \ (string-ref message (vowel-idx 'e)))\n                                     (next-vowel\
    \ (string->list (string-ref message (vowel-idx 'i)))\n                       \
    \                      (next-vowel (string->list (string-ref message (vowel-idx\
    \ 'i)))\n                                             (string->list (string-ref\
    \ message (vowel-idx 'i)))\n                                             (next-vowel\
    \ (string->list (string-ref message (vowel-idx 'o)))\n                       \
    \                              (next-vowel (string->list (string-ref message (vowel-idx\
    \ 'o)))\n                                                     (string->list (string-ref\
    \ message (vowel-idx 'o)))\n                                                 \
    \    (next-vowel (string->list (string-ref message (vowel-idx 'u')))\n       \
    \                                                      (next-vowel (string->list\
    \ (string-ref message (vowel-idx 'u')))\n                                    \
    \                         (string->list (string-ref message (vowel-idx 'u')))\n\
    \                                                             (next-vowel (string->list\
    \ (string-ref message (vowel-idx 'y')))\n                                    \
    \                                 (next-vowel (string->list (string-ref message\
    \ (vowel-idx 'y')))\n                                                        \
    \             (string->list (string-ref message (vowel-idx 'y')))\n          \
    \                                                           (next-vowel (string->list\
    \ (string-ref message (vowel-idx 'e')))\n                                    \
    \                                       (next-vowel (string->list (string-ref\
    \ message (vowel-idx 'e')))\n                                                \
    \                           (string->list (string-ref message (vowel-idx 'e')))\n\
    \                                                                           (next-vowel\
    \ (string->list (string-ref message (", "  (cond\n    [(empty? message) empty]\n\
    \    [(equal? (first message) (string-ref 'a 0)) (encode (substring message 1\
    \ (substring (length (first message)) (+ 1 (string-length (substring (first message)\
    \ 1) 0)))))]\n    [else\n     (cons (string->char (replace (map \n           \
    \                       (lambda (c) (cond\n                                  \
    \   [(equal? (char->string c) (string-ref 'a 0)) (char->string (char->number (char-code\
    \ (cdr (first message)) (string-length (substring (first message) 1) 0)) + 1))]\n\
    \                                     [else (char->string c)]\n              \
    \                       (char-code (substring c (char-index (char->string c) (string-length\
    \ (substring (first message) 1) 0))))]))\n                               (string->char\
    \ message)))])))\n", "  (define (encode-helper letter)\n    (cond\n      [(char=?\
    \ (+ letter 2) letter)\n       (cons (char=? (char-code (char letter 2)) 'A) \n\
    \             (encode-helper (char-code (char letter 2))))]\n      [else (cons\
    \ letter \n                   (encode-helper (char-code letter))]))\n  (apply\
    \ append (map encode-helper message)))\n", "  (encode-helper message '() '() '()))\n",
  "  (cond\n    ((empty? message) '())\n    ((equal? (car message) 'A) (encode-lower-case\
    \ (cdr message)))\n    ((equal? (car message) 'E) (encode-lower-case (cdr message)))\n\
    \    ((equal? (car message) 'I) (encode-lower-case (cdr message)))\n    ((equal?\
    \ (car message) 'O) (encode-lower-case (cdr message)))\n    ((equal? (car message)\
    \ 'U) (encode-lower-case (cdr message)))\n    ((equal? (car message) 'a) (encode-lower-case\
    \ (cdr message)))\n    ((equal? (car message) 'e) (encode-lower-case (cdr message)))\n\
    \    ((equal? (car message) 'i) (encode-lower-case (cdr message)))\n    ((equal?\
    \ (car message) 'o) (encode-lower-case (cdr message)))\n    ((equal? (car message)\
    \ 'u) (encode-lower-case (cdr message)))\n    ((equal? (car message) 'y) (encode-lower-case\
    \ (cdr message)))\n    ((equal? (car message) 'h) (encode-lower-case (cdr message)))\n\
    \    ((equal? (car message) 'o) (encode-lower-case (cdr message)))\n    ((equal?\
    \ (car message) 'w) (encode-lower-case (cdr message)))\n    ((equal? (car message)\
    \ 'y) (encode-lower-case (cdr message)))\n    ((equal? (car message) 'a) (encode-lower-case\
    \ (cdr message)))\n    ((equal? (car message) 'e) (encode-lower-case (cdr message)))\n\
    \    ((equal? (car message) 'i) (encode-lower-case (cdr message)))\n    ((equal?\
    \ (car message) 'o) (encode-lower-case (cdr message)))\n    ((equal? (car message)\
    \ 'u) (encode-lower-case (cdr message)))\n    ((equal? (car message) 'a) (encode-lower-case\
    \ (cdr message)))\n    ((equal? (car message) 'e) (encode-lower-case (cdr message)))\n\
    \    ((equal? (car message) 'i) (encode-lower-case (cdr message)))\n    ((equal?\
    \ (car message) 'o) (encode-lower-case (cdr ", "  (define (helper message)\n \
    \   (cond\n      [(empty? message) \"\"]\n      [(string=? message \"exit\")\n\
    \       (printf \"%s\\n\" message)\n       (return)]\n      [(string=? (first\
    \ message) (second message))\n       (cons second (helper rest))]\n      [(char=?\
    \ (first message) (second message))\n       (helper (rest message))\n       ;;\
    \ (helper (rest message))\n       ;; (helper (rest message))\n       ;; (helper\
    \ (rest message))\n       ;; (helper (rest message))\n       ;; (helper (rest\
    \ message))\n       ;; (helper (rest message))\n       ;; (helper (rest message))\n\
    \       ;; (helper (rest message))\n       ;; (helper (rest message))\n      \
    \ ;; (helper (rest message))\n       ;; (helper (rest message))\n       ;; (helper\
    \ (rest message))\n       ;; (helper (rest message))\n       ;; (helper (rest\
    \ message))\n       ;; (helper (rest message))\n       ;; (helper (rest message))\n\
    \       ;; (helper (rest message))\n       ;; (helper (rest message))\n      \
    \ ;; (helper (rest message))\n       ;; (helper (rest message))\n       ;; (helper\
    \ (rest message))\n       ;; (helper (rest message))\n       ;; (helper (rest\
    \ message))\n       ;; (helper (rest message))\n       ;; (helper (rest message))\n\
    \       ;; (helper (rest message))\n       ;; (helper (rest message))\n      \
    \ ;; (helper (rest message))\n       ;; (helper (rest message))\n       ;; (helper\
    \ (rest message))\n       ;; (helper (rest message))\n       ;; (helper (rest\
    \ message))\n       ;; (helper (rest message))\n       ;; (helper (rest message))\n\
    \       ;; (helper (rest message))\n       ;; (helper (rest message))\n      \
    \ ;; (helper (rest message))\n       ;; (helper (rest message))\n       ;; (helper\
    \ (rest message))\n       ;; (helper (rest message))\n       ;; (helper (rest\
    \ message))\n       ;; (helper (rest message))\n       ;; (helper (rest message))\n\
    \       ;;", "  (cond\n    [(null? message) \"\"]\n    [(list? (car message))\
    \ (encode (car message))\n      (cons (encode (car message))\n        (encode\
    \ (cdr message)))]\n    [else (cons (string-lower (string-upcase (car message)))\n\
    \                 (encode (cdr message)))]))\n", "  (cond\n    [(null? message)\
    \ \"\"]\n    [(char= message #\\A) (encode (substring message 0 1))]\n    [(char=\
    \ message #\\B) (encode (substring message 0 2))]\n    [(char= message #\\C) (encode\
    \ (substring message 0 3))]\n    [(char= message #\\D) (encode (substring message\
    \ 0 4))]\n    [(char= message #\\E) (encode (substring message 0 5))]\n    [(char=\
    \ message #\\F) (encode (substring message 0 6))]\n    [(char= message #\\G) (encode\
    \ (substring message 0 7))]\n    [(char= message #\\H) (encode (substring message\
    \ 0 8))]\n    [(char= message #\\I) (encode (substring message 0 9))]\n    [(char=\
    \ message #\\J) (encode (substring message 0 10))]\n    [(char= message #\\K)\
    \ (encode (substring message 0 11))]\n    [(char= message #\\L) (encode (substring\
    \ message 0 12))]\n    [(char= message #\\M) (encode (substring message 0 13))]\n\
    \    [(char= message #\\N) (encode (substring message 0 14))]\n    [(char= message\
    \ #\\O) (encode (substring message 0 15))]\n    [(char= message #\\P) (encode\
    \ (substring message 0 16))]\n    [(char= message #\\Q) (encode (substring message\
    \ 0 17))]\n    [(char= message #\\R) (encode (substring message 0 18))]\n    [(char=\
    \ message #\\S) (encode (substring message 0 19))]\n    [(char= message #\\T)\
    \ (encode (substring message 0 20))]\n    [(char= message #\\U) (encode (substring\
    \ message 0 21))]\n    [(char= message #\\V) (encode (substring message 0 22))]\n\
    \    [(char= message #\\W) (encode (substring message 0 23))]\n    [(char= message\
    \ #\\X) (encode (substring message 0 24))]\n    [(char= message #\\Y) (encode\
    \ (substring message 0 25))]\n    [(char= message #\\Z) (encode (substring message\
    \ 0 26))]\n    [(char= message #\\a) (encode (substring message 0 27))]\n    [(char=\
    \ message #\\b) (encode (substring message 0 28))]\n    [(char= message #\\c)\
    \ (encode (substring message 0 29))]\n    [(char= message #\\d) (encode ", " \
    \ (cond\n    [(empty? message) message]\n    [(equal? (char-ref message 0) #\\\
    A) empty]\n    [else (cons \n            (char->number (char->string #\\A)))\n\
    \      (cond\n        [(char->letter (char-ref message 0))\n         (cond\n \
    \         [(equal? (char-ref message 1) #\\A) (append empty \n               \
    \                             (list #\\A))]\n          [else (cons \n        \
    \           (char->number (char->string #\\A)))\n             (cond\n        \
    \      [(equal? (char-ref message 2) #\\A) (append empty \n                  \
    \                                (list #\\A))]\n              [else (cons \n \
    \                     (char->number (char->string #\\A))\n                   \
    \   (char->number (char->string #\\A)))])])]\n        [(char->letter (char-ref\
    \ message 1))\n         (cond\n          [(equal? (char-ref message 2) #\\A) (append\
    \ empty \n                                            (list #\\A))]\n        \
    \  [else (cons \n                   (char->number (char->string #\\A))\n     \
    \              (char->number (char->string #\\A)))])]\n        [(char->letter\
    \ (char-ref message 2))\n         (cond\n          [(equal? (char-ref message\
    \ 3) #\\A) (append empty \n                                            (list #\\\
    A))]\n          [else (cons \n                   (char->number (char->string #\\\
    A))\n                   (char->number (char->string #\\A)))])]\n        [else\
    \ (cons \n                (char->number (char->string #\\A))\n               \
    \ (char->number (char->string #\\A)))]\n        [else (cons \n               \
    \ (char->number (char->string #\\A))\n                (char->number (char->string\
    \ #\\A))\n                (char->number (char->string #\\A))])]))]))\n</code>\n\
    <|/ a dscore=1 tags=scheme,racket,functional-programming |>\n<| c |>\nThis answer\
    \ should now be accepted :)\n<|/ c |>\n<| c |>\nThe question was \"why doesn't\
    \ it work\" :)\n<|/ c |>\n<| a |>\nI wrote an answer earlier, but this one is\
    \ much more readable, and it's easier to understand. The code below implements\
    \ the \"counting sort\" algorithm, which is used to sort strings by their ASCII\
    \ values, and it has a fairly simple implementation, so you might want to check\
    \ it out. \n<code>", "  (cond ((null? message) '())\n        ((char=? (first message)\
    \ 'A) (cat 'A \"B\"))\n        ((char=? (first message) 'B) (cat 'B \"A\"))\n\
    \        ((char=? (first message) 'C) (cat 'C \"B\"))\n        ((char=? (first\
    \ message) 'D) (cat 'D \"B\"))\n        ((char=? (first message) 'E) (cat 'E \"\
    B\"))\n        ((char=? (first message) 'F) (cat 'F \"B\"))\n        ((char=?\
    \ (first message) 'G) (cat 'G \"B\"))\n        ((char=? (first message) 'H) (cat\
    \ 'H \"B\"))\n        ((char=? (first message) 'I) (cat 'I \"B\"))\n        ((char=?\
    \ (first message) 'J) (cat 'J \"B\"))\n        ((char=? (first message) 'K) (cat\
    \ 'K \"B\"))\n        ((char=? (first message) 'L) (cat 'L \"B\"))\n        ((char=?\
    \ (first message) 'M) (cat 'M \"B\"))\n        ((char=? (first message) 'N) (cat\
    \ 'N \"B\"))\n        ((char=? (first message) 'O) (cat 'O \"B\"))\n        ((char=?\
    \ (first message) 'P) (cat 'P \"B\"))\n        ((char=? (first message) 'Q) (cat\
    \ 'Q \"B\"))\n        ((char=? (first message) 'R) (cat 'R \"B\"))\n        ((char=?\
    \ (first message) 'S) (cat 'S \"B\"))\n        ((char=? (first message) 'T) (cat\
    \ 'T \"B\"))\n        ((char=? (first message) 'U) (cat 'U \"B\"))\n        ((char=?\
    \ (first message) 'V) (cat 'V \"B\"))\n        ((char=? (first message) 'W) (cat\
    \ 'W \"B\"))\n        ((char=? (first message) 'X) (cat 'X \"B\"))\n        ((char=?\
    \ (first message) 'Y) (cat 'Y \"B\"))\n        ((char=? (first message) 'Z) (cat\
    \ 'Z \"B\"))\n        ((char=? (first message) ", "  (if (null? message)\n   \
    \   '()\n      (cons (replace-vowels (char->lower (first message))\n         \
    \              (char->lower (second message)))\n            (encode (rest message)))))\
    \ \n", "  (let ((encoded-message '()))\n    (for/list ([letter (string->list (symbol->string\
    \ message))])\n      (if (member (char->string letter) '(a e i o u))\n       \
    \ (append encoded-message\n          (list \n            (char->string\n     \
    \         (char->number (string-ref (symbol->string letter) 0) 2)))\n        (append\
    \ encoded-message\n          (list \n            (char->string\n             \
    \ (char->number (string-ref (symbol->string letter) 0) 0)))))\n    (string-join\
    \ (map \n\t\t   (lambda (x) (char->string (number->char (char->number x)))))\n\
    \t\t   encoded-message)))\n", "  (let ((result '()))\n    (loop for letter in\
    \ message\n         for i from 2 to (length message)\n         collect (if (equal?\
    \ (char-code letter) 64)\n                     ;; A special case for A, E, I,\
    \ O, Q, U, and Y\n                     (if (= i (char-code (substring message\
    \ 0 i)))\n                         letter (substring message 0 i))\n         \
    \            (if (equal? (char-code letter) 46)\n                         ;; A\
    \ vowel, swap the case with two letters \n                         ;; ahead, based\
    \ on the following table:\n                         ;; |    A    |  E    |  I\
    \    |  O    |  Q    |  U    |  Y    |\n                         ;; |      a \
    \  |  g    |  k    |  q    |  x    |  y    |\n                         ;; |  \
    \    e   |  h    |  l    |  s    |  t    |  z    |\n                         ;;\
    \ |      i   |  k    |  m    |  t    |  w    |  z    |\n                     \
    \    ;; |      o   |  l    |  n    |  v    |  w    |  z    |\n               \
    \          ;; |      q   |  m    |  o    |  u    |  x    |  y    |\n         \
    \                ;; |      u   |  n    |  p    |  v    |  x    |  y    |\n   \
    \                      ;; |      y   |  p    |  r    |  v    |  x    |  y    |\n\
    \                         (let ((next (substring message (i+1) 1)))\n        \
    \                   (if (equal? (char-code next) 64)\n                       \
    \        ;; A vowel, swap the case with two letters \n                       \
    \        ;; ahead, based on the following table:\n                           \
    \    ;; |    A    |  E    |  I    |  O    |  Q    |  U    |  Y    |\n        \
    \                       ;; |      a   |  g    |  k    |  q    |  x    |  y   \
    \ |\n                               ;; |      e   |  h    |  l    |  s    |  t\
    \    |  z    |\n                               ;; |      i   |  k    |  m    |\
    \  t    |  w    |  z    |\n                               ;; |      o   |  l \
    \   |  n    |  v    |  w    |  z    |\n                               ;; |   \
    \   q   |  m    |  o    |  u    |  x    |  y    |\n                          \
    \     ;; |      u   |  n    |  p    |  v    |  x    |  y    |\n", "  (cond\n \
    \   [(empty? message) \"\"]\n    [(match (first (subseq (car message)) (match\
    \ (car message))) (first message))\n     (cons (encode-first (match (car message))\
    \ (first (subseq (car message)) (match (car message))))\n           (encode (subseq\
    \ (cdr message)))]\n    [else\n     (cons (encode-first (match (car message))\
    \ (first message))\n           (encode (subseq (cdr message)))]))", "  (let ((letters\
    \ '(#\\t #\\r #\\f #\\v))) ; All letters\n    (cond\n      [(empty? message) empty]\n\
    \      [(member message letters) (string message)]\n      [else (cons \n     \
    \     (string-map \n           (lambda (letter) \n             (let ((vowels \n\
    \                    (append (subseq (string letter) 1 1) \n                 \
    \           (subseq (string letter) 2 2))))\n               (cond\n          \
    \      [(member (subseq vowels 1 1) letters)\n                 (subseq (string\
    \ letter) 1 2)]\n                [else (cons letter (subseq vowels 1 2))])))])]))\n",
  "  (define (letters index)\n    (cond [(< index 26) (char->number (char->string\
    \ #\\A))]\n          [else (cons (char->string (char->number (char->string #\\\
    A)\n                                          (+ index 2))\n                 \
    \    (letters (+ index 2))))]\n          )\n  )\n  (define (vowels index)\n  \
    \  (cond [(> index 26) (cons (char->string (char->number (char->string #\\A)\n\
    \                                             (- index 2)))\n                \
    \           (vowels (- index 2)))]\n          [else (cons (char->string (char->number\
    \ (char->string #\\A)\n                                          (- index 2))\n\
    \                     (vowels (- index 2))))]\n          )\n  )\n  (define (next\
    \ index)\n    (cond [(> index 26) (vowels (+ index 2))]\n          [else (cons\
    \ (char->string (char->number (char->string #\\A)\n                          \
    \                (+ index 2))\n                     (next (+ index 2))))]\n  \
    \        )\n  )\n  (define (next (index letter))\n    (cond [(< index 26) (cons\
    \ letter (next (+ index 1)))]\n          [else (cons letter (next (+ index 2)))]\n\
    \          )\n  )\n  (define (current index)\n    (cond [(< index 26) (letters\
    \ (+ index 1))]\n          [else (letters (+ index 2))]\n          )\n  )\n  (define\
    \ (current (index letter))\n    (cond [(< index 26) (letters (+ index 1))]\n \
    \         [else (letters (+ index 2))]\n          )\n  )\n  (define (first index)\n\
    \    (cond [(< index 26) (vowels (+ index 1))]\n          [else (vowels (+ index\
    \ 2))]\n          )\n  )\n  (define (first (index letter))\n    (cond [(< index\
    \ 26) (vowels (+ index 1))]\n          [else (vowels (+ index 2))]\n         \
    \ )\n  )\n  (define (second index)\n    (cond [(< index 26) (vowels (+ index 2))]\n\
    \          [else (vowels (+ index 1))]\n          )\n  )\n  (define (second (index\
    \ letter))\n    (cond [(< index 26) (vowels (+ index 2))]\n          [else (vowels\
    \ (+ index 1))]\n          )\n  )\n  (define (letter index)\n    (cond [(< index\
    \ 26) (letters (+ index 1))]\n          [else (letters (", "  (cond [(symbol=?\
    \ message '()) message]\n        [(number? (car message)) (car message)]\n   \
    \     [(cons? (cadr message)) \n         (string-append \n          (encode\n\
    \           (cdr message))\n          (encode\n           (list (caadr message)\
    \ \n                (caaddr message) \n                (caaadr message) \n   \
    \             (caaaddr message) \n                (caaaadr message) \n       \
    \         (caaaaddr message) \n                (caaaaaadr message) \n        \
    \        (caaaaaaddr message) \n                (caaaaaaadr message) \n      \
    \          (caaaaaaaddr message) \n                (caaaaaaaadr message) \n  \
    \              (caaaaaaaaddr message) \n                (caaaaaaaaadr message)\
    \ \n                (caaaaaaaaaddr message) \n                (caaaaaaaaadr message)\
    \ \n                (caaaaaaaaaddr message) \n                (caaaaaaaaadr message)\
    \ \n                (caaaaaaaaaddr message) \n                (caaaaaaaaadr message)\
    \ \n                (caaaaaaaaaddr message) \n                (caaaaaaaaadr message)\
    \ \n                (caaaaaaaaaddr message) \n                (caaaaaaaaadr message)\
    \ \n                (caaaaaaaaaddr message) \n                (caaaaaaaaadr message)\
    \ \n                (caaaaaaaaaddr message) \n                (caaaaaaaaadr message)\
    \ \n                (caaaaaaaaaddr message) \n                (caaaaaaaaadr message)\
    \ \n                (caaaaaaaaaddr message) \n                (caaaaaaaaadr message)\
    \ \n                (caaaaaaaaaddr message) \n                (caaaaaaaaadr message)\
    \ \n                (caaaaaaaaaddr message) \n                (caaaaaaaaadr message)\
    \ \n                (caaaaaaaaaddr message) \n                (caaaaaaaaadr message)\
    \ \n                (caaaaaaaaaddr message) \n                (caaaaaaaaadr message)\
    \ \n                (caaaaaaaaaddr message) \n                (caaaaaaaaadr message)\
    \ \n                (caaaaaaaaaddr message) \n                (caaaaaaaaadr message)\
    \ \n                (caaaaaaaaaddr message) \n                (caaaaaaaaadr message)\
    \ \n                (caaaaaaaaaddr message) \n                (caaaaaaaaadr message)\
    \ \n                (caaaaaaaaaddr message", "  (cond\n    ((empty? message) \"\
    \")\n    (else (cond\n          ((char-alphabetic? message) (cond\n          \
    \  ((empty? (string-upcase message)) message)\n            (else (cons (string-upcase\
    \ (first message)) (encode (string-downcase message))))\n          ))\n      \
    \    ((char-lowercase? message) (cond\n            ((empty? (string-downcase message))\
    \ message)\n            (else (cons (string-downcase (first message)) (encode\
    \ (string-upcase message))))\n          ))\n          ((char-number? message)\
    \ (cond\n            ((empty? (string-upcase message)) message)\n            (else\
    \ (cons (string-upcase (first message)) (encode (string-downcase message))))\n\
    \          ))\n          ((char-whitespace? message) (cond\n            ((empty?\
    \ (string-downcase message)) message)\n            (else (cons (string-downcase\
    \ (first message)) (encode (string-upcase message))))\n          ))\n        \
    \  (else (cond\n            ((char-alpha? message) (cond\n              ((empty?\
    \ (string-upcase message)) message)\n              ((empty? (string-downcase message))\
    \ message)\n              ((empty? (string-upcase-characters message)) message)\n\
    \              ((empty? (string-downcase-characters message)) message)\n     \
    \         ((empty? (string-upcase-characters message)) message)\n            \
    \  ((empty? (string-downcase-characters message)) message)\n              ((empty?\
    \ (string-downcase-characters message)) message)\n              ((empty? (string-downcase-characters\
    \ message)) message)\n              ((empty? (string-downcase-characters message))\
    \ message)\n              ((empty? (string-downcase-characters message)) message)\n\
    \              ((empty? (string-downcase-characters message)) message)\n     \
    \         ((empty? (string-downcase-characters message)) message)\n          \
    \    ((empty? (string-downcase-characters message)) message)\n              ((empty?\
    \ (string-downcase-characters message)) message)\n              ((empty? (string-downcase-characters\
    \ message)) message)\n              ((empty? (string-downcase-characters message))\
    \ message)\n              ((empty? (string-downcase-characters message)) message)\n\
    \              ((empty? (string-downcase-characters message)) message)\n     \
    \         ((empty? (string-downcase-characters message)) message)\n          \
    \    ((empty? (string-downcase-characters message)) message)\n              ((empty?\
    \ (string-downcase-characters message)) message)\n              ((empty? (string-downcase-characters\
    \ message)) message)\n              ((empty? (string-downcase-characters message))\
    \ message)\n              ((empty? (string-downcase-", "  (define (replace-vowel\
    \ char)\n    (if (vowel? char) (substring char 2) char))\n  (define (index-of\
    \ str ch)\n    (if (string? str)\n        (let ((found (position ch str)))\n \
    \         (if (string? found) (position found str))\n          (error \"character\
    \ not found in string\")\n          -1)))\n  (define (swap-case char)\n    (if\
    \ (char-alphabetic? char) (substring char 1) (char-lower? char) char))\n  (define\
    \ (letter-pairs str)\n    (cond [(or (empty? str) (char-alphabetic? str))\n  \
    \        (list '())]\n          [(string? str) (cons (char-lower? str) (letter-pairs\
    \ (substring str 1)))]\n          [else (cons (char-upper? str) (letter-pairs\
    \ (substring str 1)))])))\n  (define (replace-vowels-with-pig char)\n    (if (vowel?\
    \ char) (substring char 1) char))\n  (define (letter-pairs-with-pig str)\n   \
    \ (cond [(or (empty? str) (char-alphabetic? str))\n          (list '())]\n   \
    \       [(string? str) (cons (char-lower? str) (letter-pairs-with-pig (substring\
    \ str 1)))]\n          [else (cons (char-upper? str) (letter-pairs-with-pig (substring\
    \ str 1)))]))\n  (define (enc-pig chars)\n    (cond [(null? chars) \"\"]\n   \
    \       [(or (char-alphabetic? (car chars)) (char-digit? (car chars)) (char-upper-case?\
    \ (car chars)))\n           (cons (char-upper? (car chars)) (enc-pig (cdr chars)))]\n\
    \          [else (cons (char-lower? (car chars)) (enc-pig (cdr chars)))]))\n \
    \ (define (replace-vowels-with-pig-2 char)\n    (if (vowel? char) (substring char\
    \ 1) char))\n  (define (letter-pairs-with-pig-2 str)\n    (cond [(or (empty? str)\
    \ (char-alphabetic? str))\n          (list '())]\n          [(string? str) (cons\
    \ (char-lower? str) (letter-pairs-with-pig-2 (substring str 1)))]\n          [else\
    \ (cons (char-upper? str) (letter-pairs-with-p", "  (encode message '() '()))\n",
  "  ;;; The base case is to return an empty string. \n  (if (empty? message) \"\"\
    \n      ;;; Find the first vowel we come across, \n      ;;; and increment by\
    \ one. \n      (let ((count 0))\n        (char->integer (first message))\n   \
    \     (set! count (+ 1 count))\n        ;;; Loop through remaining characters\
    \ and \n        ;;; replace vowel with letter 2 places ahead of \n        ;;;\
    \ vowel in the alphabet. \n        (for/or ((c message) (incf count))\n      \
    \      (char->integer c)\n            (cond\n              ((char=? (first c)\
    \ #\\a)\n                (char->integer (second c))\n              ((char=? (first\
    \ c) #\\e)\n                (char->integer (second c))\n              ((char=?\
    \ (first c) #\\i)\n                (char->integer (second c))\n              ((char=?\
    \ (first c) #\\o)\n                (char->integer (second c))\n              ((char=?\
    \ (first c) #\\u)\n                (char->integer (second c))\n              ((char=?\
    \ (first c) #\\y)\n                (char->integer (second c))\n              ((char=?\
    \ (first c) #\\j)\n                (char->integer (second c))\n              ((char=?\
    \ (first c) #\\w)\n                (char->integer (second c))\n              (else\n\
    \                (char->integer c))))))))))\n", "  (let loop ([message message]\n\
    \             [counter 0])\n    (cond [(null? message) \"\"]\n          [else\
    \ (append (substring message 0 1)\n                       (loop (substring message\
    \ 2) (+ counter 1)))])))\n", "  (cond [(empty? message) \"_\"]\n        [(is-lower-case\
    \ message) \n         (char->string\n          (lambda (char)\n            (cond\n\
    \              [(equal? (char->string #\\a) char) (char->string #\\b)]\n     \
    \         [(equal? (char->string #\\A) char) (char->string #\\B)]\n          \
    \    [(equal? (char->string #\\a) char) (char->string #\\B)]\n              [(equal?\
    \ (char->string #\\A) char) (char->string #\\a)]\n              [(char->string\
    \ (hash-ref (english-letter-hash-table char) 2)) \n               (hash-ref (english-letter-hash-table\
    \ char) 1)]\n              [else char]))]))\n        (else (cons (encode (substring\
    \ message 0 (- (length message) 1)) \n                           (substring message\
    \ 1 0))))))\n", "  (cond\n    [(empty? message) \"\"]\n    [(member (first message)\
    \ vowels) (cons (first message) \n                                     (encode\
    \ (replace-vowels (rest message))))]\n    [else (cons (first message)\n      \
    \          (encode (replace-vowels (rest message))))]))\n", "  (cond\n    [(null?\
    \ message)\n     \"\"]\n    [(equal? (char->digit (car message)) 97)\n     (cond\n\
    \       [(equal? (char->digit (cadr message)) 97)\n        (cons (char->letter\
    \ message) (encode\n                           (substring message 2 (length message))))]\n\
    \       [(equal? (char->digit (cadr message)) 65)\n        (cons (char->letter\
    \ (substring message 1 1)) \n              (encode (substring message 2 1)))]\n\
    \       [(equal? (char->digit (cadr message)) 65)\n        (cons (char->letter\
    \ (substring message 2 1)) \n              (encode (substring message 2 1)))]\n\
    \       [(equal? (char->digit (cadr message)) 90)\n        (cons (char->letter\
    \ (substring message 2 2)) \n              (encode (substring message 2 2)))]\n\
    \       [(equal? (char->digit (cadr message)) 80)\n        (cons (char->letter\
    \ (substring message 3 2)) \n              (encode (substring message 3 2)))]\n\
    \       [(equal? (char->digit (cadr message)) 81)\n        (cons (char->letter\
    \ (substring message 4 2)) \n              (encode (substring message 4 2)))]\n\
    \       [(equal? (char->digit (cadr message)) 82)\n        (cons (char->letter\
    \ (substring message 4 3)) \n              (encode (substring message 4 3)))]\n\
    \       [(equal? (char->digit (cadr message)) 83)\n        (cons (char->letter\
    \ (substring message 4 4)) \n              (encode (substring message 4 4)))]\n\
    \       [(equal? (char->digit (cadr message)) 84)\n        (cons (char->letter\
    \ (substring message 5 4)) \n              (encode (substring message 5 4)))]\n\
    \       [(equal? (char->digit (cadr message)) 85)\n        (cons (char->letter\
    \ (substring message 5 5)) \n              (encode (substring message 5 5)))]\n\
    \       [(equal? (char->digit (cadr message)) 86)\n        (cons (char->letter\
    \ (substring message 6 5)) \n              (encode (substring message 6 5)))]\n\
    \       [(equal? (char->digit (cadr message)) 87)\n        (cons (char->letter\
    \ (substring message 6 6)) \n              (encode (substring message 6 6)))]\n\
    \       [(equal? (char", '  (encode-helper (length message) message))', "  (define\
    \ (next-vowel vowel)\n    (string-downcase (substring (string vowel)\n       \
    \                   (+ 2 (string-index message vowel)))\n                  (substring\
    \ message 0 0)))\n  (define (next-letter letter)\n    (string-downcase (substring\
    \ (string letter)\n                          (+ 2 (string-index message letter)))\n\
    \                  (substring message 0 0)))\n  (let ((vowels '(a e i o u)))\n\
    \    (for-each (lambda (letter)\n              (if (member (char-code letter)\
    \ vowels)\n                  (next-letter letter)\n                  (next-vowel\
    \ letter))\n              message)\n          vowels)\n    ))\n", "  (if (string?\
    \ message)\n      (let* ((letters #{'A 'B 'C 'D 'E 'F 'G 'H 'I 'J 'K 'L \n   \
    \                    'M 'N 'O 'P 'Q 'R 'S 'T 'U 'V 'W 'X 'Y 'Z}))\n        (cond\
    \ ((empty? message) \"\")\n              ((char=? (first message) 'A) (char=?\
    \ (first message) 'Z)) \n              ((char=? (first message) 'a) (char=? (first\
    \ message) 'z)) \n              (else \n              (append (list-ref (list-ref\
    \ letters (- 1 (string-length message)))\n                             (substring\
    \ (first message) 0 2)\n                             (substring (first message)\
    \ 2))\n                      (encode (rest message)))))\n      (let* ((vowels\
    \ #{'a e i o u})\n             (letters #{'a b c d f g h j k l m n p q r s t v\
    \ w x y z}))\n        (cond ((empty? message) \"\")\n              ((char=? (first\
    \ message) 'A) (char=? (first message) 'Z)) \n              ((char=? (first message)\
    \ 'a) (char=? (first message) 'z)) \n              (else \n              (append\
    \ (list-ref (list-ref letters (- 1 (string-length message)))\n               \
    \              (substring (first message) 0 2)\n                             (substring\
    \ (first message) 2))\n                      (encode (rest message)))))\n    \
    \  (let* ((vowels #{'a e i o u})\n             (letters #{'a b c d f g h j k l\
    \ m n p q r s t v w x y z}))\n        (cond ((empty? message) \"\")\n        \
    \      ((char=? (first message) 'A) (char=? (first message) 'Z)) \n          \
    \    ((char=? (first message) 'a) (char=? (first message) 'z)) \n            \
    \  (else \n              (append (list-ref (list-ref letters (- 1 (string-length\
    \ message)))\n                             (substring (first message) 0 2)\n \
    \                            (substring (first message) 2))\n                \
    \      (encode (rest message)))))\n      (let* ((vowels #{'a e i o u})\n     \
    \        (letters #{'a b c d f g h j k l m n p q r s t v w x y z}))\n        (cond\
    \ ((empty? ", "  (define (enc m i j) \n    (cond\n      [(empty? m) m]\n     \
    \ [(equal? i (first m)) (char j (second m))] \n      [else (enc m i (add1 j))]))\n\
    \  (enc message 'a 'b))\n", "  (cond\n    [(empty? message) \"Z\"]\n    [(symbol?\
    \ (car message)) (encode-symbol (car message))]\n    [else (encode-letter (car\
    \ message) (encode (cdr message)))]))\n", "  (let ([alphabet (make-alphabet (list-length\
    \ message))])\n    (loop [i 0]\n      (let ([letter (substring message i)])\n\
    \        (when (equal? (char-code (substring alphabet (+ i (char-code letter))))\
    \ 65)\n          (set! i (+ i (char-code letter)))\n          (set! alphabet (substring\
    \ alphabet i))\n          (set! i (+ i (char-code letter)))\n          (set! alphabet\
    \ (substring alphabet i))\n          (set! i (+ i (char-code letter)))\n     \
    \     (set! alphabet (substring alphabet i))\n          (set! i (+ i (char-code\
    \ letter)))\n          (set! alphabet (substring alphabet i))\n          (set!\
    \ i (+ i (char-code letter)))\n          (set! alphabet (substring alphabet i))\n\
    \          (set! i (+ i (char-code letter)))\n          (set! alphabet (substring\
    \ alphabet i))\n          (set! i (+ i (char-code letter)))\n          (set! alphabet\
    \ (substring alphabet i))))\n        (set! i (+ i (char-code letter)))\n     \
    \   alphabet))))\n", "  (cond\n    [(empty? message) \"\"]\n    [(equal? (first\
    \ message) #\\a) (encode-vowel-first (rest message))]\n    [(equal? (first message)\
    \ #\\e) (encode-vowel-second (rest message))]\n    [(equal? (first message) #\\\
    i) (encode-vowel-third (rest message))]\n    [(equal? (first message) #\\o) (encode-vowel-fourth\
    \ (rest message))]\n    [(equal? (first message) #\\u) (encode-vowel-fifth (rest\
    \ message))]\n    [(equal? (first message) #\\y) (encode-vowel-sixth (rest message))]\n\
    \    [else (encode-lower-case message)]))\n", "  ;; Scan the string once to map\
    \ the letters to numbers\n  ;; then map the numbers to their original letters.\n\
    \  (define (map char map)\n    ;; Find the index of the letter in the map\n  \
    \  (define (char-index (char map))\n      \n      ;; Get the index for that letter\n\
    \      (define (find char map)\n        ;; Find the index of the letter in the\
    \ map\n        (define (char-index (char map))\n          (cond\n            ;;\
    \ If char is in the map, return its index\n            (char-in-map char map)\n\
    \            \n            ;; If char is not in the map, return #f \n        \
    \    (#f '#f)\n          ))\n        \n        ;; Return the index\n        char-index)\n\
    \      \n      ;; Return the index\n      (find char map))\n    \n  ;; Get the\
    \ letters in the message\n  (define (get-letters message)\n    (for-each (lambda\
    \ (char) (char-index char)) message))\n  \n  ;; Get the numbers associated with\
    \ the letters\n  (define (get-numbers map message)\n    (let ((nums (list))\n\
    \          (result (list (first map)))\n          (i 0))\n      (for-each (lambda\
    \ (letter) (set! nums (cdr (assoc letter map))))\n                message\n  \
    \              (lambda (num)\n                  (set! result (cons (first nums)\
    \ result)))\n                (lambda () \n                  (set! i (+ i 1))\n\
    \                  result))))\n  \n  ;; Create a map of all the letters in the\
    \ english alphabet\n  (define (create-map alphabet)\n    (map (lambda (char) (char-index\
    \ char)) alphabet))\n  \n  ;; Create a map of all the vowels in the english alphabet\n\
    \  (define (create-vowel-map alphabet)\n    (let ((vowels (list)))\n      (for-each\
    \ (lambda (char) (char-index char)) alphabet\n                (lambda (char)\n\
    \                  (cond \n                    (\n                      (char-in-map\
    \ char vowels)\n                      \n                      ;; If char is a\
    \ vowel, add it to the vowels list\n                      (set! vowels (cons char\
    \ vowels))\n                      \n                      ;; If char is not a\
    \ vowel, add it to the vowels list\n                      (set! vowels (cons (-\
    \ char 26) (cons char vowels)))\n                    )\n                  )\n\
    \                )\n              )\n      (list)))\n  \n  ;; Create a map of\
    \ all the numbers for the letters\n  (define (create-numbers-map map message)\n\
    \    (let ((numbers (list))\n          (", "  (let ((result (make-string (string-length\
    \ message) )))\n    (loop for i from 0 to (string-length message) \n         collect\
    \ (if (char=? (substring message i) 'A) (char->string\n                      \
    \                              (+ (char->integer (char->string (substring message\
    \ i))\n                                                              (char->integer\
    \ (char->string (substring message (i + 1) ))))) \n                          \
    \                          (substring message i))\n                 into result)))\n",
  "  (let ([vowels '(a e i o u y)])\n    (define (subst vowel)\n      (cond\n    \
    \    [(member (char-after vowel) '(A E I O U Y)) (subst (char-after vowel))]\n\
    \        [else vowel]))\n    (cond\n      [(empty? message) message]\n      [else\
    \ (apply (append (map (lambda (c) (subst c)) vowels) message))]))\n", "  (define\
    \ (helper message current-letter next-letter)\n    (cond\n      [(empty? message)\
    \ message]\n      [(equal? (char-lower-case current-letter) next-letter) (helper\
    \ (cdr message) current-letter (char-upper-case next-letter))]\n      [else (helper\
    \ (cdr message) (char-upper-case current-letter) (char-lower-case next-letter))]))\n\
    \  (helper message (char-upper-case 'a') (char-lower-case 'z')))\n", "  (let loop\
    \ ((counter 0)\n             (output \"\")\n             (message message))\n\
    \    (if (empty? message)\n        (reverse output)\n        (loop (add1 counter)\n\
    \              (if (string=? (nth (sub1 counter) message) \n                 \
    \           (sub (nth counter message) \n                                 message))\n\
    \                  (cons (sub (nth counter message) message)\n               \
    \         output)\n                  (cons message output)\n                 \
    \ )\n              (sub1 counter)\n              ))))", "  (let ((alphabet (list\
    \ 'A B C D E F G H I J K L M N O P Q R S T U V W X Y Z)))\n    (cond\n      [(empty?\
    \ message) \"\"]\n      [(empty? (rest message)) message]\n      [else\n     \
    \  (cond\n         [(member alphabet (rest message)) (cons alphabet \n       \
    \                                            (encode (substring message 0 (- (length\
    \ message) 2)))]\n         [else (cons (char->integer (char->lower (first message)))\
    \ (encode (substring message 1)))]))]))) \n", "  (cond\n    [(empty? message)\
    \ message]\n    [(empty? (rest message)) (cons (first message) (encode (rest message)))]\n\
    \    [else (concat (encode-case-vowels (rest message)) (encode (first message)))]))\n",
  "  (if (null? message) '()\n      (map (\u03BB (c) (cond [(member c '(a e i o u))\
    \ (car \n                              (filter (\u03BB (v) (member v '(a e i o\
    \ u))) \n                                       message))]\n                 \
    \ [(member c '(a e i o u)) (list c (list-ref message (member c '(a e i o u)) 2))]))\n\
    \                  (filter (\u03BB (c) (member c '(a e i o u))) message))))\n",
  "  (let ((output (make-list 256)))\n    (define (helper i c)\n      (if (= i (string-length\
    \ message))\n          output\n          (set! output\n                (char-ref\
    \ message i)\n                (char-ref output (char-ref output (char-ref output\
    \ (char-ref output (char-ref output (substring output 0 i)) 2))))\n          \
    \      (helper 1 (char-ref message i)))\n      (set! output\n            (char-ref\
    \ output (char-ref output (char-ref output (char-ref output (char-ref output (substring\
    \ output 0 i)) 3))))\n            (char-ref output (char-ref output (char-ref\
    \ output (char-ref output (char-ref output (char-ref output (substring output\
    \ 0 i)) 4)) c))))\n    (helper (string-length message) 'A))\n  output)\n", " \
    \ (define (vowel-counter (vowel string)\n    (cond\n      [(string=? vowel \"\"\
    )\n       (string)\n       ;; No vowels in message, so return string\n       string]\n\
    \      [(string=? (substring (string vowel) 2)\n                  \"ay\")\n  \
    \     (+ (string-length string) (substring string 1))]\n      [else\n       (cond\n\
    \         [(string=? (substring (string vowel) 2)\n                    \"AEIOU\"\
    )\n         (cond\n           [(string=? (substring (string vowel) 3)\n      \
    \                \"AEIOU\")\n           (+ (string-length string) (substring string\
    \ 2))]\n           [else\n            (+ (string-length string) (substring string\
    \ 1))]\n           ])]\n         [else\n          (cond\n            [(string=?\
    \ (substring (string vowel) 2)\n                      \"AEIOU\")\n           \
    \ (cond\n              [(string=? (substring (string vowel) 3)\n             \
    \           \"AEIOU\")\n               (cond\n                 [(string=? (substring\
    \ (string vowel) 4)\n                           \"AEIOU\")\n                 (+\
    \ (string-length string) (substring string 2))]\n                 [else\n    \
    \              (+ (string-length string) (substring string 1))]\n            \
    \     ])]\n              [else\n               (+ (string-length string) (substring\
    \ string 1))]\n              ])]\n            [else\n            (+ (string-length\
    \ string) (substring string 1))]\n            [else\n            (+ (string-length\
    \ string) (substring string 1))]\n            ])]\n         [else\n          (cond\n\
    \            [(string=? (substring (string vowel) 2)\n                      \"\
    AEIOU\")\n            (cond\n              [(string=? (substring (string vowel)\
    \ 3)\n                        \"AEIOU\")\n               (cond\n             \
    \    [(string=? (substring (string vowel) 4)\n                           \"AEIOU\"\
    )\n                 (+ (string-length string) (substring string 2))]\n       \
    \          [else\n                  (+ (string-length string) (substring string\
    \ 1))]\n                 ])]\n              [else\n               (+ (string-length\
    \ string) (substring string 1))]\n              ])]\n            [else\n     \
    \       (+ (string-length string) (substring string 1))]\n            [else\n\
    \            (+ (string-length string) (substring string 1))]\n            ])]\n\
    \         [else\n          (cond\n            [(string=? (substring (string vowel)\
    \ 2)\n                      \"AEIOU\")\n            (cond\n              [(string=?\
    \ (substring (string vowel) 3)\n                        \"AEIOU\")\n         \
    \      (cond\n                 [(string=? (", "  (cond\n    [(empty? message)\
    \ \"\"]\n    [(empty? (rest message)) (cons message \"\")]\n    [(equal? (first\
    \ message) (string-ref message 0)) (cons (first message) message)]\n    [else\
    \ (cons (first message) (encode (rest message))) (encode (rest message))]\n  ))",
  "  (let ([new-message \"\"]) \n    (for ([i (string-length message)]) \n      (let\
    \ ([letter (char-ref message i)])\n        (cond\n          [(string=? letter\
    \ #\\A)\n           (cond\n             [(char=? (char-ref message (i-1)) #\\\
    a)\n               (set! new-message \n                     (string-append new-message\
    \ letter))\n               (cond\n                 [(char=? (char-ref message\
    \ (i+2)) #\\A)\n                   (set! new-message \n                      \
    \  (string-append new-message letter))\n                 (cond\n             \
    \      [(char=? (char-ref message (i+2)) #\\z)\n                    (set! new-message\
    \ \n                          (string-append new-message \n                  \
    \                     (char-ref message (i+1))))\n                   new-message]\n\
    \                 [else new-message])]\n              [else new-message]\n   \
    \          [else new-message])]\n          [(string=? letter #\\z)\n         \
    \  (cond\n             [(char=? (char-ref message (i-1)) #\\z)\n             \
    \  (set! new-message \n                     (string-append new-message letter))\n\
    \               (cond\n                 [(char=? (char-ref message (i+1)) #\\\
    A)\n                   (set! new-message \n                        (string-append\
    \ new-message letter))\n                 (cond\n                   [(char=? (char-ref\
    \ message (i+1)) #\\z)\n                    (set! new-message \n             \
    \             (string-append new-message \n                                  \
    \     (char-ref message (i-1))))\n                   new-message]\n          \
    \       [else new-message])]\n             [else new-message])]\n          [(string=?\
    \ letter #\\A)\n           (cond\n             [(char=? (char-ref message (i-1))\
    \ #\\z)\n               (set! new-message \n                     (string-append\
    \ new-message letter))\n               (cond\n                 [(char=? (char-ref\
    \ message (i-1)) #\\z)\n                   (set! new-message \n              \
    \          (string-append new-message letter))\n                 (cond\n     \
    \              [(char=? (char-ref message (i+1)) #\\z)\n                    (set!\
    \ new-message \n                          (string-append new-message \n      \
    \                                 (char-ref message (i-1))))\n               \
    \    new-message]\n                 [else new-message])]\n             [else new-message])]\n\
    \          [new-message])\n    (new-message)))\n</code>\n<|/ a dscore=0 tags=racket,scheme\
    \ |>\n<| c |>\nI did think about writing a recursive function that would swap\
    \ the case, but I couldn't get that ", "  (apply str ((for [char (string->list\
    \ (string->symbol message))]\n              (let* ((index (char-index (char-upcase\
    \ char)))\n                     (index-2 index (+ index 2)))\n              (cond\n\
    \                 ((and (not (member (char-name char) '(\"a\" \"e\" \"i\" \"o\"\
    \ \"u\" \"y\"))) (= index 0))\n                  (cons char char))\n         \
    \        ((member (char-name char) '(\"a\" \"e\" \"i\" \"o\" \"u\" \"y\"))\n \
    \                 (cond\n                    ((null? index-2)\n              \
    \       (cons (char-name char) char))\n                    ((null? (subseq index-2\
    \ 1))\n                     (cons (subseq index-2 0) (char-name char)))\n    \
    \                (else (cond\n                              ((= (subseq index-2\
    \ 1) (subseq index))\n                               (cons (subseq index-2 1)\
    \ (char-name char)))\n                              (else (cons (char-name char)\
    \ (subseq index-2 1)))))))))))))\n", "  (encode-helper message (list '() (list)))\n\
    \  )\n", "  (define (swapCase letter)\n    (if (member letter #{'a A e E i I o\
    \ O u U y Y})\n        letter\n        (char->integer (char->string\n        \
    \              (byte-string-reverse (substring letter 0 3)))))\n    (substring\
    \ letter (+ 0 (char->integer (char->string \n                                \
    \           (byte-string-reverse (substring letter 0 1))))))))\n  \n  (define\
    \ (replaceVowels letter)\n    (let ((vowels '(a e i o u)))\n      (if (member\
    \ letter vowels)\n          letter\n          (substring letter 0 (+ (char->integer\
    \ (char->string (byte-string-reverse (substring letter 0 3))))\n             \
    \                (char->integer (char->string (byte-string-reverse (substring\
    \ letter 0 1)))))))\n      )))\n    \n  (define (processString str idx startIdx\
    \ endIdx)\n    (cond (and (positive? idx) (< idx endIdx)) \n          (string\
    \ \"\")\n          (else (cons (string (replace (substring str startIdx idx) (substring\
    \ str startIdx endIdx) \n                                           (encode (substring\
    \ str idx endIdx)))))\n             (processString str (+ idx 1) startIdx endIdx))))\n\
    \  (processString message 0 0 (length message)))\n", "  (let* ((vowels '(a e i\
    \ o u))\n         (vowel-positions (loop for vowel in vowels\n               \
    \                collect (list-ref (hash-ref vowel-frequencies vowel) 0)))\n \
    \        (consonants '(a e i o u y w z))\n         (consonant-positions (loop\
    \ for consonant in consonants\n                                collect (list-ref\
    \ (hash-ref consonant-frequencies consonant) 0)))\n         (vowel-pairs (list-ref\
    \ (append vowel-positions consonant-positions) 0))\n         (substitutions '(a\
    \ a b b c c d d e e f f g g h h i i j j k k l l m m n n o o p p q q r r s s t\
    \ t u u v v w w x x y y z))\n         (letter-pairs (loop for pair in vowel-pairs\n\
    \                           collect (first pair)))\n         (letter-positions\
    \ (loop for letter in letters\n                              collect (list-ref\
    \ (hash-ref letter-frequencies letter) 0)))\n         (substitution-positions\
    \ (loop for pair in letter-pairs\n                                   collect (list-ref\
    \ substitutions \n                                                 (hash-ref letter-positions\
    \ \n                                                   (first pair)))))\n    \
    \     (substitutions (loop for pair in letter-pairs\n                        \
    \   collect (second pair)))\n         (result (make-string (string-length message)\n\
    \                          (append message (make-array string-length #\\)))))\n\
    \    (loop for i from 0\n          for character in message\n          for substitution\
    \ in substitutions\n          for pair in letter-pairs\n          for position\
    \ in substitution-positions \n          for position2\n          in vowel-positions\n\
    \          for substitution2 in (substitution-positions)\n          when (= position\
    \ position2)\n          do (string-set! result i (string-set! result i substitution\
    \ (list-ref substitution2 i))))\n    (string-set! result (string-length result)\
    \ #\\)))\n", "  (let* ((letters (string->list (string->symbol (string->list message)))))\n\
    \    (define (letter n)\n      (cond\n        ((< n 26) (string-ref letters (+\
    \ n 1)))\n        ((= n 26) (string-ref letters 'a'))\n        (else (string-ref\
    \ letters 'a')))\n    (define (affine letter next-letter)\n      (cond\n     \
    \   ((< next-letter 26) (string-append letter next-letter))\n        ((= next-letter\
    \ 26) (string-append 'a 'a))\n        (else (string-append 'a 'a)))\n    (define\
    \ (next-letter n)\n      (cond\n        ((< n 26) (string-ref letters (+ n 1)))\n\
    \        ((= n 26) (string-ref letters 'a'))\n        (else (string-ref letters\
    \ 'a')))\n    (apply (lambda (letter) (lambda (next-letter) (let ((n (+ n 1)))\
    \ (cond\n                                                  ((< n 26) (string-append\
    \ letter next-letter))\n                                                  ((=\
    \ n 26) (string-append 'a 'a))\n                                             \
    \     (else (string-append 'a 'a)))))) letters))))\n</code>\nAnd here's the decoding\
    \ function using Racket:\n<code>\n#lang racket\n", "  (define (swap-case string)\n\
    \    (define (letter position)\n      (cond \n        ((> position 0) (string-append\
    \ (substring string 0 position)\n                                    (substring\
    \ string position (string- \n                                                \
    \      length string) position)))\n        (else string)))\n    (define (vowel-position\
    \ vowel)\n      (cond \n        ((> vowel (string- 0 string) (string- 1 string)\
    \ (string- 2 string)) 3)\n        (else 0)))\n    (define (vowel-string position)\n\
    \      (cond \n        ((> position 0) (string-append (substring string 0 position)\n\
    \                                    (substring string position (string- \n  \
    \                                                    length string) position)))\n\
    \        (else string)))\n    (define (vowel-positions string)\n      (cond \n\
    \        ((string= string \"\") \"\")\n        ((string= string \"a\") (list (vowel-position\
    \ \"a\"))\n        (string= string \"e\") (list (vowel-position \"e\"))\n    \
    \    (string= string \"i\") (list (vowel-position \"i\"))\n        (string= string\
    \ \"o\") (list (vowel-position \"o\"))\n        (string= string \"u\") (list (vowel-position\
    \ \"u\")))\n        ((string= string \"A\") (list (vowel-position \"A\"))\n  \
    \      (string= string \"E\") (list (vowel-position \"E\"))\n        (string=\
    \ string \"I\") (list (vowel-position \"I\"))\n        (string= string \"O\")\
    \ (list (vowel-position \"O\"))\n        (string= string \"U\") (list (vowel-position\
    \ \"U\")))))\n    (define (vowel-string position)\n      (cond \n        ((> position\
    \ 0) (string-append (substring string 0 position)\n                          \
    \          (substring string position (string- \n                            \
    \                          length string) position)))\n        (else string)))\n\
    \    (define (vowel-positions string)\n      (cond \n        ((string= string\
    \ \"\") \"\")\n        ((string= string \"a\") (list (vowel-position \"a\"))\n\
    \        (string= string \"e\") (list (vowel-position \"e\"))\n        (string=\
    \ string \"i\") (list (vowel-position \"i\"))\n        (string= string \"o\")\
    \ (list (vowel-position \"o\"))\n        (string= string \"u\") (list (vowel-position\
    \ \"u\")))\n        ((string= string \"A\") (list (vowel-position \"A\"))\n  \
    \      (string= string \"E\") (list (vowel-position \"E\"))\n", "  (let ([vowels\
    \ '(a e i o u)])\n    (encode-case\n     (string->list (string message))\n   \
    \  (lambda (letter)\n       (if (member letter vowels)\n           (member letter\
    \ (string->list (string message)))\n           letter)))))\n</code>\nEDIT 2:\n\
    I made a mistake thinking that string->list was a commutative function. It actually\
    \ turns out the case function needs to be commutative because it needs to return\
    \ the same value for each argument (unless it's already in the right case). I\
    \ edited my code accordingly.\n<|/ a tags=scheme,racket,string,list |>\n<| c |>\n\
    I get the following errors: Error: attempt to define undefined identifier: encode-case\n\
    \ context...:\n  /Applications/Racket v6.6/collects/racket/private/racket-implementation.rkt:90:4:\
    \ undefined\n identifier: encode-case\n context...:\n  /Applications/Racket v6.6/collects/racket/private/racket-implementation.rkt:90:4:\
    \ undefined\n identifier: encode-case\n<|/ c |>\n<| c |>\nI used your function\
    \ and I get this errors: Error: attempt to define a named let: encode-case\n context...:\n\
    \  /Applications/Racket v6.6/collects/racket/private/racket-implementation.rkt:90:4:\
    \ undefined\n identifier: encode-case\n context...:\n  /Applications/Racket v6.6/collects/racket/private/racket-implementation.rkt:90:4:\
    \ undefined\n identifier: encode-case\n<|/ c |>\n<| c |>\nOh, sorry, I made a\
    \ mistake: this isn't a named let but the case function that you defined. I'll\
    \ edit my answer to fix that problem.\n<|/ c |>\n<| a tags=scheme,racket,string,list\
    \ |>\nThe simplest approach to this question would be to convert to a string,\
    \ split the string on whitespace, map the splitted string to a list, then map\
    \ the list to lowercase:\n<code>", "  (cond\n    [(empty? message) empty]\n  \
    \  [else (let* ([(vowels '(a e i o u))\n                  [a (cons 'a vowels)]\n\
    \                  [e  (cons 'e vowels)]\n                  [i  (cons 'i vowels)]\n\
    \                  [o  (cons 'o vowels)]\n                  [u  (cons 'u vowels)]\n\
    \                  [vowels (cons 'v vowels)]\n                  [v  (cons 'v vowels)]\n\
    \                  [message  (cons (first message) vowels)]])\n           (map\
    \ (\u03BB (c) (cond\n                          [(vowel-position? (c) message)\n\
    \                           (list (+ (c) (second message) 1))]\n             \
    \             [(>= (c) (second message))\n                           (list (first\
    \ c) (+ (c) (second message) 1))]))\n               vowels)])))\n", "  (cond\n\
    \    [(empty? message) \"\"]\n    [(member (first (first message)) (to-lower (first\
    \ message)))\n      (cons (char->string (char->integer (char->integer 'a))\n \
    \                 (char->integer (char->integer 'A))\n                  (char->integer\
    \ 'a) (char->integer 'A))\n            (encode (rest message)))]\n    [else (encode-helper\
    \ (first message)\n                        (rest message)])\n  ))\n", "  (cond\n\
    \    [(empty? message) \"\"]\n    [(equal? (char-after (car message)) 'a) (char-after\
    \ (char-before (car message)) 'a)]\n    [(equal? (char-after (car message)) 'A)\
    \ (char-after (char-before (car message)) 'A)]\n    [(equal? (char-after (car\
    \ message)) 'e) (char-after (char-before (car message)) 'e)]\n    [(equal? (char-after\
    \ (car message)) 'E) (char-after (char-before (car message)) 'E)]\n    [(equal?\
    \ (char-after (car message)) 'i) (char-after (char-before (car message)) 'i)]\n\
    \    [(equal? (char-after (car message)) 'I) (char-after (char-before (car message))\
    \ 'I)]\n    [(equal? (char-after (car message)) 'o) (char-after (char-before (car\
    \ message)) 'o)]\n    [(equal? (char-after (car message)) 'O) (char-after (char-before\
    \ (car message)) 'O)]\n    [(equal? (char-after (car message)) 'u) (char-after\
    \ (char-before (car message)) 'u)]\n    [(equal? (char-after (car message)) 'U)\
    \ (char-after (char-before (car message)) 'U)])", "  (cond\n    [(empty? message)\
    \ (error \"Empty message.\")]\n    [else\n     (let ((alphabet (make-array '(26)))\n\
    \           (offset 0))\n      (loop for [char message]\n         ;; Find the\
    \ index of the char in the alphabet\n         (let ([index (position char alphabet)])\n\
    \           (unless index\n             (set! alphabet (append alphabet (list\
    \ char)))\n             index))\n         ;; Encode the char\n         (let ([char\
    \ (char->integer char)])\n           (cond\n             [(<= 2 offset) (set!\
    \ alphabet (subseq alphabet 1 index))\n               (+ offset 1)\n         \
    \      (set! offset 0)]\n             [(char->integer 'a) (set! alphabet (subseq\
    \ alphabet index index))\n               (+ offset 1)\n               (set! offset\
    \ 0)]\n             [else (char->integer 'z) (set! alphabet (subseq alphabet index\
    \ index))\n               (+ offset 1)\n               (set! offset 0)]\n    \
    \         [(char->integer 'A) (set! alphabet (subseq alphabet index index))\n\
    \               (+ offset 1)\n               (set! offset 0)]\n             [else\
    \ (set! offset 0)]\n             [(char->integer 'Z) (set! alphabet (subseq alphabet\
    \ 0 index))\n               (+ offset 1)\n               (set! offset 0)]\n  \
    \           [else (error \"Only letters are allowed.\")]\n             [else (error\
    \ \"Unreachable.\")]))]))\n", "  (cond\n    [(empty? message) \"\"]\n    [(equal?\
    \ (first message) ?A) (cons (char ?A) (encode (second message)))]\n    [(equal?\
    \ (first message) ?a) (cons (char ?a) (encode (second message)))]\n    [(equal?\
    \ (first message) ?E) (cons (char ?E) (encode (second message)))]\n    [(equal?\
    \ (first message) ?e) (cons (char ?e) (encode (second message)))]\n    [(equal?\
    \ (first message) ?I) (cons (char ?I) (encode (second message)))]\n    [(equal?\
    \ (first message) ?i) (cons (char ?i) (encode (second message)))]\n    [(equal?\
    \ (first message) ?O) (cons (char ?O) (encode (second message)))]\n    [(equal?\
    \ (first message) ?o) (cons (char ?o) (encode (second message)))]\n    [(equal?\
    \ (first message) ?U) (cons (char ?U) (encode (second message)))]\n    [(equal?\
    \ (first message) ?u) (cons (char ?u) (encode (second message)))]\n    [(equal?\
    \ (first message) ?Y) (cons (char ?Y) (encode (second message)))]\n    [(equal?\
    \ (first message) ?y) (cons (char ?y) (encode (second message)))]\n    [else (cons\
    \ (char ? (encode-vowel (second message))))]))\n", "  (cond\n    ((null? message)\
    \ #f)\n    ((string=? message #\\space) #f)\n    ((string=? message #\\newline)\n\
    \     (cond\n       ((string=? message #\\space) #f)\n       ((string=? message\
    \ #\\tab) #f)\n       ((string=? message #\\return) #f)\n       ((string=? message\
    \ #\\backslash) #f)\n       ((string=? message #\\newline) #f)\n       ((string=?\
    \ message #\\e) #f)\n       ((string=? message #\\g) #f)\n       ((string=? message\
    \ #\\h) #f)\n       ((string=? message #\\i) #f)\n       ((string=? message #\\\
    k) #f)\n       ((string=? message #\\l) #f)\n       ((string=? message #\\o) #f)\n\
    \       ((string=? message #\\p) #f)\n       ((string=? message #\\q) #f)\n  \
    \     ((string=? message #\\r) #f)\n       ((string=? message #\\s) #f)\n    \
    \   ((string=? message #\\t) #f)\n       ((string=? message #\\v) #f)\n      \
    \ ((string=? message #\\0) #f)\n       ((string=? message #\\1) #f)\n       ((string=?\
    \ message #\\2) #f)\n       ((string=? message #\\3) #f)\n       ((string=? message\
    \ #\\4) #f)\n       ((string=? message #\\5) #f)\n       ((string=? message #\\\
    6) #f)\n       ((string=? message #\\7) #f)\n       ((string=? message #\\8) #f)\n\
    \       ((string=? message #\\9) #f)\n       ((string=? message #\\colon) #f)\n\
    \       ((string=? message #\\dash) #f)\n       ((string=? message #\\equals)\
    \ #f)\n       ((string=? message #\\less) #f)\n       ((string=? message #\\greater)\
    \ #f)\n       ((string=? message #\\question) #f)\n       ((string=? message #\\\
    at) #f)\n       ((string=? message #\\apostrophe) #f)\n       ((string=? message\
    \ #\\quotation) #f)\n       ((string=? message #\\ampersand) #f)\n       ((string=?\
    \ message #\\ampersand) #f)\n       ((string=? message #\\asterisk) #f)\n    \
    \   ((string=? message #\\asterisk) #f)\n       ((string=? message #\\plus) #f)\n\
    \       ((string=? message #\\plus) #f)\n       (", "  (define (helper s letter\
    \ index)\n    (if (= index 0)\n        (cons (case letter (a-z A-Z A B C D E F\
    \ G H I J K L M N O P Q R S T U V W X Y Z) letter)\n              s)\n       \
    \ (helper (cons letter s)\n                (case letter (a-z A-Z A B C D E F G\
    \ H I J K L M N O P Q R S T U V W X Y Z) letter)\n                (+ index 1))))\n\
    \  (helper () '() 0))\n</cell>\n<code language=racket>", "  (let ([vowels '(\"\
    a\" \"e\" \"i\" \"o\" \"u\")])\n    (cond\n      [(string? message) message]\n\
    \      [else (append\n             (append (map #(cond [(string? (char-code (first\
    \ %)))\n                                 (string-append (list (char-code (first\
    \ %))\n                                                    (list char-code \n\
    \                                                          (second %)))\n    \
    \                                       (first %)])\n                      vowels)\n\
    \                   (map char-code (map #(cond [(string? (char-code %)) %]\n \
    \                                            [else (list %)]) message)))))]))\n",
  "  (let loop ([i 0] [v \"\"])\n    (cond [(empty? message) \"\"]\n          [(char=?\
    \ (first message) (first v)) \n           (cons v (loop (+ i 2) (first v)))]\n\
    \          [(char=? (first message) (second v)) \n           (cons (second v)\
    \ (loop (+ i 2) (second v)))]\n          [else\n           (loop (+ i 2) (first\
    \ v))]))))\n", "  (define (enc c i)\n    (if (= i 0)\n        (concat '(c c)\n\
    \                 (cons (string->list (char->string (cdr (char->string c))) \n\
    \                             (char->string c))\n                       nil)\n\
    \                 )\n        (cons (char->string c)\n               (enc c (-\
    \ i 1)))\n        )\n      )\n  (enc message (length message)))\n", "  (map (lambda\
    \ (c) (if (char=? c 'a) (char=? (char-after c 'a) 'z) (char-after c 'a)))\n  \
    \     (map (lambda (c) (if (char=? c 'a) 'A (char-after c 'a)))\n           (range\
    \ (length message))))\n  message)\n", "  (let loop ((i 0)\n             (newmessage\
    \ (copy-string message)))\n    (cond ((empty? newmessage)\n           (copy-string\
    \ \"~\"))\n          ((equal? i (length (substring (string (first newmessage)\
    \ 0)\n                               (string-index newmessage (first newmessage)\
    \ 0)))\n                 (string-index newmessage (first newmessage) 0))\n   \
    \        (loop (+ i 1)\n                  (newstring (substring newmessage 0 i)))\n\
    \          ((equal? (string-index newmessage (first newmessage) 0)\n         \
    \         (string-index newmessage (string-index newmessage (first newmessage)\
    \ 0) 0))\n           (let ((nextletter (second (substring (string (first newmessage)\
    \ 0)\n                                        (string-index newmessage (first\
    \ newmessage) 0)) \n                            (substring (string (second newmessage)\
    \ 0)\n                                      (string-index newmessage (second newmessage)\
    \ 0)))\n                 (nextletter2 (second (substring (string (second newmessage)\
    \ 0)\n                                        (string-index newmessage (second\
    \ newmessage) 0)) \n                            (substring (string (third newmessage)\
    \ 0)\n                                      (string-index newmessage (third newmessage)\
    \ 0)))\n                 (nextletter3 (second (substring (string (third newmessage)\
    \ 0)\n                                        (string-index newmessage (third\
    \ newmessage) 0)) \n                            (substring (string (fourth newmessage)\
    \ 0)\n                                      (string-index newmessage (fourth newmessage)\
    \ 0)))\n                 (nextletter4 (second (substring (string (fourth newmessage)\
    \ 0)\n                                        (string-index newmessage (fourth\
    \ newmessage) 0)) \n                            (substring (string (fifth newmessage)\
    \ 0)\n                                      (string-index newmessage (fifth newmessage)\
    \ 0)))\n                 (nextletter5 (second (substring (string (fifth newmessage)\
    \ 0)\n                                        (string-index newmessage (fifth\
    \ newmessage) 0)) \n                            (substring (string (sixth newmessage)\
    \ 0)\n                                      (string-index newmessage (sixth newmessage)\
    \ 0)))\n                 (nextletter6 (second (substring (string (sixth newmessage)\
    \ 0)\n                                        (string-index newmessage (sixth\
    \ newmessage) 0)) \n                            (substring (string (seventh newmessage)\
    \ 0)\n                                      (string-index newmessage (seventh\
    \ newmessage) 0)))\n                 (nextletter7 (second (substring (string (seventh\
    \ newmessage) 0)\n                                        (string-index newmessage\
    \ (seventh newmessage) 0)) \n                            (substring (string (eighth\
    \ newmessage) ", "  (let ((message (list->string (list->list (string->list message)))))\n\
    \    (encode1 message 0)))\n", "  (cond\n    [(empty? message) empty]\n    [(match\
    \ (first message) 'a) (replace (first message) 'a \n                         \
    \    ((- 'a 1) (first message)))]\n    [(match (first message) 'b) (replace (first\
    \ message) 'b \n                             ((- 'b 1) (first message)))]\n  \
    \  [(match (first message) 'c) (replace (first message) 'c \n                \
    \             ((- 'c 1) (first message)))]\n    [(match (first message) 'd) (replace\
    \ (first message) 'd \n                             ((- 'd 1) (first message)))]\n\
    \    [(match (first message) 'e) (replace (first message) 'e \n              \
    \               ((- 'e 1) (first message)))]\n    [(match (first message) 'f)\
    \ (replace (first message) 'f \n                             ((- 'f 1) (first\
    \ message)))]\n    [(match (first message) 'g) (replace (first message) 'g \n\
    \                             ((- 'g 1) (first message)))]\n    [(match (first\
    \ message) 'h) (replace (first message) 'h \n                             ((-\
    \ 'h 1) (first message)))]\n    [(match (first message) 'i) (replace (first message)\
    \ 'i \n                             ((- 'i 1) (first message)))]\n    [(match\
    \ (first message) 'j) (replace (first message) 'j \n                         \
    \    ((- 'j 1) (first message)))]\n    [(match (first message) 'k) (replace (first\
    \ message) 'k \n                             ((- 'k 1) (first message)))]\n  \
    \  [(match (first message) 'l) (replace (first message) 'l \n                \
    \             ((- 'l 1) (first message)))]\n    [(match (first message) 'm) (replace\
    \ (first message) 'm \n                             ((- 'm 1) (first message)))]\n\
    \    [(match (first message) 'n) (replace (first message) 'n \n              \
    \               ((- 'n 1) (first message)))]\n    [(match (first message) 'o)\
    \ (replace (first message) 'o \n                             ((- 'o 1) (first\
    \ message)))]\n    [(match (first message) 'p) (replace (first message) 'p \n\
    \                             ((", "  (let ((letters '())\n        (vowels '()\n\
    \            (vowels 'a\n                'e\n                'i\n            \
    \    'o\n                'u\n                'y\n                'a\n        \
    \        'e\n                'i\n                'o\n                'u\n    \
    \            'y\n                'A\n                'E\n                'I\n\
    \                'O\n                'U\n                'Y\n                'a\n\
    \                'e\n                'i\n                'o\n                'u\n\
    \                'y\n                'A\n                'E\n                'I\n\
    \                'O\n                'U\n                'Y)))\n    (string-append\n\
    \        (string->string\n            (loop for i from 0 below string->length\
    \ message\n                  collect (substring message i 1))\n            (loop\
    \ for i from 0\n                  for letter from (list->string (list->list (take\
    \ letters i vowels)))\n                  collect (substring letter 2 1)))\n  \
    \      (loop for i from 0 below (string->length message)\n              collect\
    \ (substring message i 1)))\n    (string->string\n        (loop for i from 0\n\
    \              for letter from (list->string (list->list (take letters i vowels)))\n\
    \              collect (substring letter 2 1)))\n    (string->string\n       \
    \ (loop for i from 0\n              for letter from (list->string (list->list\
    \ (take letters i vowels)))\n              collect (substring letter 2 1)))))\n\
    </code>\n<code>\n#lang racket\n", "  (cond\n    [(string-empty? message) \"\"\
    ]\n    [else (let\n           ([first \n              (substring message 0 (-\
    \ (length message) 2))])\n            (cond\n             [(substring message\
    \ 1 1)\n              (let\n               ([vowels '(a e i o u)])\n         \
    \       (append (map car\n                           (map (lambda (vowel) (append\
    \ vowel first))\n                               vowels))\n                   \
    \      first)\n                     second)]\n             [(substring message\
    \ 1 1)\n              (let\n               ([vowels '(A E I O U)])\n         \
    \       (append (map car\n                           (map (lambda (vowel) (append\
    \ vowel first))\n                               vowels))\n                   \
    \      first)\n                     second)]\n             [(substring message\
    \ 1 1)\n              (let\n               ([vowels '(A E I O U)])\n         \
    \       (append (map car\n                           (map (lambda (vowel) (append\
    \ vowel first))\n                               vowels))\n                   \
    \      first)\n                     second)]\n             [(substring message\
    \ 1 1)\n              (let\n               ([vowels '(A E I O U)])\n         \
    \       (append (map car\n                           (map (lambda (vowel) (append\
    \ vowel first))\n                               vowels))\n                   \
    \      first)\n                     second)]\n             [(substring message\
    \ 1 1)\n              (let\n               ([vowels '(A E I O U)])\n         \
    \       (append (map car\n                           (map (lambda (vowel) (append\
    \ vowel first))\n                               vowels))\n                   \
    \      first)\n                     second)]\n             [(substring message\
    \ 1 1)\n              (let\n               ([vowels '(a e i o u)])\n         \
    \       (append (map car\n                           (map (lambda (vowel) (append\
    \ vowel first))\n                               vowels))\n                   \
    \      first)\n                     second)]\n             [(substring message\
    \ 1 1)\n              (let\n               ([vowels '(a e i o u)])\n         \
    \       (append (map car\n                           (map (lambda (vowel) (append\
    \ vowel first))\n                               vowels))\n                   \
    \      first)\n                     second)]\n             [(substring message\
    \ 1 1)\n              (let\n               ([vowels '(a e i o u)])\n         \
    \       (append (map car\n                           (map (lambda (vowel) (append\
    \ vowel first))\n                               vowels))\n                   \
    \      first)\n                     second)]\n             [(substring message\
    \ 1 1)\n              (let\n               ([vowels '(", "  (loop for i below\
    \ (string-length message)\n        with x \n        for char from (string-chars\
    \ message)\n        do (if (equal? char (substring message i (+ i 1)))\n     \
    \         (set! x (char-uppercase char))\n              (set! x (char-lowercase\
    \ char))\n              (set! x (char-replace (substring message i (+ i 1)) x))\n\
    \              (set! x (char-replace (char-uppercase char) (char-uppercase x))\n\
    \                      (char-replace (char-lowercase char) (char-lowercase x))\n\
    \                      (char-replace (char-replace (char-uppercase char) (char-uppercase\
    \ x)) (substring message i (+ i 1)))\n                      (char-replace (char-replace\
    \ (char-lowercase char) (char-lowercase x)) (substring message i (+ i 1)))\n \
    \                     x))\n        finally (return x)))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
