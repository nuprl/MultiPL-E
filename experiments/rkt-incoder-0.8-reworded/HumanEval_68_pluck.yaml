name: HumanEval_68_pluck
language: rkt
prompt: "#lang racket\n\n;; \"Given a list representing a branch of a tree that has\
  \ non-negative integer nodes\n;; your task is to pluck one of the nodes and return\
  \ it.\n;; The plucked node should be the node with the smallest even value.\n;;\
  \ If multiple nodes with the same smallest even value are found return the node\
  \ that has smallest index.\n;; The plucked node should be returned in a list, [\
  \ smalest_value, its index ],\n;; If there are no even values or the given list\
  \ is empty, return [].\n;; Example 1:\n;; >>> (pluck (list 4 2 3))\n;; (list 2 1)\n\
  ;; Explanation: 2 has the smallest even value, and 2 has the smallest index.\n;;\
  \ Example 2:\n;; >>> (pluck (list 1 2 3))\n;; (list 2 1)\n;; Explanation: 2 has\
  \ the smallest even value, and 2 has the smallest index.\n;; Example 3:\n;; >>>\
  \ (pluck (list ))\n;; (list )\n;; Example 4:\n;; >>> (pluck (list 5 0 3 0 4 2))\n\
  ;; (list 0 1)\n;; Explanation: 0 is the smallest value, but  there are two zeros,\n\
  ;; so we will choose the first zero, which has the smallest index.\n;; Constraints:\n\
  ;; * 1 <= nodes.length <= 10000\n;; * 0 <= node.value\n(define (pluck arr)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate pluck))\n\
  \    (check-equal? (candidate (list 4 2 3)) (list 2 1))\n    (check-equal? (candidate\
  \ (list 1 2 3)) (list 2 1))\n    (check-equal? (candidate (list )) (list ))\n  \
  \  (check-equal? (candidate (list 5 0 3 0 4 2)) (list 0 1))\n    (check-equal? (candidate\
  \ (list 1 2 3 0 5 3)) (list 0 3))\n    (check-equal? (candidate (list 5 4 8 4 8))\
  \ (list 4 1))\n    (check-equal? (candidate (list 7 6 7 1)) (list 6 1))\n    (check-equal?\
  \ (candidate (list 7 9 7 1)) (list ))\n))\n\n(test-humaneval)"
completions: ["  (if (empty? arr)\n      (list)\n      (let ([min (list-min (sort\
    \ arr (lambda (a b) (equal? (mod (+ a (/ a 2) 2) 0) (mod (+ b (/ b 2) 2) 0)))))\
    \ index]\n            (min-index (list-index (sort arr (lambda (a b) (equal? (mod\
    \ (+ a (/ a 2) 2) 0) (mod (+ b (/ b 2) 2) 0))))))\n            (result (if (equal?\
    \ (+ (/ min 2) 2) (/ min 3) 3)\n                        (cons (list-node arr min)\
    \ (list min-index index))\n                        (pluck min-index))))))\n",
  "  (cond\n    [(empty? arr) '()]\n    [(pluck next (first arr))\n     (cond\n  \
    \     [(empty? (rest arr)) (list '() (first arr) (first arr))]\n       [(odd?\
    \ next)\n        (cond\n         [(equal? (first arr) next)\n          (cond\n\
    \            [(empty? (rest arr)) (list '() (first arr) (first arr))]\n      \
    \      [(even? (first arr))\n             (cond\n              [(empty? (rest\
    \ arr)) (list '() (first arr) (first arr))]\n              [(even? (first arr))\n\
    \               (cond\n                 [(empty? (rest arr)) (list '() (first\
    \ arr) (first arr))]\n                 [(even? (first arr)) (list (first arr)\
    \ next (first arr))]\n                 [(odd? (first arr)) (list (first arr) (first\
    \ arr) (first arr))]\n                 [(empty? (rest arr)) (list '() (first arr)\
    \ (first arr))]\n                 [else (list '() (first arr) (first arr))]\n\
    \                 )]\n              [(odd? (first arr))\n               (cond\n\
    \                 [(empty? (rest arr)) (list '() (first arr) (first arr))]\n \
    \                [(even? (first arr)) (list (first arr) next (first arr))]\n \
    \                [(odd? (first arr)) (list (first arr) (first arr) (first arr))]\n\
    \                 [(empty? (rest arr)) (list '() (first arr) (first arr))]\n \
    \                [else (list '() (first arr) (first arr))]\n                 )]\n\
    \              [else (list '() (first arr) (first arr))]\n             )]\n  \
    \        [else (list '() (first arr) (first arr))]\n         )]\n       [(even?\
    \ next)\n        (cond\n         [(empty? (rest arr)) (list '() (first arr) (first\
    \ arr))]\n         [(even? (first arr))\n          (cond\n            [(empty?\
    \ (rest arr)) (list '() (first arr) (first arr))]\n            [(even? (first\
    \ arr))\n             (cond\n              [(empty? (rest arr)) (list '() (first\
    \ arr) (first arr))]\n              [(even? (first arr))\n               (cond\n\
    \                 [(empty? (rest arr)) (list '() (first arr) (first arr))]\n \
    \                [(even? (first arr)) (list (first arr) next (first arr))]\n \
    \                [(odd? (first arr)) (list (first arr) (first arr) (first arr))]\n\
    \                 [(empty? (rest arr", "  (define min-value (car (car arr)))\n\
    \  (define min-index (caddr arr))\n  (define max-value (cadr arr))\n  (define\
    \ max-index (cddr arr))\n  (define max-index-value (min-index max-index))\n  (cond\n\
    \    [(< min-value max-value)\n     (cons min-value [ min-index max-index-value\
    \ ])]\n    [(and (> min-value 0) (> max-value 0)) \n     (cond\n       [(< max-index\
    \ 0)\n        (cons max-value [ max-index max-index-value ])]\n       [else \n\
    \        (cons (car arr) \n              (pluck (cdr arr))))]\n    [(> max-index\
    \ 0) \n     (cond\n       [(< max-index 0)\n        (cons max-value [ max-index\
    \ max-index-value ])]\n       [else \n        (cond\n          [(and (> min-value\
    \ 0) (> max-value 0)) \n           (cond\n             [(< min-index 0)\n    \
    \          (cons min-value [ min-index max-index-value ])]\n             [else\
    \ \n              (cons max-value [ max-index max-index-value ]))]\n         \
    \ [else \n           (cons (car arr) \n                  (pluck (cdr arr))))])]\n\
    \    [else (cons max-value [max-index max-index-value])]))\n", "  (let ([min (min-even\
    \ (sort arr))])\n    (cond\n      [(empty? min) empty]\n      [(even? (car min))\
    \ (list car min)]\n      [(odd? (car min)) (pluck min)]\n      [(null? (cdr min))\
    \ (pluck min)])))\n", "  (if (empty? arr) '()\n      (let ([head (car arr)])\n\
    \        (if (even? head)\n            (cons (car arr) (cadr arr))\n         \
    \   (pluck arr)\n            )))))\n", "  (cond\n    [(empty? arr) (list empty)]\n\
    \    [(null? arr) (list empty)]\n    [(= (first arr) (even? (first arr))) (list\
    \ first (position (first arr)))]\n    [else (pluck [(next arr)\n             \
    \      (+ 1 (position arr (first arr)))\n                   arr]]))\n", "  (check-expect\
    \ (length arr) 0)\n  (define (helper node result)\n    (cond\n      [(null? node)\
    \ result]\n      [(odd? node.value) (helper (next node) result)]\n      [else\
    \ (helper (next node) (list node.value (length result)))]))\n  (helper (first\
    \ arr) '()))\n", "  (let loop ((i 0) (result '()))\n    (cond\n      [(empty?\
    \ arr) result]\n      [else (loop (add1 i) (cons (car arr) (loop (add1 i) empty)))]\n\
    \    ))\n  )\n", "  (let\n      [(pluck-helper (lambda (arr n sum)\n         \
    \             (cond\n                        [(empty? arr) (list sum (min 0 n))]\n\
    \                        [else (pluck-helper (rest arr (+ n 1) (+ sum node.value))\n\
    \                                        (+ n 1)\n                           \
    \             (+ sum node.value))]))]\n    (pluck-helper arr (length arr) 0)))\n",
  "  (define (index lst)\n    (define (helper lst)\n      (cond [(empty? lst) (error\
    \ 'index)\n             (let ((val (car lst)))\n               (cond [(even? val)\
    \ (helper (cdr lst))\n                       (else (error 'index))])])\n    (helper\
    \ lst))\n  (define (even? v)\n    (< (expt v 2) 2))\n  (define (pick)\n    (cond\n\
    \      [(empty? arr) (error 'pick)\n       (cond [(even? (first arr)) (first arr)\n\
    \               (else (pick (rest arr)))]]))\n  (cond\n    [(empty? arr) (error\
    \ 'pick)\n     (cond [(even? (first arr)) (first arr)\n            (else (pick\
    \ (rest arr)))]])\n  [else (pick (rest arr))]))\n", "  (cond\n    [(empty? arr)\
    \ '()]\n    [(null? (cdr arr)) (list (car arr) 0)]\n    [(even? (car arr)) (cons\
    \ (car arr) (+ (car arr) 1))]\n    [else (pluck \n             (append (list (car\
    \ arr))\n                     (pluck \n                       (append (cdr arr)\
    \ (list (car arr)))))]))\n", "  (cond\n    [(empty? arr) empty]\n    [(> (first\
    \ arr) 0) (pluck \n                       (rest arr))\n     (if (> (even? (first\
    \ arr)) 0)\n         (cons \n           (first arr)\n           (pluck (rest arr)))]\n\
    \    [else (pluck \n               (rest arr))]))\n", "  (if (null? arr)\n   \
    \   []\n      (let ([smallest (car arr)])\n        (let ([smallest-index (sub1\
    \ (length (filter (lambda (x) (even? x)) arr)))]\n              (cond [(empty?\
    \ (filter (lambda (x) (even? x)) arr))\n                     (list smallest smallest-index)]\n\
    \                  [else (cond [(even? (car arr)) (cons (car arr) (append (pluck\
    \ [(sub1 (length (filter (lambda (x) (even? x)) arr))])) (cons (car arr) (cons\
    \ smallest-index smallest) (pluck (rest arr))))]\n                        [(not\
    \ (even? (car arr)) (cons (car arr) (cons smallest-index smallest) (pluck (rest\
    \ arr)))]\n                        [else (pluck (rest arr))])))))))\n", "  (let\
    \ loop ((arr (in-list arr))\n             (min-value (first arr))\n          \
    \   (min-idx 0))\n    (if (null? arr)\n        (list min-value min-idx)\n    \
    \    (let ((el (rest arr)))\n          (if (zero? (modulo el 2))\n           \
    \   (loop (rest arr)\n                    (cons min-value (first arr))\n     \
    \               (+ 1 (first arr)))\n              (loop (rest arr)\n         \
    \           min-value\n                    (cons min-idx (first arr))))))))\n",
  "  (cond\n    [(empty? arr) empty]\n    [(empty? (rest arr)) empty]\n    [(equal?\
    \ (first arr) 1) (cons (first arr) empty)]\n    [else (pluck rest (cond\n    \
    \                   [(odd? (first arr)) (cons (first arr) (pluck first (cond\n\
    \                                [(even? (first arr)) (cond\n                \
    \                                    [(equal? (first arr) (second arr))\n    \
    \                                                 (cons (first arr) (pluck first\
    \ (pluck first (cond\n                                                       \
    \                 [(odd? (first arr)) (pluck first (cond\n                   \
    \                                                                            [(even?\
    \ (first arr)) (cond\n                                                       \
    \                                                             [(equal? (first\
    \ arr) (second arr))\n                                                       \
    \                                                             (cons (first arr)\
    \ (pluck first (pluck first (cond\n                                          \
    \                                                                            \
    \  [(odd? (first arr)) (pluck first (cond\n                                  \
    \                                                                            \
    \                  [(even? (first arr)) (cond\n                              \
    \                                                                            \
    \                          [(equal? (first arr) (second arr))\n              \
    \                                                                            \
    \                                          (cons (first arr) (pluck first (pluck\
    \ first (cond\n                                                              \
    \                                                                          [(even?\
    \ (first arr)) (cond\n                                                       \
    \                                                                            \
    \         [(equal? (first arr) (second arr))\n                               \
    \                                                                            \
    \                                 (cons (first arr) (pluck first (pluck first\
    \ (cond\n                                                                    \
    \                                                                            \
    \                                [(odd? (first arr)) (pluck first (cond\n    \
    \                                                                            \
    \                                                                            \
    \                        [(even? (first arr)) (cond\n                        \
    \                                                                            \
    \                                                                            \
    \        [(equal? (first arr) (second arr))\n                                \
    \                                                                            \
    \                                                                            (cons\
    \ (first arr) (pluck first (pluck first (cond\n                              \
    \                                                                            \
    \                                                                            \
    \      [(odd? (first arr)) (pluck first (cond\n                              \
    \                                                                            \
    \                                                                            \
    \                                              [(even? (first arr)) (cond\n  \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \  [(equal? (first arr) (second arr))\n                                      \
    \                                                                            \
    \                                                                            \
    \                                          (cons (first arr) (pluck first (pluck\
    \ first (cond\n                                                              \
    \                                                                            \
    \                                                                            \
    \                      [(odd? (first arr)) (pluck first (cond\n              \
    \                                                                            \
    \                                                                            \
    \                                                                          [(even?\
    \ (first arr)) (cond\n                                                       \
    \                                                                            \
    \                                                                            \
    \                                     [(equal? (first arr) (second arr))\n   \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \             (cons (first arr) (pluck first (pluck first (cond\n            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \        [(even? (first arr)) (cond\n                                        \
    \                                                                            \
    \                                                                            \
    \                                                            [(equal? (first arr)\
    \ (second arr))\n                                                            \
    \                                                                            \
    \                                                                            \
    \                                        (cons (first arr) (pluck first (pluck\
    \ first (cond\n                                                              \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \      [(odd? (first arr)) (pluck first (", "  (cond\n    [(empty? arr) (empty?)]\
    \ \n    [(not (integer? (car arr)))\n     (pluck arr)]\n    [else (cons (car arr)\n\
    \              (pluck \n               (cdr arr)))]))\n", "  (cond\n    [(empty?\
    \ arr) empty]\n    [(number? arr) (list (car arr) 1)]\n    [else (let ([smallest\
    \ (car arr)]\n                   [smallest idx]\n                   [smallest\
    \ ev]\n                   [smallest-index 1])\n            (cond [(>= smallest\
    \ ev)\n                    (let ([node (car arr)]\n                          [node\
    \ idx])\n                      (cond\n                        [(number? node)\
    \ (list (smallest-index idx) (smallest-index idx))]\n                        [else\
    \ (let ([ev (car arr)]\n                                    [ev idx])\n      \
    \                        (cond\n                                [(= ev (car arr))\
    \ (list (smallest-index idx) (smallest-index idx))]\n                        \
    \        [else (pluck node (list idx ev) (+ idx 1))]))]))]))]))\n", "  (define\
    \ (helper-arr arr ans index max-index)\n    (cond\n      [(empty? arr)\n     \
    \  (append (list ans)\n              (if (= index max-index)\n               \
    \   (list index)\n                  (helper-arr (rest arr)\n                 \
    \           (cons (car arr) ans)\n                            (+ index 1)\n  \
    \                          max-index))]\n      [(even? (car arr))\n       (helper-arr\
    \ (cdr arr)\n                  (cons (car arr) ans)\n                  (+ index\
    \ 1)\n                  max-index)]\n      [else\n       (helper-arr (rest arr)\n\
    \                  ans\n                  (+ index 1)\n                  max-index)]))\n\
    \  (helper-arr arr '() 0 10000))\n", "  (cond\n    ((empty? arr) '())\n    ((=\
    \ (length arr) 0) '())\n    ((= (length arr) 1) (list (car arr)))\n    (else (cond\n\
    \            ((= (car arr) (modulo (car arr) 2))\n             (cond\n       \
    \       ((empty? (cdr arr)) '())\n              ((even? (car arr)) (list '() (car\
    \ arr)))\n              ((= (car arr) (modulo (car arr) 2)) (list (car arr) (cons\
    \ 0 (cdddr arr)))))\n            (else (cond\n                    ((even? (car\
    \ arr))\n                     (cond\n                      ((= (car arr) (modulo\
    \ (car arr) 2)) (list (car arr) (cons 0 (cdddr arr)))))\n                    ((=\
    \ (car arr) (modulo (car arr) 2)) (list (car arr) (cons (car arr) (cons 1 (cdddr\
    \ arr)))))))\n          ))))))\n", "  (if (empty? arr)\n      '()\n      (let\
    \ ((smallest (min-key arr even? #min)))\n        (cond\n          (even? (first\
    \ smallest)) (list smallest (index (first smallest)))\n          (else (pluck\
    \ (rest arr)))))))\n", "  (let ([i 0])\n    (if (null? arr)\n        (list [])\n\
    \        (let ([v (car arr)])\n          (cond [(even? v) (pluck arr v)\n    \
    \            (< v v) (< i 0)\n                (else (loop (cdr arr) (v (+ v 2))\n\
    \                             (cons v i))))]))))\n</code>\n<|/ a |>\n<| c |>\n\
    Am I allowed to say that when an answer has multiple upvotes it's because it is\
    \ more efficient than the others?\n<|/ c |>\n<| c |>\nI'm voting up because this\
    \ is so elegant. I am curious though, how can we be so smart when we are so unpopular?\n\
    <|/ c |>\n<| c |>\nI love `for` loops. I am not trying to say you're wrong, but\
    \ I think I should be able to pick up at least some basic concepts easily without\
    \ having to use `for` loops so often.\n<|/ c |>\n<| c |>\nI think the reason this\
    \ was downvoted was because it was too long; I edited it to be more readable.\n\
    <|/ c |>\n<| c |>\nI wasn't sure if my code was readable to you or me, so I left\
    \ it alone. Thanks for editing.\n<|/ c |>\n<| a dscore=1 |>\n<code>", "  (cond\n\
    \    [(empty? arr) empty]\n    [(even? (car arr)) (cons (car arr) (pluck (cdr\
    \ arr)))]\n    [else (pluck arr)])\n  )\n", "  (if (or (empty? arr) (null? (car\
    \ arr))) (list '() 0)\n      (let ([arr (cdr arr)])\n        (let loop ([min (car\
    \ arr)]\n                   [arr '()])\n          (if (null? arr)\n          \
    \    (loop '() 0)\n              (let ([node (car arr)])\n                (cond\n\
    \                  [(= (even? node) (min)) (loop '(node) 0)]\n               \
    \   [else (loop (if (< (even? node) (min)) node (min)) (add1 node))])\n      \
    \        )))\n        (loop '() 0)\n        (let ([value (car arr)])\n       \
    \   (cond\n            [(= value 0) (list value 0)]\n            [else (cons (car\
    \ arr) (cdr arr))])\n          )\n      )))\n", "  (cond [(empty? arr) (list '()\
    \ '())]\n        [(odd? (car arr)) (list (car arr) (add1 (car arr)))]\n      \
    \  [else (list (car arr) (add1 (car arr)))]))\n", "  (cond\n    ((empty? arr)\
    \ nil)\n    ((not (odd? (caar arr)))\n     (cons (caar arr) (incar arr)))\n  \
    \  (else\n     (cond\n       ((empty? (cdar arr))\n         (cons (car arr) (incar\
    \ arr)))\n       ((not (odd? (car arr)))\n        (cond\n          ((empty? (cdar\
    \ arr)) nil)\n          ((not (even? (car arr)))\n           (cons (car arr) (incar\
    \ arr)))\n          (else (cond\n                ((odd? (car arr))\n         \
    \        (cond\n                   ((empty? (cdar arr))\n                    (list\
    \ car incar))\n                   ((not (even? (car arr)))\n                 \
    \   (cons (car arr) (incar arr)))\n                   (else (cons (car arr) (pluck\
    \ arr)))))))))\n       (else (cons (car arr) (pluck arr)))))))\n", "  (cond ((empty?\
    \ arr) '())\n        (else (let ([min (min (sort (filter odd? arr))) (node-value\
    \ (first arr))])\n                (if (= min (first arr))\n                  \
    \  (pluck @((rest arr)))\n                    (let ([min2 (min (sort (filter even?\
    \ arr))) (ind (first arr)])\n                          ([min3 (min (sort (filter\
    \ odd? arr))) (ind (first arr)])])\n                      (list (append (list\
    \ min) (rest arr))\n                             (append ind (inc (length arr)))\n\
    \                             (append min2 min3))))))))\n", "  (cond\n    [(empty?\
    \ arr) '()]\n    [(number? (car arr)) (cons (car arr) (pluck \n              \
    \                    (cdr arr)))]\n    [(even? (car arr)) (cons (car arr) (pluck\
    \ \n                                   (cdr arr)))]\n    [else (pluck \n     \
    \          (cdr arr))]))\n", "  (let* ((evens (sort (map (lambda (x) (even? (car\
    \ x)) arr)) even?))\n         (first (first evens))\n         (smallest (car first)))\n\
    \    (cond ((null? evens) (list smallest))\n          ((and (not (pair? smallest))\
    \ (not smallest))\n           (cons smallest '()))\n          (else (let ((smallest2\
    \ (map (lambda (x) (if (pair? x) (smallest (car x)) x) arr)))\n              \
    \    (cons smallest2 smallest)))))\n  ))", "  (cond\n    [(empty? arr) empty]\n\
    \    [(null? (first arr)) (first arr)]\n    [(even? (first arr)) (cons (first\
    \ arr) (pluck rest))]\n    [else (pluck rest)]))\n", "  (let loop ((min (min-value\
    \ arr))\n             (i 0))\n    (cond\n      [(empty? arr) empty]\n      [(=\
    \ min (even? i)) (list min i)]\n      [else (loop (min (even? i)) (inc i))])))\n\
    \  ", "  (if (null? arr)\n      '()\n      (let ([head (min (filter (lambda (e)\
    \ (even? (- e (first arr)))) arr)])\n            (tail (filter (lambda (e) (even?\
    \ (- e (first arr)))) (rest arr))))\n        (append (list head (reverse (sort\
    \ (map inc (sort (map car tail)))))) \n                (pluck tail))))\n", " \
    \ (cond\n    [(empty? arr) empty]\n    [else (cons (car arr) (cadddr arr))]\n\
    \  ))\n", "  (let loop ((arr arr)\n             (min (minimum arr))\n        \
    \     (idx (car arr))\n             (smalest_value (if (list? arr)\n         \
    \                        (min (pluck (first arr)))\n                         \
    \        min)))\n    (cond ((null? arr)\n           (list (if (null? arr)\n  \
    \                   nil\n                     (error \"Empty List\"))))\n    \
    \      ((even? smalest_value)\n           (list (list smalest_value idx))\n  \
    \        ((= idx smalest_value)\n           (loop (rest arr)\n               \
    \  min\n                 (+ 1 (car arr))\n                 (min (pluck (rest arr))))\n\
    \          ((< (car arr) min)\n           (loop (rest arr)\n                 min\n\
    \                 (+ 1 (car arr))\n                 (min (pluck (rest arr)))))))))\n",
  "  (let ([result (empty-list)])\n    (cond\n      [(empty? arr) result]\n      [(even?\
    \ (first arr)) (set-indexed (first arr) (pluck rest (- index (first arr)))) (set-indexed\
    \ (first arr) index) (cons (first arr) result)]\n      [else (pluck rest (+ index\
    \ (first arr)))]\n      )))\n", "  (cond\n    [(empty? arr) '()]\n    [(equal?\
    \ (car arr) '()) (list '() '())]\n    [else (cons ((min (filter even? arr)) (length\
    \ (filter even? arr))) \n              (pluck \n               (map (curry curry-apply\
    \ #(sub1 %) (car %)) \n                       (filter (curry even? arr) arr)))]))\n",
  "  (let loop ((arr (car arr))\n             (arr (cdr arr)))\n    (if (null? arr)\n\
    \        ;; base case\n        (cons (car arr) (list 0 0))\n        (let ((curr-val\
    \ (car arr))\n              (curr-idx (car arr)))\n          (cond ((= curr-idx\
    \ 0)\n                 (cons (car arr) (list curr-val curr-idx))\n           \
    \      (else\n                   (loop\n                     ;; recursive case\n\
    \                     (cons (car arr) (append (list (car arr) curr-val) (list\
    \ (cdr arr))))\n                     (cdr arr))))))))\n</code>\n<|/ a |>\n<| a\
    \ dscore=0 |>\nThis code will solve the problem using tail recursion:\n<code>",
  "  (cond\n    [(empty? arr) (empty)]\n    [(even? (car arr)) (list-ref arr (car\
    \ arr) 1)]\n    [else (pluck rest)]))\n", "  (define (helper node)\n    (cond\n\
    \      [(empty? node)\n       (cond\n         [(empty? (rest node))\n        \
    \  (cons (car node) '())]\n         [else (cons (car node) (helper (rest node)))])]\n\
    \      [else\n       (cond\n         [(= (expt (car node) 2) (car arr))\n    \
    \      (helper (rest node))\n         [(= (expt (car node) 2) (cadr arr))\n  \
    \        (cons (car node) (helper (rest node)))]\n         [else (cons (car node)\
    \ (helper (rest node)))])]))\n  (helper (reverse (sort arr))))\n", "  (let loop\
    \ ((smallest-value '()) (i 0))\n    (cond\n      [(null? (car arr)) smallest-value]\n\
    \      [(= i (length arr)) smallest-value]\n      [else\n       (let ((smallest-node-value\
    \ (car arr))\n             (smallest-node-index (- i 1)))\n         (cond\n  \
    \         [(< smallest-node-value (car smallest-value)) (set! smallest-value smallest-node-value)]\n\
    \           [(< smallest-node-index (- smallest-node-value (car smallest-value)))\n\
    \            (set! smallest-value smallest-node-value smallest-node-index)]\n\
    \           [else (set! i (+ i 1))]\n           (loop (car smallest-value) (add1\
    \ smallest-node-index))))]\n      )))\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThank\
    \ you for taking your time and answering this question. I was looking for the\
    \ most idiomatic and performant solution so I can compare it to other solutions\
    \ posted. I didn't want to just throw a bunch of code at you, as it's clear that\
    \ nobody is really interested in solving this problem in a performant manner either.\
    \ Anyway, thank you again.\n<|/ c |>\n<| c |>\nThank you for taking the time to\
    \ edit your answer, I really appreciate it. What I really meant to say is that\
    \ I wanted to see whether other solutions had been posted, so I can compare their\
    \ performance. I think I figured out how to do it in O(log n) time, but it's still\
    \ a little slower than other solutions. So I will add my own answer and accept\
    \ yours.\n<|/ c |>\n<| a tags=racket,scheme |>\nHere's a solution that runs in\
    \ O(n log n) time.\n<code>\n#lang racket\n", "  (cond\n    [(empty? arr) empty]\n\
    \    [(even? (car arr)) (car arr)]\n    [else (pluck (cdr arr))]))\n", "  (define\
    \ (pluck k smalest index arr)\n    (cond\n      [(empty? arr) (list smalest index)]\n\
    \      [(zero? (car arr)) (pluck k (car arr) (+ index 1) arr)]\n      [(even?\
    \ (car arr)) (pluck k (car arr) 0 arr)]\n      [(smalest_value (smalest k) smalest\
    \ index arr)]\n      [else (pluck k (pluck k (smalest_value smalest index arr))\
    \ (+ index 1) arr)]))\n  (define (smalest_value smalest index arr)\n    (cond\n\
    \      [(empty? arr) smalest]\n      [(smalest_value (smalest k) smalest index\
    \ arr) (pluck k (smalest k) (+ index 1) arr)]\n      [else (smalest_value (smalest\
    \ k) smalest index arr)]))\n  (define (smalest k smalest index arr)\n    (cond\n\
    \      [(empty? arr) k (+ index 1)]\n      [(smalest_value (smalest k) smalest\
    \ index arr) (smalest k (smalest k) (+ index 1) arr)]\n      [else (smalest_value\
    \ (smalest k) smalest index arr)]))\n  (smalest 0 #f 0 arr))\n", "  (cond\n  \
    \  ((empty? arr) '())\n    ((not (even? (car arr)))\n     (pluck \n      (cons\
    \ (car arr) (cons (car arr) '())))\n    (else (pluck \n            (cons (car\
    \ arr) (pluck \n                                     (cdr arr)))))\n    )\n  )\n\
    )\n", "  (let* ((min-index (min (map even? (map car (filter (curry even? (rest\
    \ arr)))))\n                         (length (map car (filter (curry even? (rest\
    \ arr)))))\n                         (min-even (car min-index)))\n         (smalest_value\
    \ (if (null? min-index) (car min-index) min-even)))\n    (cond\n      [(null?\
    \ arr) (list smalest_value)]\n      [(= smalest_value min-even) (list smalest_value\
    \ min-index)]\n      [else (pluck rest)]))\n  )\n", "  (let loop ((index 0) (arr\
    \ arr))\n    (cond ((empty? arr) nil)\n          ((even? (car arr))\n        \
    \   (loop (+ index (car arr)) (cdr arr)))\n          ((< index (length arr)) (loop\
    \ (+ index 1) (cdr arr))))\n    (list (car arr) index)))\n", "  (if (or (empty?\
    \ arr)\n          (null? arr))\n      empty\n      (let ([smallest (first arr)]\n\
    \            [smallest-index (first (rest arr))]\n            [smallest-even null])\n\
    \        (if (null? arr)\n            (list smallest-even smallest-index)\n  \
    \          (if (< ((first arr) smallest) (first arr))\n                (set! smallest\
    \ (first arr))\n                (set! smallest-index (first (rest arr)))\n   \
    \             (set! smallest-even smallest)\n                (let ([new-smallest\
    \ (first arr)])\n                  (set! arr (rest arr))\n                  (pluck\
    \ arr)\n                  (list (smallest-even new-smallest) smallest-index)))))))\n",
  "  (cond\n    [(empty? arr) empty]\n    [(= (length arr) 1) (first arr)]\n    [else\
    \ (cond\n          [(even? (first arr)) (cond\n                              \
    \     [(= (first arr) (second arr)) (list (first arr) 1)]\n                  \
    \                 [(< (first arr) (second arr)) (list (first arr) (first arr))])]\n\
    \          [else (cond\n                 [(= (length arr) 2) (cond\n         \
    \                               [(even? (first arr)) (cond\n                 \
    \                                              [(= (first arr) (third arr)) (list\
    \ (second arr) (first arr))]\n                                               \
    \                [(< (first arr) (third arr)) (list (second arr) (first arr))])]\n\
    \                                        [else (cond\n                       \
    \                        [(even? (first arr)) (cond\n                        \
    \                                 [(= (first arr) (second arr)) (list (third arr)\
    \ (first arr))] \n                                                         [(<\
    \ (first arr) (second arr)) (list (third arr) (first arr))])]\n              \
    \                                 [else (cond\n                              \
    \                         [(even? (first arr)) (cond\n                       \
    \                                        [(= (first arr) (third arr)) (list (third\
    \ arr) (first arr))] \n                                                      \
    \         [(< (first arr) (third arr)) (list (third arr) (first arr))])]\n   \
    \                                            [else (cond\n                   \
    \                                    [(even? (first arr)) (cond\n            \
    \                                                   [(= (first arr) (second arr))\
    \ (list (first arr) (first arr))] \n                                         \
    \                      [(< (first arr) (second arr)) (list (first arr) (first\
    \ arr))])]\n                                               [else (cond\n     \
    \                                                  [(even? (first arr)) (cond\n\
    \                                                               [(= (first arr)\
    \ (first arr)) (list (second arr) (first arr))] \n                           \
    \                                    [(< (first arr) (first arr)) (list (second\
    \ arr) (first arr))])]\n                                               [else (cond\n\
    \                                                       [(even? (first arr)) (cond\n\
    \                                                               [(= (first arr)\
    \ (third arr)) (list (third arr) (first arr))] \n                            \
    \                                   [(< (first arr) (third arr)) (list (third\
    \ arr) (first arr))])]\n                                               [else (cond\n\
    \                                                       [(even? (first arr)) (cond\n\
    \                                                               [(= (first arr)\
    \ (second arr)) (list (second arr) (first arr))] \n                          \
    \                                     [(< (first arr) (second arr)) (list (second\
    \ arr) (first arr))])]\n                                               [else (cond\n\
    \                                                       [(even? (first arr)) (cond\n\
    \                                                               [(= (first arr)\
    \ (first arr)) (list (first arr) (first arr", "  (cond\n    [(empty? arr) '()]\n\
    \    [(even? (car arr)) (car arr)]\n    [else (let* ([smallest (min (car arr)\
    \ (even? (car arr)))]\n                [j ((indexof (min arr (even? (car arr))))\
    \ (car arr))]\n                [result (cons (car arr) (list smallest j))]\n \
    \               (pluck (rest arr)))]))])\n</code>\n<|/ a tags=racket,scheme,lisp,functional-programming\
    \ |>\n<| c |>\nI appreciate your answer and it works perfectly. As I mentioned\
    \ in my question I do have to use the `indexof` function and it's giving me a\
    \ hard time. I have to find the index of the smallest even value without using\
    \ `(min (car arr) (even? (car arr)))`\n<|/ c |>\n<| c |>\n: Then you'll have to\
    \ write a recursive function that calls itself twice but instead of comparing\
    \ the first element with the smallest element, you'll have to compare the second\
    \ element with the smallest element and so on. Also, recursion is often the easiest\
    \ way to implement a recursive function.\n<|/ c |>\n<| a |>\nHere's one solution:\n\
    <code>", "  (let ([smallest (car arr)]\n        [smallest-index (car arr)])\n\
    \    (if (null? arr)\n        (list*)\n        (let ([node (car arr)])\n     \
    \     (if (even? (car arr))\n              (cons (car arr) (cadr arr))\n     \
    \         (if (> smallest (car arr))\n                  (let ([new-smallest (car\
    \ arr)])\n                    (set! smallest (car arr))\n                    (set!\
    \ smallest-index (cadr arr))\n                    (cons new-smallest smallest)\n\
    \                    (pluck arr))\n                  (set! smallest (car arr))\n\
    \                  (set! smallest-index (cadr arr))\n                  (cons node\
    \ smallest)\n                  (pluck arr)))))\n        (let ([new-smallest (car\
    \ arr)])\n          (set! smallest (car arr))\n          (set! smallest-index\
    \ (cadr arr))\n          (cons new-smallest smallest)\n          (pluck arr)))))\n",
  "  (define (pluck-helper-function node idx)\n    (cond\n      [(null? (rest node))\
    \ (cond\n                             [(equal? (rest node) '()) '()]\n       \
    \                      [(equal? ((first node) 'value) '()) '()]\n            \
    \                 [(even? ((first node) 'value)) (cond\n                     \
    \                                       [(equal? ((first node) 'value) '()) '()]\n\
    \                                                            [(smaller-than-or-equal?\
    \ ((first node) 'value) '()) idx]]\n                             [else (cons (first\
    \ node) '())])]\n      [(even? ((first node) 'value)) (cond\n                \
    \                        [(equal? ((first node) 'value) '()) '()]\n          \
    \                              [(smaller-than-or-equal? ((first node) 'value)\
    \ '()) idx]]\n                      [else (pluck-helper-function\n           \
    \                      (rest node)\n                                 (+ idx ((first\
    \ node) 'value)))]))\n      [(smaller-than-or-equal? ((first node) 'value) '())\
    \ (cond\n                                                   [(equal? ((first node)\
    \ 'value) '()) '()]\n                                                   [else\
    \ (pluck-helper-function\n                                                   \
    \          (rest node)\n                                                     \
    \        (+ idx 1))])]))\n\n  (cond\n    [(null? (rest arr)) '()]\n    [(equal?\
    \ ((first arr) 'value) '()) '()]\n    [(even? ((first arr) 'value)) (cond\n  \
    \                                [(equal? ((first arr) 'value) '()) '()]\n   \
    \                               [(smaller-than-or-equal? ((first arr) 'value)\
    \ '()) 0]]\n                  [else (pluck-helper-function\n                 \
    \          (rest arr)\n                           0)]))))\n", "  (check-expect\
    \ (>= (length arr) 2) '())\n  (check-expect (> (first arr) '()) '())\n  (check-expect\
    \ (> (second arr) '()) '())\n  (check-expect (even? (first arr)) '())\n  (check-expect\
    \ (even? (second arr)) '())\n  (let ([smallest (min (map even? (map first arr))\
    \ (map second arr))])\n    (cond\n      [(or (equal? smallest '()) (even? smallest))\
    \ '()]\n      [else (list smallest (second smallest))]))))\n", "  (cond ((null?\
    \ arr) '())\n        ((= (length arr) 0) '())\n        (else (let ([smalest_value\
    \ (min-indexed (filter even? arr)))\n                   (smallest_value (car smalest_value))\n\
    \                   (smallest_index (length smalest_value))]\n               \
    \ (cond ((> (- smallest_index 0) (- smalest_value 0)) (car smalest_value))\n \
    \                     ((null? (cdr smalest_value)) '())\n                    \
    \  ((not (null? (cdr smalest_value))) (pluck smalest_value))\n               \
    \       (else (pluck smalest_value)))))\n        (else (pluck arr))))\n", "  (if\
    \ (null? arr)\n      (list )\n      (let ([smallest (car arr)]\n            [smallest-index\
    \ (car arr)])\n        (pluck \n         (cdr arr)\n         (cond [(= (modulo\
    \ smallest 2 ) 0) smallest\n                (= (modulo smallest 2 ) 1)\n     \
    \           (= (modulo smallest-index 2 ) 0) smallest-index\n                (else\
    \ (pluck \n                        (cdr arr)\n                        (cond [(=\
    \ (modulo smallest 2 ) 0) smallest\n                               (= (modulo\
    \ smallest-index 2 ) 0) smallest-index\n                               (else (cons\
    \ (first arr) \n                                        (cons smallest (cons smallest-index\
    \ (cdr arr))))))))]\n             )\n         ))))\n", "  (let loop ([arr arr]\n\
    \             [index 0]\n             [smallest-even -1]\n             [smalest_value\
    \ -1])\n    (if (null? arr)\n        (if (= smallest-even -1)\n            (if\
    \ (= smalest_value -1)\n                '()\n                (list smalest_value\
    \ index))\n            (list smallest-even index))\n        (let ((n (car arr)))\n\
    \          (if (even? n)\n              (loop (cdr arr)\n                    (+\
    \ index 1)\n                    (if (< n smallest-even)\n                    \
    \    smallest-even\n                        smalest_value))\n              (loop\
    \ (cdr arr)\n                    (+ index 1)\n                    smallest-even)\n\
    \              (loop (cdr arr)\n                    (+ index 1)\n            \
    \        smalest_value)))))\n", "  (let loop ([head null]\n             [result\
    \ null])\n    (if (null? arr)\n        result\n        (let ([node (car arr)])\n\
    \          (if (even? node)\n              (loop (cdr arr)\n                 \
    \   (cons node result))\n              (loop (cdr arr) result))))))\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\nThanks so much for taking the time to write this up.\
    \ I was working on a different solution and had this in mind, but you were so\
    \ fast I must have gone too fast.\n<|/ c |>\n<| a |>\nHere's a solution using\
    \ the \"list\" primitive (for use with Racket):\n<code>", "  (cond\n    [(empty?\
    \ arr) []]\n    [(list? (car arr)) (pluck arr)]\n    [else (cond\n           \
    \   [(even? (car arr)) (cons (car arr) (pluck arr))]\n              [else (cond\n\
    \                     [(even? (cadr arr)) (cons (car arr) (pluck arr))] \n   \
    \                  [else (cond\n                              [(even? (caddr arr))\
    \ (cons (car arr) (pluck arr))] \n                              [else (cond\n\
    \                                       [(even? (cddr arr)) (cons (car arr) (pluck\
    \ arr))] \n                                       [else (cond\n              \
    \                                  [(even? (cend arr)) (cons (car arr) (pluck\
    \ arr))]\n                                                [else (cond\n      \
    \                                                   [(even? (cinit arr)) (cons\
    \ (car arr) (pluck arr))]\n                                                  \
    \       [else (cond\n                                                        \
    \           [(even? (cinitdr arr)) (cons (car arr) (pluck arr))] \n          \
    \                                                         [else (cond\n      \
    \                                                                    [(even? (cinitrdr\
    \ arr)) (cons (car arr) (pluck arr))] \n                                     \
    \                                     [else (cond\n                          \
    \                                                         [(even? (cinitdrdr arr))\
    \ (cons (car arr) (pluck arr))] \n                                           \
    \                                        [else (cond\n                       \
    \                                                                      [(even?\
    \ (cinitdrdr arr)) (cons (car arr) (pluck arr))] \n                          \
    \                                                                   [else (cond\n\
    \                                                                            \
    \                            [(even? (cinitdrdr arr)) (cons (car arr) (pluck arr))]\
    \ \n                                                                         \
    \                               [else (cond\n                                \
    \                                                                            \
    \   [(even? (cinitdrdr arr)) (cons (car arr) (pluck arr))] \n                \
    \                                                                            \
    \                   [else (cond\n                                            \
    \                                                                           [(even?\
    \ (cinitdrdr arr)) (cons (car arr) (pluck arr))] \n                          \
    \                                                                            \
    \                 [else (cond\n                                              \
    \                                                                            \
    \                            [(even? (cinitdrdr arr)) (cons (car arr) (pluck arr))]\
    \ \n                                                                         \
    \                                                                            \
    \ [else (cond\n                                                              \
    \                                                                            \
    \                     [(even? (cinitdrdr arr)) (cons (car arr) (pluck arr))] \n\
    \                                                                            \
    \                                                                            \
    \       [else (cond\n                                                        \
    \                                                                            \
    \                                    [(even? (cinitdrdr arr)) (cons (car arr)\
    \ (pluck arr))] \n                                                           \
    \                                                                            \
    \                                 ", "  (if (null? arr)\n      '()\n      (let\
    \ ([head (first arr)])\n        (if (null? (rest arr))\n            (list head\
    \ -1)\n            (let ([evens (filter (lambda (x) (even? x))\n             \
    \                   (filter (lambda (x) (not (null? x))) arr))]\n            \
    \      [smallest (minimum evens)]\n                  [smallest-index (index smallest\
    \ evens)])\n              (if (null? evens)\n                  (list head -1)\n\
    \                  (if (< smallest (minimum evens))\n                      (list\
    \ (list head smallest-index) (index head smallest-index))\n                  \
    \    (list head -1))))))))\n", "  (cond\n    [(empty? arr) '()]\n    [(empty?\
    \ (cdr arr)) (list (first arr) 0 (car arr))]\n    [else (if (even? (first arr))\n\
    \              (list (first arr) (car arr) (cdr (cdr arr)))\n              (if\
    \ (equal? (car arr) (pluck arr))\n                  (list (car arr) (cdr (cdr\
    \ arr)) (pluck arr))\n                  (list (car arr) (cdr (cdr arr)) (pluck\
    \ arr))))]))\n", "  (if (empty? arr)\n      []\n      (let ([smallest (car arr)]\n\
    \            [smallest-index 0]\n            [new-arr (cdr arr)])\n        (if\
    \ (empty? new-arr)\n            (list smallest smallest-index)\n            (let\
    \ ([c (car new-arr)]\n                  [smallest-c (pluck new-arr)]\n       \
    \           [index (+ 1 smallest-index)])\n              (if (< c smallest)\n\
    \                  (cons c smallest-index)\n                  (let ([new-smallest-c\
    \ (pluck new-arr)]\n                        [new-smallest-index (+ 1 smallest-index)]\n\
    \                        [new-new-arr (cons (car new-smallest-c) new-new-arr)])\n\
    \                    (if (< c new-smallest-c)\n                        (cons c\
    \ smallest-index)\n                        (let ([new-new-smallest-c (pluck new-new-arr)]\n\
    \                              [new-new-smallest-index (+ 1 smallest-index)]\n\
    \                              [new-new-new-arr (cons (car new-new-smallest-c)\
    \ new-new-new-arr)])\n                          (if (< c new-new-smallest-c)\n\
    \                              (cons c smallest-index)\n                     \
    \         (cons (car new-new-smallest-c) new-new-new-index)))))\n            \
    \      (cons c index)))))))\n", "  (cond\n    ((null? arr) nil)\n    ((null? (cdr\
    \ arr)) (car arr))\n    ((even? (car arr))\n     (cond\n       ((even? (car arr))\n\
    \        (cond\n          ((even? (car arr))\n           (cond\n             ((even?\
    \ (car arr))\n               (cond\n                ((even? (car arr))\n     \
    \            (cond\n                  ((even? (car arr))\n                   (cond\n\
    \                    ((even? (car arr))\n                     (cons (car arr)\
    \ '()))\n                    ((odd? (car arr))\n                     (cond\n \
    \                     ((even? (car arr))\n                       (cond\n     \
    \                   ((even? (car arr))\n                         (cond\n     \
    \                     ((even? (car arr))\n                           (cond\n \
    \                           ((even? (car arr))\n                             (cond\n\
    \                              ((even? (car arr))\n                          \
    \     (cond\n                                ((even? (car arr))\n            \
    \                     (cond\n                                  ((even? (car arr))\n\
    \                                   (cond\n                                  \
    \  ((even? (car arr))\n                                     (cond\n          \
    \                            ((odd? (car arr))\n                             \
    \          (cons (car arr) '()))\n                                      ((even?\
    \ (cdr arr))\n                                       (cond\n                 \
    \                       ((even? (cdr arr))\n                                 \
    \        (cond\n                                          ((even? (cdr arr))\n\
    \                                           (cond\n                          \
    \                  ((even? (cdr arr))\n                                      \
    \       (cond\n                                              ((even? (cdr arr))\n\
    \                                               (cond\n                      \
    \                          ((even? (cdr arr))\n                              \
    \                   (cond\n                                                  ((even?\
    \ (cdr arr))\n                                                   (cond\n     \
    \                                               ((even? (cdr arr))\n         \
    \                                            (cond\n                         \
    \                             ((even? (cdr arr))\n                           \
    \                            (cond\n                                         \
    \               ((even? (cdr arr))\n                                         \
    \                (cond\n                                                     \
    \     ((even? (cdr arr))\n                                                   \
    \        (cond\n                                                            ((even?\
    \ (cdr arr))\n                                                             (cond\n\
    \                                                              ((even? (cdr arr))\n\
    \                                                               (cond\n      \
    \                                                          ((even? (cdr arr))\n\
    \                                                                 (cond\n    \
    \                                                              ((even? (cdr arr))\n\
    \                                                                   (cond\n  \
    \                                                                  ((even? (cdr\
    \ arr))\n                                                                    \
    \ (cond\n                                                                    \
    \  ((even? (cdr arr))\n                                                      \
    \                (cond\n                                                     \
    \                   ((even? (cdr arr))\n                                     \
    \                                    (cond\n                                 \
    \                         ((even? (cdr arr))\n                               \
    \                            (cond\n                                         \
    \                   ((even? (cdr arr))\n", "  (if (null? arr)\n      '()\n   \
    \   (let ([smallest (min (map even? (map (lambda (x) (- x arr)) arr)))]\n    \
    \        [smallest smallest]\n            [smallests #(map (lambda (x) (- x arr))\
    \ arr)\n                     smallests (car smallests)]\n            [index smallest]\n\
    \            [indexs #(first smallests index)])\n        (if (null? smallests)\n\
    \            '()\n            (list (second smallests)\n                   (first\
    \ indexs))))))\n</code>\n<|/ a dscore=2 |>\n<| c |>\nthank you for you answer.\
    \ i just need to ask if you can optimize the code because my instructor said that\
    \ using map and lambda is quite slow and i try to optimize my code because he\
    \ want us to do so. but i also want to ask that if the input list is just integers,\
    \ can we optimize it to be more time efficient ?\n<|/ c |>\n<| c |>\nYou can do\
    \ it, but it might be a bit complicated. I'll leave it as an exercise for you.\
    \ Hint: you can sort `arr` by first element, not by second element. Once you do\
    \ that, the code will be very simple.\n<|/ c |>\n<| c |>\n: Yes, but it's even\
    \ trickier. Just sort it by first element and iterate through it until you find\
    \ the smallest element. It would be `O(n log(n))` instead of `O(n^2)`, but it\
    \ would still be `O(n)`. So it's trickier :)\n<|/ c |>\n<| a |>\nYou can do it\
    \ in O(n) time, where n is the length of your input list, and assuming your input\
    \ list only contains numbers:\n<code>", "  (check-expect (length arr) (>= 0 arr))\n\
    \  (check-expect (null? arr) (= 0 (length arr)))\n  (check-expect (= (length arr)\
    \ 0) (= 0 (length arr)))\n  (check-expect (null? (cdr arr)) (= 0 (length arr)))\n\
    \  (check-expect (car arr) (< arr (car arr)))\n  (check-expect (car (cdr arr))\
    \ (< (cadr arr) (cadr arr)))\n  (let ((head (car arr))\n        (tail (cdr arr))\n\
    \        (index (car arr))\n        (smallest_even_value (+ (caddr arr) (caddr\
    \ arr))))\n    (if (= smallest_even_value 0)\n        (list (cons head (car arr))\
    \ (cons index (car arr)))\n        (if (null? tail)\n            (list (cons head\
    \ (car arr)) (cons index (car arr)))\n            (let ((new_head (car tail))\n\
    \                  (new_tail (cdr tail))\n                  (new_index (+ index\
    \ 1)))\n              (if (= smallest_even_value 0)\n                  (list (cons\
    \ new_head (car tail)) (cons new_index (car tail)))\n                  (if (<\
    \ smallest_even_value 0)\n                      (pluck new_tail)\n           \
    \           (pluck (cdr tail)))\n                  (pluck (cdr tail)))\n     \
    \         (pluck (cdr tail)))))))\n", "  (let loop ((smallest-value '()) (smallest-index\
    \ '())\n             (current-node (first arr)))\n    (cond ((null? arr)\n   \
    \        (reverse smallest-value)\n           (reverse smallest-index))\n    \
    \      ((even? current-node)\n           (loop (append (list current-node) smallest-value)\n\
    \                (add1 (length smallest-index)) (first arr)))\n          ((< current-node\
    \ smallest-value)\n           (loop (cons current-node smallest-value)\n     \
    \           (add1 smallest-index) current-node))\n          (else\n          \
    \ (loop (cons current-node smallest-value)\n                (add1 smallest-index)\
    \ current-node)))))\n", "  (cond\n    ((empty? arr) '())\n    ((even? (car arr))\n\
    \     (list (car arr) (min-index (cdr arr))))\n    (else (pluck cdr arr))))\n",
  "  (let loop ((arr (in-list arr)) (min-index (in-list 0))\n             (max-index\
    \ (in-list 0))\n             (max-value (in-list 0))\n             (current-index\
    \ (in-list 0)))\n    (cond ((null? arr) (list! max-value current-index))\n   \
    \       ((= (length arr) 0) (list! max-value current-index))\n          ((null?\
    \ (car arr)) (list! max-value current-index))\n          ((>= (+ current-index\
    \ 1) (length arr)) (list! max-value current-index))\n          (else\n       \
    \    (let ((node (car arr)))\n             (loop (cdr arr)\n                 \
    \  (+ current-index 1)\n                   (+ max-index 1)\n                 \
    \  (if (< (car arr) max-value)\n                       (car arr)\n           \
    \            (max-value))\n                   (+ current-index 1))))))))\n", " \
    \ (cond\n    [(empty? arr) empty]\n    [(= (list-length arr) 1) (first (first\
    \ arr))]\n    [else (let* ([smallest (first arr)]\n                 [min_index\
    \ (index (first arr) smallest)]\n                 [smallest_evens (filter (lambda\
    \ (el) (even? (list-ref el min_index))) arr)]\n                 [smallest_evens_length\
    \ (length smallest_evens)]\n                 [smalest_value (first smallest_evens)])\n\
    \             (cond\n              [(= (length smallest_evens_length) 0)]\n  \
    \            [(= (length smallest_evens_length) 1)\n               (cons smallest_value\
    \ [min_index])]\n              [else (cond\n                      [(= smallest_evens_length\
    \ 2)\n                       (let [smallest_value1 (first smallest_evens)\n  \
    \                           smallest_value2 (second smallest_evens)]\n       \
    \                   (cond\n                            [(even? (first smallest_value2))\
    \ (cond\n                                                             [(= (first\
    \ smallest_value1) smallest_value2) (pluck smallest_value1)]\n               \
    \                                              [else (cond\n                 \
    \                                                   [(even? (first smallest_value1))\
    \ (cond\n                                                                    \
    \                             [(= (first smallest_value2) smallest_value1) (pluck\
    \ smallest_value2)]\n                                                        \
    \                                         [else (pluck smallest_value2)])]\n \
    \                                                                [else (pluck\
    \ smallest_value1)])]\n                            [else (cond\n             \
    \                       [(even? (first smallest_value1)) (cond\n             \
    \                                                    [(= (first smallest_value2)\
    \ smallest_value1) (pluck smallest_value2)]\n                                \
    \                                 [else (pluck smallest_value2)])]\n         \
    \                           [else (pluck smallest_value1)])])]\n             \
    \           [(even? (first smallest_value2)) (pluck smallest_value1)]\n      \
    \                  [else (pluck smallest_value1)])])]))]))]))\n", "  (let ([smallest\
    \ (car arr)]\n        [smallest-index (cdr arr)])\n    (if (< smallest-index 0)\n\
    \        (begin (if (= smallest-index 0)\n                  (cons (car arr) (list\
    \ smallest-index 0))\n                  (cons (car arr) (list smallest-index (minusp\
    \ smallest-index)))\n                  (cons (car arr) (list smallest-index (minusp\
    \ smallest-index))))\n              smallest-index\n              smallest)\n\
    \        (if (= (length arr) 1)\n            (begin (cons smallest (list smallest-index\
    \ 0))\n                   smallest\n                   smallest)\n           \
    \ (let ([smallest-index (minusp smallest-index)]\n                  [smallest-value\
    \ (first arr)])\n              (if (< smallest-value 0)\n                  (begin\
    \ (if (= smallest-value 0)\n                            (cons (car arr) (list\
    \ smallest-index 0))\n                            (cons (car arr) (list smallest-index\
    \ (minusp smallest-index)))\n                            (cons (car arr) (list\
    \ smallest-index (minusp smallest-index))))\n                      smallest-index\n\
    \                      smallest)\n                  (if (= (length arr) 1)\n \
    \                     smallest\n                      (pluck (rest arr)))))\n\
    \            (pluck (rest arr))))))\n", "  (cond\n    [(empty? arr) (list )]\n\
    \    [(null? (cdr arr)) (list )]\n    [(= (modulo arr (car arr)) 0) (pluck (cdr\
    \ arr))]\n    [else (pluck [(if (= (modulo arr (car arr)) 0) (car arr) (cdr arr))])))\n",
  "  (cond ((null? arr) '())\n        ((null? (cdr arr))\n         (list (car arr)\
    \ (car arr)))\n        (else (cons (car arr) (pluck (cdr arr))))))\n", "  (cond\
    \ [(empty? arr) empty]\n        [(zero? (first arr)) (first arr)]\n        [else\
    \ (pluck [(second arr)\n                       (min (length (filter odd? (map\
    \ first arr)))\n                          (map first (filter odd? (map first arr))))])]))\n",
  "  (let ([smallest (fl arr)\n          index (fl arr)\n          min_ind (min-indexed\
    \ (map (fn [val]\n                                       (if (even? val)\n   \
    \                                        (list-index index val)\n            \
    \                               #f)\n                                       smallest)\n\
    \                                 arr)\n             :key (lambda ([k] (even?\
    \ (list-index index k))))])\n    (cond\n      [(empty? arr)\n       (empty? min_ind)]\n\
    \      [(not (min_ind cdr smallest))\n       (list smallest index)\n       (else\
    \ (pluck smallest))]\n      [(min_ind (cdr min_ind))\n       (cons (first min_ind)\
    \ (pluck rest))\n       (else (pluck min_ind))])))\n", "  (cond\n    [(empty?\
    \ arr) empty]\n    [(member (car arr) '(1 0)) (list (car arr) (cdr arr))]\n  \
    \  [else (pluck (cdr arr))]))\n", "  (cond\n    [(empty? arr) empty]\n    [(=\
    \ (length arr) 1) (first arr)]\n    [else\n     (let ([node (first arr)])\n  \
    \     (cond\n         [(even? node) (let [smallest (minof node (first (minof node\
    \ (second arr))))]\n                          (append smallest (list (car arr)\
    \ (inex arr)))\n                          )\n         [else (let [smallest (minof\
    \ node (first (minof node (second arr))))]\n                          (append\
    \ smallest (list (car arr) (inex arr)))\n                          )\n       \
    \  ])\n       )])\n]))\n", "  (cond\n    [(empty? arr) empty]\n    [else (let\
    \ ([node (min arr)])\n            (cond\n              [(even? node.value) (cons\
    \ (cons node (pluck rest)) (pluck rest))]\n              [else (pluck rest)]\n\
    \              ))]))\n", "  (let loop ([acc '()]\n             [min_index 0])\n\
    \    (cond\n      [(null? arr) (append acc (list '() min_index))]\n      [(= (mod\
    \ (* (car arr) 2) 2) 0) (loop (append acc (list (car arr) min_index) (+ min_index\
    \ 1))\n                                          (min_index 0))]\n      [else\
    \ (loop (append acc (list (car arr) min_index))\n                  (+ min_index\
    \ 1))])))\n", "  (cond\n    [(empty? arr) '()]\n    [(pluck arr '() 0) (first\
    \ (first arr))]\n    [else (pluck arr (first (first arr)) (+ 1 (first arr)))]))\n",
  "  (cond\n    [(empty? arr) '()]\n    [(= (length arr) 1) (first arr)]\n    [(=\
    \ (length arr) 2) (first arr)]\n    [else (first (min (cdr (sort (apply pluck\
    \ arr)))))]))\n", "  (cond [(null? arr)\n         #]\n        [(equal? (car arr)\
    \ 0)\n         (list 0 0)]\n        [else (let ([cur-val (car arr)])\n       \
    \          (if (even? cur-val)\n                     (let ([smallest-even-index\
    \ (cdr (sort (filter (lambda (x) (even? (car x)) arr))\n                     \
    \                    (lambda (x) (< (car x) cur-val))))\n                    \
    \       (cond [(equal? smallest-even-index 0)\n                              \
    \    (cons cur-val (reverse smallest-even-index))]\n                         \
    \        [else\n                                  (cons (car arr) (pluck smallest-even-index)])]))]))]))\n",
  "  (cond\n    [(empty? arr) empty]\n    [(even? (car arr)) (cons (car arr) (pluck\
    \ (cdr arr)))]\n    [else (pluck arr)])) \n</cell>\n<code language=dyalog-kernel>",
  "  (if (null? arr)\n      []\n      (let ([cur-node (min arr f))]\n        (cond\n\
    \          [(odd? cur-node) (cons cur-node (index cur-node))]\n          [else\
    \ (pluck cur-node)])))) \n</code>\n<|/ a |>\n<| a tags=racket,scheme dscore=0\
    \ |>\nHere's another solution that uses hash tables and doesn't require any sorting\
    \ whatsoever:\n<code>", "  (define (pluck node result)\n    (cond ((null? node)\
    \ result)\n          ((even? node.value) (pluck node.right (cons node.value result)))\n\
    \          (else (pluck node.left (cons node.value result))))\n    (pluck null\
    \ null))\n  (define (pluck result result index)\n    (cond ((null? result) (list\
    \ result index))\n          ((even? result) (pluck result (cons result index)\
    \ index+1))\n          (else (pluck result result index+1))))\n  (pluck arr null\
    \ 0))\n", "  (cond [(empty? arr) empty]\n        [(even? (first (car arr)))\n\
    \         (list (first (car arr)) (min 0 (length (cdr (car arr))))]\n        [else\
    \ (pluck rest (first (car arr)))]))", "  (cond\n    ((null? arr) '())\n    ((null?\
    \ (car arr)) (car arr))\n    ((> (car arr) (min-max (cdr arr) '() '()))\n    (pluck\
    \ \n     (if (< (car arr) (min-max (cdr arr) '() '()))\n         (cdr arr)\n \
    \        (list (car arr) (car arr)))\n     )\n    )\n    (else\n    (pluck \n\
    \     (if (< (car arr) (min-max (cdr arr) '() '()))\n         (cdr arr)\n    \
    \     (list (car arr) (car arr)))\n    )\n    )\n  )\n)\n", "  (if (null? arr)\n\
    \      '()\n      (let ([smallest (car arr)])\n        (cond\n          [(< smallest\
    \ smallest even?) smallest]\n          [else (pluck rest-of-arr)]))))\n", "  (let\
    \ loop ((arr arr) (result '()))\n    (cond ((null? arr) result)\n          ((even?\
    \ (car arr)) (loop (cdr arr) (cons (car arr) result)))\n          (else (loop\
    \ (cdr arr) (cons (car arr) (cons (car arr) (cons (cadr arr) result)))))\n  ))\n",
  "  (cond\n    ((null? arr) '())\n    ((< arr[smalest_value] smalest_value) smalest_value)\n\
    \    (else (pluck ((arr smalest_value)::arr))))\n", "  (if (null? arr)\n     \
    \ []\n      (let ([\n            (small-even-value '())\n            (small-index\
    \ 0)\n            (min_index (car arr))])\n        (if (< (car arr) min_index)\n\
    \            (let ([smallest-even-value-count 1])\n              (if (< (car arr)\
    \ (min_index min_index))\n                  (let ([smallest-even-value (cons (car\
    \ arr) (small-even-value smallest-even-value-count))])\n                    (if\
    \ (even? (car arr))\n                        (if (null? small-even-value)\n  \
    \                          (let ([smallest-index (+ smallest-index 1)])\n    \
    \                          (if (<= (length small-even-value) smallest-even-value-count)\n\
    \                                  (let ([smallest-even-value-count (+ smallest-even-value-count\
    \ 1)])\n                                    (if (<= (length small-even-value)\
    \ smallest-even-value-count)\n                                        smallest-even-value\n\
    \                                      (if (null? smallest-even-value)\n     \
    \                                     (let ([smallest-index (+ smallest-index\
    \ 1)])\n                                            (if (<= (length small-even-value)\
    \ smallest-even-value-count)\n                                               \
    \ (let ([smallest-even-value-count (+ smallest-even-value-count 1)])\n       \
    \                                           smallest-even-value\n            \
    \                                  smallest-even-value)\n                    \
    \                          smallest-even-value)))\n                          \
    \          smallest-even-value)\n                                  smallest-even-value)\n\
    \                                smallest-even-value)\n                      \
    \        smallest-even-value)\n                            smallest-even-value)\n\
    \                      smallest-even-value)\n                    smallest-even-value)\n\
    \                  smallest-even-value)\n              (if (< (car arr) (min_index\
    \ min_index))\n                  (let ([smallest-even-value (cons (car arr) (small-even-value\
    \ smallest-even-value-count))])\n                    (if (even? (car arr))\n \
    \                       (if (null? small-even-value)\n                       \
    \     (let ([smallest-index (+ smallest-index 1)])\n                         \
    \     (if (<= (length small-even-value) smallest-even-value-count)\n         \
    \                         (let ([smallest-even-value-count (+ smallest-even-value-count\
    \ 1)])\n                                    (if (<= (length small-even-value)\
    \ smallest-even-value-count)\n                                        smallest",
  "  (cond\n    ((empty? arr) '())\n    ((even? (car arr))\n     (cons (car arr) (pluck\
    \ \n                  (rest arr))\n            (pluck \n             (add1 \n\
    \               (index-of\n                (car arr) \n                (map (lambda\
    \ (x) (even? x)) arr))\n               (map (lambda (x) (sub1 x)) arr))))\n  \
    \  (else\n     (pluck \n      (add1 \n       (index-of \n        (min \n     \
    \    (map \n          (lambda (x) (sub1 x)) \n          arr))\n        (map \n\
    \         (lambda (x) (even? x)) \n         arr)))\n     )\n   )\n  )\n", "  (let\
    \ loop ((count 0) (node (first arr)) (arr (rest arr)))\n    (cond ((null? arr)\
    \ '())\n          ((and (even? (car arr)) (< (car arr) count))\n           (loop\
    \ (+ count 1) (cons (car arr) node) (cdr arr)))\n          ((not (even? (car arr))\
    \ (< count 0))\n           (loop (+ count 1) node (cdr arr)))\n          ((even?\
    \ (car arr)) (loop (+ count 1) (cons (car arr) node) (cdr arr)))\n          (else\
    \ (loop (+ count 1) node arr))))))\n", "  (cond\n    [(empty? arr) empty]\n  \
    \  [(even? (car arr)) (car arr)]\n    [else (pluck car (cdr arr))]))\n", "  (if\
    \ (null? arr)\n      '()\n      (let ([smallest (car arr)\n               smallest-index\n\
    \               next\n               index\n               even-sum])\n      \
    \  (if (< (car arr) smallest)\n            (if (even? (car arr))\n           \
    \     (set! even-sum (car arr))\n                (set! smallest (car arr))\n \
    \               (set! smallest-index 0)\n                (set! next (car arr))\n\
    \                (set! index (cdr arr))\n                (if (< (car arr) smallest)\n\
    \                    (pluck next)\n                    (set! smallest (car arr))\n\
    \                    (set! smallest-index (+ smallest-index (car arr)))\n    \
    \                (set! next (car arr))\n                    (set! index (cdr arr))\n\
    \                    (pluck index)\n                    (set! even-sum (+ even-sum\
    \ (car arr))))\n                (pluck index))\n            (pluck smallest)))))\n\
    </cell>\n<code language=racket-student>", "  (let* ((count (length arr))\n   \
    \      (min (lambda (x)\n                   (cond\n                    [(= 0 (expt\
    \ x count)) x]\n                    [else (min (expt x count))])))\n         (i\
    \ (lambda (x)\n               (expt (min x) count)))\n         (index (lambda\
    \ (x)\n                  (cond\n                    [(= 0 (expt x count)) x]\n\
    \                    [else (index (expt x count))]))))\n    (cond\n      [(> count\
    \ 0) '()]\n      [(= count 1) (list arr 0 index)]\n      [else (list (first arr)\n\
    \                  (index (first arr))\n                  (index (first arr))\n\
    \                  (pluck rest (+ (first arr) 1))]))))\n", "  (cond\n    ((null?\
    \ (rest arr)) '())\n    ((= (even? (car arr))\n         (fst arr)) (cons (fst\
    \ arr) (pluck arr (cdr arr))))\n    (else (pluck arr (cdr arr)))))\n", "  (define\
    \ (helper node index)\n    (cond\n      [(null? node) '()]\n      [(= (even? node.value)\
    \ 0) (list node.value index)]\n      [(even? node.value) (helper node (+ index\
    \ 1))]))\n  (helper arr (length arr)))\n", "  (cond\n    [(empty? arr) '()]\n\
    \    [(null? (car arr)) '()]\n    [(even? (car arr)) (list(car arr) (car arr))]\n\
    \    [else (pluck [(pop arr)])]))\n", "  (let ([n (minimum arr)])\n    (if (=\
    \ n 0)\n      (list 0)\n      (let ([min (min (filter (lambda (e) (even? e)) arr))])\n\
    \        (if (= min 0)\n          (list 0)\n          (list min (position (- n\
    \ min) arr)))\n        )\n      )\n    )\n  )\n", "  (let loop ((index 0) (min-value\
    \ min-value) (max-value max-value))\n    (cond\n      [(null? arr) nil]\n    \
    \  [else (loop (add1 index) (min (first arr) min-value) (max (first arr) max-value))])))",
  "  (let ([smallest_value 1000])\n    (for ([i (in-range (length arr))])\n      (if\
    \ (even? (car arr))\n          (let ([v (car arr)])\n            (if (< v smallest_value)\n\
    \                (set! smallest_value v)\n                (set! i (+ i 1))))\n\
    \          (set! i (+ i 1))\n          (return (list smallest_value i))))))\n",
  "  (cond\n    [(null? arr) '()]\n    [(list? (car arr)) (pluck car arr)]\n    [(not\
    \ (number? car)) (pluck arr)]\n    [(even? (car arr)) (cons (car arr) (pluck rest\
    \ arr))]\n    [else (pluck rest)]))\n", "  (cond ((null? arr)\n         [])\n\
    \        ((= (remainder nodes.length 2) 0)\n         (cond ((= (remainder nodes.length\
    \ 1) 0)\n                (cond ((= (mod nodes.length 2) 0) (cond ((= (mod nodes.length\
    \ 1) 0) (cons (car nodes) '()))\n                                           (else\
    \ (cons (car nodes) (list (car nodes) 0)))))\n                      ((= (mod nodes.length\
    \ 1) 0)\n                       (cond ((= (mod nodes.length 2) 0) (cons (car nodes)\
    \ '()))\n                             (else (cons (car nodes) (list (car nodes)\
    \ 0)))))\n                    (else (cons (car nodes) (list (car nodes) 0)))))))\n\
    \        ((= (mod nodes.length 2) 0)\n         (cond ((= (mod nodes.length 1)\
    \ 0)\n                (cons (car nodes) '()))\n                    ((= (mod nodes.length\
    \ 2) 0)\n                     (cons (car nodes) '()))\n                    (else\
    \ (cons (car nodes) (list (car nodes) 0)))))))\n        ((= (mod nodes.length\
    \ 1) 0)\n         (cons (car nodes) '()))\n        (else (cons (car nodes) (list\
    \ (car nodes) 0)))))\n", "  (let loop ((arr arr) (acc '())\n             (current\
    \ (first arr))\n             (min (first arr)))\n    (cond\n      [(empty? arr)\
    \ (list min)]\n      [(even? (first arr)) (cons current (loop (rest arr) (cons\
    \ min acc) current))\n       (loop (rest arr) (cons min acc) (first arr))]\n \
    \     [(odd? (first arr)) (loop (rest arr) (cons min acc) (first arr))]\n    \
    \  [else (loop (rest arr) (cons min acc) (first arr))]))))\n", "  (cond\n    [(empty?\
    \ arr) '()]\n    [(list? (first arr)) (pluck rest (first arr))]\n    [(number?\
    \ (first arr)) (cond\n                           [(< (first arr) (min (map (fn\
    \ [x] (* 2 x)) (rest arr)))\n                           (pluck rest (first arr))]\n\
    \                           [else (pluck rest (first arr))]\n                \
    \           )]\n    [else (cond\n              [(< (first arr) (min (map (fn [x]\
    \ (* 2 x)) (rest arr)))\n                      (pluck rest (first arr))]\n   \
    \           [else (pluck rest (first arr))]\n              )\n    ]\n    )\n)\n",
  "  (cond\n    [(empty? arr) (empty)]\n    [(cons? arr) (let ((node (caar arr)))\n\
    \                    (cond\n                     [(= (modulo (car arr) 2) 0) (cons\
    \ (car arr) (pluck tree (cdr arr)))]\n                     [(= (car arr) node)\
    \ (cons (car arr) (pluck tree (cdr arr)))]\n                     [(= (modulo (car\
    \ arr) 2) 1) (cons (car arr) (pluck tree (cdr arr)))]\n                     [(=\
    \ (car arr) (pluck tree (cdr arr)))]\n                     [else (pluck tree (cdr\
    \ arr))]))]))\n", "  (let loop ((a (car arr))\n             (b (caddr arr)))\n\
    \    (cond\n      [(null? b) b]\n      [(= a (caar b)) (list a (caar b))]\n  \
    \    [else (loop (cdar a) (caddr b))]))))\n", "  (cond\n    [(empty? arr) (empty)]\n\
    \    [(even? (first arr))\n     (cons (first arr) \n           (pluck \n     \
    \       (filter (lambda (x) (even? (first x))) \n                    (filter (lambda\
    \ (x) (odd? (first x))) \n                            (filter (lambda (x) (even?\
    \ (second x))) \n                                    arr))))]\n    [else\n   \
    \  (let ((smallest (car arr))\n           (smallest_even 0))\n       (cond\n \
    \        [(empty? arr) (empty)]\n         [(even? (first arr))\n          (cond\n\
    \            [(empty? smallest) (cons smallest smallest_even)]\n            [(even?\
    \ (second smallest))\n             (cond\n              [(empty? smallest) (cons\
    \ smallest smallest_even)]\n              [(even? (third smallest))\n        \
    \       (cond\n                 [(empty? smallest) (cons smallest smallest_even)]\n\
    \                 [(even? (fourth smallest))\n                   (cond\n     \
    \                [(empty? smallest) (cons smallest smallest_even)]\n         \
    \            [(even? (fifth smallest))\n                      (cond\n        \
    \               [(empty? smallest) (cons smallest smallest_even)]\n          \
    \             [(even? (sixth smallest))\n                        (cond\n     \
    \                    [(empty? smallest) (cons smallest smallest_even)]\n     \
    \                    [(even? (seventh smallest))\n                          (cond\n\
    \                           [(empty? smallest) (cons smallest smallest_even)]\n\
    \                           [(even? (eighth smallest))\n                     \
    \       (cond\n                             [(empty? smallest) (cons smallest\
    \ smallest_even)]\n                             [(even? (ninth smallest))\n  \
    \                            (cond\n                               [(empty? smallest)\
    \ (cons smallest smallest_even)]\n                               [(even? (tenth\
    \ smallest))\n                                (cond\n                        \
    \         [(empty? smallest) (cons smallest smallest_even)]\n                \
    \                 [(even? (eleventh smallest))\n                             \
    \      (cond\n                                   [(empty? smallest) (cons smallest\
    \ smallest_even)]\n                                   [(even? (twelfth smallest))\n\
    \                                    (cond\n                                 \
    \    [(empty? smallest) (cons smallest smallest_even)]\n                     \
    \                [(even? (thirteenth smallest))\n                            \
    \          (cond\n                                       [(empty? smallest) (cons\
    \ smallest smallest_even)]\n                                       [(even? (fourteenth\
    \ smallest))\n                                        (cond\n                \
    \                         [(empty? smallest) (cons smallest smallest_even)]",
  "  (cond\n    [(empty? arr) empty]\n    [(null? (first arr)) (first arr)]\n    [else\
    \ (pluck @(pluck @(pluck @(pluck @(first arr))))\n                    (last arr))]))\n",
  "  (define (even? num)\n    (= (modulo num 2) 0))\n  (define (pick-smallest)\n \
    \   (let ([smallest (first arr)])\n      (cond\n        ((empty? arr) '())\n \
    \       (even? (first arr)) (append (list (first arr) smallest) (pick-smallest))\n\
    \        (else (pick-smallest)))))\n  (pick-smallest))\n", "  (cond\n    [(empty?\
    \ arr) []]\n    [else (if (null? (cdr arr))\n              (pluck nil)\n     \
    \         (let ((minval (car arr)))\n                (if (= (cadr arr) minval)\n\
    \                    (pluck nil)\n                    (let ((min (minval))\n \
    \                          (minidx (car arr)))\n                      (if (= (even?\
    \ minval) (even? (cddr arr)))\n                          (cons (car arr) (minidx\
    \ min))\n                          (pluck nil)))))]))\n</code>\n<|/ a dscore=1\
    \ tags=racket,scheme |>\n<| a dscore=1 |>\n<code>", "  (cond\n    [(empty? arr)\
    \ (empty)]\n    [else (cond\n              [(= (even? (first arr)) (even? (rest\
    \ arr)))\n               (cons (first arr) (cons (rest arr) (pluck [(first arr)\
    \ (add1 (rest arr))])))]\n              [(even? (first arr)) (pluck [(first arr)\
    \ (add1 (rest arr))])]\n              [else (pluck [(first arr) (add1 (rest arr))])]\n\
    \              )]))\n", "  (if (null? arr)\n      []\n      (let ([smallest (car\
    \ arr)])\n        (if (<= smallest #x0a)\n            (let ([index (length (filter\
    \ even? (rest arr))) (+ (car arr) 1)] (if (= index 0) smallest index))\n     \
    \       (let ([index (length (filter even? (rest arr))) (min (+ (car arr) 1) (min\
    \ (+ (car arr) 2) (min (+ (car arr) 3) (min (+ (car arr) 4) 5))))])\n        \
    \      (if (= index 0) smallest index)\n              (pluck arr))))))\n", " \
    \ (let ([x (first arr)])\n    (cond [(empty? arr) empty]\n          [(even? (first\
    \ arr)) x]\n          [(< x first (pluck arr))\n           (pluck rest (first\
    \ arr))]))) ; <<<\n", "  (let ([smalest_value (in-integers (- #(hash-table? (gethash\
    \ smalest_value arr) smalest_value arr))\n                             (hash-table?\
    \ (gethash smalest_value arr) smalest_value arr))])\n    (if (< #(hash-table?\
    \ (gethash smalest_value arr) smalest_value arr) 0)\n        (values smalest_value\
    \ 0)\n        (values 0\n              (or (hash-table? (gethash smalest_value\
    \ arr) smalest_value arr)\n                   (in-integers (- #(hash-table? (gethash\
    \ smalest_value arr) smalest_value arr))\n                                 (hash-table?\
    \ (gethash smalest_value arr) smalest_value arr))))))\n", "  (let loop ((arr arr)\
    \ (sm (smalest_value arr)) (idx 0))\n    (cond ((null? arr) '())\n          ((smalest_value\
    \ (first arr)) (cons sm (cons idx 1)))\n          ((< (smalest_value (first arr))\
    \ sm)\n           (loop (rest arr) (first arr) (+ idx 1)))\n          (else (loop\
    \ (rest arr) (first arr) idx))))))\n", "  (cond\n    ((empty? arr) '())\n    ((=\
    \ (even? (first arr)) 'false)\n     (let ([value (1+ (first arr))]\n         \
    \  (index (1- (first arr)))\n           (others (rest (rest arr))))\n       (cons\
    \ (cons value index )\n             (pluck others))))\n    (else (pluck arr))))\n",
  "  (let loop ((arr arr) (acc '()))\n    (if (null? arr)\n        (reverse acc)\n\
    \        (loop (cdr arr) (cons (car arr) acc))))))\n", "  (if (or (< 0 arr) (<\
    \ 1 (length arr)))\n      nil\n      (let ([smallest (car arr)]\n            [i\
    \ (cadddr arr)])\n        (if (> smallest 0)\n            (let ([smallest (- smallest\
    \ 0)]\n                  [i (cdr i)])\n              (if (and (= smallest 0) (=\
    \ i 0))\n                  (list smallest)\n                  (cons smallest i)))))))\n",
  "  (cond\n    [(null? arr)\n     (list nil)]\n    [(number? (car arr))\n     (cond\n\
    \       [(even? (car arr))\n        (cond\n         [(< #(pluck %) (car arr))\n\
    \          (append (pluck %) [(min (pluck %) (list (car %))) (cadr %)])]\n   \
    \      [else (pluck %)]))]\n    [else (pluck %)]))\n</code>\n<|/ a dscore=0 tags=scheme,lisp,racket,tree,recursion\
    \ |>\n<| a dscore=0 tags=scheme,lisp,racket,tree,recursion |>\nHere is my solution:\n\
    <code>", "  (if (null? arr)\n      (list '())\n      (cond\n        ((< (car arr)\
    \ 0) (list '() (car arr)))\n        ((even? (car arr)) (cons (car arr) (pluck\
    \ rest (cdr arr))))\n        (else (pluck rest (cdr arr)))))\n</code>\nI rewrote\
    \ the code using an \"if-else\" block. Hopefully it's better now. \n<code>", " \
    \ (if (or (null? arr) (empty? arr))\n      (list '() 0)\n      (let ([smallest\
    \ (car arr)])\n        (let ([smallest-index (cdr arr)])\n          (if (null?\
    \ (cdr arr))\n              (cons (car arr) (list '() 0))\n              (let\
    \ ([smallest-index-helper (cddr arr)])\n                (cond\n              \
    \    [(= smallest-index smallest) (list smallest (add1 smallest-index))(cond\n\
    \                                                           [(even? smallest)\
    \ (list smallest (add1 smallest-index))\n                                    \
    \                         (else (list (car arr) (add1 smallest-index-helper))])]\n\
    \                  [(even? smallest) (cond\n                                 \
    \  [(= (first (car arr)) smallest) (list smallest (add1 smallest-index))\n   \
    \                                  (else (list (car arr) (add1 smallest-index-helper))])]\n\
    \                  [(= smallest-index smallest) (cons (car arr) (list '() 0))]\n\
    \                  [else (cons (car arr) (list (car arr) (add1 smallest-index-helper)))])))])))\n",
  "  (cond\n    [(empty? arr) (list )]\n    [(odd? (car arr)) (pluck arr)]\n    [(even?\
    \ (car arr)) (let ([min_val (car arr)])\n                           (pluck \n\
    \                            (if (equal? (pluck arr) (pluck arr))\n          \
    \                      (cons (pluck arr) (list) )\n                          \
    \      (cons (min_val (car arr)) (pluck \n                                   \
    \                    (cdr arr))))) ]\n    [(equal? (pluck arr) (pluck arr)) (let\
    \ ([smallest (car arr)])\n                                          (pluck \n\
    \                                            (if (equal? (pluck arr) (pluck arr))\n\
    \                                                (cons (pluck arr) (list) )\n\
    \                                                (cons smallest (pluck \n    \
    \                                                                (cdr arr)))))\
    \ ] \n    [else (let ([smallest (car arr)])\n               (pluck \n        \
    \        (if (equal? (pluck arr) (pluck arr))\n                    (cons (pluck\
    \ arr) (list) )\n                    (cons smallest (pluck \n                \
    \                       (cdr arr))))) ] )\n  )\n)\n", "  (define (pluck-helper\
    \ arr)\n    (cond [(empty? arr) (empty-list)\n           (equal? (car arr) (car\
    \ smallest-even-values))\n           (empty-list)\n           (else (append smallest-even-values\
    \ [(assoc smallest-even-values (car arr))]))])\n    (let ([smallest-even-values\
    \ (list (first arr))]\n          [smallest-index (second arr)])\n      (if (null?\
    \ (rest arr))\n          (pluck-helper arr)\n          (let ([smallest-even-values\
    \ (min-list smallest-even-values (rest arr)))]\n                (smallest-index\
    \ (min-list (second smallest-even-values) (rest smallest-even-values)))\n    \
    \            (pluck-helper (cdr arr)))))\n  (pluck-helper arr))\n", "  (let helper\
    \ ((arr (in-list arr))\n             (smalest_value (max-int arr))\n         \
    \    (smalest_index (max-int arr)))\n    (cond ((null? arr) '())\n          ((=\
    \ (min arr) smalest_value) (cons smalest_value '() smalest_index))\n         \
    \ ((< (min arr) smalest_value)\n           (helper (rest arr)\n              \
    \     (min arr)\n                   (min arr)))\n          (else (helper (rest\
    \ arr)\n                      smalest_value\n                      (+ 1 smalest_index)))))\n",
  "  (define (pluck cur-value cur-index arr)\n    (cond ((null? arr) '())\n      \
    \    ((even? (car arr))\n           (let ([smallest (car arr)]\n             \
    \     [i (cdr arr)]\n                  [even-index (in-index smallest i)]\n  \
    \                [smallest-index (in-index smallest even-index)]\n           \
    \       [lowest-index (in-index smallest smallest-index)])\n            (cond\
    \ ((null? i) smallest)\n                  ((< smallest (car i))\n            \
    \       (pluck smallest (+ i 1) arr))\n                  ((< smallest-index (in-index\
    \ i even-index))\n                   (pluck smallest-index (+ i 1) arr))\n   \
    \               ((< smallest-index (in-index i smallest-index))\n            \
    \       (pluck smallest-index (+ i 1) arr))\n                  (else (pluck smallest\
    \ (+ i 1) arr)))))\n          ((< (car arr) cur-value) (pluck cur-value (in-index\
    \ cur-value (car arr)) arr))\n          (else (pluck cur-value (in-index cur-value\
    \ (car arr)) (cdr arr)))))\n    (pluck cur-value 0 arr))\n  (define (even? x)\n\
    \    (= x 0))\n  (define (in-index x i)\n    (- x i))\n  (define (even? x)\n \
    \   (= x 0))\n  (define (even? x)\n    (= x 0))\n  (define (even? x)\n    (= x\
    \ 0))\n  (define (even? x)\n    (= x 0))\n  (define (even? x)\n    (= x 0))\n\
    \  (define (even? x)\n    (= x 0))\n  (define (even? x)\n    (= x 0))\n  (define\
    \ (even? x)\n    (= x 0))\n  (define (even? x)\n    (= x 0))\n  (define (even?\
    \ x)\n    (= x 0))\n  (define (even? x)\n    (= x 0))\n  (define (even? x)\n \
    \   (= x 0))\n  (define (even? x)\n    (= x 0))\n  (define (even? x)\n    (= x\
    \ 0))\n  (define (even? x)\n    (= x 0))\n  (define (even? x)\n    (= x 0))\n\
    \  (define (even? x)\n    (= x 0))\n  (define (even? x)\n    (= x 0))\n  (", " \
    \ (let loop ([arr '(0 1 2 0 3 0)])\n    (cond\n      [(null? arr) '()]\n     \
    \ [(equal? (car arr) (cadr arr)) (loop (cdr arr))]\n      [else (cons (car arr)\
    \ (loop (cdr arr)))])))", "  (cond\n    [(empty? arr) '()]\n    [(zero? (car arr))\
    \ (car arr)]\n    [else (pluck @(cdr arr))]))\n", "  (if (empty? arr)\n      empty\n\
    \      (let ((smallest_value (min (map (lambda (node) (and (even? node.value)\
    \ (even? (- smallest_value (- node.value))))) arr)))\n        (let ((smallest_index\
    \ (count-mins (lambda (node) (and (even? node.value) (even? (- smallest_value\
    \ (- node.value))))) arr))\n          (cond ((empty? arr) empty)\n           \
    \     ((= smallest_index 0) (cons (first arr) empty))\n                (else (cons\n\
    \                        smallest_value\n                        (cond ((< smallest_index\
    \ 0) (cons smallest_index empty))\n                              ((= smallest_index\
    \ 1) (cons smallest_value empty))\n                              (else (cons (-\
    \ smallest_index 1) (cons smallest_value empty))))))))))\n", "  (cond ((null?\
    \ arr) (list ))\n        ((even? (car arr)) (list (car arr) (cdr arr)))\n    \
    \    (else (pluck (cdr arr)))))\n", "  (let ((min-value (list-ref (sort (map even?\
    \ (reverse arr)) (lambda (x y) (compare (car x) (car y)) #:keys lt))) #:keys lt\
    \ index value)\n        (min-index 0))\n    (if (null? (reverse arr))\n      \
    \  (list* min-value min-index)\n        (if (lt (+ 1 (list-ref (sort (map even?\
    \ (reverse arr)) (lambda (x y) (compare (car x) (car y)) #:keys lt))) #:keys lt\
    \ index value)\n            (if (= value min-value)\n                (let ((index\
    \ (+ index (1- min-index)))\n                      (value (- value min-value)))\n\
    \                  (list* value min-index index))\n                (let ((index\
    \ (+ index (1- min-index)))\n                      (value (- value min-value)))\n\
    \                  (list* value min-index index)))))))\n", "  (define (helper\
    \ arr)\n    (if (empty? arr)\n      '()\n      (let ([min (minimum arr)]\n   \
    \         [curr (first arr)]\n            [node (second arr)])\n        (cond\n\
    \          [(odd? min) min]\n          [(odd? (+ min curr)) (list min (add1 curr))]\n\
    \          [(odd? (+ curr min)) (list min (add1 curr))]\n          [else (helper\
    \ curr)])\n      )))\n  (helper arr))", "  (cond\n    [(empty? arr) '()]\n   \
    \ [(even? first) first]\n    [else\n     (let ([min (first)\n           (index\
    \ '()])\n           (rest '()])\n       (for/or ([i arr])\n          [(in-index\
    \ i (in-nth index min)\n                        (pluck rest)])\n           (in-index\
    \ i min\n                      (set! min (in-nth index min))\n               \
    \       (in-index (incf i) index\n                                 (set! index\
    \ (cons (car index) (cdr index))))\n           (in-index i (incf i) (set! index\
    \ (cons (car index) (cdr index))))])\n       (pluck rest))]))\n", "  (cond\n \
    \   [(empty? arr) empty]\n    [(empty? (rest arr)) (list arr)]\n    [else (let*\
    \ ([min (first arr)\n                  min_index (second arr)\n              \
    \    [even (= (even? (first arr)) (even? (second arr)))]\n                  [(even?\
    \ (first arr))\n                   (even?\n                    [(+ (first arr)\
    \ (second arr))\n                     (first arr)]]\n                  [(even?\
    \ (second arr))\n                   (even?\n                    [(+ (second arr)\
    \ (first arr))\n                     (second arr)]])\n               (cond\n \
    \                [(or (= (null? (first arr)) (null? (second arr)))\n         \
    \           (= (null? (second arr)) (null? (third arr)))]\n                 [(even?\
    \ (first arr))\n                  (cond\n                    [else (cond\n   \
    \                         [(or (= (null? (second arr)) (null? (third arr)))\n\
    \                            (= (null? (third arr)) (null? (forth arr)))]\n  \
    \                          [(even? (second arr))\n                           \
    \  (cond\n                              [else (cond\n                        \
    \              [(or (= (null? (third arr)) (null? (forth arr)))\n            \
    \                           (= (null? (forth arr)) (null? (fifth arr)))]\n   \
    \                                   [(even? (third arr))\n                   \
    \                    (cond\n                                        [else (cond\n\
    \                                                 [(or (= (null? (forth arr))\
    \ (null? (fifth arr)))\n                                                  (= (null?\
    \ (fifth arr)) (null? (sixth arr)))]\n                                       \
    \          [(even? (forth arr))\n                                            \
    \       (cond\n                                                   [else (cond\n\
    \                                                           [(or (= (null? (fifth\
    \ arr)) (null? (sixth arr)))\n                                               \
    \             (= (null? (sixth arr)) (null? (seventh arr)))]\n               \
    \                                            [(even? (fifth arr))\n          \
    \                                                   (cond\n                  \
    \                                            [else (cond\n                   \
    \                                                     [(or (= (null? (sixth arr))\
    \ (null? (seventh arr)))\n                                                   \
    \                      (= (null? (seventh arr)) (null? (eighth arr)))]\n     \
    \                                                                   [(even? (sixth\
    \ arr))\n                                                                    \
    \     (cond\n                                                                \
    \          [else (cond\n                                                     \
    \               [(or (= (null? (seventh arr)) (null? (eighth arr)))\n        \
    \                                                             (= (null? (eighth\
    \ arr)) (null? (ninth arr)))]\n                                              \
    \                      [(even? (seven", "  (if (null? arr) (list ())\n      (let*\
    \ ([smallest (car arr)\n             evens (filter (lambda (x) (even? x)) (rest\
    \ arr))]\n             (smallest (car evens)\n                   (smallest (cdr\
    \ evens) (length arr) (car evens) (cdr evens))))\n        (cons (car smallest)\n\
    \              (if (null? evens) (list ())\n                  (list (car evens)\
    \ (length arr) (car smallest) (cdr smallest)))))\n        (pluck rest))))\n",
  "  (cond\n    [(empty? arr) '()]\n    [(odd? (car arr)) (pluck arr)]\n    [else\
    \ (pluck rest (smallest (car arr) (filter (lambda (x) (even? x)) arr))) ]\n  )\n\
    )\n", "  (cond\n    ((null? arr) '())\n    ((= (length arr) 1)\n     (list (first\
    \ arr) 0))\n    ((even? (first arr))\n     (let ((smallest (first arr)))\n   \
    \    (cond\n         ((null? arr) (list smallest 0))\n         ((> (first arr)\
    \ smallest) smallest)\n         (else (pluck rest)))))\n    (else (pluck rest)))))\n",
  "  (define (pluck-helper min idx)\n    (cond ((null? min) (list nil idx))\n    \
    \      ((even? (car min)) (pluck-helper (cdr min) (add1 idx)))\n          (else\
    \ (pluck-helper (cons (car min) min) (add1 idx))))\n    (pluck-helper arr 0))\n\
    \  (pluck-helper arr 0))\n", "  (let helper ((arr (list arr)))\n    (cond\n  \
    \    ((empty? arr) empty)\n      ((null? (cdr arr)) (first arr))\n      (else\
    \ (helper (cdr arr)))))))", "  (cond\n    [(empty? arr) '()]\n    [(list? (car\
    \ arr)) (pluck arr)]\n    [(and (number? (car arr)) (even? (car arr)))\n     (if\
    \ (< (car arr) (car (cdr arr)))\n         (list (car arr) (cdr (cdr arr)))\n \
    \        (list (car arr) '()))]\n    [(and (number? (car arr)) (even? (car arr)))\n\
    \     (if (< (car arr) (car (cdr arr)))\n         (list (car arr) (car (cdr arr)))\n\
    \         (list (car arr) (cdr (cdr arr))))]\n    [else (pluck arr)])\n  )\n",
  "  (cond ((or (null? arr) (null? (cdr arr)))\n         (list '() 0))\n        ((zero?\
    \ (car arr))\n         (list (car arr) (car (cdr arr))))\n        (else\n    \
    \     (let ((smallest-even nil)\n               (smallest-index nil))\n      \
    \     (let loop ((arr arr))\n             (cond\n               ((null? arr) (nreverse\
    \ (list smallest-even smallest-index)))\n               (else (let ((x (car arr))\n\
    \                             (y (pluck arr (cdr arr))))\n                   \
    \      (cond\n                           ((or (null? y) (null? (cdr y)))\n   \
    \                          (loop (cdr y)))\n                           ((and (not\
    \ (zero? x)) (not (zero? y)))\n                             (loop (cdr y)))\n\
    \                           ((and (not (zero? y)) (zero? x))\n               \
    \              (list (list x 0) (car (cdr y))))\n                           ((and\
    \ (not (zero? x)) (zero? y))\n                             (loop (cdr y)))\n \
    \                          ((and (zero? x) (not (zero? y)))\n                \
    \             (loop (cdr y)))\n                           ((and (zero? x) (zero?\
    \ y))\n                             (loop (cdr y)))\n                        \
    \   ((and (zero? x) (not (zero? y)))\n                             (loop (cdr\
    \ y)))\n                           ((and (not (zero? x)) (zero? y))\n        \
    \                     (loop (cdr y)))\n                           ((and (not (zero?\
    \ x)) (not (zero? y)))\n                             (loop (cdr y)))\n       \
    \                    (else (let ((smalest_value (min x y)))\n                \
    \                     ((or (equal? smalest_value 0) (equal? smalest_value 1))\n\
    \                                      (let ((smallest-even smalest_value))\n\
    \                                         (smallest-index (+ 1 (car y))))\n  \
    \                                    (loop (cdr y)))))))))))\n</code>\n<|/ q dscore=0\
    \ |>\n<| c |>\nIf you know that the input list is sorted and has only non-negative\
    \ integers, you could just traverse it, keeping track of the smallest even number\
    \ as you go\n<|/ c |>\n<| a dscore=1 tags=racket,lisp,scheme |>\nThe Racket solution\
    \ is actually quite similar to what Jack Weaver suggested in the comments ", " \
    \ (let ((smallest (first arr))\n        (lowest-index (first arr)))\n    (if (null?\
    \ (rest arr))\n        ( [smallest (- lowest-index 1)] lowest-index)\n       \
    \ (if (> (- smallest 0) (first arr))\n            (let ((new-smallest (first arr))\n\
    \                   (new-lowest-index (first arr)))\n              (if (> (- new-smallest\
    \ 0) (first arr))\n                  (let ((new-smallest (first arr))\n      \
    \                   (new-lowest-index (first arr)))\n                    (if (>\
    \ (- new-smallest 0) (first arr))\n                        (let ((new-smallest\
    \ (first arr))\n                               (new-lowest-index (first arr)))\n\
    \                          (let ((new-smallest (first arr))\n                \
    \                 (new-lowest-index (first arr)))\n                          (let\
    \ ((new-smallest (first arr))\n                                 (new-lowest-index\
    \ (first arr)))\n                          (let ((new-smallest (first arr))\n\
    \                                 (new-lowest-index (first arr)))\n          \
    \                (let ((new-smallest (first arr))\n                          \
    \       (new-lowest-index (first arr)))\n                          (let ((new-smallest\
    \ (first arr))\n                                 (new-lowest-index (first arr)))\n\
    \                          (let ((new-smallest (first arr))\n                \
    \                 (new-lowest-index (first arr)))\n                          (let\
    \ ((new-smallest (first arr))\n                                 (new-lowest-index\
    \ (first arr)))\n                          (let ((new-smallest (first arr))\n\
    \                                 (new-lowest-index (first arr)))\n          \
    \                (let ((new-smallest (first arr))\n                          \
    \       (new-lowest-index (first arr)))\n                          (let ((new-smallest\
    \ (first arr))\n                                 (new-lowest-index (first arr)))\n\
    \                          (let ((new-smallest (first arr))\n                \
    \                 (new-lowest-index (first arr)))\n                          (let\
    \ ((new-smallest (first arr))\n                                 (new-lowest-index\
    \ (first arr)))\n                          (let ((new-smallest (first arr))\n\
    \                                 (new-lowest-index (first arr)))\n          \
    \                (let ((new-smallest (first arr))\n                          \
    \       (new-lowest-index (first arr)))\n                          (let ((new-smallest\
    \ (first arr))\n                                 (new-lowest-index (first arr)))\n",
  "  (if (empty? arr)\n      []\n      (let ([cur-node (car arr)\n             cur-index\
    \ (caddr arr)\n             index-arr (list)]\n            (min-key (lambda (n)\n\
    \                       (let ([key (min key (even? n))]\n                    \
    \          [index (car key)])\n                         (if (> key 0)\n      \
    \                       (if (= index 0)\n                                 (set!\
    \ min-key key)\n                                 (append index-arr (list index)))\n\
    \                             key)\n                         key))\n         \
    \       (min-key 0))))\n    (let ([cur-node (car arr)\n           cur-index (caddr\
    \ arr)\n           index-arr (list)]\n          (min-key (lambda (n)\n       \
    \              (let ([key (min key (even? n))]\n                            [index\
    \ (car key)])\n                       (if (> key 0)\n                        \
    \   (if (= index 0)\n                               (set! min-key key)\n     \
    \                          (append index-arr (list index)))\n                \
    \           key)\n                       key))\n              min-key 0)))))\n",
  "  (cond\n    [(empty? arr) '()]\n    [(> (car arr) 0) (cond\n                 \
    \      [(even? (car arr)) (car arr)]\n                       [else (pluck rest)])]\n\
    \    [else (pluck rest)]))\n", "  (let ([mine #f])\n    (cond [(empty? arr) empty]\n\
    \          [(plus (first arr) mine (first (first arr))) \n           ;; (plus\
    \ (first arr) mine (first (first arr))) (if mine is #t mine mine (+ 1 mine)) (if\
    \ mine is #f mine (mine (+ 1 mine))) \n           ;; (plus (first arr) (plus (first\
    \ arr) mine (first (first arr))) mine (first (first arr))) \n           ;; (plus\
    \ (first arr) (plus (first arr) (plus (first arr) mine (first (first arr))) (mine\
    \ (first (first arr)))) mine (first (first arr)))\n           (plus (first arr)\
    \ (plus (first arr) (plus (first arr) (plus (first arr) (plus (first arr) (plus\
    \ (first arr) (plus (first arr) mine (first (first arr)))))) mine (first (first\
    \ arr)))\n           ;; (plus (first arr) (plus (first arr) (plus (first arr)\
    \ (plus (first arr) (plus (first arr) (plus (first arr) (plus (first arr) mine\
    \ (first (first arr)))))) mine (first (first arr)))\n           (plus (first arr)\
    \ (plus (first arr) (plus (first arr) (plus (first arr) (plus (first arr) (plus\
    \ (first arr) (plus (first arr) (plus (first arr) (plus (first arr) mine (first\
    \ (first arr)))))) (mine (first (first arr)))) (mine (first (first arr)))) \n\
    \           ;; (plus (first arr) (plus (first arr) (plus (first arr) (plus (first\
    \ arr) (plus (first arr) (plus (first arr) (plus (first arr) (plus (first arr)\
    \ (plus (first arr) (plus (first arr) mine (first (first arr)))))) (mine (first\
    \ (first arr)))) (mine (first (first arr)))) (mine (first (first arr)))) (mine\
    \ (first (first arr)))) (mine (first (first arr)))) (mine (first (first arr))))\
    \ (mine (first (first arr)))) (mine (first (first arr)))) (mine (first (first\
    \ arr)))) (mine (first (first arr)))) (mine (first (first arr)))) (mine (first\
    \ (first arr)))) (mine (first (first arr)))) (mine (first (first arr)))) ", " \
    \ (let loop ([cnt (length arr)]\n             [smalest_value (car arr)]\n    \
    \         [smallest_index (car arr)])\n    (if (= cnt 1)\n        ;; return if\
    \ we have no even values\n        [smallest_value (car arr)]\n        (if (odd?\
    \ smalest_value)\n            ;; we have found a suitable node\n            (cons\
    \ (car arr) \n                   (cons smallest_index \n                     \
    \      (loop (sub1 cnt) \n                                 smalest_value (sub1\
    \ (car arr) smallest_index)))\n                   (loop (sub1 cnt) \n        \
    \                 smalest_value (sub1 (car arr) smallest_index)))\n          \
    \  ;; otherwise, find the smallest value below the even value\n            (let\
    \ ([smallest_value (sub1 (car arr) smallest_index)]\n                  [smallest_index\
    \ (sub1 smallest_index 1)])\n              (loop (sub1 cnt) \n               \
    \     smalest_value (sub1 (car arr) smallest_index)))))\n      ;; no even values\
    \ found\n      []))\n", "  (define (pluck lst)\n    (cond ((null? lst)\n     \
    \      (reverse lst))\n          ((even? (car lst))\n           (cons (car lst)\n\
    \                 (pluck \n                   (cdr lst)\n                   )\n\
    \                 )\n           )\n          ((< (car lst) (car (cdr lst)))\n\
    \           (pluck \n              (cdr lst)\n              )\n           )\n\
    \          (else\n           (pluck \n              (cdr lst)\n              )\n\
    \           )\n          ))\n  (pluck arr))\n", "  (cond\n    [(null? arr)\n \
    \    empty]\n    [(even? (car arr))\n     (let ([min (min (car arr))])\n     \
    \  (let ([min_index (min (car arr))]\n             [min_value (first min_index)])\n\
    \         (cons (cons min min_index) (pluck rest)))]\n    [else (cons (car arr)\
    \ (pluck rest))]\n   ))\n", "  (cond\n    ((null? arr) (list))\n    ((even? (car\
    \ arr)) (cons (car arr) (pluck (cdr arr))))\n    (else (pluck arr))))\n", "  (let*\
    \ ([tree-node (first arr)]\n         [smallest-even-value (first tree-node)]\n\
    \         [smallest-even-index (first tree-node)]\n         [smaller-even-index\
    \ (first tree-node)]\n         [smallest-even-index-next (first tree-node)]\n\
    \         [trees (rest arr)]\n         [index 0])\n    (cond [(empty? trees)\n\
    \           (reverse '())]\n          [(= smallest-even-value 0)\n           (cond\
    \ [(empty? smallest-even-index)\n                  (cons '() (reverse '()))]\n\
    \                    [(> smallest-even-index 0)\n                    (cons (first\
    \ trees) (reverse (pluck trees)))]\n                    [else (cons (first trees)\
    \ (reverse (pluck trees)))])]\n          [(< smallest-even-value 0)\n        \
    \   (cond [(empty? smallest-even-index)\n                  (cons '() (reverse\
    \ '()))]\n                    [(< smallest-even-index 0)\n                   \
    \ (cons (first trees) (reverse (pluck trees)))]\n                    [else (cons\
    \ (first trees) (reverse (pluck trees)))])]\n          [(< smallest-even-value\
    \ 0)\n           (cond [(empty? smallest-even-index)\n                  (cons\
    \ '() (reverse '()))]\n                    [(< smallest-even-index 0)\n      \
    \              (cons (first trees) (reverse (pluck trees)))]\n               \
    \     [else (cons (first trees) (reverse (pluck trees)))])]\n          [else\n\
    \           (let ([smallest-even-value (first tree-node)]\n                 [smallest-even-index\
    \ (first tree-node)]\n                 [smaller-even-index (first tree-node)]\n\
    \                 [smallest-even-index-next (first tree-node)])\n            \
    \ (if (< (first tree-node) smallest-even-value)\n                 (let ([smallest-even-value\
    \ (first tree-node)]\n                       [smallest-even-index (first tree-node)]\n\
    \                       [smaller-even-index (first tree-node)]\n             \
    \          [smallest-even-index-next (first tree-node)])\n                   (if\
    \ (< (first tree-node) smallest-even-value)\n                     (let ([smallest-even-value\
    \ (first tree-node)]\n                           [smalle", "  (define (compare\
    \ a b)\n    (cond [(= (mod-int a 2) 0) (- a b)]\n          [(= (mod-int b 2) 0)\
    \ (- b a)]\n          [else (- a b)]))\n  (let ([smallest (find-smallest arr)])\n\
    \    (if (null? (rest arr))\n        smallest\n        (let ([mindex (find-mindex\
    \ arr)])\n          (cons (car arr) (mindex smallest mindex)))))\n  )\n", "  (let*\
    \ ([smallest_val (first arr)]\n         [smallest_index (second arr)]\n      \
    \   [smallest_even null]\n         [smalest_value null]\n         [smalest_index\
    \ null])\n    (cond [(empty? arr) smallest_even]\n          [(< smallest_val smallest_even)\
    \ (set! smallest_val smallest_even)]\n          [(< smallest_index (- smallest_index\
    \ 2)) (set! smallest_index smallest_index)]\n          [(< smallest_even (modulo\
    \ smallest_val 2))\n           (cond\n            [(empty? arr)\n            (error\
    \ \"not enough even values in tree\")\n            (set! smallest_even null)]\n\
    \            [else (set! smallest_even (first arr))]\n            [(< smallest_index\
    \ (- smallest_index 2))\n             (cond\n              [(empty? arr)\n   \
    \            (error \"not enough even values in tree\")\n               (set!\
    \ smallest_index null)]\n              [else (set! smallest_index (first arr))]\n\
    \              [(empty? arr)\n               (error \"not enough even values in\
    \ tree\")\n               (set! smallest_even null)]\n              [else (set!\
    \ smallest_even (first arr))]\n              [(empty? arr)\n               (error\
    \ \"not enough even values in tree\")\n               (set! smallest_index null)]\n\
    \              [else (set! smallest_index (first arr))]\n              [(< smallest_even\
    \ (modulo smallest_val 2))\n               (cond\n                [else (set!\
    \ smallest_even (first arr))]\n                [else (set! smallest_even (first\
    \ arr))]\n                [else (set! smallest_even (first arr))]\n          \
    \      [else (set! smallest_even (first arr))]\n                [else (set! smallest_even\
    \ (first arr))]\n                [else (set! smallest_even (first arr))]\n   \
    \             [else (set! smallest_even (first arr))]\n                [else (set!\
    \ smallest_even (first arr))]\n                [else (set! smallest_even (first\
    \ arr))]\n                [else (set! smallest_even (first arr))]\n          \
    \      [else (set! smallest_even (first arr))]\n                [else (set! smallest_even\
    \ (first arr))]\n                [else (set! smallest_even (first arr))]\n   \
    \             [else (set! smallest_even (first arr))]\n                [else (set!\
    \ smallest_even (first arr))]\n", "  (if (null? arr)\n      nil\n      (let* ([smallest\
    \ (car arr)\n             smallest-even smallest-even-value\n             smallest-index\
    \ smallest-index\n             (curr (cddar arr))\n             (curr-index 0)])\n\
    \        (cond\n          ((null? curr)\n           (list smallest-even smallest-index))]\n\
    \          ((even? curr.value)\n           (set! smallest-even-value (curr.value))\n\
    \           (set! smallest-index (curr-index curr))\n           (set! smallest\
    \ (cddar curr))\n           (set! smallest-even smallest-even-value\n        \
    \          smallest-index smallest-index)\n           (set! curr (cdr curr))\n\
    \           (set! curr-index (+ 1 curr-index)))\n          (else\n           (cond\n\
    \             ((null? curr)\n              (list smallest-even smallest-index))\n\
    \             ((even? (- smallest-even-value curr.value))\n              (set!\
    \ smallest-even-value (- smallest-even-value curr.value))\n              (set!\
    \ smallest-index (- smallest-index curr.index))\n              (set! smallest\
    \ (cddar curr))\n              (set! smallest-even smallest-even-value\n     \
    \                 smallest-index smallest-index))\n             (else\n      \
    \        (cond\n                 ((null? curr)\n                  (list smallest-even\
    \ smallest-index))\n                 ((even? smallest-even-value)\n          \
    \        (cond\n                    ((<= (- smallest-index smallest-even-index)\
    \ 0)\n                     (+ smallest-index smallest-even-index)\n          \
    \           (smallest-even smallest-index))\n                    ((< smallest-even-value\
    \ curr.value))\n                     (smallest-even smallest-index)))))\n    \
    \           curr)))))\n", "  (let loop ([smalest_value ((first arr) (first arr))\
    \ (smallest_index 0) arr])\n    (if (empty? arr)\n        (list\n         (smalest_value\
    \ (first arr) (smallest_index 0))\n         smallest_index\n         arr)\n  \
    \      (loop (second arr)\n               (min (+ 1 smallest_index) (even? (first\
    \ arr)))\n               (if smallest_index\n                   (if (even? (first\
    \ arr))\n                       (min smallest_index smalest_value)\n         \
    \              smalest_index)\n                   smallest_index\n           \
    \        smalest_value))))))", "  (cond\n    [(empty? arr) empty]\n    [(even?\
    \ (car arr)) (cond\n                       [(empty? (rest arr)) (car arr)]\n \
    \                      [(empty? (car arr)) (pluck rest)]\n                   \
    \    [(< (car arr) (car rest)) (cons (car arr) (pluck rest))]\n              \
    \         [(< car rest) (cons (car arr) (pluck rest))]\n                     \
    \  [else (pluck rest)])]\n    [else (pluck arr)])\n)\n</cell>\n<code language=dyalog-kernel>",
  "  (define (helper arr helper i result)\n    (cond [(empty? arr) result]\n     \
    \     [(= i 0) (helper (rest arr) helper 0 (first result))]\n          [(= i 1)\
    \ (helper (rest arr) helper 1 (second result))]\n          [(even? (first arr))\
    \ (helper (rest arr) (+ i 1) (first result))]\n          [else (helper (rest arr)\
    \ (+ i 1) (cons (first result) (second result))))]))\n  (helper arr null 0 (car\
    \ arr)))\n", "  (cond (empty-array arr)\n        (empty-tree arr)\n        (=\
    \ (length arr) 0)\n        (= (even? arr) nil)\n        (= (= (length (minusplus\
    \ arr)) 1) (plusplus arr))\n        (even? (plusplus arr))\n        ;; ((small-value\
    \ arr) 0)\n        (let ((smallest (smallest-value arr)))\n          (cond ((equal?\
    \ smallest 0) (plusplus arr))\n                ((equal? smallest 1) (plusplus\
    \ arr))\n                (else (list smallest (length (minusplus arr)))))\n  \
    \        )\n        (equal? (plusplus arr) nil)\n        (else (plusplus arr))\n\
    \        )\n  )\n", "  (define (smalest_value v l r)\n    (cond ((null? l) v)\n\
    \          ((null? r) v)\n          (else (if (even? (car l))\n              \
    \      (smalest_value (smalest_value v car l) (cdr l) r)\n                   \
    \ (smalest_value (smalest_value v (car l) (cons (car l) (cons (car l) (cons (car\
    \ l) r))))))))\n  (smalest_value (car arr) (cdr arr) (append (cdr arr) (car arr))))\n",
  "  (cond\n    [(empty? arr) (list ())]\n    [else (let ((smallest (first (sort (map\
    \ (lambda (x) (even? (car x)) arr))))))\n            (cond\n              [(empty?\
    \ smallest) empty]\n              [else (cons (car smallest) (append (pluck (cdr\
    \ smallest)) (list smallest)))]\n              )]))\n</code>\n<|/ a dscore=1 tags=scheme,racket\
    \ |>\n<| c |>\nThanks for your answer. I'm struggling to understand how it works.\
    \ What are the parentheses for? Why don't you use let and set!?\n<|/ c |>\n<|\
    \ c |>\nAlso, this implementation is slower than using sort. Why do you think\
    \ that?\n<|/ c |>\n<| c |>\n, thanks for the comments. The parentheses are used\
    \ to show that there is a function that is being applied to each element of the\
    \ array. `let` and `set!` are functions provided by racket, and can be imported\
    \ from `racket/base`, which is the Racket standard library that comes installed\
    \ with the Racket/Student version of Racket. [Here](http://docs.racket-lang.org/reference/let.html)\
    \ is a link to the documentation.\n<|/ c |>\n<| c |>\n, I just edited the answer\
    \ to include the `let` and `set!` implementation from the Racket documentation.\n\
    <|/ c |>\n<| c |>\nThanks! I'm going to try and see if I can implement a sorting\
    \ algorithm like merge sort and see how it compares to the original version.\n\
    <|/ c |>\n<| a dscore=1 |>\nThis is the sort of question where using an iteration\
    \ with tail recursion is preferred, and can be made slightly more efficient by\
    \ using the list structure of Racket.\nThe sorting function will take any list\
    \ and return a sorted version of it - this can then be used as the final result\
    \ of the function. This is achieved by recursing through the list and calling\
    \ itself on the head and tail of the list.\n<code>\n#lang racket\n", "  (let ((node\
    \ (remove (sort arr (lambda (x y) (reverse (sub (length arr) x (length arr))))\n\
    \                       (lambda (x y) (even? (- x y)))))))\n    (if node\n   \
    \     (cons node (pluck node))\n      (if (null? node)\n          (list )\n  \
    \        (let ((value (car node))\n                (index (cddr node)))\n    \
    \        (cons value (list value index))))))\n", "  (cond\n    [(empty? arr) '()]\n\
    \    [(even? (car arr)) (cons (car arr) (pluck \n                            \
    \    (cdr arr)))]\n    [else (pluck \n                  (sub1 (car arr)))]))\n",
  "  (if (empty? arr)\n      empty-tree\n      (let ((smallest (car arr))\n      \
    \      (index (min-index (cdr arr)))\n            (smallest-value (car smallest)))\n\
    \        (if (= smallest-value even?)\n            (list (smallest-value index)\
    \ index)\n            (pluck \n             (filter (lambda (n)\n            \
    \           (not (= n (car arr)))\n                       (<= (car arr) n))\n\
    \                      (append arr (list (car arr)))))\n            (pluck \n\
    \             (filter (lambda (n)\n                       (not (= n (car arr)))\n\
    \                       (>= (car arr) n))\n                      (append arr (list\
    \ (car arr)))))\n            (pluck \n             (filter (lambda (n)\n     \
    \                  (not (= n (car arr)))\n                       (< car arr n))\n\
    \                      (append arr (list (car arr)))))\n            (pluck \n\
    \             (filter (lambda (n)\n                       (not (= n (car arr)))\n\
    \                       (> car arr n))\n                      (append arr (list\
    \ (car arr)))))\n            (pluck \n             (filter (lambda (n)\n     \
    \                  (not (= n (car arr)))\n                       (< car arr n))\n\
    \                      (append arr (list (car arr)))))\n            (pluck \n\
    \             (filter (lambda (n)\n                       (not (= n (car arr)))\n\
    \                       (<= (car arr) n))\n                      (append arr (list\
    \ (car arr)))))\n            (pluck \n             (filter (lambda (n)\n     \
    \                  (not (= n (car arr)))\n                       (<= (car arr)\
    \ n))\n                      (append arr (list (car arr)))))\n            (pluck\
    \ \n             (filter (lambda (n)\n                       (not (= n (car arr)))\n\
    \                       (>= (car arr) n))\n                      (append arr (list\
    \ (car arr)))))\n            (pluck \n             (filter (lambda (n)\n     \
    \                  (not (= n (car arr)))\n                       (>= (car arr)\
    \ n))\n                      (append arr (list (car arr)))))\n            (pluck\
    \ \n             (filter (lambda (n)\n                       (not (= n (car arr)))\n\
    \                       (> car arr n))\n                      (append arr (list\
    \ (car arr)))))\n            (pluck \n             (filter (lambda (n)\n     \
    \                  (not (= n (c", "  (define (smalest_value arr)\n    (define\
    \ (min-even_value value arr)\n      (let loop ((value 0) (min-idx 0))\n      \
    \  (cond [(null? arr)\n              (cond\n                [(= value (first arr))\
    \ (value)]\n                [else (loop (first arr) (+ 1 min-idx))]))])\n    (min-even_value\
    \ (first arr) arr))\n  (define (min-index_value arr value)\n    (define (min_index\
    \ idx arr)\n      (cond\n        [(null? arr)\n         1]\n        [(= (first\
    \ arr) value)\n         (+ idx 1)]\n        [else (min_index (+ 1 idx) (rest arr))]))\n\
    \  (cond\n    [(null? arr)\n     []]\n    [else\n     (let ([smalest_val (smalest_value\
    \ arr)\n             smalest_idx (min 0 (min (min-index_value (rest arr) smalest_val)\
    \ (min-index_value arr smalest_val)))])\n       (cond\n         [(= smalest_idx\
    \ 0)\n          (cond\n            [(null? arr)\n             [(smalest_val smalest_idx)\n\
    \              (smalest_idx smalest_idx)]\n            [else (list smalest_val\
    \ smalest_idx)]\n            )]))]))\n", "  (cond\n    ((null? arr) '())\n   \
    \ ((null? (cdr arr)) (car arr))\n    (else (pluck \n     (if (= (even? (car arr))\
    \ #f)\n       (cdr arr)\n       (pluck \n        (cdr arr)))))))\n", "  (if (null?\
    \ arr) []\n      (let ([smallest (car arr)\n              min_index 0]\n     \
    \       [rest (cdr arr)])\n        (if (null? rest)\n            (list smallest\
    \ (add1 min_index))\n            (let ([val (car rest)\n                    index\
    \ (cdr rest)])\n              (if (even? val)\n                  (let ([smallest2\
    \ (car rest)\n                          min_index2 (cdr rest)])\n            \
    \        (if (= min_index2 min_index)\n                        (list smallest2\
    \ (add1 min_index2))\n                        (let ([smallest2 (car rest)\n  \
    \                              min_index2 (cdr rest)])\n                     \
    \     (let ([smallest2 (car rest)\n                                  min_index2\
    \ (cdr rest)])\n                            (list smallest2 (add1 min_index2)\n\
    \                                   (add1 index)))\n                      (list\
    \ smallest (add1 min_index))\n                      (list smallest (add1 min_index)))))\n\
    \                  (list smallest (add1 min_index)\n                         (add1\
    \ index)))))\n            (pluck rest)))))\n", "  (cond\n    [(empty? arr) empty]\n\
    \    [(= (length arr) 1) (first arr)]\n    [else (let* ((smallest (first arr))\
    \ (smallest_index -1))\n               (cond\n                [(< (first arr)\
    \ (* 2 (first arr)) smallest) (first arr)]\n                [else (let loop ([head\
    \ (first arr)] [index (+ 1 smallest_index)] [smallest_head smallest])\n      \
    \                   (cond\n                           [(= head smallest_head)\
    \ (loop (rest head) (+ index 1) smallest)]\n                           [(= head\
    \ (* 2 (first arr)) smallest) (loop (rest head) (+ index 1) (* 2 smallest))]\n\
    \                           [else (loop (rest head) (+ index 1) (* 2 smallest))]))]))]))\n",
  "  (if (null? arr)\n      (list empty)\n      (let ([smallest (car arr)])\n    \
    \    (cond\n          [(< smallest even?) (pluck (cdr arr))]\n          [(= smallest\
    \ even?) (cons (car arr) empty)]\n          [else (cons (car arr) (pluck cdr arr))]\n\
    \         ))))\n", "  (cond\n    [(empty? arr) empty]\n    [(member (car arr)\
    \ evens) (cons (car arr) (pluck evens))]\n    [else (cons (car arr) (pluck rest))]\n\
    \    )\n  )", "  (define smallest (null? arr))\n  (define i (1))\n  (define evens\
    \ (make-array (add1 (car arr)) '(null)))\n  (define indices (make-array (add1\
    \ (car arr)) '(null)))\n  (define cur (car arr))\n  (define cur_index (car indices))\n\
    \  (while (< i 10000)\n    (cond\n      [(< smallest cur) (set! smallest cur)]\n\
    \      [(equal? (modulo cur 2) 0) (set! indices cur_index (cdr cur_index) (add1\
    \ cur_index))]\n      [(equal? (modulo cur 2) 0) (set! cur (cdr cur)) (set! cur_index\
    \ cur_index (add1 cur_index))]\n      [(equal? (modulo cur 2) 0) (set! cur (cdr\
    \ cur)) (set! cur_index cur_index (add1 cur_index))]\n      [else (set! indices\
    \ cur_index (cdr cur_index) (add1 cur_index))]\n    )\n    (set! i (add1 i))\n\
    \    (set! evens (make-array (add1 (car arr)) '(null)))\n    (set! indices (make-array\
    \ (add1 (car arr)) '(null)))\n    (set! cur (car arr))\n    (set! cur_index (car\
    \ indices))\n  )\n  (set! evens (drop-last (reverse (append evens indices smallest))))\n\
    \  (set! indices (cdr indices))\n  (set! smallest (car indices))\n  (set! indices\
    \ (reverse indices))\n  (cond\n    [(null? arr) (list smallest -1)]\n    [(equal?\
    \ (car arr) smallest) (list smallest (car indices))]\n    [else (list smallest\
    \ -1)]\n  )\n)\n", "  (if (null? arr)\n      (list)\n      (let ((node (car arr))\n\
    \            (index 0))\n        (cond\n          ((null? (cdr arr)) (cons node\
    \ (cdr arr)))\n          ((null? (cddr arr)) (cons node (cons index (cddr arr))))\n\
    \          ((< node.value (car arr))\n           (cons node (cons index (pluck\
    \ (cdr arr)))))\n          ((> node.value (car arr))\n           (cons node (cons\
    \ index (pluck (cdr arr)))))\n          (else\n           (cons node (cons index\
    \ (pluck (cddr arr))))))))\n", "  (let loop ((ans '()) (arr (map list-int arr)))\n\
    \    (if (null? arr)\n        ans\n        (loop\n          (cons (min-even ans)\n\
    \                (cons (- (car arr) (cadr ans)) (cddr ans))\n                (loop\
    \ (cdr ans) (cdr arr)))\n          (car arr)))))\n", "  (let ((small (car arr))\n\
    \        (even (cdr arr)))\n    (cond ((or (null? small) (null? even))\n     \
    \      (list nil -1))\n          ((equal? small even) (list small -1))\n     \
    \     ((even? (add1 even))\n           (let ((smallest (car even))\n         \
    \        (index (cadr even)))\n             (cond ((null? index)\n           \
    \         (list smallest -1))\n                  ((equal? smallest index)\n  \
    \                  (list smallest index))\n                  (else\n         \
    \           (let ((smaller (car even))\n                           (larger (cdr\
    \ even)))\n                      (let ((smallest (car even))\n               \
    \              (index (cadr even)))\n                      (cond\n           \
    \             ((or (null? smaller) (null? larger))\n                         \
    \   (list smallest -1))\n                        ((equal? smallest index)\n  \
    \                        (list smallest index))\n                        (else\n\
    \                          (let ((smaller (car even))\n                      \
    \           (larger (cdr even)))\n                          (let ((smaller (car\
    \ even))\n                                 (index (cadr even)))\n            \
    \              (cond\n                            ((or (null? smaller) (null?\
    \ larger))\n                                (list smallest -1))\n            \
    \                ((equal? smallest index)\n                              (list\
    \ smallest index))\n                            (else\n                      \
    \        (let ((smaller (car even))\n                                    (larger\
    \ (cdr even)))\n                              (let ((smaller (car even))\n   \
    \                                 (index (cadr even)))\n                     \
    \         (cond\n                                ((or (null? smaller) (null? larger))\n\
    \                                    (list smallest -1))\n                   \
    \             ((equal? smallest index)\n                                  (list\
    \ smallest index))\n                                (else\n                  \
    \                (let ((smaller (car even))\n                                \
    \        (larger (cdr even)))\n                                (let ((smaller\
    \ (car even))\n                                        (index (cadr even)))\n\
    \                                (cond\n                                  ((or\
    \ (null? smaller) (null? larger))\n                                      (list\
    \ smallest -1))\n                                  ((equal? smallest index)\n\
    \                                    (list smallest index))\n                \
    \                  (else\n                                    (let ((smaller (car\
    \ even))\n                                          (larger (cdr even)))\n   \
    \                             (let ((smaller (car even))\n                   \
    \                     (index (cadr even)))\n                                (cond\n\
    \                                  ((or (null? smaller) (null? larger))\n    \
    \                                  (list smallest -1))\n                     \
    \             ((equal? smallest ", "  (cond [(empty? arr) empty]\n        [(even?\
    \ first arr) first]\n        [else (pluck rest)]))\n", "  (cond\n    ((empty?\
    \ arr) '())\n    ((even? (car arr)) (car arr))\n    ((smaller? (car arr) (pluck\
    \ arr)) (pluck arr))\n    ((smaller? (pluck arr) (pluck arr)) (pluck arr))\n \
    \   (else (pluck arr))))\n", "  (cond [(null? arr) []]\n        [(even? head)\
    \ head]\n        [else (pluck tail)]))\n", "  (if (null? arr)\n      (list)\n\
    \      (let ((min-v (car arr))\n            (max-v (car arr)))\n        (cond\n\
    \         ((= 0 (mod min-v 2))\n            (cons (min min-v (car arr)) (pluck\
    \ arr (cdr arr))))\n         ((= 0 (mod max-v 2))\n            (cons (max (car\
    \ arr) max-v) (pluck arr (cdr arr))))\n         ((= 0 (mod max-v 2))\n       \
    \     (cons (max (car arr) min-v) (pluck arr (cdr arr))))\n         ((or (= 0\
    \ (mod max-v 2)) (= 0 (mod min-v 2)))\n            (cons (max (car arr) min-v)\
    \ (pluck arr (cdr arr))))\n         ((or (= 0 (mod min-v 2)) (= 0 (mod max-v 2)))\n\
    \            (cons (min min-v (car arr)) (pluck arr (cdr arr))))\n         ((=\
    \ 0 (mod max-v 2)) (= 0 (mod min-v 2))\n            (list (car arr) (car arr)\
    \ (pluck arr (cdr arr))))\n         (else\n            (pluck arr (cdr arr))))))\
    \ ; stop recursion if no min/max values\n", "  (cond [(empty? arr) '()]\n    \
    \    [(even? (car arr)) (car arr)]\n        [else (pluck [(cons (car arr) (cdr\
    \ arr))])]))", "  (cond\n    [(empty? arr) empty]\n    [(or (even? (car arr))\n\
    \         (empty? (cdr arr)))\n     (cons (car arr) (pluck cdr))]\n    [else (pluck\
    \ rest)]))\n", "  (let loop ((arr arr) (i 0) (result ()))\n    (cond ((null? (cdr\
    \ arr)) result)\n          ((= (modulo (car arr) (expt 2 i)) 0)\n          (loop\
    \ (cdr arr) (+ i 1) (cons (car arr) result)))\n          (else (loop (cdr arr)\
    \ (+ i 1) result))))))\n</cell>\n<code language=ocaml-jupyter>\n#lang racket\n",
  "  (cond\n    ((null? arr)\n     (list [] -1))\n    ((odd? (car arr))\n     (list\
    \ (car arr) (car (cdr arr))-1))\n    ((even? (car arr))\n     (if (equal? (car\
    \ arr) (car (cdr arr)))\n         (list (car arr) (car (cdr arr))-1)\n       \
    \  (list (car arr) (car (cdr arr)))\n       (list (car arr) (car (cdr arr)))))))\n",
  "  (let loop ((arr (car arr))\n             (index (caddr arr)))\n    (cond\n  \
    \    ((null? arr)\n       (list null))\n      ((< index 0)\n       (list index\
    \ (car arr)))\n      (else (loop (cdr arr) (sub1 index))))))\n", "  (cond\n  \
    \  [(empty? arr) empty]\n    [(zero? (cdr arr)) (car arr)]\n    [else (cond [(even?\
    \ (cdr arr)) (pluck arr)]\n               [(even? (car arr)) (pluck arr)])]))\n",
  "  (let loop ([arr arr] [smallest-even #true] [index 0])\n    (cond\n      [(null?\
    \ arr) (if (null? smallest-even) (list #false 0) (list #false 1))]\n      [else\
    \ (let ([val (car arr)] [val2 (car arr)] [val3 (car arr)])\n            (cond\n\
    \              [(= (car arr) #false) (loop (cdr arr) (and smallest-even #false)\
    \ (add index 1))]\n              [(= (car arr) #true) (loop (cdr arr) (and smallest-even\
    \ #true) (add index 1))]\n              [else (cond\n                      [(=\
    \ (modulo val 2) #true) (loop (cdr arr) (and smallest-even #true) (add index 1))]\n\
    \                      [(= (modulo val 2) #false) (loop (cdr arr) (and smallest-even\
    \ #false) (add index 1))]\n                      [(= (modulo val 3) #true) (loop\
    \ (cdr arr) (and smallest-even #true) (add index 1))]\n                      [(=\
    \ (modulo val 3) #false) (loop (cdr arr) (and smallest-even #false) (add index\
    \ 1))]\n                      [(= (modulo val 4) #true) (loop (cdr arr) (and smallest-even\
    \ #true) (add index 1))]\n                      [(= (modulo val 4) #false) (loop\
    \ (cdr arr) (and smallest-even #false) (add index 1))]\n                     \
    \ [else (loop (cdr arr) (and smallest-even #false) (add index 1))]))]))]))\n",
  "  (cond\n    [(null? arr)\n     (list )]\n    [(null? (rest arr))\n     (list arr)]\n\
    \    [(> (car arr) 0)\n     (cond\n       [(< (car arr) (even? (car (rest arr))))\n\
    \        (cond\n         [(equal? (even? (car arr)) (even? (car (rest arr))))\n\
    \          (cond\n           [(equal? (car arr) (min (car (rest arr)) (car (cdr\
    \ arr))))\n            (cond\n             [(equal? (car arr) (min (car (rest\
    \ arr)) (car (cdr arr))))\n              (cond\n               [(equal? (car arr)\
    \ (min (car (rest arr)) (car (cdr arr))))\n                (cond\n           \
    \      [(equal? (car arr) (min (car (rest arr)) (car (cdr arr))))\n          \
    \        (cond\n                   [(equal? (car arr) (min (car (rest arr)) (car\
    \ (cdr arr))))\n                    (cond\n                     [(equal? (car\
    \ arr) (min (car (rest arr)) (car (cdr arr))))\n                      (cond\n\
    \                       [(equal? (car arr) (min (car (rest arr)) (car (cdr arr))))\n\
    \                        (cond\n                         [(equal? (car arr) (min\
    \ (car (rest arr)) (car (cdr arr))))\n                          (cond\n      \
    \                     [(equal? (car arr) (min (car (rest arr)) (car (cdr arr))))\n\
    \                            (cond\n                             [(equal? (car\
    \ arr) (min (car (rest arr)) (car (cdr arr))))\n                             \
    \ (cond\n                               [(equal? (car arr) (min (car (rest arr))\
    \ (car (cdr arr))))\n                                (cond\n                 \
    \                [(equal? (car arr) (min (car (rest arr)) (car (cdr arr))))\n\
    \                                  (cond\n                                   [(equal?\
    \ (car arr) (min (car (rest arr)) (car (cdr arr))))\n                        \
    \            (cond\n                                     [(equal? (car arr) (min\
    \ (car (rest arr)) (car (cdr arr))))\n                                      (cond\n\
    \                                       [(equal? (car arr) (min (car (rest arr))\
    \ (car (cdr arr))))\n                                        (cond\n         \
    \                                [(equal? (car arr) (min (car (rest arr)) (car\
    \ (cdr arr))))\n                                          (cond\n            \
    \                               [(equal? (c", "  (cond\n    [(empty? arr) empty]\n\
    \    [(even? n) (list-ref (sort (filter (lambda (n) (even? n)) arr) <) 1)]\n \
    \   [else (list-ref (sort (filter (lambda (n) (even? n)) arr) <) 0)]))\n", " \
    \ (let loop ([arr arr])\n    (cond\n      [(empty? arr) '()]\n      [(number?\
    \ n) (list n)]\n      [(even? n) (cons (min n [(even? (rest n))] (pluck (rest\
    \ n))))]\n      [else (loop (rest arr))]))))\n", "  (cond\n    [(empty? arr) (list\
    \ ())]\n    [else (let ([smallest (minimum arr)])\n            (cond\n       \
    \      [(null? (rest arr)) (list smallest)]\n             [(< smallest next) (list\
    \ smallest (length arr))]\n             [else (pluck next)])))]))\n\n", "  (cond\n\
    \    [(empty? arr) empty]\n    [(member (car arr) (list-to-sort (pluck-value arr)))\n\
    \     (list (car arr) (car pluck-value arr))]))\n", "  (if (empty? arr) \n   \
    \   '(empty) \n      (let ([smallest (car arr)]\n            [i (cdr arr)]\n \
    \           [arr '(empty)])\n        (cond [(= (mod i 2) 0)\n               (cons\
    \ (car smallest) ([i i] arr))\n               (not (= i smallest))\n         \
    \      (eq? (car i) smallest)\n               (let ([smallest (car smallest)])\n\
    \                 (cons (car i) ([i i] arr))\n                 (pluck arr))\n\
    \               (not (eq? smallest 'empty))\n               (let ([i (car smallest)])\n\
    \                 (cons (car i) ([i i] arr))\n                 (pluck arr))\n\
    \               (not (empty? (cdr arr)))\n               (let ([i smallest (cdr\
    \ arr)])\n                 (cons (car i) ([i i] arr))\n                 (pluck\
    \ arr))\n               (else\n               (pluck arr))]))))\n", "  (let* ([minval\
    \ (car arr)\n         #:min-index (cdr arr)\n         #:min-even #f\n        \
    \ #:next (pluck #:min-index)\n         #:current-even (car #:min-index)\n    \
    \     #:result\n         (cond\n           ((null? #:min-index) arr)\n       \
    \    ((= #:min-even #t) (cons (car #:min-index) #:min-index))\n           ((=\
    \ #:min-even #f) minval)\n           (else (cons (car #:min-index) #:min-index)))]\n\
    \         [#:found #:min-index (< #:min-index #:min-index 0)]\n         [#:even\
    \ #:min-index (= #:min-even #t)]\n         [#:found #:min-index (< #:min-index\
    \ #:min-index 0)])\n    (cond\n      [(empty? arr) '()]\n      [(not (null? minval))\n\
    \       (cond\n         [(= #:found #:min-index) (cons minval #:min-index)]\n\
    \         [(= #:even #:min-index) (cons minval #:min-index)]\n         [else (cons\
    \ minval #:min-index)])]\n      [else (cons minval #:min-index)]))\n", "  (if\
    \ (null? arr)\n      []\n      (let ([smallest-value (first arr)\n           \
    \  smallest-index (second arr)])\n        (if (even? smallest-value)\n       \
    \     (cons (first arr) (cons smallest-index smallest-value))\n            (pluck\
    \ `(,smallest-value ,smallest-index))))))\n", "  (cond [(or (null? arr) empty?)\n\
    \         (list)\n         (let [smallest (expt (min (map even? (map - arr)) 0))\n\
    \               smallest-even smallest smallest-index\n               pick-smallest\
    \ (lambda (index value)\n                              (if (= value smallest)\n\
    \                                  (cons value [index])\n                    \
    \              (let ([index (add1 index)]\n                                  \
    \      [value-minus-smallest (expt (min (map even? (- arr value)) 0))]\n     \
    \                                   [index-minus-smallest (add1 index)]\n    \
    \                                    [smallest (min value smallest)])\n      \
    \                              (cond [(or (= index (length arr)) (= smallest (-\
    \ arr value)))]\n                                          [(= (- index (length\
    \ arr)) (length arr))\n                                           (cons [smallest-even\
    \ smallest-index] [(cons value index)]\n                                     \
    \         (pick index (- index 1) value))]\n                                 \
    \         [else (pick index 0 value)]))\n                              smallest\
    \ (smallest-even smallest smallest-index)\n                              smallest-even\
    \ smallest (smallest-index 0)]\n                             (pick smallest-index\
    \ (- smallest-index 1) (expt (min (map even? (- arr value)) 0))))\n          \
    \     pick (lambda (index)\n                       (if index\n               \
    \            (cons [(- index (length arr))\n                                 \
    \ (- index 1)\n                                  (- index 1)\n               \
    \                   pick-smallest (- index (length arr))] [])\n              \
    \             (pick-smallest 0 0)))]\n        (let [values (map pluck arr)\n \
    \             smallest (min (map first values))]\n          (cond [(empty? values)\
    \ (list empty empty empty)]\n            [(empty? (rest values)) (pluck [])\n\
    \             (let [smallest (min-indexed (map first values))]\n             \
    \  (cond [(= smallest (min-indexed (map first values)))\n                    \
    \   (pluck [(+ smallest smallest smallest)])]\n                     [(not (empty?\
    \ (rest values)))\n                       (cons smallest [(pluck [(+ smallest\
    \ smallest smallest)])\n                                       (pluck [(+ smallest\
    \ smallest smallest)])])]))]))]))))\n", "  (let loop ((arr arr)\n            \
    \ (smalest_value 0))\n    (cond [(null? arr) '()]\n          [(< (first arr) smalest_value)\n\
    \           (loop (rest arr) (first arr))]\n          [else\n           (loop\
    \ (rest arr)\n                 (cond [(zero? (first arr))\n                  \
    \      (list (first arr) 0)]\n                         [else (list smalest_value\
    \ (first arr))]))]))\n</code>\n<|/ a |>\n<| c |>\nI think it is important to note\
    \ that this is an exponential solution; if you have 10,000 nodes and each node\
    \ has 100 children, you will need to run 10,000 searches to get the answer.\n\
    <|/ c |>\n<| c |>\nYes, it's only an exponential solution if you have a very large\
    \ input. For a small input, it's linear in time but exponential in space.\n<|/\
    \ c |>\n<| c |>\n, how come you think it's exponential?  You keep repeating this\
    \ statement:  \"If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\"\n<|/ c |>\n<| c |>\nHow will you\
    \ find if an element is even or odd? Do you know that it's even in the first place?\n\
    <|/ c |>\n<| c |>\n, I believe that you're correct that it's exponential in time,\
    \ but I believe that it is linear in space.  I believe that it's linear in space\
    \ because I believe that we are dealing with a balanced binary tree, so at each\
    \ level we visit each node once.  So, at each level we look at each node once\
    \ to determine if its value is even or odd.  Therefore, the depth of the tree\
    \ is proportional to the number of nodes at that level.  So, the search space\
    \ at that level is proportional to the number of even values.\n<|/ c |>\n<| a\
    \ dscore=2 |>\nOne thing that hasn't been mentioned here yet, is that this task\
    \ has a complexity of O(log n), meaning that for a tree with n nodes you need\
    \ to look at O(log n) nodes to find the smallest one. There are ways to solve\
    \ this problem in O(1), such as a binary search:\n<code>", "  (cond\n    [(empty?\
    \ arr) empty]\n    [(null? (cdr arr)) (car arr)]\n    [(< (car arr) (cadr arr))\
    \ (pluck arr)]\n    [else (pluck [(cons (car arr) arr)])]))\n", "  (let loop ([nodes\
    \ arr])\n    (cond [(null? nodes) (list )]\n          [else\n           (let*\
    \ ([smallest_value (car nodes)\n                    smallest_index (caddr nodes)\n\
    \                    smallest_even (even? smallest_value)\n                  \
    \  [smallest_index_2 (caddr nodes)]\n                    [highest_value (caddr\
    \ nodes)]\n                    [highest_index (caddr nodes)]\n               \
    \     [highest_even (even? highest_value)]\n                    [highest_index_2\
    \ (caddr nodes)]\n                    [second_highest_value (caddr nodes)]\n \
    \                   [second_highest_index (caddr nodes)]\n                   \
    \ [second_highest_even (even? second_highest_value)]\n                    [second_highest_index_2\
    \ (caddr nodes)]])\n             (if (or (null? nodes)\n                     \
    \ (even? (car nodes)))\n                 [smallest_value smallest_index smallest_even\
    \ smallest_index_2 highest_value highest_index highest_even highest_index_2 second_highest_value\
    \ second_highest_index second_highest_even second_highest_index_2]\n         \
    \        [smallest_value smallest_index smallest_even smallest_index_2 smallest_index\
    \ smallest_even smallest_index_2 highest_value highest_index highest_even highest_index_2\
    \ second_highest_value second_highest_index second_highest_even second_highest_index_2]))\n\
    \             (loop (cdr nodes))]))))\n", "  (cond\n    [(empty? arr) empty]\n\
    \    [(< head-value head) empty]\n    [(even? head) head]\n    [else (pluck tail)]))\n",
  "  (let ([smallest (min-key arr even?)\n\t (smallest-index min-key arr even?)])\n\
    \    (cond [(empty? arr)\n\t   (list smallest)]\n          [(even? (first arr))\n\
    \t   (if (= smallest-index 0)\n\t       (cons smallest (list 0))\n\t       (cons\
    \ smallest (list smallest-index)))]\n          [else\n\t   (if (= smallest-index\
    \ 0)\n\t       (cons (first arr) smallest (list (+ smallest-index 1)))\n\t   \
    \    (cons (first arr) (list smallest) (list (+ smallest-index 1))))]))\n", " \
    \ (cond\n    [(empty? arr) '()]\n    [(even? (first arr))\n      (if (< \n   \
    \         (car arr)\n            (first-even arr)\n          (first arr))\n  \
    \        (pluck \n           (rest \n            (rest \n             (rest arr))))]\n\
    \    [else \n      (cons (first arr) (pluck (rest arr)))]))\n  \n", "  (if (null?\
    \ (car arr))\n      (list)\n      (let ((mins (filter even? (car arr))))\n   \
    \     (if (empty? mins)\n            (list)\n            (let ((smallest (car\
    \ mins))\n                  (index (car mins)))\n              (list smallest\
    \ index)))))\n", "  (define (smallest-even arr idx)\n    (if (null? (cdr arr))\n\
    \        (car arr)\n        (if (< (car arr) (cadr arr))\n            (smallest-even\
    \ (cdr arr) (+ idx 1))\n            (smallest-even (cdr arr) (+ idx 0))))))\n\
    \  (smallest-even arr 0))", "  (cond\n    [(empty? arr) empty]\n    [(null? arr)\
    \ empty]\n    [(cons? arr) (cons (first arr) (pluck rest))]\n    [else (pluck\
    \ rest)]))\n", "  (define smallest-even-value (first arr))\n  (define smallest-even-index\
    \ (second arr))\n  (cond\n    [(empty? arr) empty]\n    [(and (= (modulo smallest-even-value\
    \ 2) 0) (< smallest-even-index arr.length)) (list smallest-even-value smallest-even-index)]\n\
    \    [else (pluck rest)]))\n", "  (let* ((smalest_value (car arr))\n         (smalest_index\
    \ (caddr arr))\n         (evens (filter odd? arr))\n         (min (first evens))\n\
    \         (index (second evens))\n         (evens (filter even? arr))\n      \
    \   (min (first evens))\n         (index (second evens)))\n    (if (or (equal?\
    \ smalest_value min) (equal? index min))\n        (list min index)\n        (pluck\
    \ evens))))\n", "  (define (smalest_value lst)\n    (if (null? lst)\n      0\n\
    \      (if (< (car lst) 0)\n          (smalest_value (cdr lst))\n          (smalest_value\
    \ (cadr lst))))))\n\n  (define (smallest_index lst)\n    (if (null? lst)\n   \
    \   0\n      (if (< (car lst) 0)\n          (smallest_index (cdr lst))\n     \
    \     (smallest_index (cadr lst))))))\n\n  (smalest_value (map smalest_value arr))\n\
    \n  (smallest_index (map smallest_index arr)))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
