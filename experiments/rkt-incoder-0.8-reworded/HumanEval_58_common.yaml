name: HumanEval_58_common
language: rkt
prompt: "#lang racket\n\n;; Return sorted unique common elements for two lists.\n\
  ;; >>> (common (list 1 4 3 34 653 2 5) (list 5 7 1 5 9 653 121))\n;; (list 1 5 653)\n\
  ;; >>> (common (list 5 3 2 8) (list 3 2))\n;; (list 2 3)\n(define (common l1 l2)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate common))\n\
  \    (check-equal? (candidate (list 1 4 3 34 653 2 5) (list 5 7 1 5 9 653 121))\
  \ (list 1 5 653))\n    (check-equal? (candidate (list 5 3 2 8) (list 3 2)) (list\
  \ 2 3))\n    (check-equal? (candidate (list 4 3 2 8) (list 3 2 4)) (list 2 3 4))\n\
  \    (check-equal? (candidate (list 4 3 2 8) (list )) (list ))\n))\n\n(test-humaneval)"
completions: ["  (cond ((null? l1) l2)\n        ((null? l2) l1)\n        ((equal?\
    \ (first l1) (first l2)) (common (rest l1) (rest l2)))\n        (else (append\
    \ (common (first l1) (rest l2)) (common (rest l1) (first l2))))))\n", "  (cond\
    \ [(empty? l1) l2]\n        [else (append (remove (car l1) l2)\n             \
    \         (common (remove (car l2) l1)\n                              l2))]))",
  "  (sort (append (sort l1)\n                (sort l2)))\n  )\n", "  (let ((common-tail\n\
    \         (filter common-tail? l2\n                  (filter (lambda (x)\n   \
    \                         (member x l1))\n                          l1\n     \
    \                     :key identity))))\n    (cond ((null? l1) l2)\n         \
    \ ((null? l2) l1)\n          (else (append common-tail (list l1))))))\n", "  (cond\
    \ [(or (null? l1) (null? l2))\n         '()]\n        [(and (< l1\n          \
    \         (car l2))\n             (< l2\n                   (car l1)))\n     \
    \    (cons (car l1)\n               (common (cdr l1)\n                      (cdr\
    \ l2)))]\n        [else\n         (common (cdr l1)\n                 (cdr l2))]))\n",
  "  (cond [(empty? l1)\n         (reverse (cons (first l2) (first l1)))]\n      \
    \  [else (cons (first l2)\n                    (common (rest l1)\n           \
    \                  (rest l2)))]))\n", "  (sort-unique\n   (lambda (x y) (equal?\
    \ (first x) y))\n   l1 l2))\n", "  (if (empty? l1)\n      l2\n      (let ((l1\
    \ (take l1 l2))\n            (l2 (take l2 l1))\n            (common (rest l1)\
    \ (rest l2)))\n        (if (member l2 (distinct l1))\n            l1\n       \
    \     (append (list (first l1)) (common (rest l1) l2))))))\n", "  (cond\n    [(empty?\
    \ l1)\n     (if (null? l2) l1 (list l2))]\n    [(empty? l2)\n     (if (null? l1)\
    \ l1 (list l2))]\n    [else\n     (let [head (lcar l1)\n           tail (lcar\
    \ l2)]\n       (cond\n         [(= head tail) head]\n         [(< head tail) (cons\
    \ head (common (cdr l1) l2))]\n         [else\n          (cons (common (cdr l1)\
    \ l2)\n                (common (cdr l2) l1))]\n         ))]))\n", "  (cond [(empty?\
    \ l1) l2]\n        [(empty? l2) l1]\n        [(equal? (first l1) (first l2)) (second\
    \ l1)]\n        [else (common (rest l1) (rest l2))]))\n", "  (let ((l1 (sort l1))\n\
    \        (l2 (sort l2)))\n    (let loop ((l1 l1) (l2 l2))\n      (cond ((null?\
    \ l1) l2)\n            ((null? l2) l1)\n            ((equal? (car l1) (car l2))\
    \ (loop (cdr l1) (cdr l2)))\n            (else (cons (car l1) (loop (cdr l1) l2))))))\n\
    </code>\n<|/ a tags=lisp,common-lisp |>\n<| a dscore=1 |>\n<code>", "  (sort (remove-duplicates\
    \ ((lambda (x y)\n                                (cond [(empty? l1) l2]\n   \
    \                                   [(empty? l2) l1]\n                       \
    \               [(equal? (first l1) (first l2))\n                            \
    \           #t]\n                                      [(equal? (first l2) (first\
    \ l1))\n                                       #t]\n                         \
    \             [(equal? (first l1) (first l2))\n                              \
    \         (cons (first l1)\n                                            ((common\
    \ (rest l1) (rest l2)))]\n                                      [(equal? (first\
    \ l2) (first l1))\n                                       (cons (first l2)\n \
    \                                           ((common (rest l1) (rest l2)))]\n\
    \                                      [(equal? (first l1) (first l2))\n     \
    \                                  (cons (first l1)\n                        \
    \                    ((common (rest l2) (rest l1)))]\n                       \
    \               [(equal? (first l2) (first l1))\n                            \
    \           (cons (first l2)\n                                            ((common\
    \ (rest l1) (rest l2)))]\n                                      [(equal? (first\
    \ l1) (first l2))\n                                       (cons (first l1)\n \
    \                                           ((common (rest l2) (rest l1)))]\n\
    \                                      [(equal? (first l2) (first l1))\n     \
    \                                  (cons (first l2)\n                        \
    \                    ((common (rest l1) (rest l2)))]\n                       \
    \               [(equal? (first l1) (first l2))\n                            \
    \           (cons (first l1)\n                                            ((common\
    \ (rest l2) (rest l1)))]\n                                      [(equal? (first\
    \ l2) (first l1))\n                                       (cons (first l2)\n \
    \                                           ((common (rest l1) (rest l2)))]\n\
    \                                      [(equal? (first l1) (first l2))\n     \
    \                                  (cons (first l1)\n                        \
    \                    ((common (rest l2) (rest l1)))]\n                       \
    \               [(equal? (first l2) (first l1))\n                            \
    \           (cons (first l2)\n                                            ((common\
    \ (rest l1) (rest l2)))]\n                                      [(equal? (first\
    \ l1) (first l2))\n                                       (cons (first l1)\n \
    \                                           ((common (rest l2) (rest l1)))]\n\
    \                                      [(equal? (first l2) (first l1))\n     \
    \                                  (cons (first l2)\n                        \
    \                    ((common (rest l1) (rest l2)))]\n                       \
    \               [(equal? (first l1) (first l2))\n                            \
    \           (cons (first l1)\n                                            ((common\
    \ (rest l2) (rest l1)))]\n                                      [(equal? (first\
    \ l2) (first l1))\n                                       (con", "  (cond ((null?\
    \ l1) l2)\n        ((null? l2) l1)\n        ((equal? (first l1) (first l2)) \n\
    \         (cons (first l2) (common (rest l1) (rest l2))))\n        (else \n  \
    \       (common (rest l1) (rest l2)))))\n  ", "  (cond\n    ((null? l1) l2)\n\
    \    ((member (first l1) l2)\n     (common (rest l1) l2))\n    (else (common (rest\
    \ l1) l2))))\n", "  (apply append (remove-if (lambda (x) (not (member x l2)))\
    \ l1) l2))\n", "  (define (find x xs) (cond ((null? xs) '())\n               \
    \          ((eq? (car xs) x) (cdr xs))\n                         (else (find x\
    \ (cdr xs)))))\n  (find (first l1) (find (first l2) (car l1))))\n", "  (cond [(empty?\
    \ l1) l2]\n        [(empty? l2) l1]\n        [(equal? (first l1) (first l2)) (common\
    \ (rest l1) (rest l2))]\n        [else (cons (first l1) (common (rest l1) l2))]))\n\
    </code>\nThis solution is also simpler than the one I posted above by removing\
    \ the duplicates before sorting the lists.\n<|/ a |>\n<| a tags=scheme dscore=1\
    \ |>\nMy answer is a bit different, but probably more efficient and also shorter:\n\
    <code>", "  (cond\n    [(empty? l1 empty? l2) empty]\n    [(empty? l1) (list empty)]\n\
    \    [(empty? l2) (list empty)]\n    [else (append (sort l1)\n               \
    \    (common (sort l2)\n                             (rest l2)))]))\n", "  (filter\
    \ (lambda (e) (not (member e l2))) l1))\n</code>\n<|/ a dscore=2 |>\n<| a |>\n\
    This is my first time answering a question on Stack Overflow, so I apologize in\
    \ advance for any errors or inaccuracy in the code. :P\nI think I might have figured\
    \ out the problem you're having, but I'll point out a couple other things. \n\
    First, instead of using map and filter, you can use filter-not. This function\
    \ is like filter, except it negates its predicate. \n<code>", "  (let loop ((l1\
    \ (car l1)) (l2 (cdr l2))\n            (res   (list l1)))\n    (cond ((null? l1)\
    \ res)\n          ((null? l2) res)\n          (else\n           (loop (car l1)\
    \ (cdr l2)\n                 (append (loop (car l2) (cdr l2)) (cons (car l1) res)))))))\n",
  "  (cond ((null? l1) l2)\n        ((null? l2) l1)\n        (else (let ([min1 (car\
    \ l1)]\n                      [min2 (car l2)])\n                   (if (< (car\
    \ l1) (car l2))\n                       (common (cdr l1) (cdr l2))\n         \
    \              (common (cdr l2) (cdr l1))))))))\n", "  (if (null? l1)\n      (if\
    \ (null? l2)\n          ()\n          l2)\n      (if (not (member (first l1) l2))\n\
    \          (cons (first l1) (common l1 (rest l2)))\n          (common l2 (rest\
    \ l1)))))\n", "  (cond\n    [(empty? l1) l2]\n    [(empty? l2) l1]\n    [(equal?\
    \ (first l1) (first l2)) (second l1)]\n    [else\n     (append (common (rest l1)\
    \ l2)\n            (common (first l1) (rest l2)))]))\n", "  (define (subseq i\
    \ j l)\n    (cond\n      [(null? l)\n       (list nil nil)]\n      [(< i (length\
    \ l)) (subseq i (length l) l)]\n      [else\n       (cons (first l) (subseq (+\
    \ i 1) j l))]\n      ))\n  (subseq 1 1 (sort l1 subseq)))\n", "  (cond\n    [(empty?\
    \ l1) l2]\n    [(empty? l2) l1]\n    [else (let [smallest (first l1)\n       \
    \            second (first l2)\n                   smallest-count (length l1)\n\
    \                   second-count (length l2)]\n             (cond\n          \
    \     [(< smallest-count second-count)\n                (if (equal? smallest second)\n\
    \                    (common (rest l1) (rest l2))\n                    (cons smallest\
    \ (common (rest l1) (second)))])]\n               [else (cond\n              \
    \          [((< smallest second) (equal? first second))\n                    \
    \     ((< second smallest) (equal? first second))\n                         (else\
    \ (common (rest l1) (rest l2)))])]))]))\n", "  (cond\n    ((null? l1) l2)\n  \
    \  ((null? l2) l1)\n    (else\n     (if (equal? (first l1) (first l2))\n     \
    \  (common (rest l1) (rest l2))\n       (cons (first l1) (common (rest l1) (rest\
    \ l2)))\n      )))\n  )\n", "  (define (helper l1 l2 count)\n    (if (null? l1)\n\
    \        #t\n        (if (equal? (first l1) (first l2))\n            (helper (rest\
    \ l1) (rest l2) (+ count 1))\n            (helper (rest l1) l2 (+ count 1)))))\n\
    \  (if (null? l2)\n      #f\n      (helper (rest l1) l2 (+ count 1))))\n</code>\n\
    <|/ a |>\n<| c |>\nThank you for your help. I will test and come back with the\
    \ result.\n<|/ c |>\n<| c |>\nI have tried your code, my input was `(common (list\
    \ 2 5 3 9 11) (list 5 3 2 7 4 6 11))` but your results are `#t` and `#f` instead\
    \ of `#t` and `#t`. Maybe I missed something?\n<|/ c |>\n<| c |>\nIt's because\
    \ of the last line: `(equal? (first l1) (first l2))`\n<|/ c |>\n<| a tags=racket,scheme\
    \ |>\nHere is another solution that works in racket, but with O(n) complexity\
    \ instead of O(n^2).\n<code>\n#lang racket\n", "  (if (empty? l1)\n      l2\n\
    \      (if (empty? l2)\n          l1\n          (if (< (car l1) (car l2))\n  \
    \            (append l1 (list (car l1) (common (cdr l1) l2))\n              (common\
    \ (cdr l1) (cdr l2))\n              (common l1 (cdr l2))))))))\n", "  (let ((sorted-commons\
    \ (sort (set->list (set-intersect (list->set l1) (list->set l2))) (<))))\n   \
    \ (list-ref sorted-commons 0)))\n</code>\n<|/ a tags=racket,functional-programming\
    \ |>\n<| c |>\nThis is really good. How would I be able to modify this so that\
    \ it returns not just common elements but their relative positions?\n<|/ c |>\n\
    <| c |>\nI added the function `get-position` for the relative position.\n<|/ c\
    \ |>\n<| a tags=racket,functional-programming dscore=2 |>\nUsing Racket sets:\
    \ \n<code>\n#lang racket\n", "  (sort (remove (sort l1) l2)\n        (<)))\n",
  "  (if (null? l1)\n      (if (null? l2)\n          '()\n          l2)\n      (let\
    \ ([elm1 (car l1)]\n            [elm2 (car l2)])\n        (if (member elm1 elm2)\n\
    \            (common (cdr l1) (cdr l2))\n            (if (null? (cdr l1))\n  \
    \              (common (cdr l2) l1)\n                (common (cdr l2) (cdr l1)))))))\n",
  "  (cond\n    ((null? l1) l2)\n    ((null? l2) l1)\n    (else (append (interleave\
    \ l1 (car l2)) (common (cdr l1) (cdr l2))))\n    )\n  )\n", "  (cond [(null? l1)\
    \ l2]\n        [(member l1(car l2) l1) (common c1 (cdr l2))]\n        [else (common\
    \ c1 (cdr l1))]))\n", "  (let ((l3 (sort (list l1 l2) '<))\n        (l4 (sort\
    \ (list l2 l3) '<))\n        (l1head (first l1))\n        (l2head (first l2)))\n\
    \    (cond ((null? l1)\n           (list (cdr l1head)))\n          ((null? l2)\n\
    \           (list (cdr l2head)))\n          ((> l1head l2head)\n           (if\
    \ (> l1head l1head)\n               (list (car l1head))\n               (list\
    \ (cdr l1head)))))\n    (cond ((or (null? l1) (null? l2))\n           (if (null?\
    \ l1)\n               (if (null? l2)\n                   (list)\n            \
    \       (list))\n               (list))\n          ((equal? (first l1) (first\
    \ l2))\n           (if (equal? (first l2) (first l1))\n               (if (equal?\
    \ (second l2) (second l1))\n                   (if (equal? (second l1) (third\
    \ l1))\n                       (if (equal? (third l1) (third l2))\n          \
    \                 (if (equal? (third l2) (fourth l1))\n                      \
    \         (if (equal? (fourth l1) (fourth l2))\n                             \
    \      (if (equal? (fourth l2) (fifth l1))\n                                 \
    \      (if (equal? (fifth l1) (fifth l2))\n                                  \
    \         (if (equal? (fifth l2) (sixth l1))\n                               \
    \                (if (equal? (sixth l1) (sixth l2))\n                        \
    \                           (if (equal? (sixth l2) (seventh l1))\n           \
    \                                            (if (equal? (seventh l1) (seventh\
    \ l2))\n                                                           (if (equal?\
    \ (seventh l2) (eighth l1))\n                                                \
    \               (if (equal? (eighth l1) (eighth l2))\n                       \
    \                                            (if (equal? (eighth l2) (ninth l1))\n\
    \                                                                       (if (equal?\
    \ (ninth l1) (ninth l2))\n                                                   \
    \                        ())))\n                                           (if\
    \ (equal? (ninth l2) (tinth l1))\n                                           \
    \    (if (equal? (tinth l1) (tinth l2))\n                                    \
    \               (if (equal? (tinth l2) (tenth l1))\n                         \
    \                              (if (equal? (tenth l1) (tenth l2))\n          \
    \                                                 (if (equal? (tenth l2) (eleventh\
    \ l1))\n                                                               (if (equal?\
    \ (eleventh l1) (eleventh l2))\n                                             \
    \                    (if (equal? (eleventh ", "  (sort (remove-duplicates \n \
    \         (filter (lambda (e) (equal? e (car l1) #t)) l2))))\n", "  (if (null?\
    \ l1)\n      l2\n      (if (equal? l1 l2)\n          l1\n          (append (remove\
    \ l1 l2) (common (remove l1 l2) l2)))))\n", "  (cond\n    [(empty? l1) l2]\n \
    \   [(empty? l2) l1]\n    [(equal? (first l1) (first l2)) (common (rest l1) (rest\
    \ l2))]\n    [else (cons (first l1)\n               (common (rest l1)\n      \
    \                  (cons (first l2) (rest l2))))]\n    ))\n", "  (sort (remove\
    \ #(null? %) (cdr l2)) <))\n", "  (cond\n    [(or (empty? l1) (empty? l2))\n \
    \    (list '())]\n    [(equal? (car l1) (car l2))\n     (cons (car l1)\n     \
    \      (common (cdr l1) (cdr l2)))]\n    [(equal? (car l1) (cdr l2))\n     (common\
    \ (cdr l1) (cdr l2))]\n    [else\n     (if (equal? (car l1) (cdr l2))\n      \
    \   (common (cdr l1) l2)\n         (common l1 l2))]))\n", "  (cond [(null? l1)\n\
    \         (reverse l2)]\n        [(null? l2)\n         (reverse l1)]\n       \
    \ [else\n         (let [c1 (car l1)\n               c2 (car l2)\n            \
    \   ls1 (cdr l1)\n               ls2 (cdr l2)\n               result\n       \
    \        (lambda (x y)\n                 (if (> x y)\n                     (equal?\
    \ x y)\n                     (equal? x c1) (equal? y c2) (equal? x ls1) (equal?\
    \ y ls2))))\n           (for/fold ((h null) (x null)) ([x l1]) (list (car x))\n\
    \                     ([y l2]) (list (car y)))\n           (filter (lambda (z)\
    \ (z result)) (map result l1 l2))]))\n", "  (sort (remove-duplicates \n      \
    \    (remove-if\n           (lambda (e) (equal? (first e) (rest e)))\n       \
    \    (sort l1 '<) (sort l1 '<)))\n         '<))\n", "  (let ([len1 (length l1)]\n\
    \        [len2 (length l2)])\n    (cond [(or (= len1 len2) (< len1 len2)) '()]\n\
    \          [(and [number? (car l1)] [number? (car l2)])\n           (list '())]\n\
    \          [(number? (car l1) (or (= len1 len2) (< len1 len2))) \n           (cons\
    \ (car l1) (common (cdr l1) (cdr l2)))]\n          [else (common (cdr l1) (cdr\
    \ l2))]))))\n</code>\n<|/ a tags=scheme,racket,list |>\n<| c |>\nYour `common`\
    \ function has exponential time complexity, and should be replaced with a simpler\
    \ solution that runs in linear time complexity, like the one given by.\n<|/ c\
    \ |>\n<| a dscore=4 tags=scheme,racket,list |>\nIn case anyone is looking for\
    \ an answer to the second question of how to find the longest common subsequence\
    \ in a list, and not necessarily a longest common sublist, here's a recursive\
    \ version that doesn't take exponential time if the lists are all sorted.\n<code>",
  "  (sort l1 (comp (lambda (x) (member x l2)) (lambda (x) (member x l1)))\n     \
    \    #:key 'first))\n</code>\n<|/ a tags=racket,scheme,sorting |>\n<| a dscore=0\
    \ tags=racket,scheme,sorting |>\nIn Racket:\n<code>", "  (cond\n    [(empty? l1)\
    \ l2]\n    [(empty? l2) l1]\n    [(equal? (first l1) (first l2)) (cons (first\
    \ l1) (common rest (rest l2)))]\n    [else (common rest (rest l1))]))\n", "  (if\
    \ (empty? l1 l2)\n      l2\n      (if (member (car l1) l2)\n          (cons (car\
    \ l1) (common (cdr l1) l2))\n          (common (cdr l1) l2))))\n", "  (cond\n\
    \    [(null? l1) l2]\n    [(null? l2) l1]\n    [else (if (equal? (car l1) (car\
    \ l2)) (cons (car l1) (common cdr l2)) (common (cdr l1) (cdr l2)))]))\n", "  (sort-remove-duplicates\
    \ \n   (filter (lambda (x) (memberx x l1))\n            (filter (lambda (x) (memberx\
    \ x l2))\n                    l1))\n   l2))\n</cell>\n<cell>\n#lang racket\n",
  "  (cond\n    ((null? l1) l2)\n    ((null? l2) l1)\n    ((equal? (car l1) (car l2))\
    \ (common (cdr l1) (cdr l2)))\n    (else (cons (car l1) (common (cdr l1) (cdr\
    \ l2))))))\n", "  (cond\n    ((null? l1) l2)\n    ((null? l2) l1)\n    ((equal?\
    \ (first l1) (first l2)) (common (rest l1) (rest l2)))\n    (else (cons (first\
    \ l1) (common (rest l1) (rest l2))))))\n", "  (let ((l (sort (append l1 l2) '<)))\n\
    \    (remove-if (lambda (x) (not (member x l)))\n              l)))\n", "  (cond\
    \ [(null? l1) l2]\n        [(member (car l1) l2)\n         (common (cdr l1) l2)\n\
    \         l1]\n        [else\n         (common (cdr l1) l2)]))\n", "  (let ([x\
    \ (remove-duplicates l1)\n         y (remove-duplicates l2)])\n    (if (null?\
    \ x) '()\n        (if (null? y) '()\n            (cons (car x) (car y))))))\n",
  "  (sort (remove (set-to-list (union (sort l1) (sort l2))) l1) '<))\n", "  (if (null?\
    \ l1)\n      (list l2)\n      (if (null? l2)\n          (list l1)\n          (if\
    \ (equal? (car l1) (car l2))\n              (append (list (car l1)) (car (cdr\
    \ l1)))\n              (if (equal? (car l2) (car l1))\n                  (append\
    \ (cdr (cdr l2)) (list (car l2)))\n                  (common (cdr l1) (cdr l2)))))))\n\
    </cell>\n<cell>\n#lang racket\n", "  (cond [(empty? l1) l1]\n        [(empty?\
    \ l2) l2]\n        [(member l1 (cdr l2))\n         (common l1 (cdr l2))]\n   \
    \     [(member l2 (cdr l1))\n         (common l2 (cdr l1))]\n        [else (append\
    \ (list (car l1) (car l2))\n                      (common (cdr l1) (cdr l2)))]))\n",
  "  (cond\n    ((null? l1) l2)\n    ((null? l2) l1)\n    ((equal? (first l1) (first\
    \ l2)) (common (rest l1) (rest l2)))\n    (else (append (common (first l1) l2)\
    \ (common (first l2) l1)))))\n", "  (define (unique-common-elements lst)\n   \
    \ (let ((lst-length (length lst)))\n      (if (<= lst-length 1)\n          (list\
    \ lst)\n          (append (cons (first lst) (unique-common-elements (rest lst)))\
    \ \n                   (unique-common-elements (subseq lst 1))))))\n  (unique-common-elements\
    \ l1)\n  (unique-common-elements l2))\n", "  (sort (list-ref l1 (sort l2))))\n",
  "  (let ((ls (sort l1 '<))))\n    (cond ((empty? ls) l1)\n          ((equal? (first\
    \ ls) (first l2)) (common (rest ls) (rest l2)))\n          (else (cons (first\
    \ ls) (common (rest ls) (rest l2))))))))\n</code>\n<|/ a dscore=4 |>\n<| c |>\n\
    I didn't know about sort or sort for that matter.\n<|/ c |>\n<| c |>\nAh.  I didn't\
    \ know that sort sorts in-place and returns a new list.\n<|/ c |>\n<| c |>\nIt\
    \ does return a new list, but you really don't have to do that. You can always\
    \ assign the result to a new variable, if you wish.\n<|/ c |>\n<| c |>\nAh.  I\
    \ didn't know that.  I guess I could have sworn it sorted.  Thanks.\n<|/ c |>\n\
    <| c |>\nA quick test shows that it doesn't sort the list.  (sort '(1 4 3 34 653\
    \ 2 5) '<) returns #(1 2 3 4 5 653).\n<|/ c |>\n<| a tags=racket,scheme |>\n<code>",
  "  (cond\n    [(empty? l1) '()]\n    [(empty? l2) '()]\n    [(not (equal? (first\
    \ l1) (first l2))) (common (rest l1) (rest l2))]\n    [else (cons (first l1)\n\
    \               (common (rest l1)\n                       (rest l2)))]))\n", " \
    \ (sort (remove-duplicates l1) '< :key (lambda (e)\n                         \
    \      (member e l2)))) \n", "  (cond ((null? l1)\n         l2)\n        ((null?\
    \ l2)\n         l1)\n        ((and (number? (car l1)) number? (car l2))\n    \
    \     (cons (car l1) (common (cdr l1) (cdr l2))))\n        (else\n         (common\
    \ (cdr l1) (cdr l2)))))\n", "  (sort (remove-if (lambda (x) (member? x l1)) (sort\
    \ l2))))\n", "  (cond\n    [(null? l1) l2]\n    [(member (first l1) l2) (common\
    \ (rest l1) l2)]\n    [else (cons (first l1) (common (rest l1) l2))]))\n", " \
    \ (filter (lambda (e)\n            (member e l1 l2))\n          (union (sort l1)\n\
    \                 (sort l2))))\n", "  (cond ((null? l1) l2)\n        ((null? l2)\
    \ l1)\n        (else (if (equal? (first l1) (first l2))\n                    (cons\
    \ (first l1) (common (rest l1) (rest l2)))\n                    (common (rest\
    \ l1) (rest l2))))))\n", "  (define (helper l1 l2 seen acc)\n    (cond\n     \
    \ [(null? l1) acc]\n      [else (helper (rest l1) (rest l2) (cons (first l1) seen)\
    \ (rest acc))]\n      [(member first (rest l2)) (cons (first l1) seen)]\n    \
    \  [else (helper (rest l1) (rest l2) seen acc)]\n      ))\n  (helper l1 l2 #f\
    \ (list #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f\
    \ #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f\
    \ #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f\
    \ #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f\
    \ #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f\
    \ #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f\
    \ #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f\
    \ #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f\
    \ #f #f #", "  (cond\n    ((null? l1)(list))\n    ((null? l2)(list))\n    ((equal?\
    \ (first l1) (first l2))\n     (cons (first l1) (common (rest l1) (rest l2))))\n\
    \    (else (common (rest l1) l2))))\n", "  (if (or (null? l1)(null? l2))\n   \
    \   nil\n      (let ([a (first l1)\n            b (first l2)])\n        (if (null?\
    \ a)\n            (cons b (common (rest l1) (rest l2)))\n            (if (same-key\
    \ a b)\n                (common (rest a) (rest b))\n                (cons a (common\
    \ (rest l1) (rest l2)))))))\n  (define (same-key a b)\n    (< (first a) (first\
    \ b)))\n", "  (cond\n    ((null? l1) l2)\n    ((null? l2) l1)\n    ((equal? (first\
    \ l1) (first l2)) (common (rest l1) (rest l2)))\n    (else (cons (first l1) (common\
    \ (rest l1) l2)))\n  ))", "  (append (remove-if (lambda (x) (member x l1)) l2)\n\
    \          (remove-if (lambda (x) (member x l2)) l1)))\n", "  (if (or (null? l1)\
    \ (null? l2))\n      '()\n      (cond ((equal? (first l1) (first l2)) (common\
    \ (rest l1) (rest l2)))\n            ((equal? (first l2) (first l1)) (common (rest\
    \ l1) (rest l2)))\n            (else (cons (first l1) (common (rest l1) (rest\
    \ l2))))))))\n</code>\n<|/ a tags=racket,scheme |>\n<| a tags=racket,scheme dscore=1\
    \ |>\nHere is a recursive implementation that doesn't require sorting.\n<code>",
  "  (define (helper l1 l2 acc)\n    (cond\n      [(empty? l1) acc]\n      [(empty?\
    \ l2) acc]\n      [(equal? (first l1) (first l2)) (helper (rest l1) (rest l2)\
    \ (cons (first l1) acc))]\n      [else (helper (rest l1) l2 (cons (first l1) acc))]\n\
    \      ))\n  (helper l1 l2 '()))", "  (cond ((null? l1) l2)\n        ((null? l2)\
    \ l1)\n        ((equal? (first l1) (first l2)) (common (rest l1) (rest l2)))\n\
    \        (else (common (rest l1) l2))))\n", "  (cond [(empty? l1) l2]\n      \
    \  [(empty? l2) l1]\n        [(equal? (first l1) (first l2)) (common (rest l1)\
    \ (rest l2))]\n        [else (cons (first l1)\n                    (common (rest\
    \ l1)\n                             (rest l2)))]))\n", "  (sort (sort l1)\n  \
    \      (compare l2)\n        ;; unique\n        #:key (lambda (x y) (< (first\
    \ x) first y) (< (first y) first x))\n        ;; equality\n        #:equal? (lambda\
    \ (x y) (equal? (first x) first y)))\n  ;; No unique elements\n  (filter (lambda\
    \ (x y) (not (equal? (first x) first y))) l2))\n</code>\n<|/ a tags=racket,scheme\
    \ dscore=1 |>\n<| a tags=racket,scheme |>\nHere's a simple implementation using\
    \ Racket's built-in \"set\" data structure:\n<code>", "  (sort (car (set-difference\
    \ (list l1 l2) (list l1 l2)))))\n", "  (remove-if (lambda (x) (member x l2)) l1))\n",
  "  (filter\n   (lambda (x)\n     (member (first x) l2)\n     l1)\n   (sort\n   \
    \ (remove-duplicates \n     (sort l1 <))))) ; #lang racket\n", "  (cond [(null?\
    \ l1) '()]\n        [(member (first l1) l2) (first (common (rest l1) l2))]\n \
    \       [else (common (rest l1) l2)]))\n", "  (sort (filter (lambda (x) (not (null?\
    \ x))) (remove (lambda (x) (equal? x l2)) l1)) 'descend))\n", "  (apply append\n\
    \         (sort (filter even? (rest l1)) <)\n         (sort (filter even? (rest\
    \ l2)) <)))\n", "  (cond\n    ((empty? l1)(empty? l2))\n    ((equal? (first l1)\
    \ (first l2))\n     (if (equal? (rest l1) (rest l2))\n       (first l1)\n    \
    \   (first l2))\n     (if (equal? (rest l1) (rest l2))\n       (first l1)\n  \
    \     (first l2)))\n    (else\n     (cond\n       ((equal? (first l1) (first l2))\n\
    \        (if (equal? (rest l1) (rest l2))\n          (cons (first l1) (common\
    \ l2 (rest l2)))\n          (cons (first l1) (common l2 (rest l2)))))\n      \
    \ ((equal? (first l1) (first l2))\n        (if (equal? (rest l1) (rest l2))\n\
    \          (cons (first l1) (common l2 (rest l2)))\n          (cons (first l1)\
    \ (common l2 (rest l2)))\n          (cons (first l1) (common l2 (rest l2)))\n\
    \          (cons (first l1) (common l2 (rest l2)))))\n       ((equal? (first l1)\
    \ (first l2))\n        (if (equal? (rest l1) (rest l2))\n          (cons (first\
    \ l1) (common l2 (rest l2)))\n          (cons (first l1) (common l2 (rest l2))\n\
    \                 (cons (first l1) (common l2 (rest l2)))))))\n    ))\n)\n", " \
    \ (cond\n    ((null? l1) l2)\n    ((null? l2) l1)\n    ((equal? (car l1) (car\
    \ l2)) (common (cdr l1) (cdr l2)))\n    (else (cons (car l1) (common (cdr l1)\
    \ l2)))))\n", "  (let loop ((l1 l1) (l2 l2) (lc '())\n            (l2 '() :init))\n\
    \    (cond ((null? l1) l2)\n          ((null? l2) l1)\n          ((equal? (first\
    \ l1) (first l2))\n           (loop (rest l1) (rest l2) (cons (first l1) lc)))\n\
    \          ((equal? (first l1) (first l2))\n           (loop (rest l1) (rest l2)\
    \ lc))\n          (else\n           (loop (rest l1) l2 (cons (first l1) lc))))))\n",
  "  (append (sort (distinct-values l1)) l2))\n", "  (cond [(empty? l1) l2]\n    \
    \    [(member (head l1) l2)\n         (common (tail l1) l2)]\n        [else (cons\
    \ (head l1)\n                    (common (tail l1) l2))]))\n", "  (sort (set-diff\
    \ (set l1) (set l2)) (lambda (s) (< (length s) (length l1)))))\n</code>\n<|/ a\
    \ dscore=2 tags=racket,scheme |>\n<| c |>\nYes, the function has other parts,\
    \ but I just wanted to get the unique values. Thanks!\n<|/ c |>\n<| a |>\nThis\
    \ is an implementation using Racket hash tables\n<code>", "  (sort (filter (lambda\
    \ (x) (not (member x l1))) l2) #'<))\n", "  (cond\n    [(empty? l1) l2]\n    [(empty?\
    \ l2) l1]\n    [(memq (first l1) (first l2)) #(cons (first l1) (common rest l2))]\n\
    \    [else (common rest (cons (first l1) l2))]))\n", "  (cond ((null? l1) l2)\n\
    \        (else (let ((x (car l1))\n                     (y (first l2))\n     \
    \                (z (second l2)))\n              (if (same? x y)\n           \
    \       (common (cdr x) (remove x l2)))\n              (if (same? x z)\n     \
    \             (common (cdr y) (remove y l2)))\n              (cons x (common x\
    \ (cdr y)))))))\n", "  (cond [(null? l1)\n         (reverse (sort l2))]\n    \
    \    [(null? l2)\n         (reverse (sort l1))]\n        [else (set\n        \
    \        (append (sort l1)\n                        (sort l2)))\n         (cons\
    \ (first l1) (common (rest l1) l2))]))\n", "  (sort (distinct (map first l1))\
    \ (< first (first l1)) l2))\n</code>\n<|/ a tags=list,racket,sorting,scheme |>\n\
    <| c |>\nNice!  Could you explain how it works? I don't understand the map first\
    \ part.\n<|/ c |>\n<| c |>\nThat would be really useful, though it isn't really\
    \ something that I really understand. How does map first work?\n<|/ c |>\n<| c\
    \ |>\nIn a map, each element is mapped to another element, in our case the first\
    \ element of a list is the same as the second element. `map` takes a function\
    \ and applies it to all the elements of a list. So the `first` part just gets\
    \ the first element of a list and puts it in a variable.\n<|/ c |>\n<| a |>\n\
    I really like Martin's answer, but I thought I'd provide another solution that\
    \ doesn't use hash tables and still preserves ordering.  The important concept\
    \ here is that (< a b) is the same as (>= a b), so you can simply write (< first\
    \ last) to check if the first element of each list is greater or less than the\
    \ second.\n<code>", "  (sort (sort-unique (sort-common (sort-uniq (sort-eq? l1\
    \ l2) (sort-uniq (sort-eq? l1 l2) '())) '())) '()))", "  (sort (remove-duplicates\
    \ (foldr append l1 (sort l2))))\n  )\n", "  (if (null? l1)\n      (if (null? l2)\n\
    \          l1 l2\n          (common (rest l1) (rest l2))\n          )\n      (if\
    \ (null? l2)\n          l1 l2\n          (if (< (car l1) (car l2))\n         \
    \     (common (rest l1) l2)\n              (common l1 (rest l2))\n           \
    \   )\n          )\n      ;; Common part is the same in both lists\n      (if\
    \ (eq? (car l1) (car l2))\n          (common l1 (cdr l2))\n          (common (cdr\
    \ l1) l2)\n          )\n      )\n  )\n  )\n", "  (cond\n    [(null? l1) l2]\n\
    \    [(member (first l1) l2)\n     (common (rest l1) l2)]\n    [else (cons (first\
    \ l1) (common (rest l1) l2))]))\n", "  (cond [(null? l1)\n         (reverse l2)]\n\
    \        [(null? l2)\n         (reverse l1)]\n        [else\n         (cond [(<\
    \ l1\n                   (caar l2))\n                (cons (car l1)\n        \
    \               (common (cdr l1) l2))]\n               [else\n               \
    \ (cons (car l2)\n                       (common (cdr l1) l2))]))]))\n</cell>\n\
    <cell>\n#lang racket\n", "  (let ((c (make-hash (cons (first l1) (second l2)))))\n\
    \    (define (check l1 l2 h)\n      (cond [(null? l1) (hash h)\n             (begin\n\
    \               (check-list l1 h) (check-list l2 h)\n               (return h))]\n\
    \            [(equal? (first l1) (first l2)) (check (rest l1) (rest l2) h)\n \
    \            (check (rest l1) (rest l2) (hash (cons (first l1) (first l2))))]\n\
    \            [else (check-hash (hash (cons (first l1) (first l2))) (cons (first\
    \ l1) (first l2))) (check (rest l1) (rest l2) (hash (cons (first l1) (first l2))))]\n\
    \        ))\n    (check-hash (hash l1) l2 l2)\n    (check l1 l2 hash)))\n", " \
    \ (sort (distinct (remove-duplicates l1))\n        (lambda (a b) (< (length a)\
    \ (length b)) (< (car a) (car b)))))\n", "  (sort (remove-if (lambda (x) (not\
    \ (member (car x) l2))) l1) '<))\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThat was\
    \ my first approach, but I wanted to avoid using `member` and instead use `equal?`\n\
    <|/ c |>\n<| c |>\nIf you don't know how to use `member` then use it. It is much\
    \ clearer, more efficient, and more idiomatic than using an `if` statement.  By\
    \ the way, your approach only uses `member` once, but it is repeated twice - which\
    \ makes it more inefficient.\n<|/ c |>\n<| c |>\nI added a better solution, using\
    \ `equal?`. You don't really need `remove-if`.\n<|/ c |>\n<| c |>\nYes, I added\
    \ a better solution, using `equal?`. I hope you don't mind the edit.\n<|/ c |>\n\
    <| a tags=racket,scheme |>\nI would suggest that you avoid using member. Here\
    \ is a simple solution that is O(n log n) for the remove-if approach that you\
    \ propose in the first place. \n<code>", "  (cond ((null? l1)\n         (reverse\
    \ l2))\n        ((null? l2)\n         (reverse l1))\n        (else\n         (cond\
    \ ((< car l1 l2)\n                (cons (car l1) (common cdr l1)))\n         \
    \      ((< car l2 l1)\n                (cons (car l2) (common cdr l2)))\n    \
    \           (else\n                (common l1 (cdr l1)))))))\n</code>\n<|/ a dscore=4\
    \ |>\n<| c |>\nI don't see any explanation of this implementation\n<|/ c |>\n\
    <| c |>\n- I just added an explanation.\n<|/ c |>\n<| c |>\nYes, it works. I really\
    \ need to learn how to use the \"do\" keyword. Thank you very much!\n<|/ c |>\n\
    <| a dscore=4 tags=scheme,racket |>\n<code>", "  (sort (filter (lambda (x) (member?\
    \ x l2) l1) l2) <))\n", "  (let ((len (length l1) (n-length l2))\n        (result\
    \ (make-array (+ len len) :initial-element nil)))\n    (do ((i 0 (+ i 1)))\n \
    \       ((< len len))\n      (if (equal? (subseq l1 i) l2)\n          (set! result\
    \ (subseq result i (+ i 1))) (begin\n                                        \
    \        (do ((j (+ i 1))\n                                                  \
    \   ((< len j) (set! i (+ i 1)))\n                                           \
    \          ((< len j) (set! i (+ i 1)))))\n                                  \
    \              (set! result (subseq result i j))\n                           \
    \                     (set! i (+ i 1)))))\n    (sort result)))\n", "  (sort (remove-duplicates\
    \ l1)\n        (remove-duplicates l2)\n        '()))\n", "  (cond\n    [(empty?\
    \ l1)\n     (empty? l2)\n     (list (first l1) (first l2))]\n    [else\n     (let\
    \ ((l1 (car l1))\n           (l2 (car l2)))\n       (if (equal? l1 l2)\n     \
    \      (common (cdr l1) (cdr l2))\n           (if (< l1 l2)\n               (common\
    \ (cons (car l1) l2) (cdr l2))\n               (common (cdr l1) (cons (car l2)\
    \ l2))))))])\n", "  (sort (remove (equal? (car l1) (car l2)) l1) < (car l2)))\n",
  "  (sort (remove l1 (sort (remove l2 l1)))))\n</code>\n<|/ a dscore=0 |>\n<| a tags=racket,scheme\
    \ |>\n<code>", "  (if (null? l1)\n      l2\n      (if (member (car l1) l2)\n \
    \         (cdr l2)\n          (cons (car l1) (common l2 (cdr l1))))))\n</code>\n\
    <|/ a |>\n<| c |>\nIt doesn't work for me. Look at the example I added\n<|/ c\
    \ |>\n<| c |>\n: I think you've done a typo while typing the example. `l1 l2`\
    \ is supposed to be `l1 l2`. I will edit the example.\n<|/ c |>\n<| c |>\nYes.\
    \ You're right but even when I make these typos the function gives me wrong results.\
    \ I'll try to fix it. Thanks anyway\n<|/ c |>\n<| c |>\n: I just tested the function\
    \ and it is giving me correct results. I suspect your algorithm may be giving\
    \ incorrect results. How do you test it?\n<|/ c |>\n<| c |>\n: I tested the function\
    \ by calling the function with the example and with all the examples. I'm going\
    \ to add the code to the question right now.\n<|/ c |>\n<| a dscore=0 |>\nYou\
    \ could write your own Common Prefix function and use that instead to eliminate\
    \ duplicates. You don't have to write it by hand, you could just copy and paste\
    \ it from the internet somewhere:\n<code>", "  (cond [(empty? l1) l1]\n      \
    \  [(empty? l2) l2]\n        [(eq? (first l1) (first l2)) (cons (first l1) (common\
    \ (rest l1) (rest l2)))]\n        [(eq? (first l2) (first l1)) (cons (first l2)\
    \ (common (rest l2) (rest l1)))]\n        [else (cons (first l1) (common (rest\
    \ l1) (rest l2)))]))\n", "  (remove (lambda (x) (equal? (first x) l1)) (sort l2)\n\
    \         #f (lambda (x) (equal? (first x) l1)) (sort l2)))\n</code>\n<|/ a |>\n\
    <| c |>\nAwesome solution, thanks! I like the idea of using a hash map for unique\
    \ elements, then just filtering the result. That's a really clever idea. I tried\
    \ to use it myself but I don't understand the use of the hash-map for unique elements,\
    \ why not just use a set and be done? Am I missing something? Also, if you use\
    \ the hash-map as a set, what would the key be for the hash-map? Would it be the\
    \ number in the list, or would it be the entire list?\n<|/ c |>\n<| c |>\nHash-maps\
    \ are also designed to be fast. Because a hash-map is indexed by an integer, you\
    \ can just use a unique integer as the key. So the key would just be an integer.\n\
    <|/ c |>\n<| c |>\nOh I see! So you wouldn't use the numbers to sort the lists\
    \ just because you needed to? Because you were just trying to get a unique list\
    \ of numbers? I thought you had to do that because you had to compare each list\
    \ to the other list. Thanks a lot for your help! It really helps.\n<|/ c |>\n\
    <| c |>\nThat's right. In fact, I would probably just use a set because it's actually\
    \ simpler. You're welcome!\n<|/ c |>\n<| c |>\nYou don't need to sort a list to\
    \ find common elements. Common elements don't have to be adjacent to each other.\
    \ Think of them as points on a line and the list is just ordered pairs of points.\n\
    <|/ c |>\n<| a dscore=2 tags=racket,scheme |>\nHere's a solution that doesn't\
    \ involve any recursion or iteration, and is O(n), so it's better if you have\
    \ a huge list with lots of duplicates.  It's also slightly more concise than other\
    \ solutions presented here, and is actually the kind of thing Racket can do better\
    \ than most other languages.  (It's probably just as fast, but probably much less\
    \ readable.)\n<code>", "  (let ([l1 (sort l1)\n\tl2 (sort l2)])\n    (if (null?\
    \ l1 l2)\n      (list l1)\n      (let ((l1 (car l1))\n\t     (l2 (car l2))\n\t\
    \     (c (cdr l1))\n\t     (d1 (cdr l2)))\n\t(let ([c-d1 (if (< c d1) c d1)]\n\
    \t       [c-c2 (if (< c c2) c c2)]\n\t       [d-d1 (if (< d d1) d d1)]\n\t   \
    \    [d-c2 (if (< d c2) d c2)])\n\t  (cond [(< c-d1 c-c2) (cons c-d1 d1)]\n\t\t\
    [(< c-d2 c-c1) (cons c-d2 d2)]\n\t\t[(< c-c1 c-c2) (cons c-c1 d1)]\n\t\t[(< c-c2\
    \ c-d1) (cons c-c2 d2)]\n\t\t[else (cons (car l1) (common (cons (car l2) d1) d2))])))])))\n",
  "  (cond [(empty? l1) l2]\n        [(empty? l2) l1]\n        [(equal? (car l1) (car\
    \ l2)) (common (cdr l1) (cdr l2))]\n        [else (cons (car l1) (common (cdr\
    \ l1) l2))]))\n", "  (if (or (null? l1) (null? l2))\n      '()\n      (let ((head\
    \ (car l1))\n            (tails (cdr l1))\n            (tails2 (cdr l2)))\n  \
    \      (cond\n          ((or (equal? (car l1) (car l2))\n              (equal?\
    \ (car l2) (car l1)))\n           (if (null? tails2)\n               '()\n   \
    \            (cons (car tails2) (common tails2 tails))))\n          (else (if\
    \ (equal? (car l1) (car l2))\n                    (if (null? tails2)\n       \
    \                 '()\n                        (cons (car tails2) (common tails2\
    \ tails))\n                    (cons (car l1) (common tails2 tails)))))))))\n",
  "  (cond [(null? l1) l2]\n        [(null? l2) l1]\n        [else (set! l1 (remove-if\
    \ (lambda (x) (not (member? x l2))) l1))\n             (set! l2 (remove-if (lambda\
    \ (x) (not (member? x l1))) l2))\n             (if (empty? l1) (list l2)\n   \
    \               (if (empty? l2) (list l1)\n                      (append (common\
    \ (first l1) (first l2))\n                               (common (rest l1) (rest\
    \ l2))))))]))\n", "  (sort (remove-duplicates\n          (filter (lambda (e)\n\
    \                     (memq e l1)))\n          l2)\n        #'<))\n", "  (cond\
    \ ((null? l1) l2)\n        ((null? l2) l1)\n        (else (let ((h1 (hash-table\
    \ (hash-table-count l1) (hash-table-size l1))\n                         (h2 (hash-table\
    \ (hash-table-count l2) (hash-table-size l2))))\n                  (cond ((equal?\
    \ h1 h2)\n                        (hash-table-remove-value l1 h1)\n          \
    \              (hash-table-remove-value l2 h2)\n                        (hash-table-count\
    \ h1))\n                    ((equal? (hash-table-count l1) (hash-table-count l2))\n\
    \                     (if (equal? (hash-table-size l1) (hash-table-size l2))\n\
    \                         (hash-table-remove-value l1 h1)\n                  \
    \       (hash-table-remove-value l2 h2)\n                         (hash-table-count\
    \ h1))\n                     (else\n                       (hash-table-remove\
    \ l1 h1\n                                          (hash-table-remove l2 h2\n\
    \                                                            (hash-table-count\
    \ h1))))\n                    (else (let ((a (hash-table-remove-value l1 h1)\n\
    \                                   (b (hash-table-remove-value l2 h2)\n     \
    \                                   (c (hash-table-count h1))))\n            \
    \                (cond\n                             ((equal? a b)\n         \
    \                     (hash-table-remove-value l1 h1)\n                      \
    \        (hash-table-remove l2 h2\n                                          \
    \    (hash-table-count h1))\n                              (c))\n            \
    \                ((equal? a c)\n                              (hash-table-remove-value\
    \ l1 h1)\n                              (hash-table-remove l2 h2\n           \
    \                                   (hash-table-count h1))\n                 \
    \             (b))\n                            (else (let ((e (hash-table-remove\
    \ l1 h1\n                                                        (hash-table-remove\
    \ l2 h2\n                                                                    \
    \     (hash-table-count h1)))\n                                        (g (hash-table-count\
    \ h1))))\n                                  (cond\n                          \
    \          ((equal? a e)\n                                     (hash-table-remove\
    \ l1 h1\n                                                  (hash-table-remove\
    \ l2 h2\n                                                                 (hash-table-count\
    \ h1)))\n                                     (hash-table-remove l2 h2\n     \
    \                                             (hash-table-count h1))\n       \
    \                              (hash-table-count h1))\n                      \
    \              ((equal? b e)\n                                     (hash-table-remove\
    \ l1 h1\n                                                  (hash-table-remove\
    \ l2 h2\n                                                                 (hash-table-count\
    \ h1)))\n                                     (hash-table-remove l2 h2", "  (sort\
    \ (filter (lambda (x)\n                  (member (car l1) l2))\n             \
    \   l2)))\n", "  (sort (filter (lambda(x) (equal? (first x) (car l2))) l1) <))\n",
  "  (cond (empty? l1) l2\n        (empty? l2) l1\n        ;; else the 1st element\
    \ of the 1st list is smaller\n        (< (car l1) (car l2)) (common (cdr l1) (cdr\
    \ l2))\n        ;; else the 1st element of the 2nd list is smaller\n        (<\
    \ (car l2) (car l1)) (common (cdr l2) (cdr l1))\n        ;; else the 1st element\
    \ of both lists is equal\n        (= (car l1) (car l2)) (common (cdr l1) (cdr\
    \ l2))\n        ;; else both lists are equal\n        (true) (common (cdr l1)\
    \ (cdr l2)))\n</code>\n<|/ a |>\n<| a dscore=1 |>\nA solution in Racket, similar\
    \ to my first answer, but using sort:\n<code>", "  (cond [(empty? l1) l2]\n  \
    \      [(empty? l2) l1]\n        [else\n         (let ([(c1 (first l1))\n    \
    \            (c2 (first l2))])\n           (if (eq? c1 c2)\n               (common\
    \ l1 (rest l2))\n               (cons c1 l1))]))))\n", "  (cond (empty? l1) l2\n\
    \        (empty? l2) l1\n        ;; For each pair of elements, if they are not\
    \ equal then add the\n        ;; element to a new list, otherwise add the new\
    \ list to an\n        ;; empty list.\n        (not (equal? (first l1) (first l2)))\
    \ (cons (first l1) (common (rest l1) l2))\n        (not (equal? (first l2) (first\
    \ l1))) (cons (first l2) (common (rest l2) l1))\n        (not (equal? (first l1)\
    \ (first l2))) (common (rest l1) l2)\n        (not (equal? (first l2) (first l1)))\
    \ (common (rest l2) l1))))\n", "  (remove-if\n   (lambda (x) (not (member x l2)))\n\
    \   l1))\n", "  (cond [(empty? l1) l2]\n        [(empty? l2) l1]\n        [(eq?\
    \ (first l1) (first l2)) (common (rest l1) (rest l2))]\n        [else (common\
    \ (rest l1) (rest l2))]))\n", "  (remove-duplicates \n   (remove-duplicates \n\
    \    (remove-duplicates \n     (remove-duplicates \n      (remove-duplicates \n\
    \       (remove-duplicates \n        (remove-duplicates \n         (remove-duplicates\
    \ \n          (remove-duplicates \n           (remove-duplicates \n          \
    \  (remove-duplicates \n             (remove-duplicates \n               (remove-duplicates\
    \ \n                (remove-duplicates \n                 (remove-duplicates \n\
    \                   (remove-duplicates \n                    (remove-duplicates\
    \ \n                     (remove-duplicates \n                       (remove-duplicates\
    \ \n                        (remove-duplicates \n                         (remove-duplicates\
    \ \n                          (remove-duplicates \n                          \
    \  (remove-duplicates \n                             (remove-duplicates \n   \
    \                           (remove-duplicates \n                            \
    \   (remove-duplicates \n                                (remove-duplicates \n\
    \                                 (remove-duplicates \n                      \
    \             (remove-duplicates \n                                    (remove-duplicates\
    \ \n                                     (remove-duplicates \n               \
    \                       (remove-duplicates \n                                \
    \       (remove-duplicates \n                                        l1)\n   \
    \                                    l2)))))))))))))))))))))))))))\n</code>\n\
    <|/ a dscore=1 |>\n<| a |>\nIf you're using Racket, there is a higher-order function\
    \ named foldr, which does exactly what you want. I think you could use it in this\
    \ case:\n<code>", "  (sort (remove-duplicates (fold-left (lambda (a b) (if (equal?\
    \ (car a) (car b)) a b)) l1 l2) '()))\n)\n", "  (sort (interleave l1 l2) (lambda\
    \ (x) (< (length x) 0))))\n", "  (sort (filter (lambda (x) (member x l1)) l2))\n\
    \  )\n", "  (let loop ((i 0) (l1 (reverse l1)) (l2 (reverse l2))\n           \
    \  (r1 (reverse (sort l1))) (res\n               (reverse (sort (cons (first l1)\
    \ l2)))))\n    (if (null? r1)\n        (reverse res)\n        (loop (+ i 1)\n\
    \               (rest l1)\n               (rest l2)\n               (cons (first\
    \ l1) l2)\n               (cons i r1)))))\n", "  (cond\n    [(null? l1) l2]\n\
    \    [(null? l2) l1]\n    [else (let ([s1 l1] [s2 l2]) (remove-if (lambda (x)\
    \ (member? x s2)) (remove #(member? x s1) s1) (remove #(member? x s2) s2))])))\n\
    </code>\n<|/ a dscore=1 tags=common-lisp,list,lambda,racket |>\n<| c |>\nThanks\
    \ for the response.  When I run this in Racket it returns \"(list 3 2)\" instead\
    \ of (list 2 3).\n<|/ c |>\n<| c |>\nI've added a version with an extra `remove`\
    \ at the end, try it now.\n<|/ c |>\n<| c |>\nI've edited the answer so it's in\
    \ Racket. I've been playing around with a simpler version myself but it's quite\
    \ slow at handling lists that are longer than about `100`.\n<|/ c |>\n<| c |>\n\
    Ah, I was able to get the code to work in Racket (I got it all wrong the first\
    \ time I tried).  Thanks for the help.\n<|/ c |>\n<| c |>\nI've added a version\
    \ that works in Racket as well.\n<|/ c |>\n<| a tags=common-lisp,list,lambda,racket\
    \ dscore=1 |>\nThis is not an answer, but an alternative solution in Common Lisp\
    \ using setq and pop and using two lists:\n<code>", "  (sort (remove-if (lambda\
    \ (x) (not (member x l1))) l2)\n        > (lambda (x) (not (member x l2)))))\n",
  "  (cond [(empty? l1) l2]\n        [(empty? l2) l1]\n        [(equal? (first l1)\
    \ (first l2))\n         (append l1 (common (rest l1) l2))]\n        [else (common\
    \ (rest l1) l2)]))\n", "  (let loop ((l1 l1)\n             (l2 l2)\n         \
    \    (l (list l1 l2)\n               (append l1 (append l2 l))\n             \
    \  (append l (append l1 l2))))\n    (cond\n      [(null? l) l]\n      [(null?\
    \ l2) l]\n      [(equal? (first l) (first l2)) l]\n      [else (loop (rest l1)\
    \ (rest l2) l)]))))\n", "  (sort (remove-duplicates \n         (for ([e (map car\
    \ (unions l1 l2))])\n             (member e l1)))\n        less/less))\n</code>\n\
    <|/ a tags=racket,racket-student-languages dscore=1 |>\n<| c |>\nThe `(sort ...)`\
    \ was unnecessary indeed, since `remove-duplicates` already does it for you, sorting\
    \ them lexicographically by the first element.\n<|/ c |>\n<| a dscore=0 |>\nIt\
    \ seems that your problem is to find the most frequent element in a list. Here\
    \ is an approach with map and frequencies \n<code>", "  (let loop ((l1 l1)\n \
    \            (l2 l2))\n    (if (null? l1) l2\n        (if (null? l2) l1\n    \
    \        (let ([e (first l1)]\n                  [e1 (second l1)])\n         \
    \     (if (not (member? e l2))\n                  (if (< e e1)\n             \
    \         (append l1 (list e))\n                      l1)\n                  (append\
    \ l2 (list e))\n                  l2))\n            (loop (rest l1)\n        \
    \          (rest l2)))\n        (loop (rest l1)\n              (rest l2)))))\n",
  "  (cond ((null? l1) l2)\n        ((null? l2) l1)\n        (else (cons (first l1)\n\
    \                   (common (rest l1) l2)))\n        ))\n</code>\n<|/ a tags=racket,scheme\
    \ |>\n<| c |>\nThanks for your effort. I was hoping to find a solution without\
    \ recursion, but I guess there is no way to avoid it.\n<|/ c |>\n<| c |>\nThe\
    \ solution does not use recursion. It's a straightforward implementation. I don't\
    \ see how you think it uses recursion.\n<|/ c |>\n<| c |>\nThanks for your answer.\
    \ While it might be an approach I might consider for a \"simple\" problem, this\
    \ approach is somewhat unintuitive in its approach. While it might look like it\
    \ makes use of a `fold` function, it actually uses recursion (which is why I posted\
    \ my question here). I didn't say that I think that it is recursion.\n<|/ c |>\n\
    <| c |>\nI see what you mean now. I thought you were talking about a solution\
    \ using `fold`. Thanks for the clarification.\n<|/ c |>\n<| c |>\n: I thought\
    \ you were talking about a solution using fold. My bad. Thanks for your help.\n\
    <|/ c |>\n<| a dscore=3 tags=racket,scheme |>\nYou can do it without a fold. \n\
    <code>", "  (let ((i (count-matches l1 l2)))\n    (cond ((< i 0)\n           (error\
    \ \"No common elements between ~s and ~s.\" l1 l2))\n          ((zero? i)\n  \
    \         (cons l1 (reverse l2))))\n    (cons (first l1 (sub1 i))\n          (common\
    \ (sub1 l1 (sub2 i))\n                   (sub2 l2 (sub3 i))))))\n", "  (define\
    \ (common-helper l1 l2)\n    (cond\n      [(null? l1) l2]\n      [(null? l2) l1]\n\
    \      [(equal? (car l1) (car l2)) (common-helper (cdr l1) (cdr l2))]\n      [else\
    \ (append (list (car l1)) (list (car l2))])]))\n  (common-helper l1 l2))\n", " \
    \ (define (iter list1 list2)\n    (if (empty? list1)\n        '()\n        (if\
    \ (equal? (first list1) (first list2))\n            (cons (first list1) (iter\
    \ (rest list1) (rest list2)))\n            (iter (rest list1) (rest list2)))))\n\
    \  (iter l1 l2))\n</cell>\n<text>\nLists And Arithmetic\nRacket has a number of\
    \ different ways to do arithmetic with lists.  One of the more straightforward\
    \ is the (+) operator which adds a single item to a list.  The other is the (++)\
    \ operator which prepends a single item to a list.  In all cases, we can use the\
    \ (list) function to convert a list to a sublist.  This can make some code more\
    \ readable in some cases.  For example:\n\n\n</text>\n<cell>\n#lang racket", " \
    \ (cond ((null? l1) l2)\n        ((null? l2) l1)\n        (else (let ((x (caar\
    \ l1)) (y (caar l2)))\n                 (if (equal? (car l1) (car l2))\n     \
    \                (common (cdr l1) (cdr l2))\n                     (if (< (car\
    \ l1) (car l2))\n                         (append (list (car l1)) (common l1 (cdr\
    \ l1)))\n                         (append (list (car l2)) (common l2 (cdr l2)))))))))\n",
  "  (sort (remove (set l1) l2) <))\n</code>\n<|/ a |>\n<| c |>\nFor an explanation\
    \ as to why the list comprehension works in your answer, see [my answer](https://stackoverflow.com/a/67006905/13),\
    \ which basically boils down to \"it works by sorting the input lists then discarding\
    \ duplicates\"\n<|/ c |>\n<| a tags=racket,list,common-lisp |>\nIn Racket:\n<code>",
  "  (if (null? l1)\n      l2\n      (if (member (first l1) l2)\n          (common\
    \ (rest l1) l2)\n          (common (first l1) (rest l2))))))\n</code>\n<|/ a dscore=4\
    \ |>\n<| c |>\nNice recursive solution. Though I wouldn't recommend using it for\
    \ larger lists. A simple `fold` will suffice and will still be efficient for longer\
    \ lists.\n<|/ c |>\n<| c |>\nThanks, I didn't know about fold. Would you mind\
    \ explaining how this works?\n<|/ c |>\n<| c |>\n: For a `fold`, it's worth understanding\
    \ what the base case is. If `l1 `is empty and `l2` isn't, you return the list\
    \ `l2`. Otherwise, you can compare `(l1 (first l1))` with `l2`. If `(l1 (first\
    \ l1))` is found in `l2`, you return the list `l1` without it. If it's not found,\
    \ you return the list `l1` with the first element of `l2` appended. Since `l1`\
    \ is not empty, you're guaranteed that `l1` will have at least one element (the\
    \ last one in `l2`). That last step is what makes `fold` a good solution. `fold`\
    \ is one of the most powerful tools in Racket.\n<|/ c |>\n<| a tags=scheme,racket\
    \ dscore=4 |>\n<code>", "  (cond ((null? l1) l2)\n        ((null? l2) l1)\n  \
    \      (else (let ((a (append (reverse l1) l2))\n                   (b (append\
    \ l1 reverse l2)))\n              (cond\n                ((> a (length b))\n \
    \                (append (take-last (length a) a) b))\n                (#t '())))))\n",
  "  (sort (remove-duplicates l1 l2) subst))\n", "  (sort (remove-duplicates \n  \
    \        (map (lambda (e) \n                 (if (> (car e) (car l2)) \n     \
    \                (cdr e) \n                     (car e) \n                   ))\
    \ \n          l1 \n          ) \n        >\n          >\n          <))\n</code>\n\
    <|/ a tags=racket,scheme,functional-programming dscore=2 |>\n<| c |>\nHow is this\
    \ better than the answer from Oscar? I thought it was just a different way of\
    \ doing things (perhaps slightly more efficient).\n<|/ c |>\n<| c |>\nIt does\
    \ a lot more. My answer gives you the unique elements in the shorter list, and\
    \ sorts them.\n<|/ c |>\n<| a dscore=2 |>\nYou can write this in one line, but\
    \ it is not very readable (compared to your solution):\n<code>", "  (let loop\
    \ ((l1 l1) (l2 l2))\n    (cond\n      [(empty? l1) l2]\n      [(empty? l2) l1]\n\
    \      [(equal? (car l1) (car l2)) (loop (cdr l1) (cdr l2))]\n      [else (cons\
    \ (car l1) (loop (cdr l1) l2))])))\n</code>\n<|/ a tags=racket,lisp,scheme |>\n\
    <| c |>", "  (let loop ([l1 l1 (reverse l1) l2]\n             [l2 l2 (reverse\
    \ l2) (cons (car l1) l2)])\n    (cond ((null? l1) l2)\n          ((null? l2) l1)\n\
    \          ((null? (cdr l1)) (car l2))\n          ((null? (cdr l2)) (car l1))\n\
    \          (else (loop (cdr l1) (cdr l2) (cdr (car l1) l2))))))\n", "  (cond\n\
    \    [(null? l1) l2]\n    [(member (first l1) l2) (first (common l2 (rest l1)))]\n\
    \    [(member (first l2) l1) (first (common l1 (rest l2)))]))\n", "  (let ((g\
    \ (lambda (x y)\n            (let ((p (eql x y)))\n              (cond\n     \
    \         [(not p) (if (eql x y) (cons x y) '())]\n              [p '()]\n   \
    \           [else '()])))\n        (t '()))\n    (if (eql l1 '())\n        t\n\
    \        (let ((c (car l1))\n              (e (first l2)))\n          (if (eql\
    \ l2 '())\n              t\n              (let ((c (car l2))\n               \
    \     (e (first l1)))\n                (if (or (eql e '())\n                 \
    \        (eql g (car c) e))\n                    t\n                    (cons\
    \ e (g (car c) e)))))))))\n", "  (sort (remove-duplicates #(if (eq? (first %1)\
    \ (first %2)) (second %1) %2)\n                            l1)\n        #'<))\n\
    </code>\n<|/ a tags=common-lisp,racket dscore=4 |>\n<| c |>\n`setq` has already\
    \ been declared as `setq!`, but it isn't the same thing.\n<|/ c |>\n<| c |>\n\
    Thanks for the clarification.  I thought I knew what I was talking about and assumed\
    \ it was the same thing.  I corrected my answer.\n<|/ c |>\n<| a dscore=3 |>\n\
    Here is a simple way to do it.\n<code>\n#lang racket\n", "  (let ((len1 (length\
    \ l1))\n        (len2 (length l2)))\n    (cond [(= len1 0)\n           l2]\n \
    \         [(= len2 0)\n           l1]\n          [else (let ((lc (list '()))\n\
    \                       (i (0 1)))\n               (while i < (+ len1 len2)\n\
    \                 (cond\n                 [(= i (+ len1 len2))\n             \
    \      (cons (first lc) (common l2 (rest lc)))]\n                 [(< i (+ len1\
    \ len2))\n                   (cons (first l1) (common l2 (rest lc)))]\n      \
    \           [else (let ((c (first lc))\n                            (s1 (common\
    \ l2 (rest lc)))\n                            (s2 (common l1 (rest lc))))\n  \
    \                 (if (equal? c s2)\n                       (cons c (cons s1 lc))\n\
    \                       (cons c (cons (first lc) (cons s2 lc))))])])]))", "  (sort\
    \ (set-intersect (sort l1) (sort l2))))\n", "  (cond [(empty? l1) l2]\n      \
    \  [(empty? l2) l1]\n        [(member (first l1) l2)\n         (common (rest l1)\
    \ l2)]\n        [else (common (rest l1) l2)]))\n", "  (remove-if\n   (lambda (x)\n\
    \     (not (member x l2)))\n   l1))\n", "  (cond [(null? l1) l2]\n        [(member\
    \ (first l1) l2) (common (rest l1) l2)]\n        [else (common (rest l1) l2)]))\n",
  "  (cond\n    [(null? l1) l2]\n    [(null? l2) l1]\n    [(equal? (first l1) (first\
    \ l2))\n     (common (rest l1) (rest l2))]\n    [else\n     (append (first (first\
    \ l1)) \n             (common (rest l1) l2))]))\n", "  (cond\n    [(empty? l1)\
    \ l1]\n    [(empty? l2) l2]\n    [(equal? (first l1) (first l2)) (cons (first\
    \ l1) (common (rest l1) (rest l2)))]\n    [else (common (rest l1) (rest l2))]))\n",
  "  (sort (remove-duplicates \n          (filter (lambda (x) (member? x l1) l2))\n\
    \          l1))\n  )\n", "  (sort (set-diff (set-intersection l1 (sort l2)) l1))\n\
    \  )\n", "  (sort (list l1 l2)\n        (lambda (x y)\n          (< (first x)\
    \ (y) (second x)))))\n", "  (cond [(null? l1) l2]\n        [(null? l2) l1]\n \
    \       [(equal? (first l1) (first l2)) (common (rest l1) (rest l2))]\n      \
    \  [else (cons (first l1) (common (rest l1) (rest l2)))]))\n", "  (cond\n    [(empty?\
    \ l1)(empty? l2)'()]\n    [(empty? l2) (append (first (rest l1)) (first (rest\
    \ l2)))'()]\n    [else (append (first (rest l1)) (first (common l2 (rest l2))))]\n\
    \    ))\n", "  (cond\n    [(empty? l1) l2]\n    [(empty? l2) l1]\n    [(member\
    \ (first l1) l2) (first (common (rest l1) l2))]\n    [else (common (rest l1) l2)]))\n",
  "  (apply append (sort (map cadr l1)) (sort (map cadr l2))))\n", "  (set! result\
    \ '())\n  (cond [(empty? l1) l1]\n        [(empty? l2) l2]\n        [(equal? (first\
    \ l1) (first l2)) (cons (first l2) result)]\n        [else (common (rest l1) (rest\
    \ l2))]))\n</code>\n<|/ a |>\n<| c |>\nWhy do you use `set!`? It will cause many\
    \ problems. Why not simply use `result`?\n<|/ c |>\n<| c |>\n, yes, of course.\
    \ I just wanted to make minimal changes to the OP's code, not to correct all the\
    \ mistakes.\n<|/ c |>\n<| c |>\nOk, it looks like you're trying to fix the code\
    \ in the question. I thought you were trying to fix the code from the answer.\
    \ My bad.\n<|/ c |>\n<| c |>\n, I'm sorry, I thought that OP had written it, but\
    \ he changed his minds. I made a mistake with the second case (in the question,\
    \ now corrected). Now the answer doesn't make sense. My fault.\n<|/ c |>\n<| c\
    \ |>\nNothing wrong with answering questions when you see other people's solutions.\n\
    <|/ c |>\n<| a tags=racket,lisp,common-lisp,scheme dscore=3 |>\n<code>", "  (sort\
    \ (remove-duplicates \n          (sort l1 (lambda (x y) (< (first x) y))\n   \
    \              (sort l2 (lambda (x y) (< (first y) x)))))))\n", "  (let ([f (lambda\
    \ (c1 c2) (< (first c1) (first c2)))])\n    (filter (lambda (c) (f c l1)) l2)))\n",
  "  (remove-if (lambda (e) (or (equal? e l1) (equal? e l2))) l2))\n", "  (sort (set\
    \ l1) (lambda (x y) (< (length x) \n                                     (length\
    \ y)))\n         #:key (lambda (x) (first x))\n         #:ordering reverse \n\
    \         #:stable))\n", "  (sort-uniq (remove-if (lambda (x) (equal? (first l1)\
    \ (first x))) (remove-if (lambda (x) (equal? (first l2) (first x))) l1)) l2))\n\
    </code>\nThe first two functions remove-if and sort-uniq are from the answers\
    \ posted here and here.\n<|/ a |>\n<| c |>\nIt might help to define `remove-if`\
    \ as `(define (remove-if pred lst) (filter (lambda (x) (not (pred x))) lst))`.\n\
    <|/ c |>\n<| c |>\nGood idea, I've added it to the answer.\n<|/ c |>\n<| a tags=racket,scheme\
    \ |>\n<code>", "  (sort (remove #(equal? (first %) (car %)) l1)\n        (remove\
    \ #(equal? (first %) (car %)) l2)\n        '()))\n</code>\n<|/ a dscore=1 tags=racket,common-lisp,lisp,list\
    \ |>\n<| c |>\nOkay, so I added some code to my answer, which seems to work correctly.\
    \ Hope it helps you.\n<|/ c |>\n<| c |>\nThanks, I'll try it out. :)\n<|/ c |>\n\
    <| c |>\nYou really don't need the two `remove` calls. Just use `remove-if`.\n\
    <|/ c |>\n<| c |>\nOh, didn't know that, thanks! I've updated the answer with\
    \ the improved code.\n<|/ c |>\n<| a |>\nIf your lists are sorted, you can use\
    \ the built-in sort procedure:\n<code>", "  (cond\n    ((empty? l1) l2)\n    ((member\
    \ #t (distinct l1 l2)) (sort l1 l2))\n    (else (cons (first l1) (common (rest\
    \ l1) l2)))))\n", "  (cond\n    ((null? l1) l2)\n    ((null? l2) l1)\n    ((equal?\
    \ (car l1) (car l2)) (common (cdr l1) (cdr l2)))\n    (else (cons (car l1) (common\
    \ (cdr l1) (cdr l2))))))\n", "  (define (helper l1 l2)\n    (cond [(empty? l1)\
    \ l2]\n          [(empty? l2) l1]\n          [else (cond\n                  [(equal?\
    \ (first l1) (first l2))\n                   (helper (rest l1) (rest l2))]\n \
    \                 [(equal? (first l2) (first l1))\n                   (helper\
    \ (rest l2) (rest l1))]\n                  [else (cons (first l1) (helper (rest\
    \ l1) (rest l2)))]))])\n  (helper l1 l2))\n</cell>\n<code language=dyalog-kernel>\n\
    #lang racket\n", "  (define (sort l1 l2)\n    (if (null? l1)\n        (if (null?\
    \ l2)\n            l2\n            (cons nil l2))\n        (let ((c1 (car l1))\n\
    \              (c2 (car l2)))\n          (if (eq? c1 c2)\n              (sort\
    \ (cdr l1) l2)\n              (if (< (car l1) (car l2))\n                  (cons\
    \ (car l1) (sort (cdr l1) l2))\n                  (cons (car l2) (sort l1 (cdr\
    \ l2))))))))\n  (sort l1 l2))\n", "  (cond\n    ((null l1) l2)\n    ((null? l2)\
    \ l1)\n    ((equal? (first l1) (first l2)) (second l1) (second l2))\n    (else\
    \ (append (common l1 (rest l1)) l2))))\n", "  (cond\n    ((null? l1) l2)\n   \
    \ ((null? l2) l1)\n    (else (let ((c1 (car l1))\n               (c2 (car l2))\n\
    \               (rest1 (cdr l1))\n               (rest2 (cdr l2))\n          \
    \     (rest1 (common (rest l1) rest1))\n               (rest2 (common (rest l2)\
    \ rest2)))\n          (if (equal? (c1 c2) true)\n              (recur rest1 rest2)\n\
    \              (if (equal? (c1 c2) true)\n                  (recur (rest rest1)\
    \ rest2)\n                  (recur (rest rest1) (rest rest2))))))))\n", "  (cond\n\
    \    ((null? l1) l2)\n    ((null? l2) l1)\n    ((equal? (first l1) (first l2))\
    \ (second l1) (second l2))\n    (else (common l1\n                 (remove l1\
    \ l2)))))\n", "  (cond\n    [(empty? l1 l2) '()]\n    [(not (member l1 (rest l2)))\
    \ (cons l1 (common (rest l1) l2))]\n    [else (common (rest l1) l2)]))\n", " \
    \ (sort (unique (remove-duplicates l1) (remove-duplicates l2))))\n", "  (let ([len1\
    \ (length l1)])\n    (let ([len2 (length l2)])\n      (cond [(= len1 len2) (return\
    \ l1)]\n            [(< len1 len2) (return l1)]\n            [else (common (subseq\
    \ l1 0 len1) (subseq l2 0 len2))])))\n  (if (= len1 (length l2)) (return-from\
    \ common l1)\n      (cond [(< len1 (length l2)) (return-from common l1)]\n   \
    \         [else (common l1 (subseq l2 0 len2))])))\n  ", "  (sort (distinct (sort-merge\
    \ l1 l2)) '<))\n", "  (sort (remove-duplicates \n          (cons (first (sort\
    \ l1)) (remove-duplicates \n                                            (cons\
    \ (first (sort l2)) l1))))\n        >\n        >\n        >\n        (cons (first\
    \ (sort l1)) (remove-duplicates \n                                           \
    \ (cons (first (sort l2)) l1)))))\n", "  (cond\n    [(empty? l1 l2) ()]\n    [(empty?\
    \ l2 l1) ()]\n    [else (if (equal? (first l1) (first l2))\n              (cons\
    \ (first l1) (common (rest l1) (rest l2)))\n              (if (equal? (first l1)\
    \ (rest l2) (common (rest l1) (rest l2)))\n                  (common (rest l1)\
    \ (rest l2)))))]))\n", "  (sort (remove l1 l2))\n  )\n", "  (let ([x (first l1)\n\
    \t   y (first l2)])\n    (cond [(equal? x y) '()]\n          [(equal? x '())\n\
    \           (cons y l2)]\n          [(equal? '() y)\n           (cons x l1)]\n\
    \          [else\n           (let ([x (common x y)])\n             (cons x (common\
    \ y x))])])))\n", "  (sort (remove-duplicates (remove-if #(< (first %1) (first\
    \ %2)) l1)) l2))\n", "  (if (null? l1)\n      l2\n      (let ([cur (car l1)]\n\
    \            [rest (cdr l1)])\n        (cond [(< cur rest) (common cur rest)]\n\
    \              [else (cons (car l1) (common rest l2))])))) ; #lang racket\n",
  "  (filter\n   (lambda (x) (member x l2))\n   (set l1)))\n</code>\nAnd here is a\
    \ little more generic version:\n<code>", "  (cond\n    [(empty? l1) l2]\n    [(empty?\
    \ l2) l1]\n    [(cons? l1 (rest l1)) (cons l1 (common l1 (rest l2)))]\n    [(cons?\
    \ l2 (rest l2)) (cons l2 (common l1 (rest l2)))]\n    [else (cons (first l1) (common\
    \ l1 (rest l2)))]\n  )\n)", "  (cond\n    [(empty? l1) l2]\n    [(empty? l2) l1]\n\
    \    [else\n     (let ([head (first l1)]\n           [tail (common (rest l1) l2)])\n\
    \       (cond\n         [(member head tail) (cons (first l1) (common tail (rest\
    \ l2)))]\n         [else (common tail (rest l1))])))]))\n</code>\n<|/ a dscore=1\
    \ |>\n<| c |>\nWhat is the advantage of using hash-tables for this? The code is\
    \ basically the same and even more inefficient, as you use recursion for both\
    \ search and adding to a hash-table (where hash-tables are inefficient).\n<|/\
    \ c |>\n<| c |>\n, hash-tables are faster than using recursion and for small lists,\
    \ they tend to run faster. Believe me, I've tried many different approaches to\
    \ this problem and have found that hash-tables run very fast (<1ms) even for large\
    \ lists. By the way, the code posted here is also very fast.\n<|/ c |>\n<| c |>\n\
    Thanks, I'll try this.  I was thinking about this problem and saw that it is essentially\
    \ a linked list problem with one more element in the head.  My mistake was to\
    \ think that common element was a linked list.\n<|/ c |>\n<| c |>\n, I tried your\
    \ solution with two lists: `(common '(1 2 3 4 5 6) (1 2 3 4 5 6 7 8))` and it\
    \ produced this result `'(1 2 3 4 5 6)`. I guess it is not correct because common\
    \ element should be between list1 and list2.\n<|/ c |>\n<| c |>\n, I have edited\
    \ my solution. It should be exactly what you are looking for.\n<|/ c |>\n<| a\
    \ |>\nIt's a little hard to tell what the output should be, but I think you want\
    \ a function that takes the two lists as input and returns the list of items that\
    \ are common to both.\nFirst, we'll need a function that returns true if a list\
    \ contains a given item:\n<code>", "  (cond\n    ((null? l1) l2)\n    ((null?\
    \ l2) l1)\n    ((equal? (first l1) (first l2)) (common (rest l1) (rest l2)))\n\
    \    (else (common (rest l1) l2))))\n", "  (let loop ((len1 length? l1)\n    \
    \         (len2 length? l2)\n             (l '()))\n    (cond ((or (< len1 len2)\n\
    \              (and (list? l1)\n                  (list? l2))\n              (and\
    \ (list? l2)\n                  (list? l1))))\n          ((and (list? l1)\n  \
    \            (list? l2))\n           (loop (rest l1)\n                  (rest\
    \ l2)\n                  (cons l l)))\n          ((and (list? l2)\n          \
    \    (list? l1))\n           (loop (rest l2)\n                  (rest l1)\n  \
    \                (cons l l)))\n          ((and (list? l1)\n              (list?\
    \ l2))\n           (loop (rest l1)\n                  (rest l2)\n            \
    \      (cons l l)))\n          (else\n           (cons l l)))))\n</code>\n<|/\
    \ a dscore=3 |>\n<| a tags=racket,scheme,lisp |>\nA simple approach:\n<code>",
  "  (cond\n    [(empty? l1) l1]\n    [(empty? l2) l2]\n    [else (if (equal? (first\
    \ l1) (first l2))\n              (common (rest l1) (rest l2))\n              (cons\
    \ (first l1) (common (rest l1) (rest l2)))\n             )\n           ]\n   )\n\
    \  )\n", "  (define (loop l1 l2)\n    (if (null? l1)\n        l2\n        (let\
    \ ((head (car l1))\n              (tail (cdr l1)))\n          (if (null? tail)\n\
    \              (cons head l2)\n              (loop (cdr head) (cons head l2))))))\n\
    \  (loop l1 l2))\n", "  (if (null? l1)\n      (reverse l2)\n      (if (null? l2)\n\
    \          l1\n          (if (equal? l2 (first l1))\n              (cons (first\
    \ l1) (common rest (rest l1)))\n              (cons (first l2) (common (rest l1)\
    \ (rest l2))))))))\n", "  (sort (remove-duplicates (cond [(empty? l1) l2]\n  \
    \                             [(empty? l2) l1]\n                             \
    \  [else (remove (first l1) l2)])))\n  )\n", "  (let loop ((l1 l1) (l2 l2) (unique\
    \ '()))\n    (cond\n      ((null? l1) l2)\n      ((null? l2) l1)\n      ((equal?\
    \ (car l1) (car l2)) (loop (cdr l1) (cdr l2) (cons (car l1) unique)))\n      (else\
    \ (loop (cdr l1) (cdr l2) unique))))))\n", "  (sort (remove-duplicates \n    \
    \     (remove-duplicates \n          (remove-duplicates \n           (remove-duplicates\
    \ l1 l2)\n           (remove-duplicates l2 l1))\n         l2))))\n", "  (if (null?\
    \ l1)\n      (if (null? l2)\n          ()\n          l2)\n      (if (equal? (first\
    \ l1) (first l2))\n          (common (rest l1) l2)\n          (common l1 (rest\
    \ l2)))\n      (append (sort (first l1) <)\n              (sort (first l2) <)\n\
    \              (common (rest l1) (rest l2)))\n      ))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
