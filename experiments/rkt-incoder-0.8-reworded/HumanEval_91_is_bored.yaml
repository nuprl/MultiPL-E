name: HumanEval_91_is_bored
language: rkt
prompt: "#lang racket\n\n;; You'll be given a string of words, and your task is to\
  \ count the number\n;; of boredoms. A boredom is a sentence that starts with the\
  \ word \"I\".\n;; Sentences are delimited by '.', '?' or '!'.\n;; For example:\n\
  ;; >>> (is_bored \"Hello world\")\n;; 0\n;; >>> (is_bored \"The sky is blue. The\
  \ sun is shining. I love this weather\")\n;; 1\n(define (is_bored S)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate is_bored))\n\
  \    (check-equal? (candidate \"Hello world\") 0)\n    (check-equal? (candidate\
  \ \"Is the sky blue?\") 0)\n    (check-equal? (candidate \"I love It !\") 1)\n \
  \   (check-equal? (candidate \"bIt\") 0)\n    (check-equal? (candidate \"I feel\
  \ good today. I will be productive. will kill It\") 2)\n    (check-equal? (candidate\
  \ \"You and I are going for a walk\") 0)\n))\n\n(test-humaneval)"
completions: ["  (if (string=? (substring S 0 3) \"I\")\n      (+ 1 (is_bored (substring\
    \ S 4 5))) (is_bored (substring S 1 3))))\n", "  (define (helper S n)\n    (cond\n\
    \      [(string=? (car S) 'I) (helper S (+ n 1))]\n      [(string=? (car S) '!)\
    \ (helper (cdr S) (+ n 1))]\n      [(string=? (car S) '?) (helper (cdr S) (+ n\
    \ 1))]\n      [else n]))\n  (helper S (0)))\n", "  (if (not (equal? (string->symbol\
    \ (car S)) \"I\"))\n      (+ 1 (is_bored (rest S))) 0))\n", "  (cond\n    [(empty?\
    \ S) #f]\n    [(equal? (first S) \"I\") #t]\n    [else #f]))\n", "  (let loop\
    \ ((S S) (n 0))\n    (cond\n      [(string=? (first S) \"I\") n]\n      [(null?\
    \ (rest S)) n]\n      [(loop (rest S) (+ n 1))]\n      [(loop (first S) (+ n 1))]\n\
    \      [(loop (rest S) n)]\n      [(loop S (+ n 1))]\n      [(loop S (+ n 1))]\n\
    \      [(loop (first S) n)]\n      [(loop (rest S) n)]\n      [(loop S (+ n 1))]\n\
    \      [(loop (first S) (+ n 1))]\n      [(loop (rest S) (+ n 1))]\n      [(loop\
    \ S (+ n 1))]\n      [(loop S (+ n 1))]\n      [(loop (first S) n)]\n      [(loop\
    \ (rest S) n)]\n      [(loop S (+ n 1))]\n      [(loop S (+ n 1))]\n      [(loop\
    \ S (+ n 1))]\n      [(loop S (+ n 1))]\n      [(loop S (+ n 1))]\n      [(loop\
    \ S (+ n 1))]\n      [(loop S (+ n 1))]\n      [(loop S (+ n 1))]\n      [(loop\
    \ S (+ n 1))]\n      [(loop S (+ n 1))]\n      [(loop S (+ n 1))]\n      [(loop\
    \ S (+ n 1))]\n      [(loop S (+ n 1))]\n      [(loop S (+ n 1))]\n      [(loop\
    \ S (+ n 1))]\n      [(loop S (+ n 1))]\n      [(loop S (+ n 1))]\n      [(loop\
    \ S (+ n 1))]\n      [(loop S (+ n 1))]\n      [(loop S (+ n 1))]\n      [(loop\
    \ S (+ n 1))]\n      [(loop S (+ n 1))]\n      [(loop S (+ n 1))]\n      [(loop\
    \ S (+ n 1))]\n      [(loop S (+ n 1))]\n      [(loop S (+ n 1))]\n      [(loop\
    \ S (+ n 1))]\n      [(loop S (+ n 1))]\n      [(loop S (+ n 1))]\n      [(loop\
    \ S (+ n 1))]\n      [(loop S (+ n 1))]\n      [(loop S (+ n 1))]\n      [(loop\
    \ S (+ n 1))]", "  (let ((boredom '()))\n    (do\n      (let ((current (first\
    \ S)))\n        (cond\n          ((eq? current 'I) (incf boredom))\n         \
    \ ((char=? (car S) '.') (incf boredom))\n          ((char=? (car S) '?') (incf\
    \ boredom))\n          ((char=? (car S) '!') (incf boredom))\n          ((eq?\
    \ '. current) (incf boredom))\n          ((eq? '? current) (incf boredom))\n \
    \         ((eq? '! current) (incf boredom))\n          ((eq? '. current) (incf\
    \ boredom))\n          ((eq? '? current) (incf boredom))\n          ((eq? '! current)\
    \ (incf boredom))\n          (else (return boredom)))))\n    boredom))\n", " \
    \ (cond [(empty? S) #f]\n        [(starts-with? (car S) \"I\") #t]\n        [else\
    \ #f]))\n", "  (match (string->list S) [(list \"I\" \".\" \".\" \".\" \"!\") #t\
    \ #f #f]))\n", "  (count-bored S \".?!\"))\n", "  (cond\n    [(equal? (first S)\
    \ \"I\") 0]\n    [(equal? (first S) \".\") 0]\n    [(equal? (first S) \"?\") 0]\n\
    \    [(equal? (first S) \"!\") 0]\n    [else 1]))", "  (cond [(empty? S) (empty?\
    \ #t)] [(equal? (first S) \"I\") true]\n        [else false]))\n", "  (cond [(string-prefix?\
    \ S \"I\") 1]\n        [else 0]))\n", "  (cond [(empty? S) #f]\n        [(equal?\
    \ S (substring S 0 (string-length S)))\n         (equal? (substring S (string-length\
    \ S)) \"I\") #t]\n        [else #f]))\n", "  (cond\n    ((string-match \"^I\"\
    \ S) 0)\n    ((string-match \"[.!?]\" S) 1)\n    (else (+ 1 (is_bored (substring\
    \ S 0 (string-match \"[.!?]\" S)))))\n  )\n)\n</code>\n<|/ a tags=racket,scheme,racket-student-languages\
    \ |>\n<| c |>\nHah, I remember this question (about string/regex) in my first\
    \ semester at Uni when I was learning Scheme. I'm glad I saw it!\n<|/ c |>\n<|\
    \ c |>\nI was thinking of a regex of `\"^I[.!?]\"` since this looks for \"I\"\
    \ followed by a full stop, \".\", \"!\", or \"?\". However this would be overkill\
    \ since `\"^I\"` would also find matches for \"I\" at the beginning of a string.\n\
    <|/ c |>\n<| c |>\nI thought about it, and came up with the expression `\"^I[.!?]\"\
    ` but then realized that `[.!?]` will find `.` and `!` in the middle of a string\
    \ and `[.!?]` is going to be more like `\".!?\"` since the `^` matches the beginning\
    \ of the string, meaning that the character class `[.!?]` will match `.`, `!`,\
    \ and `?`.\n<|/ c |>\n<| c |>\nOkay, I'm just not seeing how `\"^I[.!?]\"` will\
    \ match \"I\" at the beginning. \"^I\" will match \"I\" at the beginning of a\
    \ string, and \"[.!?]\" will match \".\" and \"!\" as well. The regex is fine\
    \ because \"^I\" will match \"I\" at the beginning of a string, so the \"[.!?]\"\
    \ will match \".\" and \"!\" as well and they will just be ignored.\n<|/ c |>\n\
    <| c |>\nNope, `\"^I\"` won't match \"I\" at the beginning of a string, because\
    \ that string doesn't begin with it.\n<|/ c |>\n<| a |>\nHere's a function that\
    \ does it.\n<code>\n#lang racket\n", "  (define (helper A B C)\n    (cond ((null?\
    \ C) 0)\n          ((equal? (car C) #\\.) 1)\n          ((equal? (car C) #\\?)\
    \ 1)\n          ((equal? (car C) #\\!) 1)\n          (else (helper (cdr A) B C))))\n\
    \  (helper S '() S))\n", "  (cond\n    [(empty? S) 0]\n    [(equal? #\\I (car\
    \ S)) 0]\n    [else 1]))\n", "  (cond\n    [(empty? S) #f]\n    [(starts-with?\
    \ (first S) \"I\") (+ 1 (is_bored (rest S)))]))\n", "  (cond\n    ((equal? S (substring\
    \ S 0 1)) 0)\n    ((equal? S (substring S 1 2)) \"?\") \n    ((equal? S (substring\
    \ S 2 3)) \"!\") \n    ((equal? S (substring S 0 2)) \"!\") \n    ((equal? S (substring\
    \ S 1 3)) \"?\"))))\n", "  (let ([T (explode-sentence S)]\n        [I 0]\n   \
    \     [! 0])\n    (cond [(empty? T) I]\n          [(equal? (first (first T)) \"\
    I\") (+ 1 (+ I 1))]\n          [(equal? (first (first T)) \"!\") (+ 1 (+ ! 1))]\n\
    \          [else (is_bored (first T))]))\n  )\n", "  (= (count-boredoms S) (length\
    \ (split S \".\" 0))))\n", "  (cond\n    ((string-equal? (substring S 0 2) \"\
    I\") 1)\n    ((string-equal? (substring S 0 2) \"!\")\n     (+ 1 (is_bored (substring\
    \ S 2 ))))\n    ((string-equal? (substring S 0 2) \".\")\n     (+ 1 (is_bored\
    \ (substring S 2 ))))\n    ((string-equal? (substring S 0 2) \"?\")\n     (+ 1\
    \ (is_bored (substring S 2 ))))\n    (else 0)))\n", "  (cond\n    ((eqv? S \"\
    I\") 0)\n    ((eqv? S \".\") 0)\n    ((eqv? S \"?\") 0)\n    ((eqv? S \"!\") 0)\n\
    \    (else (+ 1 (is_bored (substring S 0 (string-length S)))))))\n", "  (cond\
    \ [(string=? (substring S 0 1) \"I\") 0]\n        [(or (string=? (substring S\
    \ 0 1) \".\") (string=? (substring S 0 1) \"?\") (string=? (substring S 0 1) \"\
    !\")) 1]\n        [else 0]))\n", "  (cond\n    [(starts-with \"I\" S) 0]\n   \
    \ [else 1]))\n", "  (let loop ((bored 0) (ins 0))\n    (cond\n      [(eq (string-ref\
    \ S 0) \"I\")\n       (incf bored)\n       (loop (+ bored 1) (ins + 1))]\n   \
    \   [(eq (string-ref S 0) \".\") (incf bored)]\n      [(eq (string-ref S 0) \"\
    ?\") (incf bored)]\n      [(eq (string-ref S 0) \"!\")\n       (incf bored)\n\
    \       (loop (+ bored 1) (ins + 1))]\n      [else (incf bored)]))\n  (not bored))\n",
  "  (cond [(equal? (substring S 0 1) \"I\") 1]\n        [else 0]))\n", "  (match-count\
    \ S \"I\" 0))\n", "  (string-length (substring S 0 (string-match \"^I\" S))))\n",
  "  (cond\n    [(empty? S) 0]\n    [(equal? (first S) \"I\") (+ 1 0)]\n    [(equal?\
    \ (first S) \"?\") (+ 1 0)]\n    [(equal? (first S) \"!\") (+ 1 0)]\n    [else\
    \ (is_bored (rest S))]))\n", "  (if (string=? \"I\" S)\n      (add1 (count_boredoms\
    \ S)))\n  0)\n", "  (< (string-length S) 11)\n  (or (char= (char-ref S 0) ?i)\
    \ \n      (char= (char-ref S 0) ?!) \n      (char= (char-ref S 0) ?.')))\n", " \
    \ (or (starts-with? S \"I\") (starts-with? S \"!\") (starts-with? S \"?\")))\n",
  "  ;; Your code here\n  ;; (define is_bored (lambda (string) \n  ;;            \
    \           ; Your code here\n  ;;                       ;; (define is_bored (lambda\
    \ (string) \n  ;;                       ;;                         ; Your code\
    \ here\n  ;;                       ;;                         ;; (define is_bored\
    \ (lambda (string) \n  ;;                       ;;                           ;\
    \ Your code here\n  ;;                       ;;                           ;; (define\
    \ is_bored (lambda (string) \n  ;;                       ;;                  \
    \           ; Your code here\n  ;;                       ;;                  \
    \           ;; (define is_bored (lambda (string) \n  ;;                      \
    \ ;;                               ; Your code here\n  ;;                    \
    \   ;;                               ;; (define is_bored (lambda (string) \n \
    \ ;;                       ;;                                 ; Your code here\n\
    \  ;;                       ;;                                 ;; (define is_bored\
    \ (lambda (string) \n  ;;                       ;;                           \
    \        ; Your code here\n  ;;                       ;;                     \
    \              ;; (define is_bored (lambda (string) \n  ;;                   \
    \    ;;                                     ; Your code here\n  ;;           \
    \            ;;                                     ;; (define is_bored (lambda\
    \ (string) \n  ;;                       ;;                                   \
    \    ; Your code here\n  ;;                       ;;                         \
    \              ;; (define is_bored (lambda (string) \n  ;;                   \
    \    ;;                                         ; Your code here\n  ;;       \
    \                ;;                                         ;; (define is_bored\
    \ (lambda (string) \n  ;;                       ;;                           \
    \              ; Your code here\n  ;;                       ;;               \
    \                          ;; (define is_bored (lambda (string) \n  ;;       \
    \                ;;                                         ;; Your code here\n\
    \  ;;                       ;;                                         ;; (define\
    \ is_bored (lambda (string) \n  ;;                       ;;                  \
    \                       ;; Your code here\n  ;;                       ;;     \
    \                                    ;; (define is_bored (lambda (string) \n \
    \ ;;                       ;;                                         ;; Your\
    \ code here\n  ;;                       ;;                                   \
    \      ;; (define is_bored (lambda (string) \n  ;;                       ;;  \
    \                                       ;; Your code here\n  ;;              \
    \         ;;                                         ;; (define is_bored (lambda\
    \ (string) \n  ;;                       ;;                                   \
    \      ;; Your code here\n  ;;                       ;;                      \
    \                   ;; (define is_bored (lambda (string) \n  ;;              \
    \         ;;                                         ;; Your code here\n  ;; \
    \                      ;;                                         ;; (define is_bored\
    \ (lambda (string) \n", "  (let ((count 0))\n    (string->list (car S))\n    (cond\n\
    \      [(empty? S) count]\n      [(equal? \"I\" (car S)) (incf count)]))))\n</code>\n\
    For reference, here are some other ways to count boredoms more efficiently:\n\
    <code>", "  (string-match-p \"^I\" S))\n", "  (and (= (index 'i S) 0)\n      \
    \ (= (index '. S) 0)\n       (= (index '? S) 0)\n       (= (index '! S) 0)\n \
    \      (= (index (substring S 0 1) \"I\") 0)\n       (= (index (substring S 0\
    \ 1) \".\") 0)\n       (= (index (substring S 0 1) \"?\") 0)\n       (= (index\
    \ (substring S 0 1) \"!\") 0)\n       (= (index (substring S 0 1) \"I\") 0)\n\
    \       (= (index (substring S 0 1) \".\") 0)\n       (= (index (substring S 0\
    \ 1) \"?\") 0)\n       (= (index (substring S 0 1) \"!\") 0)\n       (= (index\
    \ (substring S 0 1) \"I\") 0)\n       (= (index (substring S 0 1) \".\") 0)\n\
    \       (= (index (substring S 0 1) \"?\") 0)\n       (= (index (substring S 0\
    \ 1) \"!\") 0)\n       (= (index (substring S 0 1) \"I\") 0)\n       (= (index\
    \ (substring S 0 1) \".\") 0)\n       (= (index (substring S 0 1) \"?\") 0)\n\
    \       (= (index (substring S 0 1) \"!\") 0)\n       (= (index (substring S 0\
    \ 1) \"I\") 0)\n       (= (index (substring S 0 1) \".\") 0)\n       (= (index\
    \ (substring S 0 1) \"?\") 0)\n       (= (index (substring S 0 1) \"!\") 0)\n\
    \       (= (index (substring S 0 1) \"I\") 0)\n       (= (index (substring S 0\
    \ 1) \".\") 0)\n       (= (index (substring S 0 1) \"?\") 0)\n       (= (index\
    \ (substring S 0 1) \"!\") 0)\n       (= (index (substring S 0 1) \"I\") 0)\n\
    \       (= (index (substring S 0 1) \".\") 0)\n       (= (index (substring S 0\
    \ 1) \"?\") 0)\n       (= (index (substring S 0 1) \"!\") 0)\n       (= (index\
    \ (substring S 0 1) \"I\") 0)\n       (= (index (substring S 0 1) \".\") 0)\n\
    \       (= (index (substring S 0 1) \"?\") 0)\n       (= (index (substring S 0\
    \ 1) \"!\") 0)", "  (let ((counts #{}))\n    (loop for x in\n          (cond ((string=?\
    \ (substring S 0 4) \"I\") (set! counts (add1 counts)))\n                (else\
    \ (set! counts (add1 counts))))\n         until (string=? (substring S 0 4) \"\
    .\")\n         collect counts)))\n", "  (let ([boredom (atom 0)])\n    (do-all-chars\n\
    \     ((c char)\n      (cond\n       ((char= c #\\I) (begin (set! boredom (+ 1\
    \ (char= c #\\I)))))))\n    S)\n    (bool (< boredom 0)))\n", "  (count-bored-words\
    \ S 'I 0))\n", "  (cond [(empty? S)            #f]\n        [(eq? (substring S\
    \ 0 3) \"I\")   #t]\n        [(eq? (substring S 0 3) \"He\") #f]\n        [(eq?\
    \ (substring S 0 3) \"Hi\") #f]\n        [(eq? (substring S 0 3) \"Hello\")  \
    \ #t]\n        [(eq? (substring S 0 3) \"he\")   #t]\n        [(eq? (substring\
    \ S 0 3) \"hi\") #f]\n        [(eq? (substring S 0 3) \"good\")   #t]\n      \
    \  [(eq? (substring S 0 3) \"well\") #f]\n        [(eq? (substring S 0 3) \"sun\"\
    )   #t]\n        [(eq? (substring S 0 3) \"sky\")   #t]\n        [(eq? (substring\
    \ S 0 3) \"blue\")   #t]\n        [(eq? (substring S 0 3) \"sun\")   #t]\n   \
    \     [(eq? (substring S 0 3) \"rain\") #f]\n        [(eq? (substring S 0 3) \"\
    love\") #f]\n        [(eq? (substring S 0 3) \"this\")   #t]\n        [(eq? (substring\
    \ S 0 3) \"weather\") #f]\n        [(eq? (substring S 0 3) \"and\")   #t]\n  \
    \      [else                  #f]\n        ))\n", "  (count\n   (filter (lambda\
    \ (s) (member s \"I\"))\n          (map #(concat \"I\" %) (string-split S #\"\
    .\")))))\n", "  (cond\n    [(member \"I\" S) (length (filter #(begins-with \"\
    I\" %) S))]\n    [else 0]))\n", "  (count_boredoms S (lambda (s) (eq? s \"I\"\
    ))))\n", "  (butlast\n   (map sentence-first-word\n       (sentences S))))\n",
  "  (cond [(empty? S) #f]\n        [(equal? (first S) \"I\") 1]\n        [(equal?\
    \ (first S) \"you\") 1]\n        [(equal? (first S) \"We\") 1]\n        [else\
    \ 0]))\n", "  (cond ((or (string-ref S 0) (string-ref S 1))\n         (string-match\
    \ \"I.*\" S))\n        (else 0)))\n", "  (cond\n    ((bored? S \"I\") 1)\n   \
    \ ((bored? S \".\") 1)\n    ((bored? S \"?\") 1)\n    ((bored? S \"!\") 1)\n \
    \   (else 0)))\n", "  (if (string=? (substring S 0 0) \"I\")\n      (+ 1 (length\
    \ S)))\n  0)\n", "  (and (string-equal? (substring S 0 1) \"I\")\n       (string-equal?\
    \ (substring S 1 2) \".\")\n       (string-equal? (substring S 3 4) \".\")\n \
    \      (string-equal? (substring S 5 6) \".\")\n       (string-equal? (substring\
    \ S 7 8) \".\")\n       (string-equal? (substring S 9 10) \".\")\n       (string-equal?\
    \ (substring S 11 12) \".\")\n       (string-equal? (substring S 13 14) \"!\"\
    )\n       (string-equal? (substring S 15 16) \"?\")\n       (string-equal? (substring\
    \ S 17 18) \"!\"))\n)\n", "  (let ((boredom-count 0))\n    (loop for sentence\
    \ S\n          for char = 'I' until (char-equal? char ?. ?? ?.) do\n         \
    \ (set! boredom-count (add1 boredom-count)))))\n", "  (cond (empty? S) 0\n   \
    \     (not (string=? \"I\" (car S))) (+ 1 (is_bored (cdr S))))\n        (else\
    \ 0))\n", "  (cond\n    [(equal? (first S) \"I\") 0]\n    [(equal? (first S) \"\
    !\") 0]\n    [(equal? (first S) \".\") 0]\n    [else 1]\n  ))\n", "  (match S\n\
    \    ((begin I)\n     (length S))\n    ((begin I (. .))\n     (length S))\n  \
    \  ((begin I (? ?))\n     (length S))\n    ((begin I (! !))\n     (length S))\n\
    \    ((begin I (. .) (? ?) (! !))\n     (length S))\n    ((begin I (. .) (? ?)\
    \ (! !) (. .))\n     (length S))\n    ((begin I (. .) (? ?) (! !) (. .) (? ?))\n\
    \     (length S))\n    ((begin I (. .) (? ?) (! !) (. .) (? ?) (. .))\n     (length\
    \ S))\n    ((begin I (. .) (? ?) (! !) (. .) (? ?) (. .) (. .))\n     (length\
    \ S))\n    ((begin I (. .) (? ?) (! !) (. .) (? ?) (. .) (. .) (. .))\n     (length\
    \ S))\n    ((begin I (. .) (? ?) (! !) (. .) (? ?) (. .) (. .) (. .) (. .))\n\
    \     (length S))\n    ((begin I (. .) (? ?) (! !) (. .) (? ?) (. .) (. .) (.\
    \ .) (. .) (. .))\n     (length S))\n    ((begin I (. .) (? ?) (! !) (. .) (?\
    \ ?) (. .) (. .) (. .) (. .) (. .))\n     (length S))\n    ((begin I (. .) (?\
    \ ?) (! !) (. .) (? ?) (. .) (. .) (. .) (. .) (. .))\n     (length S))\n    ((begin\
    \ I (. .) (? ?) (! !) (. .) (? ?) (. .) (. .) (. .) (. .) (. .))\n     (length\
    \ S))\n    ((begin I (. .) (? ?) (! !) (. .) (? ?) (. .) (. .) (. .) (. .) (.\
    \ .))\n     (length S))\n    ((begin I (. .) (? ?) (! !) (. .) (? ?) (. .) (.\
    \ .) (. .) (. .) (. .))\n     (length S))\n    ((begin I (. .) (? ?) (! !) (.\
    \ .) (? ?) (. .) (. .) (. .) (. .) (. .))\n     (length S))\n    ((begin ", " \
    \ (define (loop S count)\n    (cond\n      [(not (equal? (car S) \"I\")) (loop\
    \ (cdr S) count)]\n      [else (+ count 1)]\n      ))\n  (loop S 0))\n", "  (cond\n\
    \    [(empty? S) #t]\n    [(starts-with? \"I\" S) #t]\n    [(starts-with? \"!\"\
    \ S) #f]\n    [else #f]))\n", "  (define (helper prev sentence)\n    (cond\n \
    \     [(not (symbol=? (first sentence) 'I)) sentence]\n      [else (helper (cons\
    \ prev sentence) (rest sentence))]\n      ))\n  (helper null S)))\n", "  (cond\n\
    \    ((string=? (substring S 0 4) \"I\") 0)\n    ((string=? (substring S 0 3)\
    \ \"i\") 0)\n    ((string=? (substring S 0 2) \"you\") 0)\n    ((string=? (substring\
    \ S 0 2) \"you\") 1)\n    ((string=? (substring S 0 2) \"I\") 1)\n    ((string=?\
    \ (substring S 0 2) \"i\") 1)\n    ((string=? (substring S 0 2) \"I\") 1)\n  \
    \  ((string=? (substring S 0 2) \"i\") 1)\n    ((string=? (substring S 0 2) \"\
    you\") 1)\n    ((string=? (substring S 0 2) \"you\") 1)\n    ((string=? (substring\
    \ S 0 2) \"I\") 1)\n    ((string=? (substring S 0 2) \"i\") 1)\n    ((string=?\
    \ (substring S 0 2) \"I\") 1)\n    ((string=? (substring S 0 2) \"i\") 1)\n  \
    \  ((string=? (substring S 0 2) \"you\") 1)\n    ((string=? (substring S 0 2)\
    \ \"you\") 1)\n    ((string=? (substring S 0 2) \"I\") 1)\n    ((string=? (substring\
    \ S 0 2) \"i\") 1)\n    ((string=? (substring S 0 2) \"I\") 1)\n    ((string=?\
    \ (substring S 0 2) \"i\") 1)\n    ((string=? (substring S 0 2) \"you\") 1)\n\
    \    ((string=? (substring S 0 2) \"you\") 1)\n    ((string=? (substring S 0 2)\
    \ \"I\") 1)\n    ((string=? (substring S 0 2) \"i\") 1)\n    ((string=? (substring\
    \ S 0 2) \"I\") 1)\n    ((string=? (substring S 0 2) \"i\") 1)\n    ((string=?\
    \ (substring S 0 2) \"you\") 1)\n    ((string=? (substring S 0 2) \"you\") 1)\n\
    \    ((string=? (substring S 0 2) \"I\") 1)\n    ((string=? (substring S 0 2)\
    \ \"i\") 1)\n    ((string=? (substring S 0 2) \"I\") 1)\n    ((string=? (substring\
    \ S 0 2) \"i\") 1)\n    ((string=? (substring S 0 2) \"you\") 1)\n    ((string=?\
    \ (substring S 0 2) \"you\") 1)\n    ((string=? (substring S 0 2) \"I\") 1)\n\
    \    ((string=? (substring S 0 2) \"i\") 1)\n    ((string=? (sub", "  (or (char=?\
    \ (first S) 'I') (char=? (first S) '!') (char=? (first S) '.') (char=? (first\
    \ S) '?') ))", "  (cond\n    [(empty? S) 0]\n    [(starts-with? S \"I\") 1]\n\
    \    [else 0]))\n", "  (let loop ((i 0) (n 0))\n    (cond\n      [(eq? S \"\"\
    ) n]\n      [(eq? (char-code S) ?I) (incf n)]\n      [(eq? (char-code S) ?. )\
    \ (incf n)\n       (loop (+ i 1) n)\n       (loop (+ i 1) n)]\n      [(eq? (char-code\
    \ S) ?! ) (incf n)\n       (loop (+ i 1) n)\n       (loop (+ i 1) n)]\n      [else\
    \ (incf n)\n       (loop (+ i 1) n)]))\n  n)", "  (cond [(starts-with? S \"I\"\
    ) (length (filter #(begins-with? % \"I\") S))]\n        [else (length (filter\
    \ #(begins-with? % \".\") S))]))\n", "  (define (scan-to-bored S)\n    (cond [(string=?\
    \ (substring S 0 1)  \"I\")\n          (+ 1 bored)]\n          [else\n       \
    \    (bored 0)]))\n  (scan-to-bored S))\n", "  (define (loop i count)\n    (if\
    \ (char=? i #\\?) (incf count)\n      (if (char=? i #\\.) (loop (substring S i\
    \ 1) count)\n        (if (char=? i #\\.)\n          (loop (substring S i 1) (add1\
    \ count))\n          (loop (substring S i 1) count))))\n    count)\n  (loop 0\
    \ (if (char=? S #\\.) 1 0)))\n", "  (cond\n    [(starts-with? S (substring \"\
    I\" 0))         ;; (IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII",
  "  (cond [(string-match \"(^I.*)(\\.|\\.|!)(.*)\" (string->symbol S)) 3]\n     \
    \   [else 0]))\n", "  (match S\n    (((\"I\" \"are\") \".\") (1))\n    (((\"I\"\
    \ \"am\") \".\") (1))\n    (((\"I\" \"is\") \".\") (1))\n    (((\"I\" \"you\"\
    ) \".\") (1))\n    (((\"I\" \"are\") \"!\") (1))\n    (((\"I\" \"am\") \"!\")\
    \ (1))\n    (((\"I\" \"is\") \"!\") (1))\n    (((\"I\" \"you\") \"!\") (1))\n\
    \    ((_ \".\") (1))\n    ((_ \"!\") (1))\n    ((_ \"?\") (1))\n    ((_) (0))))\n",
  "  (if (string=? (first S) \"I\") (+ 1 (is_bored (rest S)))\n      (is_bored (rest\
    \ S))\n      0))\n", "  (let loop ((n 0)\n             (count '()))\n    (if (empty?\
    \ S)\n        (length count)\n        (let ((c (car S))\n               (rest\
    \ (cdr S)))\n          (cond ((eq? c (string-append \"I \" (string-append rest\
    \ \". \")))\n                 (loop (+ n 1) count))\n                ((eq? c (string-append\
    \ \"? \" (string-append rest \". \")))\n                 (loop (+ n 1) count))\n\
    \                ((eq? c (string-append \"! \" (string-append rest \". \")))\n\
    \                 (loop (+ n 1) count))\n                (else (loop (+ n 1)\n\
    \                           (cons (car S) count)))))))\n", "  (< (length S) 1)\n\
    \  (char-equal? (char-before-first-of S #\\?) #\\?)\n  (char-equal? (char-before-first-of\
    \ S #\\.) #\\.)\n  (char-equal? (char-before-first-of S #\\.) #\\?)\n  (= (char-before-first-of\
    \ S #\\.) #\\?)\n  (= (char-before-first-of S #\\.) #\\.)\n  (= (char-before-first-of\
    \ S #\\.) #\\!)\n  (= (char-before-first-of S #\\.) #\\.)\n  (char-equal? (char-before-first-of\
    \ S #\\.) '#\\!)\n  (char-equal? (char-before-first-of S #\\.) '#\\.)\n  (char-equal?\
    \ (char-before-first-of S #\\.) '#\\?)\n  (char-equal? (char-before-first-of S\
    \ #\\.) '#\\.)\n  (= (char-before-first-of S #\\.) '#\\?)\n  (= (char-before-first-of\
    \ S #\\.) '#\\.)\n  (= (char-before-first-of S #\\.) '#\\!)\n  (= (char-before-first-of\
    \ S #\\.) '#\\.)\n  1))\n", "  (- (string->length (substring S 0 1))\n     (string->length\
    \ (substring S 1 (string->length (substring S 2 0)))))\n", "  (cond [(equal? (car\
    \ S) 'I)\n         (+ (count_bored? (cdr S))\n            (count_bored? (cddr\
    \ S))\n            (count_bored? (cdddr S)))]\n        [else 0]))\n", "  (cond\
    \ [(empty? S) #f]\n        [(equal? (first S) \"I\") 1]\n        [(equal? (first\
    \ S) \".\") (is_bored (rest S))]\n        [(equal? (first S) ?) (is_bored (rest\
    \ S))]\n        [(equal? (first S) \"!\") (is_bored (rest S))]\n        [else\
    \ 0]))\n", "  (and (not (empty? S))\n       (and (equal? (first S) \"I\")\n  \
    \          (or\n             (equal? (rest S) \".\")\n             (equal? (rest\
    \ S) \"?\")\n             (equal? (rest S) \"!\")))))\n", "  (if (or (char=? (car\
    \ S) 'I') (char=? (car S) '.')\n          (char=? (car S) '?') (char=? (car S)\
    \ '!'))\n      (+ 1 (is_bored (rest S)))\n      0))\n", "  (cond [(empty? S) 0]\n\
    \        [(eq? 'I (car S)) 1]\n        [(eq? '.(car S)) (is_bored (cdr S))]\n\
    \        [(eq? '!(car S)) (is_bored (cdr S))]\n        [else (is_bored (cdr S))]))\n",
  "  (let ([I (substring (S 0) 0 1)]\n        [dot (substring (S 0) 1 1)]\n      \
    \  [question (substring (S 0) 2 1)]\n        [exclamation (substring (S 0) 3 1)]\n\
    \        [end (substring (S 0) 4 1)]\n        [len (length S)]\n        [I (char->integer?\
    \ I)])\n    (cond\n      [(and (not I) (not dot) (not question) (not exclamation)\
    \ (not end) (not len)) 0]\n      [(and (not I) dot (not question) (not exclamation)\
    \ (not end) (not len)) 1]\n      [(and (not I) question (not exclamation) (not\
    \ end) (not len)) 2]\n      [(and (not I) exclamation (not end) (not len)) 3]\n\
    \      [(and (not I) end (not len)) 4]\n      [(not I) 5]\n      [(not I) (char->integer?\
    \ dot)]\n      [(not I) (char->integer? question)]\n      [(not I) (char->integer?\
    \ exclamation)]\n      [(not I) (char->integer? end)]\n      [(not I) len]\n \
    \     [else (substring (S 0 len)) 0])))\n", "  (cond\n    [(empty? S) 0]\n   \
    \ [(equal? (first S) 'I) 1]\n    [else 0]))\n", "  (= (length (filter is-bored\
    \ S)) 0))\n", "  (cond\n    ((string-match-p \"^[I][^.!?]*\" S) 0)\n    ((string-match-p\
    \ \"^[^.!?]*[I][^.!?]\" S) 1)\n    ((string-match-p \"^[!?].+?[!?.]\" S) 0)\n\
    \    (else (error \"Not a valid sentence: ~a\" S))))\n", "  (match (string->list\
    \ S)\n    ['(\"I\")' 0]\n    ['(\"I.*\")' 1]\n    ['(.*\")' 1]\n    ['(\".*\"\
    )' 1]\n    ['(.*\\?.*\")' 1]\n    ['(\"\\W.*\")' 1]\n    ['(\"\\W\\W.*\")' 2]\n\
    \    ['(\"\\W\\W\\W.*\")' 3]\n    ['(\\W.*\\?.*\")' 1]\n    ['(\\W\\W.*\\?.*\"\
    )' 2]\n    ['(\\W\\W\\W.*\\?.*\")' 3]\n    ['(\\W.*\\!.*\")' 1]\n    ['(\\W\\\
    W.*\\!.*\")' 2]\n    ['(\\W\\W\\W.*\\!.*\")' 3]\n    ['(\\W.*\\?.*\\!.*\")' 1]\n\
    \    ['(\\W\\W.*\\?.*\\!.*\")' 2]\n    ['(\\W\\W\\W.*\\?.*\\!.*\")' 3]\n    ['(\\\
    W.*\\!.*\\?.*\")' 1]\n    ['(\\W\\W.*\\!.*\\?.*\")' 2]\n    ['(\\W\\W\\W.*\\!.*\\\
    ?.*\")' 3]\n    ['(.*\\?.*\\!.*\\?.*\")' 1]\n    ['(.*\\!.*\\?.*\\!.*\")' 2]\n\
    \    ['(.*\\!.*\\!.*\\?.*\")' 3]\n    ['(.*\\!.*\\!.*\\!.*\")' 4]\n    ['(.*\\\
    ?.*\\?.*\\?.*\")' 1]\n    ['(.*\\?.*\\?.*\\!.*\")' 2]\n    ['(.*\\?.*\\!.*\\?.*\"\
    )' 3]\n    ['(.*\\!.*\\?.*\\?.*\")' 4]\n    ['(.*\\!.*\\?.*\\!.*\")' 5]\n    ['(.*\\\
    ?.*\\?.*\\?.*\\?.*\")' 6]\n    ['(.*\\?.*\\?.*\\?.*\\!.*\")' 7]\n    ['(.*\\?.*\\\
    ?.*\\!.*\\?.*\")' 8]\n    ['(.*\\?.*\\!.*\\?.*\\?.*\")' 9]\n    ['(.*\\?.*\\!.*\\\
    ?.*\\!.*\")' 10]\n    ['(.*\\!.*\\?.*\\?.*\\?.*\")' 11]\n", "  (cond (empty? S)\
    \ 0\n        (string=? (first S) \"I\") 1\n        (else (is_bored (rest S)))))\n",
  "  (cond\n    [(= (length S) 0)\n     #f]\n    [(equal? (first S) \"I\")\n     (+\
    \ 1 (is_bored (rest S)))]))\n", "  (let ((w (car S)))\n    (cond\n      [(string=?\
    \ w \"I\") 1]\n      [(string=? w \".\") 0]\n      [(string=? w \"?\") 0]\n  \
    \    [(string=? w \"!\") 0]\n      [else (is_bored (cdr S))]))\n</code>\n<|/ a\
    \ tags=lisp,racket,functional-programming,scheme dscore=2 |>\n<| c |>\nIf `string=?`\
    \ is not available (it isn't in Racket by default), use `(equal? (car S) w)`.\n\
    <|/ c |>\n<| c |>\nNote that this can be made more efficient by just returning\
    \ the number of occurrences of `\"I\"`, since it can tell that `\"I\"` is in front\
    \ of `\"love\"` already, and can just decrement the count of `\"I\"` as it encounters\
    \ other words.  Also, it's worth mentioning that this can be made more efficient\
    \ by using a `hash-table` with a hash-key of `(car S)` and a value of `(+ 1 (cdr\
    \ S))`.  Since `hash-table` has O(1) lookup time, the overall running time is\
    \ `O(n + n) = O(n)`, not `O(n)`, as the `count-occurrence` function can be.\n\
    <|/ c |>\n<| a dscore=2 |>\nI like answers for this question, but I wanted to\
    \ give my take on the solution using hashes instead of recursion. My first thought\
    \ was to convert the list of strings to a list of pairs where each pair represented\
    \ a word and its number of occurrences, then use map to count the occurrences\
    \ of each word in the string - but then I realized that in racket we can use a\
    \ hash table to count the occurrences of each word without having to convert the\
    \ list of strings to a list of pairs.\n<code>\n#lang racket\n", "  (let loop ((S\
    \ S) (count 0))\n    (cond\n      [(equal? (string-ref S 0) \"I\") (+ count 1)]\n\
    \      [else (loop (rest S) (+ count 1))]))\n</code>\nThe string-ref function\
    \ finds the nth character of your string S at index n. So (string-ref S 0) returns\
    \ the first character of the string S, and string-ref S 1 returns the second character\
    \ of S, etc. You can read more about the string-ref function here. The rest function\
    \ takes two arguments: the first is the string S and the second is the start index.\
    \ So if you wanted to get the characters after the first 'I' in your string S,\
    \ you would use:\n<code>", "  (if (string-match \"^I\" S) #t\n      #f))\n", " \
    \ (define (go)\n    (cond\n      [(eq? S (string-match \"^I\" S)) 0]\n      [(string-match\
    \ \"\\\\.|!\" S) (add1 bored)]\n      [(string-match \"\\\\.|?\" S) (add1 question)]\n\
    \      [else (add1 bored)])\n    (if (string-match \"\\\\.|!\" S)\n        (go)\n\
    \        (go)))\n  (define (bored)\n    (add1 bored))\n  (define (question)\n\
    \    (add1 question))\n  (define (is-bored S)\n    (if (string-match \"\\\\.|!\"\
    \ S)\n        bored\n        question))\n  (is-bored S))\n", "  (cond [(equal?\
    \ (first S) \"I\") (count S 2)]\n        [else 0]))\n", "  (cond [(null? S) 0]\n\
    \        [(equal? (substring (first S) 0 1)\n                  \"I\") (+ 1 (is_bored\
    \ (substring (first S) 1 (string-length S))))]\n        [else 0]))", "  (let loop\
    \ ((bored-count 0))\n    (cond\n      [(empty? S) bored-count]\n      [(starts-with?\
    \ S \"I\") (inc! bored-count)]\n      [(member (car S) '.?!) (inc! bored-count)]\n\
    \      [(member (car S) '?.!') (inc! bored-count)]\n      [(member (car S) 'I')\
    \ (inc! bored-count)]\n      [(member (car S) '!') (inc! bored-count)]\n     \
    \ [else (loop (+ bored-count 1))]))\n  bored-count)\n</code>\n<|/ a dscore=2 |>\n\
    <| a |>\nFor a similar but different task, I used the following:\n<code>", " \
    \ (cond\n    [(empty? S) 0]\n    [(equal? (first S) 'I) (+ 1 (is_bored (rest S)))]))\n",
  "  (define (loop n s)\n    (if (empty? s)\n        (length s)\n        (loop (+\
    \ n 1) (rest s))))\n  (loop (count-if-not (lambda (s) (equal? (first s) 'I)))\
    \ S))\n", "  (let* ((word (car S))\n         (part (cadr S))\n         (count\
    \ 0))\n    (if (equal? word \"I\")\n        (set! count (+ count 1))\n       \
    \ (let ((next (substring (part 0) (+ 3 (string-length part)))) \n            \
    \   (next-part (substring (part 1) (+ 2 (string-length part))))) ; \"I.\"\n  \
    \        (cond\n            ((equal? next \".\") \n             (cond\n      \
    \         ((equal? next-part \"!\") \n                (set! count (+ count 1)))\
    \ ;; \"!.\"\n               ((equal? next-part \"?\") \n                (set!\
    \ count (+ count 0))) ;; \"?.\"\n               ((equal? next-part \".\") \n \
    \               (set! count (+ count 0))) ;; \".!\"\n               ((equal? next-part\
    \ \"!\") \n                (set! count (+ count 1))) ;; \"!?\"\n             \
    \  (else \n                (set! count (+ count 0))) ;; \".?\"\n             \
    \  ))\n            ((equal? next \"!\") \n             (cond\n               ((equal?\
    \ next-part \"!\") \n                (set! count (+ count 1))) ;; \"!.\"\n   \
    \            ((equal? next-part \"?\") \n                (set! count (+ count\
    \ 0))) ;; \"?.\"\n               ((equal? next-part \".\") \n                (set!\
    \ count (+ count 0))) ;; \".!\"\n               ((equal? next-part \"!\") \n \
    \               (set! count (+ count 1))) ;; \"!?\"\n               (else \n \
    \               (set! count (+ count 0))) ;; \".?\"\n               ))\n     \
    \       ((equal? next \"?\") \n             (cond\n               ((equal? next-part\
    \ \"!\") \n                (set! count (+ count 1))) ;; \"!.\"\n             \
    \  ((equal? next-part \".\") \n                (set! count (+ count 0))) ;; \"\
    .!\"\n               ((equal? next-part \"!\") \n                (set! count (+\
    \ count 1))) ;; \"!?\"\n               ((equal? next-part \".\") \n          \
    \      (set! count (+ count 0))) ;; \".?\"\n               (else \n          \
    \      (set! count (+ count 0))) ;; \".?\"\n               ))\n            (else\
    \ \n             (cond\n               ((equal? next-part \".\") \n          \
    \      (set! count (+ count 0))) ;; \".!\"\n", "  (match S\n    ((.) 0)\n    ((?)\
    \ 0)\n    ((!) 0)\n    ((!.) 0)\n    ((!?) 0)\n    ((!!) 0)\n    ((!!.) 0)\n \
    \   ((!??) 0)\n    ((!??.) 0)\n    ((!???) 0)\n    ((!???.) 0)\n    ((!????) 0)\n\
    \    ((!????.) 0)\n    ((!?????) 0)\n    ((!?????.) 0)\n    ((!??????) 0)\n  \
    \  ((!??????.) 0)\n    ((!???????) 0)\n    ((!???????.) 0)\n    ((!????????) 0)\n\
    \    ((!????????.) 0)\n    ((!?????????) 0)\n    ((!?????????.) 0)\n    ((!??????????)\
    \ 0)\n    ((!??????????.) 0)\n    ((!???????????) 0)\n    ((!???????????.) 0)\n\
    \    ((!????????????) 0)\n    ((!????????????.) 0)\n    ((!?????????????) 0)\n\
    \    ((!?????????????.) 0)\n    ((!??????????????) 0)\n    ((!??????????????.)\
    \ 0)\n    ((!???????????????) 0)\n    ((!???????????????.) 0)\n    ((!????????????????)\
    \ 0)\n    ((!????????????????.) 0)\n    ((!?????????????????) 0)\n    ((!??????????????????)\
    \ 0)\n    ((!???????????????????.) 0)\n    ((!????????????????????) 0)\n    ((!?????????????????????.)\
    \ 0)\n    ((!??????????????????????) 0)\n    ((!???????????????????????.) 0)\n\
    \    ((!????????????????????????.) 0)\n    ((!???????????????????????????.) 0)\n\
    \    ((!??????????????????????????????.) 0)\n    ((!??", "  (equal? (count-boredoms\
    \ S) 1))\n", "  (define (helper str boredoms)\n    (cond [(string-match \"I\"\
    \ str) #t]\n          [(string-match \".\" str) #t]\n          [(string-match\
    \ \"!\" str) #t]\n          [(string-match \"?\" str) #t]\n          [else (helper\
    \ (substring str 2)\n                       (+ boredoms 1))]))\n  (helper (substring\
    \ S 0) 0))\n", "  (define (is-bored x y)\n    (and (equal? (substring x 0) 'I)\
    \ (equal? (substring x 1) y)\n          (or (equal? (substring x 1) '.') (equal?\
    \ (substring x 1) '?') (equal? (substring x 1) '!'))))\n  (define (find-bored\
    \ x y)\n    (if (is-bored x y)\n        (+ 1 (find-bored (substring x 1) y)))\n\
    \    (find-bored x y))\n  (define (boredom-count S)\n    (if (null? S)\n     \
    \   0\n        (find-bored (substring S 0) '.')))\n  (boredom-count S))\n", " \
    \ (cond\n    [(empty? S) 0]\n    [(and (eql? (car S) \"I\") (= (car S) (cadr S)))\n\
    \     (+ 1 (is_bored (cdr S)))]\n    [else 0]))\n", "  (let ((count 0))\n    (for\
    \ [s (split S \"\\.\\?\\!\")\n           c (char s)\n           :while [c]]\n\
    \      (if (eq? (first c) \"I\")\n          (set! count (add1 count)))))\n  count)\n",
  "  (regexp-match (string->regexp \"^I\") S))\n", "  (cond (equal? (car S) \"I\"\
    ) (+ 1 (is_bored (cdr S)))))\n</code>\n<|/ a tags=racket,scheme dscore=2 |>\n\
    <| a tags=racket,scheme |>\nYou can just use count as you already did for is_bored\
    \ in the second example:\n<code>", "  (equal? (char-equal? (first S) #\\I) #\\\
    !))\n", "  (define (count-boredom S)\n    (if (string=? (first S) \"I\")\n   \
    \     (+ 1 (count-boredom (rest S)))\n        0))\n  (count-boredom S))\n</cell>\n\
    <code language=dyalog-kernel>\n#lang racket\n", "  (cond ((eq? (caar S) 'I) (+\
    \ 1 (is_bored (rest S))))\n        (else (is_bored (rest S))))\n)\n", "  (recognize\
    \ (lambda (s) (starts-with? s \"I\"))\n             S\n             #:starts-with?\
    \ \"I\"))\n", "  (and (= S (string->list \"I love\"))\n       (= S (string->list\
    \ \"!\"))\n       (= S (string->list \"?\"))\n       (= S (string->list \".\"\
    ))))\n", "  ;; This will be the list we build up\n  (define (is-bored lst)\n \
    \   ;; This will be the count we'll return at the end\n    (define count 0)\n\
    \    ;; This will be our return value\n    (define bored-found #f)\n    ;; If\
    \ the list is empty\n    (cond [(null? lst) #f]\n          ;; If we're at the\
    \ first element\n          [(not (member (first lst) '(\"I\"))) #f]\n        \
    \  ;; Otherwise, check whether it's a boredom sentence\n          [else (cond\
    \ (\n                  [(eq? (first lst) \"I\")\n                   ;; If so,\
    \ increment our count\n                  (set! count (add1 count))\n         \
    \         ;; And, set our flag\n                  (set! bored-found #t)]\n   \
    \               ;; Otherwise, keep going down\n                  [else (is-bored\
    \ (rest lst))]))]))\n  ;; And we're done if our flag was true (it never was in\
    \ the examples)\n  (is-bored S))", "  (cond [(string=? (string-ref S 0) \"I\"\
    )\n         (+ 1 (length (split-string (remove-char S \"I\") #\\. \"!?.\")))]\n\
    \        [else 0]))\n", "  (cond (string=? (first S) \"I\")\n        (string=?\
    \ (rest S) \".\") (count S))\n  (cond\n    ((string=? (first S) \".\") (count\
    \ S))\n    ((string=? (first S) \".\") (count S))\n    (else (count S))))\n",
  "  (let ((bored 0))\n    (map\n     (lambda (x)\n       (if (char=? (car x) 'I)\
    \ (add1 bored) bored))\n     (string->list S))\n    bored))\n", "  (= (rest (split\
    \ S #\\. #\\? #\\!)) \"I\"))\n", "  (or (string-match \"I \" (string S)) (string-match\
    \ \". \" (string S))\n      (string-match \"? \" (string S)) (string-match \"\
    ! \" (string S))))\n", "  (match (regexp-replace S (regexp-quote \"(I|\\.|!?)\
    \ \") \".\") '((I) (.) (!? (.)))\n      0\n      1\n      (#t 0)))\n", "  (cond\n\
    \    [(empty? S) #f]\n    [(eq? (first S) \"I\") #t]\n    [(eq? (first S) \".\"\
    ) #t]\n    [(eq? (first S) \"/\") #t]\n    [else (is_bored (rest S))]))\n", " \
    \ (= (length S) 0)\n  (let ((l (string-length (string-downcase S))))\n    (and\
    \ (char=? char '?) (= 0 (substring S 0 (+ l 1))))\n    (and (char=? char '!) (=\
    \ 1 (substring S 1 (+ l 1))))))\n", "  ;; TODO: Use match to find the first boredom\
    \ word.\n  (check-expect (length (match-pattern \"I\" S)) 0))\n", "  (define (helper\
    \ W T)\n    (cond\n      [(string? W) (helper W (append T T))]\n      [(string?\
    \ T) (helper W (append T '?))]))\n  (helper S '()))\n", "  (< (length (rest S))\
    \ 2)\n  (or (= (substring (first S) 0 1) \"I\")\n      (= (substring (first S)\
    \ 0 2) \"i.\")\n      (= (substring (first S) 0 3) \"!\"))\n  (and (= (substring\
    \ (first S) 0 2) \".\")\n       (= (substring (first S) 0 3) \"?\")))\n", "  (and\
    \ (not (null? S))\n       (char-equal? (char-code (first S)) #\\i)\n       (char-equal?\
    \ (char-code (first S)) #\\.)\n       (char-equal? (char-code (first S)) #\\?)\n\
    \       (char-equal? (char-code (first S)) #\\!)))\n", "  (define (Scan str)\n\
    \    (cond [(empty? str) 0]\n          [(equal? (first str) 'I) (+ 1 (Scan (rest\
    \ str)))]\n          [else (Scan (rest str))]))\n  (Scan S))\n", "  (if (string=?\
    \ (caar S)\n                \"I\")\n      1\n      0))\n", "  (cond\n    ((null?\
    \ S) 0)\n    ((equal? (car S) \"I\") (+ 1 (is_bored (cdr S)))\n    ((equal? (car\
    \ S) \"!\") (+ 1 (is_bored (cdr S)))\n    ((equal? (car S) \".\") (+ 1 (is_bored\
    \ (cdr S)))\n    ((equal? (car S) \".?\") (+ 1 (is_bored (cdr S)))\n    ((equal?\
    \ (car S) \"?\") (+ 1 (is_bored (cdr S)))\n    ((equal? (car S) \"!.\") (+ 1 (is_bored\
    \ (cdr S)))\n    ((equal? (car S) \"!?\") (+ 1 (is_bored (cdr S)))\n    ((equal?\
    \ (car S) \".!\") (+ 1 (is_bored (cdr S)))\n    ((equal? (car S) \"?!\") (+ 1\
    \ (is_bored (cdr S)))\n    ((equal? (car S) \"!.?\") (+ 1 (is_bored (cdr S)))\n\
    \    ((equal? (car S) \".!?\") (+ 1 (is_bored (cdr S)))\n    ((equal? (car S)\
    \ \".!.\") (+ 1 (is_bored (cdr S)))\n    ((equal? (car S) \"!?.\") (+ 1 (is_bored\
    \ (cdr S)))\n    ((equal? (car S) \"!?.!\") (+ 1 (is_bored (cdr S)))\n    ((equal?\
    \ (car S) \".!?.\") (+ 1 (is_bored (cdr S)))\n    ((equal? (car S) \".!?.!\")\
    \ (+ 1 (is_bored (cdr S)))\n    ((equal? (car S) \"?!.\") (+ 1 (is_bored (cdr\
    \ S)))\n    ((equal? (car S) \"?!.!\") (+ 1 (is_bored (cdr S)))\n    ((equal?\
    \ (car S) \"?!?.\") (+ 1 (is_bored (cdr S)))\n    ((equal? (car S) \"?!?.!\")\
    \ (+ 1 (is_bored (cdr S)))\n    ((equal? (car S) \"!?!.\") (+ 1 (is_bored (cdr\
    \ S)))\n    ((equal? (car S) \"!?!.!\") (+ 1 (is_bored (cdr S)))\n    ((equal?\
    \ (c", "  (let ([I (index 'I S)]) ;; returns first index of \"I\" inside S\n \
    \   (cond\n      [(< I 0) 0] ;; no \"I\" found\n      [(equal? (char-before-string-prefix\
    \ S (+ I 1)) 'I) 1] ;; \"I\" found\n      [(char-after-string-prefix S (+ I 1))\
    \ 0] ;; \"!\" or \"?\" found\n      [(char-after-string-prefix S (+ I 2)) 1] ;;\
    \ \".\" found\n      [(char-after-string-prefix S (+ I 3)) 1] ;; \"!\" found\n\
    \      [(char-after-string-prefix S (+ I 4)) 0] ;; \"?\" found\n      [(char-after-string-prefix\
    \ S (+ I 5)) 1] ;; \".\" found\n      [(char-after-string-prefix S (+ I 6)) 1]\
    \ ;; \"?\" found\n      [(char-after-string-prefix S (+ I 7)) 0] ;; \"!\" found\n\
    \      [(char-after-string-prefix S (+ I 8)) 1] ;; \".\" found\n      [(char-after-string-prefix\
    \ S (+ I 9)) 1] ;; \"!\" found\n      [(char-after-string-prefix S (+ I 10)) 0]\
    \ ;; \".\" found\n      [(char-after-string-prefix S (+ I 11)) 1] ;; \"?\" found\n\
    \      [(char-after-string-prefix S (+ I 12)) 0] ;; \"!\" found\n      [(char-after-string-prefix\
    \ S (+ I 13)) 1] ;; \".\" found\n      [(char-after-string-prefix S (+ I 14))\
    \ 1] ;; \"?\" found\n      [(char-after-string-prefix S (+ I 15)) 0] ;; \"!\"\
    \ found\n      [(char-after-string-prefix S (+ I 16)) 1] ;; \".\" found\n    \
    \  [(char-after-string-prefix S (+ I 17)) 1] ;; \"!\" found\n      [(char-after-string-prefix\
    \ S (+ I 18)) 0] ;; \".\" found\n      [(char-after-string-prefix S (+ I 19))\
    \ 1] ;; \"?\" found\n      [(char-after-string-prefix S (+ I 20)) 0] ;; \"!\"\
    \ found\n      [(char-after-string-prefix S (+ I 21)) ", "  (let ((bored #t))\n\
    \    (loop\n       for c (string-length (string-ref S 0))\n       while (or (=\
    \ 0 (string-ref S c)) (= c (string-length (string-ref S c)))\n              (and\
    \ (char=? (char-code ?i) (char-code ?i)) bored)\n              (set! bored #f))\n\
    \       collect bored)))\n", "  (let ((bored-state (make-bored-state S)))\n  \
    \  (when (bored? bored-state)\n      (set! bored-state (not bored-state)))))\n",
  "  (cond (equal? (first S) \"I\") #t\n        (equal? (rest S) \".\") #t\n     \
    \   (equal? (rest S) \"?\") #t\n        (equal? (rest S) \"!\")\n        #f\n\
    \        (else\n         (is_bored (rest S)))))\n", "  (equal? S (string-prefix?\
    \ \"I \" (string->list S))))\n", '  (= (length S) (count #\. (substring S 0 (string-length
    S)))))', "  (if (equal? (first S) \"I\")\n      (+ 1 (count-bored-sentences S))\n\
    \      0))\n", "  (cond\n    ((or (char-equal? (car S) ?.)\n         (char-equal?\
    \ (car S) !.))\n      0)\n    ((char-equal? (car S) ?.) (+ 1 (is_bored (cdr S))))\n\
    \    (else (is_bored (cdr S)))))\n</cell>\n<code language=dyalog-kernel>\n'hello?'\n\
    </cell>\n<code language=dyalog-kernel>\n'hello?' == 'hello'\n</cell>\n<code language=dyalog-kernel>\n\
    'hello?' == 'hello!?'\n</cell>\n<code language=dyalog-kernel>\n'hello?' == 'hello!'\n\
    </cell>\n<code language=dyalog-kernel>\n'hello?' == 'hello?'\n</cell>\n<code language=dyalog-kernel>\n\
    'hello?' == 'hello.!?'\n</cell>\n<code language=dyalog-kernel>\n'hello?' == 'hello.?'\n\
    </cell>\n<code language=dyalog-kernel>\n'hello?' == 'hello..?'\n</cell>\n<code\
    \ language=dyalog-kernel>\n'hello?' == 'hello...?'\n</cell>\n<code language=dyalog-kernel>\n\
    'hello?' == 'hello.!.'\n</cell>\n<code language=dyalog-kernel>\n'hello?' == 'hello.!.'\n\
    </cell>\n<code language=dyalog-kernel>\n'hello?' == 'hello.!.'\n</cell>\n<code\
    \ language=dyalog-kernel>\n'hello?' == 'hello.!.'\n</cell>\n<code language=dyalog-kernel>\n\
    'hello?' == 'hello.!.'\n</cell>\n<code language=dyalog-kernel>\n'hello?' == 'hello.!.'\n\
    </cell>\n<code language=dyalog-kernel>\n'hello?' == 'hello.!.'\n</cell>\n<code\
    \ language=dyalog-kernel>\n'hello?' == 'hello.!.'\n</cell>\n<code language=dyalog-kernel>\n\
    'hello?' == 'hello.!.'\n</cell>\n<code language=dyalog-kernel>\n'hello?' == 'hello.!.'\n\
    </cell>\n<code language=dyalog-kernel>\n'hello?' == 'hello.!.'\n</cell>\n<code\
    \ language=dyalog-kernel>\n'hello?' == 'hello.!.'\n</cell>\n<code language=dyalog-kernel>\n\
    'hello?", "  (number? (string->number (string-match-all #rx\"^I\" S :start1 0\
    \ :start2 1)))\n)\n", "  (length (filter (lambda (S)\n                    (and\
    \ (equal? (first S) \"I\")\n                         (equal? (rest S) \".\")))\n\
    \                  (explode-sentence S))))\n", "  (count\n   (lambda (x)\n   \
    \  (if (bored x)\n         (+ 1 (bored x))\n         0))\n   S))\n", "  (define\
    \ (helper T C) (if (char=? T '.)\n                           (helper (cdr T) C)\n\
    \                           (helper (cdr (cdr T)) C)))\n  (let ((bored 0))\n \
    \   (let ((T (helper S bored)))\n      (if (char=? T ?!)\n          bored\n  \
    \        (helper T (+ bored 1))))))\n", "  (let loop ((S S))\n    (if (empty?\
    \ S)\n        (if (equal? (first S) \"I\")\n            (+ 1 (loop (rest S)))\n\
    \            0))))\n", "  (cond\n    ((equal? (substring S 0 3) \"I\")\n     (+\
    \ 1 (is_bored (substring S 4)))) ; count number of boredoms\n    (else 0)))\n",
  "  (cond [(= 0 (string-match (substring S 0 2) \"I\"))\n         1]\n        [else\
    \ 0]))\n", "  (= (length S)\n     (string-match (substring S 0 1) \"[I]?\")))\
    \ ; match the first char and check it's an \"I\" ?\n", "  (= (length S)\n    \
    \ (if (equal? (substring S 0 1) \"I\")\n         (+ 1 (is_bored (substring S 1)))\n\
    \         (+ 0 (is_bored (substring S 2))))\n       0))\n", "  (cond\n    ((string-match?\
    \ S \"I\")\n     (+ 1 (length S)))\n    ((string-match? S \"[.!?]\")\n     (+\
    \ 1 (length S)))\n    (else\n     (+ 1 (string-length S)))))\n", "  (cond [(=\
    \ (length S) 0)  0]\n        [(starts-with? (car S) \"I\") 1]\n        [(starts-with?\
    \ (car S) \".\")  1]\n        [(starts-with? (car S) ?\"!\")  1]\n        [else\
    \  0]))\n", "  (and (equal? (car S) \"I\") (equal? (cdr S) \".\")))\n</code>\n\
    <|/ a dscore=0 tags=scheme,racket |>\n<| a tags=scheme,racket |>\n<code>\n#lang\
    \ racket\n", "  (count_bored-words S))\n", "  (< (count (starts-with S \"I\"))\n\
    \      (count (starts-with S \".\"))\n      (count (starts-with S \"?\"))\n  \
    \    (count (starts-with S \"!\"))))\n", "  (define (count-boredoms sent)\n  \
    \  (if (string=? (first sent) #\"I\")\n        (+ 1 (count-boredoms (rest sent)))))\n\
    \  (if (string=? (first S) #\"I\")\n      (+ 1 (count-boredoms (rest S)))))\n",
  "  (cond\n    [(eq? (caar S) 'I)\n     (length (filter (lambda (x) (equal? (car\
    \ S) x)) '(. . ?)))]\n    [(eq? (caar S) '!)\n     (length (filter (lambda (x)\
    \ (equal? (car S) x)) '(. . ?)))]\n    [(eq? (caar S) '?)\n     (length (filter\
    \ (lambda (x) (equal? (car S) x)) '(. . !)))]\n    [else 0]))\n", "  (let ((bored\
    \ 0))\n    (loop\n       for x across (string->list S) by (skip-chars-then-find\
    \ \"? . \")\n       when (string=? (char-to-string x) \"I\")\n       do (+ bored\
    \ 1))))\n", "  (define (helper S)\n    (cond ((equal? (first S) \"I\") 1) (else\
    \ (helper (rest S)))))\n  (helper S))\n", "  (let* ((words (explode S))\n    \
    \     (n (length (filter #(memq 'i %) (explode %)))))\n    (<= n 0) n))\n", " \
    \ (cond ((null? S) 0)\n        ((char= (car S) #\\I) (+ 1 (is_bored (rest S))))\n\
    \        (else (is_bored (rest S)))))\n</cell>\n<code language=dyalog-kernel>\n\
    #lang racket\n", "  (and (begins-with? S \"I\")\n       (or (ends-with? S \".\"\
    ) (ends-with? S \"?\") (ends-with? S \"!\")))\n  )\n", "  (< (length S) 3)\n \
    \ (char=? (substring S 0 1) \"i\"))\n", "  (length (filter (lambda (x) (equal?\
    \ (first x) 'I')) S)))\n", "  (define S (string->list S))\n  (define (helper N\
    \ L L L)\n    (if (null? L)\n        0\n        (if (equal? (string->char (car\
    \ L)) 'I)\n            (+ 1 (helper N (cdr L) L (cdr L)))\n            (helper\
    \ N (cdr L) L (cdr L)))))\n  (helper 0 S S S))\n", "  (let ((count 0))\n    (cond\n\
    \      [(equal? (first S) \"I\") (add 1 count)]\n      [else (add count (is_bored\
    \ (rest S)))])))\n", "  (cond ( (= (length S) 0)\n          #t)\n        ( (equal?\
    \ (char-after (first S) 'I')) #f)\n        ( (equal? (char-after (first S) '?')\
    \ #f)\n          #t)\n        ( (equal? (char-after (first S) '!') #f)\n     \
    \     #t)\n        (else #f)))\n", "  (cond\n    [(starts-with? S \"I\") 0]\n\
    \    [(equal? S \".\") 0]\n    [(equal? S \"!\") 0]\n    [else 1]))\n", "  (local\n\
    \    [(define (boredom P)\n       (if (string=? P \"I\")\n           (add1 (+\
    \ 1 (count (sentence P))))))\n     (define (sentence S)\n       (cut S \"[.!?]\"\
    )))\n   (boredom S))\n", "  (and (= (first S) 'I)\n       (string=? (rest S) \"\
    .\")\n       (string=? (rest S) \"?\")\n       (string=? (rest S) \"!\")))\n",
  "  (match S\n      [(\"\"     _)      0]\n      [(#\"I\" S) (1+ (is-bored S))]\n\
    \      [(_     _)      0]\n      [(_#\"\\.\" S)  0]\n      [(_#\"\\?\" S)  0]\n\
    \      [(_#\"\\!\" S)  0]\n      [(#\"\\.\" S) (is-bored S)]))\n", "  ;; Split\
    \ S into sentences by '.', '?' or '!'\n  (define S1 (sentences S))\n  ;; Count\
    \ the number of sentences that start with 'I'.\n  (define BORED (foldl boredom-count\
    \ 0 (mapcar boredom-count S1)))\n  (= BORED 0))\n", "  (let ((split-str (split-string\
    \ (sentence->list S)\n                                (lambda (A)\n          \
    \                        (or (char-equal? A '?)\n                            \
    \          (char-equal? A '!)\n                                      (char-equal?\
    \ A '.)))))\n        (boredoms  (map car\n                        (filter boredom?\n\
    \                                 (map car\n                                 \
    \    (map cons (split-str S))))))\n    (cond\n      [(empty? boredoms)       \
    \   0]\n      [(boredoms-ends? boredoms) 1]\n      [else                    0])))\n",
  "  (and (eq? (first S) \"I\") (equal? (rest S) \".\") (equal? (rest S) \"?\") (equal?\
    \ (rest S) \"!\")))\n", "  (let ([T (split-string S \"\\\\.?\")])\n    (if (null?\
    \ T)\n        0\n        (or (eq? (car T) \"I\")\n            (is_bored (cdr T))\n\
    \            (+ 1 (is_bored (car T)))))))\n", "  (if (not (equal? S \"\"))\n \
    \     (let ((word (first S)))\n        (if (and (equal? word \"I\") (equal? (rest\
    \ S) \"!\"))\n            1\n            (+ 1 (is_bored (rest S)))))\n      0))\n",
  "  (cond\n    [(empty? S) 0]\n    [(equal? (car S) 'I) (+ 1 (is_bored (cdr S)))]\n\
    \    [(equal? (car S) '.') (+ 1 (is_bored (cdr S)))]\n    [(equal? (car S) '?')\
    \ (+ 1 (is_bored (cdr S)))]\n    [(equal? (car S) '!') (+ 1 (is_bored (cdr S)))]\n\
    \    [else (is_bored (cdr S))]))\n", "  (cond [(null? S) 0]\n        [(equal?\
    \ (first S) \"I\") 1]))\n", "  (cond\n    ((and (string=? (first S) \"I\") (string=?\
    \ (second S) \".\")\n          (string=? (third S) \"?\") (string=? (fourth S)\
    \ \"!\"))\n     1)\n    ((and (string=? (first S) \".\") (string=? (second S)\
    \ \"?\")\n          (string=? (third S) \"!\") (string=? (fourth S) \".\"))\n\
    \     1)\n    ((and (string=? (first S) \".\") (string=? (second S) \"!\")\n \
    \         (string=? (third S) \".\") (string=? (fourth S) \"?\"))\n     1)\n \
    \   (else 0)))\n", "  (cond\n    [(or (not (string-starts-with? S \"I\"))\n  \
    \         (not (string-starts-with? S \"I.\")\n           (not (string-starts-with?\
    \ S \"?\"))\n           (not (string-starts-with? S \"!\"))) 0]\n    [else 1]))\n",
  "  (let ((count-boredoms 0))\n    (define (is-bored-helper S boredoms count)\n \
    \     (cond\n        ((eq? (substring S 0 1) boredoms)\n         (incf count))\n\
    \        (else (incf count)))\n    (string-match \"^I\" S)\n    (is-bored-helper\
    \ S \"?\" count-boredoms)\n    (is-bored-helper S \".\" count-boredoms)\n    (is-bored-helper\
    \ S \"!\" count-boredoms)))\n", "  (or (equal? (substring S 0 1) \"I\") ;; start\
    \ of \"I\"\n      (equal? (substring S 0 1) \"!\")) ;; start of \"!\"\n  (or (equal?\
    \ (substring S 0 2) \".\") ;; \".\"\n      (equal? (substring S 0 2) \"?\")))\
    \ ;; \"?\"\n  (or (equal? (substring S 0 3) \"!\") ;; \"!\"\n      (equal? (substring\
    \ S 0 3) \".\"))) ;; \".\"\n  (or (equal? (substring S 0 4) \"I\") ;; \"I\"\n\
    \      (equal? (substring S 0 4) \"!\")) ;; \"!\"\n  (or (equal? (substring S\
    \ 0 5) \".\") ;; \".\"\n      (equal? (substring S 0 5) \"?\"))) ;; \"?\"\n  (or\
    \ (equal? (substring S 0 6) \".\") ;; \".\"\n      (equal? (substring S 0 6) \"\
    ?\"))) ;; \"?\"\n  (or (equal? (substring S 0 7) \".\") ;; \".\"\n      (equal?\
    \ (substring S 0 7) \"?\"))) ;; \"?\"\n  (or (equal? (substring S 0 8) \".\")\
    \ ;; \".\"\n      (equal? (substring S 0 8) \"?\"))) ;; \"?\"\n  (or (equal? (substring\
    \ S 0 9) \"!\") ;; \"!\"\n      (equal? (substring S 0 9) \".\"))) ;; \".\"\n\
    \  (or (equal? (substring S 0 10) \".\") ;; \".\"\n      (equal? (substring S\
    \ 0 10) \"?\"))) ;; \"?\"\n  (or (equal? (substring S 0 11) \".\") ;; \".\"\n\
    \      (equal? (substring S 0 11) \"?\"))) ;; \"?\"\n  (or (equal? (substring\
    \ S 0 12) \".\") ;; \".\"\n      (equal? (substring S 0 12) \"?\"))) ;; \"?\"\n\
    \  (or (equal? (substring S 0 13) \".\") ;; \".\"\n      (equal? (substring S\
    \ 0 13) \"?\"))) ;; \"?\"\n  (or (equal? (substring S 0 14) \".\") ;; \".\"\n\
    \      (equal? (substring S 0 14) \"?\"))) ;; \"?\"\n  (or (equal? (substring\
    \ S 0 15) \".\") ;; \".\"\n      (equal? (substring S 0 15) \"?\"))) ;; \"?\"\n\
    \  (or (equal? (substring S 0 16) \".\") ;; \".\"\n      (equal? (substring ",
  "  (count\n   (lambda (s) (and (char=? (first s) 'I) (char=? (rest s) '.') (char=?\
    \ (rest s) '?') (char=? (rest s) '!'))\n    (split S '.?!'))))\n", "  (or (string=?\
    \ (substring S 0 2) \"I\") (string=? (substring S 0 2) \"!\") (string=? (substring\
    \ S 0 2) \".\") (string=? (substring S 0 2) \"?\") ))\n", "  (cond\n    ((empty?\
    \ S) 0)\n    ((eq? (char-lower-case (first S)) 'i) (+ 1 (is_bored (rest S))))\n\
    \    (else (is_bored (rest S)))))\n", "  (cond [(equal? (first S) \"I\") 1]\n\
    \        [else 0]))\n", "  (match (match-beginning \"I\" S)\n\t '() 0\n\t (_)\
    \ (+ 1)))\n", "  (< (string-length S) 2)\n  (string=? (substring S 0 1) \"I\"\
    ))\n", "  (define (Scan sentence sentence-index)\n    (cond\n      [(string=?\
    \ (substring sentence 0 sentence-index)\n                   \"I\") (+ 1 (Scan\
    \ sentence sentence-index))])\n    (Scan sentence (+ sentence-index 1))))\n  (Scan\
    \ S 0))\n", "  (or (char=? (char-type (char-after 'I S) 'boredom) \"boredom\"\
    )\n      (char=? (char-type (char-after 'I S) 'bore) 'boredom)))\n", "  (define\
    \ (helper w n found)\n    (cond\n      [(empty? w) found]\n      [(char=? (first\
    \ w) #'I) (incf n)]\n      [(char=? (first w) #'!) (helper (rest w) (decf n) (if\
    \ (= n 0) found 0))]\n      [(char=? (first w) #'.') (helper (rest w) (decf n)\
    \ (if (= n 0) found 0))]\n      [(char=? (first w) #'?) (helper (rest w) (decf\
    \ n) (if (= n 0) found 0))]\n      [else (helper (rest w) (decf n) (if (= n 0)\
    \ found 1))]\n    )\n  )\n  (helper S (length S) 0)\n)\n", "  (let loop ((i 0)\
    \ (bored 0))\n    (cond\n      ((empty? S) bored)\n      (else (or (char=? (car\
    \ S) 'I)\n                (char=? (car S) '.')\n                (char=? (car S)\
    \ '?')\n                (char=? (car S) '!'))\n             (loop (+ i 1)\n  \
    \                (if (char=? (car S) 'I) 1 bored)))))\n", "  (= (length S) (+\
    \ (length (rest S)) 1))\n  (= (substring S 0 1) \"I\"))\n", "  (let ((i 0))\n\
    \    (define (helper S)\n      (if (empty? S) (add1 i) (helper (cdr S))))\n  \
    \  (helper S)))\n", "  (or (equal? (car S) \"I\")\n      (equal? (car S) \"the\"\
    )\n      (equal? (car S) \"I\")))\n", "  (> (string-length (substring S 0 (string->length\
    \ (substring S 0 (string-length S)))) \"I\") 1))\n", "  (cond\n    [(empty? S)\
    \ 0]\n    [(equal? (first S) 'I) 1]\n    [else 0]))\n", "  (count\n   (lambda\
    \ (x)\n     (string=? (substring x 0 (string-length x))\n               #b '#\\\
    . #\\? #\\!)\n         x)) S\n   0 1))\n", "  (define (helper S)\n    (cond [(equal?\
    \ (first S) \"I\") 1]\n          [(equal? (first S) \"!\") 1]\n          [(equal?\
    \ (first S) \".\") 1]\n          [(equal? (first S) \"?\") 1]\n          [else\
    \ (helper (rest S))]))\n  (helper S))\n", "  (cond\n    [(empty? S) #f]\n    [(equal?\
    \ (first S) 'I) #t]\n    [(equal? (first S) '!) #f]\n    [(equal? (first S) '?)\
    \ #t]\n    [else #f]))\n", "  (let ([ss (split-string S #\\. #\\? #\\!)]\n   \
    \     [boredom 0]\n        [i 0])\n    (cond [(empty? ss) #t]\n          [(equal?\
    \ (first ss) \"I\") (set! boredom (+ 1 boredom))]\n          [else (set! i (+\
    \ 1 (is-bored (rest ss))))]\n          [else #f])))\n", "  (count (lambda (s)\
    \ (starts-with? s \"I\"))\n          (split-string S \".?!\")))\n", "  (= (length\
    \ S) (length \n               (filter (lambda (x) (char-upper? (first x))) \"\
    I HELLO WORLD IS THIS!!??\"))))\n</code>\n<|/ a tags=racket,scheme |>\n<| a |>\n\
    <code>", "  (match S\n    ['(I)    1]\n    ['(\\.)   1]\n    ['\\?      1]\n \
    \   ['\\!      2]))\n</code>\nI hope I helped!\n<|/ a |>\n<| c |>\n`'(I)` is a\
    \ syntax error, a syntax error because it starts with a number `1`.\n<|/ c |>\n\
    <| c |>\nIt works! Thanks a lot. I realized that my code is very similar to yours.\
    \ I just had to fix some mistakes.\n<|/ c |>\n<| c |>\nI'm glad you found it useful!\
    \ Feel free to accept my answer if it solved your problem! :) https://stackoverflow.com/help/someone-answers\n\
    <|/ c |>\n<| a tags=racket,scheme |>\nIt's not really a good idea to define a\
    \ function with side effects, because that means your program can become unpredictable\
    \ in future if you define it multiple times. Instead, I'd suggest defining the\
    \ function as a predicate that takes one argument, which is your string. \nThis\
    \ way you always know that the function is going to return true or false based\
    \ on that argument.\n<|/ a dscore=0 |>\n<| a tags=racket,scheme |>\n<code>", " \
    \ (cond\n    [(equal? S \"I\") 0]\n    [(equal? S \".\") 0]\n    [(equal? S \"\
    ?\") 0]\n    [(equal? S \"!\") 0]\n    [else (+ 1 (is_bored (re-sub S \"([.?!])\"\
    \ \"\")))]))\n", "  (match S\n    ['(? #(boredom . ?))] 1))\n</code>\n<|/ a dscore=1\
    \ tags=racket,scheme |>\n<| a |>\nA possible solution is:\n\nDefine a function\
    \ that splits a list into two sub-lists:\n\n<code>", "  (cond [(empty? S) 0]\n\
    \        [(and (equal? (first S) \"I\") (equal? (rest S) \".\")) 1]\n        [(and\
    \ (equal? (first S) \"I\") (equal? (rest S) \"?\")) 1]\n        [(and (equal?\
    \ (first S) \"I\") (equal? (rest S) \"!\")) 1]\n        [else 0]))\n", "  (cond\n\
    \    [(starts-with \"I \" S)      0]\n    [(starts-with \"I \" S) \"-1\"]\n  \
    \  [(starts-with \"I \" S) (+ 1 (is_bored (S)))]\n    [(starts-with \"I \" S)\
    \ (+ 1 (is_bored (S)))]\n    [else                      1]\n  ))\n", "  (let loop\
    \ ([(bored 0) (sentence S) (next next) (cp #\\E) (count 0) (cp2 #\\E)])\n    (cond\n\
    \      [(null? sentence) (= count bored)]\n      [(char=? (first sentence) cp)\
    \ (loop (+ bored 1) (rest sentence) next\n                                   (cons\
    \ (first sentence) cp) (first sentence) 1)]\n      [(char=? (first sentence) cp2)\
    \ (loop (+ bored 1) (rest sentence) next\n                                   \
    \    (cons (first sentence) cp2) (first sentence) 2)]\n      [(char=? (first sentence)\
    \ cp) (loop (+ bored 1) (rest sentence) next\n                               \
    \    (cons (first sentence) cp) (first sentence) 2)]\n      [else (loop (+ bored\
    \ 1) (rest sentence) next (cons (first sentence) cp) next 2)]))))\n", "  (cond\
    \ [(string-match #rx\"^I\" S) 1]\n        [else 0]))\n", "  (cond\n    [(or (string=?\
    \ \"I\" (substring S 0 2))\n         (string=? \"i\" (substring S 0 2)))\n   \
    \  (length S)\n    ]\n    [(string=? \".\" (substring S 0 1))\n     (cond\n  \
    \     [(or (string=? \"?\" (substring S 0 1))\n            (string=? \"!\" (substring\
    \ S 0 1)))\n        (length S)\n       ]\n       [else\n        (+ 1 (is_bored\
    \ (substring S 1)))\n       ]\n      ]\n     ]\n    [else\n     (+ 1 (is_bored\
    \ (substring S 1)))\n     ]\n    )\n  )\n  )\n", "  (cond\n    [(= (length (string->list\
    \ S)) 1)\n     (= (string->char (car S)) 'I')]\n    [(or (string->char (car S))\n\
    \          (string->char (car S) '?'))\n     (or (string->char (car S))\n    \
    \      (string->char (car S) '!'))]\n    [else 0]))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
