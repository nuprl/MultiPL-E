name: HumanEval_46_fib4
language: rkt
prompt: "#lang racket\n\n;; The Fib4 number sequence is a sequence similar to the\
  \ Fibbonacci sequnece that's defined as follows:\n;; fib4(0) -> 0\n;; fib4(1) ->\
  \ 0\n;; fib4(2) -> 2\n;; fib4(3) -> 0\n;; fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3)\
  \ + fib4(n-4).\n;; Please write a function to efficiently compute the n-th element\
  \ of the fib4 number sequence.  Do not use recursion.\n;; >>> (fib4 5)\n;; 4\n;;\
  \ >>> (fib4 6)\n;; 8\n;; >>> (fib4 7)\n;; 14\n(define (fib4 n)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate fib4))\n\
  \    (check-equal? (candidate 5) 4)\n    (check-equal? (candidate 8) 28)\n    (check-equal?\
  \ (candidate 10) 104)\n    (check-equal? (candidate 12) 386)\n))\n\n(test-humaneval)"
completions: ["  (if (= n 0)\n      0\n      (+ (fib4 (- n 1)) (fib4 (- n 2)) (fib4\
    \ (- n 3)) (fib4 (- n 4)))))\n", "  (cond [(= n 1) 0]\n        [(= n 2) 2]\n \
    \       [(= n 3) 1]\n        [else (+ (fib4 (- n 1)) (fib4 (- n 2)) (fib4 (- n\
    \ 3)) (fib4 (- n 4))) ]\n    ) )\n</code>\n<|/ a dscore=0 |>\n<| c |>\nWhy not\
    \ just use `+` in place of `+@`? `+@` is usually a macro that does something different.\n\
    <|/ c |>\n<| c |>\nYou can't do it in Scheme. `+` would add numbers, not strings.\
    \ Scheme has no primitive that can add strings and numbers. You need `string-append`,\
    \ which is not in Scheme.\n<|/ c |>\n<| c |>\nSure you can do it. `+` is defined\
    \ as a macro, and that macro can expand to a list of `+` operations. What I meant\
    \ was that `+` is usually defined as a primitive and not as a macro, so one can\
    \ do `(+ 1 2)` just fine. `+@` is usually a macro defined as a function, so one\
    \ would have to do `(+@ 'a 'b)`.\n<|/ c |>\n<| c |>\nIf you look at the [SICP\
    \ reference manual](http://www.sics.se/sicp/reference/ref.htm) you will see it\
    \ defined as a macro.\n<|/ c |>\n<| c |>\nYou can't use +@ to add the strings\
    \ because you get a syntax error when you try. Plus, SICP doesn't have a builtin\
    \ function to add the strings. You would have to define your own function for\
    \ it.\n<|/ c |>\n<| a |>\nI agree with the other answers that using a recursive\
    \ solution would be simpler and clearer than a tail recursive solution. \nHowever,\
    \ if you must write a tail-recursive solution, you need to use an auxiliary function.\
    \ The only way to achieve this with pure Scheme would be to wrap each level of\
    \ recursion into a call to the aux. function, which could be a macro or a function.\n\
    <|/ a dscore=0 tags=racket,scheme |>\n<| a |>\nSICP chapter 4 has an implementation\
    \ of Fibonacci in Scheme.  It uses + as the primitive operator.  To use + as an\
    \ operator in Racket, you could do (+ a b) instead of (+@ a b).  \nFor this problem\
    \ though, the solution of using recursion is simpler and clearer.\n<|/ a dscore=0\
    \ tags=racket,scheme |>\n<| c |>\nIn SICP chapter 4, they just use +", "  (define\
    \ (helper n a b)\n    (if (= n 0)\n        a\n        (helper (- n 1)\n      \
    \        (+ a b)\n              b)))\n  (helper n 0 0))\n</code>\nI hope this\
    \ helps you get the answer you seek.\n<|/ a tags=scheme |>\n<| a dscore=1 |>\n\
    Here's a scheme solution:\n<code>", "  ((cond [(= n 0) 0]\n        [(= n 1) 0]\n\
    \        [(= n 2) 2]\n        [(= n 3) 0]\n        [(= n 4) 0]\n        [(= n\
    \ 5) 0]\n        [(= n 6) 0]\n        [(= n 7) 0]\n        [(= n 8) 0]\n     \
    \   [(= n 9) 0]\n        [(= n 10) 0]\n        [(= n 11) 0]\n        [(= n 12)\
    \ 0]\n        [(= n 13) 0]\n        [(= n 14) 0]\n        [(= n 15) 0]\n     \
    \   [(= n 16) 0]\n        [(= n 17) 0]\n        [(= n 18) 0]\n        [(= n 19)\
    \ 0]\n        [(= n 20) 0]\n        [(= n 21) 0]\n        [(= n 22) 0]\n     \
    \   [(= n 23) 0]\n        [(= n 24) 0]\n        [(= n 25) 0]\n        [(= n 26)\
    \ 0]\n        [(= n 27) 0]\n        [(= n 28) 0]\n        [(= n 29) 0]\n     \
    \   [(= n 30) 0]\n        [(= n 31) 0]\n        [(= n 32) 0]\n        [(= n 33)\
    \ 0]\n        [(= n 34) 0]\n        [(= n 35) 0]\n        [(= n 36) 0]\n     \
    \   [(= n 37) 0]\n        [(= n 38) 0]\n        [(= n 39) 0]\n        [(= n 40)\
    \ 0]\n        [(= n 41) 0]\n        [(= n 42) 0]\n        [(= n 43) 0]\n     \
    \   [(= n 44) 0]\n        [(= n 45) 0]\n        [(= n 46) 0]\n        [(= n 47)\
    \ 0]\n        [(= n 48) 0]\n        [(= n 49) 0]\n        [(= n 50) 0]\n     \
    \   [(= n 51) 0]\n        [(= n 52) 0]\n        [(= n 53) 0]\n        [(= n 54)\
    \ 0]\n        [(= n 55) 0]\n        [(= n 56) 0]\n        [(= n 57) 0]\n     \
    \   [(= n 58) 0]\n        [(= n 59) 0]\n        [(= n 60) 0]\n        [(= n 61)\
    \ 0]\n        [(= n 62) 0]\n        [(= n 63) 0]\n        [(= n 64) 0]", "  (cond\
    \ [(= n 0) 0]\n        [(= n 1) 0]\n        [(= n 2) 2]\n        [(= n 3) 0]\n\
    \        [else (+ (fib4 (- n 4)) (fib4 (- n 3)) (fib4 (- n 2)) (fib4 (- n 1))))]))\n\
    </code>\n<|/ a tags=racket,scheme,fibonacci dscore=1 |>\n<| c |>\nYou might want\
    \ to add that `fib4` should use a tail-recursive function and `cons` is for building\
    \ lists.\n<|/ c |>\n<| a dscore=1 |>\n<code>", "  (if (< n 1)\n      n\n     \
    \ (+ (fib4 (- n 1)) \n         (+ (fib4 (- n 2)) \n            (+ (fib4 (- n 3))\
    \ \n              (+ (fib4 (- n 4)) '())))))\n</cell>\n<cell>\n#lang racket\n",
  "  (if (< n 4)\n      0\n      (+ (fib4 (- n 1)) \n         (fib4 (- n 2)) \n  \
    \       (fib4 (- n 3)) \n         (fib4 (- n 4)))))\n", "  (cond [(< n 4)\n  \
    \       0]\n        [(< n 5)\n         0]\n        [(< n 6)\n         2]\n   \
    \     [(< n 7)\n         0]\n        [else\n         (+ (fib4 (- n 4)) (fib4 (-\
    \ n 3))\n            (fib4 (- n 2)) (fib4 (- n 1)))]))", "  (cond [(= n 0) 0]\n\
    \        [(= n 1) 0]\n        [(= n 2) 2]\n        [(= n 3) 0]\n        [else\
    \ (+ (fib4 (- n 4))\n                  (fib4 (- n 3))\n                  (fib4\
    \ (- n 2))\n                  (fib4 (- n 1))))))\n", "  (cond [(= n 0) 0]\n  \
    \      [(= n 1) 0]\n        [(= n 2) 2]\n        [(= n 3) 0]\n        [else (+\
    \ (fib4 (- n 4)) (fib4 (- n 3)) (fib4 (- n 2)) (fib4 (- n 1))) ]))\n\n#lang racket\n",
  "  (define (helper f a b)\n    (if (< n 0)\n        b\n        (helper (lambda (x)\n\
    \                   (+ (f x) (helper f a (f x)))) a (f b)))\n  (helper lambda\
    \ (lambda (x y)\n                  (+ x y))\n          0\n          1))\n", " \
    \ (if (= n 0)\n      0\n      (+ (fib4 (- n 1)) (* (fib4 (- n 2)) (* (fib4 (-\
    \ n 3)) (* (fib4 (- n 4)) 1)))))\n", "  (cond\n    ((= n 0) 0)\n    ((= n 1) 0)\n\
    \    ((= n 2) 2)\n    ((= n 3) (fib4 (- n 1)))\n    (else (+ (fib4 (- n 2)) (fib4\
    \ (- n 3))) (fib4 (- n 4)))\n    ))\n", "  ((if (= n 0) 0\n       (+ (fib4 (-\
    \ n 1))\n          (fib4 (- n 2))\n          (fib4 (- n 3))\n          (fib4 (-\
    \ n 4)))\n  )))\n", "  (if (= n 0) 0\n      (if (= n 1) 0\n          (if (= n\
    \ 2) 2\n              (if (= n 3) 0\n                  (+ (fib4 (- n 1)) (fib4\
    \ (- n 2)) (fib4 (- n 3)) (fib4 (- n 4)))\n                  (fib4 (- n 4))))))",
  "  (if (= n 0) 0\n      (+ (fib4 (- n 1)) (fib4 (- n 2)) (fib4 (- n 3)) (fib4 (-\
    \ n 4)))))\n", "  (cond [(= n 0) 0]\n        [(= n 1) 0]\n        [(= n 2) 2]\n\
    \        [(= n 3) (+ (fib4 (- n 1)) (fib4 (- n 2)))]\n        [(= n 4) (+ (fib4\
    \ (- n 3)) (fib4 (- n 4)))]))\n", "  (cond\n    [(< n 0) 0]\n    [else (+ (fib4\
    \ (- n 1))\n            (fib4 (- n 2))\n            (fib4 (- n 3))\n         \
    \   (fib4 (- n 4)))]))\n", "  (define (aux1 x)\n    (+ (aux1 x) (aux1 x) (aux1\
    \ x) (aux1 x)))\n  (define (aux2 x y)\n    (+ (aux2 x y) (aux2 x (+ y 1))))\n\
    \  (aux2 0 n))", "  (if (= n 0)\n      0\n      (+ (fib4 (- n 1)) (fib4 (- n 2))\
    \ (fib4 (- n 3)) (fib4 (- n 4)))))\n", "  (cond [(= n 0) 0]\n        [(= n 1)\
    \ 0]\n        [(= n 2) 2]\n        [(= n 3) 0]\n        [else (+ (fib4 (- n 1))\n\
    \                (fib4 (- n 2))\n                (fib4 (- n 3))\n            \
    \    (fib4 (- n 4)))))]\n)", "  (let ([f (lambda (n) (if (= n 0) 0 (+ (fib4 (-\
    \ n 1)) (fib4 (- n 2)))))])\n    (f n)))\n", "  (cond [(< n 0)\n         (error\
    \ 'fib4 \"Number not between 0 and 4\")]\n        [(= n 1)\n         0]\n    \
    \    [(= n 2)\n         2]\n        [else\n         (+ (fib4 (- n 1))\n      \
    \      (fib4 (- n 2))\n            (fib4 (- n 3))\n            (fib4 (- n 4)))\
    \ ]))\n\n#lang racket\n", "  (cond [(= n 0) 0]\n        [(= n 1) 0]\n        [(=\
    \ n 2) 2]\n        [(= n 3) 0]\n        [else (+ (fib4 (- n 4)) (fib4 (- n 3))\n\
    \                    (fib4 (- n 2))\n                    (fib4 (- n 1))))))\n",
  "  (cond [(= n 0)\n         0]\n        [(= n 1)\n         0]\n        [(= n 2)\n\
    \         2]\n        [(= n 3)\n         0]\n        [(= n 4)\n         4]\n \
    \       [else\n         (+ (fib4 (- n 4)) (fib4 (- n 3)) (fib4 (- n 2)) (fib4\
    \ (- n 1)))]))\n", "  ;; base case\n  (if (= n 0) 0\n      ;; recursive case\n\
    \      (+ (fib4 (- n 1)) (fib4 (- n 2)) (fib4 (- n 3)) (fib4 (- n 4)))))", " \
    \ ;; Base case\n  (cond [(= n 0) 0]\n        [(= n 1) 0]\n        [(= n 2) 2]\n\
    \        [(= n 3) 0]\n        [else (+ (fib4 (- n 1)) (fib4 (- n 2)) (fib4 (-\
    \ n 3)) (fib4 (- n 4)))]))\n", "  (cond\n    [(< n 1) 0]\n    [else (+ fib4 (-\
    \ (fib4 n) 1) (fib4 n) (fib4 (- n 1)))]))\n", "  (if (= n 0)\n      0\n      (+\
    \ (fib4 (- n 1)) (fib4 (- n 2)) (fib4 (- n 3)) (fib4 (- n 4)))))\n", "  (cond\n\
    \    [(= n 0) 0]\n    [(= n 1) 1]\n    [(= n 2) 2]\n    [(= n 3) 3]\n    [else\
    \ (+ (fib4 (- n 2)) (fib4 (- n 3)) (fib4 (- n 4)))]))\n", "  (if (= n 0)\n   \
    \   0\n      (+ (fib4 (- n 1))\n         (fib4 (- n 2))\n         (fib4 (- n 3))\n\
    \         (fib4 (- n 4)))))\n", "  (cond [(= n 0) 0]\n        [(= n 1) 0]\n  \
    \      [(= n 2) 2]\n        [(= n 3) 0]\n        [else (+ (fib4 (sub1 n)) (fib4\
    \ (sub2 n)) (fib4 (sub3 n)) (fib4 (sub4 n)))))]\n", "  (if (zero? n)\n      0\n\
    \      (+ (fib4 (sub1 n))\n         (fib4 (sub2 n))\n         (fib4 (sub3 n))\n\
    \         (fib4 (sub4 n))))\n)\n", "  (cond\n    [(< n 0) 0]\n    [(< n 1) 0]\n\
    \    [(< n 2) 2]\n    [(< n 3) 0]\n    [(< n 4) 0]\n    [else (+ (fib4 (- n 4))\
    \ (fib4 (- n 3)) (fib4 (- n 2)) (fib4 (- n 1)))]))", "  (cond\n    ((= n 0) 0)\n\
    \    ((= n 1) 0)\n    ((= n 2) 2)\n    ((= n 3) 0)\n    ((= n 4) 4)\n    (else\
    \ (+ (fib4 (- n 1)) (fib4 (- n 2)) (fib4 (- n 3)) (fib4 (- n 4))))))\n", "  (cond\
    \ [(= n 0) 0]\n        [(= n 1) 1]\n        [(= n 2) 2]\n        [(= n 3) 3]\n\
    \        [else (+ (fib4 (- n 4)) (fib4 (- n 3)) (fib4 (- n 2)) (fib4 (- n 1))))]))\n",
  "  (if (<= n 4)\n      0\n      (+ (fib4 (- n 2)) (fib4 (- n 3)) (fib4 (- n 4))\
    \ (fib4 (- n 5)))))\n", "  (if (= n 0)\n      0\n      (+ (fib4 (sub1 n)) (fib4\
    \ (sub1 n-1)))))\n</code>\n<|/ a |>\n<| c |>", "  ;; Add code here that computes\
    \ fib4(n).\n  ;; >>> fib4 6\n  ;; 8\n  ;; >>> fib4 7\n  ;; 14\n  (define (fib4loop\
    \ 0 result)\n    (if (= n 0)\n        result\n        (fib4loop (- n 1) (+ result\
    \ (* 4 n)))))\n  (fib4loop n 0))\n", "  (cond [(= n 0)\n         0]\n        [(=\
    \ n 1)\n         0]\n        [(= n 2)\n         2]\n        [(= n 3)\n       \
    \  0]\n        [else\n         (+ (fib4 (- n 4)) (fib4 (- n 3))\n            (fib4\
    \ (- n 2)) (fib4 n))]))\n", "  (if (< n 0)\n      0\n      (+ (fib4 (- n 2)) (fib4\
    \ (- n 1)) (fib4 (- n 3)) (fib4 (- n 4)))\n))\n</cell>\n<cell>", "  (cond\n  \
    \  [(= n 0) 0]\n    [(= n 1) 0]\n    [(= n 2) 2]\n    [else (+ (fib4 (- n 1))\
    \ \n            (fib4 (- n 2)) \n            (fib4 (- n 3)) \n            (fib4\
    \ (- n 4)))]))\n", "  (cond ((= n 0) 0)\n        ((= n 1) 0)\n        ((= n 2)\
    \ 2)\n        ((= n 3) (+ (fib4 (- n 2)) (fib4 (- n 3))))\n        (else (+ (fib4\
    \ (- n 4)) (fib4 (- n 3))))))\n", "  (cond [(= n 0)\n         0]\n        [(=\
    \ n 1)\n         0]\n        [(= n 2)\n         2]\n        [(= n 3)\n       \
    \  0]\n        [else\n         (+ (fib4 (- n 4))\n            (fib4 (- n 3))\n\
    \            (fib4 (- n 2))\n            (fib4 (- n 1)))]))\n", "  (if (<= n 3)\n\
    \      0\n      (+ (fib4 (sub1 n)) (fib4 (sub2 n)))))\n", "  (define (fibo n a\
    \ b)\n    (if (= n 0)\n        a\n        (fibo (- n 1) (+ a b) b)))\n  (fibo\
    \ n 0 0))\n", "  (cond [(= n 0) 0]\n        [(= n 1) 1]\n        [(= n 2) 2]\n\
    \        [else (+ (fib4 (- n 2)) (fib4 (- n 1)) (fib4 (- n 3))) (fib4 (- n 4))]))\n",
  "  ;; (fib4 0) => 0\n  (cond [(= n 0)\n         0]\n        ;; (fib4 1) => 0\n \
    \       [(= n 1)\n         0]\n        ;; (fib4 2) => 2\n        [(= n 2)\n  \
    \       2]\n        ;; (fib4 3) => 0\n        [(= n 3)\n         0]\n        ;;\
    \ (fib4 n) => fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n        [else\n \
    \        (+ (fib4 (sub1 n)) (fib4 (sub2 n)) (fib4 (sub3 n)) (fib4 (sub4 n)))))",
  "  (if (= n 0)\n      0\n      (+ (fib4 (- n 1))\n         (fib4 (- n 2))\n    \
    \     (fib4 (- n 3))\n         (fib4 (- n 4)))))\n", "  (cond\n    [(= n 0) 0]\n\
    \    [(= n 1) 0]\n    [(= n 2) 2]\n    [(= n 3) 0]\n    [else (+ (fib4 (- n 1))\n\
    \             (fib4 (- n 2))\n             (fib4 (- n 3))\n             (fib4\
    \ (- n 4)))]))\n", "  (cond\n    [(= n 0)                0]\n    [(= n 1)    \
    \            0]\n    [(= n 2)                2]\n    [(= n 3)                0]\n\
    \    [else                  (+ (fib4 (- n 1)) (fib4 (- n 2)) (fib4 (- n 3)) (fib4\
    \ (- n 4)))]))\n\n#lang racket\n", "  ((cond [(= n 0) 0]\n        [(= n 1) 0]\n\
    \        [(= n 2) 2]\n        [(= n 3) 0]\n        [else (+ (fib4 (- n 1)) (fib4\
    \ (- n 2)) (fib4 (- n 3)) (fib4 (- n 4)))]))\n\n#lang racket\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nThis answer is wrong. You do not need to use recursion to compute\
    \ fib numbers. This is why you use memoization. You don't memoize fib4. The solution\
    \ here is to use tail recursion (no more calls to fib4 in the function body).\n\
    <|/ c |>\n<| c |>\nIt's a solution to a problem that asks you to compute the n-th\
    \ fib number in a recursive function.  I don't see how memoization would help\
    \ here...\n<|/ c |>\n<| c |>\nYes, it does help because you do not call fib4 recursively\
    \ in the body of fib4. Tail recursion is the way to go. You are computing the\
    \ fib number n recursively. Hence you use memoization.\n<|/ c |>\n<| c |>\n: That's\
    \ not how you use memoization. You use memoization because you are computing a\
    \ value that is expensive to compute but is reusable. You are not doing that.\n\
    <|/ c |>\n<| a |>\n<code>", "  (cond\n    [(= n 0) 0]\n    [(= n 1) 0]\n    [(=\
    \ n 2) 2]\n    [(= n 3) 0]\n    [(= n 4) 0]\n    [else (+ (fib4 (- n 4)) (fib4\
    \ (- n 3))) (+ (fib4 (- n 2)) (fib4 (- n 1)))]))\n", "  (cond [(= n 0) 0]\n  \
    \      [(= n 1) 0]\n        [(= n 2) 2]\n        [(= n 3) 0]\n        [(= n 4)\
    \ 0]\n        [else (+ (fib4 (- n 1)) \n                 (fib4 (- n 2)) \n   \
    \              (fib4 (- n 3)) \n                 (fib4 (- n 4))))))\n", "  (if\
    \ (= n 0)\n      0\n      (+ (fib4 (- n 1))\n         (fib4 (- n 2))\n       \
    \  (fib4 (- n 3))\n         (fib4 (- n 4)))))\n", "  (if (= n 0)\n      0\n  \
    \    (+ (fib4 (- n 1)) (fib4 (- n 2)) (fib4 (- n 3)) (fib4 (- n 4)))))\n", " \
    \ (cond [(= n 0) 0]\n        [(= n 1) 1]\n        [(= n 2) 2]\n        [(= n 3)\
    \ 3]\n        [else (+ (fib4 (- n 4)) (fib4 (- n 3)) (fib4 (- n 2)) (fib4 n))]))\n",
  "  (cond\n    [(= n 0) 0]\n    [(= n 1) 0]\n    [(= n 2) 2]\n    [(= n 3) 0]\n \
    \   [(= n 4) 0]\n    [else (+ (fib4 (sub1 n)) (fib4 (sub2 n)) (fib4 (sub3 n))\
    \ (fib4 (sub4 n)))]))\n", "  (cond\n    [(= n 0) 0]\n    [(= n 1) 0]\n    [(=\
    \ n 2) 2]\n    [(= n 3) 0]\n    [else (+ (fib4 (- n 1)) \n             (fib4 (-\
    \ n 2)) \n             (fib4 (- n 3)) \n             (fib4 (- n 4))))]))\n", " \
    \ (if (= n 0) 0\n      (if (= n 1) 1\n        (+ (fib4 (- n 1))\n           (fib4\
    \ (- n 2))\n           (fib4 (- n 3))\n           (fib4 (- n 4))))))\n", "  (cond\
    \ [(= n 0)\n         (lambda (x)\n           (if (= x 0) 0 (+ x (fib4 (- n 1)))))]\n\
    \        [(= n 1)\n         (lambda (x)\n           (if (= x 0) 0 (+ x (fib4 (-\
    \ n 2)))))]\n        [(= n 2)\n         (lambda (x)\n           (if (= x 0) 0\
    \ (+ x (fib4 (- n 3)))))]\n        [(= n 3)\n         (lambda (x)\n          \
    \ (if (= x 0) 0 (+ x (fib4 (- n 4)))))]\n        [else\n         (lambda (x)\n\
    \           (+ x (fib4 (- n 1))\n               (fib4 (- n 2))\n             \
    \  (fib4 (- n 3))\n               (fib4 (- n 4))\n             )\n        ]\n\
    \      )\n  )\n", "  (cond [(= n 0) 0]\n        [(= n 1) 0]\n        [(= n 2)\
    \ 2]\n        [(= n 3) 0]\n        [else (+ (fib4 (- n 4)) (fib4 (- n 3)) (fib4\
    \ (- n 2)) (fib4 (- n 1)))))\n", "  ;; Base case for n=0 fib4(0) = 0\n  (cond\n\
    \    [(= n 0) 0]\n    [(= n 1) 1]\n    [(= n 2) 2]\n    [else (+ (fib4 (- n 1))\
    \ (fib4 (- n 2))) 0]))\n", "  ((if (= n 0)\n      0\n      (+ (fib4 (- n 1))\n\
    \         (fib4 (- n 2))\n         (fib4 (- n 3))\n         (fib4 (- n 4)))))\n",
  "  (if (= n 0)\n      0\n      (+ (fib4 (- n 1)) (* (fib4 (- n 2)) (fib4 (- n 3)))\
    \ (fib4 (- n 4)))))\n", "  (fib n 4 1 0 1 0))\n", "  (let ([a 0])\n    (cond\n\
    \      [(= n 0) 0]\n      [(= n 1) 1]\n      [(= n 2) 2]\n      [(= n 3) 0]\n\
    \      [else\n      (set! a (+ a \n               (fib4 (sub1 n)))\n         \
    \      (fib4 (sub1 n)))]\n      )))\n\n#lang racket", "  (cond ((= n 0) 0)\n \
    \       ((= n 1) 0)\n        ((= n 2) 2)\n        ((= n 3) 0)\n        ((= n 4)\
    \ 4)\n        (else (+ (fib4 (- n 2)) (fib4 (- n 1)) (fib4 (- n 3)) (fib4 (- n\
    \ 4))))))\n\n#lang racket\n", "  (if (= n 0)\n      0\n      (+ (fib4 (- n 1))\
    \ \n         (fib4 (- n 2))\n         (fib4 (- n 3))\n         (fib4 (- n 4)))))\n",
  "  (if (= n 0) 0\n      (+ (fib4 (- n 1)) (fib4 (- n 2)) (fib4 (- n 3)) (fib4 (-\
    \ n 4)))))\n", "  (cond\n    [(= n 0) 0]\n    [(= n 1) 0]\n    [(= n 2) 2]\n \
    \   [else (+ (fib4 (- n 2)) (fib4 (- n 1)) (fib4 (- n 3)) (fib4 (- n 4)))]))\n\
    </code>\n<|/ a |>\n<| a dscore=0 |>\nHere is a solution that is similar to John\
    \ De Dyck's answer but uses functional composition and higher order functions:\n\
    <code>", "  (if (< n 4)\n      0\n      (+ (fib4 (- n 2)) (fib4 (- n 3)))))\n\
    </cell>\n<text>\nLet's see that works.  Note that when we evaluate (fib4 5), the\
    \ return value from the recursive call gets propagated back up the call stack\
    \ and returned up to the caller.  Since this occurs twice in our program, we end\
    \ up with 8 returned.\n\n\n</text>\n<cell>", "  (big-mul (big-mul fib4 (big-mul\
    \ fib4 (big-mul fib4 (big-mul fib4 1))))))\n", "  (if (= n 0)\n      0\n     \
    \ (+ (fib4 (sub1 n)) (fib4 (sub2 n)) (fib4 (sub3 n)) (fib4 (sub4 n))))) ;; #lang\
    \ racket\n", "  (if (< n 0)\n      0\n      (+ (fib4 (- n 1)) (fib4 (- n 2)) (fib4\
    \ (- n 3)) (fib4 (- n 4)))))\n", "  (cond [(= n 0) 0]\n        [(= n 1) 0]\n \
    \       [(= n 2) 2]\n        [else (+ (fib4 (sub1 n))\n                (fib4 (sub2\
    \ n))\n                (fib4 (sub3 n))\n                (fib4 (sub4 n))))])\n",
  "  (let ([a 0])\n    (define (loop n a)\n      (cond\n        ((zero? n) a)\n  \
    \      ((equal? n 1) a)\n        ((equal? n 2) (loop (sub1 n) (a+ a)))\n     \
    \   (else (loop (sub1 n) (+ a (fib n))))))\n    (loop n a)))", "  (if (= n 0)\
    \ 0\n      (if (= n 1) 1\n          (if (= n 2) 2\n              (if (= n 3) 0\n\
    \                  (+ (fib4 (- n 4))\n                      (fib4 (- n 3))\n \
    \                     (fib4 (- n 2))\n                      (fib4 (- n 1))))))))\n",
  "  (cond\n    [(= n 0) 0]\n    [(= n 1) 0]\n    [(= n 2) 2]\n    [(= n 3) 0]\n \
    \   [(= n 4) (+ (fib4 (- n 1)) (fib4 (- n 2)) (fib4 (- n 3)) (fib4 (- n 4))]\n\
    \    [else\n     (fib4 (- n 1)) (fib4 (- n 2)) (fib4 (- n 3)) (fib4 (- n 4))]\n\
    \    )\n  )\n)\n", "  (cond [(= n 0) 0]\n        [(= n 1) 0]\n        [(= n 2)\
    \ 2]\n        [(= n 3) (+ (fib4 (- n 1) ) 1)]\n        [else (+ (fib4 (- n 1)\
    \ ) (fib4 (- n 2) ) (fib4 (- n 3) ) (fib4 (- n 4)))]))", "  (cond\n    [(= n 0)\
    \ 0]\n    [(= n 1) 0]\n    [(= n 2) 2]\n    [(= n 3) (+ (fib4 (- n 1)) (fib4 (-\
    \ n 2)))]\n    [(= n 4) (+ (fib4 (- n 3)) (fib4 (- n 4)))]))\n", "  (cond [(=\
    \ n 0)\n         0]\n        [(= n 1)\n         0]\n        [(= n 2)\n       \
    \  2]\n        [(= n 3)\n         0]\n        [else\n         (+ (fib4 (- n 1))\n\
    \            (fib4 (- n 2))\n            (fib4 (- n 3))\n            (fib4 (-\
    \ n 4)))))\n", "  (cond [(zero? n) 0]\n        [else (+ (fib4 (sub1 n)) (fib4\
    \ (sub1 n)))]))\n", "  (if (zero? n) 0\n      (+ (fib4 (sub1 n)) (fib4 (sub2 n))\
    \ (fib4 (sub3 n)) (fib4 (sub4 n)))))", "  (if (= n 0)\n      0\n      (+ (fib4\
    \ (sub1 n)) (fib4 (sub2 n)) (fib4 (sub3 n)) (fib4 (sub4 n)))))\n", "  (cond [(zero?\
    \ n) 0]\n        [(zero? (add n (sub1 n)))\n         (+ (fib4 (sub1 n)) (fib4\
    \ (sub1 n)) (fib4 (sub1 n)) (fib4 (sub1 n)))]\n        [else (+ (fib4 (sub1 n))\
    \ (fib4 (sub1 n)) (fib4 (sub1 n)) (fib4 (sub1 n)))]))\n", "  (define (loop n a\
    \ b)\n    (if (> n 0)\n        (loop (- n 1)\n              (+ a b)\n        \
    \      (+ b a))\n        b))\n  (loop (+ 1 n) 0 1))\n</cell>\n<code language=ocaml-jupyter>\n\
    #lang racket\n", "  (cond [(= n 0) 0]\n        [(= n 1) 0]\n        [(= n 2) 2]\n\
    \        [(= n 3) 0]\n        [else (+ (fib4 (- n 2)) (fib4 (- n 1)) (fib4 (-\
    \ n 3)) (fib4 (- n 4))))]))\n", "  (cond [(= n 0) 0]\n        [(= n 1) 1]\n  \
    \      [(= n 2) 2]\n        [else (+ (fib4 (- n 1)) (fib4 (- n 2)) (fib4 (- n\
    \ 3)) (fib4 (- n 4))))]))\n", "  (define (helper a b c d e)\n    (if (= n 0)\n\
    \        a\n        (helper (+ b c) (+ a b) c d (+ e d))))\n  (helper 1 1 2 3\
    \ 4))\n", "  (cond [(= n 0) 0]\n        [(= n 1) 1]\n        [(= n 2) 2]\n   \
    \     [(= n 3) 0]\n        [else (+ (fib4 (- n 1)) (* (fib4 (- n 2)) (fib4 (-\
    \ n 3))) (fib4 (- n 4))))]))\n", "  (if (= n 0) 0\n      (if (= n 1) 0\n     \
    \     (if (= n 2) 2\n              (if (= n 3) 0\n                  (+ (fib4 (-\
    \ n 1))\n                       (fib4 (- n 2))\n                       (fib4 (-\
    \ n 3))\n                       (fib4 (- n 4))))))))\n#lang racket\n", '  (fib
    0 1 2 3 4 5))', "  (let ((x 0))\n    (cond\n      [(= n 0) x]\n      [(= n 1)\
    \ x]\n      [(= n 2) x]\n      [(= n 3) x]\n      [else (+ (fib4 (- n 4)) (fib4\
    \ (- n 3))\n              (fib4 (- n 2)) (fib4 (- n 1)))]\n    )))\n", "  (if\
    \ (< n 4)\n      n\n      (+ (fib4 (- n 1))\n         (fib4 (- n 2))\n       \
    \  (fib4 (- n 3))\n         (fib4 (- n 4)))))", "  ;; base case\n  (if (< n 2)\n\
    \      n\n      (+ (fib4 (- n 2)) (fib4 (- n 1)))))\n", "  (cond\n    [(= n 0)\
    \ 0]\n    [(= n 1) 1]\n    [else (+ (fib4 (- n 2)) (fib4 (- n 3))) (fib4 (- n\
    \ 4)))]))\n", "  (define (fib4 acc n acc)\n    (cond\n      [(= n 0) acc]\n  \
    \    [(= n 1) acc]\n      [(= n 2) acc]\n      [(= n 3) (+ acc acc)]\n      [(=\
    \ n 4) (+ acc (+ acc acc))]\n      [else\n       (fib4 (+ acc (+ acc (+ acc (+\
    \ acc (+ acc (+ acc acc)))))\n             (- n 1)\n             acc)]]))\n  ;;\
    \ TODO: use tail-recursion here to improve performance\n", "  (+ (if (<= n 2)\n\
    \         (* 2 n)\n         0)\n       (if (<= n 3)\n           (* 3 n)\n    \
    \       (+ (fib4 (- n 2)) (fib4 (- n 3))))))\n", "  (cond\n    [(= n 0) 0]\n \
    \   [(= n 1) 0]\n    [(= n 2) 2]\n    [else (+ (fib4 (- n 1)) \n             (fib4\
    \ (- n 2)) \n             (fib4 (- n 3)) \n             (fib4 (- n 4)))]))\n",
  "  (if (< n 0)\n      0\n      (+ (fib4 (- n 1)) (* (fib4 (- n 2)) (fib4 (- n 3))))))\n",
  "  (if (= n 0) 0\n      (+ (fib4 (- n 1)) (fib4 (- n 2)) (fib4 (- n 3)) (fib4 (-\
    \ n 4)))))\n", "  (define (helper n)\n    (cond ((= n 0) 0)\n          ((= n 1)\
    \ 0)\n          ((= n 2) 2)\n          ((= n 3) 0)\n          (else (+ (helper\
    \ n-1) (helper n-2) (helper n-3) (helper n-4)))))\n  (helper n))\n", "  (define\
    \ (iter i a b c)\n    (cond\n      [(= i n) a]\n      [else (iter (+ i 1) (+ a\
    \ (* b c)) (* b (+ c b)) (+ c c))]))\n  (iter 0 0 1))\n", "  (cond ((< n 3) 0)\n\
    \        ((< n 4) 0)\n        ((< n 5) 2)\n        ((< n 6) 0)\n        ((< n\
    \ 7) 0)\n        ((< n 7) 0)\n        (else (+ (fib4 (- n 4)) (fib4 (- n 3)) (fib4\
    \ (- n 2)) (fib4 (- n 1))))))\n\n#lang racket\n", "  (if (= n 0)\n      0\n  \
    \    (+ (fib4 (sub1 n)) (fib4 (sub2 n)) (fib4 (sub3 n)) (fib4 (sub4 n)))))\n",
  "  (if (= n 0)\n      0\n      (+ (fib4 (- n 1)) (fib4 (- n 2)) (fib4 (- n 3)) (fib4\
    \ (- n 4)))))\n", "  (define (inner-fib4 i acc x)\n    (cond ((= i 0) acc)\n \
    \         ((= i n) x)\n          (else (inner-fib4 (- i 1) (+ acc (* x x)) (+\
    \ x 1)))))\n  (inner-fib4 0 0 1))\n", "  (let ((a 0) (b 1))\n    (cond\n     \
    \ [(= n 0) a]\n      [(= n 1) b]\n      [(< n 2) (fib4 (- n 1))\n       (+ (fib4\
    \ (- n 2)) (* (fib4 (- n 2)) a))\n       (+ (fib4 (- n 3)) (* (fib4 (- n 3)) b))]\n\
    \      [(> n 3) (fib4 (- n 2))\n       (+ (fib4 (- n 3)) (* (fib4 (- n 3)) a))\
    \ (+ (fib4 (- n 4)) (* (fib4 (- n 4)) b))]\n      [(> n 4) (fib4 (- n 3))\n  \
    \     (+ (fib4 (- n 4)) (* (fib4 (- n 4)) a)) (+ (fib4 (- n 5)) (* (fib4 (- n\
    \ 5)) b))\n       (+ (fib4 (- n 6)) (* (fib4 (- n 6)) a)) (+ (fib4 (- n 7)) (*\
    \ (fib4 (- n 7)) b))]\n      [(> n 6) (fib4 (- n 4))\n       (+ (fib4 (- n 5))\
    \ (* (fib4 (- n 5)) a)) (+ (fib4 (- n 6)) (* (fib4 (- n 6)) b))\n       (+ (fib4\
    \ (- n 7)) (* (fib4 (- n 7)) a)) (+ (fib4 (- n 8)) (* (fib4 (- n 8)) b))]\n  \
    \    [(> n 7) (fib4 (- n 5))\n       (+ (fib4 (- n 6)) (* (fib4 (- n 6)) a)) (+\
    \ (fib4 (- n 7)) (* (fib4 (- n 7)) b))\n       (+ (fib4 (- n 8)) (* (fib4 (- n\
    \ 8)) a)) (+ (fib4 (- n 9)) (* (fib4 (- n 9)) b))]\n      [(> n 8) (fib4 (- n\
    \ 6))\n       (+ (fib4 (- n 7)) (* (fib4 (- n 7)) a)) (+ (fib4 (- n 8)) (* (fib4\
    \ (- n 8)) b))\n       (+ (fib4 (- n 9)) (* (fib4 (- n 9)) a)) (+ (fib4 (- n 10))\
    \ (* (fib4 (- n 10)) b))\n       (", "  (cond ((= n 0) 0)\n        ((= n 1) 0)\n\
    \        ((= n 2) 2)\n        (else (+ (fib4 (- n 2)) (fib4 (- n 1))) (fib4 (-\
    \ n 3)))))\n\n#lang racket\n", "  (cond\n    [(= n 0) 0]\n    [(= n 1) 0]\n  \
    \  [(= n 2) 2]\n    [(= n 3) 0]\n    [else (+ (fib4 (- n 2)) (fib4 (- n 1)) (fib4\
    \ (- n 3)) (fib4 (- n 4))) ]))\n", "  (cond\n    [(= n 0) 0]\n    [(= n 1) 0]\n\
    \    [(= n 2) 2]\n    [(= n 3) (fib4 (- n 4)) (fib4 (- n 3)) (fib4 (- n 2)) (fib4\
    \ (- n 1))]\n    [else (fib4 (- n 4)) (fib4 (- n 3)) (fib4 (- n 2)) (fib4 (- n\
    \ 1))] ))", "  (cond [(= n 0) 0]\n        [(= n 1) 1]\n        [(= n 2) 2]\n \
    \       [(= n 3) 0]\n        [else (+ (fib4 (- n 4)) (fib4 (- n 3))\n        \
    \         (fib4 (- n 2)) (fib4 (- n 1)))))])\n", "  (if (= n 0) 0\n      (+ (fib4\
    \ (- n 1) +) (fib4 (- n 2) +) (fib4 (- n 3) +) (fib4 (- n 4)))))\n", "  (define\
    \ (helper n acc)\n    (cond [(= n 0) (return acc)]\n          [(= n 1) (return\
    \ acc)]\n          [(= n 2) (return (helper (- n 1) (+ acc acc))\n           \
    \           (helper (- n 2) (+ acc acc)))]\n          [else\n           (helper\
    \ (- n 1) (+ acc (helper n acc)))]))\n  (helper n 0))\n", "  (if (> n 0) (fib4\
    \ (- n)) 0))\n", "  (if (= n 0)\n      0\n      (+ (fib4 (- n 1))\n         (fib4\
    \ (- n 2))\n         (fib4 (- n 3))\n         (fib4 (- n 4)))))\n", "  (if (<\
    \ n 4)\n      0\n      (+ (fib4 (- n 1))\n         (fib4 (- n 2))\n         (fib4\
    \ (- n 3))\n         (fib4 (- n 4)))))\n", "  (cond ((= n 0) 0)\n        ((= n\
    \ 1) 0)\n        ((= n 2) 2)\n        (else (+ (fib4 (- n 4)) (fib4 (- n 3)) (fib4\
    \ (- n 2)) (fib4 (- n 1))))))", "  (cond [(= n 0) 0]\n        [(= n 1) 0]\n  \
    \      [(= n 2) 2]\n        [(= n 3) 0]\n        [else (+ (fib4 (- n 1)) (fib4\
    \ (- n 2)) (fib4 (- n 3)) (fib4 (- n 4))))]))\n", "  (let ((a (make-array (+ n\
    \ 3) '(unsigned-byte 8))))\n    (set! b (make-array (+ n 3) '(unsigned-byte 8)))\n\
    \    (set! c (make-array (+ n 3) '(unsigned-byte 8)))\n    (set! d 0)\n    (set!\
    \ i (- n 1))\n    (set! r (make-array (+ n 3) '(unsigned-byte 8)))\n    (set!\
    \ s (make-array (+ n 3) '(unsigned-byte 8)))\n    (set! t (make-array (+ n 3)\
    \ '(unsigned-byte 8)))\n    (while (not (= i n))\n      (set! i (+ i 1))\n   \
    \   (set! a (+ ((mod i 2) 2) (mod a 4) (mod b 8) (mod c 16) (mod d 32) d a))\n\
    \      (set! b (+ ((mod i 2) 2) (mod b 8) (mod c 16) (mod d 32) d b))\n      (set!\
    \ c (+ ((mod i 2) 2) (mod c 16) (mod d 32) d c))\n      (set! d 0)\n      (set!\
    \ r (+ ((mod i 2) 2) (mod r 8) (mod s 16) (mod t 32) r s))\n      (set! s (+ ((mod\
    \ i 2) 2) (mod s 16) (mod t 32) s t))\n      (set! t (+ ((mod i 2) 2) (mod t 32)\
    \ t s))))\n  (+ ((mod r 4) 4) ((first r) (second r) (third r) (fourth r))))\n",
  "  (if (= n 0) 0\n      (+ (fib4 (- n 1)) (fib4 (- n 2)) (fib4 (- n 3)) (fib4 (-\
    \ n 4)))))\n", "  (cond\n    ((= n 0) 0)\n    ((= n 1) 0)\n    ((= n 2) 2)\n \
    \   (else (+ (fib4 (- n 1)) \n             (fib4 (- n 2)) \n             (fib4\
    \ (- n 3)) \n             (fib4 (- n 4)))))\n", "  (cond\n    [(= n 1) 0]\n  \
    \  [(= n 2) 2]\n    [else (+ (fib4 (- n 1))\n            (fib4 (- n 2))\n    \
    \        (fib4 (- n 3))\n            (fib4 (- n 4))))]))\n", "  (if (= n 0)\n\
    \      0\n      (+ (fib4 (- n 1))\n         (fib4 (- n 2))\n         (fib4 (-\
    \ n 3))\n         (fib4 (- n 4)))))\n", "  (define (f a b c d)\n    (if (= n 0)\n\
    \        a\n        (f (+ a b) c d)))\n  (f 1 1 1 1))\n</cell>\n<cell>\n#lang\
    \ racket\n", "  (cond ((= n 1) 0)\n        ((= n 2) 2)\n        ((= n 3) 0)\n\
    \        ((= n 4) 0)\n        (else (+ (fib4 (- n 1))\n                  (fib4\
    \ (- n 2))\n                  (fib4 (- n 3))\n                  (fib4 (- n 4))))))\n",
  "  (define (fib4 a b)\n    (if (= n 0)\n        a\n        (fib4 (+ a b) (+ b a))))\n\
    \  (fib4 0 0))", "  (if (= n 0) 0\n      (+ (fib4 (- n 1)) (fib4 (- n 2))\n  \
    \         (fib4 (- n 3)) (fib4 (- n 4)))))\n", "  (cond [(= n 0) 0]\n        [(=\
    \ n 1) 1]\n        [(= n 2) 2]\n        [(= n 3) 3]\n        [(= n 4) 8]\n   \
    \     [else (+ (fib4 (- n 1)) \n                (fib4 (- n 2)) \n            \
    \    (fib4 (- n 3)) \n                (fib4 (- n 4)))))\n", "  (cond\n    [(=\
    \ n 0) 0]\n    [(= n 1) 0]\n    [(= n 2) 2]\n    [(= n 3) 0]\n    [else (+ (fib4\
    \ (- n 1)) (fib4 (- n 2)) (fib4 (- n 3)) (fib4 (- n 4))) ]))\n", "  ;; The Fibonacci\
    \ series is calculated as follows:\n  (fib n 1))\n", "  (if (<= n 4)\n      0\n\
    \      (+ (fib4 (- n 1)) (fib4 (- n 2)) (fib4 (- n 3)) (fib4 (- n 4)))))\n", " \
    \ (cond [(= n 0) 0]\n        [(= n 1) 0]\n        [(= n 2) 2]\n        [(= n 3)\
    \ 0]\n        [else (+ (fib4 (- n 1))\n                   (fib4 (- n 2))\n   \
    \                (fib4 (- n 3))\n                   (fib4 (- n 4)))))]", "  (if\
    \ (< n 4) (cond [(= n 0) 0]\n                     [(= n 1) 1]\n              \
    \       [(= n 2) 2]\n                     [(= n 3) 3])\n      (cond [(= n 4) 4]\n\
    \            [(= n 5) 5]\n            [(= n 6) 6]\n            [(= n 7) 7])\n\
    \          (cond [(= n 8) 8]\n                [ (= n 9) 9]\n                [\
    \ (= n 10) 10]\n                [ (= n 11) 11])\n          (cond [(= n 12) 12]\n\
    \                [ (= n 13) 13]\n                [ (= n 14) 14]))", "  (cond [(=\
    \ n 0) 0]\n        [(= n 1) 0]\n        [(= n 2) 2]\n        [(= n 3) 0]\n   \
    \     [(= n 4) (0+ (fib4 (- 4 n)))]))\n</code>\n<|/ a tags=fibonacci,racket,scheme\
    \ |>\n<| c |>\n`(fib4 10000)` took over 100 seconds on my machine to compute `(fib4\
    \ 100000)`.  On an older machine it took only a second.  Is this just because\
    \ the number fibonacci has lots of digits?\n<|/ c |>\n<| c |>\n: yeah, it seems\
    \ like a lot of digits. I guess it's more of a computational complexity issue.\n\
    <|/ c |>\n<| c |>\nIn Scheme (Racket, etc.), `fib` is already a defined function,\
    \ so the name `fib4` isn't necessary in Scheme\n<|/ c |>\n<| c |>\n: ah yes, I\
    \ missed that. Thanks for pointing that out. Fixed now.\n<|/ c |>\n<| a tags=fibonacci,racket,scheme\
    \ |>\nIn Racket you can implement a recursive procedure that will take an index\
    \ as an argument, and returning the value at that index in the fibonacci sequence.\
    \ For example:\n<code>", "  (cond\n    [(= n 0) 0]\n    [(= n 1) 0]\n    [(= n\
    \ 2) 2]\n    [(= n 3) 0]\n    [(= n 4) ((+ (fib4 (- n 2)) (fib4 (- n 1))) (fib4\
    \ (- n 3))) (fib4 (- n 4))]\n    [else 0]))\n", "  (if (= n 0)\n      0\n    \
    \  (if (= n 1)\n          0\n          (+ (fib4 (- n 1)) (fib4 (- n 2))\n    \
    \         (fib4 (- n 3)) (fib4 (- n 4)))))) ;; (fib4 10)\n</code>\n<|/ a tags=scheme,fibonacci,racket\
    \ |>\n<| a dscore=1 tags=scheme,fibonacci,racket |>\nIn case you didn't know,\
    \ fib 0 is 0. So we can ignore this case. Next, when we call fib, we use the last\
    \ two numbers to generate the next number. So:\n<code>", "  (cond [(< n 1) 0]\n\
    \        [(< n 2) 1]\n        [(< n 3) 1]\n        [(< n 4) 1]\n        [else\
    \ (+ (fib4 (- n 1)) (fib4 (- n 2)) (fib4 (- n 3)) (fib4 (- n 4)))]))\n\n#lang\
    \ racket\n", "  (define (fib4-aux n)\n    (cond [(= n 1) 0]\n          [(= n 2)\
    \ 2]\n          [else (+ (fib4-aux (- n 1)) (fib4-aux (- n 2)))]))\n  (fib4-aux\
    \ n))\n", "  (cond [(= n 0) 0]\n        [(= n 1) 0]\n        [(= n 2) 2]\n   \
    \     [(= n 3) 0]\n        [else (+ (fib4 (- n 4)) (fib4 (- n 3)) (fib4 (- n 2))\
    \ (fib4 (- n 1))) ]))\n", "  (cond [(< n 0)\n         (error)\n         (fib4\
    \ 0 1 0 2)]\n        [(< n 1)\n         (error)\n         (fib4 0 1 0 2)]\n  \
    \      [(< n 2)\n         (error)\n         (fib4 0 1 0 2)]\n        [(< n 3)\n\
    \         (error)\n         (fib4 0 1 0 2)]\n        [else\n         (let ([a\
    \ (b (c (d 0 1 0 2)))])\n           (if (< n 4)\n               (fib4 n d c b)\n\
    \               (fib4 n d a b )))]))\n", "  (cond ((= n 0) 0)\n        ((= n 1)\
    \ 0)\n        ((= n 2) 2)\n        ((= n 3) 0)\n        ((= n 4) ((fib4 (- n 1))\
    \ (fib4 (- n 2)) (fib4 (- n 3)) (fib4 (- n 4)))))\n)\n", "  (cond [(= n 0) 0]\n\
    \        [(= n 1) 0]\n        [(= n 2) 2]\n        [(= n 3) 0]\n        [else\
    \ (+ (fib4 (- n 4))\n                    (fib4 (- n 3))\n                    (fib4\
    \ (- n 2))\n                    (fib4 (- n 1)))]))\n", "  (if (= n 0)\n      0\n\
    \      (+ (fib4 (- n 1)) (fib4 (- n 2)) (fib4 (- n 3)) (fib4 (- n 4)))))\n\n#lang\
    \ racket\n", "  (if (<= n 4)\n      0\n      (+ (fib4 (- n 1)) (fib4 (- n 2))\
    \ (fib4 (- n 3)) (fib4 (- n 4)))))\n", "  ((if (= n 0) 0\n      (+ (fib4 (- n\
    \ 1))\n         (fib4 (- n 2))\n         (fib4 (- n 3))\n         (fib4 (- n 4))))))\n",
  "  (if (= n 0) 0 (if (= n 1) 0 (+ (fib4 (- n 1))\n                             \
    \         (fib4 (- n 2))\n                                      (fib4 (- n 3))\n\
    \                                      (fib4 (- n 4))))))\n", "  (+ (fib4 (- n\
    \ 1)) (fib4 (- n 2)) (fib4 (- n 3)) (fib4 (- n 4))))\n</code>\n<|/ a tags=racket,scheme\
    \ dscore=0 |>\n<| c |>\nThis solution is O(n^3). Try it for n = 10.\n<|/ c |>\n\
    <| c |>\nI think this solution is O(n), even without the memoization. But the\
    \ question states that recursive solution is desired, so I assumed that memoization\
    \ would be required, but I could be wrong.\n<|/ c |>\n<| c |>\nIt's O(n^3), not\
    \ O(n^4). :)\n<|/ c |>\n<| c |>\nThanks. What did I do wrong?\n<|/ c |>\n<| c\
    \ |>\nYour `fib4` function has a bad name. In fact, its name suggests that it\
    \ would be `fibonacci`, but that's not what it does. Names matter. `fibonacci`\
    \ means \"a function that computes the nth fibonacci number\", not \"a function\
    \ that computes the nth Fibonacci number\". The latter means a function that computes\
    \ fibonacci numbers that are in descending order.\n<|/ c |>\n<| a dscore=0 |>\n\
    The other answers all use recursion to achieve the correct result, which is O(n).\
    \ However, you can do it in O(1) space by using a hash table. Here's a solution\
    \ using the racket/hash module:\n<code>\n#lang racket/hash\n", "  ((cond [(= n\
    \ 0)\n           0]\n        [(= n 1)\n           1]\n        [(= n 2)\n     \
    \      2]\n        [(= n 3)\n           3]\n        [else\n           (+ (fib4\
    \ (- n 1)) (fib4 (- n 2)) (fib4 (- n 3)) (fib4 (- n 4))))]))\n", "  (cond [(<\
    \ n 0) 0]\n        [(< n 1) 0]\n        [(< n 2) 2]\n        [(< n 3) 0]\n   \
    \     [(< n 4) 0]\n        [else (+ (fib4 (- n 4)) (fib4 (- n 3))\n          \
    \              (fib4 (- n 2))\n                        (fib4 (- n 1)))]))", " \
    \ (cond [(= n 0) 0]\n        [(= n 1) 0]\n        [(= n 2) 2]\n        [(= n 3)\
    \ 0]\n        [else (+ (fib4 (- n 4)) (fib4 (- n 3)) (fib4 (- n 2)) (fib4 (- n\
    \ 1))) ]))\n", "  (if (<= n 4)\n      0\n      (+ (fib4 (- n 1))\n         (fib4\
    \ (- n 2))\n         (fib4 (- n 3))\n         (fib4 (- n 4)))))\n</code>\n<|/\
    \ a tags=lisp,fibonacci,racket |>\n<| a dscore=2 tags=lisp,fibonacci,racket |>\n\
    The first part of the answer is that Lisps are very functional languages, meaning\
    \ that you often can implement functions without loops or recursion.  \nThe next\
    \ part is that, in a Lisp like Racket you can implement tail recursion, which\
    \ allows you to implement functions that use recursion for their tail only once.\
    \  \nHere is an example in Racket:\n<code>", "  (cond\n    ((= n 0) 0)\n    ((=\
    \ n 1) 0)\n    ((= n 2) 2)\n    (else (+ (fib4 (- n 4)) (fib4 (- n 3))) (fib4\
    \ (- n 2))))))\n\n#lang racket\n", "  (cond ((= n 0)\n         0)\n        ((=\
    \ n 1)\n         0)\n        (else (+ (fib4 (sub1 n)) (fib4 (sub2 n)) (fib4 (sub3\
    \ n)) (fib4 (sub4 n))))))\n", "  (+ (fib4-helper 0 1 2 3 4 5 6 7 8)\n     (fib4-helper\
    \ 0 1 2 3 4 5 6 7 8)))\n", "  (fib4-helper n 4 '() 0))\n", "  (if (= n 0)\n  \
    \    0\n      (+ (fib4 (- n 1)) (fib4 (- n 2)) (fib4 (- n 3)) (fib4 (- n 4)))))\n",
  "  (cond ((= n 1) 0)\n        ((= n 2) 2)\n        (else (+ (fib4 (- n 1)) \n  \
    \               (fib4 (- n 2)) \n                 (fib4 (- n 3)) \n          \
    \       (fib4 (- n 4))))))\n", "  (cond [(= n 0) 0]\n        [(= n 1) 0]\n   \
    \     [(= n 2) 2]\n        [(= n 3) 0]\n        [else (+ (fib4 (- n 4)) (fib4\
    \ (- n 3)) (fib4 (- n 2)) (fib4 (- n 1)))]))\n", "  (cond\n    ((= n 0) 0)\n \
    \   ((= n 1) 0)\n    ((= n 2) 2)\n    (else (+ (fib4 (- n 4)) (fib4 (- n 3)))\
    \ (fib4 (- n 2)))))\n", "  (if (< n 2)\n      n\n      (+ (fib4 (- n 1)) \n  \
    \       (fib4 (- n 2))\n         (fib4 (- n 3))\n         (fib4 (- n 4)))))\n",
  "  (fib n 4))\n", "  (if (= n 0)\n      0\n      (+ (fib4 (- n 1)) (fib4 (- n 2))\
    \ (fib4 (- n 3)) (fib4 (- n 4)))))\n", "  (cond\n    [(= n 1) 0]\n    [(= n 2)\
    \ 2]\n    [(= n 3) 0]\n    [else (+ (fib4 (sub1 n)) (fib4 (sub1 n)) (fib4 (sub1\
    \ n)) (fib4 (sub1 n))) ]))\n", "  (if (<= n 4)\n      (fib4 (- n 1) 0)\n     \
    \ (+ (fib4 (- n 2) (+ (fib4 (- n 3) (+ (fib4 (- n 4) 0)))))))\n", "  (cond [(=\
    \ n 0) 0]\n        [(= n 1) 0]\n        [(= n 2) 2]\n        [(= n 3) 0]\n   \
    \     [(= n 4) 3]\n        [else (+ (fib4 (- n 4)) (fib4 (- n 3)) (fib4 (- n 2))\
    \ (fib4 n)))]))\n", "  (cond\n    ((= n 0) 0)\n    ((= n 1) 0)\n    ((= n 2) 2)\n\
    \    ((= n 3) 0)\n    ((= n 4) 0)\n    ((= n 5) 4)\n    ((= n 6) 8)\n    ((= n\
    \ 7) 14)\n    (else (+ (fib4 (- n 2)) (fib4 (- n 1)) (fib4 (- n 3)) (fib4 (- n\
    \ 4))))))\n", "  (cond [(= n 0) 0]\n        [(= n 1) 0]\n        [(= n 2) 2]\n\
    \        [(= n 3) 3]\n        [else (+ (fib4 (sub1 n)) (fib4 (sub2 n)) (fib4 (sub3\
    \ n)) (fib4 (sub4 n)))]))\n", "  (cond\n    [(< n 0) 0]\n    [(< n 1) 0]\n   \
    \ [else (+ (fib4 (- n 2)) (fib4 (- n 1)) (fib4 (- n 3)) (fib4 (- n 4)))]))\n",
  "  (if (= n 0)\n      0\n      (+ (fib4 (- n 1))\n         (fib4 (- n 2))\n    \
    \     (fib4 (- n 3))\n         (fib4 (- n 4)))))\n", "  (cond\n    [(= n 0) 0]\n\
    \    [(= n 1) 0]\n    [(= n 2) 2]\n    [(= n 3) (fib4 (- n 1))]\n    [(= n 4)\
    \ (fib4 (- n 2)) (fib4 (- n 3))]\n    [else (fib4 (- n 4)) (fib4 (- n 3)) (fib4\
    \ (- n 2)) (fib4 (- n 1))]))\n", "  (if (< n 4)\n      n\n      (+ (fib4 (- n\
    \ 2)) (fib4 (- n 3))) (fib4 (- n 4))))\n\n#lang racket\n", "  (cond [(= n 0) 0]\n\
    \        [(= n 1) 0]\n        [(= n 2) 2]\n        [(= n 3) 0]\n        [else\
    \ (+ (fib4 (- n 1))\n               (fib4 (- n 2))\n               (fib4 (- n\
    \ 3))\n               (fib4 (- n 4)))))]", "  (if (= n 1)\n      0\n      (+ (fib4\
    \ (- n 1)) (fib4 (- n 2))\n         (fib4 (- n 3)) (fib4 (- n 4)))))\n\n#lang\
    \ racket\n", "  (cond [(= n 0) 0]\n        [(= n 1) 1]\n        [(= n 2) 2]\n\
    \        [(= n 3) 3]\n        [else (+ (fib4 (- n 1)) (fib4 (- n 2)) (fib4 (-\
    \ n 3)) (fib4 (- n 4))) ]))\n", "  (cond [(= n 0) 0]\n        [(= n 1) 0]\n  \
    \      [(= n 2) 2]\n        [(= n 3) 0]\n        [(= n 4) 0]\n        [else (+\
    \ (fib4 (- n 4)) (fib4 (- n 3))\n                      (fib4 (- n 2))\n      \
    \                (fib4 (- n 1)))]))\n", "  (cond [(= n 0)\n         (list 0)]\n\
    \        [(= n 1)\n         (list 0)]\n        [(= n 2)\n         (list 2)]\n\
    \        [(= n 3)\n         (list 0)]\n        [else\n         (cons (+ (first\
    \ (rest n)) (second (first n)))\n                (fib4 (sub1 (rest n))))]))\n\n\
    #lang racket\n", "  (if (= n 0)\n      0\n      (+ (fib4 (sub1 n)) (fib4 (sub1\
    \ n)) (fib4 (sub1 n)) (fib4 (sub1 n)))))\n", "  (cond\n    [(= n 0) 0]\n    [(=\
    \ n 1) 0]\n    [(= n 2) 2]\n    [(= n 3) (fib4 (- 3 1))]\n    [else (+ (fib4 (-\
    \ 3 2)) (fib4 (- 3 3)) (fib4 (- 3 4))) ]))\n", "  (if (= n 0)\n      0\n     \
    \ (+ (fib4 (- n 1)) (fib4 (- n 2)) (fib4 (- n 3)) (fib4 (- n 4)))))\n", "  (let\
    \ loop ((i 0) (a 0) (b 1) (c 2) (d) (if (< n 5) a (c (+ b c))))\n    (if (< n\
    \ 5)\n        a\n        (loop (+ i 1) (+ a b) (+ b c) (+ c d) (d))))\n</code>\n\
    <|/ a tags=racket,scheme,fibonacci,recursion |>\n<| c |>\nI don't think this is\
    \ quite what was asked for. Specifically, I don't think this takes into account\
    \ that fib1 should be 0.  Additionally, it seems that it would be possible to\
    \ write the code with only 6 lines, and that it is easier to understand.\n<|/\
    \ c |>\n<| c |>\n: I see what you mean (I added a line that does that).\n<|/ c\
    \ |>\n<| c |>\nBut that doesn't take into account that fib1 should be 0.\n<|/\
    \ c |>\n<| c |>\n: That is what I thought he was asking for, since he wrote that.\
    \  I guess the question was ambiguous.  I changed my answer to include that info.\
    \  Thanks!\n<|/ c |>\n<| c |>\nThanks Chris. Your solution is very nice. I'll\
    \ read about the \"let\" and \"loop\" keywords.\n<|/ c |>\n<| a tags=racket,scheme,fibonacci,recursion\
    \ dscore=2 |>\nAs you requested I tried to write it for you, I hope this helps:\n\
    <code>", "  (cond [(= n 0) 0]\n        [(= n 1) 1]\n        [(= n 2) 2]\n    \
    \    [(= n 3) 3]\n        [else (+ (fib4 (- n 4)) (fib4 (- n 3)) (fib4 (- n 2))\
    \ (fib4 (- n 1)))]))\n", "  (fib n 0 1))\n", "  (if (<= n 0)\n      0\n      (+\
    \ (fib4 (- n 1))\n         (fib4 (- n 2))\n         (fib4 (- n 3))\n         (fib4\
    \ (- n 4)))))\n", "  (define (helper-fib n a b c d)\n    (cond ((= n 0) a)\n \
    \         ((= n 1) b)\n          ((= n 2) c)\n          ((= n 3) d)\n        \
    \  (else (helper-fib (- n 1)\n                              (+ a b)\n        \
    \                      (+ c d)\n                              (+ d e)))\n    \
    \      ))\n  (helper-fib n 1 1 1 1))\n", "  (if (= n 0) 0\n      (if (= n 1) 1\n\
    \          (+ (fib4 (- n 2)) (fib4 (- n 3)) (fib4 (- n 4)))))) ;; #lang racket\n",
  "  (if (= n 0)\n      0\n      (+ (fib4 (- n 1)) (* (fib4 (- n 2)) (fib4 (- n 3)))\
    \ (fib4 (- n 4)))))\n", "  (cond [(= n 0) 0]\n        [(= n 1) 0]\n        [(=\
    \ n 2) 2]\n        [(= n 3) 3]\n        [(= n 4) 5]\n        [else (+ (fib4 (-\
    \ n 1)) (fib4 (- n 2)) (fib4 (- n 3)) (fib4 (- n 4)))))\n", "  (cond ((= n 0)\
    \ 0)\n        ((= n 1) 0)\n        ((= n 2) 2)\n        (else (+ (fib4 (- n 1))\
    \ (fib4 (- n 2)) (fib4 (- n 3)) (fib4 (- n 4))))))\n", "  (if (zero? n)\n    \
    \  0\n      (+ (fib4 (sub1 n)) (fib4 (sub2 n)) (fib4 (sub3 n)) (fib4 (sub4 n))))\n\
    \  )\n", "  (cond [(= n 0) 0]\n        [(= n 1) 0]\n        [(= n 2) 2]\n    \
    \    [(= n 3) 0]\n        [(= n 4) (fib4 (- n 5))]))\n", "  (if (= n 0)\n    \
    \  0\n      (+ (fib4 (- n 1)) (fib4 (- n 2)) (fib4 (- n 3)) (fib4 (- n 4)))))\n",
  "  (cond ((< n 0) 0)\n        ((= n 0) 0)\n        ((= n 1) 1)\n        (else (+\
    \ (fib4 (- n 4)) (fib4 (- n 3)) (fib4 (- n 2)) (fib4 (- n 1)))))\n)\n", "  (cond\
    \ [(= n 0) 0]\n        [(= n 1) 1]\n        [(= n 2) 2]\n        [(= n 3) 3]\n\
    \        [else (+ (fib4 (- n 4)) (fib4 (- n 3)) (fib4 (- n 2)) (fib4 (- n 1)))))\n\
    </code>\n<|/ q |>\n<| c |>\nI see that the first `fib3` was intended to be `fib4`,\
    \ but you have `fib3` in the question text as well as `fib4` in the code.\n<|/\
    \ c |>\n<| c |>\nYes, my bad, edited to correct that now. Sorry about that\n<|/\
    \ c |>\n<| c |>\nNo worries - I've edited the question text to hopefully clarify\
    \ things a bit.\n<|/ c |>\n<| c |>\nThank you for the edit!\n<|/ c |>\n<| a dscore=2\
    \ |>\nYou can improve the efficiency of your function by implementing the function\
    \ using tail recursion:\n<code>", "  (fib n 0 1))\n", "  (define (next a b)\n\
    \    (if (< a n)\n        a\n        (if (< b n)\n            b\n            (if\
    \ (< a (+ b a))\n                (+ a b)\n                (+ a (b next)))))\n\
    \  (next 1 0))\n", "  (if (< n 4)\n      (fib4 (- n 4)) \n      (if (= n 0)\n\
    \          0 \n          (+ (fib4 (- n 1)) (fib4 (- n 2)) (fib4 (- n 3)) (fib4\
    \ (- n 4))))))\n", "  (if (= n 0)\n      0\n      (+ (fib4 (- n 1)) (fib4 (- n\
    \ 2)) (fib4 (- n 3)) (fib4 (- n 4)))))", "  (cond ((= n 0) 0)\n        ((= n 1)\
    \ 0)\n        ((= n 2) 2)\n        (else (+ (fib4 (- n 1))\n                (fib4\
    \ (- n 2))\n                (fib4 (- n 3))\n                (fib4 (- n 4))))))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
