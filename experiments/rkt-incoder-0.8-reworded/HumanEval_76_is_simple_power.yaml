name: HumanEval_76_is_simple_power
language: rkt
prompt: "#lang racket\n\n;; Your task is to write a function that returns true if\
  \ a number x is a simple\n;; power of n and false in other cases.\n;; x is a simple\
  \ power of n if n**int=x\n;; For example:\n;; >>> (is_simple_power 1 4)\n;; true\n\
  ;; >>> (is_simple_power 2 2)\n;; true\n;; >>> (is_simple_power 8 2)\n;; true\n;;\
  \ >>> (is_simple_power 3 2)\n;; false\n;; >>> (is_simple_power 3 1)\n;; false\n\
  ;; >>> (is_simple_power 5 3)\n;; false\n(define (is_simple_power x n)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate is_simple_power))\n\
  \    (check-equal? (candidate 16 2) #t)\n    (check-equal? (candidate 143214 16)\
  \ #f)\n    (check-equal? (candidate 4 2) #t)\n    (check-equal? (candidate 9 3)\
  \ #t)\n    (check-equal? (candidate 16 4) #t)\n    (check-equal? (candidate 24 2)\
  \ #f)\n    (check-equal? (candidate 128 4) #f)\n    (check-equal? (candidate 12\
  \ 6) #f)\n    (check-equal? (candidate 1 1) #t)\n    (check-equal? (candidate 1\
  \ 12) #t)\n))\n\n(test-humaneval)"
completions: ["  (cond ((= n 0) true)\n        ((= n 1) (= x 1))\n        ((= (square\
    \ (mod x n)) x) (is_simple_power x (- n 1)))))", "  (cond\n    ((= x 1) (= n 1))\n\
    \    ((= x n) (= n 1))\n    ((= x (* n n)) (= n 1))\n    ((> x n) (= n 1))\n \
    \   (else (= (* n (* n x))\n               (= x (* n (* n n))\n              \
    \       (* n (* n x))\n                     (* n x))))))\n</textarea></form>\n\
    \    <script>\n      var editor = CodeMirror.fromTextArea(document.getElementById(\"\
    code\"), {\n        lineNumbers: true,\n        matchBrackets: true,\n       \
    \ mode: \"text/x-racket\"\n      });\n    </script>\n\n    <p><strong>MIME types\
    \ defined:</strong> <code>text/x-racket</code>.</p>\n\n    <p>Development of the\
    \ CodeMirror Racket mode was sponsored by the\n    <a href=\"https://racket-lang.org/\"\
    >Racket Project</a>\n    and Leopold Thiemann (<a href=\"https://twitter.com/roblest\"\
    >@roblest</a>).\n    \n    <li>The <a href=\"https://codemirror.net/doc/manual.html#addon_foldcode\"\
    >folding API</a> allows\n    you to define a <code>fold</code> function that will\
    \ give fold widget\n    updates. See the <a href=\"../demo/folding.html\">demo</a>.</li>\n\
    \    <li>New\n    modes: <a href=\"../mode/diff/index.html\">diff</a>, <a href=\"\
    ../mode/clojure/index.html\">clojure</a>,\n    <a href=\"../mode/ebnf/index.html\"\
    >ebnf</a>, <a href=\"../mode/livescript/index.html\">LiveScript</a>,\n    and\
    \ <a href=\"../mode/mirc/index.html\">mIRC</a>.</li>\n    <li>New options: <a\
    \ href=\"manual.html#option_cursorScrollMargin\"><code>cursorScrollMargin</code></a>\
    \ and <a href=\"manual.html#option_coverGutterNextToScrollbar\"><code>coverGutterNextToScrollbar</code></a>.</li>\n\
    \    <li>New events: <a href=\"manual.html#event_doc_beforeChange\"><code>\"beforeChange\"\
    </code></a>, <a href=\"manual.html#event_doc_cursorActivity\"><code>\"cursorActivity\"\
    </code></a>, <a href=\"manual.html#event_doc_beforeSelectionChange\"><code>\"\
    beforeSelectionChange\"</code></a>.</li>\n    <li>Many improvements to the <a\
    \ href=\"manual.html#event_doc_inView\"><code>\"inView\"</code></a> event.</li>\n\
    \    <li>Tweak behavior of some scrollbar buttons in update\n    <a href=\"manual.html#scroll_to_selection\"\
    >selection</a> events:\n    <a href=\"manual.html#scroll_to_selection\"><code>\"\
    start\"</code></a>\n    and <a href=\"manual.html#scroll_to_selection\"><code>\"\
    end\"</code></a>.</li>\n    <li>Add <a href=\"manual.html#event_refresh\"><code>\"\
    refresh\"</code></a> ", "  (let loop ((x x) (n n))\n    (cond ((= x 1) #t)\n \
    \         ((= x n) #f)\n          (else (loop (/ x n) (* n x))))))\n", "  (cond\
    \ ((= n 0) (= x 0))\n        ((= n (/ x n))\n         (if (= x 1) (true) (is_simple_power\
    \ x (- n 1))))\n        (else (is_simple_power x (- n 1)))))", "  (equal? (square\
    \ (floor (/ x n)) n) x))\n", "  (let loop ((x x) (n (modulo n n)) (acc #t)) ;\
    \ n is power of x\n    (cond\n      [(= n 0)\n       (cond ((= x 1) acc)\n   \
    \          ((and (= x n) (= x 1)) acc)\n             ((and (= x n) (= x n)) acc)])\n\
    \      [(= n 1)\n       (cond ((= x n) acc)]\n      [(< n 1)\n       (loop (/\
    \ x n) (/ n n) (cond ((< x n) acc)\n                                    ((= x\
    \ n) (and (not acc) acc))))]\n      [else (loop (* x n) (* n n) (and (not acc)\
    \ acc))]))) ;; n is power of x", "  (cond ((= x n) (equal? n 1))\n        ((=\
    \ n (expt x n))\n         (equal? x n))\n        (else false)))\n", '  (= (* n
    x) x))', "  (= (* n x) x))\n", "  (cond ((= x 1) (= n 0))\n        ((= n 0) false)\n\
    \        ((= x n) (= (* x n) (/ x n)))\n        (else (is_simple_power (/ x n)\
    \ (- n 1)))))\n", "  (cond ((= n 0) false)\n        ((even? n) (= (expt x 2) x))\n\
    \        (else (= (expt x n) (expt x n-1)))))\n", "  (= n (mod x n)))\n", "  (if\
    \ (= n 1)\n      x\n      (power-of-2 (* x n) x)))\n", "  (= n (* x x))\n  (=\
    \ n (* n n)))\n", "  (cond [(= n 0) (= x 0)]\n        [(= n 1) (= x 1)]\n    \
    \    [(= x 1) (= x n)]\n        [(= (mod x n) 0) (is_simple_power (/ x n) n)]))\n",
  '  (= (* n (* x x)) x))', "  (if (= n 1)\n      (= (mod x n) 0)\n      ;; Not a\
    \ power of n\n      (not (= x (* n (* n x))))))\n", "  (define (helper x n)\n\
    \    (cond\n      [(= n 0) true]\n      [(= n 1) true]\n      [else (equal? (*\
    \ n (expt x n)) x) (helper (/ x n) (- n 1))]))\n  (helper x n))", "  (= (remainder\
    \ x (* n n)) 0))\n", "  (and (= n 1) (= x (square (expt x n))))))\n", "  (cond\n\
    \    ((= n 1) x)\n    ((= x 1) x)\n    ((= x x) x)\n    ((= (mod x n) 0) (= n\
    \ 1))\n    (else false)))\n", "  (equal? n (square (modulo x n))) ;; n**int=x\
    \ iff n**int=x\n  )\n", "  (cond\n    [(= x 1) true]\n    [(= n 1) true]\n   \
    \ [else (is_simple_power (/ x n) (- n 1))]))\n", "  (= x (* n (power x n))))\n",
  "  (define (is_power_of_n n)\n    (if (= n 0) true false))\n  (define (is_power_of_n_times\
    \ n)\n    (let loop ((x x)\n               (acc 0))\n      (if (= x 0)\n     \
    \     (= acc n)\n          (loop (/ x n) (+ acc 1)))))\n  (is_power_of_n n)\n\
    \  (is_power_of_n_times n))\n", "  (= (* x x) (* n (expt x n))))\n", "  (= (integer-power-mod\
    \ x n) (* n x)))\n", "  (= n (* x x)))\n", "  (if (= n 1)\n      (eq? x x)\n \
    \     (eq? (* n (expt x n)) x)))\n", "  (= n (* x (round x))))\n", "  (and (not\
    \ (and (= n 0) (= x 1)))\n       (= x (* (expt n x))))) ;; n**int=x\n</cell>\n\
    <text>\nExercise 3\nYour task is to implement the function is_power_of_two, which\
    \ returns true if n is a power of two and false otherwise.\n\n</text>\n<cell>",
  "  (= x (* n (power x n))))\n", "  (= (recip n) x))\n", "  (= x (* n (expt n int))))\n",
  "  (< (square x) (* n n)))\n", "  (if (= n 0)\n      #f\n      (= (mod-mul x (pow-mul\
    \ x n)) x)))\n", "  (< (expt x n) 1))\n", "  (cond\n    [(= x 0) true]\n    [(=\
    \ n 1) true]\n    [(= n 2) true]\n    [else (= x (* n (* n x))\n)]))\n", "  (cond\
    \ ((= x 1) (= n 1))\n        ((= n 0) false)\n        (else (= (* n (* x (- x\
    \ 1))) x)\n              (is_simple_power x (- n 1)))))\n", "  (cond\n    ((=\
    \ n 1) (= x 1))\n    ((= n 0) (= x 0))\n    ((= x 1) (= n (expt 2 n)))\n    ((=\
    \ x 0) (= n (expt 1 n)))\n    ((= n (expt x 2))\n    (= (pow (expt x 2) n) x))\n\
    \    ((= n (expt x 1))\n    (= (pow (expt x 1) n) x))\n    ((= n (expt x n))\n\
    \    (= (pow (expt x n) n) x))))\n", "  (= (power x n) x))\n", "  (cond ((= n\
    \ 1) (= x 1))\n        ((= n 0) (= x 0))\n        ((> (* x x) (* n n)) (is_simple_power\
    \ x (- n 1)))\n        (else #f)))\n", "  (equal (mod x (* n n)) 0))\n", "  (cond\n\
    \    ((= x 0) true)\n    ((= x 1) true)\n    ((= x n) (= (* n x) x))\n    (else\
    \ false)))\n", "  (cond\n    [(= n 0) false]\n    [(= x 1) true]\n    [(= n (*\
    \ x x))\n     ((is_simple_power x (- n 1))\n      (cond (\n\t[(= n 0) true]\n\t\
    [else false]))]\n    [else false]))\n", "  (cond\n    [(< x n) false]\n    [else\
    \ (= (pow x n) x) true]))\n", "  (define (n-pow-int x n)\n    (if (= n 0)\n  \
    \    1\n      (* (* x x) (- n 1))))\n\n  (if (= n 0)\n    #t\n    (= (mod x n)\
    \ (- 1 (* n (n-pow-int x n))))))\n", "  (cond\n    ((= x 1) #t)\n    ((= x n)\
    \ #f)\n    ((= n (floor (log x n)))\n     (= x n**n))\n    (else (is_simple_power\
    \ x (- n 1)))))\n", "  (if (= (mod (* x x) n) x)\n      #t\n      #f))", "  (cond\
    \ [(= n 1) true]\n        [(= x 1) true]\n        [(= n (expt x n)) true]\n  \
    \      [else false]))\n", "  (if (= n 1)\n      true\n      (if (= (modulo x n)\
    \ 0)\n          (is_simple_power x (- n 1))\n          false))))\n", "  (= (*\
    \ n (floor (sqrt (/ x n)))) x))\n", "  (let loop ([x x] [n n]\n             [acc\
    \ 0])\n    (cond\n      [(= x 1) (= acc 1) (= n 1) true]\n      [(zero? n) (=\
    \ acc 1) (= n 1) true]\n      [(zero? acc) (= x 1) (= n 1) false]\n      [(= acc\
    \ (floor (/ x n)))\n       (loop x (/ x n) (+ acc 1))]\n      [else (= acc 1)\
    \ (= n 1) false]\n      )))\n", "  (cond [(= n 1) true]\n        [(= x 1) false]\n\
    \        [(= (^ x n) x) (is_simple_power x (- n 1))]\n        [else false]))\n",
  "  (= x n))\n</cell>\n<code language=racket-cduh>", "  (cond [(= x (* x n)) true]\n\
    \        [else false]))\n", "  (= (square (- n x)) x))\n", "  (cond ((= n 1) #t)\n\
    \        ((= n x) #f)\n        (else\n         (<= (* n n) x)\n         (power-of-x\
    \ n x)))))\n", "  (cond ((= n 0) #t)\n        ((= n 1) #t)\n        ((= x (* n\
    \ n)) #t)\n        (else #f)))\n", "  (cond ((= n 0) #t)\n        ((= n 1) #t)\n\
    \        ((= x 1) #t)\n        ((= x (* n (expt x n)))\n         (is_simple_power\
    \ x (sub1 n)))))\n", "  (cond ((= x n) t)\n        ((= x 0) nil)\n        ((=\
    \ (mod x n) 0) t)\n        (else (is_simple_power (/ x n) n))))\n", "  (and (equal?\
    \ n (floor x))\n       (= (* x n) (floor x))))\n", "  (cond ((= n 1) (= x 1))\n\
    \        ((= x 1) (= x n))\n        (else false)))\n#lang racket\n", "  ;; Your\
    \ code goes here!\n)\n", "  (cond\n    [(= n 1) (= x 1)]\n    [else (or (is_simple_power\
    \ (/ (* x x) n) (- n 1)) false)]))\n", "  (= x (expt x n)))\n", "  (cond ((= n\
    \ 0) true)\n        ((= n 1) true)\n        ((= (square (square-root x n)) x)\
    \ true)\n        ((= (square (square-root x n)) (square (square-root x n))))\n\
    \        (else false)))\n", "  (let ((power (round (n**int))))\n    (= x (* n\
    \ (- n power)))))\n", "  (if (= 0 (mod x n))\n      #t\n      #f))\n", "  (cond\
    \ ((= n 0) true)\n        ((= n 1) true)\n        ((= (* x x) n) true)\n     \
    \   (else false)))\n", "  (cond\n    [(= n 0) true]\n    [(and (= x 1) (= n 1))\
    \ true]\n    [(= (* n x) (* x n)) true]\n    [else false]))\n", "  (cond [(= x\
    \ 1) true]\n        [(= n 0) false]\n        [else (= (* n (expt x 2)) x)]\n \
    \       ))\n", "  (= (remainder x n) (quotient x n)))\n  \n", "  (= x (exp (*\
    \ n x))))\n", "  (cond\n    [(= n 0) false]\n    [(= n 1) true]\n    [else\n \
    \     (cond [(= (* n x) n) (is_simple_power x n-1)]\n            [else (is_simple_power\
    \ x (sub1 n))]))]))\n", "  (and (equal? n 1) (= x 1)))\n  ;; If x=1 then n**1=1\
    \ and n**2=1\n  (define (check x n)\n    (if (= x 1) (equal? (* n n) 1) false))\n\
    \  (if (= x 1) (check x n) false))\n  ;; If x=0 then n**0=1 and n**1=0\n  (define\
    \ (check x n)\n    (if (= x 0) (equal? (* n n) 1) false))\n  (if (= x 0) (check\
    \ x n) false))\n  ;; If x=-1 then n**-1=1 and n**0=0\n  (define (check x n)\n\
    \    (if (= x -1) (equal? (* n n) 1) false))\n  (if (= x -1) (check x n) false))\n",
  "  (cond\n    [(= x n) true]\n    [(= (mod x n) 0) false]\n    [else (is_simple_power\
    \ (quotient x n) (quotient x n))]))\n", "  (cond [(= n 0)\n         true]\n  \
    \      [else (= (* n (car x))\n                  (car (cdr x)))]))\n", "  ;; x\
    \ must be a power of n\n  (define (power-of? n)\n    ;; n is a power of n if n**int=x\n\
    \    (if (= n 1)\n        #t\n        (if (= (* n (expt x n)) x)\n           \
    \ #t\n            #f)))\n  (power-of? (expt x n)))\n", "  (= x (* n (power x n))))\n",
  "  (and (number? x)\n       (= x n)\n       (= (* x x) x)))\n", "  (equal? (expt\
    \ x n) (expt x 1)))\n#lang racket\n", "  (= n (power_of_list x)))\n", "  (= x\
    \ n))\n", "  (= (remainder x n) 0))\n", "  (define (sqrt x)\n    (/ (* x x) 0.5))\n\
    \  (define (is_power_of_2 x)\n    (= (mod x 2) 0))\n  (if (= n 0)\n      true\n\
    \      (and (and (= n 1)\n               (= x 1))\n           (not (and (is_power_of_2\
    \ x)\n                      (is_power_of_2 n))))))\n</code>\n<|/ a |>\n<| a tags=racket,scheme,lisp\
    \ |>\nAnother solution using Scheme macros:\n<code>", "  (= x (* n n)))\n", " \
    \ (cond [(= n 1) true]\n        [(= x 0) true]\n        [(= n (* x x)) (is_simple_power\
    \ x (- n 1))]\n        [else false]))\n", "  (or (= n (expt x n)) (= 1 (expt x\
    \ n))))\n", "  (= (* n x) x))\n", "  (= x (* n (* n (* n (* n n)))) x))\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nI thought the question was about an implementation\
    \ in Scheme, not Clojure.\n<|/ c |>\n<| c |>\nThe question says \"implement it\
    \ in Scheme\"\n<|/ c |>\n<| a dscore=1 |>\nHere's an implementation for Scheme:\n\
    <code>", "  (equal (mod x n) 0))\n", "  (let ([y x])\n    (if (= n 1)\n      \
    \  (= x 0)\n        (if (= n 2)\n            (= y 0)\n            (= y x))\n \
    \       (if (= n 3)\n            (= y 0)\n            (= y x)\n            (=\
    \ (+ y (* x x)) x)))\n    (eqv? (mod x n) x)))\n", "  (and (<= n 1)\n       (=\
    \ (* (expt x n) n) x)))\n", "  (equal (powers x n) (list x)))\n", "  (cond ((=\
    \ n 0) true)\n        ((= n 1) true)\n        ((= x 1) (= n (expt x 1))))\n  (cond\
    \ ((= x n) (= n (expt x 1)))\n        ((= n (expt x 2)) (= x n))\n        ((=\
    \ n (expt x 3)) (= x n)))\n  (cond ((= x n) (= n (expt x 4)))\n        ((= n (expt\
    \ x 5)) (= x n)))\n  (cond ((= x n) (= n (expt x 6)))\n        ((= n (expt x 7))\
    \ (= x n)))\n  (cond ((= x n) (= n (expt x 8)))\n        ((= n (expt x 9)) (=\
    \ x n)))\n  (cond ((= x n) (= n (expt x 10)))\n        ((= n (expt x 11)) (= x\
    \ n)))\n  (cond ((= x n) (= n (expt x 12)))\n        ((= n (expt x 13)) (= x n)))\n\
    \  (cond ((= x n) (= n (expt x 14)))\n        ((= n (expt x 15)) (= x n)))\n \
    \ (cond ((= x n) (= n (expt x 16)))\n        ((= n (expt x 17)) (= x n)))\n  (cond\
    \ ((= x n) (= n (expt x 18)))\n        ((= n (expt x 19)) (= x n)))\n  (cond ((=\
    \ x n) (= n (expt x 20)))\n        ((= n (expt x 21)) (= x n)))\n  (cond ((= x\
    \ n) (= n (expt x 22)))\n        ((= n (expt x 23)) (= x n)))\n  (cond ((= x n)\
    \ (= n (expt x 24)))\n        ((= n (expt x 25)) (= x n)))\n  (cond ((= x n) (=\
    \ n (expt x 26)))\n        ((= n (expt x 27)) (= x n)))\n  (cond ((= x n) (= n\
    \ (expt x 28)))\n        ((= n (expt x 29)) (= x n)))\n  (cond ((= x ", "  (cond\
    \ [(= x n) (= n 0)]\n        [else\n         (= (remainder x n) 0)\n         (is_simple_power\
    \ (quotient x n) n)]))\n", "  (cond [(= n 0) (eq? x 1)]\n        [else (equal?\
    \ (* x (sub1 n)) x)]\n        ))\n", "  (let ([res (expt x n)])\n    (not (= res\
    \ x))))\n", "  (power-of_n x n))\n", "  (cond [(= x 0) true]\n        [(= n 0)\
    \ true]\n        [(= x 1) false]\n        [else (= n (* x x))]))\n", "  (= (*\
    \ n x) x))\n", "  (cond\n    [(= x 0) true]\n    [(= n 0) false]\n    [(= n 1)\
    \ true]\n    [else (= (* x x) (expt x n))]))\n", "  (cond [(= n 0)\n         true]\n\
    \        [else\n         (= (* x n) (* n (power n x))\n        )]\n      )\n \
    \ )", "  (or (= n (square-root x))\n      (= (square-root x) x)))\n", "  (cond\
    \ ((= n 0) false)\n        ((= n 1) true)\n        ((= x 0) false)\n        ((=\
    \ x 1) true)\n        ((= x 2) true)\n        ((= x n) true)\n        (else false)))",
  "  (cond\n    [(= n 1) true]\n    [(= x 1) true]\n    [(= x x) ((= n n) (= x x))]\n\
    \    [else false]))\n", "  (cond ((= n 1) (= x 1))\n        ((= x n) (= x (- x\
    \ 1)))\n        (else (= x (* (* x n) (pow x n))\n                    (- x (*\
    \ (* x n) (- (pow x n) 1))))))\n", "  (= (mod x n) 0))\n", "  (define (iter x\
    \ n)\n    (cond\n      [(= n 0) x]\n      [(= x 1) x]\n      [else (iter (quotient\
    \ x n) (n-1))]))\n  (iter x n))\n", "  (= (* x n)\n     (modulo x n)))\n", " \
    \ (cond [(= n 1)\n         (= (mod x n) 0)]\n        [(= (mod x n) (* n n))\n\
    \         (= (mod x n) (- n 1))]\n        [else\n         (= (* n n) (* x x))]))\n",
  "  (= (mod1# x (- n 1)) (mod1# n n)))\n", "  (= (* n x) x))\n", "  (cond\n    [(<\
    \ x n) #f]\n    [(= x n) #t]\n    [else (is_simple_power x (- n 1))]))\n", " \
    \ (define (f y n x)\n    (cond ((= n 1) (= x y))\n          (else (f (* x n) (-\
    \ n 1) x))\n          )\n      )\n  (f x n x))\n", "  (= (remainder x n) 0))\n",
  "  (equal (power_of_n x n)\n         (power-of-n x n)))\n", "  (= (* x n) (* n n)))\n",
  "  (cond [(= n 1)  #t]\n        [else    (is_simple_power (* n x) (- n 1))]))\n",
  "  (cond ((= n 0) true)\n        ((= x 1) true)\n        ((= n 1) (= x n))\n   \
    \     ((= x (* x x)) (is_simple_power x (- n 1)))\n        (else false)))\n",
  "  (cond\n    ((= n 1) true)\n    ((= x 1) (= n x))\n    (else false)))\n</cell>\n\
    <cell>\n#lang racket\n", "  (cond ((= n 0) (= x 1))\n        ((= x 0) #f)\n  \
    \      ((= n 1) (= x (+ x 1)))\n        ((= n (* x x))\n         (= x (* x (*\
    \ x x)))\n         (= n (* x x) (* x x) (* x x) (* x x)))\n        (else #f)))\n",
  "  (= (* n x) (* n x))) \n", "  (cond\n    [(= x n) true]\n    [(= n (rem x n))\
    \ true]\n    [else false]))\n", "  (and (= (* n x) (* n (* n x)))\n       (= x\
    \ (* n n))))\n", "  (equal? (powmod x n n) #(/ x n)))\n", "  (cond ((= n 0)\n\
    \         (= x 1))\n        ((= (mod x n) 0)\n         (= (mod x n) x))\n    \
    \    (else\n         (and (equal? (mod x n) (expt n x))\n              (is_simple_power\
    \ (quotient x n) n))))\n", "  (eqv? (* n (round x)) x))\n  )", "  (let ([x x]\n\
    \        [n n])\n    (cond\n      [(= x 0) (= n 0)]\n      [(= n 1) (= x 1)]\n\
    \      [(= x n) (= n 1)]\n      [else (= (* x x) (* n n))])))", "  (= (* n (expt\
    \ x n)\n        (expt x (- n 1))\n        (expt x (- n 2)))\n      x))\n", " \
    \ (= n (pow x n)))\n", "  (= (mod (expt x n) n) x))\n", "  (cond ((= x 1) true)\
    \ (\n           ((= x n) (= (* x x) n)) (\n           (is_simple_power (/ x n)\
    \ (* 2 n)))\n           (else false))))\n", "  (= (* x n)\n     (* x (- n 1))))\n",
  "  (cond [(= x 1) true]\n        [(= x n) true]\n        [(= n (rem x n)) (is_simple_power\
    \ x (/ n 2))]\n        [else false]))\n", "  (define (is_simple_power_helper x\
    \ n)\n    (cond\n      [(= x 1) true]\n      [(= x n) true]\n      [else (is_simple_power_helper\
    \ (/ x n) (add1 n))]\n      ))\n  (is_simple_power_helper x n))\n", '  (= (remainder
    x n) 0))', "  (cond\n    [(zero? n) false]\n    [(equal? (modulo n x) 0) true]\n\
    \    [else (is_simple_power x (sub1 n))]))\n", "  (cond [(= x n) true]\n     \
    \   [else false]))\n", "  (and (= (mod x n) 0)\n       (= (floor (/ x n)) n)))\n",
  '  (= (* x (expt x n)) x))', "  (define (is_factor n)\n    (cond ((= n 1) #t)\n\
    \          ((even? n) #f)\n          ((odd? n) (is_factor (quotient n 2)))))\n\
    \  (cond ((= n 0) #f)\n        ((= n 1) #t)\n        (else (is_factor (quotient\
    \ x n))))\n)\n", "  (if (= n 1)\n      true\n      (and (integer? (car x)) (=\
    \ (car (* x n)) x))))\n", "  (if (= n 0)\n      ;; x is a power of n if n**int=x\n\
    \      (= x (* n (into-integer (exponent x))))\n      (is-simple-power-helper\
    \ (dec n) x false)))\n", "  ;; The idea is simple: \n  ;; If n is 2, then the\
    \ simple power is just x.\n  ;; If n is 1, the simple power is 1.\n  ;; If n is\
    \ 0, the simple power is not defined.\n  (if (= n 2)\n      (= x 1)\n      (=\
    \ x (* n (n->int n)))))\n", "  (cond ((= n 0) (= x 1))\n        ((= n 1) (= x\
    \ 1))\n        ((= n 2) (= x 2))\n        ((= n 3) (= x 4))\n        ((= n 4)\
    \ (= x 8))\n        (else (= x n (+ n (- x 1))))))\n", "  (= (* x n) (* x x)))\n",
  "  (cond ((= n 0) #t)\n        ((= x 1) #t)\n        (else\n         (< (square\
    \ (* x x)) n) #t)))\n", "  (cond\n    [(or (= n 1)\n         (= n 2)\n       \
    \  (= n 3)\n         (= n 4))\n     (= x 1)]\n    [else (> (expt x n) x)]))\n",
  "  (cond\n    ((= n 1) (= x 1))\n    ((= n 0) (= x 0))\n    ((= n x) (= x (* x n)))\n\
    \    (else false)))\n", "  (cond ((= x 1) (= n 1))\n        ((= x n) (= n x))\n\
    \        (else (= n (* x (sub1 n))) (= x (sub1 x)) (is_simple_power x (sub1 n)))))\n",
  "  (cond\n    ((= n 1) (= x 1))\n    ((= n 2) (= x 2))\n    ((= n 4) (= x 4))\n\
    \    ((= n 8) (= x 8))\n    ((= n 16) (= x 16))\n    ((= n 32) (= x 32))\n   \
    \ ((= n 64) (= x 64))\n    ((= n 128) (= x 128))\n    ((= n 256) (= x 256))\n\
    \    ((= n 512) (= x 512))\n    ((= n 1024) (= x 1024))\n    ((= n 2048) (= x\
    \ 2048))\n    ((= n 4096) (= x 4096))\n    ((= n 8192) (= x 8192))\n    ((= n\
    \ 16384) (= x 16384))\n    ((= n 32768) (= x 32768))\n    ((= n 65536) (= x 65536))\n\
    \    ((= n 131072) (= x 131072))\n    ((= n 262144) (= x 262144))\n    ((= n 524288)\
    \ (= x 524288))\n    ((= n 1048576) (= x 1048576))\n    ((= n 2097152) (= x 2097152))\n\
    \    ((= n 4194304) (= x 4194304))\n    ((= n 8388608) (= x 8388608))\n    ((=\
    \ n 16777216) (= x 16777216))\n    ((= n 33554432) (= x 33554432))\n    ((= n\
    \ 67108864) (= x 67108864))\n    ((= n 134217728) (= x 134217728))\n    ((= n\
    \ 268435456) (= x 268435456))\n    ((= n 536870912) (= x 536870912))\n    ((=\
    \ n 1073741824) (= x 1073741824))\n    ((= n 2147483648) (= x 2147483648))\n \
    \   ((= n 4294967296) (= x 4294967296))\n    ((= n 8589934592) (= x 8589934592))\n\
    \    ((= n 17179869184) (= x 17179869184))\n    ((= n 34359738368) (= x 34359738368))\n\
    \    ((= n 68719476736) (= x 68719476736))\n    ((= n 1374389534736) (= x 1374389534736))\n\
    \    ((= n 274877906944", "  (cond\n    ((= n 1) (= x 1))\n    ((= n 2) (= x 2))\n\
    \    ((= n 3) (= x 3))\n    ((= n 4) (= x 4))\n    ((= n 5) (= x 5))\n    ((=\
    \ n 6) (= x 6))\n    ((= n 7) (= x 7))\n    ((= n 8) (= x 8))\n    ((= n 9) (=\
    \ x 9))\n    ((= n 10) (= x 10))\n    ((= n 11) (= x 11))\n    ((= n 12) (= x\
    \ 12))\n    ((= n 13) (= x 13))\n    ((= n 14) (= x 14))\n    ((= n 15) (= x 15))\n\
    \    ((= n 16) (= x 16))\n    ((= n 17) (= x 17))\n    ((= n 18) (= x 18))\n \
    \   ((= n 19) (= x 19))\n    ((= n 20) (= x 20))\n    ((= n 21) (= x 21))\n  \
    \  ((= n 22) (= x 22))\n    ((= n 23) (= x 23))\n    ((= n 24) (= x 24))\n   \
    \ ((= n 25) (= x 25))\n    ((= n 26) (= x 26))\n    ((= n 27) (= x 27))\n    ((=\
    \ n 28) (= x 28))\n    ((= n 29) (= x 29))\n    ((= n 30) (= x 30))\n    ((= n\
    \ 31) (= x 31))\n    ((= n 32) (= x 32))\n    ((= n 33) (= x 33))\n    ((= n 34)\
    \ (= x 34))\n    ((= n 35) (= x 35))\n    ((= n 36) (= x 36))\n    ((= n 37) (=\
    \ x 37))\n    ((= n 38) (= x 38))\n    ((= n 39) (= x 39))\n    ((= n 40) (= x\
    \ 40))\n    ((= n 41) (= x 41))\n    ((= n 42) (= x 42))\n    ((= n 43) (= x 43))\n\
    \    ((= n 44) (= x 44))\n    ((= n 45) (= x 45))\n    ((= n 46) (= x 46))\n \
    \   ((= n 47) (= x 47))\n    ((= n 48) (= x 48))\n    ((= n 49) (= x 49))\n  \
    \  ((= n 50) (= x 50))\n    ((= n 51) (= x 51))\n    ((= n 52) (= x ", "  (if\
    \ (= (* n x) x)\n      #t\n      #f))\n", "  (define (f n x)\n    (if (= n 0)\n\
    \        #t\n        (let ((y (/ x n)))\n          (if (= y 0)\n             \
    \ #f\n              (f (sub1 n) y)\n              ))))\n  (f n x))\n", "  (= (*\
    \ n (power-of-integer x)) x))\n", "  (cond [(= x 1) true]\n        [(= n 1) true]\n\
    \        [(= n (expt x 2)) true]\n        [else false]))\n", "  (cond\n    ((=\
    \ n 1) true)\n    ((= x 1) true)\n    ((= x n) true)\n    (else false)))\n", " \
    \ (cond ((= x 1) #t)\n        ((= n 1) #f)\n        (else (= (* n (/ x n)) x)\
    \ (is_simple_power x (- n 1)))))\n", "  (if (= (mod x n) 0)\n      (= (mod x (expt\
    \ x n)) 0)\n      (= (mod x (expt x (- n 1))) 0)\n      (= (mod x (expt x (- n\
    \ 2))) 0)\n      (= (mod x (expt x (- n 3))) 0)\n      (= (mod x (expt x (- n\
    \ 4))) 0)\n      (= (mod x (expt x (- n 5))) 0)\n      (= (mod x (expt x (- n\
    \ 6))) 0)\n      (= (mod x (expt x (- n 7))) 0)\n      (= (mod x (expt x (- n\
    \ 8))) 0)\n      (= (mod x (expt x (- n 9))) 0)\n      (= (mod x (expt x (- n\
    \ 10))) 0)\n      (= (mod x (expt x (- n 11))) 0)\n      (= (mod x (expt x (-\
    \ n 12))) 0)\n      (= (mod x (expt x (- n 13))) 0)\n      (= (mod x (expt x (-\
    \ n 14))) 0)\n      (= (mod x (expt x (- n 15))) 0)\n      (= (mod x (expt x (-\
    \ n 16))) 0)\n      (= (mod x (expt x (- n 17))) 0)\n      (= (mod x (expt x (-\
    \ n 18))) 0)\n      (= (mod x (expt x (- n 19))) 0)\n      (= (mod x (expt x (-\
    \ n 20))) 0)\n      (= (mod x (expt x (- n 21))) 0)\n      (= (mod x (expt x (-\
    \ n 22))) 0)\n      (= (mod x (expt x (- n 23))) 0)\n      (= (mod x (expt x (-\
    \ n 24))) 0)\n      (= (mod x (expt x (- n 25))) 0)\n      (= (mod x (expt x (-\
    \ n 26))) 0)\n      (= (mod x (expt x (- n 27))) 0)\n      (= (mod x (expt x (-\
    \ n 28))) 0)\n      (= (mod x (expt x (- n 29))) 0)\n      (= (mod x (ex", " \
    \ (define (is_power_of_n x n)\n    (cond\n      [(= x n) true]\n      [else (is_power_of_n\
    \ (/ x n) (quotient n x))]))\n  (is_power_of_n x n))\n", "  (cond [(= n 0) true]\n\
    \        [(= n 1) (= x 1)]\n        [else (= x (* (expt x n)))]))\n", "  (cond\
    \ [(= n 0)\n         #t]\n        [(= (modulo x n) 0)\n         #t]\n        [else\n\
    \         (and (<= (modulo x n) 1)\n              (is_simple_power (quotient x\
    \ n) (remainder x n)))]))\n", "  (cond ((= n 0) (= x 1))\n        ((= n 1) (=\
    \ x x))\n        ((= (mod x n) 0) (is_simple_power x (sub1 n)))\n        (else\
    \ (is_simple_power x (sub1 n)))))\n", "  (cond ((= x 1) true)\n        ((= n 0)\
    \ false)\n        ((even? n) true)\n        ((= (* n n) x) true)\n        (else\
    \ (is_simple_power x (/ n 2)))))\n", "  (= (power (^ x n) n) x))\n", "  (cond\n\
    \    [(= n 0) false]\n    [(= n 1) true]\n    [else (= (* x (- n 1)) (* x n))]\n\
    \  )\n)\n", "  (cond ((= n 1) #t)\n        ((= x 1) #t)\n        (else (= n (*\
    \ x (- x 1))))))\n", "  (= (* n (* n x))\n     (* x (expt n x))))\n", "  (= (*\
    \ n n) x))\n", "  (cond ((= x 1) (= n 1)) \n        ((= x n) (= n (+ n 1))) \n\
    \        (else false)))\n", "  (fold-right (lambda (m acc) (= m n) (= acc (* x\
    \ x)))\n             false\n             x))", "  (if (= x 1)\n      true\n  \
    \    (if (= n 1)\n          (= x (* n x))\n          (and (= x (* x (* n (- n\
    \ 1))))\n               (not (is_simple_power (/ x n) n))))))\n", "  (define (power\
    \ x n)\n    (if (= n 0)\n        1\n        (* n (power x (- n 1)))))\n  (= (power\
    \ x n) x))\n", "  (= x (* n (* n n))))\n", "  (cond ((= n 0) (= x 1))\n      \
    \  ((= x 0) false)\n        (else (= (* x n) (/ x n))\n                (is_simple_power\
    \ x (- n 1)))))\n", "  (cond\n    [(= n 1)\n     (= x 1)]\n    [else (= (* n n)\
    \ x)\n          (= n (sub1 (add1 (sub1 x))))]))\n", "  (cond ((= x 1) (= n 0))\
    \ #t\n        ((= n 0) #f)\n        ((< n 1) #f)\n        ((= x x) (= n (mod x\
    \ n))) #t\n        (else (is_simple_power (sub1 x) (floor n )))))\n", "  (cond\
    \ ((= n 1) (= x 1))\n        ((even? n) (= x (* n x)))\n        (else (and (is_simple_power\
    \ x (/ n 2))\n                    (is_simple_power (* x n) n))))) \n", "  (= (expt\
    \ x n) (expt x n)))\n", "  (cond ((= n 0)\n         #t)\n        ((= (log x n)\
    \ 0)\n         #f)\n        (else (= (log x n) 1)\n               (is_simple_power\
    \ (/ x n) (- n 1)))))\n", "  (cond [(= n 0) true]\n        [(= n 1) true]\n  \
    \      [(= n 2) (= x (* x x))]\n        [else false]))\n", "  (and (= x (* n (*\
    \ n n))) (n= x 1)))\n  ", "  (cond ((= n 0) false)\n        ((= x 1) true)\n \
    \       ((= x (* n n)) true)\n        (else false)))\n</cell>\n<cell>\n#lang racket\n",
  "  (if (= n 0)\n      true\n      (if (= (* n n) x)\n          (is_simple_power\
    \ x (- n 1))\n          false))))\n", "  (cond ((= n 1) (= x 1))\n        ((=\
    \ x 0) (= n 0))\n        ((= x -1) (= n 0))\n        ((= x n) (= n 1))\n     \
    \   (else (is_simple_power (sub1 x) n))))\n", "  (cond [(= x 1) true]\n      \
    \  [else (= (* x x) n) (is_simple_power x (- x 1))]\n  )\n)\n", "  (if (= n 0)\n\
    \      (eq x 0)\n      (or (eq x 1) (= (* x x) n))))\n", '  (= x 1))', "  (cond\n\
    \    ((= x 1) (= n 1))\n    ((= n 1) #t)\n    ((= n 1) #f)\n    ((= x n) #f)\n\
    \    ((= (abs x) n)\n     (is_simple_power x (- n 1)))\n    ((not (= n 0))\n \
    \    (= (log (* x n)) (log (* x n)))\n     (is_simple_power x (- n 1)))))\n",
  "  (if (= x 1) #t #f))\n", "  (cond ((= n 0)\n         (= x 1))\n        ((= (*\
    \ n n) x)\n         (= (* x n) x))\n        (else\n         (= (/ (* x x) n) x)\n\
    \         (= (/ (* x x) n) x)))))\n", "  (= (mod x n) 0))\n", "  ;; (= n 0)\n\
    \  ;; (= n 1)\n  ;; (= n 2)\n  ;; (= n 3)\n  ;; (= n 4)\n  ;; (= n 5)\n  ;; (=\
    \ n 6)\n  ;; (= n 7)\n  ;; (= n 8)\n  ;; (= n 9)\n  ;; (= n 10)\n  (= n (modulo\
    \ (power x n) (power x 2)))\n)\n", "  (= n (* n (expt x n))))\n", "  (cond [(=\
    \ (* x n) x) (true)]\n        [(= (* x n) 1)\n         (is_simple_power x (- n\
    \ 1))]\n        [else false]))\n", "  (= (* x (* n n)) x))\n", "  (cond [(= n\
    \ 1) true]\n        [(= x 0) false]\n        [(= (mod x n) 0) false]\n       \
    \ [else (is_simple_power x (sub1 n))]\n  )\n)\n", "  (cond [(= n 0) true]\n  \
    \      [else (= (mod x n) (mod n n))]))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
