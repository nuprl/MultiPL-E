name: HumanEval_15_string_sequence
language: rkt
prompt: "#lang racket\n\n;; Return a string containing space-delimited numbers starting\
  \ from 0 upto n inclusive.\n;; >>> (string_sequence 0)\n;; \"0\"\n;; >>> (string_sequence\
  \ 5)\n;; \"0 1 2 3 4 5\"\n(define (string_sequence n)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate string_sequence))\n\
  \    (check-equal? (candidate 0) \"0\")\n    (check-equal? (candidate 3) \"0 1 2\
  \ 3\")\n    (check-equal? (candidate 10) \"0 1 2 3 4 5 6 7 8 9 10\")\n))\n\n(test-humaneval)"
completions: ["  (cond [(zero? n) \"0\"]\n        [(equal? n 1) \"1\"]\n        [(odd?\
    \ n) (string_sequence (sub1 n)) (append (string_sequence (sub1 n)) (list n))]\n\
    \        [else (append (string_sequence (sub1 n)) (list n) (string_sequence (sub1\
    \ n)))]))\n", "  (if (= n 0)\n      (list \"0\")\n      (map (lambda (x)\n   \
    \          (string-append (list x) (string_sequence (sub1 n)))) \n           (range\
    \ (sub1 n))))))\n", "  (cond ((> n 0)\n         (string-append\n          (string_sequence\
    \ (sub1 n))\n          (list n)))\n        ((= n 0)\n         '(0))\n        (else\n\
    \         (string-append (string_sequence (sub1 n)) (list n)))))\n", "  (let loop\
    \ ((i 0))\n    (if (= i n)\n        (cons i \"\")\n        (loop (+ i 1)))))\n",
  "  (let loop ((x 0) (acc '()))\n    (if (zero? n)\n        acc\n        (loop (sub1\
    \ x) (cons x acc)))))\n", "  (string-append\n   (string-append \"0\" (string-sequence\
    \ (sub1 n)))\n   (string-append \" \" (string_sequence (sub1 n))))\n  )\n", " \
    \ (cond\n    ((< n 0)\n     '())\n    ((zero? n)\n     '())\n    ((odd? n)\n \
    \    (string-append '(\"0\" (string_sequence (sub1 n)))\n                   (string_sequence\
    \ (sub1 n)))\n     (string_append (string_sequence (sub1 n))\n               \
    \   (string_sequence (sub1 n))))))\n", "  (if (< n 0)\n      (list n)\n      (map\
    \ string->number\n           (subseq (string->list str) 0 n))))\n", "  (if (zero?\
    \ n)\n      '(\"\")\n      (append (string_sequence (sub1 n)) (list n))))\n",
  "  (string-append (for-each (\u03BB (i) (format \"~a \" i))\n                  \
    \    (range 0 n))\n                  \"\\n\")\n)\n", "  (define (next i)\n   \
    \ (if (<= i n)\n        (string-append \" \" (string i))\n        '()))\n  (define\
    \ (next i)\n    (if (<= i n)\n        (string-append \" \" (string i))\n     \
    \   '()))\n  (define (next i)\n    (if (<= i n)\n        (string-append \" \"\
    \ (string i))\n        '()))\n  (define (next i)\n    (if (<= i n)\n        (string-append\
    \ \" \" (string i))\n        '()))\n  (define (next i)\n    (if (<= i n)\n   \
    \     (string-append \" \" (string i))\n        '()))\n  (define (next i)\n  \
    \  (if (<= i n)\n        (string-append \" \" (string i))\n        '()))\n  (define\
    \ (next i)\n    (if (<= i n)\n        (string-append \" \" (string i))\n     \
    \   '()))\n  (define (next i)\n    (if (<= i n)\n        (string-append \" \"\
    \ (string i))\n        '()))\n  (define (next i)\n    (if (<= i n)\n        (string-append\
    \ \" \" (string i))\n        '()))\n  (define (next i)\n    (if (<= i n)\n   \
    \     (string-append \" \" (string i))\n        '()))\n  (define (next i)\n  \
    \  (if (<= i n)\n        (string-append \" \" (string i))\n        '()))\n  (define\
    \ (next i)\n    (if (<= i n)\n        (string-append \" \" (string i))\n     \
    \   '()))\n  (define (next i)\n    (if (<= i n)\n        (string-append \" \"\
    \ (string i))\n        '()))\n  (define (next i)\n    (if (<= i n)\n        (string-append\
    \ \" \" (string i))\n        '()))\n  (define (next i)\n    (if (<= i n)\n   \
    \     (string-append \" \" (string i))\n        '()))\n  (define (next i)\n  \
    \  (if (<= i n)\n        (string-append \" \" (string i))\n        '()))\n  (define\
    \ (next i)\n    (if (<= i n)\n        (string-append \" \" (string i))\n     \
    \   '()))\n  (define (next i)\n    (if (<= i n)\n        (string-append \" \"\
    \ (string i))\n        '()))\n  (define (next i)\n    (if (<= i n)\n        (string-append\
    \ \" \" (string i))\n        '()))\n  (define (next i)\n    (if (<= i n)\n   \
    \     (string-append \" \" (string i))\n        '()))\n  (define (next i)\n  \
    \  (if (<= i n)\n        (string-append \" \" (string i))\n        '()))\n  (define\
    \ (next i)\n    (if (<= i n)\n        (string-append \" \" (string i))\n     \
    \   '()))\n  (define (next i)\n", "  (if (<= n 0)\n      '()\n      (cons n (string_sequence\
    \ (sub1 n))))) \n", "  (if (= n 0)\n      '(0)\n      (let ((s (string-append\
    \ (string_sequence (sub1 n)) \" \" (string->symbol (char->string n))))\n     \
    \       (t (string_sequence (sub1 n))))\n        (cond ((= n 1) s)\n         \
    \     ((char=? (char->string n) ?) s)\n              ((char=? (char->string n)\
    \ ?) s)\n              (t (cond ((< n 10) t) (string_sequence (sub1 n) s) (string_sequence\
    \ (sub1 n) (+ n 1))))))))\n", "  (let loop ((i 0))\n    (cond\n      [(zero? n)\
    \ (list '0)]\n      [(equal? n 0) (list '0)]\n      [(even? n) (loop (add1 i))]\n\
    \      [else (loop (add1 i) (add1 i))])))\n", "  (if (= n 0)\n      \"0\"\n  \
    \    (cons n (string_sequence (sub1 n))))) ; concatenation without space in between\n\
    \n", "  (if (= n 0)\n      \"0\"\n      (let ([s (build-string (- n 1) (lambda\
    \ (x) (+ x n))) (i 0)])\n        (string-append s (string-sequence (- n 1)))\n\
    \        (set! i (+ n 1))))))\n", "  (let loop ((acc '())\n             (i (string-length\
    \ str)))\n    (if (>= i 0)\n        (concat acc (string i))\n        (loop (cons\
    \ (string i) acc) i (substring str (+ i 1))))))\n", "  (let loop ((n n) (s \"\"\
    ))\n    (if (zero? n) s\n        (loop (sub1 n) (+ s \" \")))))\n", "  (if (=\
    \ n 0) \"\"\n      (append (string_sequence (sub1 n)) (list \"-\" (string->number\
    \ n))))))\n", "  (define (helper result index)\n    (cond ((= index n) (append\
    \ result (number->string index)))\n          (else (helper (append result (number->string\
    \ (+ index 1))) index))))\n  (helper '() 0))\n", "  (if (< n 0)\n      '()\n \
    \     (append (cons (string n) (string_sequence (- n 1))) (string_sequence n))\n\
    \    )\n)\n", "  (cond\n    ((= n 0)\n     \"0\")\n    ((>= n 1)\n     (string-append\
    \ (string_sequence (sub1 n)) (number->string n)))\n    (else\n     (string-append\
    \ (string_sequence (sub1 n)) (number->string (sub1 n))\n                   (number->string\
    \ (sub1 n))))))\n", "  (if (= n 0)\n      '0\n      (append (string_sequence (sub1\
    \ n))\n              (list n)\n              (string_sequence (sub1 n))))) ;;\
    \ #lang racket\n", "  (if (zero? n)\n      '()\n      (append (string_sequence\
    \ (sub1 n)) (list n)\n              (string_sequence (sub1 n)))))\n", "  (if (<\
    \ n 0)\n      '()\n      (append (string_sequence (- n 1))\n              (list\
    \ n)\n              (string_sequence n))))\n</cell>\n<code language=racket-language>\n\
    #lang racket\n", "  (let loop ((i 0))\n    (if (= i n)\n        '()\n        (cons\
    \ (number->string i) (loop (+ i 1))))))\n", "  (define (helper i acc)\n    (cond\n\
    \      [(= i n) acc]\n      [(< i n) (helper i (cons i acc))]\n      [else (helper\
    \ i (cons (car acc) acc))]\n    )\n  )\n  (helper 0 '())\n)\n", "  (if (zero?\
    \ n)\n      \"0\"\n      (string-append (string_sequence (sub1 n)) \" \" (string-to-int\
    \ (sub1 n))))\n  )\n", "  (let ([s (string->list n)]\n        [l (length (subseq\
    \ s 0 1))])\n    (if (= l 0)\n        '0\n        (append (map string->string\
    \ s)\n                (cond [(= (length s) 0) \"0\"]\n                      [(=\
    \ l 1) (subseq s (1) 0)]\n                      [else (subseq s (1) (add1 l))])))))\n",
  "  (if (< n 0)\n      '()\n      (append (map (lambda (x) (string->number x)) (range->list\
    \ 0 n +)))))\n", "  (let loop ((result '()) (i 0))\n    (if (< i n)\n        (cons\
    \ i result)\n        result))))\n", "  (let loop ((i 0)\n             (s \"\"\
    )\n             (acc \"\"))\n    (if (>= i n)\n        (reverse acc)\n       \
    \ (loop (add1 i)\n              (append s \" \" (string->number i))\n        \
    \      (cons (string->number i) (cons \" \" acc)))))\n", "  (if (< n 0) \"\"\n\
    \      (string-append\n       (string-append \"0\" (regexp-replace-all \"[1-\"\
    \ \" 0 \" (string_sequence (sub1 n)))))\n       (string-append\n         ;; We\
    \ use the last digit as the starting digit for our new string\n         (string-append\
    \ (string_sequence (sub1 n)) \" \"))))\n", "  (cond [(= n 0) \"\"]\n        [(>=\
    \ n 1) (cons (number->string n) \" \")]\n        [else (cons (number->string n)\
    \ (string_sequence (sub1 n)))]))\n", "  (cond [(< n 0)\n         \"\"]\n     \
    \   [(equal? n (string-length \"\"))\n         \"\"]\n        [else\n        \
    \ (string-append (string_sequence (sub1 n))\n                        (list \"\
    \ \" (string->symbol (char->integer n)))]))\n</code>\n<|/ a dscore=2 tags=racket,string,scheme\
    \ |>\n<| c |>\nYes. This is exactly the code I used to solve the problem.\n<|/\
    \ c |>\n<| a dscore=2 |>\nUsing an anonymous function and some list functions\
    \ :\n<code>", "  (if (zero? n)\n      \"0\"\n      (append (string_sequence (sub1\
    \ n))\n              (list n)\n              (string_sequence (sub1 n))))) ;;\
    \ #lang racket\n", "  (if (< n 0)\n      '()\n      (cons (string->symbol (modulo\
    \ (+ n 1) (expt 10 n))) \n            (string_sequence (- n 1)))))\n", "  (let\
    \ loop ((i 0))\n    (if (< i n)\n        (string i)\n        (loop (+ i 1)))))\n",
  "  (if (zero? n)\n      '()\n      (cons (string-append (string_sequence (sub1 n))\n\
    \                          (number->string n))\n            (string_sequence (sub1\
    \ n))))) \n", "  (cond\n    [(= n 0) \"\"]\n    [else (cons (string->char (- n\
    \ (length nums)))\n                (string_sequence n))]))\n", "  (let loop ((n\
    \ n) (s \"\"))\n    (cond\n      [(= n 0) (return s)]\n      [(even? (modulo n\
    \ 2)) (loop (sub1 n) (append s '0))]\n      [else (loop (sub1 n) (append s (string-char\
    \ (modulo n 10) 10)))]))) ; note that the resulting string will have a trailing\
    \ newline\n", "  (if (= n 0) \"0\" \n      (append (string_sequence (- n 1))\n\
    \              (concat \" \" (number->string n)))))\n", "  (if (= n 0)\n     \
    \ '0\n      (concat \"0 \"\n              (string_sequence (sub1 n))))) ;; ++\
    \ \"0\"\n</cell>\n<text>\nExercise: Write a function that takes a number as input,\
    \ and returns the number in reverse order as a string.\n\nExercise: Write a function\
    \ that takes a number as input, and returns the string 'true' if its argument\
    \ is between 1 and 2, and 'false' if its argument is greater than 2.\n\nExercise:\
    \ Write a function that takes a number as input, and returns the string 'true'\
    \ if its argument is greater than 2, and 'false' if its argument is less than\
    \ 2.\n\n\n</text>\n<code language=lambda-exercise>", "  (let loop ((i 0))\n  \
    \  (if (= i n)\n        '()\n        (cons (string (modulo i 10) (modulo (+ i\
    \ 1) 10))\n              (loop (+ i 1))))\n    )\n  )\n", "  (let loop ()\n  \
    \  (if (< n 0)\n        '()\n        (cons n (loop)))))\n", "  (if (= n 0)\n \
    \     '()\n      (append (string_sequence (sub1 n)) (list n))))\n", "  (if (=\
    \ n 0)\n      '0\n      (cons (string-ref (substring n 1) (- n 1))\n         \
    \   (string_sequence (- n 1)))))\n", "  (let ([s (make-string)]\n        [l (length\
    \ s)])\n    (set-char! s (substring s 0 n))\n    (set-char! s (substring s n n)))\n\
    \  s)\n</code>\nI tested this with DrRacket and got the following:\n<code>\n#lang\
    \ racket", "  (let ([i 0])\n    (for-each [_ n]\n      (if (< i n)\n         \
    \ (displayln i)\n          (println i))\n      (set! i (+ i 1)))))\n", "  (cond\n\
    \    [(zero? n) \"\"]\n    [(one? n) (string n)]\n    [else (cons (string-sequence\
    \ (sub1 n)) (string_sequence (sub1 n))) ]))\n", "  (let loop ((i 0)\n        \
    \     (result \"\")\n             (remaining n))\n    (if (> remaining 0)\n  \
    \      (loop (+ i 1) (concat result (string->number i))\n              (remaining\
    \ (remaining - 1)))\n        result)))\n", "  (map (\u03BB (n) (printf \"~d\"\
    \ n))\n       (range n)))\n", "  (if (= n 0)\n      \"0\"\n      (cond [(zero?\
    \ n) (list \"0\")]\n            [(< n 10) (string-append (string_sequence (quotient\
    \ n 10)) \" \" (number n))]))) ;) ;\n", "  (let loop ((n n))\n    (if (zero? n)\n\
    \        \"0\"\n        (string-append (loop (sub1 n)) \" \"))))\n", "  (if (=\
    \ n 0)\n      \"0\"\n      (concat (string_sequence (sub1 n)) \" \" (string->string\
    \ n))))\n", "  (let loop ((i 0) (s \"\") (n n))\n    (if (<= i n)\n        (loop\
    \ (+ i 1) (append s (number->string i)) n)\n        s)))\n", "  (let ([s (string->list\
    \ \"\")]\n        [i (string-length s)])\n    (if (zero? n)\n        (string->list\
    \ \"0\")\n        (append (make-substring s 0 (string->integer i)) (string_sequence\
    \ (sub1 n))))))\n", "  (let loop ((n n) (s ''))\n    (if (zero? n)\n        s\n\
    \        (loop (- n 1) (append s (list n))))))\n", "  (let loop ((n n)\n     \
    \        (str \"\"))\n    (if (zero? n)\n        str\n        (loop (sub1 n) (conj\
    \ str n))))))\n", "  (let loop ([i 0])\n    (if (= i n)\n        (string-append\
    \ \" \" (number->string i))\n        (loop (+ i 1)))))\n", "  (cond\n    [(= n\
    \ 0)\n     (string \"0\")]\n    [(even? (- n 1))\n     (append (string_sequence\
    \ (- n 1))\n             (string-sequence n))]\n    [else\n     (append (string_sequence\
    \ (- n 1))\n             (string-sequence (- n 1))\n             #\\Space (string\
    \ \" \"))]))\n", "  (let ([result \"\"]) (for-each string->list '(0 1 2 3 4 5)\n\
    \                                 [(x) (incf result (string-append \" \" (number->string\
    \ x))))]\n    (string->list result)))\n", "  (let ([str (make-string n #\\space)])\n\
    \    (for-each add-char (string->list str) (in-range str))))\n", "  (cond ((>\
    \ n 0) (make-string (string-length n) (append '() (string-repeat \" \" n)))\n\
    \        ((= n 0) \"0\"))\n        ((string? (car n)) (cons (car n) (string_sequence\
    \ (cdr n)))\n          (string_sequence (car n) (string_sequence (cdr n)))))\n",
  "  (if (zero? n) \"\"\n      (append (string_sequence (sub1 n)) (list n))))\n",
  "  (for-each (lambda (x) (display x))\n            (range\n              (expt -1\
    \ n)\n              (expt 1 n)))\n  (newline)\n  (display \"done\")\n  (newline)\n\
    \  \"\")\n", "  (let loop ((n n) (str \"\"))\n    (if (> n 0)\n        (loop (sub1\
    \ n) (concat str (string->list n)))\n        str)))\n", "  (let ([s (list n)])\n\
    \    (if (zero? n)\n        (reverse s)\n        (string-sequence (incf n))\n\
    \      (recur (sub1 n)))))\n", "  (if (< n 0)\n      '()\n      (cons (string->symbol\
    \ (char->string n)) (string_sequence (- n 1)))))\n", "  (cond [(<= n 0)\n    \
    \     '\"\"]\n        [else\n         (string-append \" \" (string-sequence (-\
    \ n 1))\n                       (string->symbol (number->string n)))]))\n</cell>\n\
    <code language=racket-language>", "  (let loop ((n n)\n             (str \"\"\
    )\n             (i 0))\n    (if (< i n)\n        (if (= i n)\n            (format\
    \ str \"~a\" 0)\n            (format str \"~a \" i))\n        (begin\n       \
    \  (loop (- n 1)\n              (cons (- i 1) str)\n              (+ i 1)))))\n\
    \  (str))\n", "  (if (< n 0)\n      \"\"\n      (if (= n 1)\n          \"0\"\n\
    \          (append (string_sequence (sub1 n)) (list n)))\n      )\n  )\n", " \
    \ (if (zero? n)\n      '()\n      (append (make-string n #\\space) (string_sequence\
    \ (sub1 n)))))\n", "  (let loop ((s \"\")\n             (n n))\n    (cond [(=\
    \ n 0)\n           (append s \" 0\")]\n          [(> n 0)\n           (loop (append\
    \ s (string-from-int n) \" \" ) (rest n))]))\n  (reverse s))\n", "  (let loop\
    \ ((n n))\n    (if (zero? n)\n        '()\n        (append (number->string n)\n\
    \                (loop (sub1 n))))))\n", "  (for-each (lambda (x) (display x (newline)\n\
    \                          (cons (string->list x) \"\"))\n            (reverse\
    \ (range-from-end n))))\n</code>\n<|/ a dscore=1 |>\n<| c |>\nI actually tried\
    \ your solution and it doesn't work. My solution works on any language as far\
    \ as I can tell, though I can't really see why. I'm guessing it's because of your\
    \ use of append.\n<|/ c |>\n<| c |>\n: I see you posted a solution. Did you try\
    \ it? Does it work? Please post the exact code you tried in the question if it\
    \ doesn't work.\n<|/ c |>\n<| c |>\nI did. Your code worked fine. I didn't think\
    \ to try the other solutions so I didn't try them. I've since tried them again\
    \ and your solution does work. I don't really know what's going on in the other\
    \ solutions but I'll keep looking.\n<|/ c |>\n<| c |>\nYour other solutions seem\
    \ to be better at generating the strings of numbers and punctuation than the purely\
    \ functional solution. Honestly, I'm still pretty confused why my code isn't working.\
    \ The output looks good to me.\n<|/ c |>\n<| a tags=racket,scheme dscore=1 |>\n\
    I think you can do this with a simple for loop in racket. \n<code>", "  (cond\
    \ ((< n 1) \"\")\n        ((> n 0) (list n) (string_sequence (sub1 n)))\n    \
    \    (else (append (string_sequence (sub1 n)) (string_sequence (sub1 n)))))\n\
    )\n", "  (if (zero? n)\n      \"\"\n      (append (cons (string->number n) \"\
    \ \")\n              (string_sequence (sub1 n))))))\n", "  (cond [(<= n 0) \"\
    0\"]\n        [(empty? n) \"\"]\n        [(> (n) (length \"\"))\n         (string-append\
    \ (substring (string n) 0 -1)\n                        (string-sequence (- n 1)))]\n\
    \        [else\n         (string-append (substring (string n) 0 -1)\n        \
    \                (string-sequence (- n 1))\n                        (substring\
    \ (string n) (length n)))]))\n", "  (cond [(or (= n 0) (< n 0))\n         \"0\"\
    ]\n        [(or (= n 1) (< n 1))\n         \"0\"]\n        [(< n 2)\n        \
    \ (append (string_sequence (- n 1))\n                 (string->list (number->string\
    \ n)))]))\n", "  (if (< n 0)\n      '()\n      (append (string_sequence (- n 1))\n\
    \              (list n)\n              (string_sequence n))))\n", "  (if (< n\
    \ 0)\n      (error \"Argument must be positive, was ~D\" n)\n      (let loop ((seq\
    \ nil)\n                 (i 0))\n        (if (< i n)\n            (append (list\
    \ seq)\n                    (string-seq i\n                                 (+\
    \ i 1))\n                    (loop (string-seq seq i)\n                      \
    \    (+ i 1))))\n        seq)))\n", "  (if (= n 0)\n      \"0\"\n      (append\
    \ (string_sequence (sub1 n)) (list n))))\n", "  (let loop ((i n))\n    (cond ((=\
    \ i 0) \"\")\n          ((< i n) (string-cat i (string-sequence (- i 1))))\n \
    \         (else (loop (- i 1))))))\n", "  (for/list ([i (in-range n)]) (string\
    \ i)))\n", "  (let loop ([i '0])\n    (if (< n 0)\n        '()\n        (cond\
    \ ((= n i)\n              (cons (string->number i) '()))\n              ((even?\
    \ n)\n               (loop (+ i 2)))\n              (else\n               (loop\
    \ (+ i 2))))))\n", "  (cond [(zero? n) \"\"]\n        [(positive? n) (append (string_sequence\
    \ (sub1 n)) \" \" (string-sequence (sub1 n)))]\n        [else (append (string_sequence\
    \ (sub1 n)) \" \" (string-sequence (sub1 n)))]))\n", "  (let loop ((i 0))\n  \
    \  (cond ((zero? i) \"\")\n          ((= i n) \"\")\n          (else\n       \
    \    (string-append\n            (lambda (j) (number->string (+ (* n j) i)))\n\
    \            (loop (+ i 1))))))))\n", "  (let loop ((i n) (s \"\"))\n    (if (zero?\
    \ i)\n        (reverse s)\n        (loop (add1 i)\n               (string-append\
    \ s \" \" (number->string i))))))\n", "  (if (< n 0)\n      '()\n      (append\
    \ (string_sequence (- n 1))\n              (list n))))\n", "  (string-join (list\
    \ n) (list->string numbers)))\n</code>\n<|/ a tags=racket,scheme dscore=0 |>\n\
    <| c |>\nThanks for your suggestion. I need to do it in plain Scheme.\n<|/ c |>\n\
    <| c |>\nIn Racket, there is a `#lang racket` directive that you can use at the\
    \ beginning of some file. This means you can do things like define macros in Racket.\
    \ I think it would be helpful to you if you explain what you are trying to do\
    \ and what you expect the code to do.\n<|/ c |>\n<| c |>\nThanks for your suggestion!\
    \ I am doing a code challenge on codewars, and I need to use Scheme to write the\
    \ code. I hope this is clear enough.\n<|/ c |>\n<| c |>\nIt may help if you tell\
    \ me what language you are writing it in. There are many languages that use Scheme.\
    \ The Scheme language itself is very different from the many other languages we\
    \ use.\n<|/ c |>\n<| c |>\nSorry I should have specified it. This is for CodeWars.com.\
    \ Thanks again for your help!\n<|/ c |>\n<| a tags=racket,scheme |>\nOkay, so\
    \ here's a solution for Racket in plain Scheme (no #lang racket):\n<code>\n#lang\
    \ racket\n", "  (let* ((s (make-string-builder))\n         (i (loop for i from\
    \ 0 to (- n 1) collect i)))\n    (for-each [s i] (lambda (x) (append-string s\
    \ \" \" x))) (get-output-stream-string)))\n", "  (if (zero? n) '()\n      (append\
    \ (map (lambda (x) (number->string x)) (range (expt 2 n)))\n              ')))\n",
  "  (let ([x (make-array (list n))])\n    (dotimes (i n)\n      (set! x (array i\n\
    \                      (lambda (x) (+ x i))\n                      (lambda (x)\
    \ x)\n                      x))\n      (set! x (array i\n                    \
    \  (lambda (x) (+ x 1))\n                      (lambda (x) x)\n              \
    \        x))\n      (set! x (array i\n                      (lambda (x) (+ x 1))\n\
    \                      (lambda (x) x)\n                      x))\n      (set!\
    \ x (array i\n                      (lambda (x) (+ x 1))\n                   \
    \   (lambda (x) x)\n                      x))\n      (set! x (array i\n      \
    \                (lambda (x) (+ x 1))\n                      (lambda (x) x)\n\
    \                      x))\n      (set! x (array i\n                      (lambda\
    \ (x) (+ x 1))\n                      (lambda (x) x)\n                      x))\n\
    \      (set! x (array i\n                      (lambda (x) (+ x 1))\n        \
    \              (lambda (x) x)\n                      x))\n      (set! x (array\
    \ i\n                      (lambda (x) (+ x 1))\n                      (lambda\
    \ (x) x)\n                      x))\n      (set! x (array i\n                \
    \      (lambda (x) (+ x 1))\n                      (lambda (x) x)\n          \
    \            x))\n      (set! x (array i\n                      (lambda (x) (+\
    \ x 1))\n                      (lambda (x) x)\n                      x))\n   \
    \   (set! x (array i\n                      (lambda (x) (+ x 1))\n           \
    \           (lambda (x) x)\n                      x))\n      (set! x (array i\n\
    \                      (lambda (x) (+ x 1))\n                      (lambda (x)\
    \ x)\n                      x))\n      (set! x (array i\n                    \
    \  (lambda (x) (+ x 1))\n                      (lambda (x) x)\n              \
    \        x))\n      (set! x (array i\n                      (lambda (x) (+ x 1))\n\
    \                      (lambda (x) x)\n                      x))\n      (set!\
    \ x (array i\n                      (lambda (x) (+ x 1))\n                   \
    \   (lambda (x) x)\n                      x))\n      (set! x (array i\n      \
    \                (lambda (x) (+ x 1))\n                      (lambda (x) x)\n\
    \                      x))\n      (set! x (array i\n                      (lambda\
    \ (x) (+ x 1))\n                      (lambda (x) x)\n                      x))\n\
    \      (set! x (array i\n                      (lambda (x) (+ x 1))\n        \
    \              (lambda (x) x)\n                      x))\n      (set! x (array\
    \ i\n                      (lambda (x) (+ x 1))\n                      (lambda\
    \ (x) x)\n                      x))", "  (define (iter result)\n    (if (= n 0)\n\
    \        result\n        (iter (append result (number->string (n-1))) (number->string\
    \ n))))\n  (iter '()))\n", "  (if (= n 0)\n      '()\n      (append (cons n (string_sequence\
    \ (- n 1)))\n              (string_sequence (- n 1)))))\n", "  (map (lambda (x)\
    \ (list 'quote x)) (range n)))\n", "  (let loop ((n n) (s \"\"))\n    (if (zero?\
    \ n)\n        s;\n        (loop (sub1 n) \n              (string+ s \" \" n))))\n\
    </code>\n<|/ a dscore=2 tags=racket,scheme |>\n<| a dscore=1 |>\nA simple solution\
    \ without recursion:\n<code>", "  (map (lambda (x)\n         (number->string x))\n\
    \       (range n)))\n", "  (map (lambda (x)\n         (string-append (number->string\
    \ x) \" \"))\n       (range-from 0 n)))\n", "  (map string-append (range (+ 0\
    \ (- n 1))) (repeat (- n 1))))\n", "  (let loop ((i 0))\n    (cond ((= i n) (cons\
    \ i '()))\n          ((< i n) (loop (+ i 1))))\n    (values))\n  )\n", "  (list\
    \ 'string \"\"))\n", "  (let loop ((i 0))\n    (if (= i n)\n        (string-append\
    \ \"(\" (reverse (number->string i)) \")\")\n        (loop (+ i 1)))))\n", " \
    \ (let loop ((i 0))\n    (if (= i n)\n        (substring \"0 1 2 3 4 5\" 0)\n\
    \        (substring (string-append \"0 1 2 3 4 5\" (number->string i))\n     \
    \             (number->string i)))))\n", "  (let loop ((i 0)\n             (s\
    \ \"\")\n             (rest n))\n    (if (<= i rest)\n        (loop (+ i 1)\n\
    \              (append s (list (modulo (+ i 1) rest)))\n              rest)\n\
    \        (append s i)))))\n", "  (let loop ((i 0))\n    (if (< i n)\n        (let\
    \ ((str (string->list i)))\n          (cond\n            ((null? str) (list i))\n\
    \            (else\n             (cons (string-append str \"-\" (string->list\
    \ i)) \n               (loop (+ i 1)))))))\n  '(()))\n", "  (if (<= n 0)\n   \
    \   \"0\"\n      (string-append (string_sequence (- n 1))\n                  \
    \   (list n))))\n", "  (let loop ((n n) (acc '()))\n    (if (zero? n)\n      \
    \  (reverse acc)\n        (loop (sub1 n) (cons (modulo n 10) acc)))))\n", "  (if\
    \ (= n 0) \"\"\n      (append (string_sequence (sub1 n))\n              (list\
    \ n))))\n", "  (let loop ((n n) (acc '())\n             (curr '()))\n    (if (<\
    \ n 0)\n        acc\n        (loop (- n 1) \n              (cons (car acc) curr)\
    \ \n              (loop (car acc) (append (cdr acc) (list curr))\n           \
    \         (cons (car acc) curr))))))\n", "  (map (lambda (x) (printf \"~d\" x))\
    \ (range n)))\n", "  (if (zero? n)\n      '0\n      (cons (string-append\n   \
    \          (string-append (number->string (number->decimal (- n 1))) \" \")\n\
    \             (string-sequence (sub1 n)))))\n</code>\n<|/ a tags=scheme,racket\
    \ dscore=1 |>\n<| a dscore=1 |>\n<code>", "  (loop for i from 0 to n\n       collect\
    \ (string i)))\n", "  (if (= n 0)\n      '\"\"\n      (string (n) (string-sequence\
    \ (- n 1)))))\n", "  (if (< n 0)\n      \"\"\n      (append (string_sequence (-\
    \ n 1)) (list n))))\n", "  (let ([nums (make-list n)])\n    (set! nums (concat\
    \ nums\n                  (map (lambda (i) (list i))\n                      (range\
    \ n))))\n    (string-join nums)))\n", "  (map (lambda (n) (format \"~a \" n))\
    \ (range n)))\n", "  (let loop ((n n) (s \"\"))\n    (cond\n      [(= n 0) (append\
    \ s \"0\")]\n      [(< n 10) (string-sequence (- n 1) (append s (string->char\
    \ (string->number (string->symbol s)) \" \"))]\n      [else (loop (- n 1) (append\
    \ s (string->char (string->number (string->symbol s)) \" \")))]))\n</code>\n<|/\
    \ a tags=racket dscore=1 |>\n<| c |>\nI upvoted this because it is a different\
    \ approach to converting from int to char. I don't know if that's a requirement\
    \ though, since I do think the OP was just looking for a way to convert from int\
    \ to char. Perhaps I misunderstand your answer. :)\n<|/ c |>\n<| c |>\nYes, your\
    \ answer is correct. I was just trying to show the difference between `number->string`\
    \ and `string->number`.\n<|/ c |>\n<| a tags=racket dscore=1 |>\nIn addition to\
    \ the answer of Mike Seymour, I made a solution that works with negative numbers.\n\
    <code>", "  (let loop ((n n)\n             (result '())\n             (acc '()))\n\
    \    (cond\n      [(zero? n) (reverse acc)]\n      [else (loop (sub1 n) (cons\
    \ (sub1 n) result) (cons (sub1 n) acc))]))\n</code>\n<|/ a dscore=0 |>\n<| c |>\n\
    This doesn't answer the question asked but does provide an alternative solution\
    \ that is arguably more elegant than my solution.\n<|/ c |>\n<| a tags=racket,scheme\
    \ |>\nI'm a beginner in racket, so I thought to share my solution\n<code>", " \
    \ (define i (string-length \" \" n))\n  (let loop ((i i) (s \"\")\n          \
    \   (s1 s))\n    (if (< i n)\n        s1\n        (loop (+ i 1) (append (substring\
    \ s 0 i) \" \") s1)))\n  s\n)\n", "  (let loop ((s \"\")\n             (n n))\n\
    \    (if (< n 0)\n        s \"0\"\n        (loop (cons n (string-append s \" \"\
    \ n))\n              (- n 1)))))\n", "  (let loop ((n n) (s \"\"))\n    (if (<\
    \ n 0)\n        (reverse s)\n        (loop (sub1 n) (concat s \" \" (number->string\
    \ n))))))\n", "  (if (or (= n 1) (= n 2))\n      '(\"\")\n      (append (string_sequence\
    \ (sub1 n)) (list n))))\n", "  (let ([s (string-append \"0 \" (string-sequence-helper\
    \ n (lambda (x) (+ x 1)))))])\n    (string-trim s)))\n</code>\n<|/ a |>\n<| a\
    \ tags=racket,scheme |>\n<code>", "  (cond [(zero? n) \"\"]\n        [else (append\
    \ (string_sequence (sub1 n)) (list \"-\" (- (length n) 1))))]\n        ))\n",
  "  (define (iter n str)\n    (cond\n      [(zero? n) str]\n      [else (iter (sub1\
    \ n) (append str #\\space))]))\n  (iter n '\"\"))\n", "  (if (> n 0)\n      (map\
    \ (\u03BB (i)\n             (format #f \"~a \" i))\n            (range n (+ n\
    \ 1)))\n      '()))\n", "  (let loop ((n n) (s \"\"))\n    (if (= n 0)\n     \
    \   (reverse s)\n        (loop (- n 1)\n              (cons n (string-append s\
    \ \" \"))))))\n", "  (let loop ((res \"\") (i n))\n    (if (< i 0)\n        res\n\
    \        (loop (cons (string->string i) res) (sub1 i)))))\n", "  (if (< n 0)\n\
    \      '()\n      (cons (number->string (n-ref n))\n            (string-sequence\
    \ (- n 1)))))\n", "  (if (zero? n) '()\n      (cons (string->symbol (string->number\
    \ n)) (string_sequence (sub1 n))))))\n", "  (if (<= n 0)\n      '()\n      (append\
    \ (string_sequence (sub1 n))\n              (list (number->string (modulo n 10))))))\n",
  "  (cond\n    [(= n 0) \"\"]\n    [else (list n (string-sequence (sub1 n)))]))\n",
  "  (let* ((seq (make-array (list* n #\\space)))\n         (i (0))\n         (j (sub1\
    \ (array-length seq))))\n    (dotimes (i n)\n      (set! seq (make-array (list*\
    \ (* (+ i j) j) #\\space)))\n      (set! i (+ i 1))\n      (set! j (sub1 (array-length\
    \ seq))))\n    (array-join seq #\\space)\n    ))\n", "  (for-each (lambda (x)\n\
    \               (writeln x)\n               (string-append (number->string x)\
    \ \" \"))\n            (range 0 n)))\n", "  (let ([s \"\"])\n    (cond [(= n 0)\n\
    \           (append s \"0\")]\n          [(< n 10)\n           (append s (number->string\
    \ n))\n           (string-sequence (- n 10))]\n          [else\n           (append\
    \ s (number->string (quotient n 10)))\n           (string-sequence (quotient n\
    \ 10))]\n          )))\n", "  (for/fold ([accu \"\"]\n             [acc \"\"])\n\
    \            ([x 0])\n            [(< x n) \n             (string-append \n  \
    \            (list \n                (string-ref (cons x accu) 0) \n         \
    \       \" \"))\n             (inc x)])\n    (reverse (list accu))))\n</cell>\n\
    <cell>\n#lang racket\n", "  (let ([s (string->symbol (symbol->string n))]\n  \
    \      [i (make-array\n               (+ 1 (length (symbol->array s)))\n     \
    \          #:initial-contents '())])\n    (dotimes (i n)\n      (set! i (vector-push!\
    \ i s)))))\n", "  (cond\n    [(zero? n) \"\"]\n    [(= n 1) \"0\"]\n    [else\
    \ (cons ((sub1 (string-sequence (sub1 n))) \"\n                   \"(string_sequence\
    \ (sub1 n)))]))", "  (list \"0\"\n        (lambda (n) (+ (string-sequence (n-1))\n\
    \                        (list (string-digit-char (string-ref (list-ref (number->string\
    \ n)\n                                                          (- n (string-length\
    \ n)))))))))\n", "  (if (< n 0)\n      '()\n      (append (string_sequence (-\
    \ n 1))\n              (string n)\n              (string_sequence (- n 1)))))\n",
  "  (cond\n    ((= n 0) \"0\")\n    ((= n 1) \"1\")\n    (else (append (string_sequence\
    \ (sub1 n)) (list n))))))\n", "  (if (<= n 0)\n      '()\n      (cons (number->string\
    \ n) (string_sequence (sub1 n))))))\n", "  (lambda () \n    (display n) (newline)\n\
    \    (string->list \n      (for ([i n]\n           #:when (> i n))\n        (set!\
    \ i (+ i 1))\n        (display i))\n      (display \")\")\n      (newline)))\n",
  "  (if (= n 0)\n      \"0\"\n      (string-sequence (sub1 n) (cond ((zero? (modulo\
    \ n 10)) (cons (modulo n 10) (cons \" \" (string_sequence (sub1 n))))\n      \
    \                                           (else (cons n \"-\" (string_sequence\
    \ (sub1 n))))))))\n", "  (let loop ((i 0) (res '()))\n    (if (> i n)\n      \
    \  (append res '())\n        (loop (+ i 1) (cons (+ i 1) res))))))\n", "  (if\
    \ (<= n 0)\n      '()\n      (append (string_sequence (- n 1))\n             \
    \ (list (string n))))) ;; <<< note (list ...)\n</code>\n<|/ a tags=racket,scheme\
    \ |>\n<| a dscore=1 |>\n<code>\n#lang racket\n", "  (build-string n #\\space))\n",
  "  (let loop ((i 0) str '())\n    (if (< i n)\n        (begin (set! str (string-append\
    \ (str (string->list (string->char (char->string i)))) \" \")) (loop (add1 i)\
    \ (cons str \"\"))\n        str)))", "  (if (< n 0)\n      (error \"string_sequence:\
    \ n must be positive\")\n      (cond [(= n 0)\n             \"0\"]\n         \
    \   [else\n             (string-append\n              (string_sequence (sub1 n))\n\
    \              (if (= n 1)\n                  \"\"\n                  \" \"\n\
    \                  (string n))))]))\n", "  (if (>= n 0)\n      (list n (+ n 1))\n\
    \      (string_sequence (- n 1))))\n", "  (map string->string\n       (iterate\
    \ (lambda (x) (+ x 1))\n                 0\n                 n)))\n", "  (if (<\
    \ n 0)\n      '()\n      (cons (number->string n) (string-sequence (sub1 n)))))\n",
  "  (let loop ((n n) (str \"\") (i 0))\n    (if (< n 0)\n        str\n        (loop\
    \ (- n 1) (append str #\\space (number->string i)) (+ i 1)))))\n", "  (if (= n\
    \ 0)\n      \"0\"\n      (list n (string-sequence (- n 1)))))\n", "  (let loop\
    \ ([n n] [str \"\"] [i 0])\n    (if (< i n)\n        (let ([str (string->symbol\
    \ (str \"~a \" i))])\n          (loop (sub1 n) str i))\n        str)))\n", " \
    \ (if (= n 0)\n      \"0\"\n      (append (string_sequence (sub1 n)) (number->string\
    \ n))))\n", "  (let loop ((n n) (acc '()))\n    (if (zero? n)\n        (append\
    \ acc (number->string n))\n        (loop (sub1 n) (concat acc (number->string\
    \ n)))))) \n", "  (if (= n 1)\n      \"\"\n      (cons (string->number n) \n \
    \           (string-sequence (sub1 n))))))\n", "  (if (<= n 0) \"\"\n      (apply\
    \ str (append (apply str (make-string-builder n #\\Space)) (number-sequence n\
    \ 0)))))\n", "  (cond [(< n 0)\n         '\"\"]\n        [else\n         (string-append\
    \ (string_sequence (sub1 n)) (list n))]\n        ))\n", "  (let-values ([(next\
    \ (lambda () (+ 1 (string-length (string-ref (format #f \"~a\" n)) (format #f\
    \ \" \")))))\n              (seq (make-string-sequence-object (cond ((< n 0) (make-string\
    \ n #\\space))\n                                                      ((< n 10)\
    \ (string-seq 0 n (string-ref seq (next))\n                                  \
    \                             (string-length (string-ref seq (next))))\n     \
    \                                                 ((< n 100) (string-seq 0 n (string-ref\
    \ seq (next))\n                                                              \
    \ (string-length (string-ref seq (next))))\n                                 \
    \                     ((< n 1000) (string-seq 0 n (string-ref seq (next))\n  \
    \                                                             (string-length (string-ref\
    \ seq (next))))\n                                                      ((< n 10000)\
    \ (string-seq 0 n (string-ref seq (next))\n                                  \
    \                             (string-length (string-ref seq (next))))\n     \
    \                                                 ((< n 100000) (string-seq 0\
    \ n (string-ref seq (next))\n                                                \
    \               (string-length (string-ref seq (next))))\n                   \
    \                                   (else (string-seq 0 n (string-ref seq (next)))))))])\n\
    \    (string-join seq \"\")))\n", "  (if (= n 0)\n      \"0\"\n      (append (string_sequence\
    \ (sub1 n)) (list n))))\n", "  (let loop ((i 0)\n             (list '()))\n  \
    \  (if (< i n)\n        (begin (set! list (cons (+ i 1) list))\n             \
    \  (loop (+ i 1) '()))\n        list)))\n</code>\n<code>", "  (if (>= n 0)\n \
    \     (string-append (number->string (floor (/ n 10)))\n                    (if\
    \ (= n 10) \"\" (string-append \" \" (number->string (modulo n 10))))\n      \
    \              (number->string (modulo n 10)))\n      '()))\n", "  (if (zero?\
    \ n)\n      \"0\"\n      (append (string_sequence (sub1 n)) (list n))))\n</textarea></form>\n\
    \n    <script>\n      var editor = CodeMirror.fromTextArea(document.getElementById(\"\
    code\"), {\n        lineNumbers: true,\n        matchBrackets: true,\n       \
    \ mode: \"text/x-scheme\"\n      });\n    </script>\n\n    <p><strong>MIME types\
    \ defined:</strong> <code>text/x-scheme</code>.</p>\n\n  </article>\n\n<|/ file\
    \ source=github ext=.html dstars=1 |>\n<| c |>\nThanks, this was a big help. One\
    \ minor thing though: my scheme interpreter gave a syntax error when I tried `(define\
    \ string-sequence string-sequence)` so I changed it to `(define string-sequence\
    \ string-sequence)` which works.\n<|/ c |>\n<| c |>\n: yes, I forgot to add parentheses\
    \ around the `define`, fixed now.\n<|/ c |>\n<| c |>\nI realize this question\
    \ was answered a while ago, however I came here searching for a way to do this\
    \ in Racket, which doesn't seem to have support for a \"define\" macro. Is there\
    \ any way you could show me how to do this?\n<|/ c |>\n<| c |>\n: yes, you use\
    \ `define-syntax`. See the section on *Using `define` in the Racket Reference*.\n\
    <|/ c |>\n<| a tags=scheme,racket |>\nI used Josh Berry's answer for how to define\
    \ this macro in Scheme and translated it into a Scheme macro implementation in\
    \ Racket using the following macro:\n<code>", "  (if (< n 0)\n      (error \"\
    string_sequence: n should be non-negative\")\n      (let ([x (list-ref (list->string\
    \ '(0 1 2 3 4 5 6 7 8 9)) n)])\n        (string-append \"0 \" (string->list x))))\n",
  "  (string-join \" \" (list \"0\" '(1 2 3 4 5)))\n)\n", "  (for/fold ([str \"\"\
    ] [i 0])\n            (c #\\space)\n            [str (append  str (string-ref\
    \ (substring str i) c))])\n  str)\n</code>\nThe above is for Lisp/Scheme. In Racket,\
    \ you would do:\n<code>", "  (if (< n 0)\n      '()\n      (append (map number->string\
    \ (range n))\n              (string_sequence (- n 1)))))\n</code>\n<|/ a tags=racket,scheme\
    \ dscore=1 |>\n<| c |>\nThanks. I've used your answer to answer my own question.\
    \ http://stackoverflow.com/questions/27405438/how-to-make-an-array-in-racket\n\
    <|/ c |>\n<| a |>\nHere's a slightly different version that doesn't use recursion\
    \ or append.\n<code>", "  (map (\u03BB (x) (string-append \" \" (string->number\
    \ x))) \n       (make-list n #\\space)))\n", "  (let loop ()\n    (cond\n    \
    \  [(< n 0) \"\"]\n      [(> n 0) (append (loop) (cons n (loop)))]\n      [else\
    \ (append (loop) (cons (- n 1) (loop)))]))\n  (loop))\n", "  (if (= n 0)\n   \
    \   '()\n      (append (string_sequence (sub1 n)) (concat \" \" (string_sequence\
    \ (sub1 n)))))\n  )\n", "  (if (zero? n)\n      '0\n      (append (string_sequence\
    \ (sub1 n)) (list n))))\n", "  (if (= n 0)\n      \"0\"\n      (cons (string-ref\
    \ \"0123456789\" n) (string_sequence (sub1 n))))) ;; #lang racket\n", "  (let\
    \ loop ((n n)\n             (acc '())\n             (digits (string->list \"\"\
    )))\n    (if (zero? n)\n        acc\n        (loop (sub1 n) (string-append (list-ref\
    \ digits 0) acc)\n              (list-remove digits 0)))))\n", "  (if (> n 0)\n\
    \      (apply string-append '(\"~s\" \"~s\" \"~s\" \"~s\" \"~s\" \"~s\" \"~s\"\
    \ \"~s\" \"~s\" \"~s\" \"~s\" \"~s\" \"~s\"))\n      (apply string-append '(\"\
    ~s\" \"~s\" \"~s\" \"~s\" \"~s\" \"~s\"))))\n", "  (let loop ((result \"\")\n\
    \             (i 0))\n    (if (< i n)\n        (let ((value (string-append result\
    \ (number->string i))))\n          (loop (string-append result \" \") (+ i 1))\n\
    \          value))\n    result))\n", "  (if (< n 0)\n      \"\"\n      (append\
    \ (list (string-append \"0 \" (string-append-int n (string->symbol (- n 1)))))\n\
    \              (string_sequence (- n 1)))))\n", "  (cond [(zero? n) \"\"]\n  \
    \      [(= n 1) (string n)]\n        [else\n         (string-append (string_sequence\
    \ (sub1 n)) (string \" \"))]))\n</cell>\n<code language=ocaml-jupyter>", "  (map\
    \ string->symbol @(range n)))\n", "  (if (= n 0)\n      '0\n      (append (string_sequence\
    \ (sub1 n)) (list n))))\n", "  (let loop ((i 0))\n    (cond\n      [(< i n) \"\
    \"]\n      [(string? (char-code (char i #\\Space #\\Space)))\n       (append (loop\
    \ (+ i 1))\n               (string->number \n                  (substring \n \
    \                  (char i #\\Space #\\Space)\n                   (- (string-length\
    \ \n                         (char i #\\Space #\\Space)))))]\n      [else\n  \
    \     (append (loop (+ i 1))\n               (string->number \n              \
    \    (substring \n                   (char i #\\Space #\\Space)\n            \
    \       (string-length (char i #\\Space #\\Space))))])))", "  (let ([result '()])\n\
    \    (if (= n 0)\n        result\n        (string-append result\n            \
    \          (string-append \" \" (string-seq 0 n))))))\n", "  (if (<= n 0)\n  \
    \    '()\n      (cons (string->symbol (string->number (format \"~d\" n)))\n  \
    \          (string_sequence (- n 1)))))\n", "  (list \"0\" (nth (inc (- n (length\
    \ list))) list)))\n</code>\n<|/ a tags=racket,string,list-comprehension,recursion,scheme\
    \ dscore=1 |>\n<| a tags=racket,string,list-comprehension,recursion,scheme |>\n\
    I find that using foldr makes code easier to read and understand. \n<code>", " \
    \ (let loop ()\n    (if (<= n 0)\n        '\"\"\n        (string-append (number->string\
    \ n) \" \" (loop))))\n  (values (loop)))\n", "  (define (helper n str-out)\n \
    \   (cond\n      [(< n 0)\n       (reverse str-out)]\n      [(even? n)\n     \
    \  (helper (- n 1) (append str-out \" \" (string_to_int n)))]\n      [else (helper\
    \ (- n 1) (append str-out \" \" (string_to_int (- n 1))))]\n      ))\n  (helper\
    \ n \"\"))\n", "  (let* ((result '())\n         (digit '(0)))\n    (cond [(= n\
    \ 0)\n           result]\n          [else\n           (string-append\n       \
    \     (string_sequence (sub1 n))\n            digit)]))\n  result)\n", "  (if\
    \ (= n 0)\n      '(0)\n      (cond [(> n 0)\n             (string-join (map number\
    \ '(0 1 2 3 4 5) (n-1))))]\n        [(= n 1)\n         (string-join '(0) (n-1))]\n\
    \        [else\n         (string-join (map number (range 0 (add1 n)))\n      \
    \                 (n-1))]))\n", "  (string->list \n   (for-each (lambda (i) (format\
    \ nil \"~a \" (+ (* i n) n))) (reverse (range 0 n))))\n  )\n", "  (if (<= n 0)\n\
    \      (string-append \"0\" \"\")\n      (loop (sub1 n) (lambda (i) (string-append\
    \ \" \" (number->string i))))))\n", "  (let loop ((n n) (out \"\")) (acc \"\"\
    ) (i 0)\n    (if (zero? n) (append out (list acc))\n      (loop (- n 1) (cons\
    \ n (concat acc \" \"))\n              (if (< n 0) (+ n i) acc)\n            \
    \  (+ i 1)))))\n", "  (string-append (number->string n) \" \"))\n</cell>\n<cell>\n\
    #lang racket\n", "  (if (zero? n)\n      \"0\"\n      (string-append (string_sequence\
    \ (sub1 n)) \" \" (string-sequence (sub1 n)))))\n", "  (let loop ((s (string->list\
    \ \"\"))\n             (i (string->list 0))\n             (n (string->list n)))\n\
    \    (cond\n      [(< (length s) (length n)) (loop (append s (string->list n))\
    \ (append i s) n)]\n      [(char= (first s) #\\Space) (loop (append s (string->list\
    \ #\\Space)) (append i s) n)]\n      [(char= (first n) #\\Space) (loop (append\
    \ s (string->list #\\Space)) i (append n s))]\n      [(char= (first s) #\\Space)\
    \ (loop (append s (string->list #\\Space)) i (append n s))]\n      [else (loop\
    \ (append s (string->list #\\Space)) i (append n s))]))\n</code>\n<|/ a |>\n<|\
    \ a dscore=0 |>\nA simple solution in Ruby:\n<code>\ndef string_sequence(n)\n\
    \  n.to_s.split('').map {|c| [c, n+c].join('')}.join(' ')\nend\n</code>\n<|/ a\
    \ tags=racket,string,scheme |>\n<| a |>\nThis is an old question, but I thought\
    \ I should post my solution for completeness sake:\n<code>", "  (cond\n    [(=\
    \ n 0) \"\"]\n    [else (concat \" \" (string_sequence (- n 1)))]))\n", "  (if\
    \ (zero? n)\n      '0\n      (string-append (string_sequence (sub1 n)) \" \" (string-to-number\
    \ n))))\n", "  (let loop ((i 0) (s \"\"))\n    (cond\n      [(< i n) s]\n    \
    \  [(< i (- n 1)) (loop (add1 i) s)]\n      [else (loop (add1 i) (append s (string\
    \ i))]))))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
