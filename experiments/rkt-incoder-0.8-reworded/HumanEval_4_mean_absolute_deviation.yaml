name: HumanEval_4_mean_absolute_deviation
language: rkt
prompt: "#lang racket\n\n;; For a given list of input numbers, calculate Mean Absolute\
  \ Deviation\n;; around the mean of this dataset.\n;; Mean Absolute Deviation is\
  \ the average absolute difference between each\n;; element and a centerpoint (mean\
  \ in this case):\n;; MAD = average | x - x_mean |\n;; >>> (mean_absolute_deviation\
  \ (list 1.0 2.0 3.0 4.0))\n;; 1.0\n(define (mean_absolute_deviation numbers)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate mean_absolute_deviation))\n\
  \    (check-equal? (candidate (list 1.0 2.0)) 0.5)\n    (check-equal? (candidate\
  \ (list 1.0 2.0 3.0 4.0)) 1.0)\n    (check-equal? (candidate (list 1.0 2.0 3.0 4.0\
  \ 5.0)) 1.2)\n))\n\n(test-humaneval)"
completions: ["  (let ((sum (+ 0 (reduce * (list (map - numbers numbers))))))\n  \
    \  (/ (- sum 0) (length numbers))))\n", "  (let ((mean (mean (list numbers))))\n\
    \    (/ (apply - (map abs numbers)) mean)))\n", "  (let ((x (first numbers))\n\
    \        (c (mean numbers)))\n    (if (not (null? (rest numbers)))\n        (/\
    \ (- (first numbers) c)\n          (abs (- (second numbers) x)))\n        0)))\n",
  "  (/ (apply + numbers\n         (map - numbers (mean numbers))) \n      (length\
    \ numbers)))\n", "  (if (empty? numbers)\n      (error \"There must be at least\
    \ one input number\" numbers)\n      (/ (- (car numbers)\n           (apply (lambda\
    \ (x mean)\n                    (/ (abs (- x mean)))\n                     (-\
    \ mean))\n            numbers (car numbers))))\n      NaN))\n", "  (/ (apply +\
    \ (map absolute numbers)) (nub (map length numbers))))\n", "  (define (mad x)\n\
    \    (- x (/ (sum (map abs numbers)) 2)))\n  (mad (list-ref numbers 0)))\n", " \
    \ (let ((mean 0) (sum (abs (- numbers))))\n    (for-each (lambda (x) (set! sum\
    \ (+ sum x))\n                   (set! mean (/ x sum))) numbers)))\n", "  (let\
    \ ((count 0))\n    (let loop ((numbers numbers)\n               (mean 0.0)\n \
    \              (deviation 0.0))\n      (cond\n        ((null? numbers) 0.0)\n\
    \        ((= count (length numbers)) 0.0)\n        ((< (car numbers) mean) deviation)\n\
    \        (else (loop (cdr numbers) (car numbers) (+ deviation (abs (- (car numbers)\
    \ mean)))))))))\n", "  (apply / (apply + numbers) (length numbers)))\n", "  (let\
    \ ((xs (map (\u03BB (x) (- x #%object-ref (mean numbers)))\n                 \
    \  numbers)))\n    (/ (abs (apply - xs)) (car (apply map - xs)))))\n", "  (let\
    \ ((mean (sum numbers)) (sum (map (lambda (x) (abs (x - mean)))\n            \
    \                        numbers))) (mad (/ (/ (sum numbers) (- sum sum))\n  \
    \                                   (- sum sum))))\n    mad))\n", "  (/ (apply\
    \ + (map (lambda (x) (abs (- x numbers))) numbers)) #(length numbers)))\n", " \
    \ (apply apply (map (\u03BB (x) (abs (- x mean))) numbers))) ; MAD = average |\
    \ x - x_mean |\n<|/ c |>\n<| c |>\nI'm sorry, I'm new to Lisp and I don't understand\
    \ this answer. Is there an easy way to do this in Scheme? I don't understand the\
    \ lambda function either. I'm trying to understand the code rather than just copying\
    \ it. Thank you very much.\n<|/ c |>\n<| c |>\nSorry, I tried to edit it, but\
    \ I kept getting an error message saying my edit was too short.\n<|/ c |>\n<|\
    \ c |>\n`lambda` is the function object for `(\u03BB (x) (+ x 1))`.  `(+ x 1)`\
    \ is shorthand for `(lambda (x) (+ x 1))`.  `(apply lambda (list 1 2 3))` is shorthand\
    \ for `(apply lambda '(1 2 3))`.  `(map (lambda (x) (+ x 1)) '(1 2 3))` is shorthand\
    \ for `(map (lambda (x) (+ x 1)) '(1 2 3))`.\n<|/ c |>\n<| a |>\nI haven't checked\
    \ it yet, but it looks fine, though I would change your last line to:\n<code>",
  "  (/ (apply + (map absolute (- numbers mean))) (length numbers)))\n", "  (/ (abs\
    \ (- (apply + numbers) (apply mean (map mean numbers))))\n     2.0))\n", "  (/\
    \ (apply + (map - (numbers) (mean (list* 0 numbers)))) (length numbers)))\n",
  "  (let ([mean (mean numbers)]\n        [dev (map abs numbers)])\n    (/ mean (map\
    \ sum dev))\n    ))\n", "  (/ (apply + (map (\u03BB (x) (abs (- x numbers))) numbers))\
    \ (car numbers)))\n", "  (let ([x (car numbers)\n        x_mean (car numbers)\n\
    \        y_mean (car (rest numbers))])\n    (/ (abs (- x x_mean))\n       (abs\
    \ (- y y_mean))))))\n</cell>\n<cell>\n#lang racket\n", "  (/ (apply + (map abs\
    \ numbers)) (apply + numbers)))\n", "  (if (empty? numbers)\n      (error \"MeanAbsoluteDeviation:\
    \ empty list of numbers\")\n      (/ (- (car numbers) (mean numbers)) (car (cdr\
    \ numbers)))))\n", "  (/ (apply + (map (fn [x] x) (map - numbers numbers))) \n\
    \     (length numbers)))\n", "  (/ (foldl #(abs (- %1 %2)) 0 numbers) (length\
    \ numbers)))\n", "  (let ((mean 0.0) (deviation 0.0))\n    (do ((n numbers (cdr\
    \ n)) ((null n) '()))\n        ((null? n) '(mean deviation))\n      (set! mean\
    \ (car n))\n      (set! deviation (+ (abs (- mean car n)) (abs (- mean (cadr n)))))))\n\
    )\n", "  (define (mean xs mean)\n    (if (null? xs)\n      mean\n      (mean cdr\
    \ (+ mean (first xs)))))\n  (if (null? numbers)\n    0.0\n    (/ (- (car numbers)\n\
    \         (mean (car numbers)\n              (car numbers))\n        )\n     (abs\
    \ (- (car numbers)\n             (mean (car numbers)\n                  (car numbers))\n\
    \             )\n      )\n    )\n  )\n", "  (/ (apply + (map (lambda (x)\n   \
    \                  (apply - numbers x))\n                   numbers))\n     (length\
    \ numbers)))\n", "  (let ((mean 0.0))\n    (for ((i numbers))\n      (let ((diff\
    \ (- i mean)))\n        (set! mean (+ mean i))\n        (/ diff mean)))))\n",
  "  (foldl (\u03BB (x y) (abs (- x y))) 0\n         numbers (/ (apply + numbers)\
    \ (length numbers))))\n", "  (define (mad x)\n    (if (null? numbers)\n      \
    \  0\n        (abs (- (first numbers) x))))\n  (apply + (map mad numbers)))\n",
  "  (let ((mean 0) (deviation 0))\n    (for ((x numbers))\n      (set! mean (+ mean\
    \ (/ x numbers))))\n    (for ((x numbers))\n      (set! deviation (+ (abs (- x\
    \ mean)) deviation))))\n  deviation)", "  (/ (mean (list numbers numbers numbers\
    \ numbers numbers numbers))\n     (length numbers)))\n", "  (cond [(null? numbers)\
    \ 0]\n        [(= (length numbers) 0) 0]\n        [else (/ (reduce + (map abs\
    \ (- numbers mean)))\n                (length numbers))]))\n", "  (if (null? numbers)\n\
    \      0\n      (/ (abs (first numbers)) (mean (rest numbers)))))\n", "  (if (not\
    \ (numbers?))\n      (error (make-error \"List of numbers not provided\" 'not-found))\n\
    \      (define mean (average numbers))\n      (define sum (sum numbers))\n   \
    \   (define (deviation number) (abs (- number mean)))\n      (define (mad x) (/\
    \ (- x mean) sum))\n      (cond ((and (number?) (number? mean)) mean)\n      \
    \      ((and (number?) sum) 0.0)\n            (else (error \"Bad input\" 'bad-input)))))\n",
  "  (/ (apply + (map (lambda (x) (abs (- x numbers))) numbers)) (car numbers)))\n",
  "  (let ((means '()))\n    (for ((number numbers) (mean 0))\n      (if (null? number)\n\
    \          (begin\n            (set! means (cons mean means))\n            mean)\n\
    \          (begin\n            (set! means (cons (+ (car number) mean) means))\n\
    \            (+ (car number) mean)\n            (set! number (cdr number)))\n\
    \      (let ((x (car means))\n            (y (cdr means)))\n        (set! x (-\
    \ (car means))\n              y (cdr means))\n        (set! means (cons (- x y)\
    \ means))))))\n", "  (let loop ((numbers numbers) (sum 0.0) (mean 0.0)\n     \
    \       (n 0))\n    (if (null? numbers)\n        sum\n        (loop (rest numbers)\
    \ (+ sum (car numbers))\n               (+ (/ n 2) mean)\n               (+ n\
    \ 1)))))\n</code>\nNow that we have a way to calculate MAD we can use it to compute\
    \ MEAN and STD. Here we use the MAD function we created earlier to compute the\
    \ MEAN and then we use the MEAN and STD functions we created earlier to compute\
    \ the MEAN and STD of our dataset:\n<code>", "  (if (null? numbers)\n      0.0\n\
    \      (/ (apply + (map abs (- numbers (apply average numbers)))) 2.0)))\n", " \
    \ ;; Sum all differences.\n  (define (sum-deviations x)\n    (- x))\n  (define\
    \ (sum-of-squares x)\n    (* x x))\n  (define (mean x)\n    (/ (reduce +\n   \
    \          (map (lambda (x) (/ x x))\n                  numbers))\n       #:initial-value\
    \ 0.0))\n  (define (sum-deviations\n           (reduce +\n                   (map\
    \ (lambda (x) (sum-deviations x))\n                         numbers))\n      \
    \     0))\n  (define (sum-of-squares\n           (reduce +\n                 \
    \  (map (lambda (x) (sum-of-squares x))\n                         numbers))\n\
    \           0))\n  (define (absolute x)\n    (if (< x 0.0)\n        (-)\n    \
    \    x))\n  (define (sum-of-absolute x)\n    (reduce (lambda (x y)\n         \
    \      (+ x y))\n             0\n             x))\n  (define (mean-of-squares\
    \ x)\n    (/ (reduce sum-of-squares\n             (map (lambda (x) (/ x x))\n\
    \                  numbers))\n       #:initial-value 0.0))\n  (define (deviation\n\
    \           (reduce (lambda (x y)\n                     (+ (absolute x) (* y y)))\n\
    \                    0\n                    x))\n  (define (deviation\n      \
    \     (reduce (lambda (x y)\n                     (+ (absolute x) (* y y)))\n\
    \                    0\n                    x))\n  (define (deviation-sum-of-squares\n\
    \           (reduce (lambda (x y)\n                     (+ x y))\n           \
    \  0\n             x))\n  (define (deviation-sum-of-absolutes\n           (reduce\
    \ (lambda (x y)\n                     (+ x y))\n             0\n             x))\n\
    \  (define (deviation-deviation\n           (reduce (lambda (x y)\n          \
    \           (+ (absolute x) (* y y)))\n             0\n             x))\n  (define\
    \ (deviation-deviation-sum-of-squares\n           (reduce (lambda (x y)\n    \
    \                 (+ x y))\n             0\n             x))\n  (define (deviation-deviation-sum-of-absolutes\n\
    \           (reduce (lambda (x y)\n                     (+ x y))\n           \
    \  0\n             x))\n  (define (deviation-mean-of-squares x)\n    (/ (reduce\
    \ deviation-sum-of-squares\n             (map (lambda (x) (/ x x))\n         \
    \         numbers))\n       #:initial-value 0.0))\n  (define (deviation-mean x)\n\
    \    (/ (reduce deviation-sum-of-absolutes\n             (map (lambda (x) (/ x\
    \ x))\n                  numbers))\n       #:initial-value 0.0", "  (/ (apply\
    \ + numbers) (length numbers)))\n", "  (let ((x (car numbers))\n        (dx (car\
    \ numbers)\n            (y (length numbers))\n            (x_mean (car numbers)))\n\
    \        (y (/ (length numbers) 2)))\n    (/ (/ (- y (* x y)) (- x x_mean)) (*\
    \ x y))))\n", "  (if (empty? numbers)\n      '0\n      (hd numbers)\n      (recur\n\
    \       (cdr numbers)\n       (+ (abs (- x x_mean))\n          (* 2 (mean_absolute_deviation\
    \ (cdr numbers))))\n       (+ x_mean (/ (apply + numbers) (length numbers))))))\n",
  "  (/ (abs (map abs numbers))\n     (length numbers)))\n", "  (let ((mean (car numbers))\n\
    \        (sum (cadr numbers))\n        (diff (map (lambda (n) (abs (- n mean)))\
    \ numbers)))\n    (/ (apply + diff) sum)))\n", "  (define (mad numbers mean)\n\
    \    (define (mad-aux mean numbers output)\n      (cond [(empty? numbers) output]\n\
    \            [else (mad-aux (car numbers) (append (cdr numbers) mean)\n      \
    \                        (cons (abs (- (car numbers) mean) mean)\n           \
    \                         output))]))\n    (mad-aux mean numbers '()))\n\n  (define\
    \ (mad-aux-mean mean numbers)\n    (let ((diff (mad numbers (car numbers))))\n\
    \      (mad-aux-mean diff (cdr numbers))))\n\n  (mad-aux-mean mean numbers))\n",
  "  (let ((mean 0))\n    (for ([x numbers])\n      (let ((diff (- x mean)))\n   \
    \     (set! mean (+ mean x))\n        (set! diff (+ diff diff))\n        (+ diff\
    \ diff))))\n  mean)\n", "  (let ((mean (mean numbers)))\n    (/ (reduce + (map\
    \ (\u03BB (x) (- x mean)) numbers)) numbers))) ; #lang racket\n", "  (let ((mean_\
    \ (apply average (map mean numbers))))\n    (apply * (map abs (- numbers mean_)))))\n",
  "  (* (apply min (map (lambda (x) (abs (- x mean))) numbers)) 2.0))\n", "  (/ (apply\
    \ - (map mean numbers)) \n     (apply + (map abs numbers))))\n", "  (let ((mean\
    \ (car numbers))\n        (diff (cdr numbers)))\n    (+ (abs (- diff mean)) (/\
    \ (length numbers) 2))))\n", "  (/ 0 (abs (reduce + numbers))))\n", "  (let* ((mean\
    \ (mean_of_list numbers))\n         (sum (abs (map - numbers (list mean)))))\n\
    \    (/ sum numbers)))\n", "  (/ (apply + (map (lambda (x) (abs (- x mean))) numbers))\
    \ count))\n", "  ;; Get average of all numbers:\n  (/ (apply + numbers)\n    \
    \ (length numbers)))\n", "  (/ (apply + (map abs numbers)) (length numbers)))\n",
  "  (let ((mean (foldr (lambda (x y) (foldr + (car x) (cdr y)) 0.0) (list 0.0) (numbers))))\n\
    \    (/ (- (apply + (map (lambda (x) (- (abs x) mean)) numbers)) mean) 2.0)))\n",
  "  (let ((x_mean (mean numbers)))\n    (map (lambda (x)\n           (abs (x - x_mean)))\n\
    \         numbers)))\n", "  (let* ((m (mean numbers))\n         (diff (map abs\
    \ (map - numbers m)))\n         (sum (apply + diff)))\n    (/ (apply / sum diff)\
    \ 2.0)))\n</code>\n<|/ a tags=racket,scheme,lisp |>\n<| c |>\nNice answer. `sum`\
    \ is not a good name for a function. Consider naming it `mean` or `average` or\
    \ something that conveys the meaning clearly to the reader.\n<|/ c |>\n<| c |>\n\
    Thank you, I updated the code to better reflect what you're saying. I think this\
    \ might be the best way to get the `sum` though. I'm going to play around with\
    \ the rest of this answer for a bit and see if I can come up with a better solution.\n\
    <|/ c |>\n<| c |>\nThanks, this is exactly what I needed.\n<|/ c |>\n<| a dscore=1\
    \ |>\n<code>", "  (let ((mean 0 (count numbers)))\n    (for ((i (range (count)))\
    \ ; i = 1, 2, 3, ...\n          (j (+ i (- count i))) ; j = 2, 4, 6, ...\n   \
    \       (m (+ mean numbers (- numbers mean)))) ; m = 1.2, 2.4, 3.6, ...\n    \
    \  (set! m (/ m i))\n      (set! mean (+ mean m))\n      m))) ; m is now the average\n",
  "  (/ (mean (map abs numbers)) 2.0))\n", "  (define (mad x)\n    (abs (- x mean)))\n\
    \  (map mad numbers))\n", "  (/ (apply + (map (lambda (x) (abs (- x mean))) numbers))\
    \ #(length numbers)))\n", "  (let* ((mean (/ (apply + numbers) (length numbers))))\n\
    \    (apply (lambda (x) (abs (x-mean)))\n           numbers)))\n", "  (let ((mean\
    \ (fold (car numbers) 0.0 numbers)))\n    (/ (apply - numbers) (apply + (map abs\
    \ numbers)))))\n", "  (define (mad x mean)\n    (/ (abs (- x mean)) (length numbers)))\n\
    \  (reduce mad numbers 0))\n", "  (if (null? numbers)\n      0\n      (/ (- (car\
    \ numbers) (mean (rest numbers))) \n         (- (length numbers) (length numbers))))))\n",
  "  (/ (mean numbers) (length numbers)))\n", "  (rest (map abs numbers) (/ (length\
    \ numbers) 2)))\n", '  (/ (sum (map (lambda (x) (abs (- x mean))) numbers)) count))',
  "  (define mean 0.0)\n  (for ([i (in-range numbers)])\n    (set! mean (+ (* i mean)\
    \ (abs (- numbers (mean numbers))))))\n  mean)\n", "  (/ sum (map (\u03BB (x)\
    \ (abs (- x mean))) numbers)))\n  ", "  (define mean (/ (apply + numbers) (length\
    \ numbers)))\n  (define deviations\n    (map (lambda (x)\n           (abs (- x\
    \ mean))) numbers))\n  (/ (apply + deviations) (length deviations)))\n", "  (cond\n\
    \    [(empty? numbers) 0]\n    [(number? (car numbers)) (abs (- mean (car numbers)))]\n\
    \    [else (+ (mean_absolute_deviation (cdr numbers)) (abs (- mean (car numbers))))]))\n",
  "  (let ((mean 0.0))\n    (for/sum ((x numbers) (sum 0.0))\n      (let ((diff (-\
    \ x mean)))\n        (set! sum (+ sum diff))\n        (set! mean (/ (+ diff mean)\
    \ 2.0)))\n      sum)\n    mean))\n", "  (define (mad numbers)\n    (if (null?\
    \ numbers)\n        0\n        (let ((sum (car numbers))\n              (mean\
    \ (car numbers))\n              (diffs (cdr numbers)))\n          (if (null? (cdr\
    \ numbers))\n              (/ (- diff mean) 2)\n              (+ (+ (- diff mean)\
    \ diff) 2)\n              (mad (cons (car numbers) (cdr numbers))))))))\n  (reverse\
    \ (map (lambda (numbers)\n                  (/ (- (mad numbers)) (length numbers)))\n\
    \              numbers)))\n", "  (apply - (map (\u03BB (x) (abs (- x mean))) numbers)))\n",
  "  (/ (apply + (map abs numbers)) \n     (length numbers)))\n", "  (let ((diff (apply\
    \ - numbers)))\n    (/ (apply mean diff) 2.0)))\n", "  (define (mean numbers)\n\
    \    (let ((sum (reduce + numbers)))\n      (/ sum numbers))\n    (let ((x_mean\
    \ (mean numbers)))\n      (let ((diffs (map (lambda (x) (- x x_mean)) numbers)))\n\
    \        (reduce + (map (lambda (d) (* d d)) diffs)))))\n\n  (mean (map (lambda\
    \ (n) (abs (- n numbers))) numbers)))\n", "  (let ((x (mean numbers)))\n    (let\
    \ loop ((numbers numbers))\n      (if (empty? numbers)\n          1.0\n      \
    \    (let ((x-x (car numbers))\n                (y-x (car numbers))\n        \
    \        (z-x (car numbers))\n                (w-x (car numbers))\n          \
    \      (y-y (mean numbers))\n                (z-y (mean numbers))\n          \
    \      (w-y (mean numbers)))\n            (/ x (abs (- x y))\n               \
    \  (abs (- x z))\n                 (abs (- x w))\n                 (abs (- y z))\n\
    \                 (abs (- y w))\n                 (abs (- z w))\n            \
    \     (abs (- w x)))))))))\n", "  (/ (abs (- numbers (apply mean numbers)))\n\
    \     (length numbers)))\n", '  (/ (apply + (map (lambda (x) (abs (- x mean)))
    numbers)) count))', "  (let ((mean (average-list numbers)))\n    (/ (sum square-list\
    \ (map abs-list numbers)) sum-list (length numbers))\n    (* mean mean)))\n",
  "  (let* ((avg (mean (map f numbers)))\n         (x_mean (f avg))\n         (mad\
    \ (map abs (- numbers (f avg)))))\n    (/ (sum mad) (length numbers))))", "  (define\
    \ (compute_mad)\n    (if (null? numbers)\n        #f\n        (let ((mean (first\
    \ numbers))\n              (x numbers)\n              (x_diff (map (lambda (n)\
    \ (- n mean)) numbers))\n              (x_squares (map (lambda (n) (* n n)) numbers)))\n\
    \          (/ x_diff (sum x_squares)))))\n  (compute_mad))\n", "  (define mean\
    \ (foldr (\u03BB (x y) (+ x y)) 0.0 (map car numbers)))\n  (define mdev (foldr\
    \ (\u03BB (x y) (- x y)) 0.0 (map car numbers)))\n  (/ (- mean mdev) (length numbers))\n\
    \  )\n", "  (let* ((mean (mean numbers))\n         (sum (foldl (lambda (x acc)\
    \ (+ x (* acc x))) 0 numbers)))\n    (/ (abs (- mean sum))\n     (length numbers))))\n",
  "  (define mean (/ (apply + numbers) (length numbers)))\n  (define deviation (map\
    \ - numbers mean))\n  (/ (apply + deviation) (length deviation)))\n", "  (/ mean\
    \ (abs (map (lambda (x) (- x mean)) numbers))))\n", "  ;; Calculate mean using\
    \ the numbers list.\n  (define mean (/ (reduce + (map mean numbers)) (car numbers)))\n\
    \  ;; Calculate difference for each number from the mean.\n  (define diff (map\
    \ abs (- numbers mean)))\n  ;; Calculate the MAD.\n  (/ (reduce + diff) (car numbers)))\n",
  "  (if (null? numbers)\n      0.0\n      (let ((diff (car numbers))\n          \
    \  (average (/ (- diff (mean numbers)) (abs diff))))\n        (+ average (mean_absolute_deviation\
    \ (cdr numbers)))))\n", "  (let ((n 0))\n    (let loop ((numbers numbers)\n  \
    \             (mean 0.0))\n      (cond ((null? numbers) 0)\n            ((> (car\
    \ numbers) mean)\n             (let ((sum (- sum numbers))\n                 \
    \  (count 0))\n               (loop (cdr numbers)\n                      (+ mean\
    \ (/ sum count))))\n            (else (loop (cdr numbers)\n                  \
    \    mean)))))\n</code>\n<|/ a |>\n<| a tags=lisp,racket |>\nHere is a recursive\
    \ solution\n<code>", "  (let ((mean (apply + numbers)))\n    (/ (apply - numbers\
    \ mean) (in-number-range numbers))))\n", "  (/ (apply + numbers) (length numbers)))\n",
  "  (if (null? numbers)\n      0.0\n      (/ (apply + (map - numbers (mean numbers)))\
    \ 2.0)))\n", "  (let ((mean (car numbers))\n        (deviations (cdr numbers)))\n\
    \    (if (null? deviations)\n        mean\n        (+ (* 0 (car deviations)\n\
    \              (abs (- (car numbers) mean)))\n           (mean_absolute_deviation\
    \ (cdr numbers))))))\n", "  ;; Calculate mean of the dataset.\n  (define (mean\
    \ numbers)\n    (car numbers))\n  (define (sum-of-squares-values numbers mean)\n\
    \    (map (lambda (n)\n           (- n (* n mean)))\n         numbers))\n  (/\
    \ (reduce (lambda (x mean)\n                (+ x (* x mean)))\n            sum-of-squares-values\
    \ numbers)\n     #(/ (length numbers) 2.0)))\n", "  (if (null? numbers)\n    \
    \  0.0\n      (let ([x_mean (mean numbers)\n            y_mean (/ (apply + (map\
    \ mean numbers))\n                       (length numbers))])\n        (/ (apply\
    \ + (map abs (- numbers (list x_mean)))) \n           (length numbers)))))\n",
  "  (define (mean-absolute-deviation xs)\n    (if (null? xs)\n        0.0\n     \
    \   (+ (* (car xs) (abs xs))\n           (mean-absolute-deviation (cdr xs)))))\n\
    \  (mean-absolute-deviation (list numbers)))\n", "  (if (empty? numbers)\n   \
    \   0.0\n      (/ mean (abs (- numbers)))))\n</cell>\n<cell>\n%%racket\n", " \
    \ (fold-left (lambda (x x_mean) (+ x x_mean))\n            (/ 0.0)\n         \
    \   numbers))\n", "  (define mean (apply average numbers))\n  (define x 0)\n \
    \ (define x_mean 0)\n  (define (mad x)\n    (cond ((= x mean) 0.0)\n         \
    \ ((> x x_mean) 0.0)\n          ((> x mean) 0.0)\n          ((< x x_mean) (+ x\
    \ x_mean))\n          (else (+ x x_mean))))\n  (let loop ((i 0))\n    (set! x_mean\
    \ (/ (+ x mean) (+ i 1)))\n    (set! x (+ x numbers[i]))\n    (set! i (+ i 1))\n\
    \    (if (< i 5)\n        (mad x)\n        (loop (+ i 1)))))\n", "  (apply / (apply\
    \ + numbers) (length numbers)))\n", "  (/ (mean (map abs numbers)) 2.0))\n", " \
    \ (/ (reduce + (map abs (- numbers mean))) count))\n", "  (/ (apply + (map - numbers\
    \ (list mean numbers))) \n     (length numbers)))\n", "  (let ((x (apply mean\
    \ numbers)))\n    (+ (abs (- x x)) (/ (length numbers) 2))))\n", "  (/ (mean numbers)\
    \ (length numbers)))\n", "  (rest\n    (map abs\n         (map (lambda (x) (/\
    \ x numbers)) numbers))\n    2))\n", "  (let ((sum (sum numbers)))\n    (/ (-\
    \ sum mean) (length numbers))))\n", "  (/ (apply - (map abs numbers)) \n     (apply\
    \ - (map average numbers))))", "  (/ (apply + (map abs (- numbers number))) numbers))\n\
    </code>\n<|/ a tags=racket,scheme |>\n<| c |>\nThat's a really nice and useful\
    \ answer - thanks for taking the time to add it - I really appreciate it.\n<|/\
    \ c |>\n<| c |>\nI agree with, this is an excellent answer.\n<|/ c |>\n<| c |>\n\
    I added a version that uses `for`, which should run a bit faster.\n<|/ c |>\n\
    <| c |>\nThanks a lot for adding the explanation of your code. As far as I know,\
    \ Racket has some sort of list comprehension syntax (like Haskell). So `[mean\
    \ [mean xs | x <- numbers]]` is equivalent to `[mean [mean x | x <- numbers]]`\
    \ but much more readable.\n<|/ c |>\n<| c |>\nI didn't know about this one, but\
    \ I suppose it's an excellent way of getting it done. Thanks!\n<|/ c |>\n<| a\
    \ dscore=2 |>\nFor what it's worth, here's an approach using for and list comprehensions:\n\
    <code>", "  (/ (apply + numbers) (length numbers)))\n", "  (/ (- (reduce + numbers)\n\
    \        (reduce + numbers))\n     (length numbers)))\n", "  ;; mean := (sum x)\
    \ / (n of x)\n  ;; n := (length numbers)\n  (define (mean x n)\n    (/ x (length\
    \ x)))\n  ;; x := numbers - mean\n  ;; sum := (reduce + x)\n  ;; n := (length\
    \ numbers)\n  (define (sum-x numbers)\n    (reduce + numbers))\n  (/ (- sum-x\
    \ mean) (length numbers)))\n", "  (let ((mean (mean_of numbers)))\n    (let loop\
    \ ((diff 0.0)\n               (numbers numbers))\n      (if (null? numbers)\n\
    \          diff\n          (loop (+ diff (abs (- (car numbers) mean))\n      \
    \             (cdr numbers))\n                (cddr numbers))))))\n", "  (/ (apply\
    \ + (map absolute (map - numbers numbers))) 6))\n", "  (/ (apply + numbers) (apply\
    \ + list)))\n", "  ;; Mean Absolute Deviation is the average absolute difference\
    \ between each\n  ;; element and a centerpoint (mean in this case):\n  (define\
    \ (mad x x_mean)\n    (if (empty? numbers)\n        'zero\n        (+ (abs (-\
    \ x x_mean))\n           (mcd (rest numbers) x))))\n\n  ;; >>> (mean_absolute_deviation\
    \ (list 1.0 2.0 3.0 4.0))\n  ;; 1.0\n  (mad numbers '(1.0))\n  )\n</code>\n<|/\
    \ a |>\n<| a tags=scheme,racket |>\nFor those who want to do it using only standard\
    \ library functions, here is my solution:\n<code>", "  (/ (apply + (map (lambda\
    \ (x) (abs (- x mean))) numbers)) n))\n", "  (/ (apply + (map abs (- numbers mean)))\
    \ (in-range (length numbers))))\n", "  (if (null? numbers)\n      (/ (car (list\
    \ numbers)) (car numbers))\n      (+ (abs (- numbers (/ (car numbers) (car numbers))))\
    \ \n          (abs (- (car numbers) (/ (car numbers) (car numbers)))))))\n", " \
    \ (define (mean xs)\n    (/ (apply + xs) (length xs)))\n  (define (mean xs ys)\n\
    \    (/ (apply + xs) (length ys)))\n  (/ (reduce + numbers)\n     (- (length numbers)\n\
    \        (length numbers))))\n</code>\n<|/ a |>\n<| c |>\nThis implementation\
    \ seems to have some issues. For example, the MAD value is correct when given\
    \ two numbers, but gives NaNs for three numbers. Also, if there is a list with\
    \ fewer than 2 numbers in it, the MAD value is NaN. Finally, this implementation\
    \ does not return a list of the same length as the input list, which seems to\
    \ be what the OP requires.\n<|/ c |>\n<| a |>\n<code>", "  (if (or (null? numbers)\
    \ (null? (cdr numbers)))\n      (float 0.0)\n      (let ((mean (/ (car numbers)\
    \ (length numbers)))\n            deviations (map - numbers numbers))\n      \
    \  (/ mean (abs deviations)))))\n", "  (/ (apply + (map * numbers numbers)) (length\
    \ numbers)))\n", "  (/ (apply + numbers)\n     (length numbers)))\n", "  (let\
    \ ((x_mean (average numbers)))\n    (/ (apply - numbers x_mean) length (- numbers\
    \ x_mean))))\n", "  (let ((mean (mean numbers)))\n    (/ (apply - (map - numbers\
    \ mean)) (length numbers))))\n", "  (let* ((mean (car numbers))\n         (sum\
    \ (cdr numbers)))\n    (/ (abs (- mean sum)) (length numbers))))\n", "  (/ (reduce\
    \ +\n             (map (lambda (x) (abs (- x #))))\n             numbers)\n  \
    \   (length numbers)))\n", "  (if (empty? numbers) 0\n      (let ((mean 0) (diff\
    \ 0))\n        (let loop ((numbers numbers)\n                   (n (car numbers))\n\
    \                   (n-1 (cdr numbers))\n                   (mean mean)\n    \
    \               (diff diff)\n                   (count 0))\n          (if (= n\
    \ 0)\n              (/ mean diff)\n              (loop (cdr numbers)\n       \
    \             (- n (car numbers))\n                    (+ n n-1)\n           \
    \         (+ mean diff)\n                    (+ count 1)))))))\n", "  (let ((x\
    \ (apply + numbers)))\n    (/ (abs (- x mean)) (length numbers))))\n", "  (if\
    \ (empty? numbers)\n      0\n      (+ (abs (- (car numbers) (mean numbers))) (*\
    \ (mean numbers) (mean numbers)))))\n", "  (define mean_number (mean numbers))\n\
    \  (define (mad x mean)\n    (define (abs-abs x)\n      (if (< x mean)\n     \
    \     x\n          (abs x)))\n    (apply + (map (lambda (x) (abs-abs x)) numbers))\n\
    \    (/ (apply + (map (lambda (x) (abs-abs x)) numbers)) (fold-right + 0 numbers))\n\
    \    (/ (reduce + numbers) (fold-right + 0 numbers))\n    (apply * 0.5 (/ (apply\
    \ + numbers) (fold-right + 0 numbers))))\n  (mad numbers mean_number))\n", " \
    \ (/ (apply + (map abs (map - numbers numbers))) (length numbers)))\n", "  (let\
    \ ((mean (mean_value numbers)))\n    (+ (mean numbers) (abs (- mean numbers)))))\n",
  "  (if (empty? numbers)\n      '0\n      (+ (abs (first numbers)) (abs (/ (- mean\
    \ number) (* (length (rest numbers)) 2))))\n      ;; For numbers greater than\
    \ the mean subtract its distance to the mean\n      ;; from the mean\n      (/\
    \ (- mean number) (* (length (rest numbers)) 2))\n      ;; Add all the distances\
    \ then divide by the number of numbers in the set\n      ;; Subtract the mean\
    \ from each of the numbers and divide by the number\n      ;; to get the average\
    \ value\n      (/ (- (mean number) (* (length (rest numbers)) 2)) (* (length (rest\
    \ numbers)) 2))))\n", "  (/ (mean (map abs numbers) (length numbers)) 2.0))\n",
  "  (let ((mean 0))\n    (if (null? numbers)\n        (/ 0 1)\n        (let* ((number\
    \ (car numbers))\n               (difference (car numbers))\n               (newMean\
    \ (+ mean (* number difference)))\n               (newMeanList (cons mean newMean))\n\
    \               (newNumbers (cdr numbers))\n               (newNumbersList (cons\
    \ number newNumbers))\n               (newNumbersList (append newNumbersList newNumbersList)))\n\
    \          (/ 0 (length newNumbersList)\n             (mean_absolute_deviation\
    \ newNumbersList))))))\n", "  (/ (apply - (map - numbers mean)) (apply + (map\
    \ - numbers mean))))\n", "  (if (empty? numbers)\n      0\n      (let ((mean (car\
    \ numbers))\n            (sum (cdr numbers)))\n        (+ (/ (- mean (* (car numbers)\
    \ sum)) (- sum mean)) sum))))\n", "  (if (empty? numbers)\n      #f\n      (let\
    \ ((x_mean (car numbers)))\n        (/ (apply - (rest numbers)) (x_mean . x_mean)))))\n",
  "  (let ((sum (foldl + 0 numbers\n                     #(let ((number (car %)))\n\
    \                        (+ (abs (- number %)) (* 2 number))))\n        mean (/\
    \ (sum numbers) (length numbers))))\n    (/ (sum numbers (- numbers (list mean))))))\n",
  "  (/ (reduce + (map abs (- numbers mean))) total))\n", "  (let ((mean 0 (sum 0)))\n\
    \    (do ((i numbers 0)\n         (diff (- x mean)))\n      ((= i #) (/ diff mean))\n\
    \      (set! mean (+ mean diff))\n      (set! i (+ i 1))))\n  mean)\n", "  (apply\
    \ / (apply + (map (lambda (number) (abs (- number mean))) numbers)) numbers))\n",
  "  (foldr (lambda (x y)\n           (/ (abs (- x y)) 2))\n         numbers\n   \
    \      0.0))\n", "  (let* ((sum (apply + numbers))\n         (mean (apply / (apply\
    \ + numbers))))\n    (/ (apply abs (- numbers mean)) sum)))\n", "  (cond\n   \
    \ [(empty? numbers) 0.0]\n    [(> (car numbers) (car numbers)) 0.0]\n    [else\
    \ (abs (- (car numbers) (/ (reduce + numbers) 2.0)))]))\n", "  (let ((mean (car\
    \ numbers))\n        (sum (cdr numbers)))\n    (/ (apply + numbers) (- sum mean))))\n",
  "  (let ([nums (filter number?)])\n    (if (empty? nums) 0\n        (+ (abs (first\
    \ nums)) (mean_absolute_deviation (rest nums))))))\n", "  (/ (apply + (map abs\
    \ (- numbers mean)) numbers) (length numbers)))\n  ;; (/ (apply + ...) ...) =>\
    \ (apply + ...) / ...\n  ;; Applied to the sum of the absolute differences to\
    \ calculate MAD\n  (+ mad_abs (- numbers (- mean numbers))))\n", "  (let* ((mean\
    \ (/ (apply + numbers) (length numbers)))\n         (sum (apply + numbers))\n\
    \         (diff (- mean sum)))\n    (/ (apply abs diff) 2.0)))\n", "  (/ sum \n\
    \     (for/sum ([i (in-range (- length numbers) 1)]\n               [j (in-range\
    \ i 1)]\n               [k]\n               [(diff (+ numbers (- numbers i)))])\n\
    \       [k]))) ; <-- this is how you get the average of a list of numbers\n",
  "  (/ (apply + (map (lambda (n) (abs (- n numbers))) numbers)) 6))\n", "  (if (null?\
    \ numbers) #f)\n  (/ (* (- numbers (mean numbers)) (length numbers)) 2.0)))\n",
  "  (/ (apply + numbers)\n     (apply + numbers)))\n", "  (let ((mean (/ (reduce\
    \ + (map mean numbers)) (length numbers))))\n    (/ (map (lambda (number) (abs\
    \ (- number mean))) numbers) (length numbers))))\n", "  (/ (apply + (map abs numbers))\
    \ (apply + (map length numbers))))\n", "  (let ((mean (mean numbers)))\n    (/\
    \ (apply (map abs numbers) (map - numbers mean)) (length numbers))))\n", "  (-\
    \ (apply + (map abs numbers)) \n     (/ (apply + numbers) (length numbers))))\n",
  "  (/ #(abs (- x mean)) (length numbers)))\n", "  (cond [(null? numbers) 0]\n  \
    \      [(number-positive? numbers)\n         (+ (abs (first numbers)) (mean_absolute_deviation\n\
    \                               (rest numbers)))]\n        [else\n         (*\
    \ 1 (mean_absolute_deviation (rest numbers)))]))\n", "  (let ((mean 0))\n    (do\
    \ ((i numbers ((+ i 1))))\n        ((zero? i))\n      (let ((diff (- i mean)))\n\
    \        (set! mean (+ i mean))\n        (+ diff diff)))))\n", "  (define (mean\
    \ n)\n    (/ n (length numbers)))\n  (define (mean n sum)\n    (/ (/ (+ n sum)\
    \ 2) n))\n  (let ((sum (sum numbers)))\n    (mean numbers (- sum numbers))))\n",
  "  (/ 0 (apply + (map * (numbers - mean) (numbers - mean)))))\n", "  (/ (apply +\
    \ (map absolute numbers)) (length numbers)))\n", "  (/ (apply + (map (lambda (x)\
    \ (abs (- x numbers))) numbers))\n     (length numbers)))\n", "  (let ((mean (mean_value\
    \ numbers)))\n    (let ((sum 0.0))\n      (for_each numbers (lambda (x) (set!\
    \ sum (add! sum (abs (- x mean)))))) (/ (sum count) count))))\n", "  (let* ((mean\
    \ (/ (reduce + (map mean numbers)) (car numbers)))\n         (sum (map abs\n \
    \                  (remove-if (lambda (number) (> number mean))\n            \
    \                   numbers))))\n    (/ (* sum sum) 2.0)))\n", "  (apply * (map\
    \ abs\n               (map - numbers numbers)))\n  ;; For a list of numbers, MAD\
    \ is the average of the absolute differences\n  ;; between the numbers *and* the\
    \ mean:\n  ;; >>> (mean_absolute_deviation (list 1.0 2.0 3.0 4.0))\n  ;; 1.0\n\
    )\n", "  (/ (apply + (map + numbers numbers)) \n     (apply + (map - numbers numbers))))\n\
    </cell>\n<cell>\n#lang racket\n", "  (let ((mean (apply average numbers)))\n \
    \   (/ (apply abs numbers) (apply abs mean))))\n", "  (apply + (map (lambda (x)\
    \ (abs (- x numbers))) numbers)))\n", "  (/ (apply abs (- numbers mean)) (length\
    \ numbers)))\n", "  (/ sum (map (lambda (x)\n                (abs (- x mean)))\n\
    \             numbers)))\n", "  (apply / (map abs (numbers - mean))\n        \
    \ numbers))\n", "  (if (null? numbers)\n      0\n      (/ <* (apply + (map (lambda\
    \ (x) (abs (- x <@numbers))) numbers))\n         (length numbers))))\n", "  (let\
    \ ((mean 0)\n        (mean 0))\n    (for ((n numbers))\n      (set! mean (+ mean\
    \ (/ n 2))))\n    (/ (- mean mean) 2))) ; #lang racket\n", "  ;; For now, assume\
    \ a mean of zero.\n  (let ((x_mean (car numbers))\n        (y_mean (cadr numbers)))\n\
    \    (let ((m1 (+ x_mean y_mean)))\n      (let ((m2 (- (car numbers)\n       \
    \          (* (car numbers) (cadr numbers))))))\n        (/ (- m1 m2)\n      \
    \    (sqrt (car (cdr numbers)))))))\n", "  (define (helper mean numbers)\n   \
    \ (cond\n      [(null? numbers) mean]\n      [else\n       (helper (+ (- mean\
    \ (car numbers)) (car numbers)) (cdr numbers))]))\n  (helper (car numbers) numbers))\n",
  "  ((apply - (map (lambda (number) (- (mean number) number)) numbers)) /\n   (apply\
    \ + (map (lambda (number) number) numbers))))\n", "  (apply /\n         (/ (apply\
    \ + numbers) (length numbers))\n         (apply abs numbers)))\n", "  (/ (abs\
    \ (apply - numbers))\n     (length numbers)))\n", "  (let ([length (length numbers)])\n\
    \    (/ (apply + (map (lambda (n) (abs (- n mean)))\n                       numbers))\
    \ length)))\n", "  (fold\n   (\u03BB (mean current)\n     (average (map (\u03BB\
    \ (x) (abs (- x mean))) current))))\n   (first numbers)\n   (rest numbers)))\n",
  "  (let ((sum (make-vector (car numbers) 0))\n        (sum-squared-dev (make-vector\
    \ (car numbers) 0)))\n    (do ((x numbers (cdr x)))\n        ((null? x) sum)\n\
    \      (do ((n n x))\n          ((= n 0) (error \"list must be non-empty\"))\n\
    \        (do ((y (car y) (- n 1))\n             ((null? y) sum)\n            \
    \ ((= y 0) sum-squared-dev)\n             ((= y n) (add1 (car y))))\n        \
    \  ((< n 1) (error \"list must be non-empty\"))\n          (do ((y (cdr y))\n\
    \               ((null? y) sum)\n               ((= y 0) sum-squared-dev)\n  \
    \             ((= y n) (add1 (cdr y))))))\n    (/ (make-vector 1 sum)\n      \
    \ sum-squared-dev)))\n", "  (if (or (null? numbers) (null? (cdr numbers)))\n \
    \     (if (or (not (number? (car numbers)))\n              (not (number? (cdr\
    \ numbers))))\n          0.0\n          (car numbers))\n      (let ((x (car numbers))\n\
    \            (x_mean (mean x)))\n        (let ((y (mean_absolute_deviation\n \
    \                 (cons (car numbers) (cdr numbers)))))\n          (/ (+ (abs\
    \ (- x x_mean)) y)\n              2.0))))\n", "  (/ (apply + (map * numbers numbers))\
    \ (- (apply + (map mean numbers)))))\n</cell>\n<text>\nThe function above applies\
    \ a map to each number, and then applies +, * and\n/, to them. Notice that we\
    \ take the difference of (apply + ...) and", "  (cond [(null? numbers) 'null]\n\
    \        [(= (length numbers) 1) (abs (first numbers))]\n        [else (abs (first\
    \ numbers)\n                   (* (mean_absolute_deviation (rest numbers))\n \
    \                      (abs (first numbers))))]))\n", "  (define (mean xs)\n \
    \   (/ #(apply + xs) (length xs)))\n\n  (define (deviation xs)\n    (/ (apply\
    \ - xs) (length xs)))\n\n  (define (mean xs n)\n    (/ (apply + xs) n))\n\n  (define\
    \ (deviation xs n)\n    (/ (apply - xs) n))\n\n  (let ((mean (mean numbers))\n\
    \        (deviation (deviation numbers)))\n    (/ (apply + numbers) (* length\
    \ (apply - numbers)))))", "  (apply abs (map - numbers mean)))\n", "  (if (null?\
    \ numbers)\n      '(0)\n      (/ (apply + (map (fn [x] (abs (- x numbers))) numbers))\
    \ \n         (length numbers))))\n", "  (define (mad x mean)\n    (if (= x mean)\n\
    \        0\n        (abs (- x mean))))\n  (define (mean xs mean)\n    (if (null?\
    \ xs)\n        mean\n        (let ((x (car xs))\n              (sum (car xs))\n\
    \              (sumsquares (cdr xs))\n              (mean (/ (+ sum sumsquares\
    \ 1) (length xs))))\n          (mean xs (/ (+ sum sumsquares 1) (length xs))))))\n\
    \  (define (sum xs sum)\n    (if (null? xs)\n        sum\n        (let ((x (car\
    \ xs))\n              (sum (car xs))\n              (sumsquares (cdr xs))\n  \
    \            (sum (+ (sum sum) x))\n              (sumsquares (* (cdr xs) x)))\n\
    \          (sum xs (+ sum sum)))))\n  (define (sumsquares xs sumsquares)\n   \
    \ (if (null? xs)\n        sumsquares\n        (let ((x (car xs))\n           \
    \   (sum (car xs))\n              (sumsquares (cdr xs))\n              (sum (+\
    \ (sum sum) x))\n              (sumsquares (+ (* sumsquares xs) x)))\n       \
    \   (sumsquares xs (+ sumsquares sum)))))\n  (let ((x (car numbers))\n       \
    \ (sum (car numbers))\n        (sumsquares (cdr numbers))\n        (mean (/ (+\
    \ sum sumsquares 1) (length numbers))))\n    (mad x (mean numbers))))\n", "  (apply\
    \ / (map (lambda (x) (car x)) numbers)\n          (map (lambda (x) (car x)) numbers)))",
  "  (if (empty? numbers)\n      '()\n      (+ (abs (- <???> (map <???> (rest numbers))))\n\
    \         (mean_absolute_deviation (rest numbers)))))\n", "  (let ((mean 0.0))\n\
    \    (for-each (lambda (n) (set! mean + n)) numbers)\n    (/ (mean number) 2))))\n",
  "  (/ (apply + (map absolute numbers)) (apply + (map length numbers))))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
