name: HumanEval_11_string_xor
language: rkt
prompt: "#lang racket\n\n;; Input are two strings a and b consisting only of 1s and\
  \ 0s.\n;; Perform binary XOR on these inputs and return result also as a string.\n\
  ;; >>> (string_xor \"010\" \"110\")\n;; \"100\"\n(define (string_xor a b)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate string_xor))\n\
  \    (check-equal? (candidate \"111000\" \"101010\") \"010010\")\n    (check-equal?\
  \ (candidate \"1\" \"1\") \"0\")\n    (check-equal? (candidate \"0101\" \"0000\"\
  ) \"0101\")\n))\n\n(test-humaneval)"
completions: ["  (loop for i from 0 to (length a)-1 and j from 0 to (length b)-1 collect\
    \ (cond (= i j) (a (mod i 2)) (b (mod j 2)) else  (cond ((char=? (char-code (char\
    \ i a)) (char-code (char j b)))) (cond ((char=? (char-code (char i b)) (char-code\
    \ (char j a)))) '??))))\n", "  (define (string_xor_helper a b)\n    (string-append\n\
    \      (substring a 0 (string->length a 2) #f)\n      (substring b 0 (string->length\
    \ b 2) #f)\n      ))\n  (string-append\n    (string-append a (substring b 0 (string->length\
    \ b 2) #f))\n    (string-append (substring a 0 (string->length a 2) #f) (substring\
    \ b 0 (string->length b 2) #f))\n    ))\n", "  (cond [(string=? a \"0\") (string=?\
    \ b \"0\") (string=? a \"1\") (string=? b \"1\") (string-cat \"0\" (string-cat\
    \ \"1\" a) (string-cat \"1\" b))] [(string=? a \"0\") (string=? b \"1\") (string-cat\
    \ \"0\" (string-cat \"0\" a) (string-cat \"1\" b))] [(string=? a \"1\") (string=?\
    \ b \"0\") (string-cat \"1\" a (string-cat \"1\" b))] [(string=? a \"1\") (string=?\
    \ b \"1\") (string-cat \"1\" a (string-cat \"1\" b)) (string-cat \"0\" a) (string-cat\
    \ \"0\" b)]\n    [else (string-cat \"0\" a (string-cat \"1\" b))]))\n", "  (define\
    \ x (length a))\n  (define y (length b))\n  (define acc (string-append \"0\" \"\
    \"))\n  (define (loop x y)\n    (cond [(> x y) acc]\n          [(= (substring\
    \ a x 1) (substring b y 1)) (string-append (substring acc x) \"1\") (loop (+ x\
    \ 1) y)]\n          [else acc]))\n  (loop x y))\n", "  (define stringa (string-chars\
    \ a #:start 0))\n  (define stringb (string-chars b #:start 0))\n  (define result\
    \ (make-string-builder))\n  (for-each (lambda (c)\n            (when (or (char-equal\
    \ c #\\0) (char-equal c #\\1))\n              (byte-set! result (current-buffer)\
    \ result))\n            (byte-set! result (current-buffer) result))\n        \
    \    (stringa-char stringa #:start 0))\n    (stringb-char stringb #:start 0))\n\
    \  (byte-length result))\n", "  (cond [(= 0 (string-length a))\n         (string-append\
    \ \"0\"\n                        (string_xor b a)\n                        \"\
    0\")]\n        [else\n         (string-append \"1\"\n                        (string_xor\
    \ a b)\n                        \"1\")]))\n", "  (string-append (string-append\
    \ \"1\" a)\n                (string-append \"1\" b)))", "  (define (helper a b)\n\
    \    (cond\n      [(char? a) (helper a (string-ref b (string-length a)))]\n  \
    \    [(char? b) (helper b (string-ref a (string-length b)))]\n      [(= (char-code\
    \ a) (char-code b)) (string-cat a b)]\n      [else (helper a b)]))\n  (helper\
    \ a b))\n", "  (cond\n    [(or (string-length a) (string-length b)) \"\"]\n  \
    \  [(string-match #\\0 a) (substring (string b) 0 1)]\n    [(string-match #\\\
    0 b) (substring a 0 1)]\n    [else (substring a 0 1)]))\n", "  (if (null? a) (string_xor\
    \ b b) (string-append (string-char-but-not a (string-char 0 (string- (string-length\
    \ a) 1))) (string-char-but-not b (string-char 1 (string- (string-length b) 1))))))\n",
  "  (let\n      [(a (regexp-match a #\"[01]+\"))\n       (b (regexp-match b #\"[01]+\"\
    ))\n       (a-str (string->list a))\n       (b-str (string->list b))]\n    (cond\n\
    \      [(empty? a-str) '()]\n      [(empty? b-str) '()]\n      [(string=? a-str\
    \ b-str) '()]\n      [(and\n         (string-length a-str)\n         (string-length\
    \ b-str)) '()]\n      [(string=? (string-reverse a-str) (string-reverse b-str))\n\
    \       '()]\n      [(string-match a b) '()]\n      [else (string-append (substring\
    \ a 1 string-length (string-length a 2))\n                            (substring\
    \ b 1 string-length (string-length b 2)))]\n      )))\n", "  (string-append (binary-xor\
    \ a) (binary-xor b)))\n", "  (cond [(equal? a b)\n         (string-append \"0\"\
    \ \"\")]\n        [(equal? (string-ref a 0)\n                   (string-ref b\
    \ 0))\n         (string-append \"\" a)]\n        [else\n         (string-append\
    \ a (string_xor (string-ref a 1)\n                                     (string-ref\
    \ b 1)))]))\n", "  (cond [(string-length a) (string-length b)] \n        [(string-match\
    \ #(= (first %) (first b)) a)\n         #(+ 0 (string-index (first b) #(= (first\
    \ %) (first b)))\n             (string-index (second b) #(= (first %) (first b)))\n\
    \             (string-index (third b) #(= (first %) (first b)))\n            \
    \ (string-index (fourth b) #(= (first %) (first b))))]\n        [else (error \"\
    Invalid inputs\")]))\n", "  (string-append (number->string (a-b))\n          \
    \       (number->string (bitwise-xor-string a b))))\n", "  (cond [(empty? a) #f]\n\
    \        [(empty? b) #f]\n        [(char=? (char-ref a 0) (char-ref b 0)) 0]\n\
    \        [else (let ([a (substring a 1 )])\n               (let ([b (substring\
    \ b 1 )])\n                 (char=? (char-ref a 0) (char-ref b 0))\n         \
    \        (string-xor a b))))]))\n</cell>\n<code language=dyalog-kernel>", "  (apply\
    \ string-append (for ([i a])\n                          (for ([j b])\n       \
    \                    (string-append i j))))) ;#lang racket\n", "  (define (helper\
    \ a b count)\n    (cond [(= count 0) (append a 'b)]\n          [else (helper a\
    \ (string-append (string (char-ref b (+ count 1))) (string (char-ref a (- count\
    \ 1)))) (add1 count)])\n  (helper a b (string-length a)))\n", "  (string->list\
    \ (binary-xor a (string->list b))))\n</code>\n<|/ a tags=racket,racket-student-languages\
    \ |>\n<| a dscore=0 tags=racket,racket-student-languages |>\nThe way I would do\
    \ it is to reverse the strings (in place) then concatenate them together.\n<code>",
  "  (let loop ((x a) (y b))\n    (cond\n      [(string-length x) (string-append \"\
    0\" y)]\n      [else (string-append (substring x 0 (string-length x)) (loop (substring\
    \ y 0 (string-length y)) (substring x 0 (string-length x))))])))\n", "  (string-append\
    \ (string-map #(if (string=? (char->integer %) #\\0) #\\1 #\\0) a) (string-map\
    \ #(if (string=? (char->integer %) #\\0) #\\0 #\\1) b)))\n</code>\n<|/ a tags=string,scheme\
    \ |>\n<| a dscore=2 |>\n<code>", "  (if (equal? a b)\n      a\n      (string-append\
    \ (number->string (a-ref a 0)) (b-ref b 0))))\n", "  (define (string_xor_iter\
    \ a b acc r)\n    (if (eq? (string-length a) (string-length b))\n        (string-append\
    \ acc r)\n        (string_xor_iter (string-append a b) r (string-append a r) b)))\n\
    \  (string-append (string_xor_iter a b ') '0))\n</code>\nThe string_xor function\
    \ takes a string and returns another string. Here's a test case:\n<code>", " \
    \ (apply string-append (map string->number (string-range (make-string-input-stream\
    \ a) (make-string-input-stream b))))\n)\n", "  (define (string_xor-helper a b\
    \ result)\n    (cond\n      [(or (string-empty? a)\n           (string-empty?\
    \ b))\n       result]\n      [(or (char=? (first a) 0)\n           (char=? (first\
    \ b) 0))\n       (string-xor-helper (rest a)\n                         (rest b)\n\
    \                         result)]\n      [else\n       (string-xor-helper (rest\
    \ a)\n                         (first b)\n                         (string-append\
    \ result (first a)))]\n      ))\n  (string-xor-helper a string b \"\"))\n", " \
    \ (cond [(null? a) (string-append \"0\" b)\n         [(null? b) (string-append\
    \ \"0\" a)\n          (char= (first a) (first b))]\n         [else (string-append\
    \ (string_xor (rest a) (rest b)) (first b))]]))\n", "  (cond\n    [(string-length\
    \ a) \"\"]\n    [(string-length b) \"\"]\n    [(string-ref a 0) (string-ref b\
    \ 0)]\n    [else (binary-xor (string-ref a 0) (string-ref b 0))]\n    ))\n", " \
    \ (let ([a (string-chars a #:radix 2) b (string-chars b #:radix 2)])\n    (string-set!\
    \ r\n                 (string-set! result '())\n                 (string-set!\
    \ result (append (string_xor r a) #:c #:b)\n                                 \
    \        (string_xor r b) #:c #:a)))))\n", "  (let ([a (string->list a)\n    \
    \    (b (string->list b)])\n    (if (and (= (length a) 2)\n             (= (length\
    \ b) 2))\n        (string-append (list-ref a 0) (list-ref b 1))\n        (string-append\
    \ (list-ref a 1) (list-ref b 0)))\n    (if (and (= (length a) 1)\n           \
    \  (= (length b) 1))\n        (string-append (list-ref a 0)\n                \
    \       (list-ref b 0))\n        (string-append (list-ref a 1)\n             \
    \          (list-ref b 1)))))\n", "  (if (string-length a) (string-append (string_xor\
    \ b (string-ref a 0 0)) (string-ref a 1 0)))\n  \"0\")\n</code>\n<|/ a tags=string,algorithm,racket\
    \ |>\n<| c |>\n`string_xor \"00100\" \"00110\"` returns `\"11110\"` instead of\
    \ `\"100\"`.\n<|/ c |>\n<| c |>\nThe question asks for the XOR of the two strings\
    \ and it returns the xor of the two strings. This is what it does. You can check\
    \ it out here: https://ideone.com/I5rY9l\n<|/ c |>\n<| c |>\nIt doesn\u2019t matter\
    \ that the question is about XORing the strings, it matters that the question\
    \ asks for a function: `string_xor :: String -> String -> String`. What you\u2019\
    ve written is `string_xor :: String -> String -> String` and it doesn\u2019t do\
    \ what the question asked.\n<|/ c |>\n<| c |>\nThanks for your comment, I'm really\
    \ sorry for misunderstanding the question. I've updated the answer, please take\
    \ a look at this link: https://ideone.com/I5rY9l\n<|/ c |>\n<| a dscore=2 |>\n\
    The answers above are fine and elegant, but they don't work for inputs of more\
    \ than two characters. Here's a simple way to do it (this solution does not modify\
    \ the input strings).\n<code>\n#lang racket\n", "  (cond [(equal? a b)  \"0\"\
    ]\n        [(equal? (string-ref a 0) (string-ref b 0)) \"0\"]\n        [else \
    \               (string-append \"1\" (string-ref a 0) (string-ref b 0))]))\n",
  "  (display a)\n  (newline))", "  (string->list (bitwise-xor bitwise-xor string-length\
    \ a) b))\n", "  (string ((string->number a) xor (string->number b))))\n", "  (let\
    \ ([xor (string-map string-append (map (lambda (c) (append (list c) '0) (string->list\
    \ a)))\n                                 (map (lambda (c) (append (list c) '1)\
    \ (string->list b)))])\n        (len-xor (string->length xor))\n        (left-pad\
    \ (car xor) (+ 4 (length (car (cdr xor))))\n        (right-pad (car (cdr xor))\
    \ (+ 4 (length (car (cdr (car xor)))))\n        (left-pad-zero (length xor) (+\
    \ 4 (string->length (string-append \"0\" (substring x 1 len-xor)))\n        (right-pad-zero\
    \ (length xor) (+ 4 (string->length (string-append \"0\" (substring xor))))]\n\
    \    (string-append left-pad right-pad left-pad-zero right-pad-zero\n      (substring\
    \ xor 0 len-xor) (substring xor len-xor))))\n", "  (cond [(equal? a b) \"\"]\n\
    \        [(and (equal? (string-ref a 0) 0) (equal? (string-ref b 0) 0)) (cons\
    \ 0 (string-xor a b))]\n        [(and (equal? (string-ref a 0) 0) (equal? (string-ref\
    \ b 0) 1)) (cons 1 (string-xor a b))]\n        [(and (equal? (string-ref a 1)\
    \ 0) (equal? (string-ref b 0) 0)) (cons 1 (string-xor a b))]\n        [(and (equal?\
    \ (string-ref a 1) 0) (equal? (string-ref b 0) 1)) (cons 0 (string-xor a b))]\n\
    \        [(and (equal? (string-ref a 1) 1) (equal? (string-ref b 0) 0)) (cons\
    \ 1 (string-xor a b))]\n        [(and (equal? (string-ref a 1) 1) (equal? (string-ref\
    \ b 0) 1)) (cons 0 (string-xor a b))]\n        [else (string-append a (string_xor\
    \ a b)]))) ; All other values are strings of length 1\n", "  (cond\n    ((or (=\
    \ (string-length a) (string-length b)) (string-length a) (string-length b)) #f)\n\
    \    ((string-length a) (string-length b))\n    ((string-length b) (string-length\
    \ a)) \n    (else \n      (string-append\n       (string-ref a (- 0 0))\n    \
    \   (string-ref b (- 0 0))\n       (string-ref a (- 0 (string-length a)))\n  \
    \     (string-ref b (- 0 (string-length b)))\n       (string-xor (string-ref a\
    \ 0)\n                   (string-ref b 0)))))\n", "  (define (helper xor aa bb)\n\
    \    (string->number\n     (if (= aa 0)\n         (string->number (string->string\
    \ xor))\n         (helper xor (string->number aa) (string->number bb))))\n  (helper\
    \ 'a 'b))\n", "  (if (null? a) (null? b) \"Error\")\n  ((append (string_xor (string_head\
    \ a) (string_head b)) (string_rest a))\n   (string_xor (string_rest a) (string_rest\
    \ b))))\n", "  (string->list\n   (string->number\n    (string->list a b #:base\
    \ 2))))\n", "  (define (parse s)\n    (cond [(zero? s)\n           #t]\n     \
    \     [(equal? s '0)\n           #t]\n          [(equal? s '1)\n           (parse\
    \ (substring s 1 1))]\n          [else\n           (parse (substring s 1 (substring-length\
    \ (substring s 0 -1))))]))\n  (parse a) (parse b) (convert (parse a) (parse b)))\n",
  "  (cond [(string-length a) (string-length b)]\n        [(string-length a) (string-length\
    \ b)]\n        [(equal? (char-ref a 0) (char-ref b 0))\n         (string-append\
    \ (char-ref a 1) (char-ref b 1))]\n        [(equal? (char-ref a 0) (char-ref b\
    \ 1))\n         (string-append (char-ref a 0) (char-ref b 0))]\n        [else\n\
    \         (string-append (char-ref a 1) (char-ref b 0))]))\n", "  (string->list\
    \ a (string-length a) (string-length b)))\n", "  (let loop (([x 0] [y 0])\n  \
    \           ([s \"\"] [s2 \"\"]))\n    (if (= x 0) s\n        (loop (+ x 1) (if\
    \ (= y 0) [s2 (char-code a)] [s2 (char-code b)])))))\n", "  (define (helper acc\
    \ i)\n    (cond [(char=? (substring b i) '1) (string-append acc (substring a i))]\n\
    \          [else helper (substring acc i) (i + 1)]))\n  (helper \"\" 0))\n", " \
    \ (display (string-cat a b)\n        (fold-left (lambda (a b)\n              \
    \      (if (string-equal? a \"0\") (concat \"0\" b) (concat a b)))\n         \
    \       \"0\" a\n                b\n                )\n              (display\
    \ #\\Space)\n              (newline)))\n", "  (define result \"\")\n  (define\
    \ count 0)\n  (define max 32)\n  (define min 0)\n\n  (define (loop n r)\n    (cond\n\
    \      [(= n 0)\n       (cons r (reverse result))]\n      [(= (bit-and n min)\
    \ 0)\n       (loop (bit-shift-left n 1) r)]\n      [(= (bit-and n max) 0)\n  \
    \     (loop (bit-shift-left n 1) (cons r \"\"))]\n      [(= (bit-and n max) (bit-shift-left\
    \ n 1))\n       (loop (bit-shift-left n 1) (cons r (char->string n)))]\n     \
    \ [else\n       (loop (bit-shift-left n 1) (cons (char->string n) (char->string\
    \ r))\n             (+ count (bit-length n)))]\n      )\n    )\n  )\n\n  (loop\
    \ a \"\")\n  (loop b \"\")\n\n  (reverse result)\n)\n", "  (string-append (binary\
    \ xor a) b))\n", "  (let ((a (string-ref a 0)) (b (string-ref b 0)))\n    (cond\n\
    \      [(not (char=? a #\\0)) \"\"]\n      [(not (char=? b #\\0)) \"\"]\n    \
    \  [else (number->string (char-code (binary-xor (char->integer a) (char->integer\
    \ b)))) ]\n      )))", "  (if (string-empty? a) (string-empty? b) \"0\") ;; \"\
    0\" is returned if either string is empty.\n  (let ([ch (char-ref (substring b\
    \ 0 (string-length a)) 0)])\n    (if (string-empty? a) (string-append \"0\" ch)\
    \ ; \"0\" is appended to end of string if string A is empty.\n    (if (string-empty?\
    \ b) (string-append ch \"0\") ; \"0\" is appended to end of string if string B\
    \ is empty.\n      (string-append (if (char-equal? ch \"0\") \"1\" \"0\") (string_xor\
    \ a b))))))\n", "  (string->int->string (string-xor a) 2))\n", "  (apply string-append\
    \ (map (lambda (x)\n                              (if (char=? x #\\0)\n      \
    \                            \"0\"\n                                  (if (char=?\
    \ x #\\1)\n                                      \"1\"\n                     \
    \                 (if (char=? x #\\2)\n                                      \
    \    \"1\"\n                                          (if (char=? x #\\3)\n  \
    \                                            \"0\"\n                         \
    \                     (if (char=? x #\\4)\n                                  \
    \                (if (char=? x #\\5)\n                                       \
    \               \"1\"\n                                                      (if\
    \ (char=? x #\\6)\n                                                         \"\
    0\"\n                                                         (if (char=? x #\\\
    7)\n                                                              \"1\"\n    \
    \                                                          \"0\"\n           \
    \                                                 ))))))))\n                 \
    \  (string->list a) (string->list b))))\n", "  (apply string-append (string-append\
    \ (string a) (string b)) \n          (map string-append (string-append \"1\" (string\
    \ a)) \n                          (string-append \"0\" (string b))))\n  ", " \
    \ (for/fold ([a-result \"\"] [b-result \"\"])\n            [(a-result \"\") ((string-ref\
    \ b (string-ref a 0) (length a 1))) 0]\n            [(b-result \"\") ((string-ref\
    \ b (string-ref a 1) (length b 1))) 0])\n  (a-result b-result))\n</code>\n<|/\
    \ a tags=scheme,racket,recursion,bitwise-operators,bit-manipulation |>\n<| c |>\n\
    I like this solution, just one correction: the third argument of `string-ref`\
    \ should be one less than the second argument, otherwise you get the wrong output.\n\
    <|/ c |>\n<| a dscore=2 tags=scheme,racket,recursion,bitwise-operators,bit-manipulation\
    \ |>\nThis is a bit late to the party, but I thought I'd share my solution in\
    \ case it helps someone else. I'm writing my own version of this function in Racket\
    \ as I'm more familiar with it.\n<code>\n#lang racket\n", "  (cond\n    [(equal?\
    \ a b) \"0\"]\n    [(equal? (string-ref a 0) (string-ref b 0)) \"0\"]\n    [else\
    \ (string-append (string_xor (string-ref a 1) (string-ref b 1))\n            \
    \            (string-append \"1\" (string-ref b 0)))]))\n", "  (let loop ([a a]\
    \ [b b] [result \"\"])\n    (if (or (= a 0) (= b 0))\n        result\n       \
    \ (loop (string-append (reverse-bits a 1) (reverse-bits b 1))\n              \
    \ (string-append (reverse-bits a 0) (reverse-bits b 0))\n               (string-append\
    \ result (reverse-bits a 1) (reverse-bits b 1))))))\n", "  (let loop ((n 0))\n\
    \    (cond\n      [(null? b) \"\"]\n      [(null? a) (loop (add1 n))\n       \
    \  \"\"]\n      [(char-not (char-at b n)) (loop (add1 n))\n         \"\"]\n  \
    \    [else (loop (add1 n))\n         (string-append (number->string (n) (sub1\
    \ n 2)) \n                       a)]))) \n", "  (map string->number\n       (lambda\
    \ (x)\n         (x `xor` string->number b)))))", "  (define (f i j)\n    (string-ref\
    \ (substring a i j)\n                   (bit-and (string->number (string-ref b\
    \ i j)) 1)))\n  (let loop ((i 0)\n             (j 0))\n    (cond\n      [(and\
    \ (<= i 7) (<= j 7)) (string-ref a i j)\n       (set! i (+ i 1) (+ j 1))]\n  \
    \    [(char-equal a '0') (set! j (+ j 1))]\n      [(char-equal a '1') (loop (+\
    \ i 1) (+ j 1))]\n      [else (loop (+ i 1) j)]))\n  (f 0 0))\n", "  (cond [(string=?\
    \ a \"010\") (string=? b \"110\")\n         (string-append \"100\" a)\n      \
    \   (string-append \"100\" b)]\n        [(string=? a \"110\") (string=? b \"010\"\
    )\n         (string-append \"101\" a)\n         (string-append \"101\" b)]\n \
    \       [else (string-append \"010\" a)\n               (string-append \"010\"\
    \ b)]))\n", "  (let ([c (string-length a)\n        d (string-length b)])\n   \
    \ (string-builder-new d)))\n   ;; TODO: optimize by only building output string\
    \ when all input chars are valid\n", "  (define (helper a b c)\n    (string->number\
    \ c))\n\n  (let ([ca (helper a a 0)]\n        [cb (helper b (string->number a)\
    \ 0)]\n        [cr (string->number b)])\n    (string->number cr)))\n</code>\n\
    This function is an industrial strength function and can be used with any string.\
    \ No error checking is done on it's input.\n<|/ a tags=string,racket,scheme dscore=1\
    \ |>\n<| a |>\nYou can implement this in Racket using Racket's built-in string/xor\
    \ procedure:\n<code>\n#lang racket\n", "  (define i 0)\n  (define j 0)\n  (define\
    \ res \"\")\n  (define (next val)\n    (when (not (= val 0))\n      (set! i (+\
    \ i 1))\n      (set! j (+ j 1))\n      (cond\n        ((= i j) (set! res val (string-to-int\
    \ res)))\n        ((= i 2) (set! res 0 (string-to-int res)))\n        (else (set!\
    \ res 0 (string-to-int res))))))\n  (next (apply string-append (map string-to-int\
    \ a) (map string-to-int b)))\n  res)\n</code>\n<|/ a dscore=2 |>\n<| c |>\nHi,\
    \ I posted my answer based on your suggestion, but it doesn't work because I can't\
    \ increment the index inside the loop...\n<|/ c |>\n<| c |>\nThank you so much\
    \ for your time and effort :)\n<|/ c |>\n<| a dscore=0 tags=racket,scheme |>\n\
    Ok, I think I've figured it out with the help of the comments.\n<code>", "  (string-append\
    \ (first a) (second a) (first b) (second b)))\n", "  (string-append (~a '~b) \"\
    \"))\n", "  (string->list a)\n  (string->list b)\n  (apply (lambda (x) (apply\
    \ (lambda (y) (apply (lambda (z) (apply (lambda (xs) (apply (lambda (ys) (apply\
    \ (lambda (zs) (apply (lambda (x y) (apply (lambda (x z) (apply (lambda (x ys)\
    \ (apply (lambda (x zs) (apply (lambda (y) \n                                \
    \                          (concat x y z))\n                                 \
    \                         (concat x ys zs))))\n                              \
    \                            (apply (lambda (x) (apply (lambda (y) (apply (lambda\
    \ (z) (apply (lambda (xs) (apply (lambda (ys) (apply (lambda (zs) (apply (lambda\
    \ (x y) (apply (lambda (x z) (apply (lambda (x ys) (apply (lambda (x zs) (apply\
    \ (lambda (y) (concat x y z))))\n                                            \
    \              (apply (lambda (x) (apply (lambda (y) (apply (lambda (z) (apply\
    \ (lambda (xs) (apply (lambda (ys) (apply (lambda (zs) (apply (lambda (x y) (apply\
    \ (lambda (x z) (apply (lambda (x ys) (apply (lambda (x zs) (apply (lambda (y)\
    \ (concat x y z))))))))))))))))))))\n                                        \
    \                  (apply (lambda (x) (apply (lambda (y) (apply (lambda (z) (apply\
    \ (lambda (xs) (apply (lambda (ys) (apply (lambda (zs) (apply (lambda (x y) (apply\
    \ (lambda (x z) (apply (lambda (x ys) (apply (lambda (x zs) (apply (lambda (y)\
    \ (concat x y z))))))))))))))))))))))))\n                                    \
    \                      (apply (lambda (x) (apply (lambda (y) (apply (lambda (z)\
    \ (apply (lambda (xs) (apply (lambda (ys) (apply (lambda (zs) (apply (lambda (x\
    \ y) (apply (lambda (x z) (apply (lambda (x ys) (apply (lambda (x zs) (apply (lambda\
    \ (y) (concat x y z))))))))))))))))))))))))))\n                              \
    \                            (apply (lambda (x) (apply (lambda (y) (apply (lambda\
    \ (z) (apply (lambda (xs) (apply (lambda (ys) (apply (lambda (zs) (apply (lambda\
    \ (x y) (apply (lambda (x z) (apply (lambda (x ys) (apply (lambda (x zs) (apply\
    \ (lambda (y) (concat x y z))))))))))))))))))))))))))))))))\n                \
    \                                          (apply (", "  (define (make-string\
    \ n)\n    (string-append '(#b0 #b1 #b2 #b3 #b4 #b5 #b6 #b7 #b8 #b9 #ba #bb #bc\
    \ #bd #be #bf #c0 #c1 #c2 #c3 #c4 #c5 #c6 #c7 #c8 #c9 #ca #cb #cc #cd #ce #cf\
    \ #d0 #d1 #d2 #d3 #d4 #d5 #d6 #d7 #d8 #d9 #da #db #dc #dd #de #df #e0 #e1 #e2\
    \ #e3 #e4 #e5 #e6 #e7 #e8 #e9 #ea #eb #ec #ed #ee #ef #f0 #f1 #f2 #f3 #f4 #f5\
    \ #f6 #f7 #f8 #f9 #fa #fb #fc #fd #fe #ff #g0 #g1 #g2 #g3 #g4 #g5 #g6 #g7 #g8\
    \ #g9 #ga #gb #gc #gd #ge #gf #h0 #h1 #h2 #h3 #h4 #h5 #h6 #h7 #h8 #h9 #ha #hb\
    \ #hc #hd #he #hf #i0 #i1 #i2 #i3 #i4 #i5 #i6 #i7 #i8 #i9 #ia #ib #ic #id #ie\
    \ #if #ih #ii #ij #il #im #in #io #iq #ir #is #it #iu #iv #iw #ix #iy #iz #$0\
    \ #$ #0 #1 #2 #3 #4 #5 #6 #7 #8 #9 #a #b #c #d #e #f #g #h #i #j #k #l #m #n #o\
    \ #p #q #r #s #t #u #v #w #x #y #z #@) \n    (lambda ()\n      (define (make-char\
    \ c)\n        (string-append (make-string n) c))\n      (define (", "  (string-append\n\
    \   (string-append (string a) (string-append \"0\" (string-append b (string \"\
    \")))) (string \"\")))\n", "  (define (helper a b)\n    (define (helper-state\
    \ state)\n      (set! state (append (string-append state a) (string-append state\
    \ b))))\n    (let loop ((state '()))\n      (if (< (length a) (length b))\n  \
    \        state\n          (loop (helper-state state)))))\n  (helper a b))\n",
  "  (define bit-set\n    (lambda (n x)\n      (if (zero? n) x\n          (bit-set\
    \ (quotient n 2) (bit-not x)))))\n  (string-append\n   (bit-set (length a) (bit-set\
    \ (length b) '0))\n   (map bit-set\n        (map bit-not\n             (lambda\
    \ (x)\n              (define (bit-not x)\n                (cond ((= x 0) '0)\n\
    \                      ((= x 1) '1)\n                      (else 'x))))\n    \
    \     a\n         b)\n   ))\n", "  (let ((xor (string->list (string-ref a 0) (string-ref\
    \ b 0))))\n    (string-append (list-ref xor-len 0) (list-ref xor-len 1))))\n",
  "  (define (helper a b)\n    (if (char=? a '0) \n        (b (helper a (string->list\
    \ b)))\n        (a (b (helper a (string->list b))))))\n  (helper a (string->list\
    \ b)))\n", "  (string->int-vector xor (string->int-vector a (string->int-vector\
    \ b)))) ;; #lang racket\n", "  (define (helper a b acc)\n    (cond\n      [(empty?\
    \ a) acc]\n      [(empty? b) (helper b '() acc)]\n      [else (helper (cdr a)\
    \ (cdr b) (cons (car a) acc))]))\n  (helper a '() (string (car b))))\n", "  (string-append\
    \ (string-append (modulo-binary a #b) \"0\"\n                               (modulo-binary\
    \ b #b)) \"0\"))\n</code>\nThe helper function modulo-binary simply returns the\
    \ modulo of two numbers a and b by treating them as binary numbers, i.e. dividing\
    \ by a number 2\u207F raised to the power of its place:\n<code>", "  (let loop\
    \ ((a a) (p 0) (b b))\n    (if (not (equal a b))\n        (loop a (+ (char p a)\
    \ (char p b)) b)\n        (loop a (+ p 1) b )))\n  ;; If not equal, return empty\
    \ string\n  \"\")\n</code>\n<|/ a |>\n<| c |>\nThanks a lot! It was really helpful.\n\
    <|/ c |>\n<| c |>\nIf you're new to Scheme, you may want to check out [R6RS](http://r6rs.org/).\n\
    <|/ c |>\n<| c |>\nIf you're on Linux/Mac OSX, you can also check out [PLT Scheme](http://pltdoc.org/).\
    \ It's a Scheme implementation that's free.\n<|/ c |>\n<| a |>\nHere is another\
    \ solution using only characters and recursion:\n<code>", "  (let loop ((x a)\n\
    \             (y b))\n    (cond\n      [(equal? (string-length x) (string-length\
    \ y)) x]\n      [(equal? (string-length x) 1) y] \n      [else (loop (append (make-string\
    \ (+ x 1) (substring y 0 x)) x) (rest y))])))\n", "  (string->list (string->symbol\
    \ (symbol->string a) (string->symbol (symbol->string b))))\n  ", "  (let ([a (string-append\
    \ a b)] [b (string-append b a)]) ; Strings are concatenated with append\n    (cond\n\
    \      [(empty? a) b]\n      [(empty? b) a]\n      [else\n       (string-append\
    \ (substring a 0 (string->number a))\n                      (substring b (string->number\
    \ b)))]))\n", "  (string->list\n   (binary-string-add\n    (binary-string-xor\
    \ (string->bits a #b110) (string->bits b #b110))\n    (string->bits a #b101))))\n",
  "  (string-append (string-reverse a) b))\n", "  (string->number\n   (list->string\n\
    \    (string-compare a (string->string b) \n     (lambda (x y) (+ x y))))))\n",
  "  (loop for c across [a-c b-c]\n        collect (if (= c 0)\n                 \
    \  a\n                   (string-append (if (= c 1)\n                        \
    \             \"1\"\n                                     \"0\")\n           \
    \                       \"0\"\n                                  (if (= (modulo\
    \ (char->integer c) 2) 1)\n                                     \"0\"\n      \
    \                               \"1\")))))\n", "  (string->list (string->symbol\
    \ a) (string->symbol b)))\n</code>\n<|/ a tags=racket,binary,scheme |>\n<| a |>\n\
    I wrote this a while ago as a homework assignment and it works very well and I'm\
    \ fairly proud of it! Just a couple notes:\n\nThe base cases are special cases\
    \ of the binary case. In other words, if you want a base case of a binary operation\
    \ that doesn't have anything to do with its operands, simply call that function\
    \ directly. No need to write a separate function for each case. \nThe base cases\
    \ are just cases that will return a binary string when given one argument, and\
    \ a blank string when given two. Since we're doing string manipulation, the base\
    \ cases for binary strings that don't have any zero digits will actually return\
    \ the empty string, so we'll have to use that special case instead of returning\
    \ #f for no input. \nThe binary case actually needs to go through two steps. First\
    \ it does binary multiplication then it does binary addition. \n\nThis way, the\
    \ function will always return a value of a binary string, even if it's empty and\
    \ thus needs a special case for when it's given zero arguments. \nFinally, the\
    \ function has three arguments. \n\nFirst is the variable that contains the binary\
    \ string. \nSecond is the base case, or the operation that you want to do on that\
    \ string. \nThird is the operation that you want to perform on the first argument.\
    \ \n\nIt will recursively call the binary case and return the result of the second\
    \ argument if it is a binary string, or the result of that binary operation applied\
    \ to the first argument if it is a non-binary string. \n<code>", "  (define a\
    \ (binary-xor a-char b-char))\n  (define b (binary-xor b-char a-char))\n  (define\
    \ result (binary-str a-str b-str))\n  (define a-str (string-to-int a))\n  (define\
    \ b-str (string-to-int b))\n  (define a-char (char-to-int (substring a 0 1)))\n\
    \  (define b-char (char-to-int (substring b 0 1)))\n  result\n  )\n", "  (cond\
    \ [(= a b) \"\"]\n        [(string-length a) (string-length b)]\n        [(string-charAt\
    \ a 0)\n         (string-xor b \n                   (substring a (string-xor 1\
    \ 2))\n                   (substring b (string-xor 1 2)))]\n        [else (cons\
    \ 0 (string_xor (substring a 1)\n                                   (substring\
    \ b 1)))]))", "  (if (null? a)\n      '()\n      (string-append (first a)\n  \
    \                   (string-append (first b)\n                               \
    \   (string_xor (rest a) (rest b)))))\n  ;; End of definition of string_xor\n\
    \  (if (= (length a 0) 0)\n      b\n      (string-append (first a)\n         \
    \            (string-append (first b)\n                                  (string_xor\
    \ (rest a) (rest b)))))\n  ;; End of definition of string_xor\n  (if (= (length\
    \ b 0) 0)\n      a\n      (string-append (first b)\n                     (string-append\
    \ (first a)\n                                  (string_xor (rest b) (rest a)))))\n\
    \  ;; End of definition of string_xor\n  (string-append (first a)\n          \
    \    (string_xor (rest a) (rest b)))\n  ;; End of definition of string_xor\n \
    \ (string-append (first b)\n              (string_xor (rest b) (rest a)))\n  ;;\
    \ End of definition of string_xor\n  (if (= (length a 0) 0)\n      b\n      (string-append\
    \ (first b)\n                     (string-append (first a)\n                 \
    \                 (string_xor (rest b) (rest a)))))\n  ;; End of definition of\
    \ string_xor\n  (if (= (length b 0) 0)\n      a\n      (string-append (first a)\n\
    \                     (string-append (first b)\n                             \
    \     (string_xor (rest a) (rest b)))))\n  ;; End of definition of string_xor\n\
    \  (if (= (length a 0) 0)\n      b\n      (string-append (first b)\n         \
    \            (string-append (first a)\n                                  (string_xor\
    \ (rest b) (rest a)))))\n  ;; End of definition of string_xor\n  (if (= (length\
    \ b 0) 0)\n      a\n      (string-append (first a)\n                     (string-append\
    \ (first b)\n                                  (string_xor (rest a) (rest b)))))\n\
    \  ;; End of definition of string_xor\n  (if (= (length a 0) 0)\n      b\n   \
    \   (string-append (first b)\n                     (string-append (first a)\n\
    \                                  (string_xor (rest b) (rest a)))))\n  ;; End\
    \ of definition of string_xor\n  (if (= (length b 0) 0)\n      a\n      (string-append\
    \ (first a)\n                     (string-append (first b)\n                 \
    \                 (string_xor (rest a) (rest b)))))\n  ;; End of definition of\
    \ string_xor\n  (if (= (length a 0) 0)\n      b\n      (string-", "  (define (string_xor_helper\
    \ a b result)\n    (if (not (equal? a b))\n        result\n        (string-append\
    \ result (code->string (a-code a) (code->string (b-code b))))))\n  (string_xor_helper\
    \ (code->string a-code a) (code->string b-code b) \"\"))\n</code>\nSome examples:\n\
    <code>\n#lang racket\n", "  (let* ((x (length a b)) (y 0) (result '()))\n    (for\
    \ ((i (min x y))) ; for loop from shortest to longest\n      (if (equal? a (b\
    \ i x))\n          (set! y (substring b i x))\n          (set! result (append\
    \ result (char #\\0))))))\n  result)\n", "  (define (string-convert a b)\n   \
    \ (string-append \n     (string-append (string #\\0) \n     (string-append (string\
    \ #\\1) \n     (string #\\0))))\n  (define (string-unconvert s d)\n    (string-append\
    \ \n     (string-append (string #\\0) \n     (string #\\1))))\n  (define (string\
    \ a b)\n    (string-convert a b)\n    (string-unconvert a b)\n    (string-unconvert\
    \ b a)\n    (string-unconvert (string #\\0) (string #\\1)))\n  (string a b))\n\
    </code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\nIn Racket, if you have a binary\
    \ string you can use the string->list function to convert the string to a list.\
    \ Then you can use the list function to do list operations on the list. For example,\
    \ to get the sum of all the numbers in the list, you can use the fold function:\n\
    <code>", "  (string->list a))\n  ", "  (let ((len-a (string-length a)) ; length\
    \ of a\n        (len-b (string-length b)) ; length of b\n        (result (make-string\
    \ len-a #\\0 )))  ; result string\n    (for/or (i (in-range 0 (add1 len-a))) (j\
    \ (in-range 0 (add1 len-b)))\n      (when (= (modulo i len-a) (modulo j len-b))\n\
    \        (set! result (string-set! result i j)\n               (string! result\
    \ j string-xor a))))\n    result))\n", "  (cond [(null? a) b]\n        [(null?\
    \ b) a]\n        [else (string_xor (string-ref a 0) (string-ref b 1))]))\n", " \
    \ (let ([s (string->lists a #:when (string=? \"0\" #:or))\n        z (string->list\
    \ b #:when (string=? \"0\" #:or))\n        result '()])\n    (do ([i 0 (+ i 1)]\
    \ ([s s] ([z z] [(eq? #:or [s z])])\n                           ([z z] [(eq? #:or\
    \ [z s])]))\n        ((< i 0)) result\n        [else\n          (set! result (cond\
    \ [(equal? [s z]) (set! result (append! result '0))\n                        \
    \       (eq? [z s]) (set! result (append! result '1))]\n                     \
    \               [else (concat [result (substring #:or (substring #:and [s z]))\
    \ '0])]))]))\n", "  (string a #\\0 b #\\0))\n", "  (string->char (bit-and (string->number\
    \ a) (string->number b))))\n", "  (string-append (string-append a b)\n       \
    \          (string-append (b a) (string 0)) \n                 (string-append\
    \ \"0\"\n                                 (string-append (b a) (string 1)) #:default\
    \ #f)\n                 #:default #f))\n", "  (apply string-append\n         (map\
    \ number->char\n               (apply binary-xor (string->list a) (string->list\
    \ b))))) ;; apply converts to list\n</cell>\n<cell>", "  (string-append (binary\
    \ xor a b) \"\"))\n", "  (string-append (string-replicate (length a) \"0\") (string-append\
    \ (string b) (string a) (string-append (string (remainder a 2) \"1\")) (string\
    \ (remainder b 2) \"1\")) ))\n", "  (apply string-append (string-append a\n  \
    \                               (string-append \"0\"\n                       \
    \                        (string->number (string-ref b 2)))\n                \
    \                 b)))\n", "  (let ((x (string-length a)) (y (string-length b)))\n\
    \    (if (or (= x y) (= y 0))\n        (char->integer (char->integer (string-ref\
    \ a 0) (string-ref b 0))) \n        (biginteger-xor-string a b))))\n", "  (cond\n\
    \    ((string-length a) (string-length b))\n    (else (string-concat (string-xor\
    \ a (substring b 0 (string-length b)))\n                          (string-xor\
    \ b (substring a 0 (string-length a)))))\n  )\n)\n", "  (define (helper-for-char\
    \ c)\n    (let loop ((result '()) (next '()))\n      (if (char=? c 0)\n      \
    \    (if (string=? next \"0\")\n              (loop (cons result next) '())\n\
    \              (loop (cons next result) '())\n              (loop (cons result\
    \ next) (cons c next)))\n          (loop (cons result next) (cons c next))))))\n\
    \  (let loop ((len (string-length a)) (acc '()))\n    (if (< len 0)\n        (reverse\
    \ acc)\n        (let ((c (char-ref a 0)))\n          (if (string=? b c)\n    \
    \          (loop (- len 1) (cons acc '()))\n              (loop (- len 1) (cons\
    \ c (cons acc '())))))))\n</code>\n<|/ a tags=algorithm,racket,binary,string,xor\
    \ |>\n<| a dscore=0 |>\nI guess it can be done in a better way but i think it\
    \ solves your problem in a different way. \n<code>\n#lang racket\n", "  (if (null?\
    \ a) (null? b) (if (char? b) (char ((~a XOR (~b AND 255))) (string-append \"0\"\
    \ \"\")) (if (char? a) (char ((~a XOR (~a AND 255))) (string-append \"0\" \"\"\
    )) (if (char? a) '1 '0)(if (char? b) '1 '0))))\n</code>\n<|/ a |>\n<| c |>\nI\
    \ do not understand the `(~a XOR (~b AND 255))` part. `~a` works on strings, but\
    \ `~b` does not work. Can you explain why you used this part of the code?\n<|/\
    \ c |>\n<| c |>\nI used it because you wanted a bitwise operation on chars.\n\
    <|/ c |>\n<| c |>\nAnd yes, I do know that `(~a XOR (~b AND 255))` is a trick\
    \ to get a bitwise operation in racket. As I said, it is my way of doing it.\n\
    <|/ c |>\n<| c |>\nThanks a lot for the explanation. I didn't know that `~` existed\
    \ in racket. I will definitely try this out and see how it goes.\n<|/ c |>\n<|\
    \ a dscore=0 |>\nYou cannot use ~ on numbers, only on strings. To work with bitwise\
    \ operators only on chars, you can use this:\n<code>", "  (let ([xor (string-append\
    \ (string-reverse a) (string-reverse b))])\n    (string-append (substring xor\
    \ 0 (string-length xor)) \"0\")))\n", "  (string->list (bitwise-xor a (string->list\
    \ b))))\n", "  (let [xor string-append string-length]\n    (loop\n       [(count\
    \ a (string->list a))\n        (count b (string->list b))]\n      (if (>= count\
    \ 0)\n          (if (= count 1)\n              (if (char= (string-ref a 0) (string-ref\
    \ b 0))\n                  (string-append xor a)\n                  (string-append\
    \ xor b))\n              (string-append xor (string-append a (string-append b\
    \ (string-append (string->list '0') (string->list '0')))))))))\n", "  (if (null?\
    \ a) b\n      (string-append (string-append a \" \" (b subst (string-length a)\
    \ 0 b)) \" \"))\n)", "  (define (helper lst c l)\n    (cond [(null? l)\n     \
    \      (string-append (string-append c \"0\") \"0\")\n           (helper (cdr\
    \ lst) (car lst) (cdr l))]\n          [(char=? (car l) a)\n           (helper\
    \ (cdr lst) (car lst) (cdr l))]\n          [else\n           (helper (cdr lst)\
    \ c l)]))\n  (helper (reverse b) a (reverse a)))\n</code>\n<|/ a |>\n<| a |>\n\
    In Haskell this would be a very simple function to implement:\n<code>\nstringxor\
    \ :: String -> String -> String\nstringxor x y = take (length x) x (++ (map head\
    \ (tail y)) ++ y)\n</code>\n<|/ a dscore=2 tags=string-length,string,racket,scheme\
    \ |>\n<| a dscore=2 |>\nThis should be pretty easy in Racket:\n<code>", "  (string->int*\
    \ (string-ref a 0) (string-ref b 0)))\n", "  (apply string-append (map string-append\
    \ (map string-append (map string-append a '0') '0) (map string-append b '0') '0)))\n\
    </code>\n<|/ a tags=racket,string,binary,scheme |>\n<| a dscore=3 |>\nI like Eli's\
    \ answer, but since I already have a solution, here it is\n<code>\n#lang racket",
  "  (let [xor-str (string-append (apply string-append a) b)]\n    (string-append\
    \ (binary-xor #x00 #x01) #x10))\n  (string-append xor-str '0)))\n", "  (string-append\
    \ (string-map '(lambda (x y)\n                              (if (string=? x y)\n\
    \                                  \"0\"\n                                  \"\
    1\"))\n                       (string-map '(lambda (x y)\n                   \
    \           (if (string=? x y)\n                                  x\n        \
    \                          y)))\n                       (string-map '(lambda (x\
    \ y)\n                              (if (string=? x y)\n                     \
    \             y\n                                  x)))\n                    \
    \   (string-map '(lambda (x y)\n                              (if (string=? x\
    \ y)\n                                  x\n                                  \"\
    0\")))\n                       (string-map '(lambda (x y)\n                  \
    \            (if (string=? x y)\n                                  y\n       \
    \                           \"0\"))\n                       (string-map '(lambda\
    \ (x y)\n                              (if (string=? x y)\n                  \
    \                x\n                                  \"1\"))\n              \
    \         (string-map '(lambda (x y)\n                              (if (string=?\
    \ x y)\n                                  y\n                                \
    \  \"1\"))\n                       (string-map '(lambda (x y)\n              \
    \                (if (string=? x y)\n                                  x\n   \
    \                               \"0\"))\n                       (string-map '(lambda\
    \ (x y)\n                              (if (string=? x y)\n                  \
    \                y\n                                  \"0\"))\n              \
    \         (string-map '(lambda (x y)\n                              (if (string=?\
    \ x y)\n                                  x\n                                \
    \  \"1\"))\n                       (string-map '(lambda (x y)\n              \
    \                (if (string=? x y)\n                                  y\n   \
    \                               \"1\"))\n                       (string-map '(lambda\
    \ (x y)\n                              (if (string=? x y)\n                  \
    \                x\n                                  \"0\"))\n              \
    \         (string-map '(lambda (x y)\n                              (if (string=?\
    \ x y)\n                                  y\n                                \
    \  \"0\"))\n                       (string-map '(lambda (x y)\n              \
    \                (if (string=? x y)\n                                  x\n   \
    \                               \"1\"))\n                       (string-map '(lambda\
    \ (x y)\n                              (if (string=? x y)\n                  \
    \                y\n                                  \"1\"))\n              \
    \         (string-map '(lambda (x y)\n                              (if (string=?\
    \ x y)\n                                  x\n                                \
    \  \"0\"))\n                       (string-map '(lambda (x y)\n              \
    \                (if (string=? x y)\n                                  y\n   \
    \                               \"0\"))\n                       (string-map '(lambda\
    \ (x y)\n                              (if (string=? x y)\n                  \
    \                x\n                                  \"1\"))\n              \
    \         (string-map '(lambda (x y)\n                              (if (string=?\
    \ x y)\n                                  y\n                                \
    \  \"", "  (if (empty? a) (empty? b) empty?)\n  (append (first a) (apply xor (rest\
    \ a)) (apply xor (rest b))))\n", "  (let ([xor (string-append (substring a \"\
    0\" 2) (substring b \"0\" 2))])\n    (string-append xor (substring a \"2\" 1))\n\
    \    (string-append xor (substring b \"2\" 1))))\n", "  (loop for x from 0 to\
    \ (length a) collect ((mod (regexp-match \"1\" a x 0) 2) (mod (regexp-match \"\
    1\" b x 0) 2))))\n</code>\n<|/ a |>\n<| c |>\nNice. Didn't realize that regexp-match\
    \ would return a string for matching. That's pretty cool.\n<|/ c |>\n<| c |>\n\
    `regexp-match` can return a list, so you can write `(length a) (length b)` instead\
    \ of `(regexp-match \"1\" a x 0) (regexp-match \"1\" b x 0)`.\n<|/ c |>\n<| c\
    \ |>\nThanks. Though I would consider that to be a little less readable than just\
    \ `length`.\n<|/ c |>\n<| a tags=racket,scheme,lisp,clojure |>\nThis could be\
    \ a little more concise, but I think it illustrates the general idea.\n<code>\n\
    #lang racket\n", "  (let ((a (regexp-opt a #\"1\" *)))\n    (let ((b (regexp-opt\
    \ b #\"0\" *)))\n      (if (or (not a) (not b))\n          \"\"\n          (append\
    \ (convert-to-binary (binary-xor a (string->bits b))) \"\")))))\n", "  (cond [(or\
    \ (string-length a) (string-length b)) #]\n        [(string-char-index a 0) (string-char-index\
    \ b 0)]\n        [else (substring (string_xor a (substring b 0 1)) (string-char-index\
    \ b (string-char-index b 0) + 1))]))\n", "  (if (string? a)\n      (string-append\
    \ (string-string-reverse a))\n      (error \"a must be of string type\")))", " \
    \ (let ((bits-xor (string->list (string->bits a #:pad-with #b)))\n        (bits-and-xor\
    \ (string->list (string->bits b)))\n        (bits-and-and-xor (string->list (string->bits\
    \ b #:pad-with #b)))\n        (bits-or-xor (string->list (string->bits b)))\n\
    \        (bits-xor-xor (string->list (string->bits b #:pad-with #b))))\n    (let\
    \ loop ()\n      (cond\n        [(null? bits-xor) bits-and-and-xor]\n        [(string-match\
    \ (string->char (car bits-xor)) #\\0)\n         (cond\n           [(string-match\
    \ (string->char (car bits-and-xor)) #\\0)\n            (loop ())]\n          \
    \ [(string-match (string->char (car bits-and-and-xor)) #\\0)\n            (loop\
    \ ())]\n           [(string-match (string->char (car bits-or-xor)) #\\0)\n   \
    \         (loop (cons (car bits-xor) bits-xor))]\n           [else\n         \
    \   (loop ())])]\n        [else\n         (loop (cons (car bits-xor) bits-xor))])))\n",
  "  (define (parse c)\n    (if (= c '(')\n        ()\n        (parse\n         (if\
    \ (/= c '0') (cons c ()) (parse (sub1 c)))\n         (if (/= c '1') (cons (sub1\
    \ c) ()) (parse (sub1 c))))))\n  (parse a)\n  (parse b))\n</code>", "  (let ([x\
    \ (string->list a)\n        y (string->list b)])\n    (string->list #\\0)\n  \
    \  (append (map string->char\n                (cond [(empty? x) (list->string\
    \ y)]\n                      [(empty? y) (list->string x)]\n                 \
    \     [(char->integer (first x))\n                       (char->integer (first\
    \ y))]\n                      [(char->integer (first y))\n                   \
    \    (char->integer (first x))]\n                      [else\n               \
    \        (cond [(char->boolean (first x))\n                            (string->char\
    \ (string-append (first x) \"1\"))]\n                             [(char->boolean\
    \ (first y))\n                            (string->char (string-append (first\
    \ y) \"1\"))]\n                             [else\n                          \
    \  (string->char (string-append (first x) \"1\")\n                           \
    \               (string->char (string-append (first y) \"1\")))]\n           \
    \                  ))]))))\n", "  (let ((x (string-length a)) (y) (z) (string))\n\
    \    (if (< x y)\n        (recur (+ x 1) y z)\n        (loop\n           for i\
    \ below x do (set! i (string->number (aref a i)) (- i 1))\n           for j below\
    \ y do (set! j (string->number (aref b j)) (- j 1))\n           for k below x\
    \ do (set! k (+ k (string->number a)) (- k 1))\n           for l below y do (set!\
    \ l (+ l (string->number b)) (- l 1))\n           for m below x do (set! m (+\
    \ m (string->number a)) (- m 1))\n           for n below y do (set! n (+ n (string->number\
    \ b)) (- n 1))\n           (string-set! z m n (string->number (string-ref z m\
    \ n)))\n           (string-set! z m n (+ (string->number a) (string-ref z m n))\n\
    \                       a (string->number b)\n                       (string->number\
    \ z)\n           (string-set! z m n (+ (string->number b) (string-ref z m n))\n\
    \                       b (string->number a)\n                       (string->number\
    \ z)))))\n", "  (if (string-length a) (string-append (string_xor a (substring\
    \ b 0 (string-length a))))\n      b))\n", "  (define char-list-length\n    (lambda\
    \ (c)\n      (if (char=? c #\\0)\n          0\n          (+ 1 (char-list-length\
    \ (cdr c))))))\n  (define char-list-first\n    (lambda (c)\n      (if (char=?\
    \ c #\\0)\n          #\\0\n          (car c))))\n  (define char-list-rest\n  \
    \  (lambda (c)\n      (if (char=? c #\\0)\n          #\\0\n          (cons (car\
    \ c)\n                (lambda (cc)\n                  (char-list-rest (cdr cc)))))))\n\
    \  (define char-list\n    (lambda (cc)\n      (if (null? cc)\n          #\\0\n\
    \          (char-list-rest cc))))\n  (define char-list-lengths\n    (lambda (c)\n\
    \      (if (char=? c #\\0)\n          #\\0\n          (+ (char-list-length (char-list-first\
    \ c)) \n             (char-list-length (char-list-rest c)))))\n  (define first-char-count\n\
    \    (lambda (cc)\n      (char-list-lengths (char-list cc))))\n  (define count\n\
    \    (lambda (cc)\n      (if (null? cc)\n          0\n          (+ 1 (first-char-count\
    \ cc)))))\n  (define first\n    (lambda (cc)\n      (char-list (char-list-rest\
    \ cc))))\n  (define rest\n    (lambda (cc)\n      (char-list (char-list-first\
    \ cc)))))\n  (define result\n    (lambda (cc)\n      (let ((first-count (count\
    \ (car cc))))\n        (let ((first-char (first cc)))\n          (let ((rest (rest\
    \ cc)))\n            (string-append (if (char=? first-char #\\0)\n           \
    \                 first-char\n                            (if (or (char=? first-char\
    \ #\\0)\n                                    (null? rest))\n                 \
    \               first-char\n                                (if (< first-count\
    \ first-char-count rest)\n                                    (substring first-char\
    \ first-count)\n                                    (substring first-char first-char-count)\n\
    \                                   (substring rest first-count)))))\n       \
    \             (rest cc)))))))\n  (let ([char-list (char-list a)])\n    (lambda\
    \ (cc)\n      (let ((char-count (count char-list)))\n        (string-append (if\
    \ (char=? char-count #\\0)\n                        char-list\n              \
    \          (substring char-list char-count))\n                    cc))))))\n",
  "  (if (and (string-empty? a) (string-empty? b))\n      '()\n      (append (string_xor\
    \ a (substring b 0 (string-length a)))\n                (string-append \"1\" (substring\
    \ a 0 (string-length a))))))", "  (let ([len (string-length a)])\n    (if (= len\
    \ 0)\n        '()\n        (string-append (substring a 0 len) (substring b 0 len)))))\n\
    #lang racket\n", "  (let ([len (string-length a)\n\tsa (subseq a\n\t\t\t0 (if\
    \ (string-length a)\n\t\t\t\t    (string-length a)\n\t\t\t\t    0)))\n\tsb (subseq\
    \ b\n\t\t\t0 (if (string-length b)\n\t\t\t\t    (string-length b)\n\t\t\t\t  \
    \  0)))\n\tresult '()])\n  (cond\n    [(< len 0)\n     (string-append result '())]\n\
    \    [(< sa sb)\n     (string-append result '())]\n    [else\n     (string-append\
    \ result (subseq a 0 sb))\n     (string-append result (subseq b sa len))]))\n",
  "  (define (helper xor a)\n    (string-append (if (string=? a #\\0)\n          \
    \               (concat \"0\" xor)\n                       xor) a))\n  (helper\
    \ xor b)\n  (helper xor \"0\"))\n", "  (string-append\n   (string-append \"0\"\
    \ a)\n   (string-append \"1\" b)))\n", "  (let ([d (string->list (string-reverse\
    \ a))])\n    (let ([f (string->list (string-reverse b))])\n      (apply str (concat\n\
    \                   (map #(if (equal? #0 a) b (bitwise-not (bitwise-xor #0 #1)))\
    \ #d)\n                   (map #(if (equal? #0 b) a (bitwise-not (bitwise-xor\
    \ #0 #1))) #f))))))\n", "  (define (helper a b)\n    (cond [(empty? a) (append\
    \ b '0)]\n          [(empty? b) (append a '0)]\n          [(char= (first a) (first\
    \ b)) (helper (rest a) (rest b))] \n          [(char= (first b) (first a)) (helper\
    \ (rest b) (rest a))] \n          [else (cond [(char= (first a) (first b)) (helper\
    \ (rest a) (rest b))] \n                        [else (helper (rest a) (rest b))]\n\
    \                      ])\n          ])\n  (helper a b))\n", "  (let [x (string-map\
    \ a #(if-let ([b (string-map b (lambda (x) (if (equal? x 0) #t #f)))]) (list #f\
    \ #f))\n        y (string 0)]\n    (do-until-end (your-do-loop (lambda (x)\n \
    \                               (when (or (null x) (null? x)) y)\n           \
    \                     (when (equal? (string-ref x 0) (string-ref x 1))\n     \
    \                             (set! y (append y (string-ref x 2)))\n         \
    \                         (set! x (string-map x (lambda (x) (if (equal? (string-ref\
    \ x 0) #t) #f #t)))\n                                  (set! x (string-map x (lambda\
    \ (x) (if (equal? (string-ref x 1) #t) #f #t)))\n                            \
    \      (set! y (cond ((or (equal? (string-ref x 0) #t) (equal? (string-ref x 1)\
    \ #t)) (append y (string-ref x 2)))\n                                        \
    \        ((equal? (string-ref x 0) #f) (cond ((null? x) (set! y (append y \"0\"\
    )) (set! x (string-map x (lambda (x) (if (equal? (string-ref x 1) #t) #f #t)))\n\
    \                                                                          ((string-ref\
    \ x 1) (cond ((null? x) (set! y (append y \"0\")) (set! x (string-map x (lambda\
    \ (x) (if (equal? (string-ref x 1) #t) #f #t)))\n                            \
    \                                                  ((string-ref x 0) (append y\
    \ \"1\")))))\n                                                ((equal? (string-ref\
    \ x 1) #t) (cond ((null? x) (set! y (append y \"1\")) (set! x (string-map x (lambda\
    \ (x) (if (equal? (string-ref x 0) #t) #f #t)))\n                            \
    \                                              ((string-ref x 0) (cond ((null?\
    \ x) (set! y (append y \"0\")) (set! x (string-map x (lambda (x) (if (equal? (string-ref\
    \ x 0) #t) #f #t)))\n                                                        \
    \                      ((string-ref x 1) (cond ((null? x) (set! y (append y \"\
    0\")) (set! x (string-map x (lambda (x) (if (equal? (string-ref x 0) #t) #f #t)))\n\
    \                                                                            \
    \          ((string-ref x 0) (append y \"1\"))))))))\n                       \
    \                         ((equal? (string-ref x 1) #f) (cond ((null? x) (set!\
    \ y (append y \"1\")) (set! x (string-map x (", "  (let ([a-list (string-split\
    \ a #\\0))\n        (b-list (string-split b #\\0))]\n    (apply string-join (map\
    \ string-append a-list b-list) #\\0)\n    (apply string-join (map string-append\
    \ a-list a-list) #\\0)\n    (apply string-join (map string-append a-list a-list)\
    \ #\\0)\n    (apply string-join (map string-append a-list a-list) #\\0)\n    (apply\
    \ string-join (map string-append a-list a-list) #\\0)\n    (apply string-join\
    \ (map string-append a-list a-list) #\\0)\n    (apply string-join (map string-append\
    \ a-list a-list) #\\0)\n    (apply string-join (map string-append a-list a-list)\
    \ #\\0)\n    (apply string-join (map string-append a-list a-list) #\\0)\n    (apply\
    \ string-join (map string-append a-list a-list) #\\0)\n    (apply string-join\
    \ (map string-append a-list a-list) #\\0)\n    (apply string-join (map string-append\
    \ a-list a-list) #\\0)\n    (apply string-join (map string-append a-list a-list)\
    \ #\\0)\n    (apply string-join (map string-append a-list a-list) #\\0)\n    (apply\
    \ string-join (map string-append a-list a-list) #\\0)\n    (apply string-join\
    \ (map string-append a-list a-list) #\\0)\n    (apply string-join (map string-append\
    \ a-list a-list) #\\0)\n    (apply string-join (map string-append a-list a-list)\
    \ #\\0)\n    (apply string-join (map string-append a-list a-list) #\\0)\n    (apply\
    \ string-join (map string-append a-list a-list) #\\0)\n    (apply string-join\
    \ (map string-append a-list a-list) #\\0)\n    (apply string-join (map string-append\
    \ a-list a-list) #\\0)\n    (apply string-join (map string-append a-list a-list)\
    \ #\\0)\n    (apply string-join (map string-append a-list a-list) #\\0)\n    (apply\
    \ string-join (map string-append a-list a-list) #\\0)\n    (apply string-join\
    \ (map string-append a-list a-list) #\\0)\n    (apply string-join (map string-append\
    \ a-list a-list) #\\0)\n    (apply string-join (map string-append a-list a-list)\
    \ #\\0)\n    (apply string-join (map string-append a-list a-list) #\\0)\n    (apply\
    \ string-join (map string-append a-list a-list) #\\0)\n    (apply string-join\
    \ (map string-append ", "  (if (null? a)\n      b\n      (cond [(string-char-b?\
    \ a 0) (cons a b)]\n            [else (string-xor (string-char a '0) (string-char-b\
    \ a 0))]))\n", "  (map string->char (map bit-xor a (bit-list b))))\n", "  (let\
    \ loop ((a a) (a b) (res '()))\n    (if (string-length a) = 0\n        (string-append\
    \ (substring b 0 1) res)\n        (if (string-length a)\n            (loop (substring\
    \ a 0 1) (substring b 0 1)\n                  (string-append (substring a 0 1)\
    \ res))\n            (loop (substring a 0 1) (substring b 0 1) res)))))\n", " \
    \ (if (string-prefix? b \"0\")\n      (string-append a b)\n      b))\n", "  (string\
    \ xor (string-ref a 0)\n            (string-ref b 0)))\n", "  (define x (string-length\
    \ a))\n  (define y (string-length b))\n  (define z (+ x y))\n  (let ((s (string->list\
    \ a)))\n    (if (= z 0)\n        (string->list b)\n        (let ((s (string->list\
    \ b)))\n          (cond [(< z y) s]\n                [else (cons 0 (string-xor\
    \ (substring s 0 (- x y)) (substring s y (- y x))))])))\n  x)\n", "  (if (or (=\
    \ (length a) 0) (= (length b) 0))\n      (error 'string-xor \"Strings must have\
    \ at least one character\" a)\n      (reverse (cons (char->int (apply (lambda\
    \ (x) (logand x 1)) a)) (cons (char->int (apply (lambda (x) (logand x 1)) b))\
    \ (string_xor (substring a 0 1) (substring b 0 1))))))\n", "  (string-append (convert\
    \ a)\n                 (convert b)\n                 (convert (bit-xor (convert\
    \ a) (convert b))))\n  )\n", "  (apply string-append (map string-append\n    \
    \                         (map string-append a b)\n                          \
    \   (repeat \"0\"))))\n", "  (let ((a (string->list (string->string a)) b (string->list\
    \ (string->string b)))\n        (accum a))\n    (let loop ((n 0) (acc '()))\n\
    \      (cond ((< n 100) (cons (string-ref a n) acc))\n            ((= n 0) (cons\
    \ (string-ref b n) acc))\n            (else (loop (+ n 1) (cons (string-ref b\
    \ n) (cons (string-ref a n) acc)))))))\n", "  (apply string-append\n         (map\
    \ (\u03BB (x)\n                (if (char= x #\\0)\n                  (string x)\n\
    \                  (string \"0\" x))))\n         (map string->char\n         \
    \      (map (\u03BB (x)\n                      (if (char= x #\\0)\n          \
    \               (string x)\n                         (string \"1\" x))))\n   \
    \            (string-split b \"0\")))\n</code>\nIt can be useful to convert from\
    \ binary to decimal by applying the inverse function to the result.\n<code>",
  "  (let ((r (string-append a b)))\n    (cond\n      [(null? r) \"\"]\n      [(string=?\
    \ \"101\" r) r]\n      [(string=? \"010\" r) (string-append \"101\" r)]\n    \
    \  [(string=? \"110\" r) (string-append \"010\" r)]\n      [else \"\"])))\n",
  "  (define x (string-length a 2))\n  (define y (string-length b 2))\n  (define c\
    \ (+ x y))\n  (define s (string-empty (substring a 0 x) \"0\" (substring b 0 y)))\n\
    \  (if (equal? c s)\n      (reverse \"0\" (cdr s))\n      (cons (if (equal? (char-at\
    \ (substring a 0 x) c) \"0\")\n                \"1\"\n                (if (equal?\
    \ (char-at (substring b 0 y) c) \"0\")\n                    \"0\"\n          \
    \          \"1\"))\n            (string-xor (substring a x c) (substring b y c))))))\n",
  "  (let ([result (make-array (length a + 1) #byte)])\n    (unless (< a (length a\
    \ + 1))\n      (error 'string-xor-invalid-length a)\n      (unless (< b (length\
    \ b + 1))\n        (error 'string-xor-invalid-length b)\n        (setf (aref result\
    \ (- a 1)) (bref result (- b 1)))))\n    (setf (aref result a) (bref result b))\n\
    \    (string->number (string (make-array (+ a b) #byte (append '0 '1))) result)))\n",
  "  (string->list a) (string-append (string->list (string-bitwise-xor a b) \"\" \"\
    \" 0 0) \"\"))\n", "  (cond [(empty? a) (empty? b) empty]\n        [(= (length\
    \ a) (length b)) (string-append a b)]\n        [else (string-append (string_xor\
    \ (rest a) (first b)) (first b))]))", "  (cond [(empty? a) (empty? b) (empty?\
    \ (string-append a b))] \n        [(equal? (string-ref a 0) (string-ref b 0))\n\
    \         (string-append a b)] \n        [else\n         (string-append (cons\
    \ (string-ref a 0) (substring b (+ (string-length a) 1)))\n                  \
    \    (substring b (+ (string-length a) (string-length b))))]))\n", "  (let ([n\
    \ (length a)]) (cond\n      ((= n 0) \"0\")\n      ((= n 1) (substring a 0 1))\n\
    \      ((= n (+ n 1)) (reverse (substring a 1 (- n 1))))\n      (else (substring\
    \ a (- n 1) n))))\n)\n", "  (if (string=? a b)\n      (append (substring a 0 2)\n\
    \              (substring b 0 2))\n      'x))\n", "  (xor (string->bits a 8) (string->bits\
    \ b 8)))\n</code>\n<|/ a tags=scheme,racket |>\n<| a dscore=0 |>\nTry this one:\n\
    <code>\n#lang racket\n", "  (if (null? b) a\n      (string-append (list-ref (string-map\
    \ string-append a '(\"0\" '(\"1\"))\n                                    (list-ref\
    \ (list-ref b 1) 2)) \n                       (string-append (list-ref (list-ref\
    \ b 1) 2)\n                                       (list-ref (list-ref a 1) 2)))))",
  "  (define x (string->list a))\n  (define y (string->list b))\n  (define xs (list->string\
    \ x))\n  (define ys (list->string y))\n  (define result (list->string\n      \
    \             (map (lambda (s) (string->list (string-append s s)))\n         \
    \               (append xs ys))))\n  (display result)\n  (newline)\n  (display\
    \ (if (equal? x y) \"XOR\" result))\n  (newline)\n  (newline)\n  (display (string->list\
    \ result))\n  (newline)\n  (newline)\n  (display (string->list result))\n  (newline)\n\
    \  (newline)\n  (newline))\n</cell>\n<code language=racket-language>", "  (string-append\
    \ (string-reverse a) (string-reverse b)))\n", "  (define (string_xor a-b &key\
    \ (start 0) (stop null))\n    (cond [(null? a-b) '()]\n          [(null? (cdr\
    \ a-b))\n           (string-append (car a-b) (cdr a-b))\n           (string-append\
    \ (car a-b) (car a-b))\n           (string-append (cdr a-b) (cdr a-b))\n     \
    \      (string-append (cdr a-b) '())]\n          [(< start (length a-b))\n   \
    \        (string-append (car a-b) (cdr a-b))\n           (string-append (cdr a-b)\
    \ '())]\n          [(< stop (length a-b))\n           (string-append (cdr a-b)\
    \ '())]\n          [else\n           (string-append (cdr a-b) (string-append (car\
    \ a-b) (string-append (cdr a-b) (list start))))]))\n  (let loop ((a-b (string-reverse\
    \ a)) (b (string-reverse b)))\n    (if (null? a-b)\n        '()\n        (string-append\
    \ (string-append (string-append '()\n                                        \
    \             (string-append (car a-b) (string-append (cdr a-b) (list 0)))) (string-append\
    \ (cdr a-b) (list 1)))\n                    (string-append (string-append '()\
    \ (string-append (cdr a-b) (list 0))) (string-append '() (string-append (cdr a-b)\
    \ (list 1))))\n                    (loop a-b (string-xor b b))))))\n", "  (string-append\
    \ (string-append a b) \"0\"))\n", "  (string-append (string-append a b) (substring\
    \ a (string-length a) b)))\n", "  (let ([x '()])\n    (for [c a]\n      (cond\
    \ [(char=? c '0) (set! x (cons x c))]\n            [else (set! x (cons c (string-xor\
    \ x (string-length b))))])))\n  )\n", "  (define base (base-digit a))\n  (define\
    \ bval (base-digit b))\n  (define acc (make-string 2))\n  (for/or ([i base]\n\
    \           [acc empty-string])\n    (string-set! acc i (string-xor acc bval))\n\
    \    acc))\n", "  (let ((r (make-string (length b) (read-string))))\n    (set!\
    \ r (string-append r (read-string))) (set! r (string-append r (read-string)))\n\
    \    (string-reverse r) (set! r (string-reverse r)) (set! r (string-reverse r))\n\
    \    (string-set! r (string-index r a 0) (byte-value b))\n    (string-set! r (string-index\
    \ r 0 1) (byte-value a))\n    (string-set! r (string-index r 0 2) (byte-value\
    \ a))\n    (string-set! r (string-index r 0 3) (byte-value b))\n    (string-set!\
    \ r (string-index r 0 4) (byte-value a))\n    (string-set! r (string-index r 0\
    \ 5) (byte-value b))\n    (string-set! r (string-index r 0 6) (byte-value a))\n\
    \    (string-set! r (string-index r 0 7) (byte-value b))\n    (string-set! r (string-index\
    \ r 0 8) (byte-value a))\n    (string-set! r (string-index r 0 9) (byte-value\
    \ b))\n    (string-set! r (string-index r 0 10) (byte-value a))\n    (string-set!\
    \ r (string-index r 0 11) (byte-value b))\n    (string-set! r (string-index r\
    \ 0 12) (byte-value a))\n    (string-set! r (string-index r 0 13) (byte-value\
    \ b))\n    (string-set! r (string-index r 0 14) (byte-value a))\n    (string-set!\
    \ r (string-index r 0 15) (byte-value b))\n    (string-set! r (string-index r\
    \ 0 16) (byte-value a))\n    (string-set! r (string-index r 0 17) (byte-value\
    \ b))\n    (string-set! r (string-index r 0 18) (byte-value a))\n    (string-set!\
    \ r (string-index r 0 19) (byte-value b))\n    (string-set! r (string-index r\
    \ 0 20) (byte-value a))\n    (string-set! r (string-index r 0 21) (byte-value\
    \ b))\n    (string-set! r (string-index r 0 22) (byte-value a))\n    (string-set!\
    \ r (string-index r 0 23) (byte-value b))\n    (string-set! r (string-index r\
    \ 0 24) (byte-value a))\n    (string-set! r (string-index r 0 25) (byte-value\
    \ b))\n    (string-set! r (string-", "  (check-type a String)\n  (check-type b\
    \ String)\n  (define (string-to-array s)\n    (string-split s #\\))\n    (define\
    \ (array-to-string a) \n      (map string-append a (string-to-array \"\")))\n\
    \    (array-to-string (string-to-array a) (string-to-array b)))\n  (string-join\
    \ (string-to-array a) (string-to-array b)))\n", "  (string (string-length a) (string-length\
    \ b)))\n", "  (define (helper result i char)\n    (cond\n      [(char= char #\\\
    0)\n       (append result (string i))]\n      [(char= char #\\1)\n       (helper\
    \ (cons 0 (cdr result)) (+ i 1) (car result))]))\n  (helper a 0 (string-length\
    \ a)))\n", "  (string->symbol (string-append (string->symbol a) (string->symbol\
    \ (string-append (string->symbol b) \"0\")))))\n</code>\n<|/ a |>\n<| a |>\nIn\
    \ Racket, if you want to do something like this, you will need to use the string\
    \ module. You cannot use symbols as you cannot use strings in Scheme. The symbol\
    \ is a literal that refers to a specific instance of a string.\n<code>\n> (symbol->string+\
    \ 'a)\n\"a\"\n</code>\nIn Racket, symbols represent single letter identifiers\
    \ like the letters a-z and A-Z which are stored as ASCII codes, but the literal\
    \ 'a represents the character represented by the ASCII code 97.\nSo if you want\
    \ to do something like:\n<code>\n> (string->symbol \"a\")\na\n</code>\nyou can\
    \ use the symbol->string function as such:\n<code>\n> (symbol->string (symbol->string\
    \ 'a))\n'a\n</code>\nIf you need to perform a binary XOR, I recommend you do this:\n\
    <code>\n> (string->symbol (string-append (string->string 'a) (string->string 'b)\
    \ '0))\n</code>\n<|/ a dscore=0 tags=scheme |>\n<| c |>\nthanks i understand now.\
    \ it wasn't working because i was passing in symbols instead of strings. i fixed\
    \ it now thanks!\n<|/ c |>\n<| c |>\nGlad I could help! Since you're new here,\
    \ please don't forget to mark the answer accepted which helped most in solving\
    \ the problem. See also [How does accepting an answer work?](http://meta.stackexchange.com/questions/5234/how-does-accepting-an-answer-work)\n\
    <|/ c |>\n<| a dscore=0 |>\nIn Racket:\n<code>", "  (assert (= (string-length\
    \ a) (string-length b)))\n  (let ((xor #f)\n        (nxor #f)\n        (result\
    \ #f))\n    (loop [xor xor\n           nxor nxor\n           result result]\n\
    \      (for [i (string->list a)]\n        (if (or (= i #\\0) (= i #\\1))\n   \
    \         (begin\n              (set! xor (xor xor i))\n              (set! nxor\
    \ (nxor nxor i))\n              (set! result (if (xor #t) #t #f))\n          \
    \    (set! xor #f)\n              (set! nxor #f)\n              (set! result (if\
    \ (nxor #t) #t #f))\n              (set! nxor #f)\n              (set! xor #f)\n\
    \              (set! nxor #f))))\n      (for [i (string->list b)]\n        (if\
    \ (or (= i #\\0) (= i #\\1))\n            (begin\n              (set! xor (xor\
    \ xor i))\n              (set! nxor (nxor nxor i))\n              (set! result\
    \ (if (xor #t) #t #f))\n              (set! xor #f)\n              (set! nxor\
    \ #f)\n              (set! result (if (nxor #t) #t #f))\n              (set! nxor\
    \ #f)\n              (set! xor #f)\n              (set! nxor #f))))\n      (if\
    \ (= result #f)\n          (set! result (string xor nxor))\n          result)))\n",
  "  (append (string-append (string-reverse a) (string-reverse b))\n          (string-reverse\
    \ (string-append (string-reverse a) b)\n                          (string-reverse\
    \ b))))\n", "  (define xor #'(lambda (x) (not (= x (bit-and x 0)))))\n  (let ([a\
    \ (string-append a \"\")\n        b (string-append b \"\")])\n    (define x (string->bit\
    \ a) \n      (let ([b (string->bit b)])\n        (string->bit (bit-and x b)))))\n\
    \    (string->bit (bit-or x xor (string->bit b))))\n", "  (let ([len (string-length\
    \ a)])\n    (cond\n      [(and (eq? len 0) (= len 0)) \"\"]\n      [(< len (string-length\
    \ b)) (string-append (substring a 0 len) (substring b 0 len))\n       (string-append\
    \ (substring a len len) (substring b len len))]\n      [else (cons (substring\
    \ a 0 len) (string-append (substring b 0 len) \"\"))])))\n", "  (string-append\
    \ (string-ref a 0) (string-ref b 0)))\n", "  (let loop ((result \"\")\n      \
    \       (a a)\n             (b b))\n    (if (null? b)\n        result\n      \
    \  (loop (string-append result (integer-char (string-ref a 1))) (string-ref b\
    \ 1) (string-ref a 2)))))\n", "  (string-append (string-to-number a)\n       \
    \           (string-to-number b)\n                  #:radix 2\n              \
    \    #:non-negative #f))\n", "  (define stra (string-ref a 0))\n  (define strb\
    \ (string-ref b 0))\n  (define stranum 0)\n  (define strbnum 0)\n  (define stranumbits\
    \ (string-length a 0) 32)\n  (define strbnumbits (string-length b 0) 32)\n  (define\
    \ stranumbitsum (fold add 0 stranumbits))\n  (define strbnumbitsum (fold add 0\
    \ strbnumbits))\n  (define stranumbitsumbits (fold add 0 stranumbits))\n  (define\
    \ strbnumbitsumbits (fold add 0 strbnumbits))\n  (define stranumbitsumb (fold\
    \ add 0 stranumbits))\n  (define strbnumbitsumb (fold add 0 strbnumbits))\n  (define\
    \ stranumbitsumbb (fold add 0 stranumbits))\n  (define strbnumbitsumbb (fold add\
    \ 0 strbnumbits))\n  (define stranumbitsumbbb (fold add 0 stranumbits))\n  (define\
    \ strbnumbitsumbbb (fold add 0 strbnumbits))\n  (define stranumbitsumbbbb (fold\
    \ add 0 stranumbits))\n  (define strbnumbitsumbbbb (fold add 0 strbnumbits))\n\
    \  (define stranumbitsumbbbb (fold add 0 stranumbits))\n  (define strbnumbitsumbbbb\
    \ (fold add 0 strbnumbits))\n  (define stranumbitsumbbbbb (fold add 0 stranumbits))\n\
    \  (define strbnumbitsumbbbbb (fold add 0 strbnumbits))\n  (define stranumbitsumbbbbaab\
    \ (fold add 0 stranumbits))\n  (define strbnumbitsumbbbbaab (fold add 0 strbnumbits))\n\
    \  (define stranumbitsumbbbbaabb (fold add 0 stranumbits))\n  (define strbnumbitsumbbbbaabb\
    \ (fold add 0 strbnumbits))\n  (define stranumbitsumbbbbaabbb (fold add 0 stranumbits))\n\
    \  (define strbnumbitsumbbbbaabbb (fold add 0 strbnumbits))\n  (define stranumbitsumbbbbaabbbaaab\
    \ (fold add 0 stranumbits))\n  (define strbnumb", "  (let ((xor (string-map #\\\
    1 a) (string-map #\\1 b)))\n    (string-map (\u03BB (pair) (apply (\u03BB (char)\
    \ (char-code char)) pair))\n                 xor)))\n", "  (string->symbol (string-append\
    \ (interleave a b) \"\")))\n", "  (define (helper x y)\n    (string-append (if\
    \ (char-equal x y)\n                      x\n                      (if (char-equal\
    \ y (substring x 0 -1))\n                          (cons x y)\n              \
    \            (helper (substring x 1) (substring y 0 -1))))))\n  (helper a b))\n",
  "  (string-append\n   (string-append (first a) (first b))\n   (string-append (rest\
    \ a) (rest b))))\n</code>\n<|/ a dscore=3 |>\n<| c |>\nGreat solution! I wonder\
    \ if this is faster than the other solutions given here: https://stackoverflow.com/a/25322717/2436175\n\
    <|/ c |>\n<| c |>\nAm I correct that your first function returns a list of characters\
    \ (instead of a string) because of the `'[char]` around `string-append`?\n<|/\
    \ c |>\n<| c |>\nyeah I think you are correct, I'll edit it to reflect that\n\
    <|/ c |>\n<| c |>\nI actually just found out that `string->list` and `list->string`\
    \ can be used to do this in one step: `(define (string_xor a b)\n  (string->list\
    \ (string-append (first a) (first b))))`\n<|/ c |>\n<| c |>\nInteresting -- that\
    \ would be the most performant way of doing it. Thanks for sharing your knowledge!\n\
    <|/ c |>\n<| a tags=scheme,racket,string |>\n<code>\n#lang racket\n", "  (let\
    \ ([o (string->list a)]\n        [p (string->list b)])\n    (cond (o == p) \"\
    0\"\n          (or (null? o) (null? p)) \"0\"\n          (number? o) (number?\
    \ p)\n          (equal? (string->number o) (string->number p))\n          (number?\
    \ (string->number o)) (string->number p)\n          (or (< o (list->string o))\
    \ (< p (list->string p))) \"0\"\n          (or (> o (list->string o)) (> p (list->string\
    \ p))) \"0\"\n          (string-equal? (string->list o) (string->list p)) \"0\"\
    \n          (string-equal? (string->list o) (list->string p)) \"0\"\n        \
    \  (string-equal? (list->string o) (string->list p)) \"0\"\n          (string-equal?\
    \ (list->string o) (list->string p)) \"0\"\n          (string-equal? (string->list\
    \ o) (list->string o)) \"0\"\n          (string-equal? (list->string o) (string->list\
    \ p)) \"0\"\n          (string-equal? (list->string o) (list->string p)) \"0\"\
    \n          (string-equal? (string->list o) (list->string o)) \"0\"\n        \
    \  (string-equal? (list->string o) (string->list p)) \"0\"\n          (string-equal?\
    \ (list->string o) (list->string p)) \"0\"\n          (< o (list->string o)) (string->list\
    \ (string-append \"0\" o))\n          (< p (list->string p)) (string->list (string-append\
    \ \"0\" p))\n          (> o (list->string o)) (string->list (string-append \"\
    1\" o))\n          (> p (list->string p)) (string->list (string-append \"1\" p))\n\
    \          (string-equal? (list->string o) (string->list o)) (string->list o)\n\
    \          (string-equal? (list->string o) (list->string p)) (string->list p)\n\
    \          (string-equal? (list->string o) (list->string o)) (string->list o)\n\
    \          (string-equal? (list->string o) (list->string p)) (string->list p)\n\
    \          (string-equal? (list->string o) (list->string o)) (string->list o)\n\
    \          (string-equal? (list->string o) (list->string p)) (string->list p)\n\
    \          (> o (list->string o", "  (let* ([a-bits (string-length a)\n      \
    \   b-bits (string-length b)\n         a-char (make-char a-bits)\n         b-char\
    \ (make-char b-bits)\n         result (make-string a-bits)])\n    (setf (apply\
    \ string-append a-char (map char->integer a)) #f)\n    (setf (apply string-append\
    \ b-char (map char->integer b)) #f)\n    (setf (apply string-append result (map\
    \ char->integer a-char)) #f)\n    (setf (apply string-append result (map char->integer\
    \ b-char)) #f)\n    result))\n", "  (apply str (bit-string (butlast (string-match\
    \ a (string-match b \"111111\")) 1 2))))\n", "  (if (or (string? a) (string? b))\n\
    \      (error (string-append \"Invalid arguments \" a \" and \" b \" for string-xor\"\
    ))\n      (let ((c #t))\n        (if (and (string? a) (string? b))\n         \
    \   (loop for c across (string-split a #\\0)\n                  for xor across\
    \ (string-split b #\\0)\n                  collect (if (and (= xor #\\0) (= c\
    \ #\\0))\n                                xor\n                              \
    \  (error \"Invalid characters \" c \" in string-xor\"))\n                  finally\
    \ (return (string-join '() (map (lambda (x) (+ x #\\0)) c))))\n            (error\
    \ (string-append \"Invalid arguments \" a \" and \" b \" for string-xor\"))))))\n",
  "  (apply string-append (map (lambda (a) (string-append (if (equal? a '1) '0 '1)\
    \ a)) (string-split a #\\) (string-split b #\\))))\n", "  (let-values ((a string->symbols\
    \ a \"a\")\n              (b string->symbols b \"b\"))\n    (cond [(or (equal?\
    \ a (string->list a))\n              (equal? b (string->list b)))\n          \
    \ (string-append (symbol->string a) (symbol->string b))]\n          [else (let\
    \ ((a (symbol->string a))\n                      (b (symbol->string b)))\n   \
    \              (string-append (symbol->string a)\n                           \
    \   (string_xor a (symbol->string b)))]))))\n", "  (define (bit-and a b)\n   \
    \ (cond\n      [(and (equal? a 0) (equal? b 0)) (quote 0)]\n      [(and (equal?\
    \ a 1) (equal? b 1)) (quote 1)]\n      [else (error? (syntax-quote (list \"and\"\
    \ a b)))]))\n\n  (define (bit-or a b)\n    (cond\n      [(and (equal? a 0) (equal?\
    \ b 0)) (quote 0)]\n      [(and (equal? a 1) (equal? b 1)) (quote 1)]\n      [else\
    \ (error? (syntax-quote (list \"or\" a b)))]))\n\n  (define (bit-not a)\n    (cond\n\
    \      [(equal? a (quote 0)) (quote 1)]\n      [else (error? (syntax-quote (list\
    \ \"not\" a)))]))\n\n  (define (bit-shift a b)\n    (cond\n      [(and (integer?\
    \ a) (integer? b)) (quote 0)]\n      [(and (equal? a 0) (equal? b 0)) b]\n   \
    \   [(and (equal? a 1) (equal? b 1)) (bit-and (bit-not a) (bit-not b))]\n    \
    \  [else (error? (syntax-quote (list \"shift\" a b)))]))\n\n  (define (bit-test\
    \ a b)\n    (cond\n      [(and (integer? a) (integer? b)) (quote true)]\n    \
    \  [(and (equal? a 0) (equal? b 0)) b]\n      [(and (equal? a 1) (equal? b 1))\
    \ (bit-or (bit-and a b) 1)]\n      [else (error? (syntax-quote (list \"test\"\
    \ a b)))]))\n\n  (define (bit-count a)\n    (cond\n      [(integer? a) (quote\
    \ 0)]\n      [(equal? a (quote 0)) 0]\n      [else (bit-or (bit-not (bit-test\
    \ a a))\n                    (bit-count (bit-shift a 1))))]))\n\n  (define (bit-test\
    \ a b)\n    (cond\n      [(and (integer? a) (integer? b)) (quote true)]\n    \
    \  [(and (equal? a 0) (equal? b 0)) b]\n      [(and (equal? a 1) (equal? b 1))\
    \ (bit-and a b)]\n      [else (error? (syntax-quote (list \"test\" a b)))]))\n\
    \n  (define (bit-count a)\n    (cond\n      [(integer? a) (quote 0)]\n      [(equal?\
    \ a (quote 0)) 0]\n      [else (bit-and (", "  (let* ([str1 (string->list a)]\n\
    \         [str2 (string->list b)]\n         [str3 (make-vector (vector-length\
    \ str1) (vector-length str2)))]\n    (for-each vector-set! str3 (vector 0 (vector-length\
    \ str1))\n                  (vector-set! str1 (vector 0 (vector-length str1) (vector-length\
    \ str2))))\n    (for-each vector-set! str3 (vector 0 (vector-length str1) (vector-length\
    \ str2) (vector-length str1)))\n    (for-each vector-set! str3 (vector 0 (vector-length\
    \ str1) (vector-length str2) (vector-length str2) (vector-length str1)))\n   \
    \ (string-append (str3) (str2))))\n", "  (let loop ((n 0)\n             (s \"\"\
    )\n             (a a))\n    (if (string? a)\n        (loop (+ n 1)\n         \
    \      (string-append s (string-to-string n))\n               (string-to-string\
    \ b))\n        (loop (+ n 1)\n               (string-append s (string-to-string\
    \ n))\n               (string-to-string b)))))", "  (apply string-append (map\
    \ string-append (map string->list a)\n                                   (map\
    \ string->list b))))\n", "  (cond\n    [(empty? a) (empty? b) (empty? a)]\n  \
    \  [(empty? b) (empty? a) \"\"]\n    [(equal? (first a) (first b))\n     (string-xor\
    \ (rest a) (rest b))\n     (string-xor (first a) (first b))]\n    [else (append\
    \ (string_xor (first a) (rest a))\n                 (string_xor (rest a) (first\
    \ b)))]))\n", "  (let* ((xor (string-map '(a 'b) '(a 'b) '(a 'b) '(a 'b) '(a 'b)\
    \ '(a 'b) '(a 'b) '(a 'b) '(a 'b) '(a 'b) '(a 'b) '(a 'b) '(a 'b) '(a 'b) '(a\
    \ 'b) '(a 'b) '(a 'b) '(a 'b) '(a 'b) '(a 'b) '(a 'b) '(a 'b) '(a 'b) '(a 'b)\
    \ '(a 'b) '(a 'b) '(a 'b) '(a 'b) '(a 'b) '(a 'b) '(a 'b) '(a 'b) '(a 'b) '(a\
    \ 'b) '(a 'b) '(a 'b) '(a 'b) '(a 'b) '(a 'b) '(a 'b) '(a 'b) '(a 'b) '(a 'b)\
    \ '(a 'b) '(a 'b) '(a 'b) '(a 'b) '(a 'b) '(a 'b) '(a 'b) '(a 'b) '(a 'b) '(a\
    \ 'b) '(a 'b) '(a 'b) '(a 'b) '(a 'b) '(a 'b) '(a 'b) '(a 'b) '(a 'b) '(a 'b)\
    \ '(a 'b) '(a 'b) '(a 'b) '(a 'b) '(a 'b) '(a 'b) '(a 'b) '(a 'b) '(a 'b) '(a\
    \ 'b) '(a 'b) '(a 'b) '(a 'b) '(a 'b) '(a 'b) '(a 'b) '(a 'b) '(a 'b) '(a 'b)\
    \ '(a 'b) '(a 'b) '(a 'b) '(a 'b) '(a 'b) '(a 'b) '(a 'b) '(a 'b) '(a 'b) '(a\
    \ 'b) '(a 'b) '(a 'b) '(a 'b) '(a 'b) '(a 'b) '(a 'b) '(a 'b) '(a 'b) '(a 'b)\
    \ '(a 'b) ", "  (cond [(empty? b) (empty? a)]\n        [else (string-append (first\
    \ a) (first b))\n               (string_xor (rest a) (rest b))]))\n", "  (let\
    \ [a-xor (string-map a '010 xor string-map b '110)\n        a-z (string-map a\
    \ '100 xor string-map b '001)]\n    (string->symbol (string->list a-xor) a-z)))\n",
  "  (define input (string->list a))\n  (define ouput (string->list b))\n  (define\
    \ xor (lambda (x y)\n              (if (eq? y '#\\0)\n                  x\n  \
    \                (* x y)))))\n  (define o (string-length output))\n  (for ((i\
    \ (string-length input)))\n    (string-set! output i (xor (string-ref input i)\
    \ (string-ref ouput i))))\n  (string->string output))\n", "  (let ((len (string-length\
    \ a)))\n    (string->list (binary->string (string->list (string->string a) (+\
    \ 0 (- len (string-length b))))\n                    (string->list (string->string\
    \ b) (+ 0 (- len (string-length a))))))))\n", "  (define (helper a b result)\n\
    \    (cond\n      [(or (char= a '0) (char= b '0)) (+ result 0)]\n      [(char=\
    \ a '0) (helper (string-downcase (substring b 1) result) (substring a 1) '0')]\n\
    \      [(char= b '0) (helper (substring a 1) (string-downcase (substring b 1)\
    \ result) '0)]\n      [(char= a '1') (helper (string-downcase (substring b 1)\
    \ result) (substring a 1) '1)]\n      [(char= a '1') (helper (substring a 1) (string-downcase\
    \ (substring b 1) result) '1)]\n      [else (error 'string-xor-invalid-inputs\
    \ '(a b))]))\n  (helper (string-downcase a) (string-downcase b) '0))\n", "  (let*\
    \ ([a (string->bits a)\n         b (string->bits b)]\n         [result (bit-xor\
    \ a b)]\n         [res-str (string->string result)]\n         [len (string-length\
    \ res-str)])\n    (string->bit res-str len)))\n", "  (encode-bin-xor (string-length\
    \ a) (string-length b)))\n", "  (apply string-append (map string-append (list\
    \ a b) (append (list \"0\") (list \"1\")))))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
