name: HumanEval_59_largest_prime_factor
language: rkt
prompt: "#lang racket\n\n;; Return the largest prime factor of n. Assume n > 1 and\
  \ is not a prime.\n;; >>> (largest_prime_factor 13195)\n;; 29\n;; >>> (largest_prime_factor\
  \ 2048)\n;; 2\n(define (largest_prime_factor n)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate largest_prime_factor))\n\
  \    (check-equal? (candidate 15) 5)\n    (check-equal? (candidate 27) 3)\n    (check-equal?\
  \ (candidate 63) 7)\n    (check-equal? (candidate 330) 11)\n    (check-equal? (candidate\
  \ 13195) 29)\n))\n\n(test-humaneval)"
completions: ["  (if (null? n)\n      0\n      (let ([q (quotient n 2)])\n       \
    \ (if (= q 0)\n            1\n            (if (not (prime? q))\n             \
    \   (* q largest_prime_factor (largest_prime_factor q))\n                (* q\
    \ largest_prime_factor (largest_prime_factor q)))))))\n", "  (if (not (positive?\
    \ n)) (error \"n must be positive\") (if (modulo n 2) (* 2 n) (if (modulo n 3)\
    \ (* 3 n) (* n n))))\n  (let ((prime (primes (quotient n 2)))\n        (facs (factors\
    \ n)))\n    (cond ((null? facs)\n           (if (modulo n prime) prime n)))\n\
    \    (cond ((> (length? facs) 1) (error \"n must be prime\"))\n          ((< (length?\
    \ facs) 2) prime)\n          ((= (length? facs) 3) (if (= (modulo n 3) 0) (* 3\
    \ n) prime))\n          (else (if (= (modulo n prime) 0) (* prime n) prime)))\n\
    \  )\n", "  (if (even? n)\n      (divide_fast (+ n 1) (floor n 2))\n      (divide_fast\
    \ (+ n 2) (floor n 2))))\n", "  (cond [(= n 2) 2]\n        [else (let ((factors\
    \ (list-of-primes n))\n                   (largest-prime (list-head factors))\n\
    \                   (remainder (remainder n 1)))\n              (if (> (list-length\
    \ factors) 0)\n                  (set! largest-prime (list-head factors))\n  \
    \                (set! remainder (remainder n 1)))]\n        [else (set! largest-prime\
    \ (list-head factors))\n              (set! remainder (remainder n 1))]))\n",
  "  (cond (\n         ;; Check for 1 by eliminating evens, if any\n         ;; >>>\
    \ largest_prime_factor 4\n         ;; 2\n         (= n 1)\n         (+ 1 (largest-prime-factor\
    \ n 2)))\n         ;; Check for 2 by eliminating odd numbers\n         ;; >>>\
    \ largest_prime_factor 7\n         ;; 3\n         (= n 2)\n         (+ 1 (largest-prime-factor\
    \ n 3)))\n         ;; Check for 3 by eliminating even numbers\n         ;; >>>\
    \ largest_prime_factor 9\n         ;; 3\n         (= n 3)\n         (+ 1 (largest-prime-factor\
    \ n 4)))\n         ;; Check for 4 by eliminating odd numbers\n         ;; >>>\
    \ largest_prime_factor 11\n         ;; 2\n         (= n 4)\n         (+ 1 (largest-prime-factor\
    \ n 5)))\n         ;; Check for 5 by eliminating even numbers\n         ;; >>>\
    \ largest_prime_factor 13\n         ;; 2\n         (= n 5)\n         (+ 1 (largest-prime-factor\
    \ n 6)))\n         ;; Check for 6 by eliminating even numbers\n         ;; >>>\
    \ largest_prime_factor 17\n         ;; 2\n         (= n 6)\n         (+ 1 (largest-prime-factor\
    \ n 7)))\n         ;; Check for 7 by eliminating even numbers\n         ;; >>>\
    \ largest_prime_factor 19\n         ;; 3\n         (= n 7)\n         (+ 1 (largest-prime-factor\
    \ n 8)))\n         ;; Check for 8 by eliminating odd numbers\n         ;; >>>\
    \ largest_prime_factor 23\n         ;; 5\n         (= n 8)\n         (+ 1 (largest-prime-factor\
    \ n 9)))\n         ;; Check for 9 by eliminating even numbers\n         ;; >>>\
    \ largest_prime_factor 29\n         ;; 7\n         (= n 9)\n         (+ 1 (largest-prime-factor\
    \ n 10)))\n         ;; Check for 10 by eliminating even numbers\n         ;; >>>\
    \ largest_prime_factor 31\n         ;; 9\n         (= n 10)\n         (+ 1 (largest-prime-factor\
    \ n 11)))\n         ;; Check for 11 by eliminating even numbers\n         ;; >>>\
    \ largest_prime_factor 39\n         ;; 13\n         (= n 11)\n         (+ 1 (largest-prime-factor\
    \ n 12)))\n         ;; Check for 12 by eliminating even numbers\n         ;",
  "  (cond ((= n 1) 1)\n        ((= n 2) 2)\n        ((prime? (modulo n 2))\n    \
    \     (modulo n 2))\n        (else\n         (largest_prime_factor (/ n 2)))))\n",
  "  (cond [(= n 1)\n         1]\n        [else\n         (let ((primes (make-primes\
    \ (ceiling sqrt n))))\n           (cond [(< n (length primes))\n             \
    \     (largest_prime_factor (- n primes))]\n                 [else\n         \
    \         (let ((largest (car primes))\n                        (candidates (cdr\
    \ primes)))\n                    (if (zero? largest)\n                       \
    \ (largest)\n                        (let ((largest (* largest candidates)))\n\
    \                          (set! candidates (cdr candidates))\n              \
    \            (set-prime (list largest) (car candidates))\n                   \
    \       (set-prime (cdr candidates) largest)\n                          (if (=\
    \ candidates 1)\n                              largest\n                     \
    \         (set! candidates (cdr candidates))\n                              (set-prime\
    \ (list largest) (car candidates))\n                              (set-prime (cdr\
    \ candidates) largest)\n                              (largest_prime_factor n))])])]))\n",
  "  (cond [(= n 1) n]\n        [(= n 2) 1]\n        [(= (sqrt n) 1)\n         (if\
    \ (prime? n) (* 2 (largest_prime_factor (/ n 2))) n)]\n        [else\n       \
    \  (if (prime? n) (* 2 (largest_prime_factor (/ n 2))) (/ n 2))]))\n", "  (if\
    \ (= n 1) 1\n      (let* ((factors (prime-factors n))\n             (largest (car\
    \ factors))\n             (largest-factor (largest_prime_factor largest)))\n \
    \       (if (> (cdr factors) largest-factor)\n            (cons largest (cdr factors))\n\
    \            factors))))\n", "  (cond ((= n 1) 1)\n        ((= n 2) 2)\n     \
    \   ((= (mod n 3) 0) (* 3 (largest_prime_factor (/ n 3))))\n        (else (largest_prime_factor\
    \ (/ n 2)))))\n", "  (cond [(= n 1)\n         1]\n        [(= (% n 2) 0)\n   \
    \      (largest_prime_factor (/ n 2))]\n        [else\n         (* n (largest_prime_factor\
    \ (/ n 2)))]))\n", "  (let ((factor (make-array (quotient n 2) #:element-type\
    \ 'int)))\n    (prime-factors n factor)\n    (list-ref factor 0)))\n", "  (if\
    \ (or (= n 2) (= n 3)) 1 \n    (max\n     (let* ([factors (prime-factors n)]\n\
    \            [largest (first factors)]\n            [remainder (remainder (first\
    \ factors) n)]\n            [largest-divisor (remainder (first factors) n)]\n\
    \            [largest-divisor-divisor (remainder (first factors) n)]\n       \
    \     [largest-divisor-divisor remainder])\n       (if (= n 2)\n           largest\n\
    \           (if (= largest-divisor-divisor 1)\n               largest\n      \
    \         (if (= largest-divisor-divisor largest)\n                   largest\n\
    \                   (largest-divisor largest)))))\n      largest)))\n", "  (for/fold\
    \ ((p 2) (e 2))\n            ((i (- n 1))\n             ((j p)\n             \
    \ (let ((p (- n 1)))\n                (if (= (modulo i j) 0)\n               \
    \     (set! p (+ j 1))\n                    (if (not (= i (+ j 1)))\n        \
    \                (set! p (+ j 1))\n                        (set! e j)))\n    \
    \            (if (= p (+ j 1))\n                    (return-from (largest_prime_factor)\n\
    \                              (modulo i j)))\n                (set! i (+ j 1)))))\n\
    \    (modulo n e)\n    (/ n e)))\n", "  (cond [(= n 2) 2]\n        [(even? (remainder\
    \ n 2)) (+ n 2)] \n        [else (largest_prime_factor (* 3 n))]))\n", "  (let\
    \ ([p 2]\n        [i 4])\n    (while (<= i n)\n      (if (= (modulo (+ 2 p) n)\
    \ 0)\n          (p (+ i 1))\n          (p (+ i 1))))\n    (modulo n p)))\n", " \
    \ (let loop ((n (+ n 2))\n             (max-factor (floor (/ n 2))))\n    (cond\
    \ ((= n 1) max-factor)\n          ((even? n) loop)\n          (else (loop (- n\
    \ 2)\n                      (if (> (/ n max-factor) 1)\n                     \
    \     (/ n max-factor)\n                          max-factor))))))\n", "  (check-type\
    \ n (bignum/biginteger bignum/integer))\n  (if (zero? n)\n      (error \"n cannot\
    \ be zero\")\n      (loop\n         with primes (list 3)\n         for i below\
    \ n\n         for p below primes\n         when (not (zero? (modulo (* i p) p)))\n\
    \         do (set! primes (cons p primes))\n         until (zero? p)\n       \
    \  finally (return (first primes)))))", "  (cond [(= n 1) 1]\n        [(= n 2)\
    \ 2]\n        [(= n 3) 3]\n        [(= n 5 #t) 5]\n        [else (* 2 (largest_prime_factor\
    \ (- n 2)))]))\n", "  (max 1 (list\n           (loop for i from 2 below (round\
    \ (sqrt n)) until\n                   (not (prime? n (/ i 2))))\n           (loop\
    \ for i from (round (sqrt n)) below (round (sqrt n)) until\n                 \
    \  (not (prime? n (/ i 2))))\n           (loop for i from 3 below (round (sqrt\
    \ n)) until\n                   (not (prime? n (/ i 2))))\n           (loop for\
    \ i from 4 below (round (sqrt n)) until\n                   (not (prime? n (/\
    \ i 2))))\n           (loop for i from 5 below (round (sqrt n)) until\n      \
    \             (not (prime? n (/ i 2))))\n           (loop for i from 6 below (round\
    \ (sqrt n)) until\n                   (not (prime? n (/ i 2))))\n           (loop\
    \ for i from 7 below (round (sqrt n)) until\n                   (not (prime? n\
    \ (/ i 2))))\n           (loop for i from 8 below (round (sqrt n)) until\n   \
    \                (not (prime? n (/ i 2))))\n           (loop for i from 9 below\
    \ (round (sqrt n)) until\n                   (not (prime? n (/ i 2))))\n     \
    \      (loop for i from 10 below (round (sqrt n)) until\n                   (not\
    \ (prime? n (/ i 2))))\n           (loop for i from 11 below (round (sqrt n))\
    \ until\n                   (not (prime? n (/ i 2))))\n           (loop for i\
    \ from 12 below (round (sqrt n)) until\n                   (not (prime? n (/ i\
    \ 2))))\n           (loop for i from 13 below (round (sqrt n)) until\n       \
    \            (not (prime? n (/ i 2))))\n           (loop for i from 14 below (round\
    \ (sqrt n)) until\n                   (not (prime? n (/ i 2))))\n           (loop\
    \ for i from 15 below (round (sqrt n)) until\n                   (not (prime?\
    \ n (/ i 2))))\n           (loop for i from 16 below (round (sqrt n)) until\n\
    \                   (not (prime? n (/ i 2))))\n           (loop for i from 17\
    \ below (round (sqrt n)) until\n                   (not (prime? n (/ i 2))))\n\
    \           (loop for i from 18 below (", "  (let* ((factors (factorize n))\n\
    \         (largest (car factors)))\n    (if (null factors)\n        n\n      \
    \  (if (> (car factors) largest)\n            (largest)\n            (largest_prime_factor\
    \ (cdr factors))))))\n", "  (if (= n 2)\n      n\n      (let loop ((n n) (m 2)\
    \ (primes '()))\n        (cond [(= m n) n]\n              [(<= n (floor (/ n m)))\
    \ (loop (/ n m) (+ m 1) (cons m primes))]\n              [else\n             \
    \  (let ((j (floor n))\n                     (r (/ j m)))\n                 (if\
    \ (= r 2)\n                     (loop (/ j r) (+ j 1) (cons r primes))\n     \
    \                (loop (* r j) r (cons r primes))))]))))\n", "  (if (or (= n 2)\n\
    \          (= n 3))\n      n\n      (let ((factor (factor (floor n))))\n     \
    \   (if (< n 2)\n            (if (= (modulo n factor) 0)\n                factor\n\
    \                (largest_prime_factor (/ n factor)))\n            (if (= (modulo\
    \ n factor) 0)\n                n\n                (largest_prime_factor (/ n\
    \ factor)))))))\n", "  (if (prime? n)\n      n\n      (let ([s (primes n)])\n\
    \        (if (null? s)\n            n\n            (if (< (first s) (* n 2))\n\
    \                (let ([s (cdr s)])\n                  (if (<= (length s) (- n\
    \ 1))\n                      (first s)\n                      (largest_prime_factor\
    \ (* n d))\n                  )\n                )\n            )\n        )\n\
    \      )\n  )\n", "  (if (= n 1)\n      1\n      (let ((factor (prime-factors\
    \ n)))\n        (if (null? factor)\n            n\n            (max (length factor)\
    \ (length (filter (lambda (f) (even? f)) factor)))))\n  )\n", "  (cond [(= n 1)\
    \ 2]\n        [(even? n) (* n 2)]\n        [else\n         (let ([factors (prime-factors\
    \ n)])\n           (max-prime-factor factors))]))\n", "  (let ((factors (make-hash-table)))\n\
    \    (cond [(prime? n) n]\n          [else (loop (add1 n) (hash-ref factors n))]\n\
    \          :done))\n)\n", "  (define (largest-prime-factor-iter n prime-count)\n\
    \    (if (< n 1)\n        0\n        (largest-prime-factor-iter (/ n prime-count)\
    \ (add1 prime-count))))\n  (largest-prime-factor-iter n 2))\n", "  (loop for p\
    \ from 2 to n\n        while ((even? n) \n              (= (remainder n p) 0)\n\
    \              (= (mod n p) 0))\n        collect p))\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nI guess this would be a better answer if it also included an explanation.\
    \ +1\n<|/ c |>\n<| c |>\nThanks. I added an explanation.\n<|/ c |>\n<| a tags=racket,scheme\
    \ |>\nHere is a simple Scheme implementation for a Sieve of Eratosthenes that\
    \ returns all prime numbers <= a given limit: \n<code>\n#lang racket\n", "  (cond\
    \ [(= n 1) 2]\n        [(even? n) (largest_prime_factor (/ n 2))]\n        [else\
    \ (* n (largest_prime_factor (/ n 2)))]))\n", "  (let loop ((x 2) (max 1) (prime\
    \ (prime? n)))\n    (if (= x max)\n        max\n        (loop (+ x 1) (* x max)\
    \ (not (prime? x)))))\n)", "  (cond [(= n 1) '()]\n        [(= (remainder n 2)\
    \ 0) (+ 1 '(2))]\n        [(is_prime n) (+ n (largest_prime_factor (- n 1)))]))\n",
  "  (define largest (list-ref (list-ref (prime_factors n) (sub1 (length n)))\n  \
    \                         (sub1 (length n))))\n  (if (= (modulo n largest) 0)\n\
    \      largest\n      (largest_prime_factor (quotient n largest))))\n", "  (let\
    \ ((candidates (primes n)))\n    (cond\n      [(empty? candidates) n]\n      [(=\
    \ (length candidates) 1) (first candidates)]\n      [else (first (max (map #(largest_prime_factor\
    \ (first %)) candidates))))]))\n", "  (if (= n 1)\n      n\n      (let ((factors\
    \ (factorize n)))\n        (if (null? (cdr factors))\n            n\n        \
    \    (if (> (car factors) (cdr factors))\n                (cdr factors)\n    \
    \            (largest_prime_factor (car factors))))))) ;; #lang racket\n", " \
    \ (cond [(= n 2)\n         2]\n        [(prime? n) (* n largest_prime_factor (largest_prime_factor\
    \ (/ n 2)))]\n        [else n]))\n", "  (define (trial-division n i)\n    (if\
    \ (even? i)\n        1\n        (if (> n (/ i 2))\n            (recur (/ n 2)\
    \ (- i 2))\n            (trial-division (* n n) (+ i 1)))))\n  (trial-division\
    \ n 2))\n", "  (let loop ((n n)\n             (n 2)\n             (factors (list\
    \ n)))\n    (if (= n 1)\n        n\n        (loop (* n n)\n               (+ n\
    \ 1)\n               (cons (* n n) factors)))))\n", "  (cond [(= n 1) n]\n   \
    \     [(even? n) (largest_prime_factor (/ n 2))]\n        [else (* 2 (largest_prime_factor\
    \ (/ n 2)))]))\n", "  (let loop ((factors (make-list n))\n             (current\
    \ (primes (first factors)))\n             (result 0))\n    (if (>= n 0)\n    \
    \    (loop\n          (cons (first factors)\n                (rest factors))\n\
    \          (+ result (first current)))\n        result)))\n", "  (cond [(= n 1)\
    \ 2]\n        [(even? (modulo n 2)) #t]\n        [(even? (modulo n 3)) (largest_prime_factor\
    \ (/ n 3))]))\n", "  (cond ((or (= n 1) (modulo n 2))\n         n)\n        ((even?\
    \ n)\n         (cond ((= (modulo n 2) 0)\n                (* n 2))\n         \
    \      ((= (modulo n 2) 1)\n                (/ n 2)))\n        ((odd? n)\n   \
    \      (largest_prime_factor (division n 2)))))\n", "  (if (< n 2) nil\n     \
    \ (cond ((= (remainder n 2) 0) (if (> (remainder n 3) 2)\n                   \
    \                 (remainder n 3)\n                                    (remainder\
    \ n 2)))\n              ((even? n) (if (> (remainder n 2) 2)\n               \
    \             (remainder n 2)\n                            (remainder n 1)))\n\
    \              (else (largest_prime_factor (quotient n 2)))))))\n", "  (if (=\
    \ n 1)\n      n\n      (let ((m (/ (Math/floor n) 2))\n            (i 2))\n  \
    \      (cond\n          [(= m 1) n]\n          [(= m 0) n]\n          [else\n\
    \           (cond\n             [(= (* m m) (* n n)) (* m (largest_prime_factor\
    \ (* n n)))]\n             [else (loop [i m n]\n                       (cond\n\
    \                         [(> (* i i) n) i]\n                         [(= (* i\
    \ i) n) (* i i)]\n                         [else (loop (+ i 2) m n)]))]))])))\n\
    </cell>\n<text>\nA recursive function with tail recursion\nIn the last section,\
    \ we wrote a function that took advantage of the fact that a recursive function\
    \ can be turned into a tail recursive function. However, we can also write this\
    \ as an iterative function as well. Here is one way to write this as an iterative\
    \ function:\n\n\n</text>\n<cell>", "  (let loop ((n n)\n             (largest-prime\
    \ 1))\n    (cond [(= n 1) largest-prime]\n          [(= (mod n largest-prime)\
    \ 0)\n           (loop (quotient n largest-prime) (add1 largest-prime))]\n   \
    \       [else (loop (quotient n largest-prime) largest-prime)]))\n</code>\n<|/\
    \ a tags=racket,scheme dscore=1 |>\n<| a tags=racket,scheme |>\nThe answers given\
    \ are all good, I'm just adding another solution using an inner procedure:\n<code>",
  "  (cond\n    [(= n 1) 2]\n    [else (max (largest_prime_factor (/ n 2)) (smallst_prime_factor\
    \ (+ n 1))))]))", "  (if (prime? n)\n      (let ([factors (list-prime-factors\
    \ n)]\n            [largest-factor (first factors)])\n        (if (empty? factors)\n\
    \            largest-factor\n            (largest_prime_factor (first factors)))))\n\
    \  n)\n", "  (if (> n 2)\n      n\n      (cond [(= (modulo n n) (even? n)) (largest_prime_factor\
    \ (quotient n 2))]\n            [(even? n) (cond [(= n 2) n]\n               \
    \           [(= (modulo n n) 1) (+ n (largest_prime_factor (quotient n 2)))]\n\
    \                          [(= (modulo n n) 2) (+ n (largest_prime_factor (quotient\
    \ n 3)))]\n                          [(= (modulo n n) 3) (+ n (largest_prime_factor\
    \ (quotient n 4)))]\n                          [else (largest_prime_factor (quotient\
    \ n 4))])]\n            [else (largest_prime_factor (quotient n 3))])))\n", " \
    \ (if (< n 2)\n      n\n      (let ((p (+ n 1)))\n        (if (even? p)\n    \
    \        (largest_prime_factor p)\n            (if (prime p)\n               \
    \ (+ n p)\n                (if (even? p)\n                    (largest_prime_factor\
    \ p)\n                    p))))))\n", "  (if (= n 1)\n      1\n      (max (prime-factors\
    \ n) (lambda (m)\n                       (if (= m 1)\n                       \
    \    1\n                           (* m\n                            (largest_prime_factor\
    \ (/ n m))))))))\n", "  (define (lf n p)\n    (cond [(= n 1)\n           1]\n\
    \          [(= (remainder n p) 0)\n           (cond [(= p (expt n 2))\n      \
    \             (/ n p)]\n                   [else\n                   (* p (lf\
    \ (quotient n p) p))]]))\n  (lf n 2))\n", "  (let ((factors (factor-range n)))\n\
    \    (loop for i from 0 below (length factors)\n          when (equal? i 0)\n\
    \          collect (first factors)\n          into factors\n          finally\
    \ (return (first factors)))))\n", "  (if (= n 1)\n      n\n      (if (prime (mod\
    \ n 2))\n          (largest_prime_factor (/ n 2))\n          (largest_prime_factor\
    \ (quot n 2))))))\n", "  (let loop ((n n) (primes #() (filter prime? primes))\n\
    \             (max n) (prime (car primes)))\n    (cond ((= n 1) prime)\n     \
    \     ((> (% n prime) (% max max))\n           (loop (/ n prime)\n           \
    \        (conj primes prime)\n                   (/ max prime)\n             \
    \      (car primes)))\n          ((< n prime) (loop (/ n prime)\n            \
    \                 (conj primes prime)\n                             max\n    \
    \                         (car primes)))))\n</code>\n<|/ a tags=racket,scheme,sieve-of-eratosthenes\
    \ dscore=2 |>\n<| c |>\nI like your implementation of the prime test. That's what\
    \ I was missing when I was solving this problem, and I didn't realize it was necessary.\n\
    <|/ c |>\n<| c |>\nThis solution is still not guaranteed to terminate in the worst\
    \ case on input that's prime. Sieve of Eratosthenes is very fast and will find\
    \ a prime very quickly with a non-prime input.\n<|/ c |>\n<| c |>\nThe worst case\
    \ is when the number is prime. That's what OP was trying to avoid. My code does\
    \ not guarantee that the number will be prime. It only works if it is non-prime\
    \ (which it does because `filter` stops when the first false is found).\n<|/ c\
    \ |>\n<| a dscore=0 |>\nThis isn't really an answer to the OP's question, but\
    \ I feel it might be useful to others.\nIt seems that one way of solving this\
    \ problem is the following:\n<code>", "  (let ([factors (prime-factors n)])\n\
    \    (max (length factors) (apply + (map lcm-of-largest-factor (map - factors\
    \ factors))))))\n", "  (define (helper n prime)\n    (cond ((= n 1) (prime))\n\
    \          ((odd? (remainder n prime)) (helper (remainder n prime) (* prime prime)))\n\
    \          ((= (remainder n prime) 0) (helper (remainder n prime) (+ prime prime))))\n\
    \  (helper (quotient n 2) 2))\n", "  (let ([factors (make-list n (lambda (x) (=\
    \ (modulo x n) 1)))])\n    (loop for i from 2 to (/ n 2) by 2\n          for j\
    \ to (- i 2) by 1\n          when (cdr factors)\n          [; If i is a factor...\n\
    \           (if (car factors) (- i 1) i)\n           (let ([candidates (filter\
    \ (lambda (factor) (= (modulo i factor) 1)) factors)])\n             (when (<=\
    \ (length candidates) (- i 1))\n               (set! factors (append (cons i factors)\
    \ candidates))\n               (return-from largest_prime_factor i))])]))\n</code>",
  "  (loop for i below n\n        until (>= i 2)\n        collect (cond [(= i 2)\n\
    \                      (+ 1 (* n i))]\n                    [else i]))", "  (let\
    \ ((factor (big-prime n)))\n    (cond ((= n 1)\n           factor)\n         \
    \ ((even? factor)\n           (small-prime factor))\n          (else\n       \
    \    (largest_prime_factor (/ n factor))))))\n", "  (let loop ((i 2) (p 1))\n\
    \    (if (= i n) (if (zero? (mod n p))\n                      p\n            \
    \          (loop (+ i 1) (- p 1)))\n            (loop (+ i 1) p))))\n", "  (cond\n\
    \    [(= n 1) 2]\n    [(= (mod n 2) 0) (/ n 2)] \n    [else (largest_prime_factor\
    \ (/ n 2))]))\n", "  (if (even? n)\n      (let ([t (largest_prime_factor (/ n\
    \ 2))])\n        (if (> n 2)\n            0\n            (max (floor (/ n t))\
    \ t)))))\n", "  (cond [(= n 1)                        1]\n        [(= (mod n 2)\
    \ 0)                  (/ n 2)]\n        [else                            (* 2\
    \ (largest_prime_factor (/ n 2)))]))\n", "  (define (helper n i k)\n    (cond\
    \ ((= i k) (/ n 2))\n          ((> n 1)\n           (helper (/ n i)\n        \
    \            (+ i 1)\n                    (+ k (/ (- n i) 2))))\n          ((prime?\
    \ n)\n           (helper (/ n i)\n                    (+ i 1)\n              \
    \      k))\n          (t (helper (/ n i)\n                    (+ i 1)\n      \
    \              (+ k 1)))))\n  (helper (* n 2)\n         0 1))\n", "  (let loop\
    \ ((p 2))\n    (if (= n 1)\n        p\n        (loop (quotient n p)))))\n", " \
    \ (let loop ((n n) (max-prime (exact-ceiling (exact-remainder n 2)))\n       \
    \     (primes ()))\n    (cond\n      [(= n 1) max-prime]\n      [(is-prime n)\
    \ n]\n      [(= max-prime 1) (first primes)]\n      [(is-prime max-prime) (loop\
    \ (first primes) max-prime primes)]\n      [(= (first primes) max-prime) (loop\
    \ (first primes) (max max-prime (first primes))\n                            \
    \                (cons (first primes) primes))]\n      [(and (is-prime max-prime)\
    \ (> n max-prime))\n       (loop (first primes) (max max-prime (first primes))\n\
    \             (cons (first primes) primes))]\n      [(and (not (is-prime max-prime))\
    \ (> n max-prime))\n       (loop (first primes) max-prime primes)]\n      [(and\
    \ (not (is-prime max-prime)) (< n max-prime))\n       (loop (first primes) max-prime\
    \ primes)]\n      [else (loop (first primes) max-prime primes)])))\n", "  (define\
    \ (helper n max_prime)\n    (cond ((= n 1) max_prime)\n          ((odd? n) (helper\
    \ (- n 1) max_prime))\n          ((even? n) (helper n max_prime)))\n  (helper\
    \ n 2))\n", "  (cond [(= n 1) n]\n        [(even? n) (/ n 2)]\n        [(odd?\
    \ n) (/ (* n primes) primes)]\n        [else (largest_prime_factor (/ n 2))]))\n",
  "  (if (< n 2) n\n      (loop (quotient n 2)\n            (if (zero? quotient)\n\
    \                (if (= (modulo n quotient) 1)\n                    quotient\n\
    \                    (loop (quotient quotient)\n                          (if\
    \ (= (modulo n quotient) 1)\n                              quotient\n        \
    \                      (if (= (modulo n quotient) 2)\n                       \
    \           quotient\n                                  (error 'largest_prime_factor\
    \ \"Not a prime number.\"))))))))\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n\
    Here is a solution which does not use division or loops.  It uses remainders,\
    \ modulo arithmetic, and the fact that 2 is a prime number itself.\n<code>", " \
    \ (if (zerop n)\n      'error\n      (let loop ((n n)\n                 (factors\
    \ '())\n                 (largest-factor '()))\n        (cond ((= n 1) largest-factor)\n\
    \              ((or (= (modulo n factor) (modulo (+ n 1) factor)) (= n 2))\n \
    \              (cond ((= (length factors) 0) largest-factor)\n               \
    \      (else (loop (/ n factor)\n                               (cons (modulo\
    \ n factor) (factors))\n                               (max (length factors) (length\
    \ largest-factor)))\n                     (loop (* n factor)\n               \
    \           (cons (modulo n factor) (factors))\n                          (max\
    \ (length factors) (length largest-factor))))))\n          ((even? n) largest-factor)\n\
    \          (else (loop (- n 1)\n                    (cons (- n 1) factors)\n \
    \                   (max (length factors) (length largest-factor))))))\n", " \
    \ (assert (> n 1))\n  (assert (= n 2))\n  (if (= n 2)\n      n\n      (let ((p\
    \ (prime-iter (- n 1))))\n        (if (null? p)\n            0\n            (max\
    \ (first p) (rest (rest p)))))\n      )\n  )\n", "  (cond ((= n 1) 0)\n      \
    \  ((prime? n) (/ n 2))\n        (else (let ((factors (prime-factors n)))\n  \
    \               (max (max-prime-factor factors))\n                 (if (zero?\
    \ max) (- 1 (max 0)))))))\n", "  (let ((factors '()))\n    (cond ((< n 2) 1)\n\
    \          ((prime? n) (list n))\n          ((composite? n) (append (largest-prime-factor\
    \ (/ n 2)) (list n)))\n          ((> (* n n) n) (append (largest-prime-factor\
    \ (/ n n)) (list n)))\n          (else (append (largest-prime-factor (* n n))\
    \ (largest-prime-factor (/ n n)))))\n    (apply append (sort factors))))\n", " \
    \ (find-largest-factor (+ 1 n) primes))\n", "  (cond ((= n 2) 2)\n        ((=\
    \ n 3) 3)\n        ((>= n 5) 5)\n        ((number? n) (largest_prime_factor (rem\
    \ n 3)))\n        (else (begin\n                  (define primes\n           \
    \         (cond ((= n 2) '())\n                          ((prime? (remainder n\
    \ 2)) '(2))\n                          (else (append (primes (remainder n 2))\n\
    \                                      (cons n (primes (remainder n 2)))))))\n\
    \                  (define largest\n                    (map first\n         \
    \                 (sort (lambda (prime) (> (% prime n) 0)) primes)))\n       \
    \           (largest)))) \n", "  (define (sieve-step n primes)\n    (cond ((=\
    \ n 1) (list-of primes))\n          ((zero? (modulo n prime)) (sieve-step (- n\
    \ 1) (cons n primes)))\n          (else (sieve-step (- n 1) (cons n (sieve (-\
    \ n 1) primes))))))\n\n  (define (sieve n primes)\n    (cond ((= n 1) primes)\n\
    \          (else (sieve (- n 1) (cons (modulo n prime) primes)))))\n\n  (sieve-step\
    \ n '()))\n", "  (let loop ([m (+ 1 n)]\n             [max n]\n             [count\
    \ 1])\n    (if (even? m)\n        n\n        (loop (quotient m (expt 2 count))\n\
    \              (quotient m 2)\n              (inc count)))))\n", "  (define (largest-prime-factor-aux\
    \ n i)\n    (cond [(= i n) (list n 1)]\n          [else (largest-prime-factor-aux\n\
    \                   (sub1 n)\n                   (add1 i))]))\n  (largest-prime-factor-aux\n\
    \   n\n   2)\n)\n", "  (define (helper n prime-factor)\n    (cond ((= n 0) (/\
    \ n prime-factor))\n          ((= (remainder n prime-factor) 0) (helper (- n prime-factor)\
    \ prime-factor))\n          (else (helper (- n prime-factor) (* prime-factor prime-factor)))))\n\
    \  (helper n 2))\n", "  (define (largest_prime_factor n)\n    (cond [(= n 1) 1]\n\
    \          [(= n 2) 2]\n          [(prime? (remainder n 2) 1)\n           (let\
    \ ([m (largest_prime_factor (quotient n 2))])\n             (if (= m n)\n    \
    \             n\n                 (* m (largest_prime_factor (quotient n m))))))\n\
    \          [else\n           (let ([m (largest_prime_factor (quotient n 2))])\n\
    \             (if (= m n)\n                 n\n                 (* m (largest_prime_factor\
    \ (quotient n m))))))]\n    (if (= n 1)\n        1\n        (if (prime? (remainder\
    \ n 2))\n            (* 2 (largest_prime_factor (quotient n 2)))\n           \
    \ (largest_prime_factor (quotient n 2))))))\n</code>\nThe racket version is pretty\
    \ similar.\n<|/ a tags=primes,racket,functional-programming |>\n<| c |>\nI forgot\
    \ to mention that i do have to have it as a procedure and i cannot use any built-in\
    \ procedures. But thank you! I'll review my code based on your answer.\n<|/ c\
    \ |>\n<| a |>\nIn case someone finds this useful, I've implemented a version of\
    \ Martin's code that works fine in racket.\n<code>", "  (largest_prime_factor_aux\
    \ n 1 (sqrt n)))\n", "  (define (helper n primes factor)\n    (cond ((= n 0) factor)\
    \ ; n is prime\n          ((= primes 0)\n           (error 'largest_prime_factor\
    \ \"All primes are greater than 1\")\n           (helper (- n 1) (- primes 1)\
    \ factor))\n          ((null? primes)\n           (helper n primes (if (zero?\
    \ n) (- n factor) (+ n factor))))\n          (else\n           (helper (- n 1)\
    \ (+ primes (first primes)) (if (zero? n) (- n factor) (+ n factor)))\n      \
    \    )\n      )\n  (helper n 1 (- (mod n prime) 1)))", "  (let ((prime-factors\
    \ (prime_factorization n)))\n    (filter prime-factors '(1 2 (3 4)))\n    (first\
    \ (sort (lambda (f1 f2) (< (first f1) (first f2))) (prime-factors ))))))\n", " \
    \ (if (<= n 1)\n      1\n      (* 2 (largest_prime_factor (- n 1)))))\n", "  (define\
    \ (largest_prime_factor-loop n factor)\n    (cond\n      [(= n 1) factor]\n  \
    \    [(prime? n) (largest_prime_factor-loop n (* n factor))]\n      [else (largest_prime_factor-loop\
    \ (- n 1) (* n factor))]\n      ))\n  (largest_prime_factor-loop n 1))\n", " \
    \ (if (> n 1)\n      nil\n      (let loop ((i 2)\n                 (largest (+\
    \ 1 i)))\n        (if (< i n)\n            (loop i\n                  (if (modulo\
    \ (modulo n i) (+ 1 i))\n                      (if (< i largest)\n           \
    \               (loop i (+ 1 i))\n                          largest)\n       \
    \               largest))))))\n", "  (let loop ((p 2) (c 2)\n             (prime\
    \ (primes? (+ n c))) #t)\n    (if (= c p)\n        prime\n        (if (prime?\
    \ n)\n            (loop (+ p 1) (+ c 2) (prime? n) #f)\n            (if (or (=\
    \ c p) (= n p))\n                (loop (+ p 1) (+ c 2) (prime? n) #t)\n      \
    \          (loop (+ p 1) (+ c 2) prime #t))))))\n", "  (cond\n    [(= n 1) (error\
    \ 'largest_prime_factor \"n must be > 1\")]\n    [(= (remainder n 2) 0) (error\
    \ 'largest_prime_factor \"n must be > 1 and be a prime\")]\n    [else (loop for\
    \ i from 2 to n \n                while (divides? n i)\n                collect\
    \ (i))]))\n", "  (cond ((null? n) '())\n        ((= n (lcm(+ 1 n (remainder n\
    \ 2))))\n         (lcm(+ 1 n (remainder n 2)))\n         ((even? n)\n        \
    \  (if (equal? (remainder n 2) 0)\n              (remainder n 2)\n           \
    \   (largest_prime_factor (remainder n 2))))\n         (else (largest_prime_factor\
    \ (remainder n 2)))))\n", "  (cond [(= n 1) n]\n        [(even? n) (largest_prime_factor\
    \ (/ n 2))]\n        [else (+ 1 (largest_prime_factor (- n 1)))]))\n</code>\n\
    <|/ a tags=racket,scheme dscore=0 |>\n<| c |>\nThank you very much for your reply.\
    \ Still i have a small question, how do i return the number of the smallest prime\
    \ factor of the given number? I'm new to racket.\n<|/ c |>\n<| c |>\nTo find the\
    \ smallest prime factor of a given number n, you can simply test if its value\
    \ is even. If it is, find the smallest prime factor of n / 2. In pseudocode: `(if\
    \ n is even, return smallest prime factor of n / 2)`\n<|/ c |>\n<| c |>\nI added\
    \ this code to my function but it always return the first number of the list and\
    \ not the smallest prime factor\n<|/ c |>\n<| c |>\n`largest_prime_factor` returns\
    \ one prime factor of the number `n`, right? So why are you adding `1` to the\
    \ result? That would just make it the next largest prime factor, wouldn't it?\
    \ So I'm assuming you are trying to return the smallest prime factor.\n<|/ c |>\n\
    <| c |>\nYes i try to return the smallest prime factor. I edited my code above.\
    \ Thanks for your help.\n<|/ c |>\n<| a dscore=0 |>\n<code>", "  (if (even? n)\n\
    \      (+ 1 (largest_prime_factor (- n 2)))\n      1))\n</cell>\n<code language=dyalog-kernel>",
  "  (define l (floor (sqrt n)))\n  (define p (floor n))\n  (define m (/ n 2))\n \
    \ (define p (- p 1))\n  (cond\n    ((= m 1) n)\n    ((= l 1) n)\n    ((= p 1)\
    \ 1)\n    ((= m l) 1)\n    ((= p (* l l)) l)\n    (else (* p (* m l)))))\n", " \
    \ (let loop ([n n] [max 0])\n    (if (> n 0)\n        (let loop ([x n] [max x])\n\
    \          (if (even? x)\n              (let loop ([x x] [max x])\n          \
    \      (if (odd? x)\n                    (if (> max x)\n                     \
    \   (loop (/ x 2) max)\n                        (loop (* x 2) max))\n        \
    \            (loop (+ x 1) x))\n                (if (< max x)\n              \
    \      (loop (/ x 2) max)\n                    (loop (* x 2) max)))))\n      \
    \  max)))\n", "  (if (even? n)\n      (* n largest_prime_factor)\n      (if (is_prime\
    \ n)\n          n\n          (max ((largest_prime_factor (/ n 2))) (if (is_prime\
    \ (/ n 3))\n                                                  (max ((largest_prime_factor\
    \ (/ n 3)) 2)\n                                                        (max ((largest_prime_factor\
    \ (/ n 5)) 3))\n                                                  (max ((largest_prime_factor\
    \ (/ n 7)) 4))))\n               n))))\n", "  (cond [(= n 1) n]\n        [else\
    \ (largest_prime_factor (next_prime n))]))\n", "  (if (is_prime n) (if (is_prime\
    \ (/ n 2)) (/ n 2) 2)\n      (largest_prime_factor (/ n 2))))\n", "  (cond [(=\
    \ n 1)\n         1]\n        [else\n         (floor (log (/ n 2))\n          \
    \      (* ((/ n 2) (floor (log (/ n 2))))\n                   (floor (/ (floor\
    \ (log (/ n 2)) 2))\n                      (ceil (log (/ (floor (log (/ n 2))\
    \ 2)) 2))))]))\n", "  (let loop ((i 2)\n             (prime (prime-number (prime-number\
    \ (+ n 1) i)))\n             (found null))\n    (cond ((= i n) (if (not (null?\
    \ found)) (* prime i) (+ i 1))\n          ((> (+ n prime) n) (loop (+ i 1) prime\
    \ found))\n          ((= (% n prime) 0) (loop (+ i 1) prime found))\n        \
    \  (t (loop (+ i 1) prime found))))))\n", "  (cond [(= n 1) 2]\n        [else\
    \ (let ([c (largest_prime_factor n)]\n                   (and (= (remainder n\
    \ c) 0)\n                        (= (* c n) n)))\n               (if (= c 1)\n\
    \                   n\n                   (* c (largest_prime_factor (- n 1)))))]))\n",
  "  (cond ((even? n)\n         (/ n 2))\n        ((= (mod n 2) 0)\n         (/ n\
    \ 2))\n        ((even? (/ n 3))\n         (largest_prime_factor (/ n 3)))\n  \
    \      ((= (mod n 3) 0)\n         (/ n 3))\n        (else (largest_prime_factor\
    \ (/ n 5)))))\n", "  (let ((factor (prime-factor-gen (+ n 1))))\n    (cond ((null?\
    \ factor) #f)\n          ((= n 0) factor)\n          (else (if (> n 1)\n     \
    \             (expt n factor)\n                  (largest_prime_factor (- n 1)))))))\n",
  "  (cond\n    [(= n 1) 2]\n    [(= n 2) 3]\n    [(= n 3) (+ (/ n 3) 1)]))\n", " \
    \ (let loop ((n n) (primes '(2)))\n    (if (= n 1)\n        2\n        (loop (/\
    \ n prime) (cons n (remove #(< n %) primes)))))))\n", "  (let loop ([n n]\n  \
    \           [primes #{1 2 3 5 7 11 13}])\n    (cond [(= n 1) 1]\n          [(empty?\
    \ primes) n]\n          [else (loop (/ n prime) (remove (modulo (first primes)\
    \ n)))])))\n", "  (let loop ((n n)\n             (factors ())\n             (next\
    \ (prime-factor-algorithm n)))\n    (cond\n      ((= n 1) 0)\n      (else (cond\
    \ \n               ((>= n 2) (cons n factors))\n               (else (loop next\
    \ (cons n (+ next (next))) (next))))))))\n", "  (let loop ((i 2)\n           \
    \  (factors #{}))\n    (if (= i n)\n        (length factors)\n        (let ((candidate\
    \ (* i i)))\n          (if (< candidate n)\n              (loop (+ i 1) (cons\
    \ candidate factors))\n              (loop (+ i 1) factors)))))))\n", "  (cond\
    \ ((= n 1) n)\n        (else (let ((f (make-prime-factorizer n)))\n          \
    \      (if (prime-factors? f)\n                    (if (>\n                  \
    \       (largest-prime-factor-so-far f)\n                         n)\n       \
    \                 (largest-prime-factor-so-far f))\n                    (largest-prime-factor-so-far\
    \ f))))))\n", "  (check-type n integer)\n  (let loop ((n (modulo n 2))\n     \
    \        (m (modulo n 3))\n             (result 1)\n             (remainder (modulo\
    \ n 5))\n             (i 2)\n             (max 0))\n    (if (< i max)\n      \
    \  (loop (modulo n i) m result (remainder (modulo n i)))\n        result))) ;;\
    \ returns last return value of loop\n</code>\nHere are some test cases:\n<code>",
  "  (cond [(= n 1) 1]\n        [(= (odd? n) 1) (/ n 2)]\n        [else (largest_prime_factor\
    \ (/ n 2))]))\n", "  (cond [(= n 1) 1]\n        [(or (= (modulo n 2) 0)\n    \
    \         (or (= (modulo n 3) 0)\n                 (or (= (modulo n 5) 0)\n  \
    \                   (or (= (modulo n 7) 0)\n                         (or (= (modulo\
    \ n 11) 0)\n                             (or (= (modulo n 13) 0)\n           \
    \                      (or (= (modulo n 17) 0)\n                             \
    \        (or (= (modulo n 19) 0)\n                                         (or\
    \ (= (modulo n 23) 0)\n                                            (= (modulo\
    \ n 31) 0))))))))))\n         (/ (gcd (floor (sqrt n)) (floor (sqrt (* n n))))\
    \ 2)\n         1]\n        [else (* n (largest_prime_factor (- n (floor (sqrt\
    \ n))))]))) ;; #lang racket\n</cell>\n<cell>", "  (if (prime? n)\n      (floor\
    \ (/ n 2))\n      (let ([d (* n n)])\n        (if (> d 2)\n            (* 2 d)\n\
    \            (if (> (mod n d) 0)\n                (let ([r (/ n d)])\n       \
    \           (if (= r 0)\n                      (+ 1 (largest_prime_factor r))\n\
    \                      (+ 1 (largest_prime_factor r)))))))\n      0))\n", "  (cond\
    \ ((= n 1) 2)\n        ((even? n) (ceiling (/ n 2)))\n        (else (largest_prime_factor\
    \ (div (car n) (ceiling (/ (car n) (floor (car n)))))))))\n", "  (let ((factors\
    \ (prime-factors n)))\n    (max-prime-factor-of (first factors) (remove-duplicates\
    \ factors))))\n", "  (define (prime-factors n)\n    (define (prime-factors-helper\
    \ n factors)\n      (cond ((= n 1) factors)\n            ((zero? (modulo n 2))\n\
    \             (prime-factors-helper (- n 2) (cons n factors)))\n            (else\n\
    \             (prime-factors-helper (- n 1)\n                                (if\
    \ (> (modulo n factor) 0)\n                                    (cons factor factors)\n\
    \                                    factors)))))\n    (prime-factors-helper n\
    \ '()))\n  (if (not (number? n))\n      (prime-factors n) (prime-factors n))\n\
    \  )\n", "  (let loop ((p 3)\n             (q n)\n             (q p))\n    (if\
    \ (zero? q)\n        n\n        (if (number? q)\n            (if (even? q)\n \
    \               (loop (+ p p) (/ q 2))\n                (loop (+ p p) (/ q 2)))\n\
    \            (loop (+ p p) (quotient q 2)))\n        )))\n", "  (define (prime?\
    \ p)\n    (= (remainder p 2) 0))\n\n  (define (largest-prime-factor i s)\n   \
    \ (if (> i s)\n        null\n        (if (prime? (car s))\n            (largest-prime-factor\
    \ (+ i 1) (cdr s))\n            (largest-prime-factor (+ i 1) (cons (car s) s)))))\n\
    \n  (largest-prime-factor n '()))", "  (define (largest_prime_factorize n)\n \
    \   (if (= n 1)\n        n\n        (let ([m (floor n 2)]\n              [factors\
    \ (loop\n                        for p 2\n                        for q p\n  \
    \                      for ((factors (loop\n                                 \
    \     for j 2\n                                      for ((p (* p p)))\n     \
    \                                 (break (< (+ q j) n))))\n                  \
    \        when (odd? (- n j))]\n                        collect (cons m factors))])\n\
    \          (cond\n            ((empty? factors)\n             (largest_prime_factorize\
    \ n))\n            (else\n             (max (first factors)\n                \
    \  (cond\n                    ((empty? remainders)\n                     (first\
    \ factors))\n                    (else\n                     (first remainders)\n\
    \                     (largest_prime_factorize n))))))))\n  (largest_prime_factorize\
    \ n))\n", "  (define (largest_prime_factor! n max_factors)\n    (cond ((= n 1)\
    \ max_factors)\n          ((even? n) (largest_prime_factor! n (cons n (max_factors))))\n\
    \          (else (largest_prime_factor! n (cons n (max_factors))\n           \
    \                          (cons (car max_factors)\n                         \
    \                 max_factors)))))\n  (largest_prime_factor! n (list n)))\n",
  "  (if (<= n 1)\n      1\n      (if (odd? n)\n          (* 2 (largest_prime_factor\
    \ n-3))\n          (* 2 (largest_prime_factor n-2))))\n</cell>\n<cell>\n#lang\
    \ racket\n", "  (cond\n    ((zero? n) 0)\n    ((odd? n) (largest_prime_factor\
    \ (- n 2)))\n    ((even? n) (if (>= n 2) (largest_prime_factor (/ n 2)) n)))\n\
    \  (if (= (modulo n 2) 0)\n      (largest_prime_factor (/ n 2))\n      (largest_prime_factor\
    \ (+ (/ n 2) (modulo n 2)))))\n", "  (cond [(zero? n) 0]\n        [else (* 2 (largest_prime_factor\
    \ (- n 1)))]))\n", "  (define (prime_checker x y)\n    (= (remainder x y)\n  \
    \    (modulo (remainder x y) (* x y))))\n\n  (define (sieve_of_eratosthenes n)\n\
    \    (define (prime_sieve-check y)\n      (if (zero? y)\n          (empty-list)\n\
    \          (cond ((< y n) (prime_sieve-check (+ y 1))\n                 (if (prime-checker\
    \ y n)\n                     (cons (modulo (modulo n y) y) \n                \
    \          (prime_sieve-check y))\n                     (prime_sieve-check y))))))\n\
    \n    (prime_sieve-check 2))\n\n  (cond ((< n 1)\n         (error \"n must be\
    \ > 1\"))\n        (else (length (remove-if (lambda (x)\n                    \
    \                        (= (remainder n x) (modulo (modulo n x) x))) \n     \
    \                          (sieve_of_eratosthenes n))))))\n", "  (cond [(= n 1)\n\
    \         (/ n 2)\n         n]\n        [(odd? n)\n         (largest_prime_factor\
    \ n-1)]\n        [(even? (mod n 2))\n         (/ (quotient n 2)\n            (+\
    \ n (floor n (/ n 2))))\n         ]\n        [else\n         (largest_prime_factor\
    \ (quotient n 2))]\n        ))\n", "  (check-type n (bignum? bigint?))\n  (if\
    \ (is-prime? n)\n      (/ n 2)\n      (let ((factor (factor-count n)))\n     \
    \   (cond [(= factor 1) n]\n              [(= factor 2) (/ n 2)]\n           \
    \   [else (* n (/ factor 2))])))) ; recur until n >= 2\n</code>\nAs you can see,\
    \ this solution is very similar to yours, yet it uses a different algorithm. By\
    \ this I mean that instead of looking for factors using the recursive definition\
    \ of factors, we're using the iterative definition of the prime factorization\
    \ (by factor-count), which means that, instead of recurring until n is greater\
    \ than or equal to 1, we keep going until we find n has only a single factor.\n\
    If we look at the iterative definition of the prime factorization (by factor-count):\n\
    <code>", "  (define (largest-prime-factor factor n)\n    (if (= n 1)\n       \
    \ factor\n        (largest-prime-factor (* factor factor) (sub1 n))))\n  (largest-prime-factor\
    \ 2 n))\n", "  (cond [(= n 2) 2]\n        [(odd? n) (* n 2)]\n        [(= (quotient\
    \ n 3) (quotient (* n 4) 7)) (* n 3)]\n        [(= (quotient n 5) (quotient (*\
    \ n 7) (quotient (* n 7) 13))) (* n 5)]\n        [(= (quotient n 7) (quotient\
    \ (* n 9) (quotient (* n 9) 17))) (* n 7)]\n        [else (* n (largest_prime_factor\
    \ (quotient n 8)))]\n  )\n)\n\n#lang racket\n", "  (check-type n number)\n  (let\
    \ loop ((n n)\n             (largest 2)\n             (prime #f)\n           \
    \  (remainder 0))\n    (if (odd? n)\n        largest\n        (loop (quotient\
    \ n prime) (+ largest 1) prime (quotient n prime))))))\n", "  (let loop ((n n)\
    \ factors '())\n    (if (< n 1)\n        factors\n        (loop (sub1 n) (cons\
    \ (modulo n n) factors) '()))))\n", "  (let ([prime (prime-factors n)]\n     \
    \   [factor (first prime)])\n    (if (empty? factor)\n        n\n        (first\
    \ factor)))))", "  (cond [(= n 1) 1]\n        [(= (modulo n 2) 0) 2]\n       \
    \ [else (+ 1 (largest_prime_factor (quotient n 2)))]))\n", "  (let ([i (in-range\
    \ (floor n 2) (ceiling n 2))])\n    (if (is-prime i)\n      (/ (expt n i)\n  \
    \       (/ i 2))\n      (if (even? i)\n          (/ (expt n 2)\n             (/\
    \ i 2))\n          (/ (expt n 3)\n             (/ i 2))))))\n", "  (cond [(= n\
    \ 1) 1]\n        [(= n 2) 2]\n        [(= n 3) 3]\n        [(= n 4) (* n 4)]\n\
    \        [(= (expt (modulo (* n n) 2) 2) (modulo (* n n) 2)) n]\n        [else\
    \ (largest_prime_factor (/ n 2))]))\n", "  (cond (<???>                      \
    \    ; n is odd\n         <???>                          ; no such prime\n   \
    \      (else                         ; n is even\n          (cond (<???>     \
    \              ; n is prime\n                (???>                     ; no such\
    \ prime\n                  <???>                    ; no such prime\n        \
    \          <???>                    ; no such prime\n                  <???> \
    \                   ; no such prime)\n                (else                  \
    \ ; n is not prime\n                  (let ([x <???>])        ; smallest prime\
    \ factor\n                    (cond\n                      ((<???> * <???>) <???>)\
    \ ; is prime\n                      ((<???> * <???>) <???>) ; is prime\n     \
    \                 ((<???> * <???>) <???>) ; is prime\n                      ((<???>\
    \ * <???>) <???>) ; is prime\n                      (else                 ) ;\
    \ is not prime\n                      x))                     ; the smallest prime\
    \ factor is returned\n                    <???>)))                 ; the smallest\
    \ prime factor is returned\n          <???>                           ; n is prime\n\
    \          <???>                           ; no such prime\n          <???>  \
    \                         ; no such prime\n          <???>))                 \
    \       ; no such prime\n</#lang racket>\n", "  (if (= n 1)\n      1\n      (let\
    \ loop ((i (floor n 2)))\n        (if (even? i)\n            (loop (/ i 2))\n\
    \            (let ((m (floor (/ n i)))\n                  (m (+ (* m (largest_prime_factor\
    \ m))\n                        (/ n i))))\n              (if (> m n)\n       \
    \           m\n                  (loop (/ i 2)))\n              )))))\n", "  (if\
    \ (< n 1) \n      n\n      (let loop ((p 2) (f 1) (found #f) (i 0))\n        (cond\
    \ \n          ((= i n) (cons p f))\n          ((= (mod n p) 0) (loop (+ p 1) f\
    \ found (+ i 1)))\n          ((not found)\n           (loop (+ p 1) f (or (= (mod\
    \ n p) 0) found) (+ i 1)))\n          (else\n           (loop (+ p 2) f found\
    \ (+ i 1)))))))\n", "  (if (<= n 1)\n      n\n      (let loop ([factors (list\
    \ 1)]\n                 [n n])\n        (if (= n 1)\n            factors\n   \
    \         (if (is_prime n)\n                (loop (cons n factors)\n         \
    \             (/ n 2)))\n            (loop (cons n factors)\n                \
    \  (/ (+ n 1) 2))))))\n</code>\n<|/ a tags=racket,sieve,racket-student-languages\
    \ |>\n<| c |>\nYou will need to test if `factors` contains n and if n is prime.\
    \ This may take some work.\n<|/ c |>\n<| c |>\nI'm pretty sure that that test\
    \ would be a problem if I were to implement the Sieve of Eratosthenes.\n<|/ c\
    \ |>\n<| c |>\nYes, but your answer doesn't test that either.\n<|/ c |>\n<| c\
    \ |>\nI was hoping to show my thought process that I wasn't entirely sure about\
    \ this and how that could be tested in my answer. I will edit my answer to include\
    \ a test case, and thanks for pointing that out.\n<|/ c |>\n<| a |>\nHere is one\
    \ in Racket that uses lazy sequences and a list accumulator:\n<code>", "  (cond\
    \ ((= n 1) 1)\n        ((= n 2) 2)\n        ((> n 2)\n         (loop for i from\
    \ 2 to (expt n i)\n               with j = (expt n i)\n               while (<\
    \ j n / i) \n               for k = (expt n j)\n               while (< k n /\
    \ j) \n               while (= (* j k) n)\n               while (= (* i k) n)\n\
    \               for l = (expt n k)\n               while (< l n / k)\n       \
    \        while (= (* k l) n)\n               while (= (* j l) n)\n           \
    \    while (= (* i l) n)\n               for m = (expt n l)\n               while\
    \ (< m n / l)\n               while (= (* l m) n)\n               while (= (*\
    \ k m) n)\n               while (= (* j m) n)\n               while (= (* i m)\
    \ n)\n               break)\n         (* n (* i n))))))\n", "  (define (find n)\n\
    \    (let loop ((n n) (found (if (= n 1) 0 (+ 1 (/ (sub1 n) (floor n 2))))))\n\
    \      (if (<= n 1)\n          found\n          (loop (- n 1) found))))\n  (find\
    \ (- n 1)))\n</cell>\n<code language=dyalog-kernel>", "  (define (largest-prime-factor-helper\n\
    \           (primes-to-test max)\n           (tested-primes primes-to-test))\n\
    \    (if (< max primes-to-test)\n        (if (> tested-primes max)\n         \
    \   (largest-prime-factor-helper (+ max primes-to-test)\n                    \
    \                      (cons tested-primes primes-to-test))\n            (first\
    \ tested-primes))\n        (first tested-primes)))\n  (largest-prime-factor-helper\
    \ n '()))\n", "  (if (< n 2)\n      n\n      (let loop ([n n (factor 1) prime-factors\
    \ prime-factors-prime])\n        (if (> n 1)\n            (loop (quotient n factor)\
    \ (quotient n factor) (+ factor 1) (cons n prime-factors))\n            (if (equal?\
    \ prime-factors (empty-set))\n                prime-factors-prime\n          \
    \      (loop (quotient n factor) (quotient n factor) (+ factor 1) (cons n prime-factors))))))\n",
  "  (cond ((= n 1) 1)\n        ((= n 2) 2)\n        (else (max ((largest_prime_factor\
    \ (/ n 2))) (prime? n))))))\n</pre>\n</div>\n</div>\n<div id=\"outline-container-org764c99f\"\
    \ class=\"outline-3\">\n<h3 id=\"org764c99f\">Examples</h3>\n<div class=\"outline-text-3\"\
    \ id=\"text-org764c99f\">\n<pre class=\"example\">", "  (let loop ((factors ())\
    \ (n n) (i 2)) (\n    (cond ((= i n) 1)\n          ((not (odd? (modulo-by-one\
    \ n i))) (loop (cons i factors) n (+ i 1)))\n          ((even? (modulo-by-one\
    \ n i)) (loop (cons i factors) n (+ i 1)))\n          ((odd? (modulo-by-one n\
    \ i)) (loop (cons i factors) n (+ i 1)))\n          (else (loop (cons i factors)\
    \ n (+ i 1)))))\n  (first factors)))\n", "  (cond [(= n 1) 2]\n        [(= n 2)\
    \ 2]\n        [(= n 3) 3]\n        [(= n 5) (/ n 3)]\n        [else (let ((m (*\
    \ n (largest_prime_factor / n)))\n                    (l (* m (largest_prime_factor\
    \ / n))))\n              (if (<= l m)\n                  l\n                 \
    \ m))]))", "  (cond [(= n 1) 1]\n        [(even? n) (if (= (floor n 2) 1) 2 (*\
    \ 2 (largest_prime_factor (/ n 2))))]\n        [(odd? n) (if (= (floor n 2) 1)\
    \ 2 (* 2 (largest_prime_factor (/ n 2))))]\n        [else (if (= (floor n 2) 1)\
    \ 2 (* 2 (largest_prime_factor (/ n 2))))]))\n", "  (if (prime? n)\n      (let\
    \ ((next (largest_prime_factor (/ n 2)))\n            (r (quotient n next)))\n\
    \        (cond ((= r 2) next)\n              ((= r 1) 1)\n              ((= next\
    \ 2) 2)\n              ((= (quotient n next) 0) (- next 1))\n              (else\
    \ next))))\n</code>\nAnd that's about all there is to it. Here's a version that\
    \ outputs the prime factors in descending order:\n<code>", "  (define (find n\
    \ a b)\n    (if (= a b)\n        n\n        (if (= (remainder n a) 0)\n      \
    \      (find n (+ a 1) b)\n            (find n (+ a 1) (b / a)))))\n  (find n\
    \ (+ 1 n) (sqrt n)))\n", "  (cond [(= n 1) 1]\n        [(even? (modulo n 2)) (modulo\
    \ n 2)]\n        [else (let ([factors (largest_prime_factor (/ n 2))])\n     \
    \           (if (or (= 1 (length factors))\n                        (= 1 (modulo\
    \ n factors))\n                        (even? n))\n                    (first\
    \ factors)\n                    (let ([i (+ 1 (modulo n factors))])\n        \
    \              (cond [(even? (modulo n factors)) (modulo n factors)]\n       \
    \                     [(<= i factors) (first factors)]\n                     \
    \       [else (first factors)]))]\n        [(odd? n) (largest_prime_factor (-\
    \ n 1))]))\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 tags=scheme |>\nThis Scheme\
    \ code has O(1) performance, O(1) memory, and O(N) storage requirements:\n<code>",
  "  (let loop ((n n) (primes #{}))\n    (cond ((= n 1) (first primes))\n        \
    \  ((member n primes)\n           (loop (/ n primes) (conj primes n)))\n     \
    \     (else (loop (* n primes) (conj primes n))))))\n", "  (if (prime? n)\n  \
    \    (if (= n 1)\n          1\n          (* 2 (largest_prime_factor (/ n 2)))\n\
    \      )\n      1\n      ))\n", "  (cond [(= n 1) n]\n        [(= (modulo n 2)\
    \ 0) 1]\n        [(even? n) (largest_prime_factor (/ n 2))]\n        [else (if\
    \ (is_prime (modulo n 2))\n                  (largest_prime_factor (/ n 2))\n\
    \                  (+ 1 (largest_prime_factor (/ n 2))))]))\n", "  (cond [(= n\
    \ 1) n]\n        [(= (remainder (sqrt n) 2) 0) (* n (largest_prime_factor (/ n\
    \ 2)))]\n        [else (largest_prime_factor (/ n 2))]))\n", "  (if (prime? n)\n\
    \      (if (> (prime-factors n) 2)\n          (prime-factors n)\n        (largest_prime_factor\
    \ (/ (n 2) (prime-factors n))))\n      n))\n", "  (cond\n    ((= n 1) 1)\n   \
    \ ((or (divides? n 2)) 1)\n    ((prime? n) (if (= (sqr (+ n 1) 2) (+ n 1)) (sqr\
    \ (+ n 1) 2))))\n  (else (+ (largest_prime_factor (- n 1)) (if (> n (floor (sqrt\
    \ (- n 1)))\n                                        (sqrt (- n 1))\n        \
    \                                (- n 1))))))\n</code>\n<|/ a |>\n<| c |>\nI didn't\
    \ know that division was part of the Racket language and not just another language.\
    \ This was extremely helpful, thank you!\n<|/ c |>\n<| a |>\nI came here trying\
    \ to figure out how to find the largest prime factor of 13195 from Common Lisp.\
    \  I wanted to contribute a recursive solution.\nMy solution was to just divide\
    \ the number by each of the prime factors and see what number you get out of division.\
    \  The largest prime factor will be the highest number in the list of numbers\
    \ divided by the prime factor you see.\nHere is my solution in Common Lisp:\n\
    <code>", "  (let ((factors (loop for i from 2 upto (floor (/ n 2)) collect i))\n\
    \         ;; The prime factors of n are 2 and its multiple factors.\n        \
    \ ;; Find all these multiples and divide n by them.\n         (multiples (loop\
    \ from 2 collect (* i 2))))\n    (cond\n      [(> n 1)\n       (cond\n       \
    \  [(empty? factors) n]\n         [else (max 0 (max 1 (filter odd? factors)))])]\n\
    \      [else\n       (cond\n         [(empty? multiples) n]\n         [else (max\
    \ (largest_prime_factor (/ n multiples)) 0)]\n       )]))\n", "  (define (find-prime-factors\
    \ n factors)\n    (cond\n      [(= n 1)\n       (cond\n         [(prime? n) factors]]\n\
    \        [else (find-prime-factors (quotient n 2)\n                          \
    \  (cons n factors))]))\n  (find-prime-factors n '()))\n", "  (define (largest_prime_factor-loop\
    \ n primes)\n    (cond [(= n 1) '()]\n          [(prime-flag? n primes) n]\n \
    \         [else (largest_prime_factor-loop (- n 1) (cons n primes))]))\n  (largest_prime_factor-loop\
    \ n '()))\n", "  (cond [(= n 1) n]\n        [(prime? n) (/ (quot n 2) 2)] [else\
    \ (largest-prime-factor (quotient n 2)))]))\n", "  (cond\n    ((= n 1) 2)\n  \
    \  ((even? n) n)\n    ((= (% n 3) 0) (/ n 3))\n    ((= (% n 5) 0) (/ n 5))\n \
    \   ((= (% n 7) 0) (/ n 7))\n    ((= (% n 11) 0) (/ n 11))\n    ((= (% n 13) 0)\
    \ (/ n 13))\n    ((= (% n 17) 0) (/ n 17))\n    ((= (% n 19) 0) (/ n 19))\n  \
    \  ((= (% n 23) 0) (/ n 23))\n    ((= (% n 29) 0) (/ n 29))\n    ((= (% n 31)\
    \ 0) (/ n 31))\n    ((= (% n 37) 0) (/ n 37))\n    ((= (% n 41) 0) (/ n 41))\n\
    \    ((= (% n 43) 0) (/ n 43))\n    ((= (% n 47) 0) (/ n 47))\n    ((= (% n 53)\
    \ 0) (/ n 53))\n    ((= (% n 59) 0) (/ n 59))\n    ((= (% n 61) 0) (/ n 61))\n\
    \    ((= (% n 67) 0) (/ n 67))\n    ((= (% n 71) 0) (/ n 71))\n    ((= (% n 73)\
    \ 0) (/ n 73))\n    ((= (% n 79) 0) (/ n 79))\n    ((= (% n 83) 0) (/ n 83))\n\
    \    ((= (% n 89) 0) (/ n 89))\n    ((= (% n 91) 0) (/ n 91))\n    ((= (% n 97)\
    \ 0) (/ n 97))\n    ((= (% n 101) 0) (/ n 101))\n    ((= (% n 107) 0) (/ n 107))\n\
    \    ((= (% n 113) 0) (/ n 113))\n    ((= (% n 119) 0) (/ n 119))\n    ((= (%\
    \ n 121) 0) (/ n 121))\n    ((= (% n 127) 0) (/ n 127))\n    ((= (% n 131) 0)\
    \ (/ n 131))\n    ((= (% n 137) 0) (/ n 137))\n    ((= (% n 143) 0) (/ n 143))\n\
    \    ((= (% n 149) 0) (/ n 149))\n    ((= (% n 151) 0) (/ n 15", "  (define primes\n\
    \    (lambda () (prime-factors n)))\n  (define (largest_prime_factor-helper)\n\
    \    (let ([next-prime (primes)])\n      (cond [(null? next-prime) n]\n      \
    \      [else (max (largest_prime_factor-helper (* n next-prime))\n           \
    \            (largest-prime-factor-helper next-prime))])))\n  (largest_prime_factor-helper))\n",
  "  (if (> n 2)\n      n\n      (loop for i from 2 to n\n             when (composite?\
    \ n)\n             collect i\n             else return)))\n", "  (cond [(< n 2)\n\
    \         2]\n        [else\n         (define (largest_prime_factor-aux (n p)\n\
    \                                 (if (prime? p)\n                           \
    \          (cons p\n                                           p)\n          \
    \                           (cons n\n                                        \
    \   n))\n                               (largest_prime_factor-aux (/ n p)\n  \
    \                                                   (if (prime? p)\n         \
    \                                                (+ 1 (/ p 2))\n             \
    \                                            (+ 1 (/ p 3)))))\n           (largest_prime_factor-aux\
    \ n 2)])\n</code>\n<|/ a tags=racket,scheme,prime-factoring |>\n<| c |>\nThank\
    \ you for your contribution. Since you seem to be a well-versed Scheme/Racket\
    \ user, would you consider a solution that uses tail-call optimization (`#lang\
    \ racket`) better than my attempt? I wonder how it compares in terms of performance.\
    \ I guess that you say that my attempt would not be \"effective\", but I'd like\
    \ to know why since I'm new to Scheme and Racket and my attempt would seem too\
    \ \"heavy\". Thank you again.\n<|/ c |>\n<| a |>\n<code>", "  (cond [(= n 2)\n\
    \         (- n 1)]\n        [else\n         (let ((p (+ n 1)))\n           (cond\
    \ [(> p 3)\n                  (if (= (modulo n p)\n                         p)\n\
    \                      p\n                      (+ n 1))]\n                 [else\n\
    \                  (largest_prime_factor p)]))]))\n", "  (loop [i 2]\n       \
    \ (if (> n 2)\n            2\n            (if (not (prime? i))\n             \
    \   i\n              (loop (+ i 1) (+ i 1)))\n            (if (= (modulo (expt\
    \ n i) i) 0)\n                i\n              (loop (+ i 1) (+ i 1))))))\n",
  "  (let loop ((factors ()))\n    (cond ((= n 1)\n           (list-ref factors 0))\n\
    \          ((zero? (modulo n x))\n           (loop (cons (modulo n x) factors)))\n\
    \          (else\n           (loop (cons (quotient n x) factors))))\n    (loop\
    \ (reverse-seq factors))))\n", "  (if (= n 1)\n      1\n      (let loop ((factors\
    \ (make-vector n (lambda (x) (<= x 1)))))\n        (cond ((= n 2)\n          \
    \     (cond ((= (vector-ref factors 0) 2) 2)\n                     ((<= (vector-ref\
    \ factors 0) 2) (vector-ref factors 0))))\n              ((vector-ref factors\
    \ 0)\n               (loop (vector-set! factors (vector-ref factors 1) (lambda\
    \ (x) (< x n)))))\n              ((not (vector-ref factors 0))\n             \
    \  (loop (vector-set! factors (vector-ref factors 1) (lambda (x) (> x 1)))))))))\n\
    </cell>\n<text>\nExercises\nCreate a procedure that returns the greatest common\
    \ denominator of two numbers. You may use either of the following definitions:\n",
  "  (let loop ((n n) (prime 1))\n    (cond\n      [(= n 1)\n       prime]\n     \
    \ [(prime? prime)\n       (loop (quotient n prime) prime)]\n      [(divides? n\
    \ prime)\n       (loop (quotient n prime) (* prime prime))]\n      [(= 0 (remainder\
    \ n prime))\n       (loop (quotient n prime) prime)]\n      [(= 1 (remainder n\
    \ prime))\n       (loop (quotient n prime) (* prime prime))]\n      [else\n  \
    \     (loop (quotient n prime) (* prime prime))]))\n</code>\nA couple of things\
    \ to note:\nFirst, I renamed your prime? function to prime? because it is more\
    \ idiomatic and thus less likely to get confused with a built-in primitive function.\n\
    Second, the divides? function is more general than your isPrime function, because\
    \ it will take care of the case where n is a multiple of prime. For example, if\
    \ the number is 5, the largest prime factor is 2.\nFinally, I changed loop to\
    \ use a tail recursive loop, which is a common idiom in Racket (and many other\
    \ functional languages). It's more idiomatic and it means we don't have to allocate\
    \ a new stack frame every time we call the function because we're using the same\
    \ stack frame as the calling function.\nThis program is also quite short and simple\
    \ in terms of complexity. Of course, we're doing an exponential number of tests,\
    \ so it's not very efficient. One way to improve this is to only test a number\
    \ with prime factors up to some upper bound (e.g., prime factors up to 10 or 100).\
    \ You'd have to play around with the value of prime until you get it right for\
    \ most numbers.\n<|/ a tags=racket,primes dscore=1 |>\n<| a dscore=0 |>\nThis\
    \ is very similar to the second answer, but I think it is much easier to read.\
    \  It uses lazy evaluation, and I think it is easier to read.  You can easily\
    \ change it to a recursive solution.\n<code>", "  (cond ((= n 1) (expt 2 1))\n\
    \        ((= (expt n 1) 1) n)\n        ((<= (expt n 1) (expt (- n 1) 2)) (expt\
    \ n 1))\n        (else (largest_prime_factor (- n 1)))))\n</code>\nIt works by\
    \ simply checking if n is a prime before trying all its multiples. If n is a prime\
    \ we immediately return the value. \nIf n is not a prime we decrease the number\
    \ by 1 until it is one. Then we try all its multiples again. \nIf n is a composite\
    \ we decrease the number by 1 until it is prime. Then we try all its multiples\
    \ again. \nIf n is a composite or it's less than two it's prime and we return\
    \ it. If n is less than two and it's even it's not a prime.\n<|/ a tags=lisp,racket\
    \ |>\n<| c |>\nI believe the `expt n 1)` is supposed to be `expt n 2)`\n<|/ c\
    \ |>\n<| c |>\nThanks, fixed.\n<|/ c |>\n<| a tags=lisp,racket |>\nThis could\
    \ be a possible implementation without using any built-in functions or modules.\
    \ It could be helpful for others as well.\n<code>", "  (cond [(= n 2)\n      \
    \   (/ n 2)]\n        [(even? n)\n         (/ n 2)]\n        [else\n         (let\
    \ ([factor (floor (/ n 2))])\n           (if (= factor 2)\n               (largest_prime_factor\
    \ (- n factor))\n               (* factor largest_prime_factor))))]))\n", "  (cond\n\
    \    [(= n 1) n]\n    [(even? n) (/ n 2)]\n    [(even? (/ n 2)) (+ 1 (largest_prime_factor\
    \ (/ n 2)))]))\n", "  (let* ((primes (sieve (- n 1))))\n    (cond (<???)\n   \
    \       (largest_prime_factor n)))\n  ))", "  (assert (and (integer? n) (not (prime?\
    \ n))))\n  (let loop ((n n) (prime false) (i 1))\n    (cond ((= i n) prime)\n\
    \          ((< i n) (loop (quotient n i) prime (+ i 1)))\n          ((= (modulo\
    \ n prime) 0) (loop (quotient n prime) true (+ i 1)))\n          (else (loop (quotient\
    \ n prime) true i)))))\n", "  (cond ( (= n 1) 0)\n        ((= n 2) 2)\n      \
    \  (else (let ((p (prime-factor-iter n)))\n                  (cond ( (null? p)\
    \ n)\n                        (else (let ((x (car p)))\n                     \
    \           (cond ((= x 1) n)\n                                      ((even? x)\
    \ (inc x))\n                                      ((odd? x) (inc (* x x)))\n \
    \                                     (else (if (= x (car p)) (inc (car p)) (inc\
    \ (* x x))))))))))))\n", "  (cond [(= n 1) 2]\n        [(even? n) (* 2 n)]\n \
    \       [else (let ((l (largest_prime_factor (/ n 2))))\n                  (if\
    \ (= l 2)\n                      n\n                      (* l l)))]))\n", " \
    \ (define (next_prime number)\n    (let ([next (ceiling number)])\n      (if (zero?\
    \ next)\n          next\n          (next_prime (floor next)))))\n  (cond [(< n\
    \ 1) n]\n        [(= (mod n 2) 0) (largest_prime_factor n)]\n        [else (next_prime\
    \ (sqrt n))]))\n", "  (cond [(= n 1)\n         1]\n        [(even? (modulo-by-two?\
    \ n 2))\n         2]\n        [(odd? (modulo-by-two? n 2))\n         (largest_prime_factor\
    \ (quotient-by-two? n 2))]))\n", "  (if (<= n 2)\n      n\n      (loop\n     \
    \    for i from 2 to (integer-part (sqrt n)) #:when (= (modulo n i) 0)\n     \
    \    collect (quotient n i))))\n</code>\n<|/ a tags=racket,functional-programming,sieve-of-eratosthenes,scheme\
    \ |>\n<| a dscore=0 |>\nA very simple functional programming solution:\n<code>",
  "  (let loop ((n n) (result 1))\n    (if (= n 1)\n        result\n        (loop\
    \ (quotient n result) (if (prime? (* n result)) result result)))))\n", "  (cond\
    \ [(= n 1) 1]\n        [(= (modulo (expt n 2)) n) (quotient n 2)]\n        [else\
    \ (largest_prime_factor (quotient n 2))]))\n", "  (if (prime? n)\n      (let ((primes\
    \ (primes (+ 1 n))))\n        (cond\n          [(empty? primes) n]\n         \
    \ [else (max_by (lambda (x) (prime? (- n x))) primes)]\n        ))\n      n))\n",
  "  (let loop ((n n) (factors '()))\n    (cond [(= n 1) (first factors)]\n      \
    \    [(null? (rest n)) (last factors)]\n          [else (loop (rest n) (append\
    \ factors (list (first n))))])))\n", "  (if (= n 2)\n      2\n      (let loop\
    \ ((next (floor (log* n 2)))\n                (factors (list-of (quotient n next)\
    \ (quotient next 2)))\n                (i 0))\n        (if (= i factors)\n   \
    \         next\n            (loop (+ next (list-ref factors (- i 1))) factors\
    \ (+ i 1))))))\n", "  (let loop ((i 2)\n             (factors '(2)))\n    (if\
    \ (< i n)\n        (if (is-prime i)\n            (loop (+ i 2) (cons i factors))\n\
    \            factors))))\n", "  (assert (and (integer? n) (> n 1)))\n  (define\
    \ (largest_prime_factor-aux (n)\n    (cond [(= n 1) n]\n          [(not (prime?\
    \ n)) n]\n          [(= (remainder n 2) 0) (largest_prime_factor-aux (/ n 2))]\n\
    \          [else (+ n (largest_prime_factor-aux (quotient n 2))\n            \
    \        (largest_prime_factor-aux (/ n 2))))))\n  (largest_prime_factor-aux n))\n",
  "  (let ((factors ())\n        (primes '()))\n    (loop\n       :break (equal? (rem\
    \ n 2)) ; prime number\n       :for x below n\n       :while (>? x n)\n      \
    \ :do (pushnew x (append factors primes))\n       :finally (return (apply max\
    \ (append primes (reverse factors)))))))\n", "  (define (largest_prime_factors\
    \ n prime)\n    (cond [(= n 1) prime]\n          [else (largest_prime_factors\
    \ (/ n prime)\n                                  (+ prime (gcd n prime)))]))\n\
    \  (largest_prime_factors n 1))\n", "  (define (next_prime prime)\n    (define\
    \ (next_factor factor)\n      (cond ((= factor prime) (+ prime factor))\n    \
    \        ((< factor prime) (next_prime prime))\n            (else factor)))\n\
    \    (cond ((< n prime) (next_prime prime))\n          ((< n 1) (next_prime 2))\n\
    \          (else (next_prime (next_factor (next_prime (next_factor n))))))\n \
    \ (nth (next_prime prime) n))", "  (largest_prime_factor-iter n 2))\n", "  (define\
    \ (iter n)\n    (if (= n 1)\n        1\n        (if (= (mod n n) 0)\n        \
    \    (iter (/ n n))\n            (+ n (iter (/ n n))))))\n  (iter n))\n", "  (cond\
    \ (\n       ((= n 1) n)\n       ((= n 2) 2)\n       ((= n 3) 2)\n       ((= n\
    \ 5) (round (/ n 2)))\n       ((prime? (modulo n 2))\n        (round (/ n 3)))\n\
    \       (else\n        (let ((f (largest_prime_factor (modulo n 2)))\n       \
    \        (factors (list f)))\n          (loop\n             for i below n\n  \
    \           for j = (+ 1 i)\n             while (>= j i)\n             do\n  \
    \           (set! factors (append (list (modulo i j))\n                      \
    \              factors))\n             (set! i (+ j 1))\n             until (prime?\
    \ (modulo i f)))\n          factors))))\n</code>\n<|/ a tags=scheme,racket dscore=0\
    \ |>\n<| a dscore=0 |>\nThe Scheme way is very simple.\n<code>", "  (let loop\
    \ ((n n)\n             (max 0))\n    (cond [(= n 1) max]\n          [(zerop n)\
    \ (error \"Can't find largest prime factor of ~D.\" n)]\n          [(even? n)\
    \ (loop n (add1 max))]\n          [else (loop (quotient n 2) (min max n))]\n \
    \         )))\n", "  (define (largest_prime_factor-inner a b c)\n    (if (zero?\
    \ a) (max (c b) 1) (max (c (* a b)) (largest_prime_factor-inner (+ a 1) b (* a\
    \ c))))\n    (if (< b n) (largest_prime_factor-inner 1 (+ b 1) c)\n      1)))\n\
    \  (largest_prime_factor-inner 2 3 n))\n", "  (let ((isprime #t))\n    (cond [(=\
    \ n 1)\n           (if (= n 2)\n               n\n               (* 2 2))]\n \
    \         [(not (= n 1))\n           (let ((factor (+ 1 (prime-factors n))))\n\
    \             (when (and (< n (* factor factor))\n                      (not (odd?\
    \ (* n factor))))\n               (begin\n                 (set! isprime #f)\n\
    \                 (return factor)))]\n          [else\n           (largest_prime_factor\
    \ (/ n 2))]\n          [else\n           (largest_prime_factor (* 2 (+ 3 (largest_prime_factor\
    \ (/ n 3)))))])))\n", "  (cond [(= n 1) 2]\n        [(= (gcd n 2)) 2]\n      \
    \  [else\n         (let ([factors (factor-range (* 2 (+ n 1))) (smallest (min\
    \ factors (- n 1)))]\n               [largest (max factors (- n 1))])\n      \
    \     (cond [(< largest smallest) smallest]\n                 [(< smallest largest)\
    \ largest]\n                 [else (largest_prime_factor smallest)]))]))\n", " \
    \ (if (= n 1)\n      n\n      (if (prime? n)\n          (if (= (expt n 2) 2)\n\
    \              n\n              (largest_prime_factor (/ n 2)))\n          (largest_prime_factor\
    \ (expt n 2))))))\n", "  (cond [(= n 2) 2]\n        [(= n 3) 3]\n        [else\
    \ (largest_prime_factor (/ n 2))]))\n", "  (cond ((or (= n 1) (prime? n))\n  \
    \       n) (else\n           (let ((primes (find-prime n)))\n             (cond\
    \ ((null? primes)\n                    (error \"No prime factors found\"))\n \
    \                  (else (max primes (- n primes))))))))\n", "  (check-positive-integer\
    \ n)\n  (check-positive-integer n)\n  (cond [(= 1 (remainder n 2)) (- n 1)]\n\
    \        [(= 1 (remainder n 3)) (- n 2)]\n        [else n]))\n", "  (cond [(=\
    \ n 1) 2]\n        [(= n 2) 3]\n        [else (let [factors (prime_factors n)]\n\
    \                (cond [(empty? factors) n]\n                      [(= (first\
    \ factors) n) (largest_prime_factor n)]\n                      [else (+ (first\
    \ factors) (largest_prime_factor n))])))]))\n", "  (if (prime? n)\n      (if (zero?\
    \ (remainder n 2))\n          n\n          (cond ((> n (/ n 2))\n            \
    \     (largest_prime_factor (/ n 2)))\n                ((not (zero? (remainder\
    \ n 3)))\n                 (largest_prime_factor (/ n 3)))\n                (else\
    \ (largest_prime_factor (/ n 2))))))\n          1))\n", "  (define (helper n prime-factors\
    \ prime)\n    (cond [(= n 1) (if (< prime 2) prime prime)]\n          [(= n 2)\
    \ (if (< prime 3) prime prime)]\n          [else (helper (- n 1) (cons prime prime-factors)\
    \ (+ prime 2))]))\n  (helper n '() 0))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
