name: HumanEval_18_how_many_times
language: rkt
prompt: "#lang racket\n\n;; Find how many times a given substring can be found in\
  \ the original string. Count overlaping cases.\n;; >>> (how_many_times \"\" \"a\"\
  )\n;; 0\n;; >>> (how_many_times \"aaa\" \"a\")\n;; 3\n;; >>> (how_many_times \"\
  aaaa\" \"aa\")\n;; 3\n(define (how_many_times string substring)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate how_many_times))\n\
  \    (check-equal? (candidate \"\" \"x\") 0)\n    (check-equal? (candidate \"xyxyxyx\"\
  \ \"x\") 4)\n    (check-equal? (candidate \"cacacacac\" \"cac\") 4)\n    (check-equal?\
  \ (candidate \"john doe\" \"john\") 1)\n))\n\n(test-humaneval)"
completions: ["  (define (how_many-times string substring start end)\n    (cond ((and\
    \ (not (= start end)) (string= substring (reverse substring))) (+ start end))\n\
    \          ((= start end) (+ start end))\n          ((not (empty? substring))\
    \ (how_many-times string substring (+ start 1) end))\n          ((string= substring\
    \ (reverse substring)) (+ start end))\n          ((string= substring substring)\
    \ (+ start end))\n          (else 0))\n  )\n  (how_many-times string substring\
    \ 0 string-length string)\n)\n", "  (define (how-many s len)\n    (cond ((string=?\
    \ s substring) (+ len 1))\n          ((string=? (substring s) substring) (how-many\
    \ (substring s) len))\n          ((null? s) (how-many substring len))\n      \
    \    (else 0)))\n  (how-many string 0))\n", "  (length\n   (remove-if (lambda\
    \ (c) (string-equal? c (string-downcase substring)))\n               (string-split\
    \ string #\\)))) ; <<<\n</code>\n<|/ a |>\n<| c |>\nYour solution only works for\
    \ characters, not for substrings (\"a\" and \"b\" would fail).\n<|/ c |>\n<| c\
    \ |>\nI assumed that, but it's good to know I'm wrong.\n<|/ c |>\n<| c |>\nI thought\
    \ it was a general solution, no?\n<|/ c |>\n<| c |>\nI misread your original comment.\
    \ It wasn't clear that you wanted to count overlapping substrings. I just thought\
    \ you wanted to count how many times two characters occurred in one string. Is\
    \ that not correct?\n<|/ c |>\n<| c |>\nNo, I meant that your solution doesn't\
    \ work with substrings, it only works characters. So \"a\", \"b\" and \"aaaa\"\
    \ would return 3 but \"aaaa\", \"a\", \"b\" and \"aaaa\" would return 3.\n<|/\
    \ c |>\n<| a tags=racket,scheme dscore=0 |>\nHere is an implementation based on\
    \ answer:\n<code>\n#lang racket\n", "  (define (loop a result start end)\n   \
    \ (cond\n      [(or (string=? a substring) (string=? substring a)) result]\n \
    \     [else (loop (cdr a) (incf result) (+ start end) start)])\n  (loop string\
    \ 0 0 (length string)))\n</cell>\n<cell>\n#lang racket\n", "  (cond\n    ((empty?\
    \ string) 0)\n    ((equal? (char-ref string 0) (substring 0)) 0)\n    (else (+\
    \ (+ (char-ref string 0) (substring 0)) \n           (how_many_times (cdr string)\
    \ (substring 1)))))\n", "  (cond\n    ((empty? string) 0)\n    ((eq? substring\
    \ \"\") 0)\n    ((eq? substring (first string)) 1)\n    ((eq? (first string) substring)\
    \ (+ 1 how_many_times (rest string) (first substring)))\n    (else (+ how_many_times\
    \ (rest string) (first substring)))))\n", "  (let ((result 0)\n        (cs (string->chars\
    \ string))\n        (s (string->chars substring)))\n    (cond ((or (string->length\
    \ string) (string->length substring)) 0)\n          ((char=? (first cs) (first\
    \ s)) 1)\n          ((char=? (first cs) (string-ref s (- 1 (char-index cs (first\
    \ s))))) 1)\n          ((char=? (first s) (string-ref cs (- 1 (char-index s (first\
    \ s))))) 1)\n          (else\n           (add1 (how_many_times (substring (rest\
    \ s)) substring))\n           result))))\n", "  (let-values ((times '() (memv\
    \ string substring 0)))\n    (if (memv string substring 0)\n        (+ times)\n\
    \        (memv string substring 1))))\n", "  (let ((matches-found 0))\n    (loop\
    \ for char across string\n          for pattern across (substring (string-length\
    \ substring) 0 substring)\n          for i from 0\n          for j from 0\n  \
    \        for match across (pattern (length pattern))\n          until (char=?\
    \ char match) (when (char=? char #\\space) (break))\n          for match-count\
    \ from 0\n          for found-count from 0\n          until (char=? char match)\
    \ (when (char=? char #\\space) (break))\n          (when (char=? char #\\space)\
    \ (continue)\n            (when (= i 0) (when (char=? char (string-ref string\
    \ 0)) (inc! found-count))\n            (when (char=? char (string-ref string 1))\
    \ (dec! found-count))\n            (when (char=? char (string-ref string 2)) (dec!\
    \ found-count))\n            (when (char=? char (string-ref string 3)) (dec! found-count))\n\
    \            (when (char=? char (string-ref string 4)) (dec! found-count))\n \
    \           (when (char=? char (string-ref string 5)) (dec! found-count))\n  \
    \          (when (char=? char (string-ref string 6)) (dec! found-count))\n   \
    \         (when (char=? char (string-ref string 7)) (dec! found-count))\n    \
    \        (when (char=? char (string-ref string 8)) (dec! found-count))\n     \
    \       (when (char=? char (string-ref string 9)) (dec! found-count))\n      \
    \      (when (char=? char (string-ref string 10)) (dec! found-count))\n      \
    \      (when (char=? char (string-ref string 11)) (dec! found-count))\n      \
    \      (when (char=? char (string-ref string 12)) (dec! found-count))\n      \
    \      (when (char=? char (string-ref string 13)) (dec! found-count))\n      \
    \      (when (char=? char (string-ref string 14)) (dec! found-count))\n      \
    \      (when (char=? char (string-ref string 15)) (dec! found-count))\n      \
    \      (when (char=? char (string-ref string 16)) (dec! found-count))\n      \
    \      (when (char=? char (string-ref string 17)) (dec! found-count))\n      \
    \      (when (char=? char (string-ref string 18)) (dec! found-count))\n      \
    \      (when", "  (cond ((or (null? string) (null? substring))\n         0)\n\
    \        ((equal? (substring 0) (string))\n         1)\n        ((equal? (substring\
    \ 0) (string))\n         (+ 1 0))\n        ((equal? (substring 0) (substring 1))\n\
    \         (how_many_times (substring 1) (string))\n         (+ 1 0))\n       \
    \ ((equal? (substring 0) (substring 1))\n         (how_many_times (substring 1)\
    \ (string))\n         (+ 1 0))\n        ((equal? (substring 0) (substring 1))\n\
    \         (how_many_times (substring 1) (string))\n         (+ 1 0))\n       \
    \ ((equal? (substring 0) (substring 1))\n         (how_many_times (substring 1)\
    \ (string))\n         (+ 1 0))\n        ((equal? (substring 0) (substring 1))\n\
    \         (how_many_times (substring 1) (string))\n         (+ 1 0))\n       \
    \ ((equal? (substring 0) (substring 1))\n         (how_many_times (substring 1)\
    \ (string))\n         (+ 1 0))\n        ((equal? (substring 0) (substring 1))\n\
    \         (how_many_times (substring 1) (string))\n         (+ 1 0))\n       \
    \ ((equal? (substring 0) (substring 1))\n         (how_many_times (substring 1)\
    \ (string))\n         (+ 1 0))\n        ((equal? (substring 0) (substring 1))\n\
    \         (how_many_times (substring 1) (string))\n         (+ 1 0))\n       \
    \ ((equal? (substring 0) (substring 1))\n         (how_many_times (substring 1)\
    \ (string))\n         (+ 1 0))\n        ((equal? (substring 0) (substring 1))\n\
    \         (how_many_times (substring 1) (string))\n         (+ 1 0))\n       \
    \ ((equal? (substring 0) (substring 1))\n         (how_many_times (substring 1)\
    \ (string))\n         (+ 1 0))\n        ((equal? (substring 0) (substring 1))\n\
    \         (how_many_times (substring 1) (string))\n         (+ 1 0))\n       \
    \ ((equal? (substring 0) (substring 1))\n         (how_many_times (substring 1)\
    \ (string))\n         (+ 1 0))\n        ((equal? (substring 0) (substring 1))\n\
    \         (how_many_times (substring 1) (string))\n         (+ 1 0))\n       \
    \ ((equal? (substring 0) (substring 1))\n         (how_many_", "  (length (remove-if-not\
    \ (lambda (x) (equal? x (string-to-symbol substring))) (string-to-list string))))\n",
  "  (define (check substring string found)\n    (cond\n      [(string=? substring\
    \ string) found]\n      [(string=? (substring string) string) (+ found 1)]\n \
    \     [else (check substring (substring string) (+ found 1))]))\n  (if (string=?\
    \ substring \"\")\n      (length string)\n      (check substring string 0)))\n",
  "  (cond\n    ((empty? string) 0)\n    ((equal? substring \"\") 0)\n    ((equal?\
    \ substring (rest string)) 0)\n    (else (+ (count_overlapping_characters string\
    \ substring) (how_many_times (rest string) substring)))))\n", "  (cond ((= string\
    \ \"\")\n         (if (> substring \"\") (length (substring \"\")) 0))\n     \
    \   ((equal? (substring \"\") \"\")\n         (length string))\n        ((equal?\
    \ (substring \"\") substring)\n         (length string))\n        ((equal? (substring\
    \ \"\") (substring \"\"))\n         (length string))\n        (else\n        \
    \ (+ 1 (how_many_times (substring \"\") (substring \"\"))))))", "  (let loop ((i\
    \ 0)\n             (count 0))\n    (cond ((eq? i (string-length string))\n   \
    \        (+ count 1))\n          ((eq? (string-ref string i) substring)\n    \
    \       (loop (+ i 1)\n                 (+ count 1)))\n          ((eq? (string-ref\
    \ string i) substring (+ i 1))\n           (loop (+ i 1)\n                 (+\
    \ count (- count 1))))\n          (else (loop (+ i 1)\n                      (+\
    \ count (- count 1))))))\n  )\n", "  (define index (string-index string substring))\n\
    \  (if (not (number? index))\n      0\n      (+ 1 (how_many_times (string-slice\
    \ string 0 (- index 1)) substring)\n           (how_many_times (string-slice string\
    \ index (string-length string))\n                          substring))))\n", " \
    \ (count (substring (string 0))\n         (substring (string 1))\n         (substring\
    \ (string 2)))\n  )\n", "  (define (helper start end substring counter)\n    (cond\n\
    \      [(zero? end) counter]\n      [(equal? substring (substring start end))\
    \ (helper (+ start 1) end substring (incf counter))]\n      [(> start end) counter])\n\
    \  (helper 0 string.length substring 0))\n", "  (cond ((equal? string \"\")\n\
    \         0)\n        ((equal? substring \"\")\n         0)\n        ((equal?\
    \ (string-length string) (string-length substring))\n         0)\n        ((equal?\
    \ (string->list string) (string->list substring))\n         (string-count string\
    \ substring))\n        (else\n         (let ((len (string-length string))\n  \
    \            (count\n               (if (string->null? string)\n             \
    \     0\n                  (loop for i from 0 to (+ len 1)\n                 \
    \        collect (+ (how_many_times (string-ref string i)\n                  \
    \                       (string-ref substring i)))))))\n           (cond\n   \
    \          ((> len 0)\n              (if (string->null? substring)\n         \
    \         0\n                  count))\n             ((equal? len (string-length\
    \ substring))\n              (if (string->null? substring)\n                 \
    \ 0\n                  count))\n             (else\n              (if (string->null?\
    \ substring)\n                  0\n                  (cond ((equal? len (string-length\
    \ string))\n                         (if (string->null? string)\n            \
    \                 0\n                             count))\n                  \
    \      (else (+ count (string-length substring)))))\n              (if (string->null?\
    \ string)\n                  0\n                  (+ count (string-length substring))))))\
    \ ))\n", "  (let loop ((count 0)\n             (chars (string-chars string)))\n\
    \    (cond\n      ((= (length chars) 0) count)\n      ((string-equal? (substring\
    \ (car chars)) (string-chars (substring-string string (car chars)))) (incf count))\n\
    \      ((= (char-ref chars 0) (length substring)) (incf count))\n      (else (loop\
    \ (+ count (loop (+ 1 chars)\n                                    (string-tail\
    \ string))))))))\n", "  (let loop ((i 0)\n             (count 0))\n    (cond\n\
    \      [(empty? string) count]\n      [(equal? (char-ref string i) substring)\n\
    \       (loop (+ i 1)\n             (add1 count))]\n      [(char-ref string i)\n\
    \       (loop (+ i 1)\n             (add1 count))]))\n</code>\n<|/ a tags=racket,scheme\
    \ |>\n<| c |>\nI did this but i got this error:\n<|/ c |>\n<| c |>\n: This code\
    \ doesn't have any errors. The problem was that you called your procedure with\
    \ `(how_many_times \"a\" \"a\")`. Try to use `()` to make it work. See the [documentation](https://docs.racket-lang.org/reference/procedures.html#%28def._%28%28lib._lang%2Fracket%2Fprivate%2Fstring..rkt%29._how_many_times%29%29).\n\
    <|/ c |>\n<| c |>\nI have changed the name of the procedure to something else\
    \ and it worked. I think it was something with the name because I used the same\
    \ name but now it worked.\n<|/ c |>\n<| a tags=racket,scheme |>\nHere's an answer\
    \ that will work:\n<code>", "  (if (string-empty? string)\n      0\n      (let\
    \ ((count 0))\n        (if (string-empty? substring)\n            count\n    \
    \        (if (equal? (string- car substring) (char-code (string- cdr string)))\n\
    \                count\n                (count (+ count 1))))))\n", "  (if (string-length\
    \ = string) 0\n      (let ((pos (string-index string substring)))\n        (if\
    \ (< pos 0)\n            0\n            (+ 1 (how_many_times string (substring\
    \ (string-tail string))))))))\n", "  (length (string-count string substring)))\n",
  "  (length string))\n", "  (cond [(null? string) 0]\n        [(null? substring)\
    \ 0]\n        [(string-equal? (substring-at (string-length string) 0) substring)\
    \ (+ 1 (how_many_times (string-tail string) substring))])\n)\n", "  (let loop\
    \ ((count 0) (strings string) (substring substring))\n    (if (null? strings)\n\
    \        count\n        (loop (+ count (find-index (char-at (first strings) (first\
    \ (rest strings))) substring))\n               (rest strings)\n              \
    \ (rest substring))))))\n", "  (let ((c (length string))\n        (count 0))\n\
    \    (while (> count c)\n      (let ((i (string-index string substring)))\n  \
    \      (set! count (+ count 1))\n        (set! string (substring 0 (+ i c)))))\n\
    \    count))\n", "  (cond\n    [(equal? string \"\") 0]\n    [else\n     (let\
    \ ((len (string-length string)))\n       (if (<= len 1)\n          0\n       \
    \   (+ (* (- len 1) (- how_many_times (string-tail string) substring) (string-index\
    \ string substring))\n             (how_many_times (string-tail string) substring))))]))\n",
  "  (length (string-match substring string)))\n", "  (let ([i 0])\n    (for/fold\
    \ ([i 0]) (count 0)\n      (if (equal? substring #\\a)\n          (set! i (+ i\
    \ 1))\n        (if (equal? (substring string i) string)\n            (set! i (+\
    \ i 1))\n          (if (equal? (substring string i) substring )\n            (set!\
    \ i (+ i 1))\n          (set! i (+ i 1)))))\n    i))\n", "  (define (how_many\
    \ count substring)\n    (cond\n      [(empty? substring) count]\n      [(eq? (first\
    \ substring) (first string)) (+ 1 (how_many 1 (rest substring)))]\n      [else\
    \ (how_many (+ count 1) (rest substring))]))\n  (how_many 0 (string-length string)))",
  "  (cond [(empty? string) 0]\n        [(string-equal substring string) 1]\n    \
    \    [(equal? (car string) substring) (+ 1 (how_many_times (cdr string) substring))]))\n",
  "  (+ (string-count string substring)\n     (string->int (match-pattern string substring))\n\
    \     (string->int (match-pattern string \"\\\\G\"))))\n", "  (let ((strings (string->list\
    \ (string))) (substring (make-string (string-length substring))))\n    (if (not\
    \ (string-equal? \"\" string))\n        (string-length (substring strings))\n\
    \        0)))\n", "  (let ((index (substring (string 0)) (count 0))\n        (found\
    \ #t))\n    (for ((i index (length string)))\n      (if (eqv? (substring (string\
    \ i) i) (string-ref string i))\n          (set! count (+ count 1))\n        (set!\
    \ found #f)))\n    count))\n", "  (cond ((string-length string = 0) (set! string\
    \ \"\"))\n        ((string=? string substring) 0)\n        (else (string-length\
    \ (substring string)) (+ 1 (how_many_times string (substring string)))))) ; string=?\
    \ will match case-sensitively\n                                              \
    \                                         ; If string is not case-sensitively,\
    \ use (string=? string (string-capitalize string))\n", "  (let ([count-substring\
    \ (count-substrings string substring)])\n    (if (< 0 count-substring 0)\n   \
    \   0\n      (add1 (- count-substring (+ substring-length substring)))))\n", " \
    \ (define (helper string substring)\n    (cond ((empty? string) 0)\n         \
    \ ((equal? (first string) substring) 1)\n          (else (+ 1 (helper (rest string)\
    \ (first substring)))))\n  (helper string substring))\n", "  (let ([start (position\
    \ substring string)])\n    (if (zero? start)\n        0\n        (+ (position\
    \ substring (string-append string substring)))\n        (- start)))))\n</code>\n\
    <|/ a dscore=2 tags=racket,functional-programming,scheme |>\n<| a tags=racket,functional-programming,scheme\
    \ dscore=1 |>\nHere is a solution using Racket and Common Lisp.\n<code>", "  (count_substring\
    \ string substring 0))\n", "  (cond ((string-length string = 0) 0)\n        ((string-length\
    \ substring = 0) 0)\n        ((= (string-length string) (string-length substring))\n\
    \         (string-length string)\n         (string-length substring))\n      \
    \  ((= (string-length string) (string-length substring))\n         ((string-equal?\
    \ (string-ref string 0) substring)\n          (+ 1 (how_many_times (string-ref\
    \ string 1) substring))\n          (how_many_times string (string-ref string 1)))\n\
    \        (else\n         (string-equal? (string-ref string 0)\n              \
    \           (string-ref string 1)\n                         substring)\n     \
    \    (+ 1 (how_many_times string (string-ref string 1))\n               (how_many_times\
    \ string (string-ref string 2)))\n         (how_many_times string (string-ref\
    \ string 1))\n         )\n        ))\n", "  (cond\n    ((string-length string)\
    \ 0)\n    ((equal? string (substring substring)) 1)\n    (else (string-length\
    \ (substring substring)))))\n", "  (string-count (string-count string substring)\
    \ substring string))\n", "  (let ((found (list-ref string 0)))\n    (cond\n  \
    \    [(not (null? found)) (+ found 1)]))\n  )\n  ", "  (length (intersection string\
    \ substring)))\n", "  (if (string? string)\n      (length (string-string-count\
    \ string substring))\n      0))\n</textarea></form>\n\n    <script>\n      var\
    \ editor = CodeMirror.fromTextArea(document.getElementById(\"code\"), {lineNumbers:\
    \ true, tabSize: 2});\n    </script>\n\n    <p><strong>MIME types defined:</strong>\
    \ <code>text/x-holodean-lisp</code>.</p>\n\n    <p>Development of the CodeMirror\
    \ addon was sponsored by a Google Summer of Code 2014. The editor is available\
    \ <a href=\"http://googlecode.blogspot.com/2014/11/google-summer-of-code-2014-building-the-editor.html\"\
    \ target=\"_blank\">here</a>.</p>\n\n  </article>\n\n<|/ file filename=index.html\
    \ |>\n<| c |>\nThank you, this is great.  I wish I could upvote this twice.\n\
    <|/ c |>\n<| c |>\nNo worries - I actually came across a similar question last\
    \ year and decided it wasn't worth the effort of writing a HLL language for it\
    \ (I wasn't expecting such an extensive set of functions/procedures to exist in\
    \ the first place).  I actually ended up writing it in Haskell first and converting\
    \ that to HLL when it was time to do so.\n<|/ c |>\n<| c |>\nThe [Emacs Lisp Mode\
    \ for Emacs](https://github.com/edaveave/emacs-lisp-mode) appears to do what you're\
    \ looking for.\n<|/ c |>\n<| a |>\nI have been using hs-mode on several projects\
    \ for years. It is extremely powerful. I recommend it.\n<|/ a tags=racket,haskell,lisp,racketlisp,scheme\
    \ dscore=5 |>\n<| c |>\nI love this answer. I'm using it for the last year and\
    \ love it. Now I'm gonna try haskell-mode.\n<|/ c |>\n<| c |>\nIt doesn't look\
    \ like haskell mode supports haskell98 or haskell2010 (the two latest releases).\
    \ I'm looking at haskell mode at http://haskell.org/haskellwiki/Haskell-mode and\
    \ they have no mention of either of those options (at least not that I can find).\
    \ Is there still a viable option?\n<|/ c |>\n<| c |>\nI checked the github page\
    \ of haskell mode. It says that it supports only R5RS and R6RS. That might not\
    \ be a problem though, I haven't tried it recently.\n<|/ ", "  (+ (string-length\
    \ string) (or (string-index string substring) 0))) ;; racket\n", "  (define (how_many\
    \ i j)\n    (cond (<= i j) (+ (substring (+ i 1) j) (how_many (+ i 1) j))\n  \
    \        (> (substring i 1) j) (how_many i (substring i 1))\n          (substring\
    \ i 1)\n          :else 0))\n  (how_many 0 (length string)))\n", "  (if (substring\
    \ (length string) string)\n      0\n      (if (substring (length string) (substring\
    \ 0 string))\n          1\n          (if (substring (length string) (substring\
    \ 0 string)) (+ 1 (how_many_times string (substring 1 string)))))))\n", "  (let\
    \ ([counts [#f]\n         chars [string]])\n    (if (string-length string)\n \
    \       (let ((char (char-ref string 0)))\n          (if (string-length substring)\n\
    \              (let ([c (char-ref substring 0)])\n                (if (string=\
    \ c char)\n                    (let ([c (char-ref string 1)])\n              \
    \        (cond ((string= c char) (set! counts (add1 counts)))))\n            \
    \      (cond ((string= c char) (set! counts (add1 counts)))))\n            (let\
    \ ([c (char-ref substring 1)])\n              (cond ((string= c char) (set! counts\
    \ (add1 counts)))))\n          (let ([c (char-ref substring 2)])\n           \
    \ (cond ((string= c char) (set! counts (add1 counts)))))\n        (set! counts\
    \ 1))\n    counts))\n", "  (let loop ((count 0) (string string) (substring substring))\n\
    \    (if (string-equal substring \"\")\n        count\n        (if (string-equal\
    \ string \"\")\n            count\n            (let ((new (substring (string-reverse\
    \ string))))\n              (if (string-equal new \"\")\n                  (loop\
    \ (+ count 1) (substring \"\") substring)\n                  (loop (+ count 1)\
    \ (substring new) (substring new)))))\n        )))\n</code>\n<|/ a tags=string,racket,scheme\
    \ |>\n<| c |>\nYour code does not work for input `\"\"`, `\"a\"` and `\"aaa\"\
    `.\n<|/ c |>\n<| a dscore=1 |>\n<code>", "  (/ (string-length string) (string-length\
    \ substring)))\n", "  (check-type string string)\n  (check-type substring string)\n\
    \  (check-type substring string)\n  (check-type substring char)\n  (when (string=?\
    \ substring \"\")\n    0)\n  (when (string=? substring \"a\")\n    0)\n  (when\
    \ (string=? substring \"aa\")\n    1)\n  (when (string=? substring \"aaa\")\n\
    \    3)\n  (when (string=? substring \"aaab\")\n    3)\n  (when (string=? substring\
    \ \"aaabbb\")\n    3)\n  (when (string=? substring \"aaabbbb\")\n    3)\n  (when\
    \ (string=? substring \"aaabbbbcc\")\n    3)\n  (when (string=? substring \"aaabbbbccc\"\
    )\n    3)\n  (when (string=? substring \"aaaaa\")\n    0)\n  (when (string=? substring\
    \ \"aaaaaa\")\n    2)\n  (when (string=? substring \"aaaaaaa\")\n    4)\n  (when\
    \ (string=? substring \"aaaaaaab\")\n    4)\n  (when (string=? substring \"aaaaaaabb\"\
    )\n    4)\n  (when (string=? substring \"aaaaaaabbb\")\n    4)\n  (when (string=?\
    \ substring \"aaaaaaabbbb\")\n    4)\n  (when (string=? substring \"aaaaaaabbbbcc\"\
    )\n    4)\n  (when (string=? substring \"aaaaaaabbbbccc\")\n    4)\n  (when (string=?\
    \ substring \"aaaaaaabbbbcccb\")\n    4)\n  (when (string=? substring \"aaaaaaabbbbcccbc\"\
    )\n    4)\n  (when (string=? substring \"aaaaaaabbbbcccbcb\")\n    4)\n  (when\
    \ (string=? substring \"aaaaaaabbbbcccbcbc\")\n    4)\n  (when (string=? substring\
    \ \"aaaaaaabbbbcccbcbcb\")\n    4)\n  (when (string=? substring \"aaaaaaabbbbcccbcbcbc\"\
    )\n    4)\n  (when (string=? substring \"aaaaaaabbbbcccbcbcbcb\")\n    4)\n  (when\
    \ (string=? substring \"aaaaaaabbbbcccbcbcbcbc\")\n    4)\n  (when (", "  (if\
    \ (null? substring)\n      0\n      (let ((head (car substring))\n           \
    \ (tail (cdr substring)))\n        (if (equal? string head) (+ 1 (how_many_times\
    \ (cdr string) tail))\n            (how_many_times (cdr string) (cons head tail)))))\n",
  "  (let loop ((found 0) (original string))\n    (cond [(empty? original) found]\n\
    \          [(equal? (substring original) (substring found)) (loop (add1 found)\
    \ (rest original))]\n          [else\n           (loop (add1 found) (substring\
    \ original))]))\n  (loop (add1 found) string))\n", "  (let ((length (length string)))\n\
    \    (cond\n      [(zero? length) 0]\n      [(char=? (substring string) (car string))\
    \ (+ 1 (how_many_times string (cdr string)))]\n      [(char=? (substring string)\
    \ (substring (cdr string))) (+ (how_many_times (substring string) substring)])\n\
    \      [else (+ 1 (how_many_times (substring string) (substring (cdr string))))])))\n",
  "  (cond\n    ((equal? (length string) 0) 0)\n    ((equal? (length substring) 0)\
    \ 0)\n    ((equal? (substring string) (substring \"\")) 0)\n    ((equal? (substring\
    \ string) (substring \"\")) 1)\n    ((equal? (substring string) (substring (car\
    \ string))) (+ 1 (how_many_times string (rest string)))))\n  )\n)\n", "  (let*\
    \ ((result 0)\n         (i (string-index string substring))\n         (j (+ i\
    \ (string-length substring)))\n         (c (substring string i (string-length\
    \ substring)))\n         (l (substring string 0 (+ i (string-length substring))))\n\
    \         (r (substring string j (+ j (string-length substring))))\n         (t\
    \ (substring string i (+ i (string-length substring))))\n         (v (substring\
    \ string 0 (+ j (string-length substring))))\n         (b (substring string i\
    \ (+ j (string-length substring))))\n         (rt (string-ref string i))\n   \
    \      (rv (string->number rt))\n         (rvb (string->boolean rv))\n       \
    \  (rvt (string-ref string i))\n         (rvt (string-ref string i))\n       \
    \  (rvt (string-ref string i))\n         (rvb (string->boolean rvt))\n       \
    \  (rvb (string->boolean rvt))\n         (rvb (string->boolean rvt))\n       \
    \  (rvb (string->boolean rvt))\n         (rvb (string->boolean rvt))\n       \
    \  (rvb (string->boolean rvt))\n         (rvb (string->boolean rvt))\n       \
    \  (rvb (string->boolean rvt))\n         (rvb (string->boolean rvt))\n       \
    \  (rvb (string->boolean rvt))\n         (rvb (string->boolean rvt))\n       \
    \  (rvb (string->boolean rvt))\n         (rvb (string->boolean rvt))\n       \
    \  (rvb (string->boolean rvt))\n         (rvb (string->boolean rvt))\n       \
    \  (rvb (string->boolean rvt))\n         (rvb (string->boolean rvt))\n       \
    \  (rvb (string->boolean rvt))\n         (rvb (string->boolean rvt))\n       \
    \  (rvb (string->boolean rvt))\n         (rvb (string->boolean rvt))\n       \
    \  (rvb (string->boolean rvt))\n         (rvb (string->boolean rvt))\n       \
    \  (rvb (string->boolean rvt))\n         (rvb (string->boolean rvt))\n       \
    \  (rvb (string->boolean rvt))\n         (rvb (string->boolean rvt))\n       \
    \  (rvb (string->boolean rvt))\n         (rvb (string->boolean rvt))\n       \
    \  (rvb (string->boolean rvt))\n         (rvb (string->boolean rvt))\n       \
    \  (rvb (string->boolean rvt))\n         (rvb (string->boolean rvt))\n       \
    \  (rvb (string->boolean rvt))\n         (rvb (string->boolean ", "  (count (\u03BB\
    \ (string) (\u03BB (substring) (equal? (string-ref string 0) substring))) substring))\n",
  "  (/ (length string) (length substring))\n  (/ (string-index string substring)\
    \ (length substring))\n  )\n", "  (cond\n    [(empty? substring) 0]\n    [(equal?\
    \ (substring (first string)) (first substring)) (+ 1 (how_many_times (rest string)\
    \ substring))]\n    [else (+ 1 (how_many_times (rest string) (cons (first substring)\
    \ substring)))]))\n", "  (count-substrings string substring 0))\n", "  (if (=\
    \ (length string) (length substring))\n      (length string)\n      (let ((found\
    \ (mem-ref string 0 (length substring))))\n        (if (= found (length substring))\n\
    \            (length string)\n            (+ 1 (how_many_times string (substring\
    \ string)))))))\n", "  (let loop ((i 0)\n             (found 0))\n    (cond\n\
    \      [(string? substring) (- found 1)]\n      [(equal? string substring) (+\
    \ found 1)]\n      [(string? (substring i)) (loop (+ i 1)\n                  \
    \                   (+ found 1))]\n      [(equal? (substring i) substring) (loop\
    \ (+ i 1)\n                                              (+ found 1))]\n     \
    \ [(char? (substring i)) (loop (+ i 1)\n                                   (+\
    \ found 1))]\n      [(equal? (substring i) (string-ref string i))]\n      [else\
    \ (loop (+ i 1) found)]))\n)\n", "  (cond\n    [(empty? string) 0]\n    [(eq?\
    \ (car string) substring) 1]\n    [else (+ 1 (how_many_times (cdr string) substring))]))\n",
  "  (cond [(empty? string) 0]\n        [(equal? string (substring string)) (+ 1 (how_many_times\
    \ (rest string) substring))\n         (+ 0 (how_many_times (substring string)\
    \ (rest string)))]\n        [else (+ 1 (how_many_times (rest string) substring))]))\n",
  "  (cond ((null? substring) 0)\n        (else (+ (string-char-index (substring string)\
    \ string) (how_many_times (substring string) substring))))))\n", "  (cond\n  \
    \  [(empty? string) 0]\n    [(equal? (substring string) substring) 1]\n    [else\
    \ (+ (how_many_times (rest string) substring) 1)]))\n", "  (define substr_length\
    \ (string-length substring))\n  (if (substr_length 0)\n      0\n      (let loop\
    \ ((i 0)\n                 (remaining string)\n                 (count 0))\n \
    \       (if (equal? remaining substring)\n            (add1 count)\n         \
    \   (if (equal? (substring 0) (remaining substring))\n                (loop (+\
    \ i 1) (substring 1) (add1 count))\n                (loop (+ i 1) remaining (add1\
    \ count)))))\n      count))\n</code>\n<|/ a |>\n<| a dscore=0 |>\nI figured out\
    \ a very simple solution, just using recursion.\n<code>", "  (cond\n    [(string-empty?\
    \ string) 0]\n    [(mem= string substring) 1]\n    [else (+ (mem= string (substring\
    \ 0 (string-length string))) (how_many_times (substring 1 (string-length string)))\
    \ ) ]))\n", "  (define (how_many substring string result)\n    (cond\n      [(empty?\
    \ string) result]\n      [(equal? (first string) substring) (+ 1 (how_many substring\
    \ (drop 1 string) result))]\n      [else (how_many substring (drop 1 string) (+\
    \ 1 (how_many substring string result)))]))\n  (how_many substring string 0))\n",
  "  (if (string= string \"\")\n      0\n      (+ (string=? string substring) (how_many_times\
    \ (string->string (string-sub string 0 string)) substring))))\n", "  (define (how_many_times_helper\
    \ string substring count)\n    (cond\n      [(empty? string) count]\n      [(string=?\
    \ (string/lower-case-of (string/substring-of string 0)) (string/lower-case-of\
    \ (substring 0))) \n       (how_many_times_helper (rest string) (substring 1)\
    \ (+ count 1))]\n      [else (how_many_times_helper (rest string) substring (+\
    \ count 1))]))\n  (how_many_times_helper string substring 0))\n", "  (cond\n \
    \   [(empty? string) (length (substring (string (length string) 0)))]\n    [(equal?\
    \ (substring string) (substring \"\")) 0]\n    [(substring string 0)\n     (+\
    \ (how_many_times string substring (substring string 0))\n        (how_many_times\
    \ string (substring string 1)))]))\n", "  (cond\n    [(empty? string) 0]\n   \
    \ [(equal? (first string) substring) (+ 1 (how_many_times (rest string) substring))]\n\
    \    [else (+ 1 (how_many_times (rest string) substring))]))\n</cell>\n<cell>\n\
    #lang racket\n", "  (let helper ([start (string-length string)\n             \
    \    end (string-length substring)]\n              [s string]\n              [start\
    \ (if (or (eq? start end)\n                          (eq? start 0))\n        \
    \              0\n                      start)]\n              [end (if (or (eq?\
    \ end start)\n                          (eq? end 0))\n                      (+\
    \ 1 (string-length substring))\n                      end)]\n              [counts\
    \ '()])\n    (cond [(empty? s) 0]\n          [(<= start end)\n           (cond\
    \ [(empty? counts)\n                   (+ 1 (helper (cdr start) (car s) start\
    \ (cdr end) counts))]\n                   [(eq? (eq? (car counts) (cadr counts))\
    \ (eq? start (car counts)))\n                    (+ 1 (helper (cdr start) (car\
    \ s) start (cdr end) (cdr counts)))]\n                   [else\n             \
    \       (helper (cdr start) (car s) start (cdr end) (cdr (cons (car counts) counts))))]\n\
    \          [else\n           (helper (cdr start) (car s) start (cdr end) counts)]))))\n",
  "  (cond [(string-length string = 0) 0]\n        [(string-length substring = 0)\
    \ 1]\n        [(equal? (string-index string substring) 0)\n         (+ 1 (how_many_times\
    \ (string-index string #\\0)\n                          substring)))\n       \
    \ (else\n         (how_many_times (string-index string substring (+ 1 0)) #\\\
    0))]))\n", "  (let ((count-string 0))\n    (loop i string\n      (if (eq? i \"\
    \")\n          count-string\n          (if (eq? (char-ref i 0)\n             \
    \     (char-ref substring 0))\n              (if (or (eq? (char-ref i 0) (char-ref\
    \ substring 0))\n                      (char-equal? (char-ref i 0)\n         \
    \                          (char-ref substring 0)))\n                  (add1 count-string)\n\
    \                  (loop j (char-tail i)\n                    (if (char-equal?\
    \ (char-ref i j)\n                                   (char-ref substring j))\n\
    \                        (add1 count-string)\n                        (loop (+\
    \ j 1) (char-tail i))))))))\n    count-string))\n", "  (let loop ((string string)\n\
    \             (substring substring))\n    (cond ((null? string) 0)\n         \
    \ ((eq? (car string) substring) 1)\n          ((begins-with? string substring)\
    \ (+ 1 (loop (cdr string) (substring substring))))\n          (else\n        \
    \   (loop (cdr string) (substring substring)))))\n", "  (cond [(empty? string)\
    \ (length substring)\n         (string-contains-substring string substring)\n\
    \         (string-contains-substring substring string)]\n        [else\n     \
    \    (1 + (if (string-contains-substring string substring)\n                (how_many_times\
    \ (substring string) (substring substring))\n                0))]))\n", "  (define\
    \ (helper string substring)\n    (cond\n      [(empty? string) 0]\n      [(equal?\
    \ (first string) substring) 1]\n      [else (+ \n              (helper (rest string)\
    \ substring)\n              (helper (rest string) (first string)))]))\n  (helper\
    \ string substring))\n", "  (if (null? substring)\n      0\n      (+ (chars-count\
    \ string)\n         (how_many_times (cdr string) (substring (car string))))))\n",
  "  (/ (string-length string) (string-length substring)))\n", "  (let* (\n      \
    \  (count (length string))\n        (end (position (string->char-code (append\
    \ substring string)) string))\n      )\n    (cond\n      [(or (<= count 0) (<\
    \ count end))\n       (+ (- count end) 1)]\n      [(eql? (string->char-code (substring\
    \ 0 count)) (string->char-code (substring end end)))\n       (+ count 1)]\n  \
    \    [else\n       (+ count 1)]\n    )\n  )\n)\n", "  (if (string=? string substring)\n\
    \      (length string)\n      (+ 1 (how_many_times (substring string) (substring\
    \ string))))\n", "  (let loop ((count 0)\n             (chars (string->list string)))\n\
    \    (cond ((null? chars)\n           (list count))\n          ((memq chars (string->list\
    \ substring))\n           (loop (add1 count) (remove chars (string->list substring))))\n\
    \          (else (loop (add1 count) (remove chars (string->list string)))))))",
  "  (cond\n    [(empty? string) 0]\n    [(equal? (substring 0) (string)) 1]\n   \
    \ [else (+ 1 (how_many_times (cdr string) (substring 1))]))) ;; #lang racket\n",
  "  (if (string? substring)\n      (length (string-to-list string substring))\n \
    \     (length (string-to-list string \"\"))))\n", "  (length (string-match-all\
    \ string substring #t #t)))\n", "  (- 0 (string-length string) (- 0 (string-length\
    \ substring) (string-length string))))\n", "  (length (subseq (string->list string)\
    \ 0 0 (string->list substring) 0)))\n", "  (define s (string-length string))\n\
    \  (define l (string-length substring))\n  (define count 0)\n  (define start 0)\n\
    \  (define end l)\n  (define string_to_search (substring start end))\n  (define\
    \ string_to_search_length (string-length string_to_search))\n  (while (< end s)\n\
    \    (define s (- end 1))\n    (define string_to_search (substring start s))\n\
    \    (define string_to_search_length (string-length string_to_search))\n    (define\
    \ end s)\n    (cond ((< start 0) (string-append\n                  (cons (substring\
    \ start 0)\n                        (string-append (make-string 1 string) (substring\
    \ 0 start))\n                        (make-string 1 string) (substring 0 start))\n\
    \                  (cons (substring end 1)\n                        (string-append\
    \ (make-string 1 string) (substring end 0))\n                        (make-string\
    \ 1 string) (substring end 0))\n                  (cons (substring start string_to_search_length)\n\
    \                        (string-append (make-string 1 string) (substring start\
    \ string_to_search_length))\n                        (make-string 1 string) (substring\
    \ start string_to_search_length))\n                  (cons (substring end string_to_search_length)\n\
    \                        (string-append (make-string 1 string) (substring end\
    \ string_to_search_length))\n                        (make-string 1 string) (substring\
    \ end string_to_search_length))\n                  (string-append (make-string\
    \ 1 string) (substring start string_to_search_length) (string-append (make-string\
    \ 1 string) (substring end string_to_search_length)))\n                  (cons\
    \ (make-string 1 string) (substring start string_to_search_length) (make-string\
    \ 1 string) (substring end string_to_search_length)))\n            ((string-equal?\
    \ string_to_search string_to_search) (+ count 1))\n            (else (string-append\n\
    \                     (cons (substring start string_to_search_length)\n      \
    \                      (string-append (make-string 1 string) (substring start\
    \ string_to_search_length))\n                            (make-string 1 string)\
    \ (substring start string_to_search_length))\n                     (cons (substring\
    \ end string_to_search_length)\n                            (string-append (make-string\
    \ 1 string) (substring end string_to_search_length))\n                       \
    \     (make-string 1 string) (substring end string_to_search_length))\n      \
    \               (cons (substring start string_to_search_length)\n            \
    \                (string-append (make-string 1 string) (substring end string_to_search_length))\n\
    \                            (make-string 1 string) (substring end string_to_search_length))\n\
    \                     (cons (make-string 1 string) (sub", "  (define (count a\
    \ b)\n    (cond\n      [(string-length a) 0]\n      [(< a (string-length b)) (+\
    \ 0 (count (substring a) b))]\n      [else (+ a (count (substring a) (substring\
    \ b)))]))\n  (count string substring))\n", "  (let loop ([index 0])\n    (if (equal?\
    \ index string-length)\n        (string-length string)\n        (let ((c (char-at\
    \ (string-ref string index))\n              match-count 0)\n              (next-index\
    \ (+ index 1)))\n          (if (or (char=? c substring)\n                  (and\
    \ (char=? (char-at string next-index) substring)\n                      (> index\
    \ next-index)))\n              (loop (+ index 1))\n              (if (or (char=?\
    \ (char-at string next-index) substring)\n                      (char=? c substring))\n\
    \                  (loop (+ index 1))\n                  (loop (+ index 2)))))))))\n",
  "  (if (empty? substring)\n      (length (string-match string #\\a))\n      (let\
    \ ((substring (substring #\\a)))\n        (let loop ((counting 0))\n         \
    \ (if (string-match string substring)\n              (loop (+ counting 1))\n \
    \             (loop (+ counting 0)))))))\n", "  (define (how_many_times-helper\
    \ string substring index count)\n    (cond\n      [(and (>= index 0) (<= index\
    \ string)) (cons index (how_many_times-helper (cdr string) (substring index) (car\
    \ count) (caddr count)))]\n      [(empty? string) (cons count (list))]))\n  (if\
    \ (equal? string \"\") (how_many_times-helper string substring 0 0))\n  (how_many_times-helper\
    \ string substring 0 0))\n", "  (define result 0)\n  (define i 0)\n  (define length\
    \ 0)\n  (for ((index substring i) (i 0 (+ i (length substring))))\n    (define\
    \ new-length (length index))\n    (cond\n      ((and (<= i 0) (< i length)) result)\n\
    \      ((and (= i (length substring)) (< new-length length)) (+ result 1))\n \
    \     (else\n        (define new-length (- new-length index))\n        (cond\n\
    \          ((< new-length length) (+ 1 (how_many_times (substring index i) substring)))\n\
    \          ((= new-length length) (+ 1 (how_many_times substring index i)))\n\
    \          (else\n            (how_many_times (substring index i) substring (+\
    \ i new-length))\n            )\n          )\n          )\n        )\n      )\n\
    \    )\n  )\n", "  (define (how_many-times str sub)\n    (define (inner-how_many-times\
    \ str sub count)\n      (if (equal? str sub)\n          count\n          (if (equal?\
    \ (substring str sub) (substring sub sub))\n              (inner-how_many-times\
    \ (substring str (substring-index str (substring-index str sub))) (substring sub\
    \ (substring-index sub sub)) (+ count 1)))))\n    (if (string? str)\n        (inner-how_many-times\
    \ str (substring str) (+ 1))\n        0))\n  (reverse (how_many-times string substring)))\n",
  "  (length (take_substrings string substring)))\n", "  (if (null? substring)\n \
    \     0\n      (if (equal? (string->char string) (string->char substring))\n \
    \         1\n          (+ (how_many_times (string->string (string->char string\
    \ 0)) substring) (how_many_times (string->string (string->char string 1)) substring))))\n",
  "  (cond [(empty? string) 0]\n        [(equal? (first string) substring) (+ 1 (how_many_times\
    \ (rest string) substring))]\n        [else (+ (how_many_times (rest string) (first\
    \ substring)) (how_many_times (rest string) substring))]))\n", "  (length string))\n",
  "  (let ((count 0))\n    (for char [string\n              substring\n          \
    \    (substring string #\\d)]\n      (if (string-match substring char)\n     \
    \     (add1 count)))))\n", "  (define (helper string substring start index)\n\
    \    (cond [(zero? index)\n           0]\n          [(string= (string-ref string\
    \ index) substring)\n           (+ start (helper string substring index (substring-length\
    \ substring)))]\n          [(string< substring (string-ref string index))\n  \
    \         (helper (string-tail string) (substring index (substring-length substring))\
    \ (substring-length substring))]))\n  (helper string substring 0 (substring-length\
    \ substring)))\n</cell>\n<cell>\n#lang racket\n", "  (length string))\n", "  (length\
    \ (filter string? (map substring string))))\n", "  (match string\n    ((#\\a #\\\
    a) 0)\n    ((#\\a #\\b) 1)\n    ((#\\a #\\b #\\a) 2)\n    ((#\\a #\\b #\\b) 2)\n\
    \    ((#\\a #\\b #\\b #\\a) 3)\n    ((#\\a #\\b #\\b #\\b #\\a) 4)\n    ((#\\\
    a #\\b #\\b #\\b #\\b #\\a) 5)\n    ((#\\a #\\b #\\b #\\b #\\b #\\b #\\a) 6)\n\
    \    ((#\\a #\\b #\\b #\\b #\\b #\\b #\\b #\\a) 7)\n    ((#\\a #\\b #\\b #\\b\
    \ #\\b #\\b #\\b #\\b #\\a) 8)\n    ((#\\a #\\b #\\b #\\b #\\b #\\b #\\b #\\b\
    \ #\\b #\\a) 9)\n    ((#\\a #\\b #\\b #\\b #\\b #\\b #\\b #\\b #\\b #\\b #\\a)\
    \ 10)\n    ((#\\a #\\b #\\b #\\b #\\b #\\b #\\b #\\b #\\b #\\b #\\a) 11)\n   \
    \ ((#\\a #\\b #\\b #\\b #\\b #\\b #\\b #\\b #\\b #\\b #\\b #\\a) 12)\n    ((#\\\
    a #\\b #\\b #\\b #\\b #\\b #\\b #\\b #\\b #\\b #\\b #\\a) 13)\n    ((#\\a #\\\
    b #\\b #\\b #\\b #\\b #\\b #\\b #\\b #\\b #\\b #\\b #\\a) 14)\n    ((#\\a #\\\
    b #\\b #\\b #\\b #\\b #\\b #\\b #\\b #\\b #\\b #\\b #\\a) 15)\n    ((#\\a #\\\
    b #\\b #\\b #\\b #\\b #\\b #\\b #\\b #\\b #\\b #\\b #\\a) 16)\n    ((#\\a #\\\
    b #\\b #\\b #\\b #\\b #\\b #\\b #\\b #\\b #\\b #\\b #\\b #\\a) 17)\n    ((#\\\
    a #\\b #\\b #\\b #\\b #\\b #\\b #\\b #\\b #\\b #\\b #\\b #\\b #\\a) 18)\n    ((#\\\
    a #\\b #\\b #\\b #\\b #\\b #\\b #\\b #\\b #\\b #\\b #\\b #\\b #\\a) 19)\n    ((#\\\
    a #\\b #\\b #\\b #\\b #\\b #\\b #\\b #\\b #\\b #\\b #\\b #\\b #\\b #\\a", "  (define\
    \ (helper string substring count)\n    (cond\n      [(or (equal? (string-ref string\
    \ 0) (substring 0)) (string-empty? string))\n       (cond [(or (equal? (string-ref\
    \ string 0) (substring 0)) (string-empty? string))\n              (set! count\
    \ (add1 count))]\n             [else (helper (substring 1) string (add1 count))])]\n\
    \      [(equal? (string-ref string 0)\n             (substring 0))\n       (add1\
    \ count)]\n      [else (helper (substring 1) string (add1 count))]))\n  (helper\
    \ string substring 0))\n", "  (count_substrings string substring 0))\n", "  (let\
    \ ([start (position (string->char-array string) substring)]\n        [end (position\
    \ (string->char-array (string->char-array string) (string-reverse substring))\n\
    \                   substring)]\n        [len (- end start)])\n    (if (= len\
    \ 0)\n        0\n        (+ (substring (substring (substring (substring (substring\
    \ (substring (substring string start end) start end) start end) start end) start\
    \ end) start end) start end)\n            (how_many_times (substring (substring\
    \ (substring (substring (substring (substring string start end) start end) start\
    \ end) start end) start end) substring))))))", "  (length (filter (lambda (match)\
    \ (equal? (car match) substring)) (matches-in string substring))))\n", "  (cond\n\
    \    [(null? string) 0]\n    [(eqv? (rest substring) (string-ref string 0)) 1])\n\
    )\n", "  (match string\n    ((empty-string) 0)\n    ((equal? string \"\") 0)\n\
    \    ((equal? string substring) 1)\n    (else (+ 1 (how_many_times (cdr string)\
    \ substring))))) ;; SICP style\n", "  (define (helper str substr)\n    (cond ((string-match\
    \ str substr)\n           (1+ (string-match str substr)\n               (helper\
    \ (substring (substring str substr))\n                      substr)))\n      \
    \    ((null? str)\n           0)\n          ((not (null? str))\n           (helper\
    \ str (substring str substr))))\n  (helper string substring))\n", "  (if (equal?\
    \ string \"\")\n      0\n      (let ((count (+ 1 (string=? substring string))))\n\
    \        (string=? (substring string) substring)\n        (set! string (string-append\
    \ string substring))\n        count)))\n", "  (let loop ((count 0) (i 0))\n  \
    \  (cond ((eql i string) count)\n          ((string=? string (substring i)) (incf\
    \ count))\n          (else (loop (+ count 1) (+ i 1))))))\n", "  (count-overlap\
    \ string (set-find substring string)))\n", "  (cond\n    ((string= string \"\"\
    )\n     (length (string= \"\" substring)))\n    ((string= string substring)\n\
    \     (length string))\n    ((string= string (substring string))\n     (length\
    \ string))\n    ((string= string (substring (string-tail string)))\n     (how_many_times\
    \ (string-tail string) (substring (string-tail string)))\n    ((string= string\
    \ (substring (string-tail (string-tail string))))\n     (how_many_times (string-tail\
    \ (string-tail string)) (substring (string-tail (string-tail string))))\n    ((string=\
    \ string (substring (string-tail (string-tail (string-tail string))))\n     (how_many_times\
    \ (string-tail (string-tail (string-tail string)) (substring (string-tail (string-tail\
    \ (string-tail string)))))\n    ((string= string (substring (string-tail (string-tail\
    \ (string-tail (string-tail string)))))\n     (how_many_times (string-tail (string-tail\
    \ (string-tail (string-tail string)) (substring (string-tail (string-tail (string-tail\
    \ (string-tail string)))))\n    ((string= string (substring (string-tail (string-tail\
    \ (string-tail (string-tail (string-tail string)))))\n     (how_many_times (string-tail\
    \ (string-tail (string-tail (string-tail (string-tail (string-tail string))) )\
    \ (substring (string-tail (string-tail (string-tail (string-tail (string-tail\
    \ string)))))\n    ((string= string (substring (string-tail (string-tail (string-tail\
    \ (string-tail (string-tail (string-tail string))) ) (substring (string-tail (string-tail\
    \ (string-tail (string-tail (string-tail (string-tail string))) ))))\n     (how_many_times\
    \ (string-tail (string-tail (string-tail (string-tail (string-tail (string-tail\
    \ (string-tail (string-tail string)) )) )) (substring (string-tail (string-tail\
    \ (string-tail (string-tail (string-tail (string-tail string)) )) )))\n    ((string=\
    \ string (substring (string-tail (string-tail (string-tail (string-tail (string-tail\
    \ (string-tail (string-tail (string-tail string))) ) (substring (string-tail (string-tail\
    \ (string-tail (string-tail (string-tail (string-tail (string-tail string)) ))\
    \ ))))\n     (how_many_times (string-tail (string-tail (string-", "  (count\n\
    \   (for [i string\n         j substring\n         cnt 1]\n     (when (equal?\
    \ i j)\n       ;; Overlapping case\n       ;; >>> (how_many_times \"a\" \"a\"\
    )\n       ;; 0\n       ;; >>> (how_many_times \"aa\" \"a\")\n       ;; 3\n   \
    \    ;; >>> (how_many_times \"a\" \"aa\")\n       ;; 3\n       ;; >>> (how_many_times\
    \ \"aaa\" \"a\")\n       ;; 3\n       ;; >>> (how_many_times \"a\" \"aaa\")\n\
    \       ;; 3\n       ;; >>> (how_many_times \"aaaa\" \"aa\")\n       ;; 3\n  \
    \     ;; >>> (how_many_times \"a\" \"aaaa\")\n       ;; 3\n       ;; >>> (how_many_times\
    \ \"aa\" \"aaaa\")\n       ;; 3\n       ;; >>> (how_many_times \"aaaa\" \"aaa\"\
    )\n       ;; 3\n      (set! cnt (+ cnt 1))\n      (cdr cnt))\n   0))\n", "  (let\
    \ loop ((count 0) (substring_length 0)\n             (original_length string-length))\n\
    \    (cond ((or (string= string \"\") (null? string)) count)\n          ((null?\
    \ substring) count)\n          ((> substring_length 0) (loop (add1 count) substring_length\
    \ original_length))\n          ((> original_length substring_length) (loop (add1\
    \ count) (- substring_length 1) (- original_length 1)))\n          (else (loop\
    \ (add1 count) (- substring_length 1) original_length)))))\n", "  (cond\n    ((empty?\
    \ string) 0)\n    ((equal? (first string) substring) 1)\n    ((equal? (first (rest\
    \ string)) substring) 1)\n    (else (+ (how_many_times (rest string) substring)\
    \ (how_many_times (rest string) (first string)))))\n", "  (cond\n    [(empty?\
    \ string) 0]\n    [(string-equal? (rest string) substring) 1]\n    [else (+ 1\
    \ (how_many_times (rest string) substring))]))\n", "  (cond\n    ((null? string)\
    \ 0)\n    ((eq? (substring string) string) 1)\n    ((null? (substring string))\
    \ 0)\n    (else (+ (how_many_times (substring string) (substring (remainder (remainder\
    \ string substring) substring))) (how_many_times string (substring (remainder\
    \ string substring)))))))\n", "  (define (match s substring)\n    (let loop ([chars\
    \ (string->list (string-ref s 0))] [res 0])\n      (cond [(null? chars) res]\n\
    \            [(equal? (string-ref chars 0) substring) (res + 1)]\n           \
    \ [else (loop (rest chars) (if (equal? (string-ref chars 0) substring) (res +\
    \ 1) 0))]))\n  (loop (string->list string) 0))\n", "  (let ((chars (string->list\
    \ string)))\n    (let ((start (lambda (c) (or (char-alphabetic? c) (char-digit?\
    \ c))))\n          (end (lambda (c) (or (char-alphabetic? c) (char-digit? c))))\n\
    \          (count 0))\n      (for ((i 0) (char chars)\n            (count 0))\n\
    \        (if (start char)\n            (if (start substring)\n               \
    \ (set! count (+ count 1))\n                (set! count 0))\n            (if (end\
    \ char)\n                (if (end substring)\n                    (set! count\
    \ (+ count 1))\n                    (set! count 0))\n            (set! count (+\
    \ count 1))))\n      count))\n", "  (if (string-empty? string)\n      0\n    \
    \  (+ 0 (count-substring-times string substring))))\n", "  (if (string-length\
    \ substring)\n      (string-length string)\n      0))\n", "  (define (how_many-times\
    \ string)\n    (cond ((empty? string) 0)\n          ((equal? (substring (car string))\
    \ (first (cadr string))) (incf (cdr (cadr string))))\n          (t (how_many-times\
    \ (cdr string))))\n  (how_many-times (string->list (string)))\n)\n", "  (length\
    \ (remove-if (lambda (x) (string-equal? x substring)) string)))\n", "  (length\
    \ (string->list string) \n        (lambda (x) (equal? (string->char x) substring))))\n",
  "  (let ((count 0))\n    (cond\n      [(equal? string \"\") count]\n      [(equal?\
    \ substring \"\") count]\n      [(equal? (string-upcase string) (string-upcase\
    \ substring)) (+ count 1)]\n      [else (how_many_times (substring (substring\
    \ (length string) 0)))]))) ;; #lang racket\n", "  (define start 0)\n  (define\
    \ end 0)\n  (let loop ((n 0))\n    (if (string-empty? string)\n        n\n   \
    \     (let ((newchar (string-ref string start)))\n          (cond ((equal? newchar\
    \ substring) n)\n                ((not (equal? (string-ref string start) substring))\n\
    \                 (loop (+ n 1)))\n                (t (loop (+ n 1)))))))\n  nil)\n",
  "  (/ (string-length string) (string-length substring)))\n", "  (cond\n    ((null\
    \ string) 0)\n    ((string-match? substring string) (string-length string))\n\
    \    (else (+ 1 (how_many_times (substring string) substring)))))\n", "  (length\
    \ string))\n", "  (cond\n    [(empty? string) 0]\n    [(equal? (first string)\
    \ substring) 1]\n    [else (+ (how_many_times (rest string) (first substring))\n\
    \             (how_many_times string substring))]))\n", "  (cond [(empty? string)\
    \ 0]\n        [(substring (first string)) (+ 1 (how_many_times (rest string) substring))]))\n",
  "  (cond\n    ((null? string) 0)\n    ((equal? (string->symbol string) substring)\
    \ 1)\n    ((equal? (string->symbol substring) string) 2)\n    (else (+ 0 (- (how_many_times\
    \ (string->string string) substring) (how_many_times (string->string substring)\
    \ string)))))\n", "  (let* ((len (string-length string))\n         (str (string->list\
    \ string))\n         (pos (string->list substring))\n         (i 0))\n    (cond\n\
    \      [(or (= i len) (string-equal string substring))\n       (+ 1 (or (list-index\
    \ '() str) pos))\n       0]\n      [else\n       (let ((match (list-ref str (add1\
    \ i))))\n         (cond\n           [(string-equal match substring)\n        \
    \    (how_many_times (substring (list-ref pos 0)) substring)\n           (string->string\
    \ match)\n           (string->string (+ (string->list (string->list substring)\
    \ i) 1))]\n           [else\n            (how_many_times (substring match) substring)\n\
    \            (string->string match)\n            (string->string (+ (string->list\
    \ (string->list substring) i) 1))]))]))\n", "  (let loop ((i 0)\n            \
    \ (found 0) (strings (reverse (substring (string i) 1000000)))\n             (length\
    \ (string-length string)))\n    (cond ((= i length)\n           (if (> found (string-length\
    \ string))\n               found\n               (loop (+ i 1)\n             \
    \        (+ found (string-length string))\n                     (append strings\
    \ (substring (string i) 1000000)))\n               (loop (+ i 1)\n           \
    \          (+ found (string-length string))\n                     nil)))\n   \
    \       ((= (string-length string) 1)\n           (loop (+ i 1)\n            \
    \     found\n                 nil\n                 (string-length string)))\n\
    \          ((string-equal? (string i) substring)\n           (loop (+ i 1)\n \
    \                found\n                 (string-length string)\n            \
    \     (string-length string)))\n          (else\n           (loop (+ i 1)\n  \
    \               found\n                 (+ found (string-length string))\n   \
    \              (substring (string i) 1000000))))))\n", "  (define (how_many count\
    \ substring string)\n    (cond\n      [(empty? string) count]\n      [(equal?\
    \ (first string) substring) (how_many (+ count 1) (first string) (rest string))]\n\
    \      [else (how_many count (first string) (cons (first string) (rest string)))]))\n\
    \  (how_many 0 (substring string) string))\n</cell>\n<code language=dyalog-kernel>",
  "  (count-substrings substring string 0))\n", "  (match string\n    (#\\a #\\a #\\\
    a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\\
    a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\\
    a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\\
    a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\\
    a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\\
    a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\\
    a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\\
    a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\\
    a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\\
    a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\\
    a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\\
    a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\\
    a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\\
    a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\\
    a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\\
    a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #\\a #", "  (if (empty? substring)\n\
    \      (length (match-string string substring))\n      (length (match-string string\
    \ (substring 1 string))))) ;; match is greedy by design; it will find the longest\
    \ match", "  (if (null? string) 0\n      (let* ((found (substring string))\n \
    \            (rest (substring (rest string)))\n             (result (+ (length\
    \ found) (length rest)))))\n        result))\n", "  (if (equal? (string-ref string\
    \ 0) substring) 0 1))\n", "  (cond\n    [(empty? string) 0]\n    [(string-equal\
    \ string substring) (+ 1 (how_many_times (rest (rest string)) substring))]\n \
    \   [else (+ (how_many_times (rest (rest string)) substring) (how_many_times string\
    \ substring))]))\n", "  (if (string-match substring string)\n      (length string)\n\
    \      (length string)))\n", "  (define (helper index string)\n    (cond\n   \
    \   [(equal? index '()) 0]\n      [(string=? string (substring 0)) (+ 1 (helper\
    \ index string))]\n      [(string=? string (substring index)) (+ 1 (helper (cdr\
    \ index) string))]\n      [else (helper (cdr index) string)]))\n  (helper 0 (substring\
    \ 0)))\n", "  (cond\n    [(empty? string) 0]\n    [(string-match substring string)\
    \ (+ 1 (how_many_times (string-downcase string) substring))]\n    [else (how_many_times\
    \ (rest string) substring)]))\n", "  (cond\n    ((string-equal \"\" substring)\
    \       0)\n    ((string-equal string substring) 1)\n    (else               \
    \          (count (string-index string substring))))) ; Simplify for clarity -\
    \ can be simplified with a local variable.\n", "  (if (null? substring)\n    \
    \  (length (string-match-p string string 0))\n      (let ((c (char-ref string\
    \ 0)))\n        (if (substring c)\n            (+ 1 (how_many_times (substring\
    \ ~c ~c) (substring ~c)))\n            (+ (how_many_times string (string-tail\
    \ substring)))))\n  0))\n", "  (length string-match-first string substring))\n",
  "  (let loop ((i 0)\n             (len string-length string))\n    (if (= i len)\n\
    \        (add1 i)\n        (let ((end (substring (string i) len)))\n         \
    \ (loop (+ i 1)\n                (- end len))\n          (if (char-equal end substring\
    \ 'false)\n              (add1 i)))))))\n", "  (cond\n    [(string? substring)\
    \ (length string)\n     (if (empty? substring)\n         (length string)\n   \
    \      (if (empty? string)\n             (- 1 (length (substring string 0)))\n\
    \             (+ 1 (how_many_times (substring string 1) substring)))]\n    [else\
    \ 0]))\n", "  (let loop ((count 0) (current string))\n    (cond ((null? current)\
    \ count)\n          ((eqv? (car current) substring) (loop (add1 count) (cdr current)))\n\
    \          (else\n           (loop (add1 count) (cdr current)))))\n  (add1 count))\n",
  "  (+ (length (string-occurrences string substring))\n     (length (string-occurrences\
    \ substring string))))\n", "  (let ([count 0])\n    (string-length (substring-at\
    \ string 0 (string->index string substring))) (+ count 1)))\n", "  (length (set-difference\
    \ (set (string->list string)) (set (string->list substring))))\n)", "  (count-overlapping-substring\
    \ string substring))\n", "  (let ((chars-to-count (string-length substring)))\n\
    \    (let loop ((chars (string-to-list string)))\n      (cond ((null? chars)\n\
    \             (if (chars-to-count 0)\n                 (return 0))\n         \
    \    (else (begin (set! chars-to-count (chars-to-count - 1))\n               \
    \          (equal? (car chars) (first chars))\n                         (loop\
    \ chars (cdr chars))))))))\n", "  (length \n  (remove #(if (equal? (substring\
    \ %1) (substring %2))\n               (append '() %1)\n               '())\n \
    \         string)))\n", "  (let ([counting (make-hash)])\n    (count-characters\
    \ string substring counting 0)))\n", "  (if (string=? \"\" substring)\n      0\n\
    \      (+ (count substring string) (count substring (string-reverse string)))))\
    \ ;; #lang racket\n", "  (cond ((equal? string \"\") 0)\n        ((equal? substring\
    \ \"\") 0)\n        (else (let ((str (string-append string substring))\n     \
    \               (count 0))\n               (cond ((equal? str \"\")\n        \
    \              count)\n                     ((equal? str substring)\n        \
    \              (+ 1 (how_many_times (string-append \"x\" str) substring)))\n \
    \                    (else\n                      (cond ((equal? (string=? str\
    \ (string-append substring \"\")) true)\n                            (+ 1 (how_many_times\
    \ (string-append substring \"\") substring)))\n                            ((equal?\
    \ (string=? str (string-append substring \"\")) false)\n                     \
    \       (+ 1 (how_many_times (string-append substring str) substring)))\n    \
    \                  (else 0))))))) ; <<<\n", "  (define (how_many_times_helper\
    \ string substring count)\n    (cond [(zero? count) 0]\n          [(equal? (string-ref\
    \ string 0) substring) (+ 1 (* count 1))]\n          [else (let ([s (string-ref\
    \ string 0)\n                    (e (substring (equal? s substring) 1)\n     \
    \               (rest (string-rest (equal? s substring) 1))])\n              \
    \  (if (or (zero? e) (null? rest))\n                    (how_many_times_helper\
    \ (concatenate 'string\n                                                    (string-append\
    \ s (substring (equal? s substring) 1))\n                                    \
    \                (substring (equal? s substring) 1 e) 1)\n                   \
    \                 (- count 1))\n                    (how_many_times_helper (concatenate\
    \ 'string\n                                                    (string-append\
    \ s e)\n                                                    (substring (equal?\
    \ s substring) 1 e))\n                                    (+ count 1)))))])\n\
    \  (how_many_times_helper string substring 0))\n", "  (let loop ([cnt 0])\n  \
    \  (cond\n      [(string? string) (+ cnt 1)]\n      [(string=? string substring)\
    \ (loop (+ cnt 1))]\n      [else (loop (+ cnt 1))])))\n", "  (cond\n    ((empty?\
    \ substring) 0)\n    ((equal? string substring) (+ 1 (how_many_times \"\" (rest\
    \ substring))))\n    (else (how_many_times (rest string) (substring string)))))\n",
  "  (cond\n    [(empty? substring) 0]\n    [(equal? (first substring) (string)) 1]\n\
    \    [else (+ 1 (how_many_times (rest substring) string))]))\n", "  (if (empty?\
    \ string)\n      0\n      (if (equal? substring \"\")\n          0\n         \
    \ (+ 1 (how_many_times (cdr string) substring))))))", "  (string-length string)\
    \ \n  (let ([s (string-match substring string)])\n    (if s\n        (+ 1 (how_many_times\
    \ s (substring s)))\n        (string-length string)))) \n", "  (cond\n    [(string-length\
    \ string = 0 substring)\n     (assert 0 \"Expected string to be non empty\")\n\
    \     (assert 0 \"Expected substring to be non empty\")\n     (assert 0 (string->list\
    \ string))\n     (assert 0 (string->list substring))\n     (assert 0 (string->list\
    \ substring))\n     (assert 0 (string->list substring))\n     (assert 0 (string->list\
    \ substring))\n     (assert 0 (string->list substring))\n     (assert 0 (string->list\
    \ substring))\n     (assert 0 (string->list substring))\n     (assert 0 (string->list\
    \ substring))\n     (assert 0 (string->list substring))\n     (assert 0 (string->list\
    \ substring))\n     (assert 0 (string->list substring))\n     (assert 0 (string->list\
    \ substring))\n     (assert 0 (string->list substring))\n     (assert 0 (string->list\
    \ substring))\n     (assert 0 (string->list substring))\n     (assert 0 (string->list\
    \ substring))\n     (assert 0 (string->list substring))\n     (assert 0 (string->list\
    \ substring))\n     (assert 0 (string->list substring))\n     (assert 0 (string->list\
    \ substring))\n     (assert 0 (string->list substring))\n     (assert 0 (string->list\
    \ substring))\n     (assert 0 (string->list substring))\n     (assert 0 (string->list\
    \ substring))\n     (assert 0 (string->list substring))\n     (assert 0 (string->list\
    \ substring))\n     (assert 0 (string->list substring))\n     (assert 0 (string->list\
    \ substring))\n     (assert 0 (string->list substring))\n     (assert 0 (string->list\
    \ substring))\n     (assert 0 (string->list substring))\n     (assert 0 (string->list\
    \ substring))\n     (assert 0 (string->list substring))\n     (assert 0 (string->list\
    \ substring))\n     (assert 0 (string->list substring))\n     (assert 0 (string->list\
    \ substring))\n     (assert 0 (string->list substring))\n     (assert 0 (string->list\
    \ substring))\n     (assert 0 (string->list substring))\n     (assert 0 (string->list\
    \ substring))\n     (assert 0 (string->list substring))\n     (assert 0 (string->list\
    \ substring))\n     (assert 0 (string->list substring))\n     (assert 0 (string->list\
    \ substring))\n     (assert 0 (string->list substring))\n     (assert 0 (string->list\
    \ substring))\n     (assert 0 (string->list substring))\n     (assert 0 (string->list\
    \ substring))\n     (assert 0 (string->list substring))\n     (assert 0 (string->list\
    \ substring))\n     (assert 0 (string->list substring))\n     (assert 0 (string->list\
    \ substring))\n", "  (/ (string-length string) (string-length substring)))\n",
  "  (cond\n    ((string-length = string) 0)\n    ((equal? (string-ref string 0) substring)\
    \ 1)\n    ((equal? (string-ref string (string-length (string-ref string 0))) substring)\
    \ 2)\n    (else (+ 3 (how_many_times string (string-append substring (string-ref\
    \ string 0)))))))\n", "  (if (string=? string substring)\n      (length substring)\n\
    \      (length (string-index-of string substring))\n  ))\n", "  (define (helper\
    \ s i j)\n    (cond ((>= i j) (length s))\n          ((eqv? (substring s (substring\
    \ s i (substring s i j))) (substring s i j)) (+ 1 (helper s (+ i 1) j)))\n   \
    \       (t (helper s (+ i 1) (+ j 1)))))\n  (helper string 0 (length string)))\n",
  "  (cond\n    [(empty? substring) 0]\n    [(equal? (substring 0) (string-ref string\
    \ 0)) 1])\n  ;; TODO: Optimize for speed and memory (using tail recursion).\n\
    \  (cond\n    [(equal? (string-ref string 0) (string-ref substring 0)) (* (how_many_times\
    \ (string->list (substring 1)) (substring 2))]\n    [else (* (how_many_times (substring\
    \ 1) (string->list (substring 2))))]))\n</cell>\n<code language=dyalog-kernel>",
  "  (let ((start-index (position-if substring string)))\n    (length (position-if\
    \ (substring string) string))))", "  (let loop ((count 0) (string-length (string->list\
    \ string)))\n    (if (< count string-length)\n        (begin\n          (cond\
    \ ((and (null? substring) (null? (string->list string)))\n                 (+\
    \ count 0))\n                ((equal? (car substring) (string->list (string->char\
    \ string (cdr substring)))))\n                (else\n                 (loop (+\
    \ count 1) (cdr substring)))\n                (else\n                 (loop (+\
    \ count 1) (cons (car substring) '())))\n            )\n        (loop 0 0))))\n",
  "  (cond\n    ((string=? string \"\")  0)\n    ((string=? string substring) 1)\n\
    \    ((string=? substring \"\")  0)\n    ((string=? substring substring) 1)\n\
    \    (else (+ 1 (how_many_times (substring string) (substring substring)))))\n",
  "  (cond [(or (= string \"\") (string-equal? string substring)) 0]\n        [else\
    \ (+ 1 (how_many_times (rest string) substring))]))\n", "  (define (how_many count)\n\
    \    (cond\n      [(or (equal? (length string) 0)\n           (equal? (length\
    \ substring) 0))\n       (count)\n       \n      [(equal? (substring string 0)\
    \ (string-ref string 0))\n       (how_many (+ count 1))]\n      [(equal? (substring\
    \ string 0)\n              (string-ref substring 0))\n       (how_many (+ count\
    \ 1))]\n      [(equal? (substring string 0)\n              (string-ref substring\
    \ 0))\n       (how_many (+ count 1))]\n      [(equal? (substring string 0)\n \
    \             (string-ref substring 0))\n       (how_many (+ count 1))]\n    \
    \  [(equal? (substring string 0)\n              (string-ref substring 0))\n  \
    \     (how_many (+ count 1))]\n      [(equal? (substring string 0)\n         \
    \     (string-ref substring 0))\n       (how_many (+ count 1))]\n      [(equal?\
    \ (substring string 0)\n              (string-ref substring 0))\n       (how_many\
    \ (+ count 1))]\n      [(equal? (substring string 0)\n              (string-ref\
    \ substring 0))\n       (how_many (+ count 1))]\n      [(equal? (substring string\
    \ 0)\n              (string-ref substring 0))\n       (how_many (+ count 1))]\n\
    \      [(equal? (substring string 0)\n              (string-ref substring 0))\n\
    \       (how_many (+ count 1))]\n      [(equal? (substring string 0)\n       \
    \       (string-ref substring 0))\n       (how_many (+ count 1))]\n      [(equal?\
    \ (substring string 0)\n              (string-ref substring 0))\n       (how_many\
    \ (+ count 1))]\n      [(equal? (substring string 0)\n              (string-ref\
    \ substring 0))\n       (how_many (+ count 1))]\n      [(equal? (substring string\
    \ 0)\n              (string-ref substring 0))\n       (how_many (+ count 1))]\n\
    \      [(equal? (substring string 0)\n              (string-ref substring 0))\n\
    \       (how_many (+ count 1))]\n      [(equal? (substring string 0)\n       \
    \       (string-ref substring 0))\n       (how_many (+ count 1))]\n      [(equal?\
    \ (substring string 0)\n              (string-ref substring 0))\n       (how_many\
    \ (+ count 1))]\n      [(equal? (substring string 0)\n              (string-ref\
    \ substring 0))\n       (how_many (", "  (check-type string string)\n  (check-type\
    \ substring string)\n\n  (define (helper string substring)\n    (if (null? string)\n\
    \        0\n        (if (string=? (first string) substring)\n            (+ 1\
    \ (helper (rest string) substring))\n            (+ 1 (helper (rest string) substring))))\n\
    \n  (helper string substring))\n", "  (cond [(empty? string) 0]\n        [(string=?\
    \ substring (string-ref string 0)) 1]\n        [else (+ 0 (- (how_many_times (string-tail\
    \ string) substring)\n                     (how_many_times (string-tail string)\
    \ (string-ref string 0))))]))\n", "  (count\n   (lambda (i string) (equal? string\
    \ (substring i))) (range) 0))\n", "  (cond\n    [(empty? string) #f]\n    [(empty?\
    \ substring) #f]\n    [(equal? substring (string-ref string 0)) #f]\n    [else\
    \ (+ 1 (how_many_times (string-upcase string) (substring (string-ref string 0))))]))\n",
  "  (cond\n    [(string? string)\n     (cond\n       [(string? substring)\n     \
    \   (string-length (substring string))\n       ]\n       [(string? substring)\
    \ (string-length substring) 0]\n       [else (string-length substring) 0]\n  \
    \     ]\n     [else (raise-invalid-type string \"How_many_times string not valid\
    \ string.\")]\n     )\n    ])\n", "  (let ((count 0))\n    (if (null? string)\n\
    \        0\n        (if (equal? (car string) substring)\n            (+ count\
    \ 1)\n            (if (substring (car string))\n                (+ count 1)\n\
    \                (if (equal? (cdr string) substring)\n                    (+ count\
    \ 1)\n                    (if (substring (cdr string))\n                     \
    \   (+ count 1)\n                        (how_many_times (cdr string) substring)\n\
    \                    )\n                )\n            )\n        )\n    )\n \
    \ )\n)\n", "  (if (eql string \"\") 0\n      (let ((len (string-length string))\n\
    \            (idx (string-index string substring)))\n        (if (< idx len)\n\
    \            (- idx (len (string-to-integer substring)))))))\n</code>\n<|/ a |>\n\
    <| a |>\nThe answer is simple: just use the function string-length.\n<code>",
  "  (cond ((string-empty? string)\n         0)\n        ((string-equal? string (substring\
    \ 0))\n         1)\n        ((substring 0 (string-length string))\n         (+\
    \ 1 (how_many_times (substring 1) substring)))\n        (else\n         (how_many_times\
    \ (substring 0) substring)\n         (+ 1 (how_many_times (substring 1) substring)))))\n\
    </code>\n<code>", "  (cond (string= \"\" substring)\n        0\n        (string=\
    \ substring \"\")\n        (string= string substring)\n        (string= (substring\
    \ 0 (string-length string)) string)\n        ((string= (substring 0 (string-length\
    \ string)) string)\n         (+ 1 (how_many_times (substring 0 (string-length\
    \ string)) (string-append substring \"\"))))\n        ((string= (substring 0 (string-length\
    \ string)) string)\n         (+ 1 (how_many_times (substring 0 (string-length\
    \ string)) (string-append substring \"\"))))\n        (else\n         (how_many_times\
    \ (substring 0 (string-length string)) (string-append substring \"\"))))) ; else\
    \ do recursion", "  (cond [(empty? string) #f]\n        [(eq? (car string) substring)\
    \ #1]\n        [(eq? (car string) substring) 0]\n        [else (+ 1 (how_many_times\
    \ string substring))]))\n", "  (cond\n    [(empty? substring) 0]\n    [(string-equal?\
    \ substring \"\") 0]\n    [else (let ([substring (remove-if #(equal? (string-length\
    \ %) 0) substring))]\n             (+ 0 (cond\n                  [(string-equal?\
    \ substring \"\") 1]\n                  [else (cond\n                        \
    \ [(string-equal? (substring (- 0 (string-length substring)) string) \"\")\n \
    \                          (+ 0 (how_many_times string substring))]\n        \
    \                 [else (how_many_times string (substring (- 0 (string-length\
    \ substring)) string))]))]))]))\n", "  (let loop ((substring substring) (string\
    \ string)\n             (result 0))\n    (if (or (= string \"\") (= substring\
    \ \"\"))\n        result\n        (loop (substring (car substring)) (cdr string)\n\
    \               (add1 result)))))\n", "  (count (string-index-of string substring\
    \ 0))\n)\n", "  (cond\n    [(empty? string) 0]\n    [(not (equal? (first string)\
    \ substring)) (+ 1 (how_many_times (rest string) substring))]))\n</cell>\n<cell>\n\
    #lang racket\n", "  (- 0 (string-length string)\n      (string-length substring)))\n",
  "  (cond\n    [(empty? substring) 0]\n    [(equal? (substring 0) (first substring))\
    \ 1])\n  (+ 1))\n", "  (loop for i from 0 to (length string)\n       collect (if\
    \ (string=? (substring (string-ref string i)) substring)\n                   (+\
    \ (if (string=? (substring (string-ref string i)) substring) 1)\n            \
    \         (if (string=? (substring (string-ref string (i+1))) substring)\n   \
    \                      (+ (if (string=? (substring (string-ref string (i+1)))\
    \ substring) 1)\n                           (if (string=? (substring (string-ref\
    \ string (i+1)) (i+1))) \n                               (+ (if (string=? (substring\
    \ (string-ref string (i+1)) (i+1))) 1)\n                                 (if (string=?\
    \ (substring (string-ref string (i+1)) (i+1))) 0)))))))\n</code>\n<|/ a dscore=1\
    \ |>\n<| c |>\nI should point out that the above code is in Racket.  It uses `for`\
    \ and `collect`.  You can find the equivalent code in any modern programming language\
    \ that is based on Scheme.  There are also equivalents for `map`, `filter` and\
    \ `reduce` - they're very useful.\n<|/ c |>\n<| c |>\nThank you so much for the\
    \ help! I will try implementing this in my code. I'll let you know if it works\
    \ and if not, I'll try working it out on my own.\n<|/ c |>\n<| c |>\nThis works\
    \ amazingly well and I'm still really trying to understand it but it works really\
    \ well. Thanks again\n<|/ c |>\n<| a |>\nIf you're looking for an iterative solution,\
    \ here's one that uses an accumulator:\n<code>"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
