name: HumanEval_30_get_positive
language: rkt
prompt: "#lang racket\n\n;; Return only positive numbers in the list.\n;; >>> (get_positive\
  \ (list -1 2 -4 5 6))\n;; (list 2 5 6)\n;; >>> (get_positive (list 5 3 -5 2 -3 3\
  \ 9 0 123 1 -10))\n;; (list 5 3 2 3 9 123 1)\n(define (get_positive l)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate get_positive))\n\
  \    (check-equal? (candidate (list -1 -2 4 5 6)) (list 4 5 6))\n    (check-equal?\
  \ (candidate (list 5 3 -5 2 3 3 9 0 123 1 -10)) (list 5 3 2 3 3 9 123 1))\n    (check-equal?\
  \ (candidate (list -1 -2)) (list ))\n    (check-equal? (candidate (list )) (list\
  \ ))\n))\n\n(test-humaneval)"
completions: ["  (if (null? l) '()\n      (cons (car l)\n            (get_positive\
    \ (cdr l)))))\n", "  (filter (lambda (x) (and (number? x) (> x 0))) l))\n", " \
    \ (filter\n   (lambda (x)\n     (> x 0))\n   l))\n", "  (filter (lambda (x) (>\
    \ x 0)) l))\n", "  (cond ((null? l) '())\n        ((null? (cdr l)) (cons (car\
    \ l) (get_positive (cdr l))))\n        (else (cons (car l) (get_positive (cdr\
    \ l))))))\n</cell>\n<cell>\n#lang racket\n", "  (filter (lambda (x) (< x 0)) l))\n",
  "  (cond\n    ((null? l) '())\n    ((< (car l) 0) l)\n    (else (cons (car l) (get_positive\
    \ (cdr l))))))\n", "  (filter (lambda (x) (not (< x 0))) (map reverse l)))\n</code>\n\
    <|/ a |>\n<| a tags=scheme,racket |>\nHere's a concise definition that doesn't\
    \ require a filter:\n<code>", "  (define (helper x)\n    (if (< x 0) (list x)\
    \ \n        (helper (- x 1))))\n  (helper 1))\n", "  (filter positive? l))\n",
  "  (cond\n    ((null? l)\n     (empty))\n    ((number? (car l))\n     (cons (car\
    \ l) \n           (get_positive (cdr l))))\n    (else\n     (get_positive (cdr\
    \ l))))\n", "  (filter positive? (reverse l)))\n", "  (cond\n    [(empty? l) (list\
    \ '())]\n    [(> (first l) 0) (cons (first l) (get_positive (rest l)))]\n    [else\
    \ (cons (first l) (get_positive (rest l)))]))\n", "  (filter (lambda (n) (> n\
    \ 0))\n          l))\n", "  (cond ((null? l) l)\n        ((not (number? (first\
    \ l))) l)\n        (#t (cons (first l) (get_positive (rest l))))))", "  (cond\n\
    \    ((null? l) '())\n    ((> first l) (cons (first l) (get_positive (list rest\
    \ (rest l)))))\n    (else (get_positive (list rest (rest l)))))\n  )\n", "  (cond\
    \ [(empty? l) empty]\n        [(positive? (first l)) (cons (first l) (get_positive\
    \ (rest l)))]\n        [else (cons (first l) (get_positive (rest l)))]))\n", " \
    \ (cond\n    [(empty? l) '()]\n    [(equal? (first l) '-) '()]\n    [else\n  \
    \   (append (filter (lambda (x) (equal? (first l) x))\n                    (get_positive\
    \ (rest l)))\n             (first l))]\n  )\n)\n", "  (cond ((null? l)\n     \
    \    (list))\n        ((> (first l) 0)\n         (cons (first l) (get_positive\
    \ (rest l)))\n         (get_positive (rest l)))))\n", "  (filter (lambda (x) (and\
    \ (number? x) (> x 0))) (map number? l)))\n", "  (cond [(empty? l) empty]\n  \
    \      [(number? (car l)) (cons (car l) empty)]\n        [else (cons (car l) (get_positive\
    \ (cdr l)))]))\n", "  (cond\n    ((null? l) '())\n    ((not (pair? l)) (cons (car\
    \ l) (get_positive (cdr l))))\n    (else (cond\n          ((< 0 (car l)) (cons\
    \ (car l) (get_positive (cdr l))))\n          (else (cons (car l) (get_positive\
    \ (cdr l)))))\n          )\n      )\n    )\n", "  (filter (lambda (x) (> x 0))\
    \ l))\n", "  (if (null? l)\n      (list)\n      (cons (car l)\n            (get_positive\
    \ (cdr l)))))\n", "  (filter (lambda (x) (> x 0)) (map reverse l)))\n", "  (if\
    \ (null? l)\n      (list)\n      (if (number? (car l))\n          (cons (car l)\
    \ (get_positive (cdr l)))\n          (if (negative? (car l))\n              (cons\
    \ (car l) (get_positive (cdr l)))\n              (get_positive (cdr l)))))) ;;\
    \ (car l)))))) ;; (car l))))\n", "  (filter (lambda (n) (> n 0)) l))\n", "  (cond\
    \ [(null? l) '()]\n        [(>= (rest l) 0) (cons (first l) (get_positive (rest\
    \ l)))]\n        [else (cons (first l) (get_positive (rest l)))]))\n", "  (cond\n\
    \    ((null? l) '())\n    ((< (car l) 0) (cons (car l) (get_positive (cdr l))))\n\
    \    (else (cons (car l) (get_positive (cdr l)))))\n)\n", "  (cond\n    ((empty?\
    \ l) '())\n    ((number? (first l))\n     (cons (first l)\n           (get_positive\
    \ (rest l))))\n    ((< 0 (first l))\n     (cons (first l)\n           (get_positive\
    \ (rest l))))))\n", "  (cond ((empty? l) '())\n        ((< first l) (cons (first\
    \ l) (get_positive (rest l))))\n        (else (get_positive (rest l)))))\n", " \
    \ (filter (lambda (x) (number? x)) l))\n", "  (filter\n   (\u03BB (x)\n     (not\
    \ (= x 0))\n     (> x 0))\n   l))\n", "  (cond\n    [(empty? l) (empty)]\n   \
    \ [(> (car l) 0) (cons (car l) (get_positive (cdr l)))]\n    [else (get_positive\
    \ (cdr l))]))\n", "  (let loop ((l l) (g null) (e null))\n    (if (null? l)\n\
    \        (reverse g)\n        (let ((g (cons (car l) g))\n              (e (cdr\
    \ l)))\n          (if (null? e)\n              (loop (cdr l) g null)\n       \
    \       (loop (cdr e) (cons (car e) g) null)))))\n", "  (filter (lambda (x) (<\
    \ x 0)) l))\n", "  (cond [(null? l) l]\n        [(positive? (car l)) (cons (car\
    \ l) (get_positive (cdr l)))]\n        [else (get_positive (cdr l))]))\n", " \
    \ (filter positive? l))\n", "  (cond\n    [(null? l) '()]\n    [(number? (car\
    \ l)) (cons (car l) (get_positive (cdr l)))]\n    [else (cons (car l) (get_positive\
    \ (cdr l)))]))\n", "  (filter (lambda (v) (< v 0)) l))\n", "  (filter (\u03BB\
    (x) (and (number? x) (> x 0))) l))\n", "  (filter (lambda (x) (not (negative?\
    \ x))) l))\n", "  (filter (lambda (x) (not (< x 0))) l))\n", "  (cond\n    ((null?\
    \ l) '())\n    ((not (positive? (car l)))\n     (cons (car l) (get_positive (cdr\
    \ l))))\n    (else (cons (car l)\n              (get_positive (cdr l)))))\n  )\n",
  "  (let loop ((lst lst)\n             (result '()))\n    (cond ((null? lst) result)\n\
    \          ((positive? (first lst)) (loop (rest lst) (cons (first lst) result)))\n\
    \          (else (loop (rest lst) result)))\n    ))\n", "  (filter positive? (reverse\
    \ l)))\n", "  (filter positive? (map positive? (list l))))\n", "  (if (null? l)\n\
    \      '()\n      (cons (car l)\n            (get_positive (cdr l)))))\n", " \
    \ (cond ((null? l) '())\n        ((number? l) l)\n        (else (cons (car l)\n\
    \                     (get_positive (cdr l)))))) ; #'\n", "  (cond\n    [(empty?\
    \ l)\n     (cons (first l) (get_positive (rest l)))]\n    [(> first l)\n     (cons\
    \ (first l) (get_positive (rest l)))]\n    [else\n     (cons (first l) (get_positive\
    \ (rest l)))]))\n", "  (cond [(empty? l) empty]\n        [(positive? (car l))\
    \ (get_positive (cdr l))]\n        [else (cons (car l) (get_positive (cdr l)))]))\n",
  "  (filter positive? l))\n", "  (flatten\n   (filter\n    (fn [x]\n      (and (>\
    \ x 0) (< x 0))\n      )\n    l\n    )\n  )", "  (filter (lambda (x) (< x 0))\
    \ l))\n", "  (cond ((null? l) '())\n        ((= (car l) 0) l)\n        (else (cons\
    \ (car l) (get_positive (cdr l)))))\n)\n", "  (flatten (filter (lambda (x)\n \
    \                 (>= x 0))\n                 l)))\n", "  (cond ((null? l) nil)\n\
    \        ((not (number? (car l)))\n         (cons (car l) (get_positive (cdr l))))\n\
    \        (else (cons (car l) (get_positive (cdr l)))))\n  )\n  ", "  (cond [(null?\
    \ l) '()]\n        [(number? l) (list l)]\n        [(> (first l) (first l)) (get_positive\
    \ (rest l))]\n        [else (cons (first l) (get_positive (rest l)))]))\n", " \
    \ (filter positive? l))\n", "  (cond\n    ((null? l)      l)\n    ((list? l) \
    \     (filter (lambda (x) (> x 0)) (get_positive (cons (car l) l)))\n    (else\
    \            get_positive (cons (car l) l))))", "  (let loop ((lst lst) (result\
    \ '()))\n    (cond\n      [(null? lst) result]\n      [else\n       (let ((el\
    \ (car lst))\n             (rest (cdr lst)))\n         (if (>= el 0)\n       \
    \      (loop (append rest result) (list el))\n             (loop (append result\
    \ lst) (list el)))))]\n  ))\n", "  (filter (lambda (e) (>= (length e) 0))\n  \
    \        l))\n", "  (filter positive? l))\n", "  (cond\n    [(empty? l) empty]\n\
    \    [(positive? (first l)) (cons (first l) (get_positive (rest l)))]\n    [else\
    \ (cons (first l) (get_positive (rest l)))]))\n", "  (filter (lambda (n) (> n\
    \ 0)) (l))\n)\n", "  (filter (lambda (e) (> (or e 0) e)) l))\n", "  (cond\n  \
    \  [(empty? l) empty]\n    [(positive? (first l)) (cons (first l) (get_positive\
    \ (rest l)))]\n    [else (cons (first l) (get_positive (rest l)))]))\n", "  (if\
    \ (empty? l) '()\n      (let ((x (car l))\n            (y (get_positive (cdr l))))\n\
    \        (if (positive? x)\n            (cons x y)\n            (cons x (cons\
    \ y '()))))))\n", "  (filter (\u03BB(x) (< x 0)) l))\n", "  (cond [(null? l)\n\
    \         (list nil)]\n        [(> head tail)\n         (cons (head l)\n     \
    \         (get_positive (tail l)))]\n        [else (cons (head l)\n          \
    \           (get_positive (tail l)))]))\n", "  (cond\n    [(empty? l) '()]\n \
    \   [(> first l) (cons first l)]\n    [else (cons (first l) (get_positive (rest\
    \ l)))]))\n", "  (filter (lambda (v) (positive? v))\n          l))\n", "  (cond\n\
    \    ((null? l) '())\n    ((> (car l) 0) (cons (car l) (get_positive (cdr l))))\n\
    \    (else (get-positive (cdr l)))))\n", "  (cond\n    ((null? l)\n     l)\n \
    \   ((zero? (car l))\n     (cons (car l) (get_positive (cdr l))))\n    (else\n\
    \     (append (get_positive (car l))\n             (list (car l)))))) ; cons returns\
    \ its first element\n", "  (cond\n    ((null? l) l)\n    ((> first l) (cons (first\
    \ l) (get_positive (rest l))))\n    (else (cons (first l) (get_positive (rest\
    \ l))))))\n", "  (if (null? l)\n      '()\n      (cond\n        [(>= (car l) 0)\
    \ (cons car l)]\n        [else (get_positive (cdr l))]))) ; recurse\n", "  (cond\n\
    \    ((null? l) '())\n    ((> car l) (cons (car l) '()))\n    (else (cons (car\
    \ l) (get_positive (cdr l))))))\n", "  (cond [(empty? l) '()]\n        [(number?\
    \ (car l)) (cdr l)]\n        [else (cons (car l) (get_positive (cdr l)))]))\n",
  "  (filter positive? l))\n", "  (filter (lambda (x) (> x 0))\n          l))\n",
  "  (cond\n    [(empty? l) (list nil)]\n    [(zero? (first l))\n     (if (empty?\
    \ (rest l)) l (cons (first l) (get_positive (rest l))))]\n    [else (cons (first\
    \ l) (get_positive (rest l)))]))\n", "  (cond\n    [(empty? l) empty]\n    [(positive?\
    \ (car l)) (cons (car l) (get_positive (cdr l)))]\n    [else (cons (car l) (get_positive\
    \ (cdr l)))]))\n", "  (cond\n    ((null? l) l)\n    ((or (number? (car l))\n \
    \        (string? (car l)))\n     (cons (car l) (get_positive (cdr l))))\n   \
    \ ((number? (car l)) (cons (car l) (get_positive (cdr l))))\n    (else (get_positive\
    \ (cdr l)))))\n", "  (filter (\u03BB (x) (> x 0)) l))\n", "  (filter number? l))\n",
  "  (filter positive? (reverse l)))\n", "  (cond\n    ((null? l) '())\n    ((list?\
    \ (car l)) (cons (car l) (get_positive (cdr l))))\n    ((not (number? (car l)))\
    \ l)\n    (else (cons (car l) (get_positive (cdr l))))))\n", "  (cond ((null?\
    \ l) (list l))\n        ((not (pair? l))\n         (list l))\n        (else\n\
    \         (append (list l) (get_positive (cdr l)))))\n", "  (let ((res (list l)))\n\
    \    (cond\n      [(empty? l) (empty? res)]\n      [else (cons (car l) (get_positive\
    \ (cdr l)))]\n    )\n    ))\n", "  (filter positive? l))\n", "  (cond [(null?\
    \ l)\n         l]\n        [(null? (cdr l))\n         (append l (list (car l)))]\n\
    \        [else\n         (append l (list (- (car l) (car l))))]))\n", "  (cond\
    \ [(null? l) l]\n        [(positive? (first l)) (cons (first l) (get_positive\
    \ (rest l)))]\n        [else (cons (first l)\n                    (get_positive\
    \ (rest l)))]))\n", "  (cond\n    [(empty? l) empty]\n    [(positive? (first l))\
    \ (cons (first l) (get_positive (rest l)))]\n    [else (get_positive (rest l))]))\n",
  "  (filter (lambda (x) (> x 0)) l))\n</code>\n<|/ a |>\n<| c |>\nI guess you meant\
    \ `filter (lambda (x) (> x 0))` instead of `(lambda (x) (> x 0))`.\n<|/ c |>\n\
    <| c |>\n: I actually meant `filter (lambda (x) (> x 0))` :) It's been a long\
    \ day and I was tired when I wrote that.\n<|/ c |>\n<| a |>\nAs others have noted,\
    \ this problem is actually a very good example for a recursive definition.  It's\
    \ not so much \"how would I do this\", but \"how do I do this recursively\". \
    \ In other words, how would you do the following without using loops?\n<code>",
  "  (cond\n    [(empty? l) '()]\n    [(pair? l) (cons (car l) (get_positive (cdr\
    \ l)))]\n    [else (cons (car l) (get_positive (cdr l)))]))\n", "  (filter positive?\
    \ l))\n", "  (filter (lambda (x) (>= x 0)) l))\n", "  (filter (lambda (e) (> e\
    \ 0)) l))\n", "  (filter (lambda (n) (positive? n)) l))\n", "  (cond ((null? l)\
    \ '())\n        ((not (number? (car l))) (list car l))\n        (else (cons (car\
    \ l) (get_positive (cdr l))))))\n", "  (cond\n    [(empty? l) (list l)]\n    [(positive?\
    \ (first l)) (cons (first l) (get_positive (rest l)))]\n    [else (cons (first\
    \ l) (get_positive (rest l)))]))\n", "  (cond\n    ((null? l) '())\n    ((> (car\
    \ l) 0) (cons (car l) (get_positive (cdr l))))\n    (else (get_positive (cdr l))))\n\
    \  )\n)\n", "  (filter (lambda (x) (< x 0)) l))\n", "  (cond\n    [(empty? l)\
    \ l]\n    [(number? (first l)) (cons (first l) (get_positive (rest l)))]\n   \
    \ [else (cons (first l) (get_positive (rest l)))]))\n", "  (cond\n    [(null?\
    \ l) l]\n    [(> (first l) 0) (cons (first l) (get_positive (rest l)))]\n    [else\
    \ (cons (first l) (get_positive (rest l)))]))\n", "  (cond\n    [(empty? l) '()]\n\
    \    [(number? (car l)) (cons (car l) (get_positive (cdr l)))]\n    [else (get_positive\
    \ (cdr l))]))\n", "  (filter (lambda (x) (> x 0)) l))\n", "  (filter positive?\
    \ (map reverse l)))\n</code>\n<|/ a tags=list,scheme,racket,filtering |>\n<| c\
    \ |>\nOh my, I really like this answer. Thank you. I'm new to scheme and I haven't\
    \ been able to get my head around it yet but I appreciate your time and effort.\n\
    <|/ c |>\n<| c |>\nI figured it out. Thank you so much for all your help! You're\
    \ a lifesaver.\n<|/ c |>\n<| a |>\nHere's another take on the problem. Since Scheme\
    \ doesn't have a filter function I've created my own. I've used a named let binding\
    \ so it's easy to see what's going on.\n<code>", "  (cond\n    ((null? l)    \
    \  l)\n    ((zero? (car l))   (cons (car l) (get_positive (cdr l))))\n    (else\
    \            (append (get_positive (car l))\n                                (get_positive\
    \ (cdr l))))))\n", "  (if (null? l)\n      '()\n      (if (< 0 (car l))\n    \
    \      (cons (car l) (get_positive (cdr l)))\n          (cons (car l) (get_positive\
    \ (cdr l)))))) ;; #lang racket\n", "  (filter positive? l))\n", "  (if (null?\
    \ l)\n      '()\n      (cons (car l)\n            (get_positive\n            \
    \ (filter (lambda (x) (>= x 0)) (cdr l)))))", "  (cond\n    ((null? l)\n     empty)\n\
    \    ((< (first l) (first l))\n     (cons (first l) (get_positive (rest l)))\n\
    \     (get_positive (rest l)))\n    (else\n     (get_positive (rest l)))))\n",
  "  (filter (lambda (x) (> x 0)) l))\n", "  (cond\n    [(empty? l) '()]\n    [(zero?\
    \ (first l)) '()]\n    [else (cons (first l)\n              (get_positive (rest\
    \ l)))]))\n", "  (cond [(null? l)\n         (empty? l)\n         l]\n        [(positive?\
    \ (car l))\n         (cons (car l) (get_positive (cdr l)))]\n        [else\n \
    \        (cons (car l) (get_positive (cdr l)))]))\n", "  (cond\n    [(empty? l)\
    \ '()]\n    [(< (first l) 0) (cons (first l) (get_positive (rest l)))]\n    [else\
    \ (get_positive (rest l))]\n  )\n)\n", "  (filter (lambda (e) (> e 0)) l))\n",
  "  (if (empty? l)\n      '()\n      (cons (car l)\n            (get_positive\n \
    \            (cdr l))))) \n", "  (if (empty? l) '()\n      (cond ((> car l) (cons\
    \ (car l) (get_positive (cdr l))))\n            (else (cons (car l) (get_positive\
    \ (cdr l)))))))\n", "  (cond\n    ((empty? l) '())\n    ((number? (first l)) (cons\
    \ (first l) (get_positive (rest l))))\n    ((list? (first l))\n     (map (lambda\
    \ (n) (get_positive n)) (first l)))))\n", "  (cond\n    [(empty? l) '()]\n   \
    \ [(not (positive? first (first l)))\n     (append (list (first l)) (list (get_positive\
    \ (rest l))))]\n    [else (append (list (first l))\n                   (list (get_positive\
    \ (rest l))))]))\n", "  (cond\n    [(empty? l) '()]\n    [(positive? (first l))\
    \ (cons (first l) (get_positive (rest l)))]\n    [else (get_positive (rest l))]))\n",
  "  (filter (lambda (x) (positive? x))\n          l))\n", "  (filter positive? (map\
    \ reverse l)))\n", "  (cond [(null? l)\n         #t]\n        [(null? (cdr l))\n\
    \         (list (car l))]\n        [else\n         (cons (car l) (get_positive\
    \ (cdr l)))]))\n", "  (filter positive? l))\n</code>\n<|/ a dscore=0 tags=scheme\
    \ |>\n<| a dscore=0 |>\nUsing only lists:\n<code>", "  (filter (lambda (x) (>\
    \ x 0)) l))\n", "  (filter \n   (\u03BB (x)\n     (not (negative? x))) \n   l))\n",
  "  (filter positive? l))\n", "  (cond\n    [(null? l) '()]\n    [(number? (car l))\
    \ (car l)]))\n", "  (filter positive? l))\n", "  (filter (lambda (i) (> i 0))\
    \ l))\n", "  (cond\n    [(null? l) empty]\n    [(>= (first l) (first '())) (cons\
    \ (first l) (get_positive (rest l)))]\n    [else (cons (first l) (get_positive\
    \ (rest l)))]))\n", "  (cond\n    [(null? l)\n     '()]\n    [(positive? (car\
    \ l))\n     (cons (car l)\n           (get_positive (cdr l)))]\n    [else\n  \
    \   (get_positive (cdr l))]))\n", "  (let loop ((lst l) (nums null))\n    (if\
    \ (empty? lst)\n        nums\n        (loop (rest lst)\n              (cond [(<\
    \ 0 (first lst)) (cons (first lst)\n                                         \
    \   nums)])))))\n", "  (filter (lambda (x)\n            (not (negative? x))) l))\n",
  "  (filter (lambda (e) (> e 0)) l))\n", "  (filter (lambda (x) (> x 0)) l))\n",
  "  (cond\n    ((null? l) l)\n    ((number? (car l)) (cons (car l) (get_positive\
    \ (cdr l))))\n    (else (cons (car l)\n              (get_positive (cdr l))))))\n\
    </cell>\n<text>\nExercise\nExercise 1 (3pts): Write a recursive function that\
    \ returns true if a list is ordered in descending order and false if it is not.\n\
    \n\n</text>\n<code language=racket-language>", "  (cond\n    [(empty? l) '()]\n\
    \    [(number? (first l)) (cons (first l) (get_positive (rest l)))]\n    [else\
    \ (cons (first l) (get_positive (rest l)))]))\n", "  (cond [(empty? l) '()]\n\
    \        [(number? (first l)) (cons (first l) (get_positive (rest l)))]\n    \
    \    [else (cons (first l)\n                    (get_positive (rest l)))]))",
  "  (filter positive? (cons l '())))", "  (cond\n    [(empty? l) empty]\n    [else\
    \ (cons (car l)\n                (get_positive (cdr l)))]))\n", "  (filter (lambda\
    \ (item)\n            (and (> item 0) (< item 0)))\n          l))\n", "  (cond\n\
    \    ((null? l) l)\n    ((list? (car l)) (get_positive (car l))\n     (cond\n\
    \       ((< (car l) 0) l) ; negative number\n       ((= (car l) 0) l) ; zero\n\
    \       ((= (car l) 1) (cons (car l) l)) ; positive number\n       (else (append\
    \ (get_positive (car l)) (get_positive (cdr l))))))))) ; everything else\n", " \
    \ (cond\n    [(null? l) '()]\n    [(number? (car l)) (cdr l)]\n    [(< 0 (car\
    \ l)) (cons (car l) (get_positive (cdr l)))]))\n", "  (cond\n    [(null? l) '()]\n\
    \    [(member (car l) '(- 0)) (cons (car l) (get_positive (cdr l)))]\n    [else\
    \ (get_positive (cdr l))]))\n", "  (let loop ((n 0)\n             (res null))\n\
    \    (cond\n      [(null? l) (if (null? res) true res)]\n      [(< 0 (car l))\
    \ (loop (+ n 1) (cons (car l) res))]\n      [else (loop (+ n 1) (cons (car l)\
    \ res))]\n    ))\n)\n", "  (let loop ((l (list l)))\n    (cond\n      [(null?\
    \ l) l]\n      [else (cons (car l) (loop (cdr l)))])))\n", "  (filter (lambda\
    \ (n) (>= n 0))\n          l))\n", "  (cond\n    [(empty? l) empty]\n    [(not\
    \ (number? (first l)))\n     (cons (first l) (get_positive (rest l)))]\n    [else\
    \ (cons (first l) (get_positive (rest l)))]))", "  (filter (lambda (n)\n     \
    \       (or (< n 0) (< n 0))) l))", "  (cond\n    ((null? l) l)\n    ((zero? (car\
    \ l)) l)\n    ((< (car l) 0) (cons (car l) (get_positive (cdr l))))\n    (else\
    \ (get_positive (cdr l)))))\n", "  (filter\n   #(< % 0) l))\n", "  (cond\n   \
    \ ((null? l) l)\n    ((number? (car l)) (cons (car l) (get_positive (cdr l))))\n\
    \    (else (append (map (lambda (x) (get_positive x)) l) (list 0)))))\n", "  (cond\
    \ [(null? l) nil]\n        [(> <???> 0) <???>]\n        [else (get_positive <???>)]))\n",
  "  (remove-if\n   (lambda (x)\n     (and\n      (zero? (number->integer x))\n  \
    \    (not (negative? (number->integer x)))))\n   l))\n", "  (filter (lambda (x)\
    \ (and (number? x) (>= x 0))) (list l)))\n", "  (cond [(empty? l) empty]\n   \
    \     [(number? (first l)) (list first l)]\n        [else (cons (first l) (get_positive\
    \ (rest l)))]))\n", "  (cond\n    [(empty? l) '()]\n    [(positive? (first l))\
    \ (cons (first l) (get_positive (rest l)))]\n    [else (get_positive (rest l))]\n\
    \  ))\n", "  (if (null? l)\n      '()\n      (cons (car l)\n            (get_positive\
    \ (cdr l)))))\n", "  (cond ((null? l) '())\n        ((number? l) (list l))\n \
    \       (else (append (list (car l))\n                      (get_positive (cdr\
    \ l)))))) ;; tail recursive part\n", "  (if (empty? l)\n      '()\n      (cons\
    \ (car l)\n            (get_positive (cdr l)))))\n", "  (cond\n    ((null? l)\
    \ '())\n    ((< (car l) 0)) \n    (else (cons (car l) (get_positive (cdr l)))))\n\
    )\n", "  (filter positive? l))\n", "  (filter (lambda (v) (> v 0)) l))\n", " \
    \ (cond [(null? l)\n         l]\n        [(< (car l) 0)\n         (cons (car l)\n\
    \              (get_positive (cdr l)))]\n        [else\n         (get_positive\
    \ (cdr l))]))\n", "  (cond\n    ((empty? l) '())\n    ((not (pair? l))\n     (cons\
    \ (first l) (get_positive (rest l)))\n     (get_positive (rest l)))\n    ((not\
    \ (pair? (first l)))\n     (cons (first l) (get_positive (rest l)))\n     (get_positive\
    \ (rest l)))\n    ((< 0 (first l) (first l)) (cons (first l) (get_positive (rest\
    \ l)))\n     (get_positive (rest l)))\n    ((< 0 (first l) (rest (first l))) (cons\
    \ (first l) (get_positive (rest l)))\n     (get_positive (rest l)))\n    ((< 0\
    \ (rest (first l)) (rest (first l))) (cons (first l) (get_positive (rest l)))\n\
    \     (get_positive (rest l)))\n    ((< 0 (rest (rest (first l)))) (cons (first\
    \ l) (get_positive (rest l)))\n     (get_positive (rest l)))\n    ((< 0 (rest\
    \ (first l)) (rest (rest (first l))))\n     (cons (first l) (get_positive (rest\
    \ l)))\n     (get_positive (rest l)))\n    ((< 0 (rest (rest (first l)))) (cons\
    \ (first l) (get_positive (rest l)))\n     (get_positive (rest l)))))\n", "  (filter\
    \ positive? l))\n", "  (filter (lambda (n) (>= n 0)) (l)))\n", "  (filter (lambda\
    \ (x) (positive? x)) l))\n", "  (filter (lambda (x)\n            (> x 0))\n  \
    \        l))\n", "  (flatten (filter (\u03BB (x)\n                    (cond\n\
    \                      [(< x 0) x])\n                    l)))) ; #lang racket\n",
  "  (filter (lambda (x) (> x 0)) l))\n", "  (filter (lambda (x) (>= x 0)) l))\n",
  "  (cond [(null? l) l]\n        [(positive? (car l)) (cdr l)]\n        [else (get_positive\
    \ (cdr l))]))\n", "  (filter positive? (reverse l)))\n", "  (filter (lambda (x)\n\
    \           (< (abs (- x)) 0)) l))\n</code></pre>\n                    </section>\n\
    \                    <section id=\"language-racket\">\n                      \
    \  <h2>Language #lang racket</h2>\n                        <p><code>(: get_positive\
    \ (Listof Positive))</code></p>\n                        <pre><code data-noescape\
    \ data-trim>", "  (cond\n    [(empty? l) '()]\n    [(not (number? (first l)))\n\
    \     (append (get_positive (rest l)) (list first))]\n    [else (cons (first l)\
    \ (get_positive (rest l)))]))\n", "  (reverse (filter (lambda (x) (> (x 0) 0))\n\
    \                 l)))\n", "  (define (helper l result)\n    (cond\n      [(null?\
    \ l) result]\n      [(number? l) (if (positive? l) (append result (list l)) result)]\n\
    \      [else (helper (rest l) (cons l result))]))\n  (helper l '()))\n", "  (cond\
    \ ((empty? l) '())\n        ((> (first l) 0) (cons (first l) (get_positive (rest\
    \ l))))\n        (else (get-positive (rest l)))))\n", "  (cond [(empty? l) empty]\n\
    \        [(positive? (first l)) (cons (first l) (get_positive (rest l)))]\n  \
    \      [else (get_positive (rest l))]))\n", "  (cond\n    [(empty? l) empty]\n\
    \    [(list? (car l)) (append (get_positive (car l)) (get_positive (cdr l)))]\n\
    \    [else (cons (car l)\n                (get_positive (cdr l)))]))\n", "  (filter\n\
    \   (lambda (x) (< x 0))\n   l))\n", "  (filter (lambda (x) (> x 0)) l))\n", " \
    \ (filter (lambda (x)\n            (<= x 0))\n          l))\n", "  (filter (lambda\
    \ (e) (> e 0))\n          l))\n", "  (if (null? l)\n      '()\n      (cons (car\
    \ l)\n            (get_positive (cdr l))))) ; go through the list, calling recursively\n\
    \                          ; with cdr only when the cdr is a number\n        \
    \                  ; that isn't zero.\n\n", "  (filter (lambda (n) (> n 0)) l))\n\
    </code>\nThis has the advantage that it is tail-recursive and will work even with\
    \ infinite lists.\n<|/ a dscore=2 |>\n<| a |>\nI suggest that in terms of clarity,\
    \ you should write (apply map 'identity lst) rather than the version you gave\
    \ as a separate definition, which is the version that uses tail recursion.\n<|/\
    \ a dscore=1 tags=racket,functional-programming,scheme |>\n<| c |>\nOh right,\
    \ I hadn't noticed that, thank you. I've edited my code in the question, I think\
    \ it is much clearer now.\n<|/ c |>\n<| c |>\nI'm a big fan of using `map` when\
    \ the function it applies to is not an identity function.\n<|/ c |>\n<| c |>\n\
    : I agree with you! I always use map in that way, and I am a bit surprised that\
    \ `map` didn't show up until after I posted this question.\n<|/ c |>\n<| a |>\n\
    I know this is an old question, and my solution doesn't really match the original\
    \ question, but I thought I'd throw in my solution incase anyone is searching\
    \ for an answer here.\n<code>", "  (cond\n    [(empty? l) empty]\n    [(number?\
    \ (first l)) (cons (first l) (get_positive (rest l)))]\n    [else (get_positive\
    \ (rest l))]\n  ))\n", "  (filter (lambda (n) (> n 0)) l))\n", "  (cond\n    [(empty?\
    \ l) empty]\n    [(null? (rest l)) (cons (first l) (get_positive (rest l)))]\n\
    \    [(null? (first l)) (get_positive (rest l))]\n    [else (cons (first l) (get_positive\
    \ (rest l)))]))\n", "  (filter (lambda (x) (not (< x 0))) l))\n", "  (cond\n \
    \   [(empty? l) '()]\n    [(<= (car l) 0) (cons (car l) (get_positive (cdr l)))]\n\
    \    [else (get_positive (cdr l))]\n  ))\n", "  (cond\n    [(empty? l)\n     (empty?\
    \ l)]\n    [(= (rest l) 0) (cons 0 (reverse l))]\n    [else (get_positive (rest\
    \ l))]\n    ))\n", "  (filter (lambda (x) (positive? x))\n          l))\n", " \
    \ (filter (lambda (x) (>= x 0)) l))\n", "  (cond\n    ((null? l) l)\n    ((> 1\
    \ (car l)) (cons (car l) (get_positive (cdr l))))\n    (else (cons (car l) (get_positive\
    \ (cdr l))))))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
