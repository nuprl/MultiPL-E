name: HumanEval_6_parse_nested_parens
language: rkt
prompt: "#lang racket\n\n;; Input to this function is a string represented multiple\
  \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
  \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
  \ two levels of nesting while ((())) has three.\n;; >>> (parse_nested_parens \"\
  (()()) ((())) () ((())()())\")\n;; (list 2 3 1 3)\n(define (parse_nested_parens\
  \ paren_string)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n\
  \    (check-equal? (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n\
  \    (check-equal? (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n   \
  \ (check-equal? (candidate \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
completions: ["  (let ((count 0))\n    (cond\n      [(string? paren_string)\n    \
    \   (cond\n         [(starts-with? paren_string \")\")\n          (set! count\
    \ (- count 1))\n          (cond\n            [(> count 0)\n             (set!\
    \ count (- count 1))\n             (cond\n               [(equal? count 0)\n \
    \               (cons paren_string (list 0))]\n               [(equal? count 1)\n\
    \                (cons paren_string (list 1))]\n               [else\n       \
    \         (cons paren_string\n                      (list (- count 1) (list 1)))]))]\n\
    \         [else\n          (cond\n            [(starts-with? paren_string \")\"\
    )\n             (set! count (- count 1))\n             (cond\n               [(equal?\
    \ count 0)\n                (cons paren_string (list 0))]\n               [(equal?\
    \ count 1)\n                (cons paren_string (list 1))]\n               [else\n\
    \                (cons paren_string\n                      (list (- count 1) (list\
    \ 1)))]))]\n         [(equal? paren_string \")\")\n          (set! count (- count\
    \ 1))\n          (cond\n            [(> count 0)\n             (set! count (-\
    \ count 1))\n             (cond\n               [(equal? count 0)\n          \
    \      (cons paren_string (list 0))]\n               [(equal? count 1)\n     \
    \           (cons paren_string (list 1))]\n               [else\n            \
    \    (cons paren_string\n                      (list (- count 1) (list 1)))]))]\n\
    \         [(equal? paren_string \"()\")\n          (set! count (+ count 1))\n\
    \          (cond\n            [(> count 0)\n             (set! count (+ count\
    \ 1))\n             (cond\n               [(equal? count 0)\n                (cons\
    \ paren_string (list 0))]\n               [(equal? count 1)\n                (cons\
    \ paren_string (list 1))]\n               [else\n                (cons paren_string\n\
    \                      (list (+ count 1) (list 1)))]))]\n         [(equal? paren_string\
    \ \"((\")\n          (set! count (+ count 1))\n          (cond\n            [(>\
    \ count 0)\n             (set! count (+ count 1))\n             (cond\n      \
    \         [(equal? count 0)\n                (cons paren_string (list 0))]\n \
    \              [(equal? count 1)\n                (cons paren_string (list 1))]\n\
    \               [else\n                (cons paren_string\n                  \
    \    (list (+ count 1) (list 1)))]))]\n         [(equal? paren_string ", "  (let\
    \ ((result (empty-list))\n        (i (string-length paren_string)))\n    (if (=\
    \ i 0)\n        result\n        (let ((level (string->list paren_string)))\n \
    \         (if (null? level)\n              result\n              (if (< (first\
    \ level) 0)\n                  (cons i result)\n                  (let ((new_result\
    \ (list i)))\n                    (cond ((string=? (first level) \")\")\n    \
    \                      (cons (cdr level) new_result))\n                      \
    \    ((string=? (first level) \")\")\n                          (cons (car level)\
    \ (append new_result (list (+ (cdr level) 1))))\n                          ((string=?\
    \ (first level) \")\")\n                          (cons (car level) (append new_result\
    \ (list (+ (car level) 1))))\n                          ((string=? (first level)\
    \ \")\")\n                          (cons (car level) new_result))\n         \
    \                 ((string=? (first level) \")\")\n                          (cons\
    \ (car level) new_result))\n                          ((string=? (first level)\
    \ \"(\")\n                          (cons (car level) new_result))\n         \
    \                 ((string=? (first level) \")\")\n                          (cons\
    \ (car level) new_result))\n                          ((string=? (first level)\
    \ \")\")\n                          (cons (car level) new_result))\n         \
    \                 ((string=? (first level) \"(\")\n                          (cons\
    \ (car level) new_result))\n                          ((string=? (first level)\
    \ \")\")\n                          (cons (car level) new_result))\n         \
    \                 ((string=? (first level) \")\")\n                          (cons\
    \ (car level) new_result))\n                          ((string=? (first level)\
    \ \"(\")\n                          (cons (car level) new_result))\n         \
    \                 ((string=? (first level) \")\")\n                          (cons\
    \ (car level) new_result))\n                          ((string=? (first level)\
    \ \")\")\n                          (cons (car level) new_result))\n         \
    \                 ((string=? (first level) \"(\")\n                          (cons\
    \ (car level) new_result))\n                          ((string=? (first level)\
    \ \")\")\n                          (cons (car level) new_result))\n         \
    \                 ((string=? (first level) \")\")\n                          (cons\
    \ (car level) new_result))\n                          ((string=? (first level)\
    \ \"(\")\n                          (cons (car level) new_result))\n         \
    \                 ((string", "  (let loop ((strings string paren_string)\n   \
    \          (levels vector 0))\n    (cond\n      [(= (length strings) 0)\n    \
    \   (reverse levels)]\n      [(or (char-before? (car strings) (char #\\))\n  \
    \         (char-before? (car strings) (char #\\)))\n        (loop (cdr strings)\
    \ (cons (length (car strings)) levels))]\n      [(char-before? (car strings) (char\
    \ #\\))\n       (loop (cdr strings) (cons (+ level 1) levels))]\n      [else\n\
    \       (loop (cdr strings) (cons (+ level 1) levels))])))\n", "  (let loop ((i\
    \ 0))\n    (cond\n      [(string-empty? paren_string) #f]\n      [(equal? (char-after\
    \ (substring paren_string i 1) '(') '(') (add i 1))]\n      [else\n       (set!\
    \ i (add i 1))\n       (loop (add i))]))))\n", "  (cond [(equal? (length paren_string)\
    \ 0)\n         #f]\n        [(equal? (char-at-pos (+ 0 (string-length paren_string))\
    \ paren_string) '(')\n         (parse_inside_parens paren_string)]\n        [else\
    \ (parse_nested_parens (string-append \"(\" paren_string (string-append \")\"\
    )))]))", "  (cond ((and (not (equal? paren_string (substring paren_string 0 (string-length\
    \ paren_string))))\n              (not (equal? (substring paren_string (string-length\
    \ paren_string)) \")\")))\n        ((equal? (char (char-code paren_string 0))\
    \ \"(\")\n         (let ((level (+ 1 (parse-nested-parens-level paren_string)))\n\
    \               (result (cons level result)))\n           (append result (parse-nested-parens-level\
    \ paren_string))\n           ;; Don't add 1 to the level if it's the first parentheses.\n\
    \           (if (equal? paren_string \"(\")\n               result\n         \
    \      (cons level result)))\n           ;; The case (()) is not handled.\n  \
    \         (else\n             (list level result))\n         result)\n       \
    \ ((equal? paren_string (substring paren_string 0 (string-length paren_string))\
    \ \")\")\n         (let ((result (parse-nested-parens-level paren_string))\n \
    \              (level (- result 1)))\n           (append result (list level))\n\
    \           result))))\n", "  (let loop ((level (quote ()))\n             (string\
    \ paren_string))\n    (cond\n      [(string-length string) level]\n      [(equal?\
    \ (first string) '(') (loop (add1 level) (rest string))]\n      [(equal? (first\
    \ string) '(') (loop (add1 level) (cons (first string) (rest string)))]\n    \
    \  [else\n       (loop (add1 level) (append (first string) (rest string))\n  \
    \           (string-tail string))])))\n", "  (cond\n    [(empty? paren_string)\n\
    \     (list 0)]\n    [(empty? (rest paren_string))\n     (cons (car paren_string)\
    \ (parse_nested_parens (cdr paren_string)))]\n    [else (let ([innermost (parse_nested_parens\
    \ (rest paren_string))])\n             (cond\n              [(empty? innermost)\n\
    \               (cons (car paren_string) (parse_nested_parens (cdr paren_string)))]\n\
    \              [else (cons (+ 1 innermost) (cons (car paren_string) (parse_nested_parens\
    \ (cdr paren_string))))]))]))\n", "  (define stack '())\n  (define level '())\n\
    \  (define opens '())\n  (define closes '())\n  (define levels '())\n  (define\
    \ (process paren_string stack)\n    (cond\n      [(empty? paren_string)\n    \
    \   (list level levels opens closes levels)]\n      [else\n       (let ([paren\
    \ (car paren_string)])\n         (cond\n           [(string=? (car paren_string)\
    \ ')']\n           (add-to-stack '(closes closes closes closes levels))\n    \
    \       (process (cdr paren_string) stack)\n           (set! closes (cdr opens))\n\
    \           (set! levels (car closes)\n                   opens (cdr levels))\n\
    \           (set! level (+ 1 (car levels)))\n           (set! levels (append (cdr\
    \ levels) '()))\n           (add-to-stack '(opens opens opens opens levels))\n\
    \           (process (cdr paren_string) stack)\n           (set! opens (cdr levels))\n\
    \           (set! levels (car opens))\n           (set! level (+ 1 (car levels)))\n\
    \           (set! levels (append (cdr levels) '()))\n           (process (cdr\
    \ paren_string) stack)\n           (set! levels (car opens))\n           (set!\
    \ level (+ 1 (car levels)))\n           (set! levels (append (cdr levels) '()))\n\
    \           (process (cdr paren_string) stack)\n           (set! levels (car levels))\n\
    \           (set! level (+ 1 (car levels)))\n           (set! levels (append (cdr\
    \ levels) '()))\n           (process (cdr paren_string) stack)\n           (set!\
    \ levels (car levels))\n           (set! level (+ 1 (car levels)))\n         \
    \  (set! levels (append (cdr levels) '()))\n           (process (cdr paren_string)\
    \ stack)\n           (set! levels (car levels))\n           (set! level (+ 1 (car\
    \ levels)))\n           (set! levels (append (cdr levels) '()))\n           (process\
    \ (cdr paren_string) stack)\n           (set! levels (car levels))\n         \
    \  (set! level (+ 1 (car levels)))\n           (set! levels (append (cdr levels)\
    \ '()))\n           (process (cdr paren_string) stack)\n           (set! levels\
    \ (car levels))\n           (set! level (+ 1 (", "  (let loop ((parens (string-split\
    \ (string paren_string) #\\Space)))\n    (cond [(empty? parens)\n           (list-ref\
    \ '() '())]\n          [(not (endswith parens (cdr parens))) (incf (parse (string\
    \ (car parens)) parens))]\n          [else (loop (cdr parens))])))\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nHe asked for a recursive solution. Not an iterative\
    \ one. He also asked for the number of parentheses and I assume that he actually\
    \ wants to count them. Nevertheless I still don't see why this should work. Could\
    \ you please explain it to me?\n<|/ c |>\n<| c |>\n: I did not know that you need\
    \ a recursive solution. Since you already posted one using \"list-ref\", I thought\
    \ you wanted an iterative one. Now I see that you have already posted one that\
    \ does the job. I am sorry that I did not make it clear that I needed a recursive\
    \ solution. Thanks for pointing this out. I will remove my answer because I cannot\
    \ delete it anymore.\n<|/ c |>\n<| a dscore=0 tags=list,scheme,nested,count |>\n\
    <code>", "  (let loop ((parens ())\n             (depth 0))\n    (cond\n     \
    \ [(empty? paren_string) empty]\n      [(equal? (car paren_string) '(') (incf\
    \ depth)\n       (loop (cdr paren_string) (add1 depth))]\n      [else (loop (cdr\
    \ paren_string) depth)]))))\n", "  (let ((par_ind 0)) ; The index where paranthesis\
    \ appears\n    (cond ((and (char? paren_string) (string=? paren_string \"\\()\"\
    ) (string=? paren_string \"\\)\")) (list par_ind))\n          ((char? paren_string)\
    \ (list par_ind))\n          (else (parse_nested_parens (string paren_string par_ind)))))\n\
    </code>\nThe output looks like this and you can easily traverse it with other\
    \ functions:\n<code>", "  (define parsed_string #f)\n  (define level #f)\n  (define\
    \ paren_group (string->list paren_string))\n  (define last_paren_group nil)\n\
    \  (define is_balanced #f)\n  (define unbalanced_count 0)\n\n  (define (parse_group\
    \ group index depth)\n    (let ((group_content (list->string group)))\n      (if\
    \ (equal? group_content '())\n          '()\n          (if (null? (car group))\n\
    \              (set! is_balanced #t)\n              (set! unbalanced_count (+\
    \ unbalanced_count 1))\n              (set! is_balanced #f))\n          (set!\
    \ is_balanced (and (equal? (car group) ')') (equal? (cdr group) '())))\n     \
    \ (set! parsed_string (append (append parsed_string group_content) (list (list\
    \ index depth)))))\n      (if (null? (car group))\n          (set! level depth)\n\
    \          (set! level (+ 1 (max (if (> unbalanced_count 0) (unbalanced_count)\
    \ 0))))\n      (set! paren_group (cdr group))\n      (set! last_paren_group (car\
    \ group))\n      (set! is_balanced (and is_balanced (equal? (car group) ')')))\n\
    \    (cond\n      [(equal? paren_group #f)\n       (if (equal? level 0)\n    \
    \       parsed_string\n           (begin\n             (set! parsed_string '())\n\
    \             (set! level (+ 1 (max (if (> unbalanced_count 0) (unbalanced_count)\
    \ 0))))\n             (set! paren_group (cdr group))\n             (set! last_paren_group\
    \ (car group))\n             (set! is_balanced (and is_balanced (equal? (car group)\
    \ '())))\n             (parse_group group 0 (- level 1)))]\n      [(equal? last_paren_group\
    \ #f)\n       (if (equal? level 0)\n           parsed_string\n           (begin\n\
    \             (set! parsed_string '())\n             (set! level (+ 1 (max (if\
    \ (> unbalanced_count 0) (unbalanced_count) 0))))\n             (set! paren_group\
    \ (cdr group))\n             (set! last_paren_group (car group))\n           \
    \  (set! is_balanced (and is_balanced (equal? (car group) '())))\n           \
    \  (parse_group group 0 (- level 1)))]\n      [(equal? last_paren_group '(())'\n\
    \        (begin\n          (set! is_balance", "  (if (string? paren_string)\n\
    \      (if (equal? paren_string \"\")\n          (list 0)\n          (let ((group\
    \ (string-split-by-string (trim paren_string) \" \"))\n                (level\
    \ (+ 1 )))\n            (if (null? group)\n                (list level) ; end\
    \ the current group\n                (let ((group-length (string-length (car group))))\n\
    \                  (if (equal? (car group) \")\")\n                      (if (>\
    \ (car group) (substring paren_string 0 (- (string-length (car group)) (+ group\
    \ group-length) ) ))\n                          (list level)\n               \
    \         (if (> (car group) (substring paren_string 0 (+ (string-length (car\
    \ group)) (+ group group-length) ) ))\n                          (list level)\n\
    \                          (if (> (car group) (substring paren_string 0 (+ (string-length\
    \ (car group)) (+ group group-length) ) ))\n                              (list\
    \ level)\n                              (if (> (car group) (substring paren_string\
    \ 0 (+ (string-length (car group)) (+ group group-length) ) ))\n             \
    \                     (list level)\n                                  (if (> (car\
    \ group) (substring paren_string 0 (+ (string-length (car group)) (+ group group-length)\
    \ ) ))\n                                      (list level)\n                 \
    \                     (if (> (car group) (substring paren_string 0 (+ (string-length\
    \ (car group)) (+ group group-length) ) ))\n                                 \
    \         (list level)\n                                          (if (> (car\
    \ group) (substring paren_string 0 (+ (string-length (car group)) (+ group group-length)\
    \ ) ))\n                                              (list level)\n         \
    \                                     (if (> (car group) (substring paren_string\
    \ 0 (+ (string-length (car group)) (+ group group-length) ) ))\n             \
    \                                     (list level)\n                         \
    \                         (if (> (car group) (substring paren_string 0 (+ (string-length\
    \ (car group)) (+ group group-length) ) ))\n                                 \
    \                     (list level)\n                                         \
    \             (if (> (car group) (substring paren_string 0 (+ (string-length (car\
    \ group)) (+ group group-length) ) ))\n                                      \
    \                    (list level)\n                                          \
    \                (if (> (car group) (substring paren_string 0 (+ (string-length\
    \ (car group)) (+ group group-length) ) ))\n                                 \
    \                             (list level)\n                                 \
    \                             (if (> (car group) (substring paren_string 0 (+\
    \ (string-", "  (let loop ((paren_string paren_string)\n             (result '())\n\
    \             (paren '()))\n    (cond [(char=? paren_string (char #\\)) result]\n\
    \          [(empty? paren_string) (append result paren)]\n          [(char=? (peek-char\
    \ paren_string) #\\)] result)\n          [(char=? (peek-char paren_string) #\\\
    ()\n           (loop (rest paren_string) result\n                  (append paren\
    \ (parse_deepest_level paren_string)))]\n          [else (loop (rest paren_string)\
    \ result paren)])))\n", "  (cond (;; empty string\n         empty-string\n   \
    \      ;; one string with one pair of parentheses\n         (if (= (string-length\
    \ paren_string) 0)\n             ;; return list of depth\n             (list 1)\n\
    \             ;; split string by parentheses\n             (parse (split_str paren_string)))))\n\
    \  (define (parse paren-list)\n    (let loop ((nest (car paren-list))\n      \
    \          (depth 1))\n      (cond ((null? paren-list)\n             (list depth))\n\
    \            ((= (length paren-list) 1)\n             (parse (cdr paren-list)))\n\
    \            ((null? (cdr paren-list))\n             (if (>= depth nest)\n   \
    \              (append (list depth)\n                          (loop (+ depth\
    \ 1) nest))\n                 (loop (+ depth 1) nest)))\n            (else\n \
    \            (loop (+ depth 1) (max depth nest))))))\n  (parse (split_str paren_string)))\n",
  "  (let loop ((i 0) (indent_level 0) (paren_string paren_string))\n    (cond\n \
    \     [(empty? paren_string)\n       (reverse (cons indent_level (loop (+ i 1)\
    \ (indent_level 1) (first paren_string))))]\n      [(eq? (char paren_string 0)\
    \ '(\n        (loop (+ i 1) (indent_level (+ indent_level 1)) (rest paren_string)))]\n\
    \      [(eq? (char paren_string 0) ')\n        (loop (+ i 1) (indent_level indent_level)\
    \ (first paren_string)))]\n      [(char? (char paren_string i))\n       (loop\
    \ (+ i 1) (indent_level (+ indent_level 1)) (rest paren_string))]\n      [(char?\
    \ (char paren_string i) (+ 1 (- (position i paren_string) (length paren_string)))\n\
    \       (loop (+ i 1) (indent_level indent_level) (rest paren_string))]))))\n",
  "  (let ((max-nesting-level (cdr paren_string)))\n    (if (null? max-nesting-level)\n\
    \        0\n        (add1\n         (- (length paren_string)\n            (parse_nested_parens\
    \ (cdr paren_string)))))\n    ))\n", "  (let loop ((parens () count)\n       \
    \      (string paren_string))\n    (if (or (string-blank? string)\n          \
    \  (string-equal? string \"\"))\n        (reverse parens)\n        (let ((char\
    \ (car string)))\n          (cond\n            [(or (char-whitespace? char)\n\
    \                  (char-equal? char #\\))\n             (loop (cons (car parens)\
    \ (car parens))\n                   (cdr string))]\n            [(char-equal?\
    \ char #\\(\\))\n             (loop (append (cons (car parens) (car parens))\n\
    \                          (car parens))\n                   (cdr string))\n \
    \            (char-equal? char #\\(\\))\n             (loop (append (cons (car\
    \ parens) (car parens))\n                          (cdr string))\n           \
    \        (cdr string))]\n            [(char-equal? char #\\(\\()\n           \
    \  (loop (append (cons (car parens) (car parens))\n                          (cdr\
    \ parens))\n                   (cdr string))\n             (char-equal? char #\\\
    ))\n             (loop (append (cons (car parens) (car parens))\n            \
    \              (cdr parens))\n                   (cdr string))]\n            [(char-equal?\
    \ char #\\)\n             (loop (append (cons (car parens) (car parens))\n   \
    \                       (cdr parens))\n                   (cdr string))]\n   \
    \         [(char-equal? char #\\(\\()\n             (loop (append (cons (car parens)\
    \ (car parens))\n                          (cdr parens))\n                   (cdr\
    \ string))\n             (char-equal? char #\\))\n             (loop (append (cons\
    \ (car parens) (car parens))\n                          (cdr parens))\n      \
    \             (cdr string))]\n            [(char-equal? char #\\(\\))\n      \
    \       (loop (append (cons (car parens) (car parens))\n                     \
    \     (cdr parens))\n                   (cdr string))]\n            [(char-equal?\
    \ char #\\))\n             (loop (append (cons (car parens) (car parens))\n  \
    \                        (cdr parens))\n                   (cdr string))]\n  \
    \          [(char-equal? char #\\))\n             (loop (append (cons (car parens)\
    \ (car parens))\n                          (cdr parens))\n                   (cdr\
    \ string))]\n            [else\n             (loop (cons (car parens) (car parens))\n\
    \                  ", "  (define (parse paren_string)\n    (cond\n      [(or (string-match\
    \ \"\\\\(\" paren_string) (string-match \"\\)\" paren_string))\n       (error\
    \ 'parens-not-expected \"invalid parentheses: ~S\" paren_string)\n       ]\n \
    \     [(string-match \"\\\\(\" paren_string)\n       (let* ((group-size 0)\n \
    \              (result '())\n               (paren-pos (string-index paren_string\
    \ 1))\n               (stack '())\n               (stack-pos 0))\n         (cond\n\
    \           [(or (string-match \"\\\\)\" paren_string)\n            (error 'too-many-levels\
    \ \"too many nested parentheses: ~S\" paren_string)\n            ]\n         \
    \  [(or (string-match \"\\\\(\" paren_string)\n                (string-match \"\
    \\\\)\" paren_string))\n            (error 'too-many-levels \"too many nested\
    \ parentheses: ~S\" paren_string)\n            ]\n           [(or (string-match\
    \ \")\" paren_string)\n            (error 'too-many-levels \"too many nested parentheses:\
    \ ~S\" paren_string)\n            ]\n           [else (error 'too-many-levels\
    \ \"too many nested parentheses: ~S\" paren_string)\n            ]\n         \
    \  ]\n         [(or (string-match \")\" paren_string)\n          (error 'too-many-levels\
    \ \"too many nested parentheses: ~S\" paren_string)\n          ]\n         [(or\
    \ (string-match \"\\\\(\" paren_string)\n               (string-match \"\\\\)\"\
    \ paren_string))\n          (error 'too-many-levels \"too many nested parentheses:\
    \ ~S\" paren_string)\n          ]\n         [else (error 'too-many-levels \"too\
    \ many nested parentheses: ~S\" paren_string)\n          ]\n         ])\n    \
    \    ]\n      [(string-match \"\\\\)\" paren_string)\n       (let* ((group-size\
    \ 0)\n               (result '())\n               (paren-pos (string-index paren_string\
    \ 1))\n               (stack '())\n               (stack-pos 0))\n         (cond\n\
    \           [(or (string-match \"\\\\(\" paren_string)\n                (string-match\
    \ \"\\\\)\" paren_string))\n            (error 'too-many-levels \"too many nested\
    \ parentheses: ~S\" paren_string)\n            ]\n           [else (error 'too-many-levels\
    \ \"too many nested parentheses: ~S\" paren_string)\n            ]\n         \
    \  ]\n         [(or (string-match \"\\\\(\" paren_string)\n               (string-match\
    \ \"\\\\)\" paren_string))\n          (error 'too-many-levels \"too many nested ",
  "  (define (parse input_string)\n    (cond [(not (empty? input_string)) (parse (rest_of_string\
    \ input_string))\n           (< (length input_string) 1)\n           (char? (car\
    \ input_string))\n           (equal? (car input_string) '()) (parse (rest_of_string\
    \ input_string))\n           (char? (car input_string))\n           (equal? (car\
    \ input_string) '()) (parse (rest_of_string input_string))\n           (equal?\
    \ (car input_string) ')) (list (length input_string) (length input_string))\n\
    \           (char? (car input_string))\n           (equal? (car input_string)\
    \ '(') (parse (rest_of_string input_string))\n           (char? (car input_string))\n\
    \           (equal? (car input_string) '(') (parse (rest_of_string input_string))\n\
    \           (equal? (car input_string) '(') (parse (rest_of_string input_string))\n\
    \           (equal? (car input_string) '(') (parse (rest_of_string input_string))\n\
    \           (equal? (car input_string) '(') (parse (rest_of_string input_string))\n\
    \           (equal? (car input_string) '(') (parse (rest_of_string input_string))\n\
    \           (equal? (car input_string) '(') (parse (rest_of_string input_string))\n\
    \           (equal? (car input_string) '(') (parse (rest_of_string input_string))\n\
    \           (equal? (car input_string) ')') (parse (rest_of_string input_string))\n\
    \           (char? (car input_string))\n           (equal? (car input_string)\
    \ '(') (parse (rest_of_string input_string))\n           (char? (car input_string))\n\
    \           (equal? (car input_string) '(') (parse (rest_of_string input_string))\n\
    \           (equal? (car input_string) '(') (parse (rest_of_string input_string))\n\
    \           (equal? (car input_string) '(') (parse (rest_of_string input_string))\n\
    \           (equal? (car input_string) '(') (parse (rest_of_string input_string))\n\
    \           (equal? (car input_string) '(') (parse (rest_of_string input_string))\n\
    \           (equal? (car input_string) '(') (parse (rest_of_string input_string))\n\
    \           (equal? (car input_string) '(') (parse (rest_of_string input_string))\n\
    \           (equal? (car input_string) '(') (parse (rest_of_string input_string))\n\
    \           (equal", "  (let ((res ()))\n    (for ([i (string-length paren_string)])\n\
    \      (let ([ch (char-ref paren_string i)])\n        (if (and (not (number? ch))\n\
    \                 (not (letter? ch)))\n            (cons i res)\n            (cons\
    \ (char->integer (char-ref ch 0)) res)))))\n    (apply list res)))\n</code>\n\
    <|/ a |>\n<| a tags=algorithm,math,nested-loops dscore=1 |>\nThis is actually\
    \ quite similar to KMP algorithm.\nLet's say we have string \"(()())\" we want\
    \ to find the max number of parentheses.\n<code>\npublic int maxParenthesis(String\
    \ str) {\n    boolean found = false;\n    boolean[] arr = new boolean[str.length()];\n\
    \    int ans = 0;\n    for (int i=0; i<str.length(); i++) {\n        if (arr[i])\
    \ {\n            boolean end = false;\n            int j = i+1;\n            while\
    \ (!found && j<str.length()) {\n                if (str.charAt(j)=='(') {\n  \
    \                  end = true;\n                } else if (str.charAt(j)==')')\
    \ {\n                    found = true;\n                } else {\n           \
    \         j++;\n                }\n                arr[j] = end;\n           \
    \ }\n            if (end) {\n                ans = Math.max(ans, j);\n       \
    \     }\n        }\n    }\n    return ans;\n}\n</code>\n<|/ a |>\n<| a dscore=1\
    \ |>\nRecursive solution:\n<code>\npublic static int maxParenthesis(String str)\
    \ {\n    int n = str.length();\n    int ans = 0;\n    if (n == 0) {\n        return\
    \ ans;\n    }\n    if (str.charAt(0) == '(') {\n        ans = 1 + maxParenthesis(str.substring(1));\n\
    \    }\n    return Math.max(ans, maxParenthesis(str.substring(1)) + 1);\n}\n</code>\n\
    <|/ a tags=algorithm,math,nested-loops |>\n<| a dscore=1 tags=algorithm,math,nested-loops\
    \ |>\nI hope this answer will help someone looking for the same algorithm. The\
    \ solution I found is to iterate over all possible nested parenthesis (including\
    \ the empty ones) and count the open/close parentheses count while ignoring parenthesis\
    \ open/close count.\n<code>\npublic int maxNestingLevel(String str) {\n    return\
    \ maxNestingLevel(str, 0);\n}\n\npublic int maxNestingLevel(String str, int level)\
    \ {\n    if(str.isEmpty()) return level;\n\n    for(int i = 1; i < str.length();\
    \ i++) {\n        if(str.charAt(i) == '(') {\n            if(str.charAt(i - 1)\
    \ != '(') {\n                level++;\n            }\n            else {\n   \
    \             level--;\n", "  (let ((paren_lists '()))\n    (cond [(null? paren_string)\n\
    \           paren_lists]\n          [(equal? (car paren_string) '())\n       \
    \    (cons 0 paren_lists)]\n          [else\n           (loop for i from 0 to\
    \ (length (car paren_string))\n                 collect (parse_nested_parens (cdr\
    \ paren_string))]))))\n", "  (cond\n    [(empty? paren_string) empty]\n    [else\n\
    \     (let ([groups (string->list paren_string)]\n           max_level (maximum\
    \ \n                      (length groups)\n                      (reduce (lambda\
    \ (level x)\n                                 (if (equal? (first x) '(')\n   \
    \                                  (+ level 1)\n                             \
    \        (+ level 0)))\n                             0 groups))])\n       (if\
    \ (equal? max_level 0)\n           (error \"parens string not well-formed\"))\n\
    \       (map (lambda (group)\n               (parse_nested_parens group))\n  \
    \           groups))]))\n", "  (let loop ((parens nil))\n    (cond [(string=?\
    \ paren_string \"()\")\n           (set! parens 0)]\n          [(string=? paren_string\
    \ \"()()\")\n           (set! parens (+ parens 1))]\n          [(string=? paren_string\
    \ \"((()))\")\n           (set! parens (+ parens 2))]\n          [(string=? paren_string\
    \ \"((()()))\")\n           (set! parens (+ parens 3))]\n          [else (set!\
    \ parens (+ parens 0))]))\n  (if (null? parens)\n      0\n      (+ 1 (loop (cdr\
    \ parens)))))\n", "  (cond [(empty? paren_string) empty]\n        [(pair? paren_string)\
    \ (parse parse_nested_parens (car paren_string))\n         (parse parse_nested_parens\
    \ (cdr paren_string))]\n        [else (error (string \"Invalid input: \" (string\
    \ paren_string)))]))\n", "  (let loop ((result '()) (parens 0) (group 0))\n  \
    \  (cond ((null? paren_string)\n           (if (< group 2)\n               (reverse\
    \ result)\n               (reverse '())))\n          ((eq? (char (string->list\
    \ (string->char paren_string))) '())\n           (loop (cons group result) (+\
    \ 1 parens) group))\n          (else\n           (loop (cons group result) parens\
    \ (+ 1 group)))))\n", "  (letrec ((iter (lambda (string level result)\n      \
    \           (cond [(or (equal? (string-ref string 0) ')')\n                  \
    \      result]\n                       [(equal? (string-ref string 0) '(')\n \
    \                        (iter (string-copy (string-tail string) level #f)\n \
    \                             (+ level 1))\n                         (iter (string-copy\
    \ (string-tail string) level #t)\n                              (+ level 0))]\n\
    \                       [else\n                        (iter (string-copy (string-tail\
    \ string) level #f)\n                              level result)]))))\n    (iter\
    \ paren_string 0\n           (list (length paren_string))))) ; The deepest nesting\
    \ is always the length of longest string\n</code>\n<|/ a dscore=2 tags=string,scheme,racket,parsing\
    \ |>\n<| c |>\nThis would be more idiomatic in Scheme if I replaced the `letrec`\
    \ with a `let`. :)\n<|/ c |>\n<| a dscore=2 tags=string,scheme,racket,parsing\
    \ |>\nThe answer by Michael Jackson is quite good, but I find it a bit unreadable\
    \ and unintuitive. Here's another version using Racket built-in procedures and\
    \ a helper function:\n<code>\n#lang racket\n", "  (let ((paren_char (first paren_string)))\n\
    \    (cond\n      [(= paren_char '())\n       (list (length (remove-if #(< %2\
    \ 26) #(char->integer (char->string %2))) paren_string))]\n      [(or (>= (length\
    \ (remove-if #(< %2 26) #(char->integer (char->string %2))) paren_string) 0)\n\
    \       (char->integer (char->string (last paren_string)))]\n      [else\n   \
    \    (parse (remove_if #(< %2 26) #(char->integer (char->string %2))) paren_string)]))))\n",
  "  (cond [(empty? paren_string)\n         (error \"Empty paren string.\")\n    \
    \     ]\n        [(equal? (char paren_string 0) '())\n         (parse_inner (cdr\
    \ paren_string))\n         ]\n        [else\n         (parse_nested_parens (cdr\
    \ paren_string))\n         ]))\n", "  (let loop ((count 1) (group_size 0) (group_list\
    \ '()) (level_count 0))\n    (cond\n      [(empty? paren_string) (list level_count)]\n\
    \      [(equal? (first paren_string) '(') (loop (+ count 1) 1 (cons group_size\
    \ group_list) 1)]\n      [(equal? (first paren_string) '(') (loop (+ count 1)\
    \ 0 (cons group_size group_list) (+ level_count 1))]\n      [(equal? (first paren_string)\
    \ '(') (loop (+ count 1) group_size (cons group_size group_list) (+ level_count\
    \ 1))]\n      [(equal? (first paren_string) ')') (loop (+ count 1) group_size\
    \ group_list level_count (+ level_count 1))]\n      [(equal? (first paren_string)\
    \ ')') (loop (+ count 1) group_size group_list level_count (+ level_count 1))]\n\
    \      [(equal? (first paren_string) ')') (loop (+ count 1) group_size group_list\
    \ level_count (+ level_count 1))]\n      [(equal? (first paren_string) '(') (loop\
    \ (+ count 1) group_size group_list level_count (+ level_count 1))]\n      [(equal?\
    \ (first paren_string) '(') (loop (+ count 1) group_size group_list level_count\
    \ (+ level_count 1))]\n      [(equal? (first paren_string) '(') (loop (+ count\
    \ 1) group_size group_list level_count (+ level_count 1))]\n      [(equal? (first\
    \ paren_string) '(') (loop (+ count 1) group_size group_list level_count (+ level_count\
    \ 1))]\n      [(equal? (first paren_string) '(') (loop (+ count 1) group_size\
    \ group_list level_count (+ level_count 1))]\n      [(equal? (first paren_string)\
    \ ')') (loop (+ count 1) group_size group_list level_count (+ level_count 1))]\n\
    \      [(equal? (first paren_string) ')') (loop (+ count 1) group_size group_list\
    \ level_count (+ level_count 1))]\n      [(equal? (first paren_string) ')') (loop\
    \ (+ count 1) group_size group_list level_count (+ level_count 1))]\n      [(equal?\
    \ (first paren_string) ')') (loop (+ count 1) group_size group_list level_count\
    \ (+ level_count 1))]\n      [(equal? (first paren_string) '(') (loop (+ count\
    \ 1) group_size group_list level_count (+ level_count 1))]\n      [(equal? (first\
    \ paren_string) '(') (loop", "  (let ((levels ()))\n    (if (string-empty? paren_string)\n\
    \        levels\n        (parse_nested_parens (parse (parse_parens paren_string))\
    \ (append levels (list level)))))) \n", "  (define (count-parens substring current-count)\n\
    \    (cond\n      [(= (length substring) 0)\n       (add1 current-count)]\n  \
    \    [else\n       (count-parens (cdr substring) (add1 (current-count)))]))\n\
    \  (define (check-count substring current-count)\n    (cond\n      [(>= (length\
    \ substring) 0)\n       (add1 current-count)]\n      [else\n       (check-count\
    \ (cdr substring) (add1 (current-count))))\n       ]))\n", "  (let loop ((string-list\
    \ paren_string)\n             (paren_level (quote 0))\n             (paren_levels\
    \ (quote 0)))\n    (cond\n      [(string-empty? string-list) paren_levels]\n \
    \     [(char= (char-code (char-first string-list)) '(] #t\n      [(char= (char-code\
    \ (char-first string-list)) '(] #t\n      [else (loop (rest string-list) \n  \
    \                (+ paren_level 1)\n                  (+ paren_levels 1)))]\n\
    \      [(char= (char-code (char-first string-list)) ')] #t\n      [(char= (char-code\
    \ (char-first string-list)) ')] #t\n      [else (loop (rest string-list) \n  \
    \                (- paren_level 1)\n                  (+ paren_levels (- paren_level\
    \ 1))))]\n      [else (loop (rest string-list) \n                  (- paren_level\
    \ 1)\n                  (+ paren_levels 1))]))))\n", "  (let\n      ([parens (regex\
    \ \"\\\\(\\\\([^\\\\)\\\\)\\\\)\")\n         (count 0)])\n    (define (loop-helper\
    \ input)\n      (match-str input parens)\n      (set! count (add1 count))\n  \
    \    (cond\n        ([(empty? input) (list count)]\n         (let ([inner-result\
    \ (loop-helper input)])\n           (cond\n             ([(> (length inner-result)\
    \ count) inner-result]\n               (loop-helper (rest input))\n          \
    \     ([(= (length inner-result) count) (list count)]\n                (loop-helper\
    \ (rest input))))))))\n    (loop-helper paren_string)))\n", "  (define (count\
    \ left right)\n    (if (null? left) 0 \n      (if (null? right) 0\n        (if\
    \ (char? left)\n          (if (char? right)\n            (+ 1 (count (substring\
    \ left 1) (substring right 1)))\n            (+ 1 (count (substring left 1) right))\n\
    \            0)\n          (if (char? right)\n            (+ 1 (count left (substring\
    \ right 1)))\n            (count left right)\n            0))))\n  (let ((count\
    \ 0))\n    (if (null? paren_string) count\n      (let ((left (car paren_string))\n\
    \            (right (cadr paren_string))\n            (max_count (count left right))\n\
    \            (max_count (+ count 1))\n            (current_count 0))\n       \
    \ (if (null? left) count\n          (if (char? right)\n            (if (> (current_count\
    \ max_count) max_count)\n              (begin (set! count max_count)\n       \
    \              (set! current_count 0)\n                     (return count))\n\
    \              (begin (set! count max_count)\n                     (set! current_count\
    \ 0)\n                     (return count))\n            (begin (set! count max_count)\n\
    \                  (set! current_count 0)\n                  (return count))\n\
    \            (begin (set! count max_count)\n                  (set! current_count\
    \ 0)\n                  (return count)))\n          (if (char? right)\n      \
    \      (begin (set! count max_count)\n                  (set! current_count 0)\n\
    \                  (return count))))))\n    (set! count 0))\n  (set! count 0))\n",
  "  (let loop ((parens (string->list paren_string)))\n    (if (null? parens)\n  \
    \      (list))\n    (let ((head (car parens)))\n      (if (or (string=? head \"\
    )\")\n              (string=? head \"(\"))\n          (loop parens)\n        \
    \  (let ((nest (+ 1 (loop (cdr parens))))\n                (rest '()))\n     \
    \       (if (> nest 0)\n                (list head nest)\n                (loop\
    \ (cons (string=? head \")\") rest))))))))\n", "  (let loop ((paren_string paren_string))\n\
    \    (if (string-empty? paren_string)\n        empty\n        (if (equal? (first\
    \ paren_string) '(\n                      (if (equal? (rest paren_string) '()\n\
    \                              empty)\n                          (if (equal? (first\
    \ paren_string) ')\n                              (let ((result 0))\n        \
    \                        (if (string-empty? (rest paren_string))\n           \
    \                         (list result)\n                                    (loop\
    \ (rest paren_string)))\n                                (loop (rest paren_string))))\n\
    \                          (if (equal? (first paren_string) '(\n             \
    \                         (if (equal? (rest paren_string) '()\n              \
    \                                (let ((result 0))\n                         \
    \                       (if (string-empty? (rest paren_string))\n            \
    \                                        (list result)\n                     \
    \                               (loop (rest paren_string)))\n                \
    \                                (loop (rest paren_string))))\n              \
    \                        (if (equal? (rest paren_string) '()\n               \
    \                               (let ((result 0))\n                          \
    \                      (if (string-empty? (rest paren_string))\n             \
    \                                       (list result)\n                      \
    \                              (loop (rest paren_string)))\n                 \
    \                               (loop (rest paren_string))))\n               \
    \                       (if (equal? (rest paren_string) '()\n                \
    \                              (let ((result 0))\n                           \
    \                     (if (string-empty? (rest paren_string))\n              \
    \                                      (list result)\n                       \
    \                             (loop (rest paren_string)))\n                  \
    \                              (loop (rest paren_string))))\n                \
    \                      (if (equal? (rest paren_string) '()\n                 \
    \                             (let ((result 0))\n                            \
    \                    (if (string-empty? (rest paren_string))\n               \
    \                                     (list result)\n                        \
    \                            (loop (rest paren_string)))\n                   \
    \                             (loop (rest paren_string))))))))))))))))))\n</code>\n\
    <|/ a |>\n<| a dscore=0 |>\nHere is another solution\n<code>", "  (if (string?\
    \ paren_string)\n      (let ((stack (make-list 0 0))\n            (group_count\
    \ 0))\n        (cond ((null? paren_string)\n               (list (length stack)))\n\
    \              ((char= paren_string '( ())\n               (set! stack (append\
    \ stack paren_string))\n               (set! group_count (+ 1 (length stack)))\n\
    \               (parse_nested_parens (cdr paren_string)))\n              (else\n\
    \               (set! stack (append stack (cons paren_string)))\n            \
    \   (set! group_count (+ 1 (length stack)))\n               (parse_nested_parens\
    \ (cdr paren_string))))))\n</code>\n<|/ a tags=racket,scheme |>\n<| a dscore=0\
    \ |>\nThis problem can be solved using racket's pattern matching language which\
    \ is very similar to regular expressions but with less power.\nA very simple solution\
    \ that uses nested pattern matching is:\n<code>", "  (let loop ((depth (min (length\
    \ paren_string) 2))\n             (open (substring paren_string 0 depth))\n  \
    \           (close (substring paren_string depth)))\n    (cond ((eq? close '())\
    \ '())\n          ((or (eq? close '()) (eq? open '(())))\n           (loop (add1\
    \ depth) open close))\n          ((eq? close '(())) (incf depth))\n          (else\
    \ (loop (add1 depth) open close))))))\n", "  (let ((res (make-list '())))\n  \
    \  (loop for c in (split paren_string)\n          while c\n          collect (begin\n\
    \                    (cond [(member (c) '(() ))\n                          (push\
    \ (cons c res) res)\n                          (else\n                       \
    \    (push (list c) (pop res))\n                           res))])\n    (sort\
    \ res))\n  )\n", "  (cond\n    [(empty? paren_string) (list 0)]\n    [(member\
    \ (car paren_string) '()) 0]\n    [(member (car paren_string) '(())) 1]\n    [else\
    \ (let ([level (parse_nested_parens (cdr paren_string))])\n            (+ level\
    \ (parse_nested_parens (cddr paren_string))))]))\n</code>\n<|/ a dscore=0 |>\n\
    <| c |>\nThis doesn't work. `(parse_nested_parens \"((()((())))(()())\")` returns\
    \ `6` when it should be `5`. The `cddr` should be `cdddr`. Also, `(parse_nested_parens\
    \ \"(()()\")` returns `0` when it should be `1`.\n<|/ c |>\n<| c |>\nIt works\
    \ fine for me. My apologies, I misunderstood the problem. Try now\n<|/ c |>\n\
    <| c |>\nOkay, it works, but it doesn't do what the OP asked for. You said the\
    \ function should return the deepest level of nesting of parens, but it returns\
    \ only the amount of nestings of parens within the input. The input `((()()))`\
    \ is supposed to return `2`, but it returns `1`.\n<|/ c |>\n<| c |>\nOh my bad,\
    \ I misunderstood it as well, now it's fixed\n<|/ c |>\n<| c |>\nSorry, but still\
    \ doesn't do what the OP asked for. I was confused by the first version of your\
    \ answer.\n<|/ c |>\n<| a dscore=0 |>\nI assume that your question is more about\
    \ how to do recursion than about how to do pattern matching. So, here is my version:\n\
    <code>", "  (cond [(= paren_string-length (string-length paren_string)) '()]\n\
    \        [else\n         (let ([group (string->list paren_string)])\n        \
    \   (cond [(empty? group) '()]\n                 [else\n                  (let\
    \ ([inner (parse_inner(group))])\n                    (cond [(empty? inner) '()]\n\
    \                          [else (append (parse_nested_parens inner) (list group))]))]))]))\n",
  "  (define current_group 0)\n  (define nested_level 0)\n\n  (define (add_group group_string)\n\
    \    (if (null? group_string)\n        nested_level\n        (let ((group (parse-string\
    \ group_string)))\n          (cond ((null? group) 0)\n                (else (set!\
    \ nested_level (if (< (parse-string group_string) nested_level) (parse-string\
    \ group_string) nested_level))\n                      (set! current_group (+ 1\
    \ current_group))\n                      (set! group (list current_group group)))))\n\
    \      )\n  )\n\n  (define (add_group_string group_string)\n    (if (null? group_string)\n\
    \        nested_level\n        (let ((group (parse-string group_string)))\n  \
    \        (cond ((null? group) 0)\n                (else (set! nested_level (if\
    \ (< (parse-string group_string) nested_level) (parse-string group_string) nested_level))\n\
    \                      (set! current_group (+ 1 current_group))\n            \
    \          (set! group (list current_group group)))))\n      )\n  )\n\n  (define\
    \ (close_paren closed_group)\n    (if (> nested_level 0)\n        (set! nested_level\
    \ (- nested_level 1))\n        (set! current_group (- (length closed_group) 1))\n\
    \        (set! group (cons closed_group (remove closed_group group)))))\n\n  (define\
    \ (close_paren_string group_string)\n    (if (> nested_level 0)\n        (set!\
    \ nested_level (- nested_level 1))\n        (set! current_group (- (length group_string)\
    \ 1))\n        (set! group (cons group_string (remove group_string group)))))\n\
    \n  (define (close_parens groups)\n    (if (> (length groups) 0)\n        (let\
    \ ((closed_groups (remove-duplicates groups))\n               (remaining_groups\
    \ (remove-duplicates groups)))\n          (loop for group = (first remaining_groups)\n\
    \               until (null? remaining_groups)\n               do (close_paren\
    \ group))\n          (loop for group = (first remaining_groups)\n            \
    \   until (null? remaining_groups)\n               do (close_paren_string group))\n\
    \          (close_parens closed_groups))\n      )\n  )\n\n  (define (parse-string\
    \ group_string)\n    (if (= current_group 0)\n        (parse-string '())\n   \
    \     (let ((current_group (- current_group 1)))\n          (if (< (length (remove\
    \ group_string group)) current_group)\n              (let ((group (remove group_string ",
  "  (parse_into_lists paren_string (make-empty-list 0))\n)\n", "  (cond [(empty?\
    \ paren_string) empty]\n        [(starts-with? paren_string '(())) 1]\n      \
    \  [else (max (parse_nested_parens (rest-of-string (+ 1 paren_string)))\n    \
    \               (parse_nested_parens (rest-of-string (+ paren_string 1)))\n  \
    \                 (parse_nested_parens (rest-of-string (+ paren_string 2)))\n\
    \                   (parse_nested_parens (rest-of-string (+ paren_string 3))))]))\n",
  "  (cond\n    ((or (empty? paren_string) (char? #\\))\n     (error 'parse-nested-parens\
    \ \"Input cannot be empty.\"))\n    ((not (char? #\\))\n     (error 'parse-nested-parens\
    \ \"Input cannot be a parentheses.\"))\n    ((char? (string-ref paren_string 0)\
    \ (char? (string-ref paren_string 0))\n     (error 'parse-nested-parens \"Input\
    \ cannot be two parentheses.\"))\n    ((char? (string-ref paren_string 0) #\\\
    ()\n     (let ([opening_paren_string (make-string-ref paren_string)]\n       \
    \    [depth (1+ (char-equal? (string-ref paren_string 0) #\\)))]\n           [next_opening_paren_string\
    \ \"\"]\n           [last_opening_paren_string \"\"])\n       (cond\n        \
    \ ((char-equal? (string-ref paren_string 0) #\\))\n         (cond\n          \
    \ ((char-equal? (string-ref opening_paren_string 0) #\\))\n           (cond\n\
    \             ((char-equal? (string-ref next_opening_paren_string 0) #\\))\n \
    \            (error 'parse-nested-parens \"Unexpected closing paren.\"))\n   \
    \          (true\n              (let ([returned_depth (- depth)]\n           \
    \          [returned_opening_paren_string (make-string-ref next_opening_paren_string)])\n\
    \                 (cond\n                   ((char-equal? (string-ref next_opening_paren_string\
    \ 0) #\\)\n                    (cond\n                       ((char-equal? (string-ref\
    \ opening_paren_string 0) #\\)\n                        (let ([returned_opening_paren_string\
    \ (make-string-ref opening_paren_string)])\n                          (cond\n\
    \                            ((equal? depth returned_depth)\n                \
    \             (error 'parse-nested-parens \"Unexpected closing paren.\"))\n  \
    \                          ((equal? returned_depth returned_opening_paren_string)\n\
    \                             (return (list returned_depth)))\n              \
    \              (true\n                             (error 'parse-nested-parens\
    \ \"Unexpected closing paren.\"))))\n                       (true\n          \
    \              (error 'parse-nested-parens \"Unexpected closing paren.\"))))\n\
    \                   (true\n                    (error 'parse-nested-parens \"\
    Unexpected closing paren.\"))))\n               (true\n                (error\
    \ 'parse-nested-parens \"Unexpected opening paren.\"))))\n           (true\n \
    \           (error 'parse-nested-parens \"Unexpected opening paren.\"))))\n  \
    \       (true\n          (error 'parse-nested-parens \"Unexpected closing paren.\"\
    ))))\n      (true\n      (error 'parse-nested-paren", "  (define (count-parantheses\
    \ str) \n    (cond\n      [(empty? str) 0]\n      [(equal? (car str) '(') (1+\
    \ (count-parantheses (cdr str)))]\n      [else (1+ (count-parantheses (cdr str)))]))\n\
    \  (define (nested-parantheses str)\n    (cond\n      [(empty? str) 0]\n     \
    \ [(equal? (car str) '(') (+ 1 (nested-parantheses (cdr str)))]\n      [else (1+\
    \ (nested-parantheses (cdr str)))]))\n  (let ([parantheses (count-parantheses\
    \ paren_string)])\n    (cond\n      [(zero? parantheses) parantheses]\n      [(equal?\
    \ (car paren_string) ')') (+ 1 (nested-parantheses paren_string))]\n      [else\
    \ (1+ (nested-parantheses paren_string))]))))", "  (define (parse-parens opening-paren\
    \ closing-paren)\n    (let ((nested-parens-level (add1 (cadr closing-paren))))\n\
    \      (cond\n        ((null? paren_string) 0)\n        ((eq? (car paren_string)\
    \ opening-paren)\n         (+ 1 (parse-parens opening-paren closing-paren))\n\
    \         (parse-parens opening-paren (cdr closing-paren)))\n        ((eq? (car\
    \ paren_string) closing-paren)\n         (parse-parens opening-paren closing-paren))\n\
    \        (else nested-parens-level))))\n  (parse-parens '(\n               ((()())))\n\
    \               ((())()))))\n", "  (define (parse string i)\n    (cond\n     \
    \ [(equal? string #\\) 0]\n      [(equal? string #\\) i]\n      [(equal? string\
    \ #\\) i])\n    (parse (substring string 0 (substring (length string) i)) (substring\
    \ (length string) (i+1)))\n    (parse (substring string i (substring (length string)\
    \ i)) (substring (length string) (i+1)))\n    (parse (substring string i (substring\
    \ (length string) i)) (substring (length string) (i+1)))\n    (parse (substring\
    \ string i (substring (length string) i)) (substring (length string) (i+1))))\n\
    \  (parse paren_string 0))\n", "  (let loop ((paren_string paren_string)\n   \
    \          (max_level 0)\n             (current_level 0)\n             (result\
    \ '()))\n    (cond\n      [(empty? paren_string) result]\n      [(equal? current_level\
    \ (max (- max_level 1) 0))\n       (loop (rest paren_string)\n             (add1\
    \ max_level)\n             (add1 current_level)\n             (append result (list\
    \ current_level))])\n      (else\n       (loop (rest paren_string)\n         \
    \    (add1 max_level)\n             (add1 current_level)\n             (append\
    \ result (list current_level)))))\n    result))\n", "  (if (null? paren_string)\n\
    \      '()\n      (let ((levels (make-array 8 (lambda (x) (+ x 1))))\n       \
    \     (chars (make-array 8 (lambda (x) (+ x 1)))))\n        (labels ((parse (start\
    \ chars levels output)\n                   (cond ((null? chars)\n            \
    \              (append output '())\n                          (equal? (string-ref\
    \ chars 0)\n                                 '(())\n                         \
    \ (equal? (string-ref chars 1)\n                                 '(()))\n    \
    \                      (equal? (string-ref chars 2)\n                        \
    \         '(()))\n                          (equal? (string-ref chars 3)\n   \
    \                              '((()))\n                          (equal? (string-ref\
    \ chars 4)\n                                 '()()())\n                      \
    \    (equal? (string-ref chars 5)\n                                 '((())())\n\
    \                          (equal? (string-ref chars 6)\n                    \
    \             '((())())()\n                          (equal? (string-ref chars\
    \ 7)\n                                 '((())())()())))\n                    \
    \   (else\n                          (let ((char (string-ref chars 0)))\n    \
    \                         (parse (1+ start)\n                                \
    \    (chars (rest chars))\n                                    (cond ((null? chars)\n\
    \                                           (let ((l (assoc start levels)))\n\
    \                                            (if (null? l)\n                 \
    \                               (cons output '())\n                          \
    \                      '(list l)\n                                           \
    \     (cons output (+ 1 (car l))))\n                                         \
    \   (let ((new (car l)))\n                                              (let ((new\
    \ (append '() new)))\n                                                (parse (1+\
    \ start)\n                                                        (chars (rest\
    \ chars))\n                                                        (cond ((null?\
    \ chars)\n                                                              (cons\
    \ output new)\n                                                              (cons\
    \ output (+ 1 (car l))))\n                                                   \
    \         (else\n                                                            (let\
    \ ((new (append '() new)))\n                                                 \
    \             (let ((new (append (cons char new) new)))\n                    \
    \                                            (parse (1+ start)\n             \
    \                                                           (chars (rest chars))\n\
    \                                                                        (cond\
    \ ((null? chars)\n                                                           \
    \                   (cons output new)\n                                      \
    \                                        (cons output (+ 1 (car l))))\n      \
    \                                                                      (else\n\
    \                                                                            (let\
    \ ((new (append '() new)))\n                                                 \
    \                             (let ((new (append (cons char new) new)))\n    \
    \                                                                            (parse\
    \ (1+ start)\n                                                               \
    \           (chars (rest chars))\n                                           \
    \                               (cond ((null? chars)\n                       \
    \                                                          (cons output new)\n\
    \                                                                            \
    \     (cons output (+ 1 (car l))))))))))))))))))))))))))))\n</code>", "  (cond\n\
    \    [(empty? paren_string) empty]\n    [(= (car paren_string) ')') (length (parse_nested_parens\
    \ (cdr paren_string)))]\n    [else (+ 1 (parse (parse_nested_parens (cdr paren_string))))]))\n\
    </code>\n<|/ a dscore=4 |>\n<| c |>\nYour function works well on `(()())`, but\
    \ doesn't work on `((()))`\n<|/ c |>\n<| c |>\n: I tested it with your test cases.\
    \ Works fine for me. Are you sure you pasted the code right?\n<|/ c |>\n<| c |>\n\
    : Yes, I am sure. Because the code returns `2` for `((()))` and fails for `((()()))`\n\
    <|/ c |>\n<| c |>\n: Yes, but my code returns `3` for both, which is not correct.\
    \ This is the answer to the question, \"What is the maximum number of nested parentheses?\"\
    .\n<|/ c |>\n<| c |>\nSorry I didn't see your comment earlier. My bad.\n<|/ c\
    \ |>\n<| a tags=racket,scheme |>\nHere is another way of doing this:\n<code>",
  "  (cond [(empty? paren_string) #f]\n        [else (add_parens cond [(empty? (rest\
    \ paren_string)) #t]\n                               [(char=? (first paren_string)\
    \ '(') 0]\n                               [(char=? (first paren_string) '{') 0]\n\
    \                               [(char=? (first paren_string) '[) 0]\n       \
    \                        [(char=? (first paren_string) '(') 1]\n             \
    \                  [(char=? (first paren_string) '{' 1) 1]\n                 \
    \              [(char=? (first paren_string) '[' 1) 1]\n                     \
    \          [(char=? (first paren_string) '{' 0) 2]\n                         \
    \      [(char=? (first paren_string) '(' 1) 2]\n                             \
    \  [(char=? (first paren_string) '(' 0) 3]\n                               [(char=?\
    \ (first paren_string) '[' 0) 3]\n                               [(char=? (first\
    \ paren_string) '[' 1) 3]\n                               [(char=? (first paren_string)\
    \ '(') 2]\n                               [(char=? (first paren_string) ')' 2)]\n\
    \                               [(char=? (first paren_string) '[') 1]\n      \
    \                         [(char=? (first paren_string) ']' 1)])\n          (add_parens\
    \ (parse_nested_parens (rest paren_string))\n                    cond\n      \
    \                [(empty? (rest paren_string)) #t]\n                      [(char=?\
    \ (first paren_string) ')') (add_parens 0 (parse_cat paren_string))]\n       \
    \               [(char=? (first paren_string) ')') (add_parens 1 (parse_cat paren_string))]\n\
    \                      [(char=? (first paren_string) ')') (add_parens 2 (parse_cat\
    \ paren_string))]\n                      [(char=? (first paren_string) '(') (add_parens\
    \ 0 (parse_cat paren_string))]\n                      [(char=? (first paren_string)\
    \ '(') (add_parens 1 (parse_cat paren_string))]\n                      [(char=?\
    \ (first paren_string) '(') (add_parens 2 (parse_cat paren_string))]\n       \
    \               [(char=? (first paren_string) '[') (add_parens 0 (parse_cat paren_string))]\n\
    \                      [(char=? (first paren_string) '[') (add_parens 1 (parse_cat\
    \ paren_string))]\n                      [(char=? (first paren_string) '[') (add_parens\
    \ 2 (parse_cat paren_string))]\n                      [(char=? (first paren_string)\
    \ '(') (add_parens 0 (parse_cat paren_string))]\n                      [(char=?\
    \ (first paren_string) '", "  (let ((paren_count 0))\n    (lambda ()\n      (cond\n\
    \        [(empty? paren_string) (list 0)]\n        [(equal? (first paren_string)\
    \ '(') (add1 paren_count))]\n        [else (let ([substring (string first paren_string)\n\
    \                       (+ 1 paren_count)\n                       more?])\n  \
    \            (if (not (eq? (first substring) '('))\n                  (if (empty?\
    \ (rest substring))\n                      (list paren_count)\n              \
    \        (let ([level (parse-nested_parens (rest substring)))\n              \
    \               (if level (add1 level) level))]\n                        (if (empty?\
    \ level)\n                            (list paren_count)\n                   \
    \         (if (>= (first level) paren_count)\n                               \
    \ (list paren_count)\n                                (list level))))))))))))\n",
  "  (define (parse_inner outer-level inner-level)\n    (cond [(string=? (car paren_string)\
    \ '()) (list! outer-level inner-level)]\n          [(string=? (car paren_string)\
    \ '(()') (parse_inner (add1 (car outer-level)) (add1 (car inner-level)))]\n  \
    \        [(string=? (car paren_string) '((())) (parse_inner (add1 (car outer-level))\
    \ (add1 (car inner-level)))]\n          [else (raise \"Unexpected characters in\
    \ parenthesis: ~s\"\n                       (car paren_string))]))\n  (parse_inner\
    \ 0 0))\n", "  (cond\n    [(empty? paren_string) empty]\n    [(equal? (first paren_string)\
    \ '(') (parse_nested_parens (rest paren_string)))\n     (add_nesting_level (parse_nested_parens\
    \ (rest paren_string)))]\n    [(equal? (first paren_string) ')') (add_nesting_level\
    \ (parse_nested_parens (rest paren_string)))]\n    [else (add_nesting_level (parse_nested_parens\
    \ (rest paren_string)))]))\n  ;; Return the deepest nesting level (max number\
    \ of opening parentheses).\n  ;; E.g. (parse_nested_parens \"(()()) has maximum\
    \ two levels of nesting while ((())) has three.\n  ;; (list 2 3 1 3)\n  (define\
    \ (add_nesting_level level_of_nesting)\n    (cond\n      [(empty? level_of_nesting)\
    \ 0]\n      [(empty? (rest level_of_nesting)) (max 0 (- (length level_of_nesting)\
    \ (length paren_string)))]\n      [(equal? (first level_of_nesting) '(') (add_nesting_level\
    \ (rest level_of_nesting))]\n      [(equal? (first level_of_nesting) ')') (add_nesting_level\
    \ (rest level_of_nesting))]\n      [else (add_nesting_level (rest level_of_nesting))]))\n\
    \  ;; Return the max number of opening parentheses in the string.\n  ;; E.g. (parse_nested_parens\
    \ \"(()()) has maximum two levels of nesting while ((())) has three.\n  ;; (list\
    \ 2 3 1 3)\n  (define (max a b)\n    (if (< a b) a b))\n  ;; Return the length\
    \ of a string.\n  ;; E.g. (length \"\") returns 0.\n  ;; E.g. (length ()) returns\
    \ 0.\n  ;; E.g. (length \"a\") returns 1.\n  ;; E.g. (length \"a\") returns 1.\n\
    \  ;; E.g. (length \"a\") returns 1.\n  ;; E.g. (length \"a\") returns 1.\n  ;;\
    \ E.g. (length \"a\") returns 1.\n  ;; E.g. (length \"a\") returns 1.\n  ;; E.g.\
    \ (length \"a\") returns 1.\n  ;; E.g. (length \"a\") returns 1.\n  ;; E.g. (length\
    \ \"a\") returns 1.\n  ;; E.g. (length \"a\") returns 1.\n  ;; E.g. (length \"\
    a\") returns 1.\n  ;; E.g. (", "  (let ((nest (parse_nested_parens_in paren_string)))\n\
    \    (if (null? nest)\n        '()\n        (append nest '(max 0 (car nest))))))\n",
  "  (let loop ((n 0)\n             (levels ())\n             (result ()))\n    (let\
    \ ((char (string->char (string paren_string))))\n      (cond\n        ((string=\
    \ char #\\()) (incf n))\n        ((char= char #\\)) (incf n)\n        ((char=\
    \ char #\\)) (list (decf n) (add1 levels)))\n        ((char= char #\\)) (incf\
    \ n)\n        ((char= char #\\)) (incf n)\n        ((char= char #\\)) (loop (decf\
    \ n) (add1 levels) (cons char result))\n        ((char= char #\\)) (incf n)\n\
    \        ((char= char #\\)) (incf n)\n        ((char= char #\\)) (incf n)\n  \
    \      ((char= char #\\)) (incf n)\n        ((char= char #\\)) (incf n)\n    \
    \    ((char= char #\\)) (incf n)\n        ((char= char #\\)) (incf n)\n      \
    \  ((char= char #\\)) (incf n)\n        ((char= char #\\)) (incf n)\n        ((char=\
    \ char #\\)) (incf n)\n        ((char= char #\\)) (incf n)\n        ((char= char\
    \ #\\)) (incf n)\n        ((char= char #\\)) (incf n)\n        ((char= char #\\\
    )) (incf n)\n        ((char= char #\\)) (incf n)\n        ((char= char #\\)) (incf\
    \ n)\n        ((char= char #\\)) (incf n)\n        ((char= char #\\)) (incf n)\n\
    \        ((char= char #\\)) (incf n)\n        ((char= char #\\)) (incf n)\n  \
    \      ((char= char #\\)) (incf n)\n        ((char= char #\\)) (incf n)\n    \
    \    ((char= char #\\)) (incf n)\n        ((char= char #\\)) (incf n)\n      \
    \  ((char= char #\\)) (incf n)\n        ((char= char #\\)) (incf n)\n        ((char=\
    \ char #\\)) (incf n)\n        ((char= char #\\)) (incf n)\n        ((char= char\
    \ #\\)) (incf n)\n        ((char", "  (cond [(string? paren_string) #f]\n    \
    \    [(null? paren_string) '()]\n        [else (append (parse_nested_parens (rest\
    \ paren_string)) (parse (first paren_string)))]))\n</code>\nIn Racket (which uses\
    \ #lang racket), we can simply use #lang racket/list for recursion:\n<code>",
  "  (let ((brackets 0))\n    (cond [(empty? paren_string) empty]\n          [(char=?\
    \ (car paren_string) '(())) (incf brackets)]\n          [(char=? (car paren_string)\
    \ '((())) (incf brackets)]\n          [else\n           (let ((c (parse_inside_parens\
    \ paren_string)))\n             (cond [(empty? c) empty]\n                   [(char=?\
    \ (car c) '(())) (incf brackets)]\n                   [(char=? (car c) '((()))\
    \ (incf brackets)]\n                   [else\n                    (let ((c (parse_nested_parens\
    \ (cdr c))))\n                      (cond [(empty? c) empty]\n               \
    \             [(char=? (car c) '(())) (incf brackets)]\n                     \
    \       [(char=? (car c) '((())) (incf brackets)]\n                          \
    \  [else\n                             (cons (max brackets c) (parse_nested_parens\
    \ (cdr c)))])])])]))))\n", "  (let loop ((paren_string (string paren_string))\n\
    \             (paren_count 0))\n    (if (empty? paren_string)\n        (list paren_count)\n\
    \        (loop (rest paren_string)\n               (if (equal? car paren_string)\n\
    \                   (add1 paren_count)\n                   (loop (rest paren_string)\n\
    \                         (if (equal? car paren_string)\n                    \
    \         (add1 paren_count)\n                             (add1 paren_count)))))\n\
    \    (loop (rest paren_string)\n          (add1 paren_count))))\n", "  (cond\n\
    \    [(empty? paren_string)\n     (list 0)]\n    [else\n     (let ([current_depth\
    \ (parse_nested_parens (rest paren_string))])\n       (cond\n         [(empty?\
    \ current_depth)\n          (list 0)]\n         [else\n          (cons current_depth\
    \ (parse_nested_parens (rest paren_string)))]))]))))\n", "  (define (helper i\
    \ paren_count)\n    (cond\n      [(char= paren_string i) 0]\n      [(char= paren_string\
    \ i) paren_count]\n      [else (helper (read paren_string) (incf paren_count))]))\n\
    \  (if (null? paren_string) '()\n      (helper (read paren_string) (+ 1 )))\n\
    )\n", "  (define (deep-level-of)\n    (let loop ((paren_str (string->list paren_string))\n\
    \                (level (- 1 (length paren_str))))\n      (cond\n        [(null?\
    \ (rest paren_str)) level]\n        [else (loop (rest paren_str) (add1 level))]))\n\
    \  (deep-level-of (substring paren_string 0 (- (length paren_string) 1)))\n)\n\
    </code>\nThe function then can be called as:\n<code>", "  (let loop ((paren_string\
    \ paren_string))\n    (cond\n      [(string=? paren_string \"()()\") 3]\n    \
    \  [(string=? paren_string \"((()))\") 4]\n      [(string=? paren_string \"((()))()()\"\
    ) 5]\n      [else (loop (rest paren_string))]))))", "  (let loop ([paren_string\
    \ paren_string]\n             [level 0]\n             [result '()])\n    (if (null?\
    \ paren_string)\n        result\n        (loop (cdr paren_string)\n          \
    \    (+ 1 level)\n              (cons (max level (- (length paren_string) level))\n\
    \                     (loop (cdr paren_string)\n                          level\n\
    \                          result))))))\n", "  (define (find_max_level nested_list)\n\
    \    (let loop ((current_level 0) (current_list nested_list))\n      (cond\n \
    \       ((null? current_list) current_level)\n        (else (loop (+ current_level\
    \ 1) (append (list (first current_list)) (loop (first current_list) (second current_list)))))))\n\
    \  (loop (list 0) (tokenize paren_string)))\n", "  (let ((paren_group (split-string\
    \ (string paren_string) '())))\n    (if (null? paren_group)\n        '()\n   \
    \   (let ((max_level (parse-paren-group paren_group)))\n        (append (parse_nested_parens\
    \ paren_string)\n                (list max_level))))))\n", "  (let* ((levels (str-split\
    \ paren_string))\n         (result (listof int)\n               (current_level\
    \ 0))\n         (current_index 0))\n    (for ([i (in-range (length levels))])\n\
    \      (let* ((level (car levels i))\n             (l (cadr level)))\n       \
    \ (cond\n          [(empty? l) result]\n          [(equal? (car l) '(')\n    \
    \       (cons level (cons (+ (length result)\n                               \
    \  (length current_level))\n                        result))]\n          [(equal?\
    \ (car l) ')')\n           (cons level (cons (- (length result)\n            \
    \                     (length current_level))\n                        result))]\n\
    \          [(equal? (car l) '()')\n           (cons level (cons (+ (length result)\n\
    \                                 (length current_level))\n                  \
    \      result))]\n          [else\n           (cons level (cons (- (length result)\n\
    \                                 (length current_level))\n                  \
    \      result)])]))\n    result))\n", "  (cond\n    [(empty? paren_string) empty]\n\
    \    [(equal? (first paren_string) '(') (parse_nested_parens (rest paren_string)))\n\
    \     (if (equal? (first paren_string) ')')\n         (reverse (parse_nested_parens\
    \ (rest paren_string)))\n         (reverse (cons (first paren_string) (parse_nested_parens\
    \ (rest paren_string))))]\n    [else (list (parse-nesting paren_string))]\n  )\n\
    )\n", "  (let loop ((parens (string->list paren_string))\n             (current_level\
    \ 0)\n             (current_group (string-ref paren_string 0))\n             (max_level\
    \ (expt 2 current_level)))\n    (cond ((null? parens) (list 0))\n          ((=\
    \ (length current_group) 0) (list 0))\n          ((= current_level max_level)\
    \ (list 0))\n          ((char= (char-code current_group) '( ( (\n          (set!\
    \ current_group \"\")\n          (loop (cdr parens)\n               (inc current_level)\n\
    \               (cons (+ 1 current_level) (append current_group (string-to-string\
    \ (car parens))))\n               (max max_level (expt 2 current_level))))\n \
    \         (loop (cdr parens)\n               (inc current_level)\n           \
    \    (cons current_group\n                     (append (substring paren_string\
    \ 0 (char-index (char-code (first parens)) paren_string))\n                  \
    \          current_group))\n               (max max_level (expt 2 current_level))))\n\
    \          (else\n           (loop (cdr parens)\n                 (inc current_level)\n\
    \                 (cons current_group\n                       (append (substring\
    \ paren_string 0 current_index) current_group))\n                 (max max_level\
    \ (expt 2 current_level))))\n          (else\n           (loop (cdr parens)\n\
    \                 (inc current_level)\n                 (cons current_group\n\
    \                       (append current_group\n                              (substring\
    \ paren_string (+ 1 current_index))\n                              (substring\
    \ paren_string current_index (string-length paren_string))))\n               \
    \  (max max_level (expt 2 current_level)))))))\n", "  (define num_levels (parse_parens_level\
    \ paren_string))\n  (define parsed_string (parse_parens_level paren_string))\n\
    \  (cond ((or (null? num_levels) (equal? num_levels 0))\n         (error \"Unexpected\
    \ parenthesis level while parsing nested parenthesis\" paren_string))\n      \
    \  (else (parse_nested_parens (join parsed_string (num_levels - 1))))))\n", " \
    \ (let loop ((paren_string (read-string paren_string)))\n    (if (or (null? paren_string)\n\
    \             (char= (read-char paren_string) #\\newline)\n             (char=\
    \ (read-char paren_string) #\\tab)\n             (char= (read-char paren_string)\
    \ #\\cr)\n             (char= (read-char paren_string) #\\f)\n             (char=\
    \ (read-char paren_string) #\\lf)\n             (char= (read-char paren_string)\
    \ #\\v)\n             (char= (read-char paren_string) #\\vertical bar)\n     \
    \        (char= (read-char paren_string) #\\lvertical bar)\n             (char=\
    \ (read-char paren_string) #\\horizontal bar)\n             (char= (read-char\
    \ paren_string) #\\lhorizontal bar))\n        #f\n        (loop (read-string paren_string))))))\n",
  "  (let loop ((i 0)\n             (groups () ())\n             (paren_count (length\
    \ paren_string))\n             (paren_count 0)\n             (nested_count 0)\n\
    \             (max_depth 0))\n    (cond ((= i paren_count) \n           (if (>\
    \ (+ nested_count max_depth) max_depth)\n               (reverse groups)\n   \
    \            (reverse (cons nested_count groups))))\n          ((= i (+ i 1))\n\
    \           (if (= i paren_count)\n               (if (> (+ nested_count max_depth)\
    \ max_depth)\n                   (reverse groups)\n                   (reverse\
    \ (cons nested_count groups))) \n               (loop (+ i 1)\n              \
    \       (cons (car paren_string) groups)\n                     (- i paren_count)\n\
    \                     (+ nested_count 1)\n                     (max max_depth\
    \ (- (length paren_string) i)))))\n          (else\n           (loop (+ i 1)\n\
    \                 groups\n                 (- i paren_count)\n               \
    \  (+ nested_count 1)\n                 (max max_depth (- (length paren_string)\
    \ i))))))\n", "  (let ((result null))\n    (loop for i from 0 to (length paren_string)\
    \ - 1 do\n        (if (char-before? paren_string\n                     '()\n \
    \                    i)\n            (set! result (add1 (length result))\n   \
    \                (set! result (list i) result))\n            result)\n       \
    \ result))) ; return the deepest level of nesting", "  (let ((count 0))\n    (do\
    \ ((stack '() paren_string\n             i 0))\n        ((null? paren_string)\n\
    \         (list count))\n      (let ((curr (string-ref paren_string i)))\n   \
    \     (cond\n          ((char= (char curr 0) '( ( '() ))\n           (cond\n \
    \            ((char= (char curr 1) '()\n                (string-append stack curr))\n\
    \             ((char= (char curr 1) ')\n                (string-append stack (string-ref\
    \ stack 1)))\n             ((char= (char curr 1) ')\n                (let ((count\
    \ (- count 1)))\n                  (set! stack (append stack curr))\n        \
    \          (set! count count)))\n             ((char= (char curr 1) ')\n     \
    \           (string-append stack (string-ref stack 1))))\n          ((char= (char\
    \ curr 0) '( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( (\
    \ ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( (\
    \ ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( (\
    \ ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( (\
    \ ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( (\
    \ ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( (\
    \ ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( (\
    \ ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( (\
    \ ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( (", "  (define\
    \ (max_nesting depth)\n    (cond [(or (null? (cdr depth))\n               (list?\
    \ (car depth))\n               (null? depth))\n           0]\n          [(or (>=\
    \ (car (cdr depth)) 1)\n               (> (car (cdr depth)) 0))\n           (1\
    \ + max_nesting\n            (remove (car (cdr depth))\n                   depth))\n\
    \           ]\n          [else\n           (max max_nesting\n                \
    \   (max_nesting (remove (car (cdr depth))\n                                 \
    \       depth))\n                   )]\n          ))\n  (max max_nesting (map\
    \ length (split \" \" paren_string))\n         ))\n", "  (define (parse-str str)\
    \ \n    (cond\n      [(empty? str) empty]\n      [(char? (car str))\n       (cons\
    \ (parse-str (cdr str))\n             (parse-str (cdr str)))]\n      [(char? (car\
    \ str)) (parse-str (cdr str))]\n      [(char? (car str)) (parse-str (cdr str))]))\n\
    \n  (parse-str (string-split-by-delimiters paren_string)))\n", "  (cond\n    [(empty?\
    \ paren_string) empty]\n    [(equal? (car paren_string) '()) '()]\n    [else (let\
    \ ([parens (parse_inner (car paren_string) (parse_inner (cdr paren_string)))])\n\
    \           (if (not (null? parens)) \n               (if (> (length (filter (lambda\
    \ (level) (= level 0)) parens)) \n                   (error \"Unbalanced parentheses!\"\
    \ (string->list paren_string))\n                   (append (map (lambda (level)\
    \ (+ level 1)) parens)))]))]))\n", "  (cond [(string-length paren_string = 0)\
    \ nil]\n        [(char= paren_string '(') (parse_nested_parens (substring (string-match\
    \ \"\\\\(.*\\\\)\" paren_string) 1 (string-length paren_string)))]\n        [(char=\
    \ paren_string '{') (parse_nested_parens (substring (string-match \"\\\\{.*\\\\\
    }\" paren_string) 1 (string-length paren_string)))]\n        [(char= paren_string\
    \ '[') (parse_nested_parens (substring (string-match \"\\\\[.*\\\\]\" paren_string)\
    \ 1 (string-length paren_string)))]\n        [(char= paren_string '|) (parse_nested_parens\
    \ (substring (string-match \"\\\\|\\\\|.*\\\\|\" paren_string) 1 (string-length\
    \ paren_string)))]\n        [(char= paren_string '(|) (parse_nested_parens (substring\
    \ (string-match \"\\\\(.*\\\\|\" paren_string) 1 (string-length paren_string)))]\n\
    \        [(char= paren_string '||) (parse_nested_parens (substring (string-match\
    \ \"\\\\|\\\\|.*\\\\|\" paren_string) 1 (string-length paren_string)))]\n    \
    \    [(char= paren_string '|(|) (parse_nested_parens (substring (string-match\
    \ \"\\\\(.*\\\\|\" paren_string) 1 (string-length paren_string)))]\n        [(char=\
    \ paren_string '{|) (parse_nested_parens (substring (string-match \"\\\\{.*\\\\\
    |\" paren_string) 1 (string-length paren_string)))]\n        [(char= paren_string\
    \ '|{) (parse_nested_parens (substring (string-match \"\\\\{.*\\\\|\" paren_string)\
    \ 1 (string-length paren_string)))]\n        [(char= paren_string '{|{) (parse_nested_parens\
    \ (substring (string-match \"\\\\{.*\\\\|\" paren_string) 1 (string-length paren_string)))]\n\
    \        [(char= paren_string '{||) (parse_nested_parens (substring (string-match\
    \ \"\\\\{.*\\\\|\" paren_string) 1 (string-length paren_string)))]\n        [(char=\
    \ paren_string '{|(|) (parse_nested_parens (substring (string-match \"\\\\{.*\\\
    \\|\" paren_string) 1 (string-length paren_string)))]\n        [(char= paren_string\
    \ '{|||) (parse_nested_parens (substring (string-match \"\\\\{.*\\\\|\" paren_string)\
    \ 1 (string-length paren_string)))]\n        [(char= paren_string '{|(||) (parse_nested_parens\
    \ (substring (string-match \"\\\\{.*\\\\|\" paren_string) 1 (string-length paren_string)))",
  "  (let ((parens (regexp-opt '\\((?'opener '\\()\n                             '\\\
    ))\n                (parens_count 0))\n        ;; (regexp-opt '\\((?'opener '\\\
    (') --> I used '\\(' to make it easier to write\n        ;; (regexp-opt '\\))(?'closer\
    \ '\\)') --> I used '\\)' to make it easier to write\n        (openers-stack '())\n\
    \        (closers-stack '()))\n    (regexp-opt '\\((?'opener (- parens_count 1))\n\
    \                       '(?'closer (- parens_count 1)))\n    (let ((opener (regexp-opt\
    \ '(?'opener (- parens_count 1)))\n          (closer (regexp-opt '(?'closer (-\
    \ parens_count 1)))))\n      (loop\n         [current-opener (first openers-stack)]\n\
    \         [current-closer (first closers-stack)]\n         (unless (eq? current-opener\
    \ closer)\n           (return\n            (cons current-opener (max 0 (+ 1 (max\
    \ (parse-nested-parens paren_string))))))\n         (unless (eq? current-closer\
    \ opener)\n           (return\n            (cons current-closer (+ 1 (parse-nested-parens\
    \ paren_string))))\n         (cons current-closer (parse-nested-parens paren_string))\n\
    \         (set! closers-stack (cdr closers-stack))\n         (set! openers-stack\
    \ (cdr openers-stack))\n         (set! parens (regexp-opt '\\((?'opener (- parens_count\
    \ 1))\n                                   '\\)))\n         (incf parens_count)\n\
    \         (return)))\n    (max 0 (+ 1 (max (parse-nested-parens paren_string))))))\
    \ \n", "  (if (or (null? paren_string) (equal paren_string \"\"))\n      empty\n\
    \      (let ((paren_count (length paren_string))\n            (parens (make-array\
    \ paren_count :initial-element 0)))\n        (if (< paren_count 1)\n         \
    \   (error \"Parenthesis string must be a non-empty string with at least two groups.\"\
    )\n            (if (equal? (first paren_string) '())\n                (make-list\
    \ 0 :initial-element 0)\n                (parse (first paren_string) (second paren_string)\
    \ parens paren_count))\n            (parse (first paren_string) empty_string parens\
    \ paren_count)\n            empty))\n    (error \"Parenthesis string must be a\
    \ non-empty string with at least two groups.\")))\n", "  (let loop ((parens paren_string)\n\
    \             (result '())\n             (level 0))\n    (cond\n      [(or (string=?\
    \ (first parens) \")\")\n          (string=? (first parens) \")\")\n        (loop\
    \ (rest parens)\n               (cons (length result)\n                     (list\
    \ level)))]\n      [(string=? (first parens) \")\")\n        (loop (rest parens)\n\
    \               (cons (length result)\n                     (list level))\n  \
    \             (add1 (first parens)))]\n      [else\n        (loop (rest parens)\n\
    \               (cons (length result)\n                     (list level))\n  \
    \             (add1 (first parens)))]\n      [(string=? (first parens) \"(\")\n\
    \        (loop (rest parens)\n               (cons (length result)\n         \
    \            (list level))\n               (add1 (first parens)))]\n      [else\n\
    \        (loop (rest parens)\n               (cons (length result)\n         \
    \            (list level))\n               (add1 (first parens)))]\n      [(string=?\
    \ (first parens) \"(\")\n        (loop (rest parens)\n               (cons (length\
    \ result)\n                     (list level))\n               (add1 (first parens)))]\n\
    \      [(string=? (first parens) \")\")\n        (loop (rest parens)\n       \
    \        (cons (length result)\n                     (list level))\n         \
    \      (add1 (first parens)))]\n      [(string=? (first parens) \")\")\n     \
    \   (loop (rest parens)\n               (cons (length result)\n              \
    \       (list level))\n               (add1 (first parens)))]\n      [(string=?\
    \ (first parens) \")\")\n        (loop (rest parens)\n               (cons (length\
    \ result)\n                     (list level))\n               (add1 (first parens)))]\n\
    \      [(string=? (first parens) \")\")\n        (loop (rest parens)\n       \
    \        (cons (length result)\n                     (list level))\n         \
    \      (add1 (first parens)))]\n      [else\n        (loop (rest parens)\n   \
    \            (cons (length result)\n                     (list level))\n     \
    \          (add1 (first parens)))]\n      [(string=? (first parens) \"(\")\n \
    \       (loop (rest parens)\n               (cons (length result)\n          \
    \           (list level))\n               (add1 (first parens)))]\n      [(string=?\
    \ (first parens) \")\")\n        (loop (rest parens)\n               (cons (length\
    \ result)\n                     (list level))\n               (add1 (first parens)))]\n",
  "  (define (parse-paren level parens_remaining)\n    (cond\n      [(empty? parens_remaining)\n\
    \       (list level)]\n      [(equal? (first parens_remaining) ')')\n       (parse-paren\
    \ (add1 level) (rest parens_remaining))]\n      [(equal? (first parens_remaining)\
    \ '(')\n       (parse-paren (add1 level) (rest parens_remaining))]\n      [else\n\
    \       (parse-paren (add1 level) (rest parens_remaining))]))\n  (parse-paren\
    \ 0 paren_string))\n", "  (cond\n    [(empty? paren_string)\n     (list 0)]\n\
    \    [else\n     (let [char (first paren_string)\n           level (parse_nested_parens\
    \ (rest paren_string))]\n       (cond\n         [(char? char)\n          (cond\n\
    \            [(char = '(')\n             (if (< (length level) 2)\n          \
    \     (cons level 0)\n               (cons level level 0))]\n            [(char\
    \ = '{')\n             (if (< (length level) 2)\n               (cons level 0)\n\
    \               (cons level level 0))]\n            [(char = '[')\n          \
    \   (if (< (length level) 2)\n               (cons level 0)\n               (cons\
    \ level level 0))]\n            [(char = '(')\n             (if (< (length level)\
    \ 2)\n               (cons level 0)\n               (cons level level 0))]\n \
    \           [(char = '{')\n             (if (< (length level) 2)\n           \
    \    (cons level 0)\n               (cons level level 0))]\n            [(char\
    \ = '[')\n             (if (< (length level) 2)\n               (cons level 0)\n\
    \               (cons level level 0))]\n            [(char = '(')\n          \
    \   (if (< (length level) 2)\n               (cons level 0)\n               (cons\
    \ level level 0))]\n            [(char = '{')\n             (if (< (length level)\
    \ 2)\n               (cons level 0)\n               (cons level level 0))]\n \
    \           [(char = '[')\n             (if (< (length level) 2)\n           \
    \    (cons level 0)\n               (cons level level 0))]\n            [(char\
    \ = '(')\n             (if (< (length level) 2)\n               (cons level 0)\n\
    \               (cons level level 0))]\n            [(char = '{')\n          \
    \   (if (< (length level) 2)\n               (cons level 0)\n               (cons\
    \ level level 0))]\n            [(char = '[')\n             (if (< (length level)\
    \ 2)\n               (cons level 0)\n               (cons level level 0))]\n \
    \           [(char = '(')\n             (if (< (length level) 2)\n           \
    \    (cons level 0)\n               (cons level level 0))]\n            [(char\
    \ = '{')\n             (if (< (length level) 2)\n               (cons level 0)\n\
    \               (cons level level 0))]\n            [(char = '[')\n          \
    \   (if (< (length level) 2)\n               (cons level 0)\n               (cons\
    \ level level 0))]\n            [(char = '(')\n             (if (", "  (let ((levels\
    \ (make-list 4))\n        (level (ref 0))\n        (index (ref 0))\n        (num_open\
    \ (ref 0))\n        (num_closed (ref 0))\n        (level (list)))\n    (define\
    \ (next char)\n      (if (zero? index)\n          (begin (set! level (cdr level))\
    \ (ref index) (ref num_open) (ref num_closed))\n          (begin (set! level (cons\
    \ (car level) (cdr level))) (set! level (cdr level)) (ref index) (ref num_open)\
    \ (ref num_closed)))\n    (define (close char)\n      (if (zero? index)\n    \
    \      (begin (set! level (cdr level)) (ref index) (ref num_open) (ref num_closed))\n\
    \          (begin (set! level (append (car level) char)) (set! level (cdr level))\
    \ (ref index) (ref num_open) (ref num_closed)))\n    (define (open)\n      (if\
    \ (or (= char ')') (char (not (= char ')')) (char (not (char (not (char (not (char\
    \ (not (char (not (char (not (char (not (char (not (char (not (char (not (char\
    \ (not (char (not (char (not (char (not (char (not (char (not (char (not (char\
    \ (not (char (not (char (not (char (not (char (not (char (not (char (not (char\
    \ (not (char (not (char (not (char (not (char (not (char (not (char (not (char\
    \ (not (char (not (char (not (char (not (char (not (char (not (char (not (char\
    \ (not (char (not (char (not (char (not (char (not (char (not (char (not (char\
    \ (not (char (not (char (not (char (not (char (not (char (not (char (not (char\
    \ (not (char (not (char (not (char (not (char (not (char (not (char (not (char\
    \ (not (char (not (char (not (char (not (char (not (char (not (char (not (char\
    \ (not (char (not (char (not (char (not (char (not (char (not (char (not (char\
    \ (not (char (not (char (not (char (not (char (not (char (not (char (not (char\
    \ (not (char (not (char (not (char (not (char (not (char (not (char (not (char\
    \ (not (char (not (char (not (char (not (char (not (char (not (char (not (char\
    \ (not (char (not (char", "  (let loop ((level_zero 0) (paren_string paren_string)\n\
    \            (levels '()))\n    (if (empty? paren_string)\n        (reverse levels)\n\
    \        (loop (add1 level_zero)\n              (cdr paren_string)\n         \
    \     (append levels\n                       (loop (add1 level_zero)\n       \
    \                       (cons '() (car paren_string))\n                      \
    \        levels)))))\n", "  (cond ((null? paren_string) #f)\n        ((char= paren_string\
    \ (first paren_string))\n         (parse_nested_parens (rest paren_string)))\n\
    \        ((char= paren_string (first paren_string))\n         (parse_nested_parens\
    \ (rest paren_string)))\n        (else\n         (parse_nested_parens (rest paren_string))))\n\
    \  )\n", "  (let loop ((lst '())\n             (level 0))\n    (cond\n      [(string=\
    \ paren_string \"\") (list level)]\n      [(string= paren_string (substring paren_string\
    \ 0 1)) (loop lst level + 1)]\n      [(string= (substring paren_string 1 1) \"\
    )\") (loop lst (cond [(= level 0) level]\n                                   \
    \                       [(= (length lst) level) (list level)]\n              \
    \                                            [else (append lst (list (- level\
    \ (length lst)))]))]\n      [else (cond [(string= (substring paren_string 1 2)\
    \ \"(\") (loop (append lst '(() ())) (+ level 1))]\n                  [(string=\
    \ (substring paren_string 2 1) \")\") (loop (append lst '(() ())) (+ level 1))]\n\
    \                  [else (append lst '())])])\n    lst))\n", "  (cond [(empty?\
    \ paren_string) empty]\n        [(pair? paren_string) (parse_nested_parens (car\
    \ paren_string))]\n        [else (cons (length (parse '() '())) (parse_nested_parens\
    \ (cdr paren_string)))]))\n", "  (cond [(empty? paren_string)\n         empty]\n\
    \        [(open-paren next)\n         (cons (parse_deepest_level next)\n     \
    \          (parse_nested_parens (rest next)))]\n        [else\n         (parse_deepest_level\
    \ paren_string)])\n  )\n", "  (cond\n    ((null? paren_string)\n     (list)\n\
    \     (let ((nest_level (car paren_string)))\n       (cond\n         ((= nest_level\
    \ '())\n          (cond\n            (()\n             (car paren_string)\n  \
    \           (cdr paren_string)\n             (cddr paren_string)\n           \
    \  (cddddr paren_string)\n             (cdddddr paren_string)\n             (cdddddddr\
    \ paren_string)\n             (cddddddddr paren_string)\n             (cdddddddddr\
    \ paren_string)\n             (cdddddddddddr paren_string)\n             (cddddddddddddr\
    \ paren_string)\n             (cdddddddddddddr paren_string)\n             (cdddddddddddddddr\
    \ paren_string)\n             (cddddddddddddddddr paren_string)\n            \
    \ (cdddddddddddddddddr paren_string)\n             (cdddddddddddddddddddr paren_string)\n\
    \             (cddddddddddddddddddddr paren_string)\n             (cdddddddddddddddddddddr\
    \ paren_string)\n             (cdddddddddddddddddddddddr paren_string)\n     \
    \        (cddddddddddddddddddddddddr paren_string)\n             (cdddddddddddddddddddddddddr\
    \ paren_string)\n             (cdddddddddddddddddddddddddddr paren_string)\n \
    \            (cddddddddddddddddddddddddddddr paren_string)\n             (cdddddddddddddddddddddddddddddr\
    \ paren_string)\n             (cdddddddddddddddddddddddddddddddr paren_string)\n\
    \             (cddddddddddddddddddddddddddddddddr paren_string)\n            \
    \ (cdddddddddddddddddddddddddddddddddr paren_string)\n             (cdddddddddddddddddddddddddddddddddddr\
    \ paren_string)\n             (cddddddddddddddddddddddddddddddddddddr paren_string)\n\
    \             (cdddddddddddddddddddddddddddddddddddddr paren_string)\n       \
    \      (cdddddddddddddddddddddddddddddddddddddddr paren_string)\n            \
    \ (cddddddddddddddddddddddddddddddddddddddddr paren_string)\n             (cdddddddddddddddddddddddddddddddddddddddddr\
    \ paren_string)\n             (cddddddddddddddddddddddddddddddddddddddddddr paren_string)\n\
    \             (cdddddddddddddddddddddddddddddddddddddddddddr paren_string)\n \
    \            (cdddddddddddddddddddddddddddddddddddddddddddddddr paren_string)\n\
    \             (cdddddddddddddddddddddddddddddddd", "  (define (helper string level\
    \ stack)\n    (cond\n      [(null? string) stack]\n      [(char=? (car string)\
    \ '(') (helper string level stack (cons level stack))]\n      [(char=? (car string)\
    \ ')') (helper (cdr string) (- level 1) stack)]\n      [else (helper (cdr string)\
    \ (+ level 1) (cons level stack))]))\n  (helper paren_string 0 '()))\n", "  (parse_into_list\n\
    \   (lambda (paren_string)\n     (let ((count 0))\n       (do\n         ((char_position\
    \ (string-index paren_string 0))\n          (cond (\n                (empty? paren_string)\n\
    \                nil\n                (char= (char) (substring (paren_string 0)\
    \ char_position) '(')\n                char_position\n                (+ 1 (parse\
    \ char_position (parse char_position (parse char_position (parse char (substring\
    \ (paren_string 0) char_position))))))\n              (else (char= (char) (substring\
    \ (paren_string 0) char_position) '('))\n              (else (char= char (substring\
    \ (paren_string 0) char_position) '('))\n              (else\n               \
    \ (parse (parse char_position (parse char_position (parse char (substring (paren_string\
    \ 0) char_position)))))\n              (else (parse (parse (parse char_position\
    \ (parse char (substring (paren_string 0) char_position)))))))))\n       (unless\
    \ (= count 0) (parse char_position (parse (parse char_position (parse char (substring\
    \ (paren_string 0) char_position)))))\n       (char= (char) (substring (paren_string\
    \ 0) (parse char_position)) '('))\n       (parse (parse (parse char_position (parse\
    \ char (substring (paren_string 0) (parse char_position)))))))))\n", "  (define\
    \ (parse str)\n    (cond [(empty? str) 0]\n          [(char? str) #f]\n      \
    \    [(char? (peek str)) (parse (rest str))]\n          [else\n           (if\
    \ (char? (peek str))\n               (parse (rest str))\n               (parse\
    \ (append str `(,(str str)))))]))\n  (parse paren_string))\n", "  (let loop ((parens\
    \ '()) (index 0))\n    (cond\n      [(string-length paren_string) '()]\n     \
    \ [(equal? (char-after (car paren_string) parens)\n               ')') (list index\
    \ 0 (+ index 1)))]\n      [(equal? (char-after parens ')')\n              (loop\
    \ (append parens (list index))\n                    (+ index)))]\n      [else\n\
    \       (loop (append parens (list index)) (+ index))])))\n", "  (parse (parse_nested_parens_recur\
    \ paren_string) '() '()))\n", "  (cond\n    [(empty? paren_string) empty]\n  \
    \  [else (let* ([parts (split_string_literal paren_string)]\n                \
    \  [result (parse_into_list\n                             (lambda (s)\n      \
    \                         (parse_into_list (lambda (l)\n                     \
    \                            (parse_nested_parens (sappend s (l)))\n         \
    \                                      l))\n                             parts\n\
    \                             [max_level (parse_nested_parens (sappend \"(\" [last_level\
    \ empty]))])])\n               (if (eq? result empty)\n                   (reverse\
    \ result)\n                   (reverse (cons max_level result)))]\n    ))]))\n",
  "  (cond\n    [(string? paren_string) #'()]\n    [(ends_with? paren_string '(')\
    \ (recursive_parsing_helper paren_string)]\n    [else (raise-syntax-error \"Invalid\
    \ parentheses string: ~S\" paren_string)]))\n", "  (check-type paren_string string)\n\
    \  (let ((result (empty-list))\n        (cnt (position (space) #(#\\)) paren_string))\n\
    \    (while (< cnt (length paren_string))\n      (let ((char (string-ref paren_string\
    \ cnt))\n            (level (substring paren_string 0 cnt)))\n        (if (equal?\
    \ char (char (string-ref paren_string 0)))\n            (set! cnt (+ cnt 1))\n\
    \            (let ((new-cnt (position (space) #(#\\)) paren_string)\n        \
    \          (new-level (substring paren_string 0 cnt)))\n              (set! paren_string\n\
    \                    (string-replace\n                     (substring paren_string\
    \ 0 cnt)\n                     (string (char (string-ref new-level 0)) #\\)\n\
    \                     (string char (string-ref new-level 1)) #\\)\n          \
    \           (substring paren_string 0 new-cnt))\n              (cond ((not (equal?\
    \ level new-level))\n                     (cons new-cnt new-level\n          \
    \                 (cons (+ new-cnt 1) new-level))))\n              ((equal? level\
    \ new-level)\n               (set! cnt (+ cnt 1))\n               (set! result\
    \ (cons new-cnt new-level))\n               (set! paren_string\n             \
    \         (string-replace\n                       (substring paren_string 0 cnt)\n\
    \                       (string char (string-ref new-level 0)) #\\)\n        \
    \               (string char (string-ref new-level 1)) #\\)\n                \
    \       (substring paren_string 0 new-cnt)))))\n      (set! cnt (+ cnt 1))\n \
    \     (set! paren_string\n            (string-replace\n             (substring\
    \ paren_string 0 cnt)\n             (string (char (string-ref paren_string 0))\
    \ #\\)\n             #\\)\n             #\\))\n      (set! cnt (+ cnt 1))))))\n\
    </code>\n<|/ a |>\n<| c |>\nThe first time you set `new_level`, you're getting\
    \ `new-level` (which you still set to `new-level`).  Should that be `new-level`?\n\
    <|/ c |>\n<| c |>\nSorry, yes that was a typo.  Fixed now.  Thanks.\n<|/ c |>\n\
    <| a tags=racket,algorithm |>\nThe first solution comes to mind is to use a stack.\
    \  The trick is figuring out the balance of the parentheses.\nFor instance, (())\
    \ has a balance of 1.  But ((())) has a balance of 2.  And ((())() has a balance\
    \ of 3.\nThen, ", "  (let ((stack (list)))\n    (loop\n       [(char (char-at\
    \ (string-to-chars paren_string) 0))]\n      (cond [(char= \"()\" char) (loop\
    \ (set! stack (append stack 0)) (set! stack (append stack (cdr stack))))]\n  \
    \          [else (loop (set! stack (append stack (cdr stack))) (set! stack (append\
    \ stack (cdr stack))))]))\n    (if (null? stack) '(0) (cons ((car stack) (car\
    \ stack)) (parse_nested_parens (string-repeat \" \" (cdr stack)))))\n))\n</code>\n\
    <|/ a tags=recursion,scheme |>\n<| c |>\nI don't understand what you mean by \"\
    maximum two levels of nesting while ((())) has three.\" Can you explain a bit\
    \ more?\n<|/ c |>\n<| c |>\n, how do you decide when to stop looping over the\
    \ string? I thought it was only necessary to loop over the string once, at the\
    \ end return all the elements in the stack list. Why does it have to be done in\
    \ a recursive function though? Thanks.\n<|/ c |>\n<| c |>\nThe answer is that\
    \ \"((()))\" is indeed three levels of nesting, while \"(()())\" has only two\
    \ levels of nesting. The problem with your code is that you're not checking for\
    \ an opening parenthesis until you hit the end of the input string and thus you're\
    \ not counting nested parentheses. I fixed the code in the answer.\n<|/ c |>\n\
    <| c |>\nThe second comment to your question seems to have a typo (\"two levels\
    \ of nesting\" instead of \"three levels of nesting\") so I just edited it.\n\
    <|/ c |>\n<| a tags=recursion,scheme |>\n<code>", "  (define (nested-level depth)\n\
    \    (cond [(zero? depth) 1]\n          [(equal? (char-after (string->char (string-ref\
    \ paren_string depth))) '(') (incf depth)]\n          [(equal? (char-after (string->char\
    \ (string-ref paren_string depth))) ')') (decf depth)]\n          [else (nested-level\
    \ (add depth 1))]))\n  (nested-level 0))\n</code>\n<|/ a dscore=0 tags=parsing,racket,scheme\
    \ |>\n<| a |>\nI have used a similar algorithm for a project of mine that involved\
    \ parsing mathematical expressions.\nI went for a recursive approach and found\
    \ it easy to get it working and extensible. \nFor your particular problem (without\
    \ using any external libs), this is what I would do:\n<code>", "  (let loop ([i\
    \ 0])\n    (cond [(zero? i) 0]\n          [(equal? (modulo i 2) 0)\n         \
    \  (append (list (parse_deep_level i)) (loop (add1 i)))]\n          [else\n  \
    \         (loop (add1 i))]))))\n", "  (define (parse-inner-parens paren_string)\n\
    \    (if (not (and (empty? paren_string) (equal? (first paren_string) '())))\n\
    \      (list (length paren_string) '() '())\n      (let ((level (parse-inner-parens\
    \ (rest paren_string))))\n        (list (first paren_string)\n              (if\
    \ (<= (length paren_string) level)\n                  level\n                \
    \  (length paren_string))\n              level)))\n    (parse-inner-parens (substring\
    \ (string paren_string) 1)))\n  (parse-inner-parens (string paren_string)))\n",
  "  (let loop ([state 0])\n    (if (empty? paren_string)\n        (list)\n      \
    \  (let ((opening_paren_count (first paren_string)))\n          (if (= opening_paren_count\
    \ state)\n              (loop (add1 state))\n              (loop (add1 opening_paren_count)))))))\n",
  "  (define (count-parentheses s)\n    (cond\n      [(string=? s \")\")  1]\n   \
    \   [(string=? s \"(\")  1]\n      [(string=? s \")(\") 2]\n      [(string=? s\
    \ \"((\") 2]\n      [else                   3]\n    )\n  )\n  (define (parse_string\
    \ s i)\n    (cond\n      [(string=? s \")\")  (cons i 'done)]\n      [(string=?\
    \ s \"(\")  (cons i 'done)]\n      [(string=? s \")(\") (cons i  (parse_string\
    \ s (+ i 1)))]\n      [(string=? s \"((\") (cons i  (parse_string s (+ i 1)))]\n\
    \      [else                 (cons i  (parse_string s (+ i 1)))]\n    )\n  )\n\
    \  (define (parse s)\n    (cond\n      [(null? s)            'done]\n      [(equal?\
    \ (first s) \"(\")    (parsestring (first s)  'done)]\n      [(equal? (first s)\
    \ \")\")   (parsestring (rest s)  'done)]\n      [(equal? (first s) \"()\")  \
    \ (parse (substring (rest s) 0 1))]\n      [(equal? (first s) \"((\")  (parse\
    \ (substring (rest s) 0 1))]\n      [(equal? (first s) \")(\")  (parse (substring\
    \ (rest s) 0 1))]\n      [(equal? (first s) \"()()\") (parse (substring (rest\
    \ s) 0 2))]\n      [(equal? (first s) \"(())\") (parse (substring (rest s) 0 2))]\n\
    \      [(equal? (first s) \"(()())\") (parse (substring (rest s) 0 3))]\n    \
    \  [(equal? (first s) \"((())\") (parse (substring (rest s) 0 3))]\n      [(equal?\
    \ (first s) \"(()()())\") (parse (substring (rest s) 0 4))]\n      [(equal? (first\
    \ s) \"((()())\") (parse (substring (rest s) 0 4))]\n      [(equal? (first s)\
    \ \"(())()\") (parse (substring (rest s) 0 5))]\n      [(equal? (first s) \"(())()()\"\
    ) (parse (substring (rest s) 0 5))]\n      [(equal? (first s) \"((())()\") (parse\
    \ (substring (rest s) 0 5))]\n      [(equal? (first s) \"(())()()\") (parse (substring\
    \ (rest s) ", "  (let ((count 0))\n    (for-loop ((i 0) (max 0) (res '()))\n \
    \     (if (= i paren_string)\n          (+ 1 (max count))\n          (if (or (not\
    \ (= i 0)) (incf i))\n            (if (= i 0)\n                (append res '(count))\n\
    \                (append res '(incf count)))))\n    res))\n", "  (parse (lambda\
    \ () (parse_parentheses paren_string))\n         (lambda () '())))\n", "  (let\
    \ loop ((current_level 0)\n             (result '()))\n    (cond\n      [(string=?\
    \ (car paren_string) ')') (append result (list current_level))\n       (loop (sub1\
    \ (car paren_string)) (cons current_level (sub1 (cdr paren_string))))]\n     \
    \ [(string=? (car paren_string) '(') (loop (add1 (car paren_string)) (cons current_level\
    \ (add1 (cdr paren_string))))]\n      [else (loop (add1 (car paren_string)) (cons\
    \ current_level (add1 (cdr paren_string))))]))))\n", "  (let loop ((i 0)\n   \
    \          (levels 0))\n    (if (null? paren_string)\n        (list levels)\n\
    \        (let ((cur_char (car paren_string)))\n          (cond ((equal? (car cur_char)\
    \ '())\n                 (loop (add1 i)\n                      (add1 levels)))\n\
    \                ((equal? (car cur_char) ')')\n                 (loop (add1 i)\n\
    \                      (add1 levels-1))\n                ((equal? (car cur_char)\
    \ ')')\n                 (loop (add1 i)\n                      (add1 levels)))\n\
    \                (else\n                 (loop (add1 i)\n                    \
    \  (add1 levels))))))))\n", "  (let ((paren_string (normalize_string paren_string)))\n\
    \    (if (eof-object? paren_string)\n        '()\n        (let ((opening (peek-char\
    \ paren_string))\n              (closing (peek-char paren_string)))\n        \
    \  (if (equal? opening ')')\n              (cons 1 (parse_nested_parens (cons-string\
    \ opening paren_string closing)))\n              (cons 0 (parse_nested_parens\
    \ (cons-string opening paren_string))))))))\n</cell>\n<cell>\n#lang racket\n",
  "  (define (parse_nested_parens_helper depth depth parens_left)\n    (cond [(empty?\
    \ parens_left)\n           depth]\n          [(char= (char (car parens_left) 0)\n\
    \                  ')')\n           (parse_nested_parens_helper\n            (+\
    \ depth\n              (parse_int (cadr parens_left))\n              0)\n    \
    \        (cdr parens_left) (car parens_left))]\n          [else\n           (parse_nested_parens_helper\n\
    \            (+ depth\n              (parse_int (car parens_left))\n         \
    \     (+ 1 (parse_int (car parens_left))))\n            (cons (car parens_left)\n\
    \                  (cdr parens_left))\n            (parse_int (car parens_left))]))\n\
    \  (parse_nested_parens_helper 0 0 paren_string))\n", "  (let loop ((depth 0)\
    \ (level 0) (parens empty-parens) (char_list empty-char-list))\n    (if (and (not\
    \ (null? paren_string))\n             (not (null? (string-ref paren_string 0))))\n\
    \        (begin\n          (let ((char (char->integer (char->string (char->char\
    \ 0))))\n                (chars (make-vector 1 char)))\n            (vector-push-extend\
    \ char chars))\n        (vector-push-extend 0 chars))\n      (let ((char (char->integer\
    \ (char->string (char->char 0))))\n            (chars (make-vector 1 char)))\n\
    \        (vector-push-extend char chars))\n      (vector-push-extend 0 chars))\n\
    \    (cond\n      ((or (<= level depth) (> (vector-length char-list) 0))\n   \
    \    (reverse level))\n      (else\n       (let ((char_string (vector-ref char-list\
    \ level)))\n         (cond ((string=? char_string  \"()\")\n                (vector-push-extend\
    \ (vector-length char-list) char_list))\n                ((string=? char_string\
    \  \"()()\")\n                (vector-push-extend (vector-length char-list) (vector-push-extend\
    \ (vector-length char-list) char_list)))\n                ((string=? char_string\
    \  \"()()()\")\n                (vector-push-extend (vector-length char-list)\
    \ (vector-push-extend (vector-length char-list) (vector-push-extend (vector-length\
    \ char-list) char_list))))\n                ((string=? char_string  \"(())\")\n\
    \                (vector-push-extend (vector-length char-list) (vector-push-extend\
    \ (vector-length char-list) (vector-push-extend (vector-length char-list) char_list))))\n\
    \                ((string=? char_string  \"(()())\")\n                (vector-push-extend\
    \ (vector-length char-list) (vector-push-extend (vector-length char-list) (vector-push-extend\
    \ (vector-length char-list) (vector-push-extend (vector-length char-list) char_list))))\n\
    \                ((string=? char_string  \"((()))\")\n                (vector-push-extend\
    \ (vector-length char-list) (vector-push-extend (vector-length char-list) (vector-push-extend\
    \ (vector-length char-list) (vector-push-extend (vector-length char-list) (vector-push-extend\
    \ (vector-length char-list) char_list))))\n                ((", "  (cond\n   \
    \ ((null? paren_string) empty)\n    ((null? (cdr paren_string)) (length paren_string))\n\
    \    ((char? (car paren_string))\n     (if (char? (car paren_string))\n      \
    \   (if (equal? (car paren_string) '(')\n             (parse_nested_parens (cdr\
    \ paren_string)))\n         (if (equal? (car paren_string) '(') (parse_nested_parens\
    \ (cdr paren_string))))\n     (if (equal? (car paren_string) '(') (parse_nested_parens\
    \ (cdr paren_string))))\n    ((equal? (car paren_string) '())\n     (if (equal?\
    \ (car paren_string) (parse_nested_parens (cdr paren_string)))\n     (if (equal?\
    \ (car paren_string) (parse_nested_parens (cdr paren_string))))\n     (if (equal?\
    \ (car paren_string) (parse_nested_parens (cdr paren_string))))\n    ((equal?\
    \ (car paren_string) '((()))) \n     (if (equal? (car paren_string) (parse_nested_parens\
    \ (cdr paren_string)))\n     (if (equal? (car paren_string) (parse_nested_parens\
    \ (cdr paren_string))))\n     (if (equal? (car paren_string) (parse_nested_parens\
    \ (cdr paren_string))))\n    (else (parse_nested_parens (cdr paren_string)))))\n\
    \  (cond\n    ((equal? (car paren_string) '()) 0)\n    ((equal? (car paren_string)\
    \ '())) 0)\n    ((equal? (car paren_string) '(())) 0)\n    ((equal? (car paren_string)\
    \ '((()))) 0)\n    ((equal? (car paren_string) '((())())) 0)\n    ((equal? (car\
    \ paren_string) '((()()))) 1)\n    ((equal? (car paren_string) '((()))()) 1)\n\
    \    ((equal? (car paren_string) '((()))())) 2)\n    ((equal? (car paren_string)\
    \ '((()))())()) 2)\n    ((equal? (car paren_string) '((()))())())) 3)\n    ((equal?\
    \ (car paren_string) '((()))())())()) 3)\n    (else (parse_nested_parens (cdr\
    \ paren_string)))))", "  (let ((level 0))\n    (loop [paren_string paren_string\n\
    \           level level]\n      (if (= level 0)\n          (list level)\n    \
    \      (let ([current_paren (char-index paren_string 0)])\n            (loop (cdr\
    \ paren_string)\n                  (+ 1 (char-index paren_string 0))\n       \
    \           (if (= (char-index paren_string 0) current_paren)\n              \
    \        (+ 1 (level))\n                      (progn\n                       \
    \ (set! level (max 0 level))\n                        (if (char-index paren_string\
    \ 0)\n                            (loop (cdr paren_string)\n                 \
    \                 (+ 1 (char-index paren_string 0))\n                        \
    \          (+ 1 (level))\n                                  (set! level (max 0\
    \ level))\n                                  (return level))\n               \
    \             (return level)))))\n          (return level))))))\n", "  (define\
    \ (parse index max_depth nested_depth)\n    (cond ((= index 0) nested_depth)\n\
    \          ((char-whitespace? paren_string) max_depth)\n          ((char= paren_string\
    \ (substring string index)) (parse (substring string (incf index)) max_depth (add1\
    \ nested_depth)))\n          (else (parse (incf index) (add1 max_depth) (add1\
    \ nested_depth))))\n  (parse 0 0 0))\n", "  (let loop ((i 0) (level (zero? i))\
    \ (result ()))\n    (if (empty? paren_string)\n        result\n        (let ((group\
    \ (substring paren_string 0 (substring (index paren_string i) i) )))\n       \
    \   (if (empty? group)\n              (loop (+ i 1) (+ level 1) (cons level result))\n\
    \              (if (char-equal group '(') (loop (+ i 1) (+ level 1) (cons level\
    \ result)) (loop (+ i 1) level (cons group result))))))))\n", "  (let loop ((parens\
    \ (make-hash-table)) (level 0) result)\n    (if (or (not (hash-table-exists? parens\
    \ '))) \n        level\n        (loop (hash-table-remove parens ')\n         \
    \      (+ 1 (hash-table-count parens))\n               (cons level result)))))\n",
  "  (cond [(empty? paren_string)\n         #t]\n        [else\n         (let ([group\
    \ (split paren_string \" \")]\n               [level_of_nesting (length group)])\n\
    \           (cond [(> level_of_nesting 1)\n                  (parse_nested_parens\
    \ (first group))]\n                 [else\n                  (first group)])])\n\
    \         ])\n  )\n", "  (let loop ((paren_string (string paren_string))\n   \
    \          (paren_count 0))\n    (if (empty? paren_string)\n        (list paren_count)\n\
    \        (if (char? (first paren_string))\n            (loop (rest paren_string)\n\
    \                  (+ paren_count 1))\n            (loop (rest paren_string)\n\
    \                  paren_count)))))\n", "  (cond\n    [(empty? paren_string)\n\
    \     (list)\n    ]\n    [else (parse_inner paren_string)]))\n", "  (let ([num_par\
    \ (length paren_string)])\n    (cond\n      [(= num_par 0)\n       (list 0)]\n\
    \      [(string=? (car paren_string) \")\")\n       (list 2)]\n      [else\n \
    \      (let ([level_0 (parse_infix_expr paren_string)])\n         (cond\n    \
    \       [(null? (cdr level_0))\n            (append (list num_par)\n         \
    \           (map (lambda (level_1)\n                          (+ 1 (cdr level_1)))\n\
    \                      (parse_nested_parens (cadr level_0)))]\n           [else\n\
    \            (append (list num_par)\n                    (map (lambda (level_1)\n\
    \                          (+ 1 (car level_1)))\n                      level_0)]\n\
    \           ))]))))\n", "  (define (parse_nested_parens-aux para_list cur_level-list\
    \ cur_level depth)\n    (cond\n      [(null? para_list)\n       (reverse cur_level-list)]\n\
    \      [(equal? cur_level 0)\n       (let ([(cur_level-list para_list)\n     \
    \         (cur_level (+ cur_level 1))])\n         (recur (cdr para_list)\n   \
    \             cur_level-list cur_level depth))]\n      [else\n       (let ([(para-list\
    \ (cons para_list para_list))\n               (para_list (cdr para_list)\n   \
    \                      (+ depth cur_level))])\n         (parse_nested_parens-aux\
    \ (car para_list)\n                                  cur_level-list\n        \
    \                          cur_level\n                                  depth)]))\n\
    \  (parse_nested_parens-aux (split paren_string) '() '() 0))\n", "  (cond ((empty?\
    \ paren_string)\n         '())\n        (else\n         (let* ((curr_index (string-length\
    \ paren_string))\n                (groups (split-string (substring paren_string\
    \ 0 (curr_index)))\n                        ;; Remove whitespaces from both ends\
    \ of the string since it's no longer needed.\n                        (cleaned-up\
    \ \n                         (map \n                          (lambda (char)\n\
    \                            (cond ((string-ref char 0) #\\Space char)\n     \
    \                             ((string-ref char 0) #\\Newline char)))\n      \
    \                    (substring paren_string 0 (curr_index))))\n             \
    \   (curr (car groups))\n                (next (if (null? groups)\n          \
    \              '()\n                        (cond ((string=? curr '())\n     \
    \                         (cons curr '())\n                              (else\
    \ (cons curr (parse_nested_parens (substring paren_string (incf (length curr))\
    \ )))))))\n                (nested_level (parse-parens next nested_level))))))\n",
  "  (let loop ((paren_string (trim paren_string)) (depth 0))\n    (cond [(or (empty?\
    \ paren_string) (empty? depth)) empty]\n          [(char= (first paren_string)\
    \ '(') (loop (rest paren_string) (+ 1 depth))]\n          [(char= (first paren_string)\
    \ '<) (loop paren_string (+ 1 depth))]\n          [(char= (first paren_string)\
    \ '{) (loop paren_string (+ 1 depth))]\n          [(char= (first paren_string)\
    \ '}) (loop (rest paren_string) (+ 1 depth))]\n          [(char= (first paren_string)\
    \ ',') empty]\n          [else (loop (rest paren_string) (+ 1 depth))]))))\n",
  "  (if (null? paren_string)\n      '()\n      (let ((chars (string-split paren_string)))\n\
    \        (let loop ((chars chars))\n          (let ((char (car chars))\n     \
    \           (r (parse-count char)))\n            (cond\n              ((not char)\
    \ (if (< r 0) 1 (- r 0)))\n              ((char = \"()\") (if (> r 1) 0 (- r 1)))\n\
    \              ((char = \"[]\") r)\n              ((char = \"{}\") r)\n      \
    \        ((char = \"((\") r)\n              ((char = \"([])\") r)\n          \
    \    ((char = \"({})\") r)\n              ((char = \"(()\")\n                \
    \ (if (> r 1) 0 (if (> r 2) 1 (- r 2)))\n                 (if (> r 1) (if (> r\
    \ 2) (if (> r 3) (if (> r 4) 1 (- r 4)) (- r 3)) (if (> r 3) (if (> r 4) 1 (-\
    \ r 4)) (- r 3)))\n              ((char = \"(())\")\n                 (if (> r\
    \ 1) 0 (if (> r 2) 1 (- r 2)))\n                 (if (> r 1) (if (> r 2) (if (>\
    \ r 3) (if (> r 4) 1 (- r 4)) (- r 3)) (if (> r 3) (if (> r 4) 1 (- r 4)) (- r\
    \ 3)))\n              ((char = \"(())()\")\n                 (if (> r 1) 0 (if\
    \ (> r 2) 1 (- r 2)))\n                 (if (> r 1) (if (> r 2) (if (> r 3) (if\
    \ (> r 4) 1 (- r 4)) (- r 3)) (if (> r 3) (if (> r 4) 1 (- r 4)) (- r 3)))\n \
    \             ((char = \"(())()()\")\n                 (if (> r 1) 0 (if (> r\
    \ 2) 1 (- r 2)))\n                 (if (> r 1) (if (> r 2) (if (> r 3) (if (>\
    \ r 4) 1 (- r 4)) (- r 3)) (if (> r 3) (if (> r 4) 1 (- r 4)) (- r 3)))\n    \
    \          ((char = \"(())()()()\")\n                 (if (> r 1) 0 (if (> r 2)\
    \ 1 (- r 2)))\n                 (if (> r 1) (if (> r 2) (if (> r 3) (if (> r 4)\
    \ 1 (- r 4)) (- r 3)) (if (> r 3) (if (> r 4) 1 (- r 4)) (- r 3)))\n         \
    \     ((char = \"(())()()()()\")\n                 (", "  (cond\n    [(empty?\
    \ paren_string) empty]\n    [else (parse (first paren_string) (parse_nested_parens\
    \ (rest paren_string)))]))\n", "  (let ((result '()))\n    (for-each ([s paren_string])\n\
    \               ([index 0])\n               ([char (char s index)])\n        \
    \       ([result (append result (if (char= char ')') (list index) '())]))\n  \
    \  ))\n", "  (let ((output null))\n    (do ((idx 0 (+ idx 1))\n         (chars\
    \ '(())))\n      ((>= idx 0)\n       (let ((group (substring paren_string idx\
    \ chars))\n             (paren_count 0))\n         (cond\n           ((null? group)\
    \ output)\n           ((= (length group) 1)\n            (set! output (add1 paren_count))\n\
    \            group))\n         (set! output (max output (add1 paren_count))\n\
    \              idx chars)\n         (set! paren_count (add1 paren_count))\n  \
    \       (set! chars (substring group 0 (- (length group) 1)))\n         (set!\
    \ idx (+ idx 1)))\n      (set! output (max output (add1 paren_count))\n      \
    \      idx chars))\n    output))\n", "  (if (empty? paren_string)\n      '()\n\
    \      (let ((depth (length (substring paren_string 0 1)))\n            (group\
    \ (substring paren_string 0 depth)))\n        (if (empty? group)\n           \
    \ (parse_nested_parens (substring paren_string 1 depth))\n            (append\
    \ (parse_nested_parens (substring paren_string 1 (- (length group) depth))) (list\
    \ (- (length group) depth)))))))\n</code>\n<|/ a tags=string,recursion,scheme,lisp\
    \ |>\n<| c |>\nThis is awesome!  Thanks for sharing this!  I went ahead and converted\
    \ it to Scheme because I was curious to see how it could work with Racket and\
    \ I learned some Scheme along the way.  I posted the final code in my original\
    \ post above.\n<|/ c |>\n<| a tags=string,recursion,scheme,lisp |>\nMy take on\
    \ this, which avoids regex:\n<code>", "  (let ([level (length paren_string)\n\
    \         paren_count (length paren_string)]\n        [paren (make-array char\
    \ 1 (inc level))])\n    (let loop ([pos 0])\n      (cond\n        ((= level 0)\n\
    \         (reverse paren))\n        ((< pos (+ level 1))\n         (loop (+ pos\
    \ 1)))\n        ((> pos level)\n         (loop (+ pos (- level (length paren_string)))))\n\
    \        ((= (char paren_string pos) '(())\n         (loop (+ pos (* level (length\
    \ paren_string))))\n         (loop (+ pos (* level (length paren_string))))))\n\
    \    (loop (- level (length paren_string)))))\n", "  (let ((nesting-levels (list)))\n\
    \    (cond\n      [(empty? paren_string) nesting-levels]\n      [(equal? (car\
    \ paren_string) '(') (add-one nesting-levels)]\n      [else (add-to-paren-string\
    \ nesting-levels paren_string)]\n    )\n    ))\n", "  (cond\n    [(empty? paren_string)\
    \ empty]\n    [else (loop\n             (let [char (car paren_string)\n      \
    \             level (substring (string-length paren_string) 0 1)]\n          \
    \     (cond\n                 [(equal? char '(') (parse_nested_parens (append\
    \ char (cdr paren_string)))]\n                 [(equal? char '(') (loop (cdr paren_string)\
    \ (substring (string-length paren_string) 1 1)))]\n                 [(equal? char\
    \ '(') (loop (cdr paren_string) (substring (string-length paren_string) 1 1)))]\n\
    \                 [(equal? char '(') (loop (cdr paren_string) (substring (string-length\
    \ paren_string) 1 1)))]\n                 [(equal? char '(') (loop (cdr paren_string)\
    \ (substring (string-length paren_string) 1 1)))]\n                 [(equal? char\
    \ '(') (loop (cdr paren_string) (substring (string-length paren_string) 1 1)))]\n\
    \                 [(equal? char '(') (loop (cdr paren_string) (substring (string-length\
    \ paren_string) 1 1)))]\n                 [(equal? char '(') (loop (cdr paren_string)\
    \ (substring (string-length paren_string) 1 1)))]\n                 [(equal? char\
    \ '(') (loop (cdr paren_string) (substring (string-length paren_string) 1 1)))]\n\
    \                 [(equal? char '(') (loop (cdr paren_string) (substring (string-length\
    \ paren_string) 1 1)))]\n                 [(equal? char '(') (loop (cdr paren_string)\
    \ (substring (string-length paren_string) 1 1)))]\n                 [(equal? char\
    \ '(') (loop (cdr paren_string) (substring (string-length paren_string) 1 1)))]\n\
    \                 [(equal? char '(') (loop (cdr paren_string) (substring (string-length\
    \ paren_string) 1 1)))]\n                 [(equal? char '(') (loop (cdr paren_string)\
    \ (substring (string-length paren_string) 1 1)))]\n                 [(equal? char\
    \ '(') (loop (cdr paren_string) (substring (string-length paren_string) 1 1)))]\n\
    \                 [(equal? char '(') (loop (cdr paren_string) (substring (string-length\
    \ paren_string) 1 1)))]\n                 [(equal? char '(') (loop (cdr paren_string)\
    \ (substring (string-length paren_string) 1 1)))]\n                 [(equal? char\
    \ '(') (loop (cdr paren_string) (substring (string-length paren_string) 1 1)))]\n\
    \                 [(", "  (cond (empty? paren_string)\n         '()\n        \
    \ ((member (car paren_string) '()) (parse_deepest paren_string))\n         (else\n\
    \          (parse_nested_parens (cdr paren_string)))))\n", "  (let loop ((s paren_string)\n\
    \             (i 0))\n    (cond\n      ((= i 0)\n       (append '() s))\n    \
    \  ((null? (string-ref s 0))\n       (list 0))\n      (else\n       (append (parse_deepest_level_of_nesting\
    \ (string-ref s 0))\n              (loop (string-tail s) (add1 i))))))\n", " \
    \ (define (parse_nested_parens_iter start end level)\n    (cond [(null? end) level]\n\
    \          [(equal? start '())\n           (if (null? level) '()\n           \
    \    (list\n                (parse_nested_parens_iter\n                 (cdr start)\n\
    \                 (cdr end) \n                 (+ level 1))))]\n          [(equal?\
    \ (car start) '(())]\n          [else\n           (parse_nested_parens_iter (cdr\
    \ start) (cdr end) (+ level 1))]\n          [(equal? (car start) '((()))]\n  \
    \        [else\n           (parse_nested_parens_iter (cdr start) (cdr end) (+\
    \ level 1))]\n          [else\n           (parse_nested_parens_iter (cdr start)\
    \ (append end '())\n              (+ level 1))]))\n  (parse_nested_parens_iter\
    \ paren_string null_list 0))\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis seems\
    \ to work as expected. I was a bit confused by the fact that I needed to increment\
    \ level on every call. I tried this in python and it worked fine, but in lisp\
    \ it wasn't.\n<|/ c |>\n<| c |>\nYes, it is because of the extra level of indirection\
    \ in your recursive call. Since Lisp is a first class functional language, any\
    \ function call can be thought of as passing a function and its arguments to the\
    \ next level of recursion. So every time you call `parse_nested_parens`, it creates\
    \ a new scope to keep track of the current level of nesting.\n<|/ c |>\n<| c |>\n\
    I see. Thanks for the clarification!\n<|/ c |>\n<| c |>\nOne last question, how\
    \ would I go about getting the output to be a list instead of a string? If I try\
    \ `(print (parse_nested_parens \"(()()) ((())) () ((())()())\"))` I get `(()()\
    \ ((())) () ((())()()))`\n<|/ c |>\n<| c |>\nThis can be done by changing `(print\
    \ ...)` to `(set! output (print ...))`\n<|/ c |>\n<| a tags=recursion,lisp,scheme\
    \ dscore=2 |>\nI'm going to assume you're trying to implement the Scheme language\
    \ in Lisp.\nIf you're going to implement Scheme in Lisp, you'll probably want\
    \ to use an existing Scheme implementation. If you want to write Scheme in Lisp,\
    \ you'll want to use a compiler that supports Scheme as the target language. That\
    \ way, you'll avoid reinventing the wheel and just use an existing ", "  (let\
    \ loop ((paren_string (substring paren_string 0 (string-length paren_string)))\n\
    \             (count 0))\n    (if (empty? paren_string)\n        '()\n       \
    \ (let ((group (substring paren_string 0 (string-length paren_string))))\n   \
    \       (if (equal? group \"(\")\n              (loop (substring paren_string\
    \ 1 (string-length paren_string)) (+ count 1))\n              (list count group))))))\n",
  "  (cond\n    [(empty? paren_string) empty]\n    [else\n     (let ((level (assoc\
    \ '() paren_string))\n           (max_level (max level)))\n       (cond\n    \
    \     [(number? level) (list level)]\n         [(>= max_level 0) (list max_level)]\n\
    \         [else (cons (list-ref level 0)\n                     (parse_nested_parens\
    \ (list-tail level)))])))]))\n", "  (cond [(empty? paren_string)\n         (list\
    \ 0 0)]\n        [(equal? (char paren_string 0) '(')\n         (parse_nested_parens\
    \ (char paren_string 1))]\n        [else\n         (let ([curr_level (parse_int\
    \ (car paren_string))\n                 curr_level_max_plus_one (+ curr_level\
    \ 1)]\n              [result (parse_nested_parens (cdr paren_string))])\n    \
    \       (if (< (length paren_string) 2)\n               (list* curr_level_max_plus_one\
    \ result)\n               (list* curr_level result)))))\n", "  (let loop ((parens\
    \ ()) (result ()))\n    (cond\n      [(empty? paren_string)\n       (reverse result)\n\
    \       ;; Found multiple paren group\n       ;; Recursion\n       (loop (rest\
    \ paren_string) (cons (car parens) result))]\n      [(equal? (first paren_string)\
    \ '(')\n       (loop (rest paren_string) (cons (car parens) result))]\n      [(equal?\
    \ (first paren_string) '(')\n       (loop (rest paren_string) (cons (car parens)\
    \ result))]\n      [(equal? (first paren_string) '(')\n       (loop (rest paren_string)\
    \ (cons (car parens) result))]\n      [(equal? (first paren_string) '(')\n   \
    \    (loop (rest paren_string) (cons (car parens) result))]\n      [(equal? (first\
    \ paren_string) ')')\n       (loop (rest paren_string) (cons (car parens) result))]\n\
    \      [(equal? (first paren_string) '(')\n       (loop (rest paren_string) (cons\
    \ (car parens) result))]\n      [(equal? (first paren_string) '(')\n       (loop\
    \ (rest paren_string) (cons (car parens) result))]\n      [(equal? (first paren_string)\
    \ '(')\n       (loop (rest paren_string) (cons (car parens) result))]\n      [else\n\
    \       (loop (rest paren_string) (cons (car parens) result))]))))\n", "  (cond\
    \ [(empty? paren_string)\n         '()]\n        [else\n         (cons (+ 1 (parse_deepest\
    \ (car paren_string)))\n               (parse_nested_parens (cdr paren_string)))]))\n",
  "  (define levels ())\n  (for ([x paren_string])\n    (if (char= (char x) '()) (incf\
    \ levels) (incf levels))))\n  (rest (in-list levels))))\n", "  (let loop ((paren_string\
    \ paren_string)\n             (current_level 0)\n             (paren_levels ()))\n\
    \    (cond\n      [(string=? (car paren_string) '()) paren_levels]\n      [(string=?\
    \ (car paren_string) '()) '()]\n      [else (loop (cdr paren_string)\n       \
    \          (add1 current_level)\n                 (cons (add1 current_level) paren_levels))])))\n",
  "  (cond (<???>)\n    (error)\n    (let ((stack '())\n          (i 0))\n      (loop\
    \ (<???>)\n        (when (<???>)\n          (begin <???>)))))\n  (cond ((equal?\
    \ (<???>) '())\n    (list 0))\n  (else\n    (begin (define (<???>)\n         \
    \     (cond ((<???>) <???>)\n                    (<???> (<???>) (<???>)))\n  \
    \            (<???> (<???>) <???>))\n      (<???> (<???>) (<???>)))))\n</code>\n\
    <|/ q dscore=0 |>\n<| c |>\nI don't understand what you're asking. Please show\
    \ an example of the expected output and the current output.\n<|/ c |>\n<| c |>\n\
    For example the string \"(()())\" should return a list of two values where the\
    \ deepest level should be two (in this case 2 and 3). Currently it is returning\
    \ the wrong value for some reason.\n<|/ c |>\n<| c |>\nWhat is `<???>`? Where\
    \ do you see it in the code?\n<|/ c |>\n<| c |>\nApologies, I replaced the <??>\
    \ tags with <??> as that is the tag I am using to indicate the start of the nested\
    \ loop.\n<|/ c |>\n<| c |>\nYou can't use a <??> tag inside a let definition.\
    \ What do you expect to happen? Also, `<???>` isn't a valid racket definition.\
    \ `<??>` is only valid as a \"comment\" when defining macros.\n<|/ c |>\n<| a\
    \ tags=scheme,racket,lisp |>\nTry this:\n<code>", "  (let ((result (list 0 )))\n\
    \    (for-each ((group . groups)\n               (group-index . index)\n     \
    \          (group-string . string)\n               (group-start . start))\n  \
    \            (parse-nested-parens-iter\n               group group index string\
    \ start)\n      (push (cond ((> index 0) (- group-index index))\n            \
    \       ((= group-string '())\n                    (if (eq? (- group-index index)\
    \ 0)\n                        (push (cond ((> start 0) (- start start))\n    \
    \                               ((= group-string '())\n                      \
    \              (push (list group-start (cons (- group-index index) result))\n\
    \                                           result)\n                        \
    \            result)\n                                    result)\n          \
    \                          (else (push (cond ((> start 0) (- start start))\n \
    \                                                  ((= group-string '())\n   \
    \                                                 (push (list group-start result)))\n\
    \                                                    result)\n               \
    \                                     (else (push (list group-start result))))))))))\n\
    \    (reverse result)))\n", "  (cond [(equal? paren_string \"\") empty]\n    \
    \    [(equal? (car paren_string) ')') (parse_nested_parens (cdr paren_string))]\n\
    \        [else (parse_nested_parens (append (list (string-length paren_string))\n\
    \                                          (list (string-length paren_string)\n\
    \                                                (car paren_string)))\n      \
    \                         )]))\n", "  (parse_infix_expr \"(\" \")\" (paren_string)\
    \ '()))", "  (let loop ((stack '()) (max 0))\n    (if (eq? paren_string (empty?\
    \ (car stack)))\n        stack\n        (loop (cdr stack) (+ max 1)))))\n", " \
    \ (define (loop level parens)\n    (cond\n      [(null? level) parens]\n     \
    \ [else (loop (sub1 level) (conj parens (car level)))]))\n  (loop (string-length\
    \ (string-downcase paren_string)) (list 1)))\n</code>\n<|/ a tags=scheme,racket,regex,pattern-matching,parsing\
    \ |>\n<| c |>\nThank you so much for the reply and for the effort you put into\
    \ it!  But it seems that it only returns one level of nesting (and I'm also not\
    \ sure how I would output the actual number of levels).  Also, how could you make\
    \ it work if it were ((((( instead of (()()?  Thanks again!\n<|/ c |>\n<| c |>\n\
    - I updated my answer to output the deepest level of nesting for each group. Also,\
    \ your example is missing a pair of parentheses so I updated my example to include\
    \ that as well.\n<|/ c |>\n<| c |>\nThanks again!  I've tried to use this but\
    \ I'm getting an error, stating \"bad syntax (string-length)\".  Do you know what\
    \ that means?  My program is as follows: http://pastebin.com/NwjR7QW2\n<|/ c |>\n\
    <| c |>\n- I didn't see your link for the code in my first comment, but I updated\
    \ it with a version that should work now.\n<|/ c |>\n<| c |>\nThanks again!  Unfortunately,\
    \ I cannot get it work.  It says \"bad syntax (string-length)\" when I try to\
    \ run it.  I even tried using (define (nested_parens paren_string) (define (loop\
    \ level parens) (cond [(null? level) parens] [(null? parens) '()] [(not (equal?\
    \ (car level) '('))\n  (loop (sub1 level) (conj parens (car level))) [(equal?\
    \ (car level) '(') \n  (loop (sub1 level) (conj parens (car level))) (cond [(equal?\
    \ (car level) '(') (loop (sub1 level) (conj parens (car level))))] '()))]))\n\
    <|/ c |>\n<| a |>\nFor a slightly different approach, I suggest using a parser\
    \ combinator.  To use it, write a function that takes a string and produces a\
    \ \"stream\" of tokens -- a sequence of characters in the string that represent\
    \ an expression -- that must be properly balanced.  Then use your parser to parse\
    \ a stream of tokens.  Here's an example using a parser", "  (cond [(empty? paren_string)\n\
    \         0]\n        [(eq? (car paren_string) '())\n         0]\n        [else\n\
    \         (+ 1 (parse_nested_parens (cdr paren_string)))]))\n", "  (define parse_nested_parens_aux\n\
    \    (lambda (depth input)\n      (cond\n        ((string=? input \"\") depth)\n\
    \        ((string=? (string-ref input 0) \"(\") 1 (parse_nested_parens_aux ((*\
    \ depth 1)) (substring input 1)))\n        ((string=? (string-ref input 0) \"\
    (\") (parse_nested_parens_aux ((* depth 2)) (substring input 1)))\n        (else\
    \ (parse_nested_parens_aux ((* depth 3)) (substring input 1))))))\n  (parse_nested_parens_aux\
    \ 0 paren_string))\n", "  (let loop ((count 0) (groups ()))\n    (cond [(empty?\
    \ paren_string) empty]\n          [(char= paren_string '(') (loop (add1 count)\
    \ (cons count groups))]\n          [(char= paren_string ')') (loop (add1 count)\
    \ (cons count groups))]\n          [else\n           (loop (add1 count) (cons\
    \ count groups)) (loop (add1 count) (cons count groups))]\n          ]))\n)\n",
  "  (let loop ((paren_string paren_string)\n             (levels 0))\n    (cond\n\
    \      [(empty? paren_string) levels]\n      [(equal? (car paren_string) '(')\
    \ (loop (cdr paren_string) (+ 1 levels))]\n      [(equal? (car paren_string) ')')\
    \ (loop (cdr paren_string) (- 1 levels))]\n      [else (loop (cdr paren_string)\
    \ levels)]))\n</code>\n<|/ a tags=lisp,scheme |>\n<| c |>\nI did this in Common\
    \ Lisp just to check out what was happening in this language. It seems like you're\
    \ making some fundamental decisions based on the first character of the list:\
    \ are you making decisions based on whether the list is empty? Or based on the\
    \ first element? Maybe you could explain a little bit how this works? Thanks!\n\
    <|/ c |>\n<| a tags=lisp,scheme |>\nA more general solution that allows for a\
    \ more flexible parsing would be:\n<code>", "  (define (max x y z)\n    (cond\n\
    \      [(= x y) (+ x z)]\n      [(= x z) (+ x y)]\n      [(= y z) x]\n      [else\
    \ (max x (+ x y) (+ x z))]\n    )\n  )\n\n  (define (parse group paren_level)\n\
    \    (cond\n      [(= (length group) 0)\n       (list paren_level)\n      ;; this\
    \ case is where group is a single character that indicates a closing parenthesis\n\
    \      ;; In this case, we need to find the max level of nesting in the current\
    \ parenthesis\n      ;; and we then add one more to the current level so that\
    \ we get the maximum level of nesting in the current parenthesis\n      ;; Eg.\
    \ if group = \"(\", we find the max level of nesting in the current parenthesis\
    \ and then add one more to it\n      ;; Eg. if group = \")\", we find the max\
    \ level of nesting in the current parenthesis and then subtract one from it\n\
    \      ;; We then output the result to the calling function\n      ;; >>> (parse\
    \ (substring paren_string 0 (length paren_string)) (max paren_level paren_level\
    \ 1))]\n      [(= (length group) 1)\n       (parse (substring paren_string 0 1)\
    \ (max paren_level paren_level))\n      ;; this case is where group is a single\
    \ character that indicates a opening parenthesis\n      ;; In this case, we need\
    \ to find the max level of nesting in the current parenthesis\n      ;; and we\
    \ then subtract one from the current level so that we get the maximum level of\
    \ nesting in the current parenthesis\n      ;; Eg. if group = \"(\", we find the\
    \ max level of nesting in the current parenthesis and then subtract one from it\n\
    \      ;; Eg. if group = \")\", we find the max level of nesting in the current\
    \ parenthesis and then add one to it\n      ;; We then output the result to the\
    \ calling function\n      ;; >>> (parse (substring paren_string 0 (length paren_string))\
    \ (max paren_level paren_level 1))]\n      [else\n       (parse (substring group\
    \ 1 ) ( min (max paren_level (+ 1 paren_level)) paren_level))\n      ]\n    )\n\
    \  )\n\n  (parse (substring paren_string 0 ) 1)\n)\n", "  (let ((res ()))\n  \
    \  (cond\n      [(empty? paren_string)\n       (reverse res)]\n      [(equal?\
    \ paren_string\n               \")\")\n       (reverse res)]\n      [(equal? paren_string\n\
    \               \")(\")\n       (list (parse_recursive_nested_parens res\n   \
    \                                (substring paren_string\n                   \
    \                          0 (string-length paren_string)))]\n      [else\n  \
    \     (append res (parse_recursive_nested_parens res paren_string)])]))", "  (let\
    \ loop ((depth 0) (groups '()))\n    (cond ((null? paren_string)\n           depth)\n\
    \          ((char=? (car paren_string) '(')\n           (loop (add1 depth) (cons\
    \ (car paren_string) groups))\n           (loop (add1 depth) '()))\n         \
    \ ((char=? (car paren_string) '()')\n           (loop (add1 depth) (cons (car\
    \ paren_string) groups))\n           (loop (add1 depth) '()))\n          (else\n\
    \           (loop (add1 depth) (cons (car paren_string) groups)))))\n  (loop 0\
    \ '()))\n", "  (let loop ([paren_string paren_string]\n             [count 0])\n\
    \    (cond\n      [(empty? paren_string)\n       (list count)]\n      [(equal?\
    \ (char (first paren_string)) '())\n       (loop (rest paren_string)\n       \
    \      (add1 count))\n       (loop (rest paren_string)\n             (add1 count))]\n\
    \      [(equal? (char (first paren_string)) '()())\n       (loop (rest paren_string)\n\
    \             (add1 count))\n       (loop (rest paren_string)\n             (add1\
    \ count))]\n      [else\n       (loop (rest paren_string)\n             (add1\
    \ count))])))\n", "  (let ((group_count 0))\n    (loop\n       [(paren_char #\\\
    ())\n        (group_count 0)]\n       [else\n        ;; If the current parentheses\
    \ level is equal to the previous level,\n        ;; then output the current level\
    \ of nesting\n        (if (equal? (string-ref paren_string 0) paren_char)\n  \
    \          group_count\n            (loop\n               [(+ (string-ref paren_string\
    \ 0) 1)\n                (if (string-ref-noncons paren_string) (set! group_count\
    \ group_count) group_count)\n                (incf group_count)\n            \
    \    (incf group_count)\n                (if (equal? (string-ref paren_string\
    \ 0) #\\))\n                    (return (list group_count))\n                \
    \    (loop\n                       [(if (string-ref-noncons paren_string) (set!\
    \ group_count group_count) group_count)\n                        (if (equal? (string-ref\
    \ paren_string 0) #\\))\n                            (return (list group_count))\n\
    \                            (loop\n                               [(if (string-ref-noncons\
    \ paren_string) (set! group_count group_count) group_count)\n                \
    \                (if (equal? (string-ref paren_string 0) #\\))\n             \
    \                       (return (list group_count))\n                        \
    \            (incf group_count)\n                                    (incf group_count)\n\
    \                                    (incf group_count)\n                    \
    \                (incf group_count)\n                                    (return\
    \ (list group_count))\n                                    (incf group_count)\n\
    \                                    (incf group_count)\n                    \
    \                (incf group_count)\n                                    (incf\
    \ group_count)\n                                    (incf group_count)\n     \
    \                               (incf group_count)\n                         \
    \           (incf group_count)\n                                    (incf group_count)\n\
    \                                    (incf group_count)\n                    \
    \                (incf group_count)\n                                    (incf\
    \ group_count)\n                                    (incf group_count)\n     \
    \                               (incf group_count)\n                         \
    \           (incf group_count)\n                                    (incf group_count)\n\
    \                                    (incf group_count)\n                    \
    \                (incf group_count)\n                                    (incf\
    \ group_count)\n                                    (incf group_count)\n     \
    \                               (incf group_count)\n                         \
    \           (incf group_count)\n                                    (incf group_count)\n\
    \                                    (incf group_count)\n                    \
    \                (incf group_count)\n                                    (incf\
    \ group_count)\n                                    (incf group_count)\n     \
    \                               (incf group_count)\n                         \
    \           (incf group_count)\n                                    (incf group_count)\n\
    \                                    (incf group_count)\n                    \
    \                (incf group_count)\n                                    (incf\
    \ group_count)\n                                    (incf group_count)\n     \
    \                               (incf group_count)\n", "  (cond [(empty? paren_string)\
    \ empty]\n        [(list? (rest paren_string))\n         (cons (parse (first paren_string))\
    \ (parse_nested_parens (rest paren_string)))]\n        [else\n         (parse\
    \ (first paren_string))]))\n</cell>\n<cell>\n#lang racket\n", "  (let ((levels\
    \ ()))\n    (let loop ((i 0))\n      (cond\n        ((null? paren_string)\n  \
    \       (reverse levels))\n        ((string=? (char paren_string i) '())\n   \
    \      (loop (+ i 1)))\n        (else\n         (loop (+ i 1)))))\n    (loop (length\
    \ paren_string)))\n</code>\n<|/ a tags=scheme,racket |>\n<| c |>\nThis works well\
    \ when there are two nested parentheses, but it fails when there are three, four,\
    \ etc. It should also give the proper answer for `(()) ()`, but instead it gives\
    \ 0. I added an answer with my attempt at fixing the problem.\n<|/ c |>\n<| a\
    \ tags=scheme,racket |>\nUsing Racket's built in parser:\n<code>", "  (let loop\
    \ ((nesting 1)\n             (paren_list '())\n             (paren_string paren_string)\n\
    \             (paren_str '()))\n    (if (equal? paren_string \"\")\n        (list->string\
    \ paren_str)\n        (let ((char (string->char paren_string)))\n          (cond\n\
    \            ((equal? char '())\n             (loop (+ nesting 1)\n          \
    \         (cons paren_str paren_list)\n                   (string->string paren_string)))\n\
    \            ((char->integer? char)\n             (loop (+ nesting 1)\n      \
    \             (cons paren_str paren_list)\n                   (string->string\
    \ paren_string)\n                   (append paren_str (list char))))\n       \
    \     (else\n             (loop (+ nesting 1)\n                   (cons paren_str\
    \ paren_list)\n                   (string->string paren_string)\n            \
    \       (append paren_str (list char)))))))\n", "  (let loop ((i 0) (depth 0))\n\
    \    (if (<= i (string-length paren_string))\n        (loop (add1 i) (add1 depth))\n\
    \        (list depth))))\n", "  (let ((parens (map (lambda (x)\n             \
    \          (let ((end (position x paren_string)))\n                         (if\
    \ (< end 0)\n                             #f\n                             (if\
    \ (eq? (substring paren_string 0 end) x)\n                                 (substring\
    \ paren_string 0 end)\n                                 (+ 1 (substring paren_string\
    \ 0 end)))))\n                       (substring paren_string 0 end)))))\n    (cond\n\
    \      [(empty? parens) 0]\n      [else (max 0 (map max parens))]))", "  (let\
    \ loop ((parens '()))\n    (cond\n      [(null? paren_string) parens]\n      [(string=?\
    \ (car paren_string) '()) '()]\n      [(string=? (car paren_string) '(())) loop\
    \ (append (loop (cdr paren_string)) (cons 1 parens))]\n      [(string=? (car paren_string)\
    \ '((())) loop (append (loop (cdr paren_string)) (cons 2 parens))]\n      [(string=?\
    \ (car paren_string) '(()())) loop (append (loop (cdr paren_string)) (cons 3 parens))]\n\
    \      [else (loop (cdr paren_string))]))))\n", "  (let loop ((parens 0) (level\
    \ 0))\n    (cond [(empty? paren_string)\n           level]\n          [(equal?\
    \ (first paren_string) '())\n           (loop (rest paren_string) (add1 level))]\n\
    \          [(equal? (first paren_string) '())\n           (loop (rest paren_string)\
    \ (add1 level))]\n          [else\n           (loop (rest paren_string) (add1\
    \ level) (list (first paren_string))))]))\n</code>\n<|/ a |>\n<| c |>\nThe code\
    \ does not work.  It returns 2 instead of 3 in the case of \"((()) ((())))\".\n\
    <|/ c |>\n<| c |>\nThis code was tested in DrRacket, which is an interactive environment\
    \ that allows the evaluation of expressions. It doesn't actually do anything by\
    \ itself. When testing it I used the exact string you mentioned in your post,\
    \ which returns 3 (as expected). Perhaps there was a typo in the string you were\
    \ using? Either way, the output (as I expected) is a list with the maximum level\
    \ of nested parens in each of the input strings. You should be able to convert\
    \ this list to a number.\n<|/ c |>\n<| c |>\nYou are right, I messed up with the\
    \ string I was using.  Your code does work!  I appreciate the help.\n<|/ c |>\n\
    <| a tags=racket,scheme |>\nThis looks like a homework question, so I don't want\
    \ to do all the work for you.  But here are some hints:\n\nA common data structure\
    \ used in lisp is pair.  That is a cons cell that contains the two parts of the\
    \ pair.\nYou need to keep track of the number of open parens.\nYou need to keep\
    \ track of the number of closed parens.\n<|/ a dscore=2 |>\n<| c |>\nI'm not asking\
    \ you to do the work for me.  I'm just looking for some guidance in what direction\
    \ to go in.\n<|/ c |>\n<| c |>\nI'm just saying you should use the data structure\
    \ I recommended.  Try solving the problem yourself, and then you can ask specific\
    \ questions when you get stuck.\n<|/ c |>\n<| a tags=racket,scheme dscore=1 |>\n\
    Okay, here is my attempt:\n<code>\n#lang racket\n", "  (let loop ((depth 0)\n\
    \             (groups ())\n             (group_list ()))\n    (if (= depth 0)\n\
    \        (reverse group_list)\n        (let ((inner_list (list (loop (- depth\
    \ 1) (append groups ())\n                                      (append group_list\
    \ group_numbers)))))\n          (loop (- depth 1) inner_list inner_list))))\n\
    \  (loop (length paren_string)\n         '() '()))\n", "  (cond [(empty? paren_string)\
    \ empty]\n        [(equal? (car paren_string) '())\n         (cons (car paren_string)\
    \ (parse_nested_parens (cdr paren_string)))]\n        [(equal? (car paren_string)\
    \ '(()))\n         (list (car paren_string) (parse_nested_parens (cdr paren_string)))]\n\
    \        [else\n         (if (equal? (car paren_string) '((()))')\n          \
    \   (list (car paren_string) (parse_nested_parens (cdr paren_string)))\n     \
    \        (if (equal? (car paren_string) '((()) ')\n                 (list (car\
    \ paren_string) (parse_nested_parens (cdr paren_string)))\n                 (if\
    \ (equal? (car paren_string) '(()()')\n                     (list (car paren_string)\
    \ (parse_nested_parens (cdr paren_string)))\n                     (if (equal?\
    \ (car paren_string) '(())')\n                         (list (car paren_string)\
    \ (parse_nested_parens (cdr paren_string)))\n                         (if (equal?\
    \ (car paren_string) '()')\n                             (list 3 (parse_nested_parens\
    \ (cdr paren_string)))\n                             (if (equal? (car paren_string)\
    \ '())')\n                                 (list 2 (parse_nested_parens (cdr paren_string)))\n\
    \                                 (if (equal? (car paren_string) '())')\n    \
    \                                 (list 1 (parse_nested_parens (cdr paren_string)))\n\
    \                                     (if (equal? (car paren_string) '()')\n \
    \                                        (list 0 (parse_nested_parens (cdr paren_string)))\n\
    \                                         (if (equal? (car paren_string) '())')\n\
    \                                             (list nil empty)\n             \
    \                                (if (equal? (car paren_string) '(()))')\n   \
    \                                              (list 2 (parse_nested_parens (cdr\
    \ paren_string)))\n                                                 (if (equal?\
    \ (car paren_string) '((()) ')\n                                             \
    \        (list (car paren_string) (parse_nested_parens (cdr paren_string)))\n\
    \                                                     (if (equal? (car paren_string)\
    \ '((()) ')\n                                                         (list (car\
    \ paren_string) (parse_nested_parens (cdr paren_string)))\n                  \
    \                                       (if (equal? (car paren_string) '((())\
    \ ')\n                                                             (list (car\
    \ paren_string) (parse_nested_parens (cdr paren_string)))\n                  \
    \                                           (if (equal? (car paren_string) '((())\
    \ ')\n                                                                 (list (car\
    \ paren_string) (parse_nested_parens (cdr paren_string)))\n                  \
    \                                               (if (equal? (car paren_string",
  "  (define level (length paren_string))\n  (define in_parens (substring paren_string\
    \ 0 (- level 1)))\n  (define depth (string-length in_parens))\n  (define max_level\
    \ (cond ((= level 0) 0)\n                        ((< depth 0) 1)\n           \
    \             (else (+ 1 (string-length (substring paren_string 1 (- level 1)))))))\n\
    \  (define final_depth (substring paren_string 0 max_level))\n  (cond\n    ((string=?\
    \ in_parens \"()\")\n     (list-ref '() final_depth))\n    ((string=? in_parens\
    \ \"[]\")\n     (list-ref '(()) final_depth))\n    ((string=? in_parens \"{}\"\
    )\n     (list-ref '(()()) final_depth))\n    ((string=? in_parens \"()()\")\n\
    \     (cons 0 (list-ref '(() () () ()) final_depth)))\n    ((string=? in_parens\
    \ \"()[]\")\n     (cons 0 (list-ref '((() () ()) ()) final_depth)))\n    ((string=?\
    \ in_parens \"[][]\")\n     (cons 0 (list-ref '((() () () ()) ()) final_depth)))\n\
    \    ((string=? in_parens \"{}{}\")\n     (cons 0 (list-ref '((() () () ()) (())\
    \ ()) final_depth)))\n    ((string=? in_parens \"{}()\")\n     (cons 0 (list-ref\
    \ '((() () () ()) (()) ()) final_depth)))\n    ((string=? in_parens \"{{}}\")\n\
    \     (cons 0 (list-ref '((() () () ()) (())) final_depth)))\n    ((string=? in_parens\
    \ \"{}{}()\")\n     (cons 0 (list-ref '((() () () ()) (()) ()) final_depth)))\n\
    \    ((string=? in_parens \"{}(){}\")\n     (cons 0 (list-ref '((() () () ())\
    \ (()) ()) final_depth)))\n    ((string=? in_parens \"{}{}[]\")\n     (cons 0\
    \ (list-ref '((() () () ()) (() () ())) final_depth)))\n    ((string=? in_parens\
    \ \"{}[]{}\")\n     (cons 0 (list-ref '((() () () ()) (() () ())) final_depth)))\n\
    \    ((string=? in_parens \"{}[][]\")\n     (cons 0 (list-ref '((() () () ())\
    \ (() () ())) final_depth)))\n    ((string=? in_parens \"[]{}{}\")\n", "  (let*\
    \ ((remaining (remove-if (string=? \")\" (string! paren_string)) paren_string))\n\
    \    (if (empty? remaining)\n        (list* 0 0)\n        (let* ((result (parse_nested_parens\
    \ remaining))\n               (nest (min (second result) (second (first result))))\n\
    \               (remaining (first result)))\n          (cons (first result) (cons\
    \ nest remaining))))))\n", "  (let ((group-count (length paren_string)))\n   \
    \ (let ((groups (make-array group-count (list null))))\n      (let loop ((i group-count)\n\
    \                 (j (sub1 i)))\n        (if (null? j)\n            groups\n \
    \           (let ((current (get-char))\n                  (new-count (if (char=?\
    \ current '( (lsp-check))))\n                  (new-level (+ (if (char=? current\
    \ ')) new-count 1))\n                  (new-group (list-ref groups j))\n     \
    \             (new-element (if (char=? current ')) (new-group) null))\n      \
    \        (set! groups (make-array (+ new-count 1) (list new-element))))\n    \
    \        (loop (sub1 j) (add1 j))))\n      (apply append\n             (map cadr\n\
    \                  (apply append\n                         (map caddr groups))))))))\n",
  "  (check-type paren_string string)\n  (let loop ((paren_string paren_string)\n\
    \             (max_levels 0))\n    (cond [(null? paren_string) '()]\n        \
    \  [(equal? (first paren_string) '(())) (loop \n                             \
    \               (rest paren_string)\n                                        \
    \    (+ max_levels 1))]\n          [else (loop (rest paren_string)\n         \
    \             (+ max_levels 1))]))))\n", "  (let ((max_level_of_nesting 0))\n\
    \    (loop for group_number in (split-string (read-string paren_string) \" \"\
    ) until\n          (or (= 0 (string-length group_number)) (= '() group_number))\n\
    \      do (set! max_level_of_nesting (max (string-length group_number) (add1 max_level_of_nesting)))\n\
    \      finally (return (if (= max_level_of_nesting 0) 1 max_level_of_nesting))))\n",
  "  (cond [(empty? paren_string)\n         0]\n        [else\n         (let ([group\
    \ (tokenize paren_string)\n                   (max-level (apply max (map (lambda\
    \ (g) count g) group)))\n                   #:i 0])\n           (if (> max-level\
    \ i)\n               ;; This group has more parentheses than we have.\n      \
    \         (append (list (cond [(empty? group) i]\n                           \
    \      [(tokenize (first group) i) 1]\n                                 [(tokenize\
    \ (first group) i) (inc (first group) 1)]))\n               (if (empty? (rest\
    \ group))\n                   ;; We are at the last level and we found the deepest\
    \ parentheses.\n                   (list i)\n                   ;; We have found\
    \ new parentheses, increase the level of nesting.\n                   (let ([group\
    \ (next group)\n                             (next-group (tokenize (rest group)\
    \ i 1))])\n                     (if (empty? (rest group))\n                  \
    \       ;; This is the last level of parentheses.\n                         (list\
    \ i)\n                         ;; We have found new parentheses, increase the\
    \ level of nesting.\n                         (let ([group (next group)\n    \
    \                               (next-group (tokenize (rest group) i 1))])\n \
    \                          (if (empty? (rest group))\n                       \
    \        ;; This is the last level of parentheses.\n                         \
    \      (append (list (cond [(empty? group) i]\n                              \
    \                   [(tokenize (first group) i) 1]\n                         \
    \                        [(tokenize (first group) i) (inc (first group) 1)]))\n\
    \                               ;; We have found new parentheses, increase the\
    \ level of nesting.\n                               (let ([group (next group)\n\
    \                                         (next-group (tokenize (rest group) i\
    \ 1))])\n                                 (if (empty? (rest group))\n        \
    \                             ;; This is the last level of parentheses.\n    \
    \                                 (append (list (cond [(empty? group) i]\n   \
    \                                                    [(tokenize (first group)\
    \ i) 1]\n                                                       [(tokenize (first\
    \ group) i) (inc (first group) 1)]))\n                                     ;;\
    \ We have found new parentheses, increase the level of nesting.\n            \
    \                         (let ([group (next group)\n                        \
    \                       (next-group (tokenize (rest group) i 1))])\n         \
    \                              (if (empty? (rest group))\n                   \
    \                        ;; This is the last level of parentheses.\n         \
    \                                  (append (list (cond [(empty? group) i]\n  \
    \                                                           [(tokenize (first\
    \ group) i) 1]\n                                                             [(tokenize\
    \ (first group) i) (inc (first ", "  (cond\n    [(empty? paren_string) empty]\n\
    \    [(equal? (peek paren_string) '(') (parse (parse_nested_parens (rest paren_string))\
    \ '(())))]\n    [else (parse (parse_nested_parens (rest paren_string)) '())]))\n",
  "  (define (make-node group count)\n    (cons count (if (equal? count 0)\n     \
    \               (list group)\n                    (cons (make-node group (sub1\
    \ count)) (make-node group 0)))))\n  (let loop ([count 0])\n    (cond [(null?\
    \ paren_string) (list count)]\n          [(equal? (car paren_string) '()) count]\n\
    \          [else (loop (sub1 (parse-integer paren_string)))]))\n  (loop 0))\n",
  "  (let ((stack_size 0))\n    (cond ((null? paren_string) #f)\n          ((string-match\
    \ \"()\" paren_string)\n           (let ((num_open_brackets (string-count \"(\"\
    \ paren_string)))\n             (set! stack_size (+ stack_size num_open_brackets))\n\
    \             num_open_brackets))\n          ((string-match \"()()\" paren_string)\n\
    \           (let ((num_open_brackets (string-count \"(\" paren_string)))\n   \
    \          (set! stack_size (+ stack_size num_open_brackets))\n             num_open_brackets))\n\
    \          (else\n           (let ((num_open_brackets (string-count \"(\" paren_string)))\n\
    \             (set! stack_size (+ stack_size num_open_brackets))\n           \
    \  num_open_brackets))))\n  (if (> stack_size 0)\n      (parse_infix_with_stack\
    \ (cdr paren_string) stack_size)\n      #f))\n</cell>\n<cell>", "  (cond [(null?\
    \ paren_string)\n         '()]\n        [(equal? (car paren_string) '(')\n   \
    \      (append (parse_nested_parens (cdr paren_string))\n                 (list\
    \ (length paren_string)))]\n        [(equal? (car paren_string) ')')\n       \
    \  (append (parse_nested_parens (cdr paren_string))\n                 (list (length\
    \ paren_string)))]\n        [else\n         (append (parse_nested_parens (cdr\
    \ paren_string))\n                 (list (length paren_string)))]))\n", "  (define\
    \ (nested-parens-helper paren_string)\n    (cond\n      [(empty? paren_string)\
    \ 0]\n      [(equal? (first paren_string) '()) (+ 1 (nested-parens-helper (rest\
    \ paren_string)))]\n      [(equal? (first paren_string) '((())) (+ 1 (nested-parens-helper\
    \ (rest paren_string)))]\n      [(equal? (first paren_string) '((())) (+ 1 (nested-parens-helper\
    \ (rest paren_string)))]\n      [(equal? (first paren_string) '(((()))) (+ 1 (nested-parens-helper\
    \ (rest paren_string)))]\n      [(equal? (first paren_string) '(()())) (+ 1 (nested-parens-helper\
    \ (rest paren_string)))]\n      [(equal? (first paren_string) '(())()) (+ 1 (nested-parens-helper\
    \ (rest paren_string)))]\n      [(equal? (first paren_string) '()()()) (+ 1 (nested-parens-helper\
    \ (rest paren_string)))]\n      [(equal? (first paren_string) '()()())]\n    \
    \  [(equal? (first paren_string) '()(())]\n      [(equal? (first paren_string)\
    \ '()())]\n      [(equal? (first paren_string) '())())]\n      [(equal? (first\
    \ paren_string) '(())]\n      [(equal? (first paren_string) '(())]\n      [(equal?\
    \ (first paren_string) '())()]\n      [(equal? (first paren_string) '())()]\n\
    \      [(equal? (first paren_string) '()))())]\n      [(equal? (first paren_string)\
    \ '(()())]\n      [(equal? (first paren_string) '(())()]\n      [(equal? (first\
    \ paren_string) '()())()]\n      [(equal? (first paren_string) '()())()]\n   \
    \   [(equal? (first paren_string) '())()()]\n      [(equal? (first paren_string)\
    \ '()())()]])\n  )\n  (nested-parens-helper paren_string))\n", "  (let loop ([paren_string\
    \ paren_string]\n             [paren_level 1]\n             [result '()])\n  \
    \  (if (empty? paren_string)\n        result\n        (loop (substring paren_string\
    \ 0 (match (first paren_string) '(())))\n              (+ paren_level 1)\n   \
    \           (cons (substring paren_string 0 (match (first paren_string) '(()))\
    \ (loop (substring paren_string 1 (match (first paren_string) '(())))\n      \
    \                                                               (+ paren_level\
    \ 1)\n                                                                     (cons\
    \ 1 (loop (substring paren_string 2 (match (first paren_string) '(()))))))))))\n\
    \  result))\n", "  (let* ([position (find_opening_parentheses paren_string)] )\n\
    \    (if (empty? position)\n        -1\n        (let [end_position (next_open_paren\
    \ position)]\n          (if (empty? end_position)\n              -1\n        \
    \      (+ (get_nth_value end_position position) 1)))\n    )\n  )\n)\n", "  (if\
    \ (empty? paren_string)\n      '()\n      (parse\n       (cons (length (rest paren_string))\
    \ (parse_nested_parens (rest paren_string)))\n       (string-split (first paren_string)\
    \ #\\ (string-length paren_string))))))\n", "  (let loop ((level_count 0) (level_list\
    \ '()))\n    (cond [(null? paren_string) level_list]\n          [(equal? (car\
    \ paren_string) '()) level_list]\n          [(equal? (car paren_string) ')) level_list]\n\
    \          [(equal? (car paren_string) '(') (loop (+ level_count 1) (cdr paren_string))]\n\
    \          [(equal? (car paren_string) '(') (loop (+ level_count 1) (cons level_count\
    \ level_list))]\n          [(equal? (car paren_string) ')') (loop (- level_count\
    \ 1) level_list)]\n          [(equal? (car paren_string) '(') (loop (+ level_count\
    \ 1) (cons level_count (loop (+ level_count 1) level_list)))]\n          [else\
    \ (loop (+ level_count 1) (cons level_count (loop (+ level_count 1) (loop (+ level_count\
    \ 1) level_list))))]))))\n", "  (parse-nested-parens '() paren_string))\n", " \
    \ (let ([level-string (substring paren_string 0 (string-length paren_string)))\n\
    \        (levels (parse-levels level_string))]\n    (make-list levels #f (length\
    \ level_string))))\n", "  (if (null? paren_string)\n      '()\n      (parse-nested-parens\
    \ (rest paren_string))))\n", "  (cond\n    [(empty? paren_string) empty]\n   \
    \ [(list? (first paren_string))\n     (append (parse_nested_parens (rest paren_string))\n\
    \             (list (length paren_string))\n             (parse_nested_parens\
    \ (rest paren_string)))]\n    [(cons (= (first paren_string) '())\n          (parse_nested_parens\
    \ (rest paren_string)))]\n    [else\n     (error \"Invalid input: Not a valid\
    \ list of parentheses!\" paren_string)]\n   ))\n", "  (cond ((equal? paren_string\
    \ (empty-str))\n         empty-str)\n        ((equal? (car paren_string) '())\n\
    \         (cons 1 (parse_nested_parens (cdr paren_string))))\n        (else\n\
    \         (parse_nested_parens (cdr paren_string)))))\n", "  (let loop ((paren_string\
    \ paren_string)\n             (level 0))\n    (if (string? paren_string)\n   \
    \     (if (= 0 (string-length paren_string))\n            (list level)\n     \
    \       (let ((groups (split-by-space paren_string)))\n              (if (null?\
    \ groups)\n                  (list level)\n                  (loop (cdr groups)\
    \ (add1 (car groups))))))\n      (error \"unbalanced parens: ~s\" paren_string))))\n",
  "  (cond ((null? paren_string)\n         (list 0))\n        (else (append (parse_nested_parens\
    \ (rest paren_string)) (parse_int (car paren_string))))))\n", "  (cond\n    [(empty?\
    \ paren_string)\n     (list 0)]\n    [(equal? (car paren_string) '( () ))\n  \
    \   (parse_deepest_level (cdr paren_string) 0)]\n    [else\n     (parse_deepest_level\
    \ (car paren_string) (+ 1 (parse_deepest_level (cdr paren_string) 0)))]))\n",
  "  (let loop ((paren_string paren_string) (parens_count 0))\n    (if (string-empty?\
    \ paren_string)\n      (list parens_count)\n      (let ((group_string (car paren_string)))\n\
    \        (cond [(string=? group_string \"'\") (loop (cdr paren_string) (incf parens_count))]\n\
    \              [(string=? group_string \"''\") (loop (cdr paren_string) (incf\
    \ parens_count))]\n              [(string=? group_string \"((\") (loop (cdr paren_string)\
    \ (incf parens_count))]\n              [(string=? group_string \"(())\") (loop\
    \ (cdr paren_string) (incf parens_count))]\n              [(string=? group_string\
    \ \")(\") (loop (cdr paren_string) (incf parens_count))]\n              [(string=?\
    \ group_string \")()\") (loop (cdr paren_string) (incf parens_count))]\n     \
    \         [else (loop (cdr paren_string) (incf parens_count))])\n      )\n   \
    \ )\n  )\n)\n</code>\n<|/ a |>\n<| a |>\nThe answer is that your method is not\
    \ working for the case of nested parentheses, e.g. ((()()))). You can use the\
    \ following function instead:\n<code>", "  (let ((result (empty-list)))\n    (define\
    \ (parse (s str)\n              (if (empty? s)\n                  (if (equal?\
    \ (car s) '())\n                      (cons 1 result)\n                      (cons\
    \ 0 result))\n                  (parse\n                      (substring s 0 (-\
    \ (length s) 1))\n                      (substring s (cdr s) str))))\n    (parse\
    \ paren_string \"\")\n    result))\n", "  (cond [(= paren_string \"\") '()]\n\
    \        [(look-ahead (not (or (char=? (peek-char 0) #\\))) (peek-char 0)) '()]\n\
    \        [else (let ([num_parens (parse-number\n                             \
    \  (look-behind paren_string (peek-char 1))\n                               )\n\
    \                   max_depth (- num_parens 1)\n                   level (min\
    \ max_depth num_parens)]\n              (if (= level 0)\n                  (cons\
    \ num_parens (parse_nested_parens (substring paren_string 0 num_parens)))\n  \
    \                (cons level parse-number\n                        (parse_nested_parens\
    \ (substring paren_string 0 num_parens)))))]))\n", "  (let ((curlevel (let ()\
    \ (count)))))\n    (match paren_string\n      (#\\( #\\) )\n      (list curlevel)\n\
    \      (#\\( #\\( #\\( #\\( #\\( #\\( #\\( #\\( #\\( #\\( #\\( #\\( #\\( #\\(\
    \ #\\( #\\) ) #\\) ) #\\) ) #\\) ) #\\) ) #\\)\n      (let ((nestedoption (parse-nesting\
    \ paren_string)))\n        (list curlevel nestedoption))\n      (#\\( #\\( #\\\
    ( #\\( #\\( #\\( #\\( #\\( #\\( #\\( #\\( #\\( #\\( #\\( #\\( #\\) ) #\\) ) #\\\
    ) ) #\\) ) #\\) ) #\\)\n      (let ((nestedoption (parse-nesting paren_string)))\n\
    \        (list curlevel nestedoption))\n      (#\\( #\\( #\\( #\\( #\\( #\\( #\\\
    ( #\\( #\\( #\\( #\\( #\\( #\\( #\\( #\\( #\\) ) #\\) ) #\\) ) #\\) ) #\\) ) #\\\
    )\n      (let ((nestedoption (parse-nesting paren_string)))\n        (list curlevel\
    \ nestedoption))\n      (#\\( #\\( #\\( #\\( #\\( #\\( #\\( #\\( #\\( #\\( #\\\
    ( #\\( #\\( #\\) ) #\\) ) #\\) ) #\\) ) #\\) ) #\\)\n      (let ((nestedoption\
    \ (parse-nesting paren_string)))\n        (list curlevel nestedoption))\n    \
    \  (#\\( #\\( #\\( #\\( #\\( #\\( #\\( #\\( #\\( #\\( #\\( #\\( #) ) #\\) ) #\\\
    ) ) #\\) ) #\\) ) #\\)\n      (let ((nestedoption (parse-nesting paren_string)))\n\
    \        (list curlevel nestedoption))\n      (#\\( #\\( #\\( #\\( #\\( #\\( #\\\
    ( #\\( #\\( #\\( #\\( #\\( #\\( #) ) #\\", "  (let loop ((levels ()) (group ())\
    \ (cuml 0)\n             (parens '(())) (in_parens false) (out_parens false))\n\
    \    (if (empty? paren_string)\n        (if (not (empty? levels))\n          \
    \  (cons '() levels)\n            (cons 0 (cons '() levels)))\n        (if (not\
    \ (empty? levels))\n            (if (not (empty? group))\n                (loop\
    \ (cons 0 (cons '() group)) () 0 cuml false false)\n                (if (not (empty?\
    \ group))\n                    (loop (cons 0 (cons '() group)) () 0 cuml false\
    \ false)\n                    (if (not (empty? group))\n                     \
    \   (loop (cons 0 (cons '() group)) () 0 cuml false false)\n                 \
    \       (if (not (empty? group))\n                            (loop (cons 0 (cons\
    \ '() group)) () 0 cuml false false)\n                            (if (not (empty?\
    \ group))\n                                (loop (cons 0 (cons '() group)) ()\
    \ 0 cuml false false)\n                                (if (not (empty? group))\n\
    \                                    (loop (cons 0 (cons '() group)) () 0 cuml\
    \ false false)\n                                    (if (not (empty? group))\n\
    \                                        (loop (cons 0 (cons '() group)) () 0\
    \ cuml false false)\n                                        (if (not (empty?\
    \ group))\n                                            (loop (cons 0 (cons '()\
    \ group)) () 0 cuml false false)\n                                           \
    \ (if (not (empty? group))\n                                                (loop\
    \ (cons 0 (cons '() group)) () 0 cuml false false)\n                         \
    \                       (if (not (empty? group))\n                           \
    \                         (loop (cons 0 (cons '() group)) () 0 cuml false false)\n\
    \                                                    (if (not (empty? group))\n\
    \                                                        (loop (cons 0 (cons '()\
    \ group)) () 0 cuml false false)\n                                           \
    \             (if (not (empty? group))\n                                     \
    \                       (loop (cons 0 (cons '() group)) () 0 cuml false false)\n\
    \                                                            (if (not (empty?\
    \ group))\n                                                                (loop\
    \ (cons 0 (cons '() group)) () 0 cuml false false)\n                         \
    \                                       (if (not (empty? group))\n           \
    \                                                         (loop (cons 0 (cons\
    \ '() group)) () 0 cuml false false)\n                                       \
    \                             (if (not (empty? group))\n                     \
    \                                                   (loop (cons 0 (cons '", " \
    \ (check-type paren_string string\n               (string-match (string->regexp\
    \ \"^\\\\([^()]*\\\\)\") paren_string))\n  (let ((count 0))\n    (map (lambda\
    \ (elem)\n           (if (string=? elem '())\n               (incf count)\n  \
    \             (if (string=? (string-ref elem 0) '(()))\n                   (inc\
    \ count)\n                   (decf count))))\n        (string->list paren_string))\n\
    \    (max 0 count)))\n", "  (define levels (make-hash))\n  (define stack (make-array\
    \ (hash-size levels) '(unordered-pair '() '()))\n  (for [[group_num group_str]\
    \ in-string\n         :min-length (string-length group_str)\n         :max-length\
    \ (string-length group_str)]\n    (hash-set! levels group_num (string-length group_str))\n\
    \    (hash-set! stack (string-to-unordered-pair (subseq group_str 0 (string-length\
    \ group_str))) group_num)\n    (hash-set! stack (string-to-unordered-pair (subseq\
    \ group_str (string-length group_str)) group_num) (list->array stack))\n  (map\
    \ top-level-nesting-level levels))\n", "  (let loop ((nests null) (cur_str paren_string))\n\
    \    (if (char= cur_str '())\n      (if (null? nests)\n        (list 1)\n    \
    \    (let ((nest_level (car nests)))\n          (if (> (car nests) nest_level)\n\
    \            (loop (cdr nests) (cdr cur_str))\n            (loop (cons nest_level\
    \ nests) (cdr cur_str)))\n          nests))\n      (loop (append (cons cur_str\
    \ '())\n                 (cdr nests))\n           (cdr cur_str))))))\n", "  (cond\n\
    \    [(empty? paren_string) (quote ())]\n    [(member (car paren_string) '(()()))\
    \ [\n            (cond\n             [(= (length (cdr (rest paren_string))) 0)\
    \ (quote (quote ()))]\n             [(= (length (cdr (rest paren_string))) 1)\
    \ (quote (quote ())))]\n             [else (quote (quote ((quote ,(car paren_string)))))]\n\
    \             )\n            ]\n    ]\n    [else (parse_nested_parens (append\
    \ (list (car paren_string))\n                                    (parse_nested_parens\
    \ (cdr paren_string))))]\n    ))\n</cell>\n<text>\nExercise\nWhat is the maximum\
    \ number of levels of nesting that a list can have?\n\nGiven input string\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
