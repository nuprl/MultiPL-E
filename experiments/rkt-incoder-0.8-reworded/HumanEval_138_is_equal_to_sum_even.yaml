name: HumanEval_138_is_equal_to_sum_even
language: rkt
prompt: "#lang racket\n\n;; Evaluate whether the given number n can be written as\
  \ the sum of exactly 4 positive even numbers\n;; Example\n;; >>> (is_equal_to_sum_even\
  \ 4)\n;; #f\n;; >>> (is_equal_to_sum_even 6)\n;; #f\n;; >>> (is_equal_to_sum_even\
  \ 8)\n;; #t\n(define (is_equal_to_sum_even n)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate is_equal_to_sum_even))\n\
  \    (check-equal? (candidate 4) #f)\n    (check-equal? (candidate 6) #f)\n    (check-equal?\
  \ (candidate 8) #t)\n    (check-equal? (candidate 10) #t)\n    (check-equal? (candidate\
  \ 11) #f)\n    (check-equal? (candidate 12) #t)\n    (check-equal? (candidate 13)\
  \ #f)\n    (check-equal? (candidate 16) #t)\n))\n\n(test-humaneval)"
completions: ["  (cond\n    [(= n 0) #f]\n    [(= n 1) #t]\n    [(= n 2) #t]\n   \
    \ [(= (modulo n 2) 0) #f]\n    [else (= (modulo n 2) (modulo (+ n 1) 2))]))\n",
  "  (cond [(= n 0) #f]\n        [(even? (- n 2)) #t]\n        [else #f]))\n", " \
    \ (= (modulo-by-four (modulo n 4) (modulo n 4)) 0))\n", "  (= (remainder (quotient\
    \ n 4) 4) 2))\n", "  (cond [(= n 0) #f]\n        [(even? n) (= (- n 2) 0)]\n \
    \       [else (= (- n 4) 0)]))\n", "  (cond\n    [(= n 0) #f]\n    [(even? n)\
    \ #f]\n    [else (= (+ n (/ 2 (add1 n))))]))\n", "  (= (modulo (+ n 4) 4) 4))\n",
  "  (< (+ n 4) 4))\n", "  (= (mod n 2)\n     (even? (remainder n 2) (/ n 2))))\n",
  "  (cond [(= n 4) true]\n        [(even? (modulo n 2)) true]\n        [else false]))\n",
  "  (<= 0 n 20))\n  ", "  (= (/ n 4) 2))\n", "  (let ([sum (+ (modulo n 4) (modulo\
    \ n 3))])\n    (= n sum)))\n", "  (= (= n 1) \n     (= (mod n 2) 0)\n     (= (mod\
    \ n 4) 0)\n     (= (mod n 8) 0)\n     (= (mod n 16) 0)\n     (= (mod n 32) 0)))\
    \ ;; eq 4 or 8\n</cell>\n<code language=dyalog-kernel>", "  (= n (+ (/ 2 n) (/\
    \ 2 n) (/ 2 n) (/ 2 n)))\n  )\n", "  (cond\n    [(= n 0) #t]\n    [else (= (modulo\
    \ (+ n (- n 4)) 2) #t)]\n  ))\n", "  (and (= n (even? (* n n)))\n       (= n (+\
    \ (* 2 n) (* 2 n))))) ;; n has to be an even number\n", "  (for/or ([i (in-range\
    \ (ceiling (/ n 4))) (< i n)]\n            [j (in-range i (in-naturals))])\n \
    \   (= (modulo n i) (modulo n j))))\n", "  (even? n (+ n 1)))\n", '  (= (- n 4)
    0))', "  (= (= (even? n) 4) (= (even? n) 6) (= (even? n) 8)))\n", "  (cond ((=\
    \ n 0) #f)\n        ((or (= n 2) (= n 4)) #t)\n        (else (and (= (modulo n\
    \ 2) 0) (= (modulo n 4) 0)) (is_equal_to_sum_even (- n 2)))))\n", '  (<= (length
    number) 4))', "  (= (exact->inexact n) (exact->exact (+ (even->exact n) (even->exact\
    \ (- n 2))))))\n", "  (cond\n    [(even? n) (equal? (remainder n 2) 0)]\n    [else\
    \ #f]))\n", "  (cond [(= n 1) #f]\n        [(even? n) (equal? (remainder n 2)\
    \ 0)]\n        [else (is_equal_to_sum_even (- n 2))]))\n", "  (cond\n    ((= n\
    \ 0) #t)\n    ((= n 1) #t)\n    ((= (modulo n 2) 0) #t)\n    ((= (modulo n 2)\
    \ 1) #f)\n    (else #f)))\n", "  (= n (even? n)))\n", "  (< (* n n) (even? (*\
    \ n 4)))\n  )\n", "  (= (mod n 4) 0)\n  (= (mod n 3) 0)\n  (= (mod n 2) 0)\n \
    \ (= (mod n 1) 0))\n", "  (= n (+ (expt 2 (- n 2)) 4)))\n", "  (= (modulo n 4)\
    \ (modulo n 6) (modulo n 8) (modulo n 10)))\n", "  (cond\n    ((= n 0) #t)\n \
    \   ((= n 1) #t)\n    ((= n 2) #t)\n    ((= (modulo n 2) 0) #f)\n    ((= (modulo\
    \ n 2) 1) #f)\n    ((= (modulo n 2) 2) #t)\n    (else (is_equal_to_sum_even (-\
    \ n 2)))))\n", "  (= (modulo (+ n (modulo (* n 2) 4)) 4) (modulo n 4)))\n", " \
    \ (zero? (modulo (- n 4) 4) n)) ;; (modulo (- n 4) 4) is a trick to get the modulo\n",
  "  (or (= (mod (+ n 2) 4) 0)\n      (= (mod (+ n 2) 2) 0)\n      (= (mod (+ n 2)\
    \ 1) 0)\n      (= (mod (+ n 2) 0) 1)))\n", "  (equal? (* n 4)\n           (remainder\
    \ (+ n 2) 4)))\n", "  (< (n) (* 4 (/ n 2) 2))\n  )\n", "  (equal? (mod n 2) 0))\n",
  "  (and (= n 2)\n       (= (modulo n 4) (= 0 n))\n       (= (modulo n 8) (= 0 n))))\n",
  "  (or (= n 4)\n      (= n 6)\n      (= n 8)))\n", "  (< (length (filter even? (partition\
    \ 2 n #:when (even? #:odd)))) 4))\n", "  (if (even? n)\n      (= (modulo (+ n\
    \ 2) 4) 0)\n      #f))\n", "  (= n (+ (* 2 (even? n)) (even? n))))\n", "  (let\
    \ ((a (list 0))\n        (b (list 0))\n        (e (list 1)))\n    (cond [(= n\
    \ 0)\n           #t]\n          [(= n 2)\n           #t]\n          [(= n (+ 2\
    \ n))\n           #f]\n          [(= 0 (remainder n 2))\n           #f]\n    \
    \      [(= 0 (remainder n 3))\n           #f]\n          [(= 0 (remainder n 4))\n\
    \           #t]\n          [(= 0 (remainder n 5))\n           #t]\n          [(=\
    \ 0 (remainder n 6))\n           #t]\n          [(= 0 (remainder n 7))\n     \
    \      #t]\n          [(= 0 (remainder n 8))\n           #t]\n          [(= 0\
    \ (remainder n 9))\n           #t]\n          [(= 0 (remainder n 10))\n      \
    \     #t]\n          [(= 0 (remainder n 11))\n           #t]\n          [(= 0\
    \ (remainder n 12))\n           #t]\n          [(= 0 (remainder n 13))\n     \
    \      #t]\n          [(= 0 (remainder n 14))\n           #t]\n          [(= 0\
    \ (remainder n 15))\n           #t]\n          [(= 0 (remainder n 16))\n     \
    \      #t]\n          [(= 0 (remainder n 17))\n           #t]\n          [(= 0\
    \ (remainder n 18))\n           #t]\n          [(= 0 (remainder n 19))\n     \
    \      #t]\n          [(= 0 (remainder n 20))\n           #t]\n          [(= 0\
    \ (remainder n 21))\n           #t]\n          [(= 0 (remainder n 22))\n     \
    \      #t]\n          [(= 0 (remainder n 23))\n           #t]\n          [(= 0\
    \ (remainder n 24))\n           #t]\n          [(= 0 (remainder n 25))\n     \
    \      #t]\n          [(= 0 (remainder n 26))\n           #t]\n          [(= 0\
    \ (remainder n 27))\n           #t]\n          [(= 0 (remainder n 28))\n     \
    \      #t]\n          [(= 0 (remainder n 29))\n           #t]\n          [(= 0\
    \ (remainder n 30))\n           #t]\n          [(= 0 (remainder n 31))\n     \
    \      #t]\n          [(= 0 (remainder n 32))\n           #t]\n          [(= 0\
    \ (remain", "  (= (mod n 4) 0))\n", "  (< (- n 4) 0))\n", "  (cond\n    [(< n\
    \ 10) #f]\n    [(= n 0) #f]\n    [(even? (remainder n 2)) #t]\n    [else #f]))\n",
  "  (<= 0 (- n 4))\n  )\n</code>\n<|/ a dscore=1 tags=racket,scheme,number-theory,function\
    \ |>\n<| a dscore=1 |>\nIn Scheme there is exactly one way to represent numbers\
    \ with infinite precision. In fact, any scheme implementation is allowed to store\
    \ infinite amounts of precision inside of a number. \nIn your example, if you\
    \ wanted to express \"a number with infinite precision\" you could do\n<code>\n\
    #lang racket\n", "  (< n (- (+ 1 4) (+ 1 4) (+ 1 4) (+ 1 4)))) ;; Equivalent to\
    \ '(= (modulo n 4) 0)'", "  (= (+ n n n n)\n     (* 4 (expt 2 (- n 2)))))\n",
  "  (cond\n    ((= n 0) #f)\n    ((= n 2) #t)\n    ((= (modulo n 4) (= 0 (modulo\
    \ n 4)))\n     (is_equal_to_sum_even (- n 4)))\n    ((= (modulo n 4) (= 4 (modulo\
    \ n 4)))\n     (is_equal_to_sum_even (- n 4)))\n    ((= (modulo n 4) (= 8 (modulo\
    \ n 4)))\n     (is_equal_to_sum_even (- n 4)))\n    ((= (modulo n 4) (= 12 (modulo\
    \ n 4)))\n     (is_equal_to_sum_even (- n 4)))\n    ((= (modulo n 4) (= 16 (modulo\
    \ n 4)))\n     (is_equal_to_sum_even (- n 4)))\n    ((= (modulo n 4) (= 20 (modulo\
    \ n 4)))\n     (is_equal_to_sum_even (- n 4)))\n    ((= (modulo n 4) (= 24 (modulo\
    \ n 4)))\n     (is_equal_to_sum_even (- n 4)))\n    ((= (modulo n 4) (= 28 (modulo\
    \ n 4)))\n     (is_equal_to_sum_even (- n 4)))\n    ((= (modulo n 4) (= 32 (modulo\
    \ n 4)))\n     (is_equal_to_sum_even (- n 4)))\n    ((= (modulo n 4) (= 36 (modulo\
    \ n 4)))\n     (is_equal_to_sum_even (- n 4)))\n    ((= (modulo n 4) (= 40 (modulo\
    \ n 4)))\n     (is_equal_to_sum_even (- n 4)))\n    ((= (modulo n 4) (= 44 (modulo\
    \ n 4)))\n     (is_equal_to_sum_even (- n 4)))\n    ((= (modulo n 4) (= 48 (modulo\
    \ n 4)))\n     (is_equal_to_sum_even (- n 4)))\n    ((= (modulo n 4) (= 52 (modulo\
    \ n 4)))\n     (is_equal_to_sum_even (- n 4)))\n    ((= (modulo n 4) (= 56 (modulo\
    \ n 4)))\n     (is_equal_to_sum_even (- n 4)))\n    ((= (modulo n 4) (= 60 (modulo\
    \ n 4)))\n     (is_equal_to_sum_even (- n 4)))\n    ((= (modulo n 4) (= 64 (modulo\
    \ n 4)))\n     (is_equal_to_sum_even (- n 4)))\n    ((= (", "  (define (helper\
    \ lst count)\n    (cond\n      [(null? lst) count]\n      [(= (car lst) n) (helper\
    \ (cdr lst) (+ count 1))]))\n  (helper lst 0))\n", "  (= (modulo-arithmetic-sum\
    \ 4 n n) 4))\n", "  (= (modulo (+ n 2) 4) (modulo (+ n 2) 4)))\n", "  (= (modulo\
    \ n 4) (modulo n 6) (modulo n 8)))\n", "  (< (+ n (mod 2 n)) 4))\n", "  (= (remainder_sum\
    \ n 4) (even? n)))\n", "  (< (- (mod n 4) (modulo n 2))\n     (modulo n 4)))\n",
  "  (equal? (n) (sum (map even? '(4 6 8 10 12))))\n  )", "  (< (+ (* 2 n) (* 2 (sub1\
    \ (+ (* 2 n) 1))))\n     (* 4 n)))\n", "  (<= n 10))\n", "  (< n 4))\n", "  (<\
    \ (abs (- n 4)) .00001))\n", "  (= (modulo n 4) (modulo (+ n 1) 4)))\n", "  (=\
    \ (even? n) (= (sum n) 4)))\n", "  (define (is_even n)\n    (= (rem n 2) 0))\n\
    \n  (let loop ((n n) (sum 0))\n    (cond ((zero? n) sum)\n          ((is_even\
    \ n) (loop (/ n 2) (+ sum n)))\n          (else (loop (+ n 2) sum))))\n  (= sum\
    \ 4))\n", "  (if (even? n)\n      (let ([a (- n 4)])\n        (= (modulo n a)\
    \ 0)\n      )\n      #f\n  ))\n", "  (cond\n    [(< n 4) #f]\n    [else #t]))\n",
  "  (= (remainder n 4) #f))\n", "  (= n (+ (rem n 2) (mod n 2)) (+ (rem n 3) (mod\
    \ n 3))\n        (+ (rem n 4) (mod n 4)))\n)\n", "  (define (is-even? n)\n   \
    \ (= (remainder n 2) 0))\n  (and (= n 0)\n       (not (is-even? (- n 1)))))\n",
  "  (< (- n 4) 4))\n</cell>\n<code language=dyalog-kernel>\n#lang racket", "  (or\
    \ (= 0 (modulo (+ n (- n 4)) 4)) (= 0 (modulo (+ n (- n 4)) 8))))\n", "  (even?\
    \ n 4 5))\n", "  (cond [(= n 0) #f]\n        [(even? (rem n 2)) true]\n      \
    \  [else #f]))\n", "  (< (* n n) (* 4 4)))\n", "  (= (+ n n) 4\n    ;; n is even\n\
    \    (or (= n 2)\n        ;; n is odd\n        (even? (- n 1)))))", "  (let loop\
    \ ((sum (- n 1))\n             (sums #:even (/ sum 4)))\n    (cond\n      [(<\
    \ sum 4) true]\n      [else (or (and (= (modulo sum 4) 0)\n                  \
    \   (and (= (modulo sums 4) 0)\n                           (= sum sums)))\n  \
    \             (loop (+ sum 2)\n                     sums))]))\n", "  (= (/ (*\
    \ n n n) (+ 4 n))\n     (* n n n)))\n", "  (= (even? n) (= (* 4 n) 4)))\n", " \
    \ (= (mod n 4) 0))\n  ", '  (= (even? n) (= 4 (modulo n 4)))) ; even numbers have
    even digits', "  (let loop ((n n)\n             (sum 0))\n    (cond\n      [(=\
    \ n 0)\n       #f]\n      [(even? n)\n       (if (= sum 4)\n           (loop (sub1\
    \ n) (+ sum 2)) ; we can't add this number to sum, because (+ n 4) gives 4\n \
    \          (loop (sub1 n) sum))]\n      [else\n       (loop (sub1 n) (+ sum 1))])))\n",
  "  (cond\n    [(= n 0) #f]\n    [(= (modulo n 2) 0) #f]\n    [(= (modulo n 4) 0)\
    \ #t]))\n", "  (equal? (remainder n 2) (even? n)))\n", "  (for/list ((i 4))\n\
    \    (= (modulo n i) 0))\n  (= (modulo n 4) 0))\n</code>\n<|/ a tags=scheme,racket\
    \ |>\n<| a |>\n<code>", "  (or (= (modulo (+ n 2) 4) (modulo (+ n 3) 4)) (= (modulo\
    \ (+ n 5) 4) (modulo (+ n 7) 4))))\n", "  (cond [(= n 0)\n         #f]\n     \
    \   [(even? (modulo n 2))\n         #f]\n        [else\n         (is_equal_to_sum_even\
    \ (sub1 n))]))\n", "  (let ((l (modulo n 4)))\n    (= (modulo n 2) l)))\n", " \
    \ (if (= (modulo n 2) 0) #t (= (modulo n 3) 0) #t (= (modulo n 4) 0)))\n", " \
    \ (cond\n    [(= n 0) #f]\n    [(= n 1) #f]\n    [(= (mod n 2) 0) #f]\n    [(=\
    \ (mod n 3) 0) #t]\n    [else (is_equal_to_sum_even (- n 2))]))\n", "  (= (modulo\
    \ (+ (* n n) (* n n)) 4) (modulo (+ n 2) 4)))\n", "  (<= n 6))\n", "  (= (- 4\
    \ n) (quotient n 4)))\n", "  (if (or (= n 0)\n          (even? (modulo n 2)))\n\
    \      #f\n      #t))\n", "  (cond\n    ((= n 0) #f)\n    ((= n 1) #f)\n    ((=\
    \ even? n) (is_equal_to_sum_even n+2))\n    ((even? n) (is_equal_to_sum_even n-2))))\n",
  "  (if (zero? n)\n      #f\n      (even? n)))\n", "  (cond\n    [(= n 0)\n     (=\
    \ n 0)]\n    [(= n 1)\n     (= n 0)]\n    [(even? n (even? (- n 2)))\n     (=\
    \ n 0)]\n    [(even? n #f)\n     #f]\n    [else\n     (cond\n       [(even? n\
    \ (odd? (- n 2)))\n        #t]\n       [(odd? n (even? (- n 2)))\n        #t]\n\
    \       [else\n        #f]\n       )])) ; End of cond\n", '  (= (= (mod n 2) 0)
    (= (mod n 4) (mod n 2) 0)))', "  (cond ((= n 0) #f)\n        ((= n 1) #t)\n  \
    \      (else (is_equal_to_sum_even (- n 2)))))\n", "  (even? n))\n", "  (<= n\
    \ 4))\n", "  (if (= (length numbers)\n         4)\n      #t\n      (equal? (sum\
    \ (map even? (map number->list numbers))) n)))\n", "  (= (even? n) (= (even? (+\
    \ 1 n)) 4)))\n", '  (equal? (modulo-by-four (+ n 1)) 0))', "  (< (expt n 2) 4))\n",
  "  (cond ((= n 0) #t)\n        ((= (even? n) false) #f)\n        (else (is_equal_to_sum_even\
    \ (- n 2)))))\n", "  (cond\n    [(= n (+ (/ n 2) (/ n 3))) (printf \"#t\")\n \
    \    (printf \"#f\")]\n    [else\n     (printf \"#f\")]))\n", "  (<= n 0))\n",
  "  (cond ((= n 2) #f) ; all positive even numbers add to 2\n        ((even? n) t)\
    \ ; negative even numbers cannot be sum of 4\n        (else #f)))\n", "  (let\
    \ ([v (modulo n 2)])\n    (and (= (modulo n 4) 0)\n         (= (modulo v 2) 0)\n\
    \         (= (modulo v 4) 0)\n         (= (modulo v 6) 0))))\n", "  (< (* (+ n\
    \ 2) 4) 6))\n", "  (cond\n    [(= n 0) #f]\n    [else (= (mod n 2) 0) #t]\n  \
    \  [else (= (mod n 2) 1) #t]\n    [else (= (mod n 2) 2) #t]\n    [else (= (mod\
    \ n 2) 3) #t]\n    [else (= (mod n 2) 4) #f]\n    [else (= (mod n 2) 5) #f]\n\
    \    [else (= (mod n 2) 6) #f]\n    [else (= (mod n 2) 7) #f]\n    [else (= (mod\
    \ n 2) 8) #f]\n    [else (= (mod n 2) 9) #f]\n    [else (= (mod n 2) 10) #f]\n\
    \    [else (= (mod n 2) 11) #f]\n    [else (= (mod n 2) 12) #f]\n    [else (=\
    \ (mod n 2) 13) #f]\n    [else (= (mod n 2) 14) #f]\n    [else (= (mod n 2) 15)\
    \ #f]\n    [else (= (mod n 2) 16) #f]\n    [else (= (mod n 2) 17) #f]\n    [else\
    \ (= (mod n 2) 18) #f]\n    [else (= (mod n 2) 19) #f]\n    [else (= (mod n 2)\
    \ 20) #f]\n    [else (= (mod n 2) 21) #f]\n    [else (= (mod n 2) 22) #f]\n  \
    \  [else (= (mod n 2) 23) #f]\n    [else (= (mod n 2) 24) #f]\n    [else (= (mod\
    \ n 2) 25) #f]\n    [else (= (mod n 2) 26) #f]\n    [else (= (mod n 2) 27) #f]\n\
    \    [else (= (mod n 2) 28) #f]\n    [else (= (mod n 2) 29) #f]\n    [else (=\
    \ (mod n 2) 30) #f]\n    [else (= (mod n 2) 31) #f]\n    [else (= (mod n 2) 32)\
    \ #f]\n    [else (= (mod n 2) 33) #f]\n    [else (= (mod n 2) 34) #f]\n    [else\
    \ (= (mod n 2) 35) #f]\n    [else (= (mod n 2) 36) #f]\n    [else (= (mod n 2)\
    \ 37) #f]\n    [else (= (mod n 2) 38) #f]\n", "  (= (modulo (+ n 1) (- n 2)) 0))\n",
  "  (< (* n n)\n      4))\n", "  (= (sum-of-four-evens n) n))\n", "  (= (- n 4) 0))\n",
  "  (cond\n    [(= n 0) #f]\n    [(= n 2) #f]\n    [(= n 4) #t]\n    [else (is_equal_to_sum_even\
    \ (- n 2))]))\n", '  (= (modulo n 4) 0))', '  (= (mod n 4) (even? n)))', "  (or\
    \ (= (modulo (* n n) 2) 0) (= (modulo (* n n) 4) 0) (= (modulo (* n n) 6) 0) (=\
    \ (modulo (* n n) 8) 0)))\n  ", "  (= (mod n 2) 0)\n  (= (mod n 4) 0)\n  (= (mod\
    \ n 6) 0)\n  (= (mod n 8) 0)\n  ;; Return true if the number can be written as\
    \ the sum of exactly 4 positive even numbers\n  ;; Example\n  ;; (is_equal_to_sum_even\
    \ 1)\n  ;; (is_equal_to_sum_even 2)\n  ;; (is_equal_to_sum_even 3)\n  ;; (is_equal_to_sum_even\
    \ 4)\n  ;; (is_equal_to_sum_even 5)\n  ;; (is_equal_to_sum_even 6)\n  ;; (is_equal_to_sum_even\
    \ 7)\n  ;; (is_equal_to_sum_even 8)\n  ;; #t\n  )\n  ", "  (= n (car evens)))\n",
  "  (<= n 4))\n", "  (zero? (remainder (+ n 1) 4)))\n", "  (cond ((= n 0) #f) \n\
    \        ((even? n) (not (= (modulo n 2) 0))\n        (else (and (is_equal_to_sum_even\
    \ (- n 2))\n                 (is_equal_to_sum_even (- n 4)))\n               \
    \ (= n 4))))\n        ", "  (= (mod n 4) 4))\n", "  (<= n 4)\n  (= (mod n 2) 0)\n\
    \  (= (mod n 3) 0)\n  (= (mod n 5) 0)\n  (= (mod n 7) 0)\n  (= (mod n 9) 0)\n\
    \  (= (mod n 11) 0)\n  (= (mod n 13) 0)\n  (= (mod n 17) 0)\n  (= (mod n 19) 0)\n\
    \  (= (mod n 23) 0))\n", "  (or (= n 0)\n      (= (odd? n) 0)\n      (= (even?\
    \ n) 0)\n      (= (= n 4) (= (even? n) 0))))\n", "  (= (even? n) (= (mod n 2)\
    \ 0)))\n", "  (cond [(= n 0) #f]\n        [(even? (rem n 2)) t]\n        [else\
    \ #f]))\n", "  (if (= n 0) true\n      (= (modulo n 2) 0) false)))\n", "  (= (mod\
    \ n 4) (even? n)))\n", "  (= n (cond ((= n 0) #f) \n            ((even? n) (=\
    \ (remainder n 2) 0)) \n            (else #f))))\n", "  (< (- n 4) 0))\n", " \
    \ (and (= (* n n) (+ n n)) (even? n)))\n", "  (< (* n 2) (* n 3) (* n 4) (* n\
    \ 5) (* n 6) (* n 7) (* n 8) (* n 9) (* n 10) (* n 11) (* n 12) (* n 13) (* n\
    \ 14) (* n 15) (* n 16) (* n 17) (* n 18) (* n 19) (* n 20) (* n 21) (* n 22)\
    \ (* n 23) (* n 24) (* n 25) (* n 26) (* n 27) (* n 28) (* n 29) (* n 30) (* n\
    \ 31)))\n", '  (= (count_of_positive_even n) 4))', "  (= (modulo (+ n 2) 4) (modulo\
    \ (+ n 3) 4) (modulo (+ n 5) 4) (modulo (+ n 7) 4)))\n", "  (= (even? n) (even?\
    \ (+ n 2))))\n", "  (cond ((= n 0) #f)\n        ((= n 2) #t)\n        ((= (* n\
    \ (+ 2 2)) 4)\n         #t)))\n", "  (= (/ n 4) (/ n 4)))\n", "  (and (= (/ n\
    \ 2) 2)\n       (= (/ (- n 2) 2) 4)\n       (= (/ (- n 2) 2) 4)\n       (= (/\
    \ (- n 2) 2) 4)\n       (= (/ (- n 2) 2) 4))\n)\n", "  (< (* n n) (- 4 (even?\
    \ (* n n)))))\n", "  (= (mod n 2) 0))\n", "  (let ([sum (make-sum n 'even)])\n\
    \    (number? sum)\n    (number? (sum 4))))\n", "  (<= n (/ 4 (+ n (* 2 (add n\
    \ (* 2 (add n (* 2 (add n (* 2 n)))))))))\n      (* 2 n)))\n", "  (= (even? n)\
    \ 4)\n)\n", "  (= (* n 4)\n     (if (= (modulo n 2) 0) 1 0)))\n", "  (cond\n \
    \   [(= n 2) #f]\n    [(even? n) (= (+ (* 2 (car n))) (car n))]\n    [else #f]\n\
    \  )\n)\n", "  (> (sum (filter (lambda (x)\n                     (= (odd? x) (even?\
    \ x))\n                    ))\n           (take-while-not (lambda (x)\n      \
    \                        (= x n)))))", "  (= (modulo n 4)\n     (modulo n 8)))\n",
  '  (= (= (+ 0 (+ n n n n)) (n + n + n + n)) 4))', "  (= (modulo n 2) 0))\n", " \
    \ (= (modulo-by-4 n (+ 1 4)) 0))\n", "  (cond\n    ((= n 0) #f) ; base case\n\
    \    ((even? n) (is_equal_to_sum_even (/ n 2)))\n    (else #t)))\n", "  (and (=\
    \ n 0)\n       (= n 1)\n       (= (mod! n 2) 0)\n       (= (even? n) false)))\n",
  "  (= (= (remainder (* n 2) 2) 4)\n     (remainder (+ n 1) 2)\n     :abs)\n  )\n",
  "  (and (even? (remainder n 2))\n       (even? (remainder n 4))))\n", "  (= (mod\
    \ n 2) 0))\n", "  (if (= (modulo n 4)\n         (modulo n 2))\n      true\n  \
    \    false))\n", "  (= (modulo (modulo n 2 4) (modulo n 2 4)) 0))\n", "  (if (=\
    \ n 0)\n      #f\n      (= (% n (quotient n 4)) (quotient n 4))))\n", "  (= (even?\
    \ n) (even? (rem n 4))))\n", "  (even?\n   (+ (* 2 n) (* 3 n) (* 5 n) (* 7 n))))\n",
  "  (<= n 4)\n  (even? (modulo-by-two n)))\n", "  (= (modulo n 4) 0)\n  )\n", " \
    \ (even? n))\n", "  (cond\n    ((= n 0)\n     #f)\n    ((= n 4)\n     #t)\n  \
    \  (else\n     (let\n       ((count (add (modulo n 2) (modulo n 4)))\n       \
    \ (sum (add n count)))\n       (or (is_equal_to_sum_even sum)\n           (= count\
    \ (modulo n 4))))))\n", "  (if (= n 0)\n      #t\n      (and (= (modulo n 2) 0)\n\
    \           (= (modulo n 4) 0)\n           (= (modulo n 6) 0)\n           (= (modulo\
    \ n 8) 0))))\n", "  (cond\n    [(= n 2) #f]\n    [(= n 4) #t]\n    [(even? n)\
    \ (is_equal_to_sum_even (/ n 2))]))\n", "  (let ([m (make-array (ceiling sqrt\
    \ n) (make-array '(unsigned-byte 4) 0))])\n    (set! m (+ (* m n) (* m n) (* m\
    \ n) (* m n)))\n    (let ([sum (+ (car m) (map (lambda (x) (cadr x)) m))])\n \
    \     (and (= sum n) (= (array-sum m) n))))\n", "  (let ((a (odds-list n)))\n\
    \    (for/sum ([x (in-range 1 a)]) \n      (if (= (mod x 4) 0)\n          (equal?\
    \ (evens? x) true)\n          (equal? (evens? x) false)))))\n", "  (= (modulo\
    \ (+ n 1) 4) #f)\n)\n", "  (cond\n    [(= n 0) #f]\n    [(even? n) true]\n   \
    \ [else (is_equal_to_sum_even (- n 2))]))\n", "  (<= (modulo n 2) 0))\n", "  (cond\n\
    \    ((= n 0) #f)\n    ((= n 1) #t)\n    ((even? n) (is_equal_to_sum_even (- n\
    \ 2)))\n    (else (is_equal_to_sum_even (- n 1)))))\n", "  (= (mod n 4) #t))\n",
  "  (cond\n    [(= n 0) #f]\n    [(even? n) (= (- n 2) 4)]))", "  (= (- n 4)\n  \
    \   (remainder n 4)))\n", "  (= (/ (* n (+ 2 n n n)) 4) (+ (mod n 2) 3)))\n",
  "  (equal? (modulo n 2 #t) #t))\n", "  (or (= (modulo n 2) 0)\n      (and (= (modulo\
    \ n 2) 0)\n           (= (modulo n 4) 0)\n           (= (modulo n 6) 0))))\n",
  "  (= (modulo (+ (* n n) 4) 4) 0))\n", "  (< (* (- n 1) n) (* 4 n)))\n", "  (let\
    \ ([sum (make_sum n)])\n    (= (make_sum n) (make_sum sum))\n    (not (zero? sum))\n\
    \    (zero? (make_decrease sum))))\n", "  (if (= n 0)\n      #f\n      (= (odd?\
    \ n) (= (mod n 2) #t))))\n", "  (= n 4)\n  ;; Evaluate whether the sum of the\
    \ given numbers is a multiple of 4\n  (for/sum ([i (in-range 2 (+ n 2))])\n  \
    \  (= (modulo (+ n i) 4) 0)\n    #t\n  )\n)\n", "  (= (modulo n 2) (modulo (+\
    \ n 4) 4)))\n", "  (= (- n 4 (ceiling n)) 0))\n", "  (= n (modulo n 4)))\n", " \
    \ (let ((l (list)))\n    (cond\n      ((= n 0) #t)\n      ((= n 1) #f)\n     \
    \ ((even? (modulo n 2)) #t)\n      (else\n       (loop\n        (cond\n      \
    \    ((< (modulo n 2) 1) (set! l (cons n (cdr l))) (set! n (modulo n 2)))\n  \
    \        ((even? (modulo n 2)) (set! n (modulo n 2)) (loop (cons n (cdr l)) (set!\
    \ n (modulo n 2))))\n          ((even? (modulo n 2)) (loop (cons n (cdr l)) (set!\
    \ l (cons n (cdr l))))\n          ((even? (modulo n 2)) (loop (cons n (cdr l))\
    \ (set! l (cons n (cdr l))))\n          ((even? (modulo n 2)) (loop (cons n (cdr\
    \ l)) (set! l (cons n (cdr l))))\n          ((even? (modulo n 2)) (loop (cons\
    \ n (cdr l)) (set! l (cons n (cdr l))))\n          (else (set! l (cons n (cdr\
    \ l))) (set! n (modulo n 2)))\n         )\n        )\n       )\n      )\n    \
    \  (else #f)\n     )\n   )\n)\n", "  (= (+ n 4) (modulo (+ n 4) 8)))\n", "  (=\
    \ (= n 0)\n     (= (+ n 1) 4)))\n", '  (= n (+ (* 2 (odd? n)) (even? n))))', " \
    \ (= (modulo n 4) #t))\n", "  (cond\n    ((= n 0)\n     (not (= n (- n 4))))\n\
    \    ((even? n) true)\n    (else false)))\n</cell>\n<code language=dyalog-kernel>\n\
    #lang racket\n", "  (= (modulo (+ n 3) 4) 0))\n", "  (cond ((or (zero? n) (negative?\
    \ n)) #f)\n        (else (even? (mod n 2)))))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
