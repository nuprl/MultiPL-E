name: HumanEval_150_x_or_y
language: rkt
prompt: "#lang racket\n\n;; A simple program which should return the value of x if\
  \ n is \n;; a prime number and should return the value of y otherwise.\n;; Examples:\n\
  ;; >>> (x_or_y 7 34 12)\n;; 34\n;; >>> (x_or_y 15 8 5)\n;; 5\n(define (x_or_y n\
  \ x y)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate x_or_y))\n\
  \    (check-equal? (candidate 7 34 12) 34)\n    (check-equal? (candidate 15 8 5)\
  \ 5)\n    (check-equal? (candidate 3 33 5212) 33)\n    (check-equal? (candidate\
  \ 1259 3 52) 3)\n    (check-equal? (candidate 7919 -1 12) -1)\n    (check-equal?\
  \ (candidate 3609 1245 583) 583)\n    (check-equal? (candidate 91 56 129) 129)\n\
  \    (check-equal? (candidate 6 34 1234) 1234)\n    (check-equal? (candidate 1 2\
  \ 0) 0)\n    (check-equal? (candidate 2 2 0) 2)\n))\n\n(test-humaneval)"
completions: ["  (cond\n    [(= n 1) x]\n    [(= (modulo n 2) 0) y]))\n", "  (cond\
    \ [(= n 0) x]\n        [(= n 1) y]\n        [else (let ([z (x_or_y (/ n 2) x y)])\
    \ \n          (cond [(= z 0) x]\n                [(= z 1) y]\n               \
    \ [else z]))]))\n</cell>\n<text>\nAvoiding Tail Calls\n\n</text>\n<text>\nIn Racket\
    \ there are several ways of optimizing programs and libraries. This section gives\
    \ an overview of some of them.\n\n\n</text>\n<text>\nTail Recursion\n\n</text>\n\
    <text>\nTail recursion is a standard idiom in functional programming. Tail recursion\
    \ means that a recursive function does not call itself directly but by passing\
    \ arguments to it. The following program is tail recursive (no stack space is\
    \ used):\n\n\n</text>\n<code language=dyalog-kernel>", "  (cond ((= n 2) y)\n\
    \        ((= (mod n x) 0) (* x y))\n        (else (* x y))))\n", "  (cond\n  \
    \  ((= n 1) (= x y))\n    ((= (mod n x) 0) (= x y))\n    (else (= x y))))\n",
  "  (cond\n    ((= n 0) (x y))\n    ((= n 1) x)\n    ((= (mod n 2) 0) y)\n    ((=\
    \ (mod n 2) 1) (x y))\n    (else (x_or_y (- n 1) (x y) (y x))))) ; This condition\
    \ handles the general case.\n", "  (cond (\n     (= n 2) (return y)\n     (= (mod\
    \ n 2) 0) (return (+ x y)))\n    (else (return (+ x y))))) ;; (x_or_y n x y) (n\
    \ x y) \n", "  (cond ((= n 0) x)\n        ((not (prime? n)) y)\n        (else\
    \ (cons (x_or_y (n-1) (* x x) (* y y)) (cons x y))))))\n", "  (cond\n    ((= n\
    \ 0) x)\n    ((= n 1) y)\n    ((= (modulo n 2) 0) (cons y (x_or_y (sub1 n) x y))))\n\
    \    ((= (modulo n 2) 1) (cons x (x_or_y (sub1 n) x y)))\n    (else (cons x x))))",
  "  (cond\n    [(= n 0) x]\n    [(= n 1) y]\n    [(= (mod n 2) 0) x]\n    [else y]))\n",
  "  (cond\n    [(even? n) (cond [(even? x) (cond [(odd? y) (cons x (x_or_y (remainder\
    \ n 2) x)) (cons y '())]\n                                        [(odd? y) '()])]\n\
    \                   [(odd? n) (cond [(even? y) (cons x (x_or_y (remainder n 2)\
    \ x)) (cons y '())]\n                                        [(odd? y) '()])]\n\
    \                   [else (cond [(even? y) (cons x (x_or_y (remainder n 2) x))\
    \ (cons y '())]\n                                        [(odd? y) '()])])]\n\
    \    [else (cond [(even? x) (cond [(odd? y) (cons x (x_or_y (remainder n 2) x))\
    \ (cons y '())]\n                                        [(odd? y) '()])]\n  \
    \                 [(odd? n) (cond [(even? y) (cons x (x_or_y (remainder n 2) x))\
    \ (cons y '())]\n                                        [(odd? y) '()])]\n  \
    \                 [else (cond [(even? y) (cons x (x_or_y (remainder n 2) x)) (cons\
    \ y '())]\n                                        [(odd? y) '()])])]\n    [else\
    \ '()])) \n", "  (cond\n    [(= n 2)\n     (if (= x y)\n         x\n         (+\
    \ x y))]\n    [(prime? n)\n     (if (= x y)\n         y\n         (+ x y))]\n\
    \    [else\n     (if (= x y)\n         x\n         (+ x y))]\n   ))\n", "  (cond\
    \ [(zero? n) x]\n        [(prime? n) y]\n        [else (error (format \"Number\
    \ must be a prime number.\" n x y))]))\n", "  (cond\n    ((= n 0) y)\n    ((and\
    \ (= (modulo n x) 0)\n          (= (modulo n y) 0))\n     (x_or_y (- n 1) x y))\n\
    \    (else x)))", "  (cond\n    ((= n 0) x)\n    ((= (mod n 2) 1) y)\n    (else\
    \ (cons (* n x_or_y y) (/ n x_or_y)))\n    )\n  )\n", "  (cond\n    [(<= n 0)\
    \ x]\n    [(<= (modulo n x) 0) y]\n    [else x]))\n", "  (cond\n    [(= n 1) x]\n\
    \    [(= (mod n 2) 0) y]))\n", "  (cond\n    [(or (= n 2) (= n 3)) x]\n    [else\
    \ y]))\n", "  (cond \n    ((= n 0) x)\n    ((odd? n) y)\n    ((prime? n) x)))\n",
  "  (cond\n    [(> (modulo n x) 0) x]\n    [else y]))\n", "  (cond ((= n 1) (first\
    \ y))\n        ((prime? n) (first x))\n        (else (first y))))\n", "  (if (prime?\
    \ n)\n      (cons x y)\n      x))\n", "  (cond ((= (modulo n x) 0)\n         (cons\
    \ y '()))\n        ((= (modulo n y) 0)\n         (cons x '()))\n        (else\
    \ (cons (modulo n x) '()))))\n</code>\n<|/ a tags=racket,scheme dscore=0 |>\n\
    <| a dscore=0 |>\nThis isn't a racket problem, its an algorithm problem.  \nWhat\
    \ you want is to return the maximum value that can fit into a number x given the\
    \ limits 1<= x <= 1000.  \nFor this you need the greatest common divisor of x\
    \ and y.\nIf you choose y = x, then gcd will always be 1.  \nThe solution to this\
    \ problem is also the solution to your algorithm problem.\n<code>", "  (cond\n\
    \    ((= n 1)      x)\n    ((modulo n 2) y)\n    (else        ((x_or_y (n-1) (*\
    \ x y) y) \n                    (* x (x_or_y (n-1) (* x y) y)))\n            \
    \      ((x_or_y (n-1) x (* x y)) \n                   (* x (x_or_y (n-1) x y))))))\n",
  "  (if (prime? n)\n      (list x y)\n      (list x y)))\n", "  (cond ((= n 2)\n\
    \         (list x y))\n        ((even? n)\n         (list x y))\n        (else\n\
    \         (x_or_y (n/2) x (+ y x))))\n", "  (if (= n 2)\n      (+ x y)\n     \
    \ (x_or_y (- n 1) x y)))\n", "  (cond [(= (mod n x) 0) (mod n y)]\n        [else\
    \ x]))\n", "  (cond [(is_prime n) x]\n        [else y]))\n", "  (cond\n    ((=\
    \ n 0)\n     x)\n    ((even? n)\n     (x_or_y (/ n 2) x y))\n    ((odd? n)\n \
    \    (x_or_y (+ (/ n 2) 1) x y))\n    ((even? (modulo n 2))\n     (x_or_y (+ (/\
    \ n 2) 1) x y))\n    ((odd? (modulo n 2))\n     (x_or_y (/ n 2) x y))\n    (else\
    \ (error \"bad args to x_or_y\"))))\n", "  (cond\n    [(= n 2) x]\n    [(odd?\
    \ (modulo n 2))\n     (x_or_y (n/2) x y)] \n    [else y]))\n", "  (if (= n 1)\n\
    \      x\n      (let ((x (x_or_y (/ n 2) x y)))\n        (if (= x y)\n       \
    \     x\n            y))))\n</code>\nIn Racket this is how I would have done this:\n\
    <code>\n#lang racket\n", "  (cond\n    [(= n 1) x]\n    [(even? n) (* y x_or_y\
    \ (/ n 2) x_or_y (odd? n))]\n    [else (* x_or_y y x_or_y (/ n 2))]))\n</code>\n\
    <|/ a tags=scheme dscore=2 |>\n<| a |>\nHow about this:\n<code>", "  (cond ((=\
    \ n 0) 'z)\n        ((= n 1) x)\n        ((= (floor (sqrt n)) 1) y)\n        (else\
    \ (x_or_y (floor (sqrt n)) x (+ x y)))))\n", "  (cond [(= (mod (+ n 1) 2) 1) x]\n\
    \        [else y]))\n", "  (if (prime? n)\n    (x n)\n    (y n)))\n", "  (cond\
    \ \n    [(= n 1) y]\n    [(= (modulo n x) 0) x]\n    [else y]))\n", "  (cond\n\
    \    [(even? n) x]\n    [(< x y) y]))\n", "  (if (odd? n)\n      (y)\n      (x)))\n",
  "  (cond\n    ((= n 0)         y)\n    ((= x y) (+ x y)) \n    ((= y 1)        \
    \ x)\n    ((= n 2)         (* x y))\n    ((> n 3)         x_or_y (- n (* 2 y))\
    \ (* x y) (* y x))\n    ((< n 3)         x_or_y (- n (* 2 x)) (* x y) (* y x))\n\
    \    ((= n 4)         x_or_y (- n (* 2 y)) (* x y) (* y x)) \n    ((= n 5)   \
    \      x_or_y (- n (* 2 x)) (* x y) (* y x)) \n    ((< n 5)         (* x y) (*\
    \ y x))))\n</code>\n<|/ a tags=racket dscore=2 |>\n<| c |>\nThanks for your effort.\
    \ How did you come up with those constants? If you think there is an algorithm\
    \ behind it, could you please share it with the community? Thank you in advance.\n\
    <|/ c |>\n<| c |>\nI just took the examples from http://en.wikipedia.org/wiki/Primality_test#Primality_test_algorithm\n\
    <|/ c |>\n<| c |>\nI see. Thank you for your help. I was struggling with this\
    \ algorithm a lot.\n<|/ c |>\n<| a dscore=2 |>\nThe question is interesting but\
    \ your explanation is too technical for me.\nI will just provide a solution that\
    \ is more intuitive:\n<code>", "  (cond\n    [(= n 1)\n     (printf \"~d\\n\"\
    \ (* x y))]\n    [else\n     (x_or_y (n-1) (* x y) (* y x))]))\n", "  (cond\n\
    \    ((= (mod n 2) 0) x)\n    ((= (mod n 2) 1) y)\n    (else\n     (x_or_y (n-1)\
    \ (+ x y) y))))\n", "  (cond [(= (mod n 2) 0)\n         (cond [(= y x)\n     \
    \           (begin (display x) (newline))\n                (display y)\n     \
    \           (newline)]\n               [else\n                (begin (display\
    \ x) (newline))\n                (display y)\n                (newline)]\n   \
    \            )]\n        [else\n         (cond [(= y x)\n                (begin\
    \ (display x) (newline))\n                (display y)\n                (newline)]\n\
    \               [else\n                (begin (display x) (newline))\n       \
    \         (display y)\n                (newline)]\n               )\n        \
    \ ]\n         )\n         ]\n         )\n", "  (cond \n    ((= (modulo n 2) 0)\
    \ y)\n    ((= (modulo n 3) 0) x)\n    (else n)))\n", "  (cond ((= n 0)\n     \
    \    (if (= x y)\n             x\n             (y x)))\n        ((= (mod n x)\
    \ 0)\n         (if (= x y)\n             y\n             (x_or_y n (x y) y)))\n\
    \        (else\n         (x_or_y n (x y) (y x))))", "  ;; Check whether the number\
    \ is prime\n  (cond [(= (prime? n) 0) x]\n        ;; It's not a prime number.\
    \ Go for the other number.\n        [else y]))\n", "  (cond ((= n 0) x)\n    \
    \    ((= (modulo n 2) 0) y)\n        (else (+ x y))))\n", "  (if (even? n)\n \
    \     y\n      x))\n", "  (cond ((= n 0) y)\n        ((= n 1) x)\n        (else\n\
    \         (x_or_y (- n 1)\n                  (* x x)\n                  (* x y)))))\n",
  "  (if (even? n)\n      (let ([x (* x x x)])\n        (if (x_or_y (/ n 2) x y)\n\
    \            x y))\n      y))", "  (if (= (mod n y) 0)\n      (list x y)\n   \
    \   (list y x)))\n", "  (cond [(= n 1) x]\n        [(= (mod n 2) 0) y]\n     \
    \   [else x_or_y (- n 1) x y]\n  )\n)\n", "  (if (prime n)\n      (+ x y)\n  \
    \    x))\n", "  (cond [(prime? n) x]\n        [else y]))\n", "  (cond ((even?\
    \ n)\n         (if (even? x)\n             (x_or_y n x (add1 y))\n           \
    \  (x_or_y n (add1 x) (add1 y))))\n        ((odd? n)\n         (if (odd? y)\n\
    \             (x_or_y n x (add1 x))\n             (x_or_y n (add1 x) (add1 y))))\n\
    \        (else (if (odd? x)\n                  x\n                  y))))\n",
  "  (if (prime? n)\n      (let ([y (* x n)]) (list y))\n      (list x)))\n", "  (cond\n\
    \    [(= n 1) x]\n    [(odd? (- n 1)) y]\n    [else x]))\n", "  (cond [(prime\
    \ n) x]\n        [else y]))\n", "  (if (prime? n)\n      (cons x y)\n      (cons\
    \ y x)))\n</cell>\n<cell>\n# %load solutions/x_or_y.rkt", "  (cond\n    [(= n\
    \ 0) x]\n    [(= (mod (+ n 1) (* n 2)) (= n 2)) y]))\n", "  (cond\n    ((= n 1)\n\
    \     (cons x y))\n    ((= (modulo n y) 0)\n     (x_or_y (quotient n y) x y))\n\
    \    ((= (modulo n x) 0)\n     (x_or_y (quotient n x) y x))\n    (else\n     (x_or_y\
    \ (quotient n x) y x))\n   )\n  )\n", "  (cond \n    [(zero? n) y]\n    [else\
    \ x]))", "  (cond\n    ((= n 0) y)\n    ((not (prime? n)) x)\n    (else (cons\
    \ x (x_or_y (- n 1) x y)))))\n  ", "  (cond ((= n 1) x)\n        ((prime? n) (x_or_y\
    \ (n-1) x y))\n        (else (y)\n)))\n", "  (cond [(= (mod n 2) 0) x]\n     \
    \   [else y]))\n", "  (cond\n    [(= n 0) y]\n    [(= (mod (+ n 1) 2) 0) x]\n\
    \    [else y]))\n", "  (cond ((= n 1)\n         (cons x y))\n        ((prime n)\n\
    \         (cons x y))\n        (else\n         (x_or_y (n-1) x y))))\n", "  (cond\
    \ ((= n 1) x)\n        ((= n 2) y)\n        (else \n         (x_or_y (+ 1 n) x\
    \ (* y y))))) ; cond is more compact", "  (cond \n    (((= n 2) x)\n     (if (<\
    \ n 3) (+ x y))\n     (if (< n 5) (+ x y)))\n    ((= (mod n 2) 0) (+ x y))\n \
    \   (else (+ x y))))\n", "  (cond\n    [(> (modulo n 2) 0) x]\n    [else y]))\n",
  "  (cond\n    [(number? n) x]\n    [(number? y) y]\n    [else \n     (cond\n   \
    \    [(even? n) x]\n       [else (* 3 x)\n        (cond\n          [(odd? n) (*\
    \ y 3)]\n          [else (* y x)]\n          )]))]))\n", "  (cond\n    ((= n 0)\
    \ x)\n    ((= n 1) y)\n    ((< n 1) (* x y))\n    (else (* x (x_or_y ((- n 1)\
    \ 2) x y)))))\n", "  (cond [(= n 0) x]\n        [(= n 1) y]\n        [(= (remainder\
    \ n 2) 0)\n         (x_or_y (remainder n 2) x y)]\n        [else x]))\n", "  \n\
    \  (cond\n    ((= n 1) x)\n    ((= (mod n 2) 0) y)\n    ((= (mod n 2) 1) x)\n\
    \    ((not (= (mod n 2) 1)) y)\n  ))\n", "  (cond \n    [(= n 1) x]\n    [else\
    \ y]\n  )\n)\n", "  (cond ((= n 2) x)\n        ((prime? n) y)\n        (else (cons\
    \ (* n (cons (- n (/ n 2)) x)) '()))))\n", "  (cond\n    ((= n 1) x)\n    ((=\
    \ (prime n) (not (= x y))) y)\n    (else (x_or_y (- n 1) x y))))\n", "  (cond\
    \ [(= n 0) x] [(< n 1) y]\n        [else (= (mod n 2) 0) x (x_or_y (- n 2) x (y_or_x\
    \ n y))]))\n", "  (cond\n    [(= n 0) y]\n    [(= (mod n 2) 1) x]\n    [else y]))\n",
  "  (cond (< n 2)\n        ((= (modulo n x) 0)\n         (x_or_y (n-1) (* x n) (*\
    \ x y)))\n        (else\n         (x_or_y (n-1) (* x y) (* x y)))\n        ))",
  "  (if (prime? n) x (y)))\n", "  \n  (cond\n    [(odd? (car n)) y]\n    [(= (car\
    \ n) x) (if (odd? (car n)) y x)]\n    [else x]))\n", "  (cond ((= n 1) y)\n  \
    \      ((= (mod n 2) 0) x)\n        (else (x y))))\n", "  (cond\n    ((= n 2)\
    \ x)\n    ((even? n) (cons x y))\n    (else y)))\n", "  (cond\n    ((= n 1)  \
    \   x)\n    ((odd? (- n 1))\n     (cond ((even? (- n 2))\n            x)\n   \
    \        ((odd? (- n 2))\n            y)))\n    (else\n     (cond ((odd? (- n\
    \ 2))\n            y)\n           ((even? (- n 2))\n            x)))\n  )\n",
  "  (cond\n    [(prime? n) x]\n    [else y]))\n", "  (cond [(= n 1)\n         (cond\
    \ [(= x y)\n                (cons y '())]\n               [(= x 1)\n         \
    \       (cons x '())]\n               [else (cons x y)]))\n        (else (cons\
    \ (x_or_y (- n 1) x (* x y)) '()))])\n", "  (cond\n    [(= n 1)\n     x]\n   \
    \ [(= (remainder n 2)\n        0)\n     y]\n    [else\n     (x_or_y (remainder\
    \ n 2)\n              x\n              y)]))\n", "  (cond\n    ((= n 0) (list\
    \ x y))\n    ((= n 1) x)\n    ((= n 2) y)\n    ((< n 2) (cons (x_or_y ((- n 1)\
    \ 1) x y)\n                    (y)))))\n", "  (cond [(= n 0) x]\n        [(= (mod\
    \ n 2) 0) y]\n        [else x]))\n", "  (if (integer? n)\n      (if (prime? n)\n\
    \          (printf \"~A\" x)\n          (printf \"~A\" y))\n      (printf \"~A\"\
    \ x)))\n", "  (cond\n    [(= n 1) x]\n    [(= (mod n 2) 0) y]\n    [else x]))\n",
  "  (cond\n    ((= n 2)  x)\n    ((= n 1)  y)\n    ((< n 1)  (x_or_y n (* x y) y))\n\
    \    (else      (* x (x_or_y n (+ x y) y)))))\n", "  (cond\n    [(= n 1)\n   \
    \  x]\n    [(= (mod n 2) 0)\n     y]\n    [else\n     (x_or_y n-1 x y)]))\n</code>\n\
    <|/ a dscore=1 tags=racket,scheme |>\n<| c |>\nThis isn't really an answer to\
    \ the question.\n<|/ c |>\n<| c |>\nWell, I answered the question and gave the\
    \ code sample which can help the OP to better understand the concept in Racket.\
    \ So, it is definitely an answer\n<|/ c |>\n<| c |>\nI disagree.  While this answers\
    \ what the OP asked, it doesn't answer what they are trying to do because this\
    \ is clearly not what they are trying to do.  You haven't answered the question.\
    \  How are you supposed to figure out how to do something if you don't know what\
    \ it is?  This is not a solution.\n<|/ c |>\n<| c |>\nHi Josh, Thanks for the\
    \ feedback. I am new to this platform and was trying to give a better explanation\
    \ for beginners. Apologies for any inconvenience I caused. I will try to make\
    \ it better. Thanks again.\n<|/ c |>\n<| c |>\nThanks John. I am still trying\
    \ to understand the concept behind this but I am not able to get past the error\
    \ where i have the #lang racket and #lang scheme in the code. Any help is appreciated\n\
    <|/ c |>\n<| a tags=racket,scheme |>\n<code>", "  (cond\n    [(= n 0) x]\n   \
    \ [(= n 1) y]\n    [(number? (modulo n x))\n     (x_or_y (int (/ n x)) x y)]\n\
    \    [else\n     (x_or_y (int (/ n y)) x y)]))\n", "  (cond [(= n 2)\n       \
    \  (list x y)\n         ]\n        [(= (even? n) 1)\n         (x_or_y (/ n 2)\
    \ x y)\n         ]\n        [else\n         (x_or_y (- n 1) x y)\n         ]\n\
    \        ))\n", "  (cond [(= (modulo n x) 0) x]\n        [else y]))\n", "  (cond\n\
    \    [(< n 2)\n     (cons x y)]\n    [(= (mod n 2) 0)\n     (x_or_y (n-1) x (cons\
    \ y x))]\n    [else\n     (x_or_y (n-1) x (cons y x))]))\n", "  (cond [(= n 1)\n\
    \         (cond [(= x y)\n                (return x)]\n               [(= x x)\
    \ (return y)]\n               [else (return '())])]\n        [else (cond [(is_prime\
    \ n) x]\n                     [else y])]))\n", "  (cond\n    [(= n 2) x]\n   \
    \ [else y]))\n", "  ((cond\n    [(= (modulo n x) 0) y]\n    [else x])))\n", " \
    \ (cond\n    ((< n 1)\n     (x_or_y 1 (+ x y) (+ y 1)))\n    ((odd? n)\n     (cond\
    \ ((= n 1)\n            (cons x\n                   (cons y\n                \
    \         (cons y '())))\n           ((= (remainder n 2) 0)\n            (x_or_y\
    \ (quotient n 2) x (+ y 1))))\n     (x_or_y (quotient n 2) x (+ y 1)))))\n</cell>\n\
    <cell>\n%store x_or_y\n</cell>\n<cell>", "  (cond [(= n 1) x]\n        [(= (modulo\
    \ n 2) 0) y]\n        [else x]))\n", "  (if (prime? n)\n      (x)\n      (y)))\n",
  "  (cond\n    ((= n 1) x)\n    ((= (mod n 2) 0) y)\n    (else (let ((x_or_y (x_or_y\
    \ (n-1) x (x_or_y (n-1) y y))))))) ; else clause is optional\n  )\n)\n</code>\n\
    <|/ a dscore=0 tags=racket,scheme |>\n<| a tags=racket,scheme |>\nThis is probably\
    \ the shortest answer, but you can do it in one line:\n<code>", "  (cond\n   \
    \ ((= n 2) x)\n    ((= (modulo n 2) 0) y)\n    (else x_or_y (quotient n 2) x (modulo\
    \ n 2))))\n", "  (cond [(number? n) (number? x)\n         (number? y) x]\n   \
    \     [(number? n) (number? y)\n         (number? x) y]\n        [(number? x)\
    \ (number? y)\n         (number? n) x]\n        [(number? y) (number? x)\n   \
    \      (number? n) y]\n        [else (error 'x_or_y \"n must be positive and x~x,\
    \ y~y\")]))\n", "  (cond [(= (modulo n 2) 0)\n         (cond [(= n x)\n      \
    \          (list y x)]\n              [(= n y)\n                (list x y)]\n\
    \              [else (list x y)]\n              )]\n        [else (cond [(= (modulo\
    \ n 3) 0)\n                    (cond [(= n x)\n                          (list\
    \ y x)]\n                      [(= n y)\n                          (list x y)]\n\
    \                      [else (list x y)]\n                      )]\n         \
    \         [else (cond [(= (modulo n 5) 0)\n                              (cond\
    \ [(= n x)\n                                    (list y x)]\n                \
    \              [(= n y)\n                                    (list x y)]\n   \
    \                           [else (list x y)]\n                              )]\n\
    \                          [else (cond [(= (modulo n 7) 0)\n                 \
    \                       (cond [(= n x)\n                                     \
    \         (list y x)]\n                                          [(= n y)\n  \
    \                                            (list x y)]\n                   \
    \                       [else (list x y)]\n                                  \
    \        )]\n                                      [else (list x y)]\n       \
    \                               )]\n                              [else (list\
    \ x y)]\n                              )]\n                      [else (cond [(=\
    \ (modulo n 11) 0)\n                                    (cond [(= n x)\n     \
    \                                         (list y x)]\n                      \
    \                    [(= n y)\n                                              (list\
    \ x y)]\n                                          [else (list x y)]\n       \
    \                                   )]\n                                     \
    \ [else (cond [(= (modulo n 13) 0)\n                                         \
    \     (cond [(= n x)\n                                                      (list\
    \ y x)]\n                                                  [(= n y)\n        \
    \                                              (list x y)]\n                 \
    \                                 [else (list x y)]\n                        \
    \                          )]\n                                              [else\
    \ (cond [(= (modulo n 17) 0)\n                                               \
    \       (cond [(= n x)\n                                                     \
    \       (list y x)]\n                                                      [(=\
    \ n y)\n                                                            (list x y)]\n\
    \                                                      [else (list x y)]\n   \
    \                                                   )]\n                     \
    \                             [else (cond [(= (modulo n 19) 0)\n             \
    \                                               (cond [(= n x)\n             \
    \                                                   (list y x)]\n            \
    \                                                  [(= n y)\n                \
    \                                                (list x y)]\n               \
    \                                               [else (list x y)]\n          \
    \                                                    )]\n                    \
    \                                          [else (cond [(= (modulo n 21) 0)\n\
    \                                                                (cond [(= n x)\n\
    \                                                                       (list\
    \ y x)]\n                                                                    [(=\
    \ n y)\n                                                                     \
    \  (list x y", "  (cond\n    [(= n 1) x]\n    [(= (modulo n 2) 0) y]\n    [else\
    \ x]))\n", "  (cond ((prime? n) x)\n        (else y)))\n", "  (cond\n    [(= n\
    \ 0)         y]\n    [(= (modulo n x) 0) x]\n    [else (modulo n x)]))\n", " \
    \ (cond ((= n 1) x)\n        ((prime n) y)\n        (else (display \"unknown number~%\"\
    )\n                (newline) (x_or_y (remainder n 2) x y))))\n", "  (cond\n  \
    \  [(= n 1) x]\n    [(= n 2) y]\n    [else x_or_y (- n 1) x y]\n  )\n)\n", " \
    \ (cond ((= (mod n 2) 0) x)\n        ((not (= (mod n 2) 0)) y)\n        (else\
    \ n)))\n", "  (cond [(= n 0) x]\n        [else y]))\n", "  (cond\n    ((= n 2)\
    \ x)\n    ((= n 3) y)\n    ((even? n) y)\n    ((odd? n) x)\n    ((= x y) x)\n\
    \    ((= x n) y)\n    ((= y n) x)\n    ((prime? n) x)\n    ((prime? y) y)\n  \
    \  ((prime? x) x)\n    ((prime? x) y)\n    ((= x y) x)\n    ((= y x) y)\n    ((=\
    \ n 1) y)\n    ((= n 2) x)\n    ((= n 3) y)\n    ((= n 4) x)\n    ((= n 5) y)\n\
    \    ((= n 6) x)\n    ((= n 7) y)\n    ((= n 8) x)\n    ((= n 9) y)\n    ((= n\
    \ 10) x)\n    ((= n 11) y)\n    ((= n 12) x)\n    ((= n 13) y)\n    ((= n 14)\
    \ x)\n    ((= n 15) y)\n    ((= n 16) x)\n    ((= n 17) y)\n    ((= n 18) x)\n\
    \    ((= n 19) y)\n    ((= n 20) x)\n    ((= n 21) y)\n    ((= n 22) x)\n    ((=\
    \ n 23) y)\n    ((= n 24) x)\n    ((= n 25) y)\n    ((= n 26) x)\n    ((= n 27)\
    \ y)\n    ((= n 28) x)\n    ((= n 29) y)\n    ((= n 30) x)\n    ((= n 31) y)\n\
    \    ((= n 32) x)\n    ((= n 33) y)\n    ((= n 34) x)\n    ((= n 35) y)\n    ((=\
    \ n 36) x)\n    ((= n 37) y)\n    ((= n 38) x)\n    ((= n 39) y)\n    ((= n 40)\
    \ x)\n    ((= n 41) y)\n    ((= n 42) x)\n    ((= n 43) y)\n    ((= n 44) x)\n\
    \    ((= n 45) y)\n    ((= n 46) x)\n    ((= n 47) y)\n    ((= n 48) x)\n    ((=\
    \ n 49) y)\n    ((= n 50) x)\n    ((= n 51) y)\n    ((= n 52) x)\n    ((= n 53)\
    \ y)\n    ((= n 54) x)\n    ((= n 55) y)\n    ((= n 56) x)\n    ((= n 57) y)\n\
    \    ((= n 58) x)\n    ((= n 59) y)\n    ((= n 60) x)\n    ((= n 61) y)\n    ((=\
    \ n 62) x)\n    ((", "  (cond [(= (mod n 2) 0) x]\n        [else y]))\n", "  (cond\
    \ ((= n 1)\n         x)\n        ((prime? n)\n         y)\n        (else\n   \
    \      (x_or_y n (+ x 1) (+ y 1)))))\n", "  (cond\n    [(= n 0) y]\n    [(= (mod\
    \ n 2) 0) x]\n    [else x_or_y (- n 1) x y]))\n", "  (cond [(= (mod n 2) 0) x]\n\
    \        [else y]))\n", "  (if (prime? n)\n      (let ([x (+ x 1)])\n\tx)\n\t\
    \  y))\n", "  (cond ((= n 0) x)\n        ((= n 1) y)\n        (else (x_or_y (quotient\
    \ n 2) x (+ y x)))))\n", "  (cond\n    [(is_prime n) x]\n    [else y]))\n", " \
    \ (if (prime? n)\n      x\n      y))\n", "  (cond [(= n 2) x]\n        [(is_prime\
    \ n) y]\n        [else (print \"x or y is not valid.\")]))\n", "  (cond\n    ((=\
    \ n 1) x)\n    ((prime n)\n     (x_or_y (n-1) (x y) y))\n    (else\n     (x_or_y\
    \ (n-1) (x y) y))))\n", "  (if (even? n)\n      x\n      y))\n", "  (cond\n  \
    \  ((= n 2) x)\n    ((and (= n 1)\n           (= x y)) y)\n    ((prime? (modulo\
    \ n x))\n     (x_or_y (- n 1) x y))\n    (else (error 'x_or_y \"~d is not a prime\
    \ number\" n))))\n</code>\n<|/ a dscore=1 tags=racket,scheme,functional-programming\
    \ |>\n<| c |>\nI guess I didn't know what \"modulo\" was (I know it only exists\
    \ in scheme). Thanks for the solution!\n<|/ c |>\n<| a tags=racket,scheme,functional-programming\
    \ |>\nThis question has been answered already but since I came here to learn more\
    \ about Scheme I thought I would share how one would tackle this exercise using\
    \ only basic arithmetic and boolean operators.\nMy approach here would not be\
    \ efficient for larger numbers. However if you're still interested then you could\
    \ use it to solve the problem of finding the first n prime numbers in O(sqrt(n))\
    \ time.\n<code>", "  \n  (cond\n    ((= n 0) x)\n    ((= n 1) y)\n    (else (let\
    \ ((x (x_or_y (1- n) (* x x) (+ x y))))\n            (cond\n              ((=\
    \ (remainder n 2) 0) (if (= n 2) x y))\n              (else (display x) (newline)\
    \ (display y)))))))\n", "  (cond\n    [(= n 1) x]\n    [(= (remainder n 2) 0)\
    \ y]\n    [else x_or_y (remainder n 2) x y]))\n", "  (cond [(= (mod n y) 0)\n\
    \         (display x)\n         (newline)]\n        [else\n         (display y)\n\
    \         (newline)]\n        [else (display \"no solution\")]))\n", "  (cond\
    \ [(even? n) (cons x (x_or_y (remainder n 2) (* 2 x) (+ y y)))]\n        [else\
    \ (cons y (x_or_y (remainder n 2) x y))]\n        ))\n", "  (cond\n    ((= (mod\
    \ n x) 0) x)\n    ((= (mod n y) 0) y)\n    (else n)))", "  (cond\n    ((= n 0)\
    \ y)\n    ((= n 1) x)\n    (else (x_or_y (/ n 2) x y))))\n", "  (cond\n    [(=\
    \ n 0) x]\n    [(= (number? n) 1) y]\n    [(= (number? n) 2) (* n x)]\n    [else\
    \ (* n y)]))", "  (cond\n    [(= (modulo-by-two n) 1) x]\n    [(= (modulo-by-two\
    \ n) 2) y]\n    [else x_or_y n x (* y y n)]\n  )\n)\n", "  (cond\n    ((= n 2)\n\
    \     (cons x y))\n    ((= (mod n 2)) \n     (x_or_y ((/ n 2) 2) x y))\n    (else\
    \ \n     (x_or_y (+ (/ n 2) 1) x y))))\n</code>\n<|/ a tags=scheme,racket |>\n\
    <| c |>\nThanks for the suggestion. I think I've got the hang of it now. I've\
    \ only been coding for a couple of months now, so I'm pretty sure I'm still confused\
    \ about everything I'm doing.\n<|/ c |>\n<| a |>\nThis is how I solved it:\n<code>",
  "  (cond\n    ((= n 0) x)\n    ((= n 1) y)\n    ((> (modulo n 2) 0) (cond \n   \
    \                       ((= (mod n 2) 0) x) (cond \n                         \
    \                   (else (cond \n                                           \
    \       ((= (mod n 3) 0) y) (cond \n                                         \
    \                    (else (cond \n                                          \
    \                          ((= (mod n 4) 0) y) (cond \n                      \
    \                                                 (else (cond \n             \
    \                                                              ((= (mod n 5) 0)\
    \ y) (cond \n                                                                \
    \            (else (cond \n                                                  \
    \                                  (= (mod n 7) 0) y) (cond \n               \
    \                                                                       (else\
    \ (cond \n                                                                   \
    \                           (= (mod n 11) 0) y) (cond \n                     \
    \                                                                           (else\
    \ y))))))))))))))\n    ((< n 3) (cond \n              ((= (modulo n 2) 0) x) (cond\
    \ \n                                 (else (cond \n                          \
    \            ((= (mod n 3) 0) y) (cond \n                                    \
    \     (else (cond \n                                                ((= (mod n\
    \ 5) 0) y) (cond \n                                                   (else (cond\
    \ \n                                                          ((= (mod n 7) 0)\
    \ y) (cond \n                                                         (else (cond\
    \ \n                                                            ((= (mod n 11)\
    \ 0) y) (cond \n                                                            (else\
    \ (cond \n                                                                 ((=\
    \ (mod n 13) 0) y) (cond \n                                                  \
    \                (else y))))))))))))))\n    ((< n 5) (cond \n              ((=\
    \ (modulo n 2) 0) x) (cond \n                                 (else (cond \n \
    \                                     ((= (mod n 3) 0) y) (cond \n           \
    \                              (else (cond \n                                \
    \                ((= (mod n 5) 0) y) (cond \n                                \
    \                   (else (cond \n                                           \
    \               ((= (mod n 7) 0) y) (cond \n                                 \
    \                        (else (cond \n                                      \
    \                      ((= (mod n 11) 0) y) (cond \n                         \
    \                                   (else (cond \n                           \
    \                                      ((= (mod n 13) 0) y) (cond \n         \
    \                                                         (else y))))))))))))))\n\
    \    ((< n 7) (cond \n              ((= (modulo n 2) 0) x) (cond \n          \
    \                       (else (cond \n                                      ((=\
    \ (mod n 3) 0) y) (cond \n                                         (else (cond\
    \ \n                                                ((= (mod n 5) 0) y) (cond\
    \ \n                                                   (else (cond \n        \
    \                                                  ((= (mod n 7) 0) y) (cond \n\
    \                                                         (else (cond \n", " \
    \ (cond\n    [(zero? n) x]\n    [(= (remainder n 2) 0) y]\n    [else x_or_y (remainder\
    \ n 2) x y]\n  )\n)\n", "  (cond (\n       ((is_prime n) x)\n       (else y)\n\
    \       )\n  (define (is_prime n)\n    (cond \n    ((= n 1)\n     #f) \n    ((=\
    \ n 2)\n     #t)\n    ((= n (round n))\n     (x_or_y n (* 2 n) (+ n 1)))\n   \
    \ ((odd? n)\n     (x_or_y n (+ n 1) (* 2 n)))\n    (else (is_prime (+ n 1)))))\n\
    </code>\n<|/ a tags=scheme |>\n<| c |>\nthanks a lot for your time and efforts.\
    \ I understood the code but I'm still confused about the way it works. I get the\
    \ general idea but not the syntax. Can you briefly tell me what each element does\
    \ in this code like for example why is it called '(define (define (is_prime n)\
    \ ...).\n<|/ c |>\n<| c |>\nalso, why doesn't the recursion stop when x is found\
    \ instead of continuing with y. how does the function know when to stop recursing?\n\
    <|/ c |>\n<| c |>\nI have edited my answer above to include the full code. Basically\
    \ it just checks all the numbers from 2 to n and if it finds one that is prime\
    \ it returns x, otherwise y will be returned.\n<|/ c |>\n<| c |>\nthanks a lot\
    \ again but could you briefly explain what you did in the code you provided and\
    \ why you put this '(define x_or_y ...).\n<|/ c |>\n<| c |>\nI have added comments\
    \ above to explain the code. Basically in scheme functions can only return one\
    \ value. So in the above code x_or_y will return either the value of x or y. This\
    \ will be called by the caller with the arguments you provided. You will need\
    \ to use the x_or_y function when you write some code using the x_or_y function\
    \ (which you wrote). Hope that helps.\n<|/ c |>\n<| a |>\n<code>", "  (cond ((<=\
    \ n 2) x)\n        ((even? n) (x_or_y (n-1) (x y) (x y)))\n        (else y)))",
  "  (cond\n    [(= n 2) x]\n    [(prime? n) y]\n    [else x]))\n", "  (if (zero?\
    \ n) x\n      (if (number? (modulo n y)) y\n          x_or_y (quotient n y)\n\
    \          y))))", "  (cond\n    ((= n 1)\n     (list x y))\n    ((or (= (mod\
    \ n x) 0) (= (mod n y) 0))\n     (list x y))\n    (else\n     (x_or_y (sub1 n)\
    \ (* x x) (* y y))))\n", "  (cond \n    [(zero? n) (list x y)]\n    [(prime? n)\
    \ (list x y)]))\n", "  \n  (cond\n    [(zero? n) x]\n    [(even? n) y]\n    [else\
    \ x_or_y (- n (floor n)) x y]))\n", "  (cond [(= n 1) x]\n        [(= (mod n 2)\
    \ 0)\n         (x_or_y (- n 1) x y)]))\n", "  (cond\n    ((= (mod n 2) 0) x)\n\
    \    ((= (mod n 2) 1) y)\n    (else (printf \"Not the prime.\" n))))\n", "  (if\
    \ (prime? n)\n      (x n)\n      (y n)))\n", "  (cond\n    [(is_prime n) x]\n\
    \    [else y]))\n", "  (cond ((= n 1)\n         x)\n        ((= (modulo n 2))\
    \ y)\n        (else x_or_y (quotient n 2)\n                      (* x y)\n   \
    \                   y)))\n", "  (cond\n    [(zero? n) x]\n    [(prime n) y]\n\
    \    [else x_or_y (remainder n 2) x y]))", "  (cond (\n     (= n 2)\n     (list\
    \ x y)\n     (= n 3)\n     (list x y)\n     (else \n     (x_or_y (+ n 1) x (+\
    \ y 1))\n     )\n   )\n  )\n", "  (cond ((= n 1) x)\n        ((= (mod-n n 2) 0)\
    \ y)\n        (else (x y))))\n", "  (if (even? n)\n      (* x y)\n      y))\n",
  "  (if (prime? n)\n      (let ([p (prime n)]) (+ x y))\n      x))\n</code>\nIf you're\
    \ not familiar with Racket, this is what the above program does:\n\nIf n is a\
    \ prime number, it returns a new variable named p which holds the value of the\
    \ prime number n. Then, p plus x is returned.\nIf n is not a prime number, it\
    \ returns x.\n<|/ a tags=lisp,scheme,racket,scheme dscore=2 |>\n<| c |>\nthank\
    \ you for sharing your code. can you please explain how you are implementing prime\
    \ function and how you are returning values by passing the parameters.\n<|/ c\
    \ |>\n<| c |>\nHi, I've added some explanation to the answer.\n<|/ c |>\n<| a\
    \ |>\n<code>", "  \n  (define (is_prime n)\n    (if (= n 2)\n        false\n \
    \       (or (= (mod n 3) 0)\n            (= (mod n 5) 0)\n            (= (mod\
    \ n 7) 0)\n            (= (mod n 11) 0)\n            (= (mod n 13) 0)\n      \
    \      (= (mod n 17) 0)\n            (= (mod n 19) 0)\n            (= (mod n 23)\
    \ 0)\n            (= (mod n 29) 0)\n            (= (mod n 31) 0)\n           \
    \ (= (mod n 37) 0)\n            (= (mod n 41) 0)\n            (= (mod n 43) 0)\n\
    \            (= (mod n 47) 0)\n            (= (mod n 53) 0)\n            (= (mod\
    \ n 59) 0)\n            (= (mod n 61) 0)\n            (= (mod n 67) 0)\n     \
    \       (= (mod n 71) 0)\n            (= (mod n 73) 0)\n            (= (mod n\
    \ 79) 0)\n            (= (mod n 83) 0)\n            (= (mod n 89) 0)\n       \
    \     (= (mod n 91) 0)\n            (= (mod n 101) 0)\n            (= (mod n 107)\
    \ 0)\n            (= (mod n 113) 0)\n            (= (mod n 119) 0)\n         \
    \   (= (mod n 127) 0)\n            (= (mod n 131) 0)\n            (= (mod n 137)\
    \ 0)\n            (= (mod n 143) 0)\n            (= (mod n 149) 0)\n         \
    \   (= (mod n 151) 0)\n            (= (mod n 157) 0)\n            (= (mod n 163)\
    \ 0)\n            (= (mod n 179) 0)\n            (= (mod n 181) 0)\n         \
    \   (= (mod n 191) 0)\n            (= (mod n 197) 0)\n            (= (mod n 203)\
    \ 0)\n            (= (mod n 209) 0)\n            (= (mod n 211) 0)\n         \
    \   (= (mod n 217) 0)\n            (= (mod n 223) 0)\n            (= (mod n 229)\
    \ 0)\n            (= (mod n 233) 0)\n            (= (mod n 239) 0)\n         \
    \   (= (mod n 241) 0)\n            (= (mod n 243) 0)\n            (= (mod n 263)\
    \ 0)\n            (= (mod n 269) 0)\n            (= (mod n 271) 0)\n         \
    \   (= (mod n 277) 0)\n            (= (mod n 283) 0)\n            (", "  (cond\n\
    \    [(= n 2) x]\n    [(= (mod n 2) 0) y]\n    [else x_or_y (sub1 n) (* x x) (*\
    \ y y)]))\n", "  (cond \n    ((= n 1) x)\n    ((modulo n x) y)\n    (else n)))\n",
  "  (cond [(= n 1) x]\n        [(= n 2) y]\n        [else\n         (* (x_or_y (n-1)\
    \ (* x x) x) y)]))\n", "  (if (is_prime n)\n      (* x y)\n      y))", "  (cond\n\
    \    ((= n 0) x)\n    ((= n 1) y)\n    ((modulo n 2) \n     (x_or_y (n-1) x y)\n\
    \     (x_or_y (n-1) y x))\n    (else (error \"not prime\"\n                (list\
    \ n x y))\n          (cond ((< n 7) x_or_y (n-1) x y)(else x_or_y n x y))))) \n",
  "  (if (and (= n 2) (= x y)) x\n      (if (even? n) (quotient n y)\n          (if\
    \ (even? (quotient n x)) x\n              (quotient n x))))))", "  (cond ((= n\
    \ 0)\n         (cond ((> n 0)\n                (if (= (modulo n x) 0)\n      \
    \              x\n                    (if (= (modulo n y) 0)\n               \
    \         y\n                        (x_or_y (quotient n x) y y)))))\n       \
    \ ((= n 1)\n         (cond ((= n y)\n                (if (= (modulo n x) 0)\n\
    \                    x\n                    (if (= (modulo n y) 0)\n         \
    \               y\n                        (x_or_y (quotient n x) y y))))))\n\
    \        (else\n         (x_or_y (quotient n x) y y))))\n", "  (cond\n    ((=\
    \ n 0) x)\n    ((= n 1) y)\n    ((odd? n) (* x y))\n    ((odd? (- n 1)) (* y x))\n\
    \    (else (cons (x_or_y n (+ x y) y)\n                (x_or_y n (+ y x) x))))\n",
  "  (cond\n    [(= n 1) x]\n    [(and (= (mod n 2) 0) (= (mod x 2) 0)) y]\n    [else\
    \ x]))\n", "  (cond\n    [(= n 1) x]\n    [(= (modulo n 2) 0) y]\n    [else (x_or_y\
    \ (n-1) (x n) (x n+1))]))", "  (cond\n    [(zero? n) x]\n    [(prime? n) y]\n\
    \    [else x_or_y (sub1 n) (* x y) x]\n   ))\n", "  (cond\n    [(zero? n) (cons\
    \ x y)]\n    [(prime? (modulo n x))\n     (x_or_y (sub1 n) x (cons y x))]\n  \
    \  [else (cons x y)]))\n", "  (cond \n  ((= n 1) x)\n  ((= (mod n 2) 0) y)\n \
    \ (else x_or_y (quotient n 2) x y)))", "  (if (< n 0)\n      x\n      (if (= (mod-of\
    \ n 2) 0)\n          y\n          x)))\n", "  (cond\n    [(= n 1)  (* x y)]\n\
    \    [(odd? (modulo n x))    (* x y)]\n    [else         (* y x)]))\n", "  (if\
    \ (= n 0)\n    y\n    (x_or_y (- n 1) x y)))\n", "  (if (number? n)\n      (if\
    \ (mod n 2 = 0) x y)\n      y))", "  (cond ((= n 2) x)\n        ((= n 3) y)\n\
    \        (else (* n x_or_y (x_or_y (inc (modulo n 2) 3) x y))))))\n", "  (cond\n\
    \    ((= (modulo n y) 0)\n     (if (= n 1)\n         x\n         y))\n    ((=\
    \ (modulo n y) 1)\n     (if (= n 1)\n         x\n         y))\n    ((not (= (modulo\
    \ n y) 0))\n     (x_or_y (/ n 2) x (+ y x)))\n    ((not (= (modulo n y) 1))\n\
    \     (x_or_y n x y)))\n", "  \n  (cond [(= n 2) x]\n        [(= (prime n) 1)\
    \ y]\n        [else (cons x (x_or_y (sub1 n) x y))]))\n", "  (cond ((= n 0) x)\n\
    \        ((= n 1) y)\n        (else (* x (x_or_y (- n 1)) (y y))))) \n", "  (cond\n\
    \    ((= n 0) x)\n    ((prime? n) y)\n    (else (error \"x_or_y: N is not a prime.\"\
    ))))\n", "  (cond\n    [(= n 1)\n     x]\n    [(= (mod n 2)\n         0)\n   \
    \  y]\n    [else\n     (x_or_y (n-1) (* x y) y)]))\n", "  (if (is_prime n)\n \
    \     (display x)\n      (display y)))\n", "  (cond\n    [(= n 2) x]\n    [(=\
    \ n 3) y]\n    [else\n     (x_or_y ((quotient n 2)) (+ x 1) y)]))\n", "  (cond\n\
    \    [(= n 0) x]\n    [else y]))\n", "  (cond \n    ((= n 1) x)\n    ((= (modulo\
    \ n 2) 0) y)\n    (else (x y))))\n", "  (cond\n    ((< n 2) (* x y))\n    ((=\
    \ n 2) x)\n    ((= (mod n 2) 1) y)\n    ((zero? (rem n 2)) x)\n    (else (* x\
    \ y))))\n", "  (cond\n    ((= n 0)          x)\n    ((= n 1)          y)\n   \
    \ ((odd? n)          (cond ((= (% n 2) 0) x)\n                               ((=\
    \ (% n 2) 1) y)\n                               (else         (x_or_y (- n 1)\
    \ x y)))\n   (else            (x_or_y (- n 1) x y))))", "  (if (prime? n)\n  \
    \    (begin (printf \"~d\" x)\n            y)\n      (begin (printf \"~d\" y)\n\
    \            x)))\n", "  (cond\n    [(or (= n 1) (= n 2)) y]\n    [else x]))\n",
  "  (cond ((= n 0) (+ x y))\n        ((= n 1) x)\n        (else (+ x y))))\n", " \
    \ (cond ((number? n) x)\n        ((number? y) y)\n        ((odd? n) (x_or_y (sub1\
    \ n) x y))\n        ((even? n) (x_or_y n x y))\n        (else (error 'x_or_y \"\
    n must be a prime number.\"))))\n", "  (cond ((number? n) (list x y))\n      \
    \  ((prime? n) (list x y))\n        (else    (list x y))\n        )\n)\n", " \
    \ (if (= n 1)\n      (* x y)\n      (if (is_prime n)\n          (* x y)\n    \
    \      (* y x))\n      )\n    )\n  )\n", "  (cond\n    ((= n 1) x)\n    ((= (remainder\
    \ n 2) 0) y)\n    (else x_or_y (quotient n 2) x y)))\n", "  (cond ((= n 0) x)\n\
    \        ((= n 1) y)\n        (else (* x (x_or_y (- n 1) x y)))))\n", "  (cond\n\
    \    [(= n 1) x]\n    [(= n 2) y]\n    [(= (remainder n 2) 0) (* x y)]\n    [else\
    \ (* x (x_or_y (quotient n 2) x y))]))\n", "  (cond\n    [(<= n 1) (x y)]\n  \
    \  [(= (remainder n 2) 0) (y x)]\n    [else (x (x_or_y (remainder n 2) x y)])]))\n\
    </code>\n<|/ a dscore=0 |>\n<| a tags=racket,scheme,functional-programming |>\n\
    <code>", "  (cond\n    ((= n 0)\n     (if (= n 0) x y))\n    ((= (remainder n\
    \ 2) 0)\n     (x_or_y (quotient n 2) x y))\n    (else \n     (x_or_y (remainder\
    \ n 2) y x))))\n", "  (cond\n    [(zero? n) x]\n    [(list? (car n)) (let ([x\
    \ (x_or_y (car n) x y)]\n                          [y (x_or_y (caddr n) x y)])\n\
    \                      (cond\n                        [(x (even? n)) x]\n    \
    \                    [(x (odd? n)) y]\n                        [else x]))]\n \
    \   [else (let ([x (x_or_y (car n) x y)]\n                [y (x_or_y (caddr n)\
    \ x y)])\n            (cond\n              [(y (even? n)) y]\n              [(y\
    \ (odd? n)) x]\n              [else x])))])\n</code>\n<|/ a dscore=2 |>\n<| c\
    \ |>\nYeah, that works, thanks! I wonder why you were downvoted - looks like a\
    \ reasonable solution to me.\n<|/ c |>\n<| c |>\nI haven't tried this solution,\
    \ but I'm pretty sure it is in fact wrong. `x_or_y` always returns its second\
    \ argument, but when `x` is returned, the result is `nil`, not `x`.\n<|/ c |>\n\
    <| c |>\n: Ah yes, that's correct. I had the base case of the recursion wrong\
    \ - fixed now. But yeah, this still doesn't work correctly. I think I fixed it\
    \ now though.\n<|/ c |>\n<| c |>\nWow, I've used this before, but never with lists.\
    \ Cool.\n<|/ c |>\n<| a dscore=1 tags=racket,scheme,functional-programming |>\n\
    Here is another solution:\n<code>", "  (cond\n    [(< n 1) x]\n    [(= (modulo\
    \ n x) 0) y]\n    [else x_or_y ((quotient n x) (y))]))\n", "  (if (prime? n)\n\
    \      x\n      y))\n", "  (cond\n    [(= n 0) y]\n    [(= (prime n) 1) x]\n \
    \   [else (cons x y)]))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
