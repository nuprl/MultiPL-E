name: HumanEval_36_fizz_buzz
language: rkt
prompt: "#lang racket\n\n;; Return the number of times the digit 7 appears in integers\
  \ less than n which are divisible by 11 or 13.\n;; >>> (fizz_buzz 50)\n;; 0\n;;\
  \ >>> (fizz_buzz 78)\n;; 2\n;; >>> (fizz_buzz 79)\n;; 3\n(define (fizz_buzz n)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate fizz_buzz))\n\
  \    (check-equal? (candidate 50) 0)\n    (check-equal? (candidate 78) 2)\n    (check-equal?\
  \ (candidate 79) 3)\n    (check-equal? (candidate 100) 3)\n    (check-equal? (candidate\
  \ 200) 6)\n    (check-equal? (candidate 4000) 192)\n    (check-equal? (candidate\
  \ 10000) 639)\n    (check-equal? (candidate 100000) 8026)\n))\n\n(test-humaneval)"
completions: ["  (if (= n 0)\n      '0\n      (cond\n        ((= (modulo n 11) 0)\n\
    \         (if (= (modulo n 13) 0)\n             '0\n             '1))\n      \
    \  ((= (modulo n 13) 0)\n         (if (= (modulo n 11) 0)\n             '1\n \
    \            '2)))))\n", "  (cond [(= (mod* n 11 13) 0)\n         (count 0 (mod\
    \ n 11 13))\n         ]\n        [else\n         (cond [(= (mod n 11) 0)\n   \
    \            (count 0 (+ 1 ))\n               ]\n                 [(= (mod n 13)\
    \ 0)\n                  (count 1 (+ 1 ))\n                  ]\n              \
    \   [else\n                  (cond [(= (mod n 11) 0)\n                       \
    \  (count 1 (+ 1 ))\n                         ]\n                           [(=\
    \ (mod n 13) 0)\n                            (count 2 (+ 1 ))\n              \
    \              ]\n                           [else\n                         \
    \   (count 3 (+ 1 ))\n                            ]\n                        \
    \   )\n                  ]\n                )\n         ]\n        ))\n", "  (if\
    \ (= n 0)\n      0\n      (if (= (modulo n 11) 0)\n          (if (= (modulo n\
    \ 13) 0)\n              (+ 1 (fizz_buzz (- n 1)))\n              (+ 1 (fizz_buzz\
    \ (- n 2))))\n          (if (= (modulo n 11) 1)\n              (+ 1 (fizz_buzz\
    \ (- n 1)))\n              (+ 1 (fizz_buzz (- n 2)))))))\n", "  (cond\n    [(zero?\
    \ n) 0]\n    [(zero? (modulo n 11)) (modulo n 11)]\n    [(zero? (modulo n 13))\
    \ (modulo n 13)]\n    [else (+ 1 (fizz_buzz (sub1 n)))]))\n</code>\n<|/ a dscore=0\
    \ tags=lisp,racket,scheme |>\n<| c |>\nSadly, this only works for `integer` and\
    \ not `real`\n<|/ c |>\n<| c |>\nI'm glad it helps! `integer` has a `modulo` function\
    \ that will work for any non-negative `real`.\n<|/ c |>\n<| c |>\n`integer` isn't\
    \ an integral datatype; `real` is the closest thing to an integral datatype. `integer`\
    \ is an alias for `long`.\n<|/ c |>\n<| c |>\nHm, `integer` is an alias for `long`\
    \ in some implementations. I *think* it's only an alias for `long` in Racket though,\
    \ but I'm not sure.\n<|/ c |>\n<| c |>\nIn Racket `real` is implemented as a double\
    \ precision floating point number internally, and thus `integer` and `long` are\
    \ *not* aliases. In any Scheme implementation where `long` is an alias for `integer`\
    \ it's possible to use `real` instead of `integer`. But Racket doesn't do that.\n\
    <|/ c |>\n<| a dscore=0 |>\nHere are some versions that use division:\n<code>",
  "  (let* ([remainder (remainder n 10)]\n         [divisor (or (mod n 11) (mod n\
    \ 13))]\n         [count 0])\n    (if (zero? divisor)\n        count\n       \
    \ (fizz_buzz (+ remainder divisor)))))\n", "  (if (zero? n)\n      0\n      (if\
    \ (or (< n (mod 11)) (< n (mod 13)))\n          (+ 1 (fizz_buzz (div (modulo-by-two\
    \ n) 10))\n               (fizz_buzz (div (modulo-by-three n) 15))\n         \
    \      (fizz_buzz (div (modulo-by-four n) 20))\n               (fizz_buzz (div\
    \ (modulo-by-five n) 25))\n               (fizz_buzz (div (modulo-by-six n) 30))\n\
    \               (fizz_buzz (div (modulo-by-seven n) 35))\n               (fizz_buzz\
    \ (div (modulo-by-eight n) 40))\n               (fizz_buzz (div (modulo-by-five\
    \ n) 45))\n               (fizz_buzz (div (modulo-by-four n) 50))\n          \
    \     (fizz_buzz (div (modulo-by-three n) 55))\n               (fizz_buzz (div\
    \ (modulo-by-two n) 60))\n               (fizz_buzz (div (modulo-by-one n) 65))\n\
    \               (fizz_buzz (div (modulo-by-zero n) 70))\n               (fizz_buzz\
    \ (div (modulo-by-two n) 75))\n               (fizz_buzz (div (modulo-by-three\
    \ n) 80))\n               (fizz_buzz (div (modulo-by-four n) 85))\n          \
    \     (fizz_buzz (div (modulo-by-five n) 90))\n               (fizz_buzz (div\
    \ (modulo-by-six n) 95))\n               (fizz_buzz (div (modulo-by-seven n) 100))\n\
    \               (fizz_buzz (div (modulo-by-eight n) 105))\n               (fizz_buzz\
    \ (div (modulo-by-five n) 110))\n               (fizz_buzz (div (modulo-by-four\
    \ n) 115))\n               (fizz_buzz (div (modulo-by-three n) 120))\n       \
    \        (fizz_buzz (div (modulo-by-two n) ", "  (loop for x from 0 to n\n   \
    \     when (mod x 11) or (mod x 13) count 1)\n  (count\n   (for x from 0 to n\n\
    \        when (and (= (mod x 11) 7) \n                 (= (mod x 13) 7))\n   \
    \      count 1)))\n", "  (cond\n    [(< n 0)\n     0]\n    [(= (modulo n 11) 0)\n\
    \     1]\n    [(= (modulo n 13) 0)\n     3]\n    [else\n     (+ (fizz_buzz (sub1\
    \ n))\n        (* 2 (fizz_buzz (sub1 n))))]))\n", "  (define (f n1 n2)\n    (cond\
    \ ((= (modulo n1 11) (modulo n2 11))\n           (cond ((= (modulo n1 13) (modulo\
    \ n2 13))\n                   (+ (modulo n1 7)\n                      (modulo\
    \ n2 7)))\n                   ((= (modulo n1 13) (modulo n2 11))\n           \
    \        (+ (modulo n1 7)\n                       (modulo n2 13)))\n         \
    \          ((= (modulo n1 11) (modulo n2 13))\n                   (+ (modulo n1\
    \ 7)\n                       (modulo n2 11))))\n          ((= (modulo n1 13) (modulo\
    \ n2 13))\n           (cond ((= (modulo n1 11) (modulo n2 11))\n             \
    \      (+ (modulo n1 7)\n                       (modulo n2 7)))\n            \
    \      ((= (modulo n1 13) (modulo n2 11))\n                   (+ (modulo n1 7)\n\
    \                       (modulo n2 13)))\n                  ((= (modulo n1 11)\
    \ (modulo n2 13))\n                   (+ (modulo n1 7)\n                     \
    \  (modulo n2 11))))))\n    (cond ((= n 0)\n           0)\n          ((= n 1)\n\
    \           1)\n          ((= n 2)\n           1)\n          ((f (quotient n 10)\
    \ 10)\n           (+ 1 (f (quotient n 10) 10)))\n          ((f (quotient n 10)\
    \ 13)\n           (+ 2 (f (quotient n 10) 13)))\n          ((f (quotient n 10)\
    \ 11)\n           (+ 3 (f (quotient n 10) 11)))\n          (else\n           (+\
    \ 4 (f (quotient n 10) 11))))))\n", "  (if (= n 0)\n      0\n      (if (= (mod\
    \ n 11) 0)\n          (if (= (mod n 13) 0)\n              (if (= (mod n 17) 0)\n\
    \                  (if (= (mod n 19) 0)\n                      (if (= (mod n 23)\
    \ 0)\n                          (if (= (mod n 27) 0)\n                       \
    \       (if (= (mod n 31) 0)\n                                  (if (= (mod n\
    \ 35) 0)\n                                      (if (= (mod n 39) 0)\n       \
    \                                   (if (= (mod n 43) 0)\n                   \
    \                           (if (= (mod n 47) 0)\n                           \
    \                       (if (= (mod n 51) 0)\n                               \
    \                       (if (= (mod n 55) 0)\n                               \
    \                           (if (= (mod n 59) 0)\n                           \
    \                                   (if (= (mod n 63) 0)\n                   \
    \                                               (if (= (mod n 67) 0)\n       \
    \                                                               (if (= (mod n\
    \ 71) 0)\n                                                                   \
    \       (if (= (mod n 75) 0)\n                                               \
    \                               (if (= (mod n 79) 0)\n                       \
    \                                                           (if (= (mod n 83)\
    \ 0)\n                                                                       \
    \               (if (= (mod n 87) 0)\n                                       \
    \                                                   (if (= (mod n 91) 0)\n   \
    \                                                                            \
    \               (if (= (mod n 95) 0)\n                                       \
    \                                                           (if (= (mod n 99)\
    \ 0)\n                                                                       \
    \                               (if (= (mod n 103) 0)\n                      \
    \                                                                            \
    \        (if (= (mod n 107) 0)\n                                             \
    \                                                                 (if (= (mod\
    \ n 111) 0)\n                                                                \
    \                                                  (if (= (mod n 115) 0)\n   \
    \                                                                            \
    \                                       (if (= (mod n 119) 0)\n              \
    \                                                                            \
    \                                (if (= (mod n 123) 0)\n                     \
    \                                                                            \
    \                             (if (= (mod n 127) 0)\n                        \
    \                                                                            \
    \                              (if (= (mod n 131) 0)\n                       \
    \                                                                            \
    \                                   (if (= (mod n 135) 0)\n                  \
    \                                                                            \
    \                                            (if (= (mod n 139) 0)\n         \
    \                                                                            \
    \                                                         (if (= (mod n 143) 0)\n\
    \                                                                            \
    \                                                                      (if (=\
    \ (mod n 147) 0)\n                                                           \
    \                                                                            \
    \               (if (= (mod n 151) 0)\n                                      \
    \                                                                            \
    \                                        (if (= (mod n 155) 0)\n             \
    \                                                                            \
    \                                                                     (if (= (mod\
    \ n 159) 0)\n                                                                \
    \                                                                            \
    \                      (if (= (mod n 163) 0)\n                               \
    \                                                                            \
    \                                                           (if (= (mod n 167)\
    \ 0)\n                                                                       \
    \                                                                            \
    \                       (if (= (mod n 171) 0)\n                              \
    \                                                                            \
    \                                                                    (if (= (mod ",
  "  (cond\n    ((= n 0) 0)\n    ((= n 1) 0)\n    ((= (modulo n 11) 0) 2)\n    ((=\
    \ (modulo n 13) 0) 3)\n    ((= (modulo n 17) 0) 4)\n    ((= (modulo n 19) 0) 5)\n\
    \    ((= (modulo n 21) 0) 6)\n    ((= (modulo n 23) 0) 7)\n    ((= (modulo n 25)\
    \ 0) 8)\n    ((= (modulo n 27) 0) 9)\n    ((= (modulo n 29) 0) 10)\n    ((= (modulo\
    \ n 31) 0) 11)\n    ((= (modulo n 33) 0) 12)\n    ((= (modulo n 35) 0) 13)\n \
    \   ((= (modulo n 37) 0) 14)\n    ((= (modulo n 39) 0) 15)\n    ((= (modulo n\
    \ 41) 0) 16)\n    ((= (modulo n 43) 0) 17)\n    ((= (modulo n 45) 0) 18)\n   \
    \ ((= (modulo n 47) 0) 19)\n    ((= (modulo n 49) 0) 20)\n    ((= (modulo n 51)\
    \ 0) 21)\n    ((= (modulo n 53) 0) 22)\n    ((= (modulo n 55) 0) 23)\n    ((=\
    \ (modulo n 57) 0) 24)\n    ((= (modulo n 59) 0) 25)\n    ((= (modulo n 61) 0)\
    \ 26)\n    ((= (modulo n 63) 0) 27)\n    ((= (modulo n 65) 0) 28)\n    ((= (modulo\
    \ n 67) 0) 29)\n    ((= (modulo n 69) 0) 30)\n    ((= (modulo n 71) 0) 31)\n \
    \   ((= (modulo n 73) 0) 32)\n    ((= (modulo n 75) 0) 33)\n    ((= (modulo n\
    \ 77) 0) 34)\n    ((= (modulo n 79) 0) 35)\n    ((= (modulo n 81) 0) 36)\n   \
    \ ((= (modulo n 83) 0) 37)\n    ((= (modulo n 85) 0) 38)\n    ((= (modulo n 87)\
    \ 0) 39)\n    ((= (modulo n 89) 0) 40)\n    ((= (modulo n 91) 0) 41)\n    ((=\
    \ (modulo n 93) 0) 42)\n    ((= (modulo n 95) 0) 43)\n    ((= (modulo n 97) 0)\
    \ 44)\n    ((= (modulo n 99", "  (cond\n    [(<= n 0) \"Not divisible by 11 or\
    \ 13.\"]\n    [(= (remainder n 3) 0) \"Not divisible by 11.\"]\n    [(= (remainder\
    \ n 5) 0) \"Not divisible by 13.\"]\n    [else (+ 1 (count-7-digit n)))]))\n",
  "  (if (>= n 0)\n      (+ 1 (- n (remainder (quotient n 11) 11))\n           (-\
    \ n (remainder (quotient n 13) 13))\n           (fizz_buzz (quotient n 11))\n\
    \           (fizz_buzz (quotient n 13))\n           (fizz_buzz (quotient n 1))\n\
    \           (fizz_buzz (quotient n 7))\n           (fizz_buzz (quotient n 15))\n\
    \           (fizz_buzz (quotient n 17))\n           (fizz_buzz (quotient n 19))\n\
    \           (fizz_buzz (quotient n 25))\n           (fizz_buzz (quotient n 35))\n\
    \           (fizz_buzz (quotient n 43))\n           (fizz_buzz (quotient n 53))\n\
    \           (fizz_buzz (quotient n 63))\n           (fizz_buzz (quotient n 73))\n\
    \           (fizz_buzz (quotient n 83))\n           (fizz_buzz (quotient n 93))\n\
    \           (fizz_buzz (quotient n 103))\n           (fizz_buzz (quotient n 113))\n\
    \           (fizz_buzz (quotient n 123))\n           (fizz_buzz (quotient n 131))\n\
    \           (fizz_buzz (quotient n 141))\n           (fizz_buzz (quotient n 151))\n\
    \           (fizz_buzz (quotient n 161))\n           (fizz_buzz (quotient n 171))\n\
    \           (fizz_buzz (quotient n 181))\n           (fizz_buzz (quotient n 191))\n\
    \           (fizz_buzz (quotient n 201))\n           (fizz_buzz (quotient n 211))\n\
    \           (fizz_buzz (quotient n 221))\n           (fizz_buzz (quotient n 231))\n\
    \           (fizz_buzz (quotient n 241))\n           (fizz_buzz (quotient n 251))\n\
    \           (fizz_buzz (quotient n 261))\n           (fizz_buzz (quotient n 271))\n\
    \           (fizz_buzz (quotient n 281))\n           (fizz_buzz (quotient n 291))\n\
    \           (fizz_buzz (quotient n 301))\n           (fizz_buzz (quoti", "  (cond\n\
    \    [(< n 0) '()]\n    [(even? n) (cons (cons n '(7)) (fizz_buzz (- n 1)))]\n\
    \    [(odd? n) (cons n (fizz_buzz (/ n 11)))]))\n", "  (let loop ((n n)\n    \
    \         (ns '(7 11 13))\n             (digits '(0 1 2 3 4 5 6 7 8 9)))\n   \
    \ (cond\n      [(zero? n) 0]\n      [(member (modulo n 10) ns) (+ 1 (loop (quotient\
    \ n 10) ns digits))]\n      [else (+ 1 (loop (quotient n 10) ns digits))])))\n",
  "  (loop for i from 0 to n and ((remainder (/ i 11) 7) < (remainder (/ i 13) 7))\n\
    \        collect (+ i 1)))\n", "  (let ([d (quotient n 11)]\n        [c (remainder\
    \ n 11)]\n        [h (quotient n 13)]\n        [l (remainder n 13)]\n        [s\
    \ (quotient n 7)]\n        [z (remainder n 7)])\n    (cond [(zero? n) 0]\n   \
    \       [(or (zero? d) (c)) (+ 1 z)]\n          [(or (zero? h) l) (+ 1 z)]\n \
    \         [(or (zero? s) d) (+ 1 z)]\n          [(or (zero? c) h) (+ 1 z)]\n \
    \         [(or (zero? l) s) (+ 1 z)]\n          [(or (zero? h) s) (+ 1 z)]\n \
    \         [(or (zero? d) c) (+ 1 z)]\n          [(or (zero? l) h) (+ 1 z)]))\n\
    \  )\n", "  (cond\n    [(= n 0) 0]\n    [(= n 1) 1]\n    [(= (modulo n 11) 0)\
    \ 2]\n    [(= (modulo n 13) 0) 3]\n    [else (fizz_buzz (quotient n 10))]))\n",
  "  (cond\n    [(< n 100) 0]\n    [(< n 1000) (+ 1 (fizz_buzz (/ n 100)))]\n    [(<\
    \ n 100000) (+ 1 (fizz_buzz (/ n 1000)))]\n    [(< n 1000000) (+ 1 (fizz_buzz\
    \ (/ n 10000)))]\n    [(< n 100000000) (+ 1 (fizz_buzz (/ n 100000)))]\n    [else\
    \ (+ 1 (fizz_buzz (/ n 1000000)))]))\n", "  (local ((define (count n)\n      \
    \       (let loop ((n n) (count 0))\n               (cond ((< n 0) 0)\n      \
    \               ((and (even? (modulo n 11))\n                          (even?\
    \ (modulo n 13)))\n                      (+ 1 (loop (quotient n 11) (+ 1 count))))\n\
    \                     (else (+ 1 (loop (quotient n 13) (+ 1 count)))))))\n   \
    \        (count n)))\n</code>\n<|/ a dscore=1 |>\n<| a tags=racket,scheme |>\n\
    Here's a solution that uses only primitive operations. I believe it is more readable\
    \ and easier to understand. Also, I think it scales well for large numbers of\
    \ divisors. You will want to test it with larger numbers of divisors.\n<code>",
  "  (cond\n    [(= n 1)\n     (number->string n)]\n    [(= (mod n 11) 0) (number->string\
    \ n)]\n    [(= (mod n 13) 0)\n     (number->string n)]\n    [else\n     (let ([count\
    \ (number->string n)])\n       (string-append \"7 \"\n                     (fizz_buzz\
    \ (- n 7)))))]))\n", "  (let loop ((n n) (acc 0))\n    (cond ((= n 0)\n      \
    \     (if (= (remainder n 11) 0) acc (loop (quotient n 11) (+ acc 1))))\n    \
    \      ((= n 1)\n           (if (= (remainder n 13) 0) acc (loop (quotient n 13)\
    \ (+ acc 1))))\n          (else\n           (loop (quotient n 10) acc)))))\n",
  "  (cond [(< n 13)\n         (cond [(= (remainder n 11) 7)\n                (+ n\
    \ 1)\n                (fizz_buzz (quotient n 11))\n                (fizz_buzz\
    \ (quotient n 13))]\n               [(= (remainder n 11) 0)\n                (+\
    \ n 1)\n                (fizz_buzz (quotient n 11))\n                (fizz_buzz\
    \ (quotient n 13))]\n               [(= (remainder n 13) 7)\n                (+\
    \ n 1)\n                (fizz_buzz (quotient n 13))]\n               [(= (remainder\
    \ n 13) 0)\n                (+ n 1)\n                (fizz_buzz (quotient n 13))]\n\
    \               [(= (remainder n 11) 0)\n                (+ n 1)\n           \
    \     (fizz_buzz (quotient n 13))]\n               [(= (remainder n 11) 7)\n \
    \               (+ n 1)\n                (fizz_buzz (quotient n 13))]\n      \
    \         [(= (remainder n 13) 0)\n                (+ n 1)\n                (fizz_buzz\
    \ (quotient n 13))])]\n        [(= n 0)\n         (cond [(= (remainder n 11) 7)\n\
    \                (+ n 1)\n                (fizz_buzz (quotient n 11))\n      \
    \          (fizz_buzz (quotient n 13))]\n               [(= (remainder n 11) 0)\n\
    \                (+ n 1)\n                (fizz_buzz (quotient n 11))\n      \
    \          (fizz_buzz (quotient n 13))]\n               [(= (remainder n 13) 7)\n\
    \                (+ n 1)\n                (fizz_buzz (quotient n 13))]\n     \
    \          [(= (remainder n 13) 0)\n                (+ n 1)\n                (fizz_buzz\
    \ (quotient n 13))]\n               [(= (remainder n 11) 7)\n                (+\
    \ n 1)\n                (fizz_buzz (quotient n 13))]\n               [(= (remainder\
    \ n 11) 0)\n                (+ n 1)\n                (fizz_buzz (quotient n 13))]\n\
    \               [(= (remainder n 13) 7)\n                (+ n 1)\n           \
    \     (fizz_buzz (quotient n 13))]\n               [(= (remainder n 13) 0)\n \
    \               (+ n 1)\n                (fizz_buzz (quotient n 13))])]\n    \
    \    [else\n", "  (cond\n    ((= n 0)\n     0)\n    ((= n 1)\n     1)\n    ((even?\
    \ n)\n     (if (= (modulo n 11)\n             (modulo n 13))\n         1)\n  \
    \   (+ 3 (fizz_buzz (- n 1)))))\n", "  (cond [(= n 0)\n         0]\n        [(=\
    \ (modulo n 11) 0)\n         (cond [(= (modulo n 13) 0)\n                (+ (fizz_buzz\
    \ (- n 13))\n                    (fizz_buzz (- n 11)))]\n              [else\n\
    \                (+ (fizz_buzz (- n 13))\n                    (fizz_buzz (- n\
    \ 11)))])]\n        [(= (modulo n 13) 0)\n         (fizz_buzz (- n 13))]))\n",
  "  (cond\n    [(= n 1) 0]\n    [(= (modulo n 11) 13) (+ 1 (fizz_buzz (quotient n\
    \ 11)))]\n    [else (+ 1 (fizz_buzz (quotient n 11)))]))\n", "  (let ((cnt 0))\n\
    \    (cond\n      [(< n 0) cnt]\n      [(= (modulo n 11) 0) (+ 1 (fizz_buzz (quotient\
    \ n 11)))]\n      [(= (modulo n 13) 0) (+ 1 (fizz_buzz (quotient n 13)))]\n  \
    \    [(= (modulo n 17) 0) (+ 1 (fizz_buzz (quotient n 17)))]\n      [(= (modulo\
    \ n 19) 0) (+ 1 (fizz_buzz (quotient n 19)))]\n      [(= (modulo n 23) 0) (+ 1\
    \ (fizz_buzz (quotient n 23)))]\n      [(= (modulo n 27) 0) (+ 1 (fizz_buzz (quotient\
    \ n 27)))]\n      [(= (modulo n 31) 0) (+ 1 (fizz_buzz (quotient n 31)))]\n  \
    \    [(= (modulo n 37) 0) (+ 1 (fizz_buzz (quotient n 37)))]\n      [(= (modulo\
    \ n 41) 0) (+ 1 (fizz_buzz (quotient n 41)))]\n      [(= (modulo n 47) 0) (+ 1\
    \ (fizz_buzz (quotient n 47)))]\n      [(= (modulo n 51) 0) (+ 1 (fizz_buzz (quotient\
    \ n 51)))]\n      [(= (modulo n 57) 0) (+ 1 (fizz_buzz (quotient n 57)))]\n  \
    \    [(= (modulo n 63) 0) (+ 1 (fizz_buzz (quotient n 63)))]\n      [(= (modulo\
    \ n 69) 0) (+ 1 (fizz_buzz (quotient n 69)))]\n      [(= (modulo n 73) 0) (+ 1\
    \ (fizz_buzz (quotient n 73)))]\n      [(= (modulo n 79) 0) (+ 1 (fizz_buzz (quotient\
    \ n 79)))]\n      [(= (modulo n 83) 0) (+ 1 (fizz_buzz (quotient n 83)))]\n  \
    \    [(= (modulo n 89) 0) (+ 1 (fizz_buzz (quotient n 89)))]\n      [(= (modulo\
    \ n 97) 0) (+ 1 (fizz_buzz (quotient n 97)))]\n      ", "  (cond\n    ((= n 0)\n\
    \     0)\n    ((or (even? n) (odd? n))\n     (if (= (mod n 11) 0)\n         (if\
    \ (= (mod n 13) 0)\n             (+ 1 (fizz_buzz (sub1 n)))\n             (+ 1\
    \ (fizz_buzz (sub1 n))))\n         (if (= (mod n 11) 0)\n             (+ 1 (fizz_buzz\
    \ (sub1 n))))\n         (if (= (mod n 13) 0)\n             (+ 1 (fizz_buzz (sub1\
    \ n))))))\n    ((= n 1)\n     (if (= (mod n 11) 0)\n         (if (= (mod n 13)\
    \ 0)\n             (+ 1 (fizz_buzz (sub1 n)))\n             (+ 1 (fizz_buzz (sub1\
    \ n))))\n         (if (= (mod n 11) 0)\n             (+ 1 (fizz_buzz (sub1 n))))\n\
    \         (if (= (mod n 13) 0)\n             (+ 1 (fizz_buzz (sub1 n))))))\n \
    \   ((= n 2)\n     (if (= (mod n 11) 0)\n         (if (= (mod n 13) 0)\n     \
    \        (+ 1 (fizz_buzz (sub1 n)))\n             (+ 1 (fizz_buzz (sub1 n))))\n\
    \         (if (= (mod n 11) 0)\n             (+ 1 (fizz_buzz (sub1 n))))\n   \
    \      (if (= (mod n 13) 0)\n             (+ 1 (fizz_buzz (sub1 n))))))\n    ((=\
    \ n 3)\n     (if (= (mod n 11) 0)\n         (if (= (mod n 13) 0)\n           \
    \  (+ 1 (fizz_buzz (sub1 n)))\n             (+ 1 (fizz_buzz (sub1 n))))\n    \
    \     (if (= (mod n 11) 0)\n             (+ 1 (fizz_buzz (sub1 n))))\n       \
    \  (if (= (mod n 13) 0)\n             (+ 1 (fizz_buzz (sub1 n))))))\n    ((= n\
    \ 4)\n     (if (= (mod n 11) 0)\n         (if (= (mod n 13) 0)\n             (+\
    \ 1 (fizz_buzz (sub1 n)))\n             (+ 1 (fizz_buzz (sub1 n))))\n        \
    \ (if (= (mod n 11) 0)\n             (+ 1 (fizz_buzz (sub1 n))))\n         (if\
    \ (= (mod n 13) 0)\n             (", "  (cond [(= n 0)\n         0]\n        [(=\
    \ (mod n 11) 0)\n         (= (mod n 13) 0)\n         2]\n        [else\n     \
    \    (+ 1 (fizz_buzz (- n 1)))]))", "  (define (loop-helper n acc)\n    (cond\n\
    \      [(= n 0)\n       (reverse acc)]\n      [else (loop-helper (sub1 n) (cons\
    \ (modulo-by n 11) acc))]))\n  (loop-helper n '()))\n", "  (cond\n    [(= n 0)\
    \ 0]\n    [(= n 1) 1]\n    [(= (modulo n 11) 0) 2]\n    [(= (modulo n 13) 0) 3]\n\
    \    [else 0]))\n", "  (cond [(= n 0)\n         0]\n        [(= (mod n 11) 0)\n\
    \         (cond [(= (mod n 13) 0)\n                (+ n 1)\n                (+\
    \ 1 (fizz_buzz (- n 1)))]\n              [(= (mod n 13) 1)\n                (+\
    \ 1 (fizz_buzz (- n 1)))\n                (+ n 1)])]\n        [(= (mod n 11) 1)\n\
    \         (+ 1 (fizz_buzz (- n 1)))\n         (+ n 1)]))\n", "  (cond [(= n 0)\
    \ 0]\n        [(and (= (modulo n 11) 7) \n               (= (modulo n 13) 7))\n\
    \         2]\n        [(and (= (modulo n 11) 7)\n               (= (modulo n 13)\
    \ 12))\n         3]\n        [(and (= (modulo n 11) 12)\n               (= (modulo\
    \ n 13) 7))\n         4]\n        [(and (= (modulo n 11) 12)\n               (=\
    \ (modulo n 13) 12))\n         5]\n        [else\n         6]\n))\n", "  (cond\
    \ ((= n 0)\n         0)\n        ((= n 11)\n         (if (even? n)\n         \
    \    0\n             (+ 3 (fizz_buzz (quotient n 11)))))\n        ((= n 13)\n\
    \         (if (odd? n)\n             0\n             (+ 3 (fizz_buzz (quotient\
    \ n 13)))))\n        (else (+ 1 (fizz_buzz (quotient n 10))))))\n", "  (cond [(<=\
    \ n 11) (fizz-buzz-helper n 0)]\n        [(<= n 13) (fizz-buzz-helper n 2)]\n\
    \        [else (fizz-buzz-helper n 3)]))\n", "  (cond [(= (modulo n 11) 0) 0]\n\
    \        [(= (modulo n 13) 0) 1]\n        [(= (modulo n 11) 13) 2]\n        [else\
    \ (fizz_buzz (quotient n 11))]))\n", "  (define (count-fizzbuzz n count)\n   \
    \ (cond\n      [(= n 0)\n       count]\n      [(= (modulo n 11) 0)\n       (count-fizzbuzz\
    \ (quotient n 11) count)\n       (count-fizzbuzz (quotient n 13) count)]\n   \
    \   [(= (modulo n 13) 0)\n       (count-fizzbuzz (quotient n 13) count)\n    \
    \   (count-fizzbuzz (quotient n 11) count)]))\n  (count-fizzbuzz n 0))\n", " \
    \ (cond\n    [(zero? n) 0]\n    [(= (modulo n 11) 0) 1]\n    [(= (modulo n 13)\
    \ 0) 2]\n    [else (fizz_buzz (sub1 n))]))\n", "  (cond [(= n 0) 0]\n        [(=\
    \ n 1) 1]\n        [(= (modulo n 11) 0) 2]\n        [(= (modulo n 13) 0) 3]\n\
    \        [else (fizz_buzz (quotient n 11))]))\n</code>\n<|/ a tags=fizzbuzz,racket,scheme\
    \ |>\n<| a tags=fizzbuzz,racket,scheme |>\nHere's a solution that uses racket's\
    \ built-in fizzbuzz procedure. The procedure accepts a number n and returns a\
    \ list containing n numbers where each of the numbers is the number \"fizzbuzz\"\
    \ concatenated with the number n (fizzbuzz n).\n<code>", "  (define (buzz-helper\
    \ x i count) #f)\n  (define (buzz-iter count i)\n    (cond\n      [(= i n) count]\n\
    \      [else (when (= (remainder i 11) (= (remainder i 13) 0))\n             \
    \   (buzz-iter (add1 count) (remainder i 11)))]\n      [else (buzz-iter count\
    \ (+ i 1))]))\n  (buzz-iter 0 1))\n", "  (define (buzz-loop n)\n    (if (= n 0)\n\
    \        0\n        (let ([m (quotient n 11)]\n              [m (quotient m 13)])\n\
    \          (if (= m 7)\n              (+ 1 (buzz-loop (quotient n 11)))\n    \
    \          (+ 1 (buzz-loop (quotient m 13)))))))\n  (buzz-loop n))\n", "  (define\
    \ (loop i counter)\n    (cond ((= i n) counter)\n          ((= (remainder n 10)\
    \ (= 11 (remainder i 10)))\n           (loop (+ i 1) (+ counter 1)))\n       \
    \   ((= (remainder n 10) (= 13 (remainder i 10)))\n           (loop (+ i 1) (+\
    \ counter 3)))\n          (else (loop (+ i 1) counter))))\n  (loop 0 0))\n", " \
    \ (cond\n    ((< n 100) 0)\n    ((< n 200) 1)\n    ((< n 300) 2)\n    ((< n 400)\
    \ 3)\n    ((< n 500) 4)\n    ((< n 600) 5)\n    ((< n 700) 6)\n    ((< n 800)\
    \ 7)\n    ((< n 900) 8)\n    ((< n 1000) 9)\n    ((< n 1100) 10)\n    ((< n 1200)\
    \ 11)\n    ((< n 1300) 12)\n    ((< n 1400) 13)\n    ((< n 1500) 14)\n    ((<\
    \ n 1600) 15)\n    ((< n 1700) 16)\n    ((< n 1800) 17)\n    ((< n 1900) 18)\n\
    \    ((< n 2000) 19)\n    ((< n 2100) 20)\n    ((< n 2200) 21)\n    ((< n 2300)\
    \ 22)\n    ((< n 2400) 23)\n    ((< n 2500) 24)\n    ((< n 2600) 25)\n    ((<\
    \ n 2700) 26)\n    ((< n 2800) 27)\n    ((< n 2900) 28)\n    ((< n 3000) 29)\n\
    \    ((< n 3100) 30)\n    ((< n 3200) 31)\n    ((< n 3300) 32)\n    ((< n 3400)\
    \ 33)\n    ((< n 3500) 34)\n    ((< n 3600) 35)\n    ((< n 3700) 36)\n    ((<\
    \ n 3800) 37)\n    ((< n 3900) 38)\n    ((< n 4000) 39)\n    ((< n 4100) 40)\n\
    \    ((< n 4200) 41)\n    ((< n 4300) 42)\n    ((< n 4400) 43)\n    ((< n 4500)\
    \ 44)\n    ((< n 4600) 45)\n    ((< n 4700) 46)\n    ((< n 4800) 47)\n    ((<\
    \ n 4900) 48)\n    ((< n 5000) 49)\n    ((< n 5100) 50)\n    ((< n 5200) 51)\n\
    \    ((< n 5300) 52)\n    ((< n 5400) 53)\n    ((< n 5500) 54)\n    ((< n 5600)\
    \ 55)\n    ((< n 5700) 56)\n    ((< n 5800) 57)\n    ((< n 5900) 58)\n    ((<\
    \ n 6000) 59)\n    ((< n 6100) 60)\n    ((< n 6200) 61)\n    ((< n 6300) 62)",
  "  (let loop ((i n)\n             (acc '()))\n    (cond ((= i 0) (cons acc '()))\n\
    \          ((= i 11) (cons (list 'fizz 'buzz) acc))\n          ((= i 13) (cons\
    \ (list 'fizz 'buzz 'fizz) acc))\n          ((< i n) (loop (- i 1) (cons (modulo-n\
    \ i) acc)))\n          :else (loop (+ i 1) acc)))))\n", "  (cond\n    ((= n 0)\
    \ 0)\n    ((= n 1) 0)\n    ((= (mod n 11) 0) 2)\n    ((= (mod n 13) 0) 3)\n  \
    \  ((= (mod n 7) 0) 4)\n    (else (fizz_buzz (sub1 n)))\n  ))\n", "  (define (fizz_buzz-helper\
    \ n)\n    (cond\n      [(< n 0) 0]\n      [(= n 0) 1]\n      [(= (modulo n 11)\
    \ 0) (fizz_buzz-helper (modulo n 13))]\n      [(= (modulo n 13) 0) (fizz_buzz-helper\
    \ (modulo n 11))]\n      [(= (modulo n 11) 0) 1]\n      [(= (modulo n 13) 0) 2]\n\
    \      [else (+ 1 fizz_buzz-helper (modulo n 11))]))\n  (fizz_buzz-helper n))\n",
  "  (cond [(< n 0)\n         (number->string n)]\n        [(= (modulo n 11) 0)\n\
    \         (number->string n)]\n        [(= (modulo n 13) 0)\n         (number->string\
    \ n)]))", "  (cond\n    [(= n 0) 0]\n    [(= n 1) 0]\n    [(= (mod n 11) 0)\n\
    \     (if (= (mod n 13) 0)\n         (+ n 1)\n         (+ n 0))]\n    [(= (mod\
    \ n 11) 0)\n     (if (= (mod n 13) 0)\n         (+ n 0)\n         (+ n 1))]\n\
    \    [else (+ n 0)]))\n", "  (define (buzz-cnt n)\n    (define (count-digits n)\n\
    \      (cond\n        ((= n 0) 0)\n        ((= n 1) 1)\n        (else (+ (count-digits\
    \ (quotient n 10)) (count-digits (remainder n 10))))))\n    (count-digits n))\n\
    \  (cond ((< n 11) (buzz-cnt n))\n        ((< n 13) (buzz-cnt n)\n         (else\
    \ (+ 1 (buzz-cnt n))))))\n", "  (count\n   (lambda (x) \n     (cond\n      [(=\
    \ (modulo x 11) 0) 1]\n      [(= (modulo x 13) 0) 2]\n      [else 0])\n     (<\
    \ x n))\n   0))\n", "  (let ([i 0])\n    (if (> n 1)\n        (let ((d (mod n\
    \ 11)))\n          (if (or (= 7 d) (= 7 0))\n              i\n              (fizz_buzz\
    \ (quotient n 11))\n              (fizz_buzz (quotient n 13))))\n        i\n \
    \       0)))\n", "  (cond\n    ((<= n 79) (+ 3 (fizz_buzz (/ n 11))))\n    ((<=\
    \ n 78) (+ 2 (fizz_buzz (/ n 13))))\n    (else 0)))\n</code>\n<|/ a dscore=2 tags=scheme\
    \ |>\n<| a dscore=2 |>\nHere's another solution, using a simple recursive function:\n\
    <code>", "  (cond\n    [(or (= n 0) (< n n)) 0]\n    [(= n 11) (+ (mod n 11) 1)]\n\
    \    [(= n 13) (+ (mod n 13) 1)]\n    [else  (fizz_buzz (- n 1))]))\n", "  (define\
    \ (helper n counter)\n    (if (zero? n)\n        counter\n        (helper (modulo\
    \ n 11) (incf counter))))\n  (helper n 0))\n", "  (cond\n    [(< n 0)\n     (cond\
    \ [(zero? n) 0]\n           [else 1])\n     ]\n    [(zero? (remainder n 11))\n\
    \     (cond [(zero? (remainder n 13)) 2]\n           [else 3])\n     ]\n    [else\
    \ (+ (fizz_buzz (quotient n 11)) (fizz_buzz (quotient n 13)))]))\n", "  (let ([i#1\
    \ (floor n 10)])\n    (cond\n      ((= i#1 7) (+ 1 (fizz_buzz (- n 1))))\n   \
    \   ((= i#1 11) (+ 1 (fizz_buzz (- n 1)))\n        (+ 1 (fizz_buzz (- n 1))))))))\n",
  "  (cond\n    ((= n 0) 0)\n    ((= (mod n 11) 0) 0)\n    ((= (mod n 13) 0) 0)\n\
    \    ((= (mod n 12) 0) 0)\n    ((= (mod n 13) 0) 0)\n    (else (+ 1 (fizz_buzz\
    \ (- n 1))))))\n", "  (define (helper n count)\n    (if (= n 0)\n        count\n\
    \        (helper (quotient n 10) (+ count 1))))\n  (helper n (helper n 0)))\n\
    </code>\nThis code is not an efficient solution, since it will run into trouble\
    \ on big numbers. You can use a memoization to avoid repeated calculations. Also\
    \ note that the inner helper function can be written in a more elegant way - it\
    \ can be written as a recursive function.\n<code>", "  (cond\n    [(< n 1) 0]\n\
    \    [(= n 13) (+ 2 1)]\n    [(= (modulo n 11) 0)\n     (cond\n       [(= (modulo\
    \ n 11) 1)\n        (cond\n         [(= (modulo n 11) 0)\n          (+ 2 1)]\n\
    \         [(= (modulo n 11) 2)\n          (+ 2 2)]\n         [(= (modulo n 11)\
    \ 3)\n          (+ 2 3)]\n         [(= (modulo n 11) 4)\n          (+ 2 4)]\n\
    \         [(= (modulo n 11) 5)\n          (+ 2 5)]\n         [(= (modulo n 11)\
    \ 6)\n          (+ 2 6)]\n         [(= (modulo n 11) 7)\n          (+ 2 (quotient\
    \ n 11))]\n         [(= (modulo n 11) 8)\n          (+ 2 8)]\n         [(= (modulo\
    \ n 11) 9)\n          (+ 2 9)]\n         [(= (modulo n 11) 10)\n          (+ 2\
    \ 10)]\n         [(= (modulo n 11) 11)\n          (+ 2 (quotient n 11))]\n   \
    \      [(= (modulo n 11) 12)\n          (+ 2 12)]\n         [(= (modulo n 11)\
    \ 13)\n          (+ 2 13)]\n         [(= (modulo n 11) 14)\n          (+ 2 14)]\n\
    \         [(= (modulo n 11) 15)\n          (+ 2 15)]\n         [(= (modulo n 11)\
    \ 16)\n          (+ 2 16)]\n         [(= (modulo n 11) 17)\n          (+ 2 17)]\n\
    \         [(= (modulo n 11) 18)\n          (+ 2 18)]\n         [(= (modulo n 11)\
    \ 19)\n          (+ 2 19)]\n         [(= (modulo n 11) 20)\n          (+ 2 20)]\n\
    \         [(= (modulo n 11) 21)\n          (+ 2 21)])]\n       [(= (modulo n 11)\
    \ 2)\n        (cond\n         [(= (modulo n 11) 0)\n          (+ 2 1)]\n     \
    \    [(= (modulo n 11) 1)\n          (+ 2 2)]\n         [(= (modulo n 11) 3)\n\
    \          (+ 2 3)]\n         [(= (modulo n 11) 4)\n          (+ 2 4)]\n     \
    \    [(= (modulo n 11) 5)\n          (+ 2 5)]\n         [(= (modu", "  (define\
    \ (count-divisors n divisors)\n    (cond [(< n divisors)\n           (append divisors\
    \ (list (number->string n)))]\n          [(number? divisors)\n           (count-divisors\
    \ n (quotient n divisors))]\n          [else\n           (count-divisors (quotient\
    \ n divisors) (append divisors '(7))))]))\n  (count-divisors n (append '(11) (append\
    \ '(13) '(1)))))\n", "  (if (= n 0)\n      0\n      (+ 1 (* (mod n 11) (mod n\
    \ 13)))\n))\n</code>\n<|/ a dscore=1 tags=racket,fizzbuzz |>\n<| c |>\nYes, this\
    \ is very similar to the way I was thinking of doing it, but I wanted to see if\
    \ I could do it with less lines of code (this is just a homework assignment).\n\
    <|/ c |>\n<| a |>\nHere's my answer:\n<code>", "  (let ((count 0))\n    (if (zero?\
    \ n) count (if (or (even? n) (odd? n)) count (fizz_buzz (- n 1)))))\n  (if (=\
    \ n 7)\n      (+ 1 (fizz_buzz (- n 1)))\n      count))\n", "  (define (helper\
    \ x y z)\n    (if (= x 7)\n        (add1 (+ (* z (/ y 11)) (* z (/ y 13)))\n \
    \              (* z (/ y 11))\n               (* z (/ y 13)))\n        (helper\
    \ x (+ y 1) z)))\n  (helper n 1 1))\n", "  (cond [(< n 0)\n         '()]\n   \
    \     [(= (remainder n 11) 0)\n         (cons n (fizz_buzz (/ n 11)))]\n     \
    \   [(= (remainder n 13) 0)\n         (cons n (fizz_buzz (/ n 13)))]\n       \
    \ [else\n         (fizz_buzz (/ n 11)) (fizz_buzz (/ n 13))]))\n", "  (cond\n\
    \    [(< n 1) 0]\n    [(= (modulo n 11) 0) (+ 1 (fizz_buzz (quotient n 11)))]\n\
    \    [(= (modulo n 13) 0) (+ 1 (fizz_buzz (quotient n 13)))]\n    [else (+ 1 (fizz_buzz\
    \ (quotient n 11)))]))\n", "  (define (count x y)\n    (cond\n      [(= x y) (+\
    \ 1 y)] \n      [else (+ (/ (mod x y) 11) (/ (mod x y) 13))]))\n  (cond\n    [(=\
    \ n 0)\n     0]\n    [(= n 1)\n     (if (= (mod n 11) 0)\n         (count n 11)\n\
    \         (count n 13))]\n    [else\n     (+ (count (/ n 11) (mod n 13))\n   \
    \     (count (/ n 13) (mod n 11))))]))\n</cell>\n<text>\nExercise 4.10\nThe function\
    \ is_palindrome accepts a string as input and returns #t if it\u2019s palindrome\
    \ and #f if it\u2019s not. We will test it on some numbers here.\n\n>>> is_palindrome\
    \ \u201C9876\u201D\n#t\n>>> is_palindrome \u201C12345\u201D\n#t\n>>> is_palindrome\
    \ \u201C321\u201D\n#f\n>>> is_palindrome \u201C514\u201D\n#f\n>>> is_palindrome\
    \ \u201C7\u201D\n#t\n>>> is_palindrome \u201C0\u201D\n#f\n\n</text>\n<code language=dyalog-kernel>",
  "  (cond\n    [(< n 0) \"No\"]\n    [(or (< n 11) (< n 13)) \"Yes\"]\n    [else\
    \ (add1 (fizz_buzz (- n 1))) (mod n 11) (mod n 13) (mod n 7)]))", "  (let loop\
    \ ((n n) (acc 0))\n    (if (< n 0)\n        acc\n        (loop (quotient n 11)\
    \ (+ acc (* 2 6)))))) ; use 11 or 13 instead of 6 to get both divisibility by\
    \ 11 and 13\n", "  (cond\n    [(= n 0) 0]\n    [(= n 1) 0]\n    [(= (mod n 11)\
    \ 0) (+ 1 (fizz_buzz (/ n 11)))]\n    [(= (mod n 13) 0) (+ 1 (fizz_buzz (/ n 13)))]\n\
    \    [(= (mod n 17) 0) (+ 1 (fizz_buzz (/ n 17)))]\n    [else (+ 1 (fizz_buzz\
    \ (/ n 7)))]))\n", "  (cond\n    [(= n 0) 'zero]\n    [(= n 1) 'one]\n    [(=\
    \ n 2) 'two]\n    [(= (mod n 3) 0) 'three]\n    [(= (mod n 3) 1) 'four]\n    [(=\
    \ (mod n 3) 2) 'five]\n    [(= (mod n 3) 3) 'six]\n    [(= (mod n 4) 0) 'seven]\n\
    \    [(= (mod n 4) 1) 'eight]\n    [(= (mod n 4) 2) 'nine]\n    [else (fizz_buzz\
    \ (sub1 n))]\n  )\n)\n", "  (cond\n    [(= n 1) 0]\n    [(= n 2) 0]\n    [else\
    \ (if (= (mod-10 n) 7) (+ (fizz_buzz (sub1 n)) 1) (fizz_buzz (sub1 n)))]))\n",
  "  (let ((remainder (modulo n 11)))\n    (cond ((= remainder 7)\n           (add1\
    \ (quotient n 11)))\n          (else (fizz_buzz (quotient n 11)))))\n</code>\n\
    <|/ a dscore=2 tags=racket,scheme |>\n<| c |>\nWow, thanks for the answer! It\
    \ helped me understand how I could solve it more clearly by looking at your code.\
    \ Thanks!\n<|/ c |>\n<| a tags=racket,scheme dscore=2 |>\nAn alternative solution\
    \ that doesn't use recursion.  It will print a number in each case where a 7 is\
    \ found:\n<code>", "  (cond ((= n 1) '(1))\n        ((= n 2) '(1))\n        ((=\
    \ n 3) '(1))\n        ((= (modulo n 11) 7) '(3))\n        ((= (modulo n 13) 7)\
    \ '(3))\n        (else (+ n (fizz_buzz (modulo n 11)))))) \n", "  (cond\n    [(=\
    \ n 0)\n     0]\n    [(= n 1)\n     (+ (* n 11) 0)]\n    [(= (modulo n 11) 13)\n\
    \     (+ (* n 11) (* n 13) 0)]\n    [(= (modulo n 13) 11)\n     (+ (* n 13) (*\
    \ n 11) 0)]\n    [else\n     (+ n (fizz_buzz (quotient n 11)))]))\n</cell>\n<text>\n\
    Exercise\nWrite a function that takes a natural number and returns the sum of\
    \ the squares of its digits.\nIt should include a case that returns the same result\
    \ as the function above (i.e. (square-digit-sum (fizz_buzz n)).\n\n\n</text>\n\
    <cell>", "  (cond\n    [(< n 0) (error \"n is negative\")] \n    [else (loop\n\
    \             [i n\n              acc 0]\n             (cond\n               [(=\
    \ (mod i 11) 0) (set! acc (+ acc 1))]\n               [(= (mod i 13) 0) (set!\
    \ acc (+ acc 1))]\n               [else (set! acc (+ acc 1))])]\n    [(= acc 0)\
    \ (list* '0 '0 '0)]\n    [else (list* '1 '(fizz i) (buzz i))]))\n", "  (cond\n\
    \    ((= n 0)          0)\n    ((zero? (remainder n 11))\n     (fizz_buzz (quotient\
    \ n 11)))\n    ((zero? (remainder n 13))\n     (fizz_buzz (quotient n 13)))\n\
    \    (else (+ 1 (fizz_buzz (quotient n 11))))))\n</code>\n<|/ a tags=number-theory,fizzbuzz,scheme,racket\
    \ |>\n<| c |>\nThe \"else clause\" can be simplified to: \n    (else (fizz_buzz\
    \ (quotient n 11))))\n<|/ c |>\n<| c |>\nThanks, edited. How about a non-recursive\
    \ solution?\n<|/ c |>\n<| a dscore=2 |>\nHere are some answers based on Racket\
    \ code (for Scheme or Scheme-like languages, not Racket). The code is based on\
    \ fizzbuzz Scheme procedure from http://web.cs.du.edu/~sturtevant/scheme/fizzbuzz.rkt\n\
    It also works with non-fizzbuzz numbers (not divisible by 11 or 13).\n<code>",
  "  (cond [(= n 0)\n         0]\n        [(even? (remainder n 13))\n         (+ n\
    \ (* (modulo n 13) 7))\n         (+ (fizz_buzz (quotient n 13)) 1)]\n        [(odd?\
    \ (remainder n 11))\n         (+ n (* (modulo n 11) 7))\n         (+ (fizz_buzz\
    \ (quotient n 11)) 1)]\n        [else\n         (fizz_buzz (quotient n 10))]))\n",
  "  (cond [(= n 0) 0]\n        [(= n 1) 0]\n        [(= (modulo n 11) 0) 1]\n   \
    \     [(= (modulo n 13) 0) 2]\n        [else (+ (fizz_buzz (quotient n 11)) (fizz_buzz\
    \ (quotient n 13))) (* n 7)]))\n", "  (cond\n    [(= n 0) 0]\n    [(= n 1) 0]\n\
    \    [(= (mod n 11) 0) 2]\n    [(= (mod n 13) 0) 3]\n    [else (fizz_buzz (- n\
    \ 1))]))\n", "  (let ([i (remainder n 11)])\n    (when (= i 7)\n      (+ 1 (fizz_buzz\
    \ (/ n 11)))))\n  )\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis was my first thought\
    \ as well, but it produces an incorrect answer (the correct result is 3 not 4\
    \ -- fizzbuzz numbers are 3 through 10, not 1 through 5).\n<|/ c |>\n<| c |>\n\
    - yes, you are right. I didn't notice that requirement. However, it is easy to\
    \ fix. I added the fix. It should work now.\n<|/ c |>\n<| c |>\nYes, it works\
    \ now, thank you! I'm still confused though, why does `(fizz_buzz 78)` return\
    \ 2?\n<|/ c |>\n<| c |>\n- because 78 is divisible by 11 and 13, so it needs to\
    \ be counted twice - once by dividing by 11 and once by dividing by 13.\n<|/ c\
    \ |>\n<| c |>\nYes, I see now. The algorithm you use is really clever.\n<|/ c\
    \ |>\n<| a tags=scheme,racket |>\nThe most elegant solution is probably to use\
    \ quotient, mod, and remainder and cond statements.\n<code>", "  (local\n    [(define\
    \ (helper i)\n      (cond [(= i (mod n 11)) 0]\n            [(= i (mod n 13))\
    \ 2])]\n          [else (+ 1 (helper i (mod n 11) (mod n 13))))])]\n    (helper\
    \ n)))\n</cell>\n<code language=racket-student-small>\n#lang racket\n", "  (define\
    \ (count n)\n    (cond\n      [(= n 0) 0]\n      [else (+ 1 (count (quotient n\
    \ 10)))]))\n  (if (> n 0)\n      (count\n       (quotient n 10))\n      0))\n",
  "  (cond ((< n 11) 0)\n        (#t (if (= (mod n 3) 0)\n          (cond ((= (mod\
    \ n 7) 0)\n                 (+ 1 0))\n               ((= (mod n 7) 1)\n      \
    \          (+ 1 0))\n               ((= (mod n 7) 2)\n                (+ 1 0))\n\
    \               ((= (mod n 7) 3)\n                (+ 1 0))\n               ((=\
    \ (mod n 7) 4)\n                (+ 1 0))\n               ((= (mod n 7) 5)\n  \
    \              (+ 1 0))\n               ((= (mod n 7) 6)\n                (+ 1\
    \ 0))\n               ((= (mod n 7) 7)\n                (+ 1 0)))))\n        (#t\
    \ (if (= (mod n 13) 0)\n          (cond ((= (mod n 17) 0)\n                 (+\
    \ 1 0))\n               ((= (mod n 17) 1)\n                (+ 1 0))\n        \
    \       ((= (mod n 17) 2)\n                (+ 1 0))\n               ((= (mod n\
    \ 17) 3)\n                (+ 1 0))\n               ((= (mod n 17) 4)\n       \
    \         (+ 1 0))\n               ((= (mod n 17) 5)\n                (+ 1 0))\n\
    \               ((= (mod n 17) 6)\n                (+ 1 0))\n               ((=\
    \ (mod n 17) 7)\n                (+ 1 0)))))))\n", "  (cond ((= n 0) 0)\n    \
    \    ((= (mod n 11) 0) 0)\n        ((= (mod n 13) 0) 0)\n        (else (+ 1 (fizz_buzz\
    \ (quotient n 11))))))\n", "  (cond [(<= (modulo n 11) 3) \"0\"]\n        [(<=\
    \ (modulo n 13) 3) \"2\"]\n        [else (+ 1 (fizz_buzz (quotient n 13)))]))\n",
  "  (cond\n    ((= n 1) 0)\n    ((= (mod n 11) 0) 2)\n    ((= (mod n 13) 0) 3)\n\
    \    (else (fizz_buzz (quotient n 11)))))\n", "  (define (count7 n)\n    (cond\n\
    \      [(< n 13) (+ (mod n 11) (mod n 13))]\n      [(< n 11) (+ 1 (mod n 13))]\n\
    \      [(< n 9) (+ 1 (mod n 11))]\n      [else 0]))\n  (cond\n    [(= n 0)\n \
    \    (cond\n       [(= (mod n 7) 0)\n        (+ 1 (count7 (sub1 n)))]\n      \
    \ [else 0])]\n    [else\n     (+ 1 (count7 (sub1 n)))]))\n</code>\n<|/ a dscore=1\
    \ tags=fizzbuzz,scheme |>\n<| a tags=fizzbuzz,scheme |>\n<code>", "  (cond\n \
    \   [(= n 0)\n     0]\n    [(= (mod n 11) 0)\n     (cond [(= (mod n 13) 0)\n \
    \             (+ n (* 3 1))]\n           [(= (mod n 13) 1)\n              (+ n\
    \ (* 3 2))]\n           [(= (mod n 13) 2)\n              (+ n (* 3 3))])]\n  \
    \  [(= (mod n 11) 1)\n     (cond [(= (mod n 13) 0)\n              (+ n (* 3 4))]\n\
    \           [(= (mod n 13) 1)\n              (+ n (* 3 5))]\n           [(= (mod\
    \ n 13) 2)\n              (+ n (* 3 6))])]\n    [(= (mod n 11) 2)\n     (cond\
    \ [(= (mod n 13) 0)\n              (+ n (* 3 7))]\n           [(= (mod n 13) 1)\n\
    \              (+ n (* 3 8))]\n           [(= (mod n 13) 2)\n              (+\
    \ n (* 3 9))])]\n    [(= (mod n 11) 3)\n     (cond [(= (mod n 13) 0)\n       \
    \       (+ n (* 3 10))]\n           [(= (mod n 13) 1)\n              (+ n (* 3\
    \ 11))]\n           [(= (mod n 13) 2)\n              (+ n (* 3 12))])]\n    [(=\
    \ (mod n 11) 4)\n     (cond [(= (mod n 13) 0)\n              (+ n (* 3 13))]\n\
    \           [(= (mod n 13) 1)\n              (+ n (* 3 14))]\n           [(= (mod\
    \ n 13) 2)\n              (+ n (* 3 15))]\n           [(= (mod n 13) 3)\n    \
    \          (+ n (* 3 16))])]\n    [(= (mod n 11) 5)\n     (cond [(= (mod n 13)\
    \ 0)\n              (+ n (* 3 17))]\n           [(= (mod n 13) 1)\n          \
    \    (+ n (* 3 18))]\n           [(= (mod n 13) 2)\n              (+ n (* 3 19))]\n\
    \           [(= (mod n 13) 3)\n              (+ n (* 3 20))])]\n    [(= (mod n\
    \ 11) 6)\n     (cond [(= (mod n 13) ", "  (cond\n    [(= n 0)\n     (printf \"\
    0\\n\")]\n    [(= n 1)\n     (printf \"1\\n\")]\n    [(= n 2)\n     (printf \"\
    2\\n\")]\n    [(= (modulo n 11) 0)\n     (printf \"3\\n\")]\n    [(= (modulo n\
    \ 13) 0)\n     (printf \"5\\n\")]\n    [else\n     (cond\n       [(= (modulo n\
    \ 7) 0)\n        (printf \"7\\n\")]\n       [(= (modulo n 7) 1)\n        (printf\
    \ \"6\\n\")]\n       [(= (modulo n 7) 2)\n        (printf \"5\\n\")]\n       [(=\
    \ (modulo n 7) 3)\n        (printf \"4\\n\")]\n       [(= (modulo n 7) 4)\n  \
    \      (printf \"3\\n\")]\n       [(= (modulo n 7) 5)\n        (printf \"2\\n\"\
    )]\n       [(= (modulo n 7) 6)\n        (printf \"1\\n\")]\n       [else\n   \
    \     (printf \"7\\n\")]\n       )]))\n</code>\n<|/ a dscore=1 tags=fizzbuzz,fizz,racket,scheme\
    \ |>\n<| a tags=fizzbuzz,fizz,racket,scheme |>\nA variation on Scheme and Racket:\n\
    <code>", "  (cond\n    [(= n 1) 1]\n    [(= n 3) 3]\n    [(or (= (% n 11) 0) (=\
    \ (% n 13) 0)) 0]\n    [else (+ 1 (fizz_buzz (/ n 11)))]\n  )\n)\n", "  (/ (/\
    \ (mod-int n 11) 11) 13))\n</code>\n<|/ a tags=fizzbuzz,racket,scheme |>\n<| c\
    \ |>\n`(mod n 11)` returns `11` for anything less than `11`\n<|/ c |>\n<| a tags=fizzbuzz,racket,scheme\
    \ dscore=1 |>\nHere is a solution based on using integer division and modulo:\n\
    <code>", "  (define (loop n result)\n    (cond ((= n 0) 0)\n          ((or (=\
    \ (remainder n 11) 0)\n               (= (remainder n 13) 0))\n           (loop\
    \ (remainder n 11) result))\n          (else (+ 1 (loop (remainder n 10) result)))))\n\
    \  (loop n 0))\n", "  (cond\n    [(< n 100) 0]\n    [(< n 1000) 1]\n    [(< n\
    \ 10000) 2]\n    [(< n 100000) 3]\n    [else 4]\n  )\n)\n\n#lang racket\n", " \
    \ (local ((define (count-7-at-least n)\n             (count-if (lambda (x) (and\
    \ (integer? x) (= (mod x 7) 0) (= x 7)))\n                       n)))\n    (count-7-at-least\
    \ n)))\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 tags=racket,scheme |>\n<code>",
  "  (cond [(< n 7) 0]\n        [(= (mod n 11) 0) (+ 0 (fizz_buzz (/ n 11)))]\n  \
    \      [(= (mod n 13) 0) (+ 2 (fizz_buzz (/ n 13)))]\n        [else (+ 3 (fizz_buzz\
    \ (/ n 13)))]))\n", "  (let ([d (floor n)]\n        [sum (if (= d 7) 1 (+ sum\
    \ 1))]\n        [count 0])\n    (cond\n      [(zero? n) count]\n      [(= d 11)\n\
    \       (cond\n         [(= (modulo n 11) 0) (+ count 1)]\n         [(= (modulo\
    \ n 11) 1) (+ count 2)]\n         [(= (modulo n 11) 2) (+ count 3)]\n        \
    \ [(= (modulo n 11) 3) (+ count 4)]\n         [(= (modulo n 11) 4) (+ count 5)]\n\
    \         [(= (modulo n 11) 5) (+ count 6)]\n         [(= (modulo n 11) 6) (+\
    \ count 7)]\n         [(= (modulo n 11) 7) (+ count 8)]\n         [(= (modulo\
    \ n 11) 8) (+ count 9)]\n         [(= (modulo n 11) 9) (+ count 10)]\n       \
    \  [(= (modulo n 11) 10) (+ count 11)]\n         [(= (modulo n 11) 11) (+ count\
    \ 12)]\n         [(= (modulo n 11) 12) (+ count 13)]\n         [(= (modulo n 11)\
    \ 13) (+ count 14)]\n         [(= (modulo n 11) 14) (+ count 15)]\n         [(=\
    \ (modulo n 11) 15) (+ count 16)]\n         [(= (modulo n 11) 16) (+ count 17)]\n\
    \         [(= (modulo n 11) 17) (+ count 18)]\n         [(= (modulo n 11) 18)\
    \ (+ count 19)]\n         [(= (modulo n 11) 19) (+ count 20)]\n         [(= (modulo\
    \ n 11) 20) (+ count 21)]\n         [(= (modulo n 11) 21) (+ count 22)]\n    \
    \     [(= (modulo n 11) 22) (+ count 23)]\n         [(= (modulo n 11) 23) (+ count\
    \ 24)]\n         [(= (modulo n 11) 24) (+ count 25)]\n         [(= (modulo n 11)\
    \ 25) (+ count 26)]\n         [(= (modulo n 11) 26) (+ count 27)]\n         [(=\
    \ (modulo n 11) 27) (+ count 28)]\n         [(= (modulo n 11) 28) (+ count 29)]\n\
    \         [(= ", "  (if (= n 0)\n      0\n      (if (even? n)\n          (+ (/\
    \ n 11)\n             (/ n 13))\n          (+ 1 (/ n 11) (/ n 13)))))\n", '  (if
    (= (mod n 11) 0) 2 (if (= (mod n 13) 0) 3 (if (= (mod n 17) 0) 5 (if (= (mod n
    19) 0) 7 (if (= (mod n 21) 0) 9 (if (= (mod n 23) 0) 11 (if (= (mod n 25) 0) 13
    (if (= (mod n 27) 0) 15 (if (= (mod n 29) 0) 17 (if (= (mod n 31) 0) 19 (if (=
    (mod n 33) 0) 21 (if (= (mod n 35) 0) 23 (if (= (mod n 37) 0) 25 (if (= (mod n
    39) 0) 27 (if (= (mod n 41) 0) 29 (if (= (mod n 43) 0) 31 (if (= (mod n 45) 0)
    33 (if (= (mod n 47) 0) 35 (if (= (mod n 49) 0) 37 (if (= (mod n 51) 0) 39 (if
    (= (mod n 53) 0) 41 (if (= (mod n 55) 0) 43 (if (= (mod n 57) 0) 45 (if (= (mod
    n 59) 0) 47 (if (= (mod n 61) 0) 49 (if (= (mod n 63) 0) 51 (if (= (mod n 65)
    0) 53 (if (= (mod n 67) 0) 55 (if (= (mod n 69) 0) 57 (if (= (mod n 71) 0) 59
    (if (= (mod n 73) 0) 61 (if (= (mod n 75) 0) 63 (if (= (mod n 77) 0) 65 (if (=
    (mod n 79) 0) 67 (if (= (mod n 81) 0) 69 (if (= (mod n 83) 0) 71 (if (= (mod n
    85) 0) 73 (if (= (mod n 87) 0) 75 (if (= (mod n 89) 0) 77 (if (= (mod n 91) 0)
    79 (if (= (mod n 93) 0) 81 (if (= (mod n 95) 0) 83 (if (= (mod n 97) 0) 85 (if
    (= (mod n 99) 0) 87 (if (= (mod n 101) 0) 89 (if (= (mod n 103) 0) 91 (if (= (mod
    n 105) 0) 93 (if (= (mod n 107) 0) 95 (if (= (mod n 109) 0) 97 (if (= (mod n 111)
    0) 99 (if (= (mod n 113) 0) 101 (if (= (', "  (cond\n    ((= n 0)0)\n    ((= n\
    \ 1)0)\n    ((= (modulo n 11) 0)0)\n    ((= (modulo n 13) 0)1)\n    ((= (modulo\
    \ n 11) 1)1)\n    (else (+ (fizz_buzz (quotient n 11))(fizz_buzz (quotient n 13)))\n\
    \  )\n)\n", "  (cond [(< n 0)\n         0]\n        [(= (modulo n 11) 0)\n   \
    \      1]\n        [(= (modulo n 13) 0)\n         3]\n        [else (+ 1 (fizz_buzz\
    \ (- n 1))))))\n", "  (if (= (mod n 11) 0)\n      (if (= (mod n 13) 0)\n     \
    \     0\n          1)\n      (+ 1 (fizz_buzz (- n 1)))))\n\n#lang racket\n", " \
    \ (define (buzz-loop i j)\n    (if (= i j)\n        0\n        (if (= (mod n 11)\
    \ 0)\n            (if (= (mod n 13) 0)\n                2\n                3)\n\
    \            (if (= (mod n 11) 0)\n                2\n                3))))\n\
    \  (buzz-loop (quotient n 11) (quotient n 13)))\n", "  (define (find x)\n    (cond\
    \ ((zero? x) #f)\n          ((< x n) 0)\n          ((= (mod x 11) #f) #f)\n  \
    \        ((= (mod x 13) #f) #f)\n          (else (+ 1 (find (quotient x 10))))))\n\
    \  (find (/ n 10)))\n", "  (if (< n 15)\n      (count (floor (/ n 11))\n     \
    \          (floor (/ n 13))\n               '7)\n      (count (floor (/ n 10))\n\
    \               (floor (/ n 13))\n               '7)))\n\n#lang racket\n", " \
    \ (let ([a (quotient n 11)\n          b (quotient n 13)])\n    (cond [(zero? a)\
    \ 0]\n          [(zero? b) 0]\n          [(= a b)\n           (+ (fizz_buzz (+\
    \ a b)) (+ (* a 7) 7))\n           ;; [A B]\n           ;; [A B C]\n         \
    \  ;; [A B C D]\n           ;; [A B C D E]\n           ;; [A B C D E F]\n    \
    \       ;; [A B C D E F G]\n           ;; [A B C D E F G H]\n           ;; [A\
    \ B C D E F G H I]\n           ;; [A B C D E F G H I J]\n           ;; [A B C\
    \ D E F G H I J K]\n           ;; [A B C D E F G H I J K L]\n           ;; [A\
    \ B C D E F G H I J K L M]\n           ;; [A B C D E F G H I J K L M N]\n    \
    \       ;; [A B C D E F G H I J K L M N O]\n           ;; [A B C D E F G H I J\
    \ K L M N O P]\n           ;; [A B C D E F G H I J K L M N O P Q]\n          \
    \ ;; [A B C D E F G H I J K L M N O P Q R]\n           ;; [A B C D E F G H I J\
    \ K L M N O P Q R S]\n           ;; [A B C D E F G H I J K L M N O P Q R S T]\n\
    \           ;; [A B C D E F G H I J K L M N O P Q R S T U]\n           ;; [A B\
    \ C D E F G H I J K L M N O P Q R S T U V]\n           ;; [A B C D E F G H I J\
    \ K L M N O P Q R S T U V W]\n           ;; [A B C D E F G H I J K L M N O P Q\
    \ R S T U V W X]\n           ;; [A B ", "  (cond\n    [(< n 100) 0]\n    [else\
    \ (cond\n            [(= (mod n 11) (mod n 13)) 2]\n            [else 3]\n   \
    \         )]))\n</code>\n<|/ a |>\n<| c |>\nThe code posted is wrong! The second\
    \ test in the \"cond\" should be \"= (= n (mod n 11) (mod n 13))\" because n is\
    \ unchanged.\n<|/ c |>\n<| c |>\nThank you for pointing it out, I will fix it.\n\
    <|/ c |>\n<| a |>\n<code>", "  (cond\n    ((= n 1) 0)\n    ((= n 2) 0)\n    ((=\
    \ n 5) (* 2 n (+ 1 n)))\n    ((= (mod n 11) 0) (* 2 n (+ 1 n)))\n    ((= (mod\
    \ n 13) 0) (* 3 n (+ 1 n)))\n    ((= (mod n 11) 0) (* 3 n (+ 1 n)))\n    ((= (mod\
    \ n 13) 0) (* 5 n (+ 1 n)))\n    ((= (mod n 11) 0) (* 5 n (+ 1 n)))\n    (else\
    \ (+ 1 (fizz_buzz (- n 1))))))\n", "  (cond\n    ((< n 100)\n     (cond\n    \
    \   ((= (modulo n 11) 0) 0)\n       ((= (modulo n 13) 0) 1)\n       (else 2))\n\
    \    ((< n 1000)\n     (cond\n       ((= (modulo n 11) 0) 0)\n       ((= (modulo\
    \ n 13) 0) 1)\n       ((= (modulo n 19) 0) 2)\n       ((= (modulo n 23) 0) 3)\n\
    \       ((= (modulo n 29) 0) 4)\n       ((= (modulo n 35) 0) 5)\n       ((= (modulo\
    \ n 43) 0) 6)\n       ((= (modulo n 49) 0) 7)\n       ((= (modulo n 55) 0) 8)\n\
    \       ((= (modulo n 63) 0) 9)\n       ((= (modulo n 69) 0) 10)\n       ((= (modulo\
    \ n 77) 0) 11)\n       ((= (modulo n 83) 0) 12)\n       ((= (modulo n 89) 0) 13)\n\
    \       ((= (modulo n 97) 0) 14)\n       ((= (modulo n 103) 0) 15)\n       ((=\
    \ (modulo n 109) 0) 16)\n       ((= (modulo n 117) 0) 17)\n       ((= (modulo\
    \ n 123) 0) 18)\n       ((= (modulo n 129) 0) 19)\n       ((= (modulo n 135) 0)\
    \ 20)\n       ((= (modulo n 143) 0) 21)\n       ((= (modulo n 149) 0) 22)\n  \
    \     ((= (modulo n 155) 0) 23)\n       ((= (modulo n 163) 0) 24)\n       ((=\
    \ (modulo n 169) 0) 25)\n       ((= (modulo n 177) 0) 26)\n       ((= (modulo\
    \ n 183) 0) 27)\n       ((= (modulo n 189) 0) 28)\n       ((= (modulo n 195) 0)\
    \ 29)\n       ((= (modulo n 203) 0) 30)\n       ((= (modulo n 209) 0) 31)\n  \
    \     ((= (modulo n 217) 0) 32)\n       ((= (modulo n 223) 0) 33)\n       ((=\
    \ (modulo n 229) 0) 34)\n       ((= (modulo n 235) 0) 35)\n       ((= (modulo\
    \ n 243) 0) 36)\n       ((= (modulo n 249) 0) ", "  (cond\n    ((= n 0) 0)\n \
    \   ((= n 1) 1)\n    ((even? n) 0)\n    ((odd? n) 1)\n    ((= (modulo n 11) 0)\n\
    \     (+ (fizz_buzz (quotient n 11)) 1))\n    ((= (modulo n 13) 0)\n     (+ (fizz_buzz\
    \ (quotient n 13)) 1))\n    (else (fizz_buzz (quotient n 10)))))\n", "  (cond\n\
    \    [(< n 0) 0]\n    [(< n 100) 0]\n    [(< n 200) 1]\n    [(< n 300) 2]\n  \
    \  [else (+ 3 (fizz_buzz (- n 100)))]))\n", "  (cond\n    [(< n 13) 0] ;; The\
    \ value '13' is used to indicate a value which is not a multiple of 11.\n    [(<\
    \ n 100) 1] ;; The value '100' is used to indicate a value which is not a multiple\
    \ of 13.\n    [else (- n (remainder n 11))]))\n", "  (cond\n    ((= n 0) 0)\n\
    \    ((= n 1) 1)\n    ((= (mod n 11) 0) 2)\n    ((= (mod n 13) 0) 3)\n    (else\
    \ (fizz_buzz (sub1 n)))))\n", "  (cond\n    [(= n 0) 0]\n    [(= n 1) 1]\n   \
    \ [(= (mod n 11) 0) 2]\n    [(= (mod n 13) 0) 3]\n    [(= (mod n 11) 1) 4]\n \
    \   [(= (mod n 13) 1) 5]\n    [else (+ (fizz_buzz (- n 1)) (fizz_buzz (- n 2))\n\
    \           (fizz_buzz (- n 3)) (fizz_buzz (- n 4))\n           (fizz_buzz (-\
    \ n 5)) (fizz_buzz (- n 6)))]))\n", "  (let loop ((result 0) (count 1))\n    (cond\
    \ [(= n 0) result]\n          [(= n 7) count]\n          [(= (modulo n 11) 0)\
    \ (loop (+ count 1) count)]\n          [(= (modulo n 13) 0) (loop (+ count 1)\
    \ count)]\n          [else (loop (+ count 1) count)])))\n", "  (cond\n    [(=\
    \ n 1) 0]\n    [(= (mod n 11) 0)\n     (cond [(= (mod n 13) 0)\n            (+\
    \ n 2)]\n           [(= (mod n 13) 1)\n            (+ n 3)]\n           [else\n\
    \            (+ n 4)]\n           )]\n    [else (+ (fizz_buzz (/ n 11)) (fizz_buzz\
    \ (/ n 13)))]))\n", "  (cond\n    ((< n 79) (+ 1 (fizz_buzz (+ n 1))))\n    ((=\
    \ n 78) (+ 1 (fizz_buzz (+ n 1))))\n    ((= n 78) (+ 1 (fizz_buzz (+ n 1))))\n\
    \    ((= n 79) (+ 1 (fizz_buzz (+ n 1))))\n    ((= n 79) (+ 1 (fizz_buzz (+ n\
    \ 1))))\n    ((= n 79) (+ 1 (fizz_buzz (+ n 1))))\n    ((= n 79) (+ 1 (fizz_buzz\
    \ (+ n 1))))\n    ((= n 79) (+ 1 (fizz_buzz (+ n 1))))\n    ((= n 79) (+ 1 (fizz_buzz\
    \ (+ n 1))))\n    ((= n 79) (+ 1 (fizz_buzz (+ n 1))))\n    ((= n 79) (+ 1 (fizz_buzz\
    \ (+ n 1))))\n    ((= n 79) (+ 1 (fizz_buzz (+ n 1))))\n    ((= n 79) (+ 1 (fizz_buzz\
    \ (+ n 1))))\n    ((= n 79) (+ 1 (fizz_buzz (+ n 1))))\n    ((= n 79) (+ 1 (fizz_buzz\
    \ (+ n 1))))\n    ((= n 79) (+ 1 (fizz_buzz (+ n 1))))\n    ((= n 79) (+ 1 (fizz_buzz\
    \ (+ n 1))))\n    ((= n 79) (+ 1 (fizz_buzz (+ n 1))))\n    ((= n 79) (+ 1 (fizz_buzz\
    \ (+ n 1))))\n    ((= n 79) (+ 1 (fizz_buzz (+ n 1))))\n    ((= n 79) (+ 1 (fizz_buzz\
    \ (+ n 1))))\n    ((= n 79) (+ 1 (fizz_buzz (+ n 1))))\n    ((= n 79) (+ 1 (fizz_buzz\
    \ (+ n 1))))\n    ((= n 79) (+ 1 (fizz_buzz (+ n 1))))\n    ((= n 79) (+ 1 (fizz_buzz\
    \ (+ n 1))))\n    ((= n 79) (+ 1 (fizz_buzz (+ n 1))))\n    ((= n 79) (+ 1 (fizz_buzz\
    \ (+ n 1))))\n    ((= n 79) (+ 1 (fizz_buzz (+ n 1))))\n    ((= n 79) (", "  (define\
    \ (divisible? n)\n    (if (= (modulo n 11) 0)\n        #t\n        #f))\n  (define\
    \ (fizz_buzz_iter count)\n    (cond ((and (= n 0)\n                (= count 0))\n\
    \           0)\n          ((divisible? n)\n           (+ count 1))\n         \
    \ (else\n           (fizz_buzz_iter (+ count 1)))))\n  (fizz_buzz_iter 0))\n",
  "  (cond\n    [(< n 1) (zero? n)]\n    [(zero? (modulo n 11))\n     (cond\n    \
    \   [(zero? (modulo n 13)) 3]\n       [(= (modulo n 13) 0) (+ 1 3)]\n       [(=\
    \ (modulo n 13) 1) (+ 1 2)]\n       [(= (modulo n 13) 2) (+ 1 1)]\n       [(=\
    \ (modulo n 13) 3) (+ 1 0)])]\n    [(= (modulo n 11) 0)\n     (cond\n       [(zero?\
    \ (modulo n 13)) 2]\n       [(= (modulo n 13) 0) (+ 1 2)]\n       [(= (modulo\
    \ n 13) 1) (+ 1 1)]\n       [(= (modulo n 13) 2) (+ 1 0)])]\n    [else (+ 1 (fizz_buzz\
    \ (quotient n 11)))]))\n", "  (cond\n    [(or (= n 1)\n          (= n 2)\n   \
    \       (= n 3))\n     (writeln '0)]\n    [(= (modulo n 11) 0)\n     (writeln\
    \ '11)]\n    [(= (modulo n 13) 0)\n     (writeln '13)]\n    [else\n     (let ([div\
    \ (/ n 11)]\n           [mod1 (modulo n 11)]\n           [mod2 (modulo n 13)])\n\
    \       (cond\n         [(= 0 mod1)\n          (writeln '0)]\n         [(= 0 mod2)\n\
    \          (writeln '1)]\n         [(= 0 div)\n          (writeln '2)]\n     \
    \    [(= 1 div)\n          (writeln '3)]\n         [(= 1 mod1)\n          (writeln\
    \ '4)]\n         [(= 1 mod2)\n          (writeln '5)]\n         [(= 1 div mod1)\n\
    \          (writeln '6)]\n         [(= 1 div mod2)\n          (writeln '7)]\n\
    \         [(= 1 div mod1 mod2)\n          (writeln '8)]\n         [else\n    \
    \      (writeln '9)]))]))\n", "  (cond [(< n 10) 0]\n        [(< n 100) 1]\n \
    \       [(< n 1000) 2]\n        [else (multiple-of-11-and-13 n)]))\n", "  (cond\n\
    \    [(< n 0) '()]\n    [(= (mod n 11) 0) 0]\n    [(= (mod n 13) 0) 1]\n    [else\
    \ (+ fizz_buzz (mod n 11))]))\n", "  (let ([f (lambda (x)\n            (if (=\
    \ x 7)\n              1\n              (+ x (f (quotient x 11)))))])\n    (+ (f\
    \ n) )))\n</cell>\n<code language=lambda-notebook>", "  (define (count-digits-by-11\
    \ n)\n    (cond\n      [(= n 0) 0]\n      [(< n 1) 1]\n      [else (+ 1 (count-digits-by-11\
    \ (quotient n 11)))]))\n  (define (count-digits-by-13 n)\n    (cond\n      [(=\
    \ n 0) 0]\n      [(< n 1) 1]\n      [else (+ 1 (count-digits-by-13 (quotient n\
    \ 13)))]))\n  (cond\n    [(> n 0) (- n)]\n    [else (+ 1 (count-digits-by-11 n))]\n\
    \    [else (+ 1 (count-digits-by-13 n))]\n    [else 0]))\n", "  (define (helper\
    \ n)\n    (cond\n      [(= n 0) 0]\n      [(= n 1) 0]\n      [(= (mod n 11) 0)\
    \ (+ n 3)] \n      [(= (mod n 13) 0) (+ n 1)] \n      [(= (mod n 7   ) 0) (+ n\
    \ 2)] \n      [(= (mod n 10  ) 0) (+ n 4)]\n      [(= (mod n 14  ) 0) (+ n 6)]\n\
    \      [(= (mod n 8   ) 0) (+ n 8)]\n      [(= (mod n 12  ) 0) (+ n 5)]\n    \
    \  [(= (mod n 11  ) 0) (+ n 9)]\n      [else (helper n)]\n      ))\n  (helper\
    \ n))\n</code>\n<|/ a |>\n<| c |>\nThanks for your help. I changed this in my\
    \ code and my problem seems to have gone away. I'm not going to say whether I\
    \ understand why though.\n<|/ c |>\n<| c |>\nThe only reason `fizz_buzz` wasn't\
    \ working for you was because you were still using the `0` base case instead of\
    \ the `1` base case in your `helper` function.  If you have time, I suggest you\
    \ read up on `cond`.\n<|/ c |>\n<| a dscore=2 tags=racket,scheme,fizzbuzz,lisp\
    \ |>\nIn case you are a victim of \"accidental recursion without explicit base\
    \ case\", here is the way to do it with the standard if:\n<code>", "  (if (zero?\
    \ n)\n      '()\n      (cond ((or (zero? (remainder n 3)) (zero? (remainder n\
    \ 7)))\n             (append (fizz_buzz (quotient n 3)) (cons (remainder n 7)\
    \ '()))\n             (append (cons (remainder n 3) '()) (fizz_buzz (quotient\
    \ n 7))))\n        (else\n             (append (fizz_buzz (quotient n 3)) (cons\
    \ (remainder n 7) '())))))\n", "  (cond ((= n 0)\n         0)\n        ((= n 1)\n\
    \         0)\n        ((= n 11)\n         2)\n        ((= n 13)\n         3)\n\
    \        (else\n         (let ((cnt 0))\n           (loop\n            for i from\
    \ 0 to (floor (/ n 10))\n            for x from 0 to 2\n            if (= (modulo\
    \ n 11 x)\n               7)\n             sum cnt\n             else (+ cnt 1)))\n\
    \         cnt))))\n", "  (if (< n 0)\n      0\n      (if (= (modulo n 11) (modulo\
    \ n 13))\n          (+ (fizz_buzz (- n 7))\n             (fizz_buzz (/ n 13))\n\
    \             (fizz_buzz (/ n 11)))\n          (+ (fizz_buzz (- n 10))\n     \
    \        (fizz_buzz (/ n 11))\n             (fizz_buzz (/ n 13))\n           \
    \  (fizz_buzz (/ n 17))\n             (fizz_buzz (/ n 19))\n             (fizz_buzz\
    \ (/ n 21))\n             (fizz_buzz (/ n 23))\n             (fizz_buzz (/ n 25))\n\
    \             (fizz_buzz (/ n 27))\n             (fizz_buzz (/ n 29))))))\n",
  "  (cond\n    [(= n 0) 0]\n    [(= n 1) 1]\n    [(= (floor (/ n 11)) 0) 2]\n   \
    \ [(= (floor (/ n 13)) 0) 3]\n    [else (fizz_buzz (- n 1))]))\n", "  (cond [(=\
    \ n 0)\n         0]\n        [(= (modulo n 11) 0)\n         (cond [(= (modulo\
    \ n 13) 0)\n                 0]\n               [else\n                 (+ (modulo\
    \ n 13) 1)]\n               )]\n        [else\n         (+ 2 (fizz_buzz (- n 1)))]))\n",
  "  (count\n   (lambda (x)\n     (and (zero? x) (even? (remainder x 7)))\n     (and\
    \ (zero? (remainder x 11)) (even? (remainder x 13)))\n     x))\n   (quotient n\
    \ 11)))\n", "  (cond\n    ((= n 0)0)\n    ((= n 7)7)\n    ((= (mod n 11) 0)0)\n\
    \    ((= (mod n 13) 0)0)\n    ((= (mod n 11) 1)0)\n    ((= (mod n 13) 1)0)\n \
    \   ((= (mod n 11) 2)0)\n    ((= (mod n 13) 2)0)\n    ((= (mod n 11) 3)0)\n  \
    \  ((= (mod n 13) 3)0)\n    ((= (mod n 11) 4)0)\n    ((= (mod n 13) 4)0)\n   \
    \ ((= (mod n 11) 5)0)\n    ((= (mod n 13) 5)0)\n    ((= (mod n 11) 6)0)\n    ((=\
    \ (mod n 13) 6)0)\n    ((= (mod n 11) 7)0)\n    ((= (mod n 13) 7)0)\n    ((= (mod\
    \ n 11) 8)0)\n    ((= (mod n 13) 8)0)\n    ((= (mod n 11) 9)0)\n    ((= (mod n\
    \ 13) 9)0)\n    ((= (mod n 11) 10)0)\n    ((= (mod n 13) 10)0)\n    ((= (mod n\
    \ 11) 11)0)\n    ((= (mod n 13) 11)0)\n    ((= (mod n 11) 12)0)\n    ((= (mod\
    \ n 13) 12)0)\n    ((= (mod n 11) 13)0)\n    ((= (mod n 13) 13)0)\n    ((= (mod\
    \ n 11) 14)0)\n    ((= (mod n 13) 14)0)\n    ((= (mod n 11) 15)0)\n    ((= (mod\
    \ n 13) 15)0)\n    ((= (mod n 11) 16)0)\n    ((= (mod n 13) 16)0)\n    ((= (mod\
    \ n 11) 17)0)\n    ((= (mod n 13) 17)0)\n    ((= (mod n 11) 18)0)\n    ((= (mod\
    \ n 13) 18)0)\n    ((= (mod n 11) 19)0)\n    ((= (mod n 13) 19)0)\n    ((= (mod\
    \ n 11) 20)0)\n    ((= (mod n 13) 20)0)\n    ((= (mod n 11) 21)0)\n    ((= (mod\
    \ n 13) 21)0)\n    ((= (mod n 11) 22)0)\n    ((= (mod n 13) 22)0)\n    ((= (mod\
    \ n 11) 23)0)\n    ((= (mod n 13) 23)0)\n    ((= (mod n 11) 24)0)\n    ((= (",
  "  (define (count n)\n    (cond\n      [(= n 7)\n       (cond\n         [(= (modulo\
    \ n 11) 0) (+ 1 0)]\n         [(= (modulo n 13) 0) (+ 1 0)]\n         [else (+\
    \ 1 0)])]\n      [else (+ 1 0)]))\n  (count n))\n", "  (define (helper-fizz_buzz\
    \ n count)\n    (cond\n      [(= n 0) 0]\n      [(= n 1) (+ count 1)]\n      [(=\
    \ (modulo n 11) 0) (helper-fizz_buzz (/ n 11) (+ count 1))]\n      [(= (modulo\
    \ n 13) 0) (helper-fizz_buzz (/ n 13) (+ count 1))]\n      [else (helper-fizz_buzz\
    \ (/ n 10) count)]))\n  (helper-fizz_buzz n 0))\n", "  (cond\n    [(< n 100)\n\
    \     (cond\n       [(= (modulo n 11) 0)\n        (cond\n         [(= (modulo\
    \ n 13) 0)\n          (+ 1 (fizz_buzz (/ n 13)))]\n         [(= (modulo n 13)\
    \ 1)\n          (+ 1 (fizz_buzz (/ n 13)))\n          (+ 1 (fizz_buzz (/ n 11)))]\n\
    \         [(= (modulo n 13) 2)\n          (+ 1 (fizz_buzz (/ n 13)))\n       \
    \   (+ 1 (fizz_buzz (/ n 11)))\n          (+ 1 (fizz_buzz (/ n 13)))]\n      \
    \   [(= (modulo n 13) 3)\n          (+ 1 (fizz_buzz (/ n 13)))\n          (+ 1\
    \ (fizz_buzz (/ n 11)))\n          (+ 1 (fizz_buzz (/ n 13)))\n          (+ 1\
    \ (fizz_buzz (/ n 11)))]\n         [(= (modulo n 13) 4)\n          (+ 1 (fizz_buzz\
    \ (/ n 13)))\n          (+ 1 (fizz_buzz (/ n 11)))\n          (+ 1 (fizz_buzz\
    \ (/ n 13)))\n          (+ 1 (fizz_buzz (/ n 11)))\n          (+ 1 (fizz_buzz\
    \ (/ n 13)))]\n         [(= (modulo n 13) 5)\n          (+ 1 (fizz_buzz (/ n 13)))\n\
    \          (+ 1 (fizz_buzz (/ n 11)))\n          (+ 1 (fizz_buzz (/ n 13)))\n\
    \          (+ 1 (fizz_buzz (/ n 11)))\n          (+ 1 (fizz_buzz (/ n 13)))\n\
    \          (+ 1 (fizz_buzz (/ n 11)))]\n         [(= (modulo n 13) 6)\n      \
    \    (+ 1 (fizz_buzz (/ n 13)))\n          (+ 1 (fizz_buzz (/ n 11)))\n      \
    \    (+ 1 (fizz_buzz (/ n 13)))\n          (+ 1 (fizz_buzz (/ n 11)))\n      \
    \    (+ 1 (fizz_buzz (/ n 13)))\n          (+ 1 (fizz_buzz (/ n 11", "  (cond\
    \ [(= n 0) 0]\n        [(= n 1) 0]\n        [(= (mod-n n 10) 0) (+ 1 )]\n    \
    \    [else (+ 1 )]))\n", "  (if (= n 0) 0 \n      (if (even? n)\n          (+\
    \ n (buzz-count (quotient n 11)))\n          (if (< n 10)\n              (+ n\
    \ (buzz-count (quotient n 13)))\n              (+ n (buzz-count (quotient n 11)))))\n\
    \  )\n)\n", "  (let ([f (quotient n 11)]\n        [b (quotient (- n f) 13)]\n\
    \        [b (if (< b 1) (+ b 1) b)]\n        [r (remainder n 11)]\n        [r\
    \ (if (< r 1) (+ r 1) r)]\n        [r (if (< r 1) (+ r 1) r)]\n        [r (if\
    \ (< r 1) (+ r 1) r)]\n        [r (if (< r 1) (+ r 1) r)]\n        [r (if (< r\
    \ 1) (+ r 1) r)])\n    (cond [(= f 0) (+ 1 (fizz_buzz (- n b)))]\n          [(=\
    \ b 0) (+ 1 (fizz_buzz (- n r)))]\n          [(= b 1) (+ 1 (fizz_buzz (- n r)))]\n\
    \          [(= b 2) (+ 1 (fizz_buzz (- n r)))]\n          [(= b 3) (+ 1 (fizz_buzz\
    \ (- n r)))]\n          [(= b 4) (+ 1 (fizz_buzz (- n r)))]\n          [(= b 5)\
    \ (+ 1 (fizz_buzz (- n r)))]\n          [(= b 6) (+ 1 (fizz_buzz (- n r)))]\n\
    \          [(= b 7) (+ 1 (fizz_buzz (- n r)))]\n          [(= b 8) (+ 1 (fizz_buzz\
    \ (- n r)))]\n          [(= b 9) (+ 1 (fizz_buzz (- n r)))]\n          [(= b 10)\
    \ (+ 1 (fizz_buzz (- n r)))]\n          [(= r 0) (+ 1 (fizz_buzz (- n f)))]\n\
    \          [(= r 1) (+ 1 (fizz_buzz (- n f)))]\n          [(= r 2) (+ 1 (fizz_buzz\
    \ (- n f)))]\n          [(= r 3) (+ 1 (fizz_buzz (- n f)))]\n          [(= r 4)\
    \ (+ 1 (fizz_buzz (- n f)))]\n          [(= r 5) (+ 1 (fizz_buzz (- n f)))]\n\
    \          [(= r 6) (+ 1 (fizz_buzz (- n f)))]\n          [(= r 7) (+ 1 (fizz_buzz",
  "  (cond\n    [(zero? n) 0]\n    [(zero? (remainder n 11)) (+ (fizz_buzz (quotient\
    \ n 11)) 1)]\n    [(zero? (remainder n 13)) (+ (fizz_buzz (quotient n 13)) 1)]\n\
    \    [else (+ (fizz_buzz (quotient n 11)) (fizz_buzz (quotient n 13)))]))\n",
  "  (cond\n    [(= n 0) (+ 0 1)]\n    [(= n 1) (+ 0 1)]\n    [(= (mod n 11) 0) (+\
    \ 0 (fizz_buzz (sub1 n)))]\n    [(= (mod n 13) 0) (+ 2 (fizz_buzz (sub1 n)))]\n\
    \    [else (+ 3 (fizz_buzz (sub1 n)))]))\n", "  (define (count-divisors n)\n \
    \   (define (helper n count)\n      (cond ((= n 0) count)\n        ((or (= (modulo\
    \ n 11) 0)\n             (= (modulo n 13) 0))\n         (helper n (+ count 1))\n\
    \         (helper (quotient n 11) (+ count 1)))\n        (else (helper (quotient\
    \ n 11) (+ count 1)))))\n    (helper n 0))\n  (count-divisors n))\n", "  (cond\n\
    \    [(< n 10) 0]\n    [(= (mod n 11) 0) 2]\n    [(= (mod n 13) 0) 3]\n    [else\
    \ (+ 3 (fizz_buzz (sub1 n)))]))\n", "  (cond\n    [(< n 0)\n     0]\n    [(< n\
    \ 11)\n     (if (= (remainder n 11) 7)\n         1\n         (fizz_buzz (remainder\
    \ n 11)))]\n    [(< n 13)\n     (if (= (remainder n 13) 7)\n         1\n     \
    \    (fizz_buzz (remainder n 13)))]\n    [else\n     (+ (fizz_buzz (quotient n\
    \ 11))\n        (fizz_buzz (quotient n 13)))]))\n", "  (cond ((< n 100) 0)\n \
    \       (#t (count-divisible-by-11 n 7)\n              (count-divisible-by-13\
    \ n 7)\n              (count-divisible-by-11 n 7))))\n", "  (cond [(< n 1)\n \
    \        0]\n        [(< n 11)\n         (fizz_buzz_helper n 0)]\n        [(<\
    \ n 13)\n         (fizz_buzz_helper n 2)]\n        [else\n         (+ 1 (fizz_buzz_helper\
    \ n (add1 (mod n 11))))]))\n", "  (cond ((= n 0) 0)\n        ((= (modulo n 11)\
    \ 0) 2)\n        ((= (modulo n 13) 0) 3)\n        (else (fizz_buzz (quotient n\
    \ 11)))))\n</code>\n<|/ a tags=scheme,racket dscore=1 |>\n<| a dscore=1 |>\nYou\
    \ can do this without using modulo, and without a loop. \n<code>", "  (define\
    \ (fizz_buzz-helper n)\n    (cond\n      [(< n 100) (+ (mod n 11) (mod n 13))]\n\
    \      [(< n 10000) (+ (mod n 111) (mod n 131))]\n      [(< n 100000) (+ (mod\
    \ n 1111) (mod n 1311))]\n      [(< n 1000000) (+ (mod n 11111) (mod n 13111))]\n\
    \      [else 0]))\n  (fizz_buzz-helper n))\n", "  (cond\n    [(<= n 100) (modulo-by-11\
    \ n)]\n    [(<= n 130) (modulo-by-13 n)]\n    [else n]))\n", "  (cond\n    [(=\
    \ n 0) 0]\n    [(and (= (mod n 11) 0)\n           (= (mod n 13) 0))\n     1]\n\
    \    [else (+ 1 (fizz_buzz (- n 1)))]))\n", "  (cond\n    [(= n 0) 0]\n    [(=\
    \ n 1) 1]\n    [(and (= (modulo n 11) 0)\n          (= (modulo n 13) 0)) 2]\n\
    \    [else (+ 3 (fizz_buzz (- n 1)))]))\n", "  (cond ((= n 0) 0)\n        ((or\
    \ (= (mod n 11) 0) (= (mod n 13) 0)) 2)\n        (else (fizz_buzz (- n 1)))))\n",
  "  (cond\n    ((= n 0)0)\n    ((= n 1)0)\n    ((= n 3)3)\n    ((= (mod n 3) 0)0)\n\
    \    ((= (mod n 3) 1)1)\n    ((= (mod n 3) 2)2)\n    ((= (mod n 3) 4)4)\n    ((=\
    \ (mod n 3) 5)5)\n    ((= (mod n 3) 7)7)\n    (else (+ 1 (fizz_buzz (- n 1))))))\n",
  "  (cond [(= n 1) 0]\n        [(= n 3) 0]\n        [(= (mod-n n 11) 0) 1]\n    \
    \    [(= (mod-n n 13) 0) 2]\n        [else (+ 3 (fizz_buzz (div-n n 11)))]))\n",
  "  (cond ((= n 0)\n         0)\n        ((= (mod n 11) 0)\n         (cond ((= (mod\
    \ n 13) 0)\n                (+ n 1))\n              (else (+ n (fizz_buzz (/ n\
    \ 13)))))\n        (else (+ n (fizz_buzz (/ n 11)))))\n        )))", "  (let loop\
    \ ([remainder n] [[counter 0] [digits '()]])\n    (if (= remainder 0)\n      \
    \  (append digits (list counter)) \n        (loop (quotient remainder 11) (cons\
    \ remainder (list counter digits)))))))\n", "  (cond\n    [(<= n 7) 0]\n    [(=\
    \ (modulo n 11) 0)\n     (cond (= (modulo n 13) 0)\n            0\n          \
    \  [else (+ 1 (fizz_buzz (quotient n 11)))])]\n    [(= (modulo n 13) 0)\n    \
    \ (cond (= (modulo n 11) 0)\n            0\n            [else (+ 1 (fizz_buzz\
    \ (quotient n 13)))])]\n    [else (+ 1 (fizz_buzz (quotient n 11)))]))\n", " \
    \ (cond\n    [(< n 1) 0]\n    [(= (modulo-by-11 n) 7) (+ 1 (fizz_buzz (quotient\
    \ n 11)))]\n    [(= (modulo-by-13 n) 7) (+ 1 (fizz_buzz (quotient n 13)))]\n \
    \   [else (fizz_buzz (quotient n 7))]))\n", "  (if (<= n 0)\n      0\n      (+\
    \ (mod n 11)\n         (mod n 13))\n      )\n  )\n", "  (if (or (= n 0) (< n 10))\
    \ n\n      (if (= (mod n 11) 0) (+ 1 (fizz_buzz (div n 11)))\n              (+\
    \ 1 (fizz_buzz (div n 13)))\n              0))))\n", "  (cond\n    [(= 0 (modulo\
    \ n 11)) 'zero]\n    [(= 0 (modulo n 13)) 'two]\n    [else (+ (fizz_buzz (quotient\
    \ n 11)) 'seven)])) ; 7\n</code>\n<|/ a tags=racket,scheme,integer,fizzbuzz |>\n\
    <| c |>\nIt's a good solution, but you can avoid the recursion by using the modulo\
    \ and quotient functions directly. Also, it's good style to write `if` instead\
    \ of `cond`. `cond` makes it hard to read and maintain.\n<|/ c |>\n<| c |>\nThanks\
    \ for the suggestion! I've updated my answer.\n<|/ c |>\n<| a |>\nHere is a simple\
    \ implementation using FizzBuzz function:\n<code>", "  (define (fizz_buzz-helper\
    \ n)\n    (cond\n      [(= n 0) 0]\n      [(= n 1) 1]\n      [(= (% n 11) 0) 1]\n\
    \      [(= (% n 13) 0) 2]\n      [else (+ 3 (fizz_buzz-helper (/ n 11)))]))\n\
    \  (fizz_buzz-helper n))\n", '  (= (modulo-by-two (remainder n 10) 10) 7))', " \
    \ (cond ((= n 0)\n         0)\n        (else\n         (cond ((= (remainder n\
    \ 11) 0)\n                (+ 1 0))\n              ((= (remainder n 13) 0)\n  \
    \              (+ 1 0))\n              (else\n               (if (= (remainder\
    \ n 7) 0)\n                   (+ (fizz_buzz (/ n 7)) 1)\n                   (+\
    \ (fizz_buzz (/ n 11)) 1)\n                   (+ (fizz_buzz (/ n 13)) 1)))))))\
    \ ;; (+ ...) concatenates strings and evaluates them left to right (lazily)\n",
  "  (cond ((= n 0) 0)\n        ((= n 1) 0)\n        ((= (mod n 3) 0) 2)\n       \
    \ (else (+ 1 (fizz_buzz (quotient n 3))))))\n", "  (if (zero? n)\n      0\n  \
    \    (+ (digits-of-n (quotient n 11)) (digits-of-n (quotient n 13))))\n  )\n",
  "  (cond [(= n 0) 0]\n        [(= n 1) 0]\n        [(= n 7) (+ 0 (+ 1 (fizz_buzz\
    \ (/ n 11))))]\n        [(= n 13) (+ 0 (+ 1 (fizz_buzz (/ n 13))))]\n        [else\
    \ (+ 1 (fizz_buzz (- n (quotient n 11)))) (+ 0 (+ 1 (fizz_buzz (/ n 13))))]))\n",
  "  (let loop ((n n))\n    (cond\n      [(zero? n) 0]\n      [(or (= (modulo n 11)\
    \ 0)\n           (= (modulo n 13) 0)) 1]\n      [else (+ (loop n (/ n 11))\n \
    \             (loop n (/ n 13)))]))))\n</code>\n<|/ a tags=racket,scheme,fizzbuzz\
    \ dscore=1 |>\n<| c |>\nThis is not correct. It returns 0 for `(fizz_buzz 1)`.\n\
    <|/ c |>\n<| a dscore=1 |>\nHere is my take on it, with Racket syntax. \n<code>",
  "  (cond\n    [(< n 1) (error \"fizz_buzz: n must be an integer\")] \n    [(zero?\
    \ (modulo n 11)) 0]\n    [(zero? (modulo n 13)) 2]\n    [else (+ (fizz_buzz (quotient\
    \ n 11)) (fizz_buzz (quotient n 13)))]))\n", "  (cond\n    [(zero? n) 0]\n   \
    \ [(even? n) (+ 1 (fizz_buzz (/ n 11)))]\n    [(odd? n) (+ 1 (fizz_buzz (/ n 13)))]\n\
    \    [else 0]))\n</code>\n<|/ a dscore=2 |>\n<| a |>\n<code>", "  (cond [(= (mod\
    \ n 11) 0) 0]\n        [(= (mod n 13) 0) 1]\n        [else (+ 1 (fizz_buzz (quotient\
    \ n 11))\n                   (fizz_buzz (quotient n 13)))]))\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nThis is a great solution that works for integer and floating point\
    \ numbers but does not work for floating point numbers (e.g 2.8).\n<|/ c |>\n\
    <| c |>\n: I added a solution which works for floating point numbers as well.\n\
    <|/ c |>\n<| c |>\nThanks Joel. I've posted a solution based on yours so you can\
    \ see how I implemented it. My solution is a recursive solution that will work\
    \ for integers or floats.\n<|/ c |>\n<| a tags=fizzbuzz,racket,scheme |>\nHere's\
    \ a solution for integers. It's a hybrid of the various solutions above. It uses\
    \ quotient, mod, and remainder to determine the number of times a certain digit\
    \ appears in the integer without using any additional procedures.\n<code>", " \
    \ (cond\n    ((= n 0) 0)\n    ((= n 1) 0)\n    ((= (modulo (modulo n 11) 13) 0)\
    \ 1)\n    (else (+ (fizz_buzz (quotient n 11)) (fizz_buzz (quotient n 13)))) ))\n",
  "  (define (iter n m)\n    (if (= m 0)\n        n\n        (iter (quotient n 11)\
    \ (quotient m 11))\n      )\n    )\n  (iter n n))\n", "  (let ((remainder (remainder\
    \ n 11))\n        (count 0))\n    (if (= remainder 7)\n        count\n       \
    \ (fizz_buzz (quotient n 11)))))\n\n#lang racket\n", "  (define (count-digits\
    \ n)\n    (if (zero? n)\n        0\n        (+ 1 (count-digits (quotient n 10)))))\
    \ \n  (count-digits (quotient n 10)))\n", "  (= (mod n 11) (mod n 13))\n  (if\
    \ (zero? n) n\n      (if (= (mod n 11) (mod n 13)) (+ n 1)\n        (fizz_buzz\
    \ (+ n 1)))))\n", "  (if (= n 0)\n      0\n      (if (= (mod n 11) 0)\n      \
    \    (if (= (mod n 13) 0)\n              2\n              (+ 1 (fizz_buzz (- n\
    \ 1)))\n          (+ 1 (fizz_buzz (- n 1)))\n          (+ 1 (fizz_buzz (- n 1)))\n\
    \          (+ 1 (fizz_buzz (- n 1)))\n          (+ 1 (fizz_buzz (- n 1))))\n \
    \     (+ 1 (fizz_buzz (- n 1)))))\n", "  (let loop ((n n))\n    (cond ((> n 0)\n\
    \           (+ (mod n 11) (mod n 13)))\n          (else\n           (loop (sub1\
    \ n))))))\n</code>\n<|/ a |>\n<| c |>\nNice and simple! I've always been a fan\
    \ of writing recursive code with loop and cond.\n<|/ c |>\n<| a tags=racket,loops,scheme\
    \ |>\nAnother way:\n<code>", "  (cond\n    [(< n 0) '0]\n    [(= (modulo n 11)\
    \ 0) '0]\n    [(= (modulo n 13) 0) '2]\n    [else '3]\n    ))\n", "  (define (helper\
    \ n i count)\n    (cond ((= 0 (mod n 11))\n           (if (= 0 (mod n 13))\n \
    \              (print count)\n               (helper n i (+ count 1)))\n     \
    \      (helper n (+ 1 i) (+ count 1)))\n          ((= 0 (mod n 10))\n        \
    \   (if (= 0 (mod n 13))\n               (print count)\n               (helper\
    \ n i (+ count 1)))\n           (helper n (+ 1 i) (+ count 1))))\n  (helper n\
    \ 1 (+ count 1)))\n</code>\n<|/ a tags=racket,modulo |>\n<| c |>\nThank you very\
    \ much. I really appreciate it. This helped me a lot.\n<|/ c |>\n<| a tags=racket,modulo\
    \ dscore=0 |>\nHere is another solution:\n<code>", "  (let ((count 0))\n    (loop\n\
    \       (when (< n 13)\n         (let ((n (modulo n 11)))\n           (if (= n\
    \ 7)\n               (set! count (+ count 1))\n               (loop\n        \
    \          (when (< n 7)\n                    (set! count (+ count 1))\n     \
    \               (when (= n 7)\n                      (set! count (+ count 1))))\n\
    \                  n))))\n      count)))\n", "  (local\n    [(define (fizz_buzz-helper\
    \ n acc)\n      (if (= n 0)\n          acc\n          (fizz_buzz-helper (quotient\
    \ n 11) \n                          (+ (mod n 11) acc)))]\n    [(fizz_buzz-helper\
    \ n 0)]))\n", "  (cond\n    [(<= n 100) (+ 1 (mod n 11) (mod n 13))]\n    [else\
    \ (+ 1 (mod n 11) 1)]))\n", "  (cond\n    [(= n 0)               0]\n    [(= n\
    \ 1)               1]\n    [(= (mod n 11) 0) (+ (fizz_buzz (floor (/ n 11)))\n\
    \                          (fizz_buzz (floor (/ n 13)))\n                    \
    \      1)]\n    [(= (mod n 11) 1) (+ (fizz_buzz (floor (/ n 11)))\n          \
    \                1)]\n    [(= (mod n 13) 0) (+ (fizz_buzz (floor (/ n 13)))\n\
    \                          1)]\n    [(= (mod n 13) 1) (+ 1)]\n    [else      \
    \            0]))\n", "  (if (= n 0)\n      '(0)\n      (if (= (modulo n 11) 0)\n\
    \          '(1 7)\n          (if (= (modulo n 13) 0)\n              '(2 7)\n \
    \             (if (= (modulo n 7) 0)\n                  '(3 7)\n             \
    \     (fizz_buzz (quotient n 7)))))))\n</code>\n<|/ a |>\n<| a tags=racket,scheme,fizzbuzz,lisp\
    \ |>\nA more succinct solution that I used once:\n<code>", "  (loop\n     for\
    \ x from 0 to (- n 1)\n     when (modulo x 11) \n     when (modulo x 13)\n   \
    \  collect (+ x 1))\n  )\n</code>\n<|/ a tags=racket,scheme dscore=3 |>\n<| a\
    \ tags=racket,scheme |>\n<code>", "  (cond\n    [(= n 0)\n     (cond\n       [(=\
    \ (modulo n 11) 0)\n        (cond\n         [(= (modulo n 13) 0)\n          (cond\n\
    \            [(= (modulo n 17) 0)\n             (return 0)]\n            [(= (modulo\
    \ n 17) 1)\n             (return 1)]))]\n         [(= (modulo n 13) 1)\n     \
    \     (return 2)])]\n       [(= (modulo n 11) 1)\n        (return 3)])]\n    [(=\
    \ (modulo n 11) 0)\n     (cond\n       [(= (modulo n 13) 0)\n        (cond\n \
    \        [(= (modulo n 17) 0)\n          (return 0)]\n         [(= (modulo n 17)\
    \ 1)\n          (return 1)])]\n       [(= (modulo n 13) 1)\n        (return 2)])]\n\
    \    [(= (modulo n 13) 0)\n     (cond\n       [(= (modulo n 17) 0)\n        (cond\n\
    \         [(= (modulo n 23) 0)\n          (return 0)]\n         [(= (modulo n\
    \ 23) 1)\n          (return 1)])]\n       [(= (modulo n 17) 1)\n        (return\
    \ 2)])]\n    [(= (modulo n 17) 0)\n     (cond\n       [(= (modulo n 23) 0)\n \
    \       (cond\n         [(= (modulo n 29) 0)\n          (return 0)]\n        \
    \ [(= (modulo n 29) 1)\n          (return 1)])]\n       [(= (modulo n 23) 1)\n\
    \        (return 2)])]\n    [(= (modulo n 23) 0)\n     (cond\n       [(= (modulo\
    \ n 29) 0)\n        (cond\n         [(= (modulo n 37) 0)\n          (return 0)]\n\
    \         [(= (modulo n 37) 1)\n          (return 1)])]\n       [(= (modulo n\
    \ 29) 1)\n        (return 2)])]\n    [(= (modulo n 29) 0)\n     (cond\n      \
    \ [(= (modulo n 37) 0)\n        (cond\n         [(= (modulo n 45) 0)\n       \
    \   (return 0)]\n         [(= (modulo n 45) 1)\n          (return 1)])]\n    \
    \   [(= (modulo n 37) 1)\n        (return 2)])]\n    [(= ", "  (cond\n    ((<\
    \ n 11) (floor (/ (/ n 11 ) 7)  ))\n    ((< n 13) (floor (/ (/ n 13 ) 7)  ))\n\
    \    (else (+ 1 (fizz_buzz (- n 1))))\n  )\n)", "  (cond [(< n 100) (+ 0 (mod\
    \ n (list 11 13)))]\n        [else (+ 0 (mod n (list 11 13))) (+ 0 (mod n (list\
    \ 11 13)))]\n        [else (+ 0 (mod n (list 11 13))) (+ 0 (mod n (list 11 13)))]\n\
    \        [else (+ 0 (mod n (list 11 13))) (+ 0 (mod n (list 11 13)))]\n      \
    \  [else (+ 0 (mod n (list 11 13))) (+ 0 (mod n (list 11 13)))]\n        [else\
    \ (+ 0 (mod n (list 11 13))) (+ 0 (mod n (list 11 13)))]\n        [else (+ 0 (mod\
    \ n (list 11 13))) (+ 0 (mod n (list 11 13)))]\n        [else (+ 0 (mod n (list\
    \ 11 13))) (+ 0 (mod n (list 11 13)))]\n        [else (+ 0 (mod n (list 11 13)))\
    \ (+ 0 (mod n (list 11 13)))]\n        [else (+ 0 (mod n (list 11 13))) (+ 0 (mod\
    \ n (list 11 13)))]\n        [else (+ 0 (mod n (list 11 13))) (+ 0 (mod n (list\
    \ 11 13)))]\n        [else (+ 0 (mod n (list 11 13))) (+ 0 (mod n (list 11 13)))]\n\
    \        [else (+ 0 (mod n (list 11 13))) (+ 0 (mod n (list 11 13)))]\n      \
    \  [else (+ 0 (mod n (list 11 13))) (+ 0 (mod n (list 11 13)))]\n        [else\
    \ (+ 0 (mod n (list 11 13))) (+ 0 (mod n (list 11 13)))]\n        [else (+ 0 (mod\
    \ n (list 11 13))) (+ 0 (mod n (list 11 13)))]\n        [else (+ 0 (mod n (list\
    \ 11 13))) (+ 0 (mod n (list 11 13)))]\n        [else (+ 0 (mod n (list 11 13)))\
    \ (+ 0 (mod n (list 11 13)))]\n        [else (+ 0 (mod n (list 11 13))) (+ 0 (mod\
    \ n (list 11 13)))]\n        [else (+ 0 (mod n (list 11 13))) (+ 0 (mod n (list\
    \ 11 13)))]\n        [else (+ 0 (mod n (list 11 13))) (+ 0 (mod n (list 11 13)))]\n\
    \        [else (+ 0 (mod n (list 11 13))) (", "  (define (fizz_buzz_loop n i)\n\
    \    (cond ((= n 0)\n           i)\n          ((= (mod n 11) 0)\n           (fizz_buzz_loop\
    \ (quotient n 11) (+ i 1)))\n          ((= (mod n 13) 0)\n           (fizz_buzz_loop\
    \ (quotient n 13) (+ i 1)))\n          (else\n           (fizz_buzz_loop (quotient\
    \ n 10) (+ i 1)))))\n  (fizz_buzz_loop n 0))\n</cell>\n<text>\nExercise 3\nThe\
    \ digits of your phone number", "  (define (count-digits n)\n    (let loop ((n\
    \ n) (digit 0))\n      (if (zero? n)\n          digit\n          (loop (quotient\
    \ n 10)\n                (+ digit (if (zero? (modulo n 10))\n                \
    \          1\n                          0)))\n      )))\n  (if (zero? n)\n   \
    \   0\n      (count-digits (modulo n 10))))\n</code>\n<|/ a tags=scheme,racket\
    \ |>\n<| a tags=scheme,racket |>\nThis is a solution in scheme using only built-in\
    \ functions.\n<code>", "  (cond [(< n 10) 0]\n        [(= n 13) 0]\n        [(=\
    \ n 11) (cond [(= (remainder n 11) 0) 1]\n                        [(= (remainder\
    \ n 11) 1) 2])\n        [else (+ 1 (fizz_buzz (quotient n 11)))]))))\n</code>\n\
    <|/ a |>\n<| c |>\nI'm fairly new to this, but I don't understand why the result\
    \ is either 0 or 1 -- why not 2 or 3? Why is the second test needed at all?\n\
    <|/ c |>\n<| c |>\nThe second test is needed because the first test is `(= (remainder\
    \ n 11) 0)`, which means that the number `11` appears exactly once in `n`, and\
    \ that's not enough.\n<|/ c |>\n<| a tags=scheme,racket,lisp dscore=2 |>\nThis\
    \ question has already been answered but for reference, here are a few additional\
    \ approaches:\nIn Scheme you can use a helper procedure that calculates the number\
    \ of fizz buzz instances for you.  Here's an implementation in Racket (but you\
    \ get the idea):\n<code>", "  (if (= n 0)\n      0\n      (if (= (mod n 11) 0)\n\
    \          (+ 1 (fizz_buzz (- n 1)))\n          (if (= (mod n 13) 0)\n       \
    \       (+ 1 (fizz_buzz (- n 1)))\n              (+ 1 (fizz_buzz (- n 1))))))\n",
  "  (if (zero? n)\n      0\n      (+ n\n         (* (remainder n 11)\n          \
    \  (if (= (modulo n 11) 0) 13\n              11)))\n    )\n  )\n", "  (cond\n\
    \    [(zero? n) 0]\n    [(= (modulo n 11) 0) 2]\n    [(= (modulo n 13) 0) 3]\n\
    \    [else (fizz_buzz (quotient n 11)) (+ 2 (fizz_buzz (quotient n 13)))]))\n",
  "  (cond [(< n 1) 0]\n        [(= (modulo (quotient n 11) 13) 0) 2]\n        [(=\
    \ (modulo (quotient n 11) 13) 7) 3]\n        [else (fizz_buzz (quotient n 11))]))\n\
    </code>\n<|/ a tags=racket,lisp |>\n<| a tags=racket,lisp |>\nRacket has a built-in\
    \ primitive called modulo, which returns the remainder of the division of the\
    \ first argument by the second. For instance, 3 mod 5 = 2 remains 2 mod 5 = 0.\
    \ So, in your example, you could write\n<code>", "  (if (or (= n 0)\n        \
    \  (= n 1)\n          (= n 2)\n          (= n 3)\n          (= n 4)\n        \
    \  (= n 5)\n          (= n 6)\n          (= n 7)\n          (= n 8)\n        \
    \  (= n 9)\n          (= n 10)\n          (= n 11)\n          (= n 12))\n    \
    \  0\n      (+ (- n 9)\n         (- n 6)\n         (- n 3)\n         (- n 1)\n\
    \         (- n 4))\n      )\n  )", "  (count-if\n   (lambda (i)\n     (and (integer?\
    \ (remainder n i))\n          (even? (remainder n i)))\n   (quotient n 10))))\n\
    </code>\nThe trick is to create a procedure that evaluates the predicate (lambda\
    \ (i) (and (even? (remainder n i)) (even? (remainder n i)))). You could also use\
    \ something like (lambda (i) (even? (remainder n i))) (which evaluates to (lambda\
    \ (i) (and (even? (remainder n i)) (even? (remainder n i))))). Finally, we could\
    \ use (lambda (i) (remainder n i)) instead of (lambda (i) (even? (remainder n\
    \ i))). \nThe procedure count-if evaluates the predicate against all integers\
    \ from 0 to the input parameter n, and returns the number of times it evaluates\
    \ to true.\n<|/ a |>\n<| c |>\n`count-if` exists in Racket (a dialect of Lisp).\
    \ It also exists in Scheme and Emacs Lisp, and it also exists in Clojure (a Lisp\
    \ dialect).\n<|/ c |>\n<| c |>\nThank you. I was looking at `count-if` in `racket`\
    \ and didn't see that `count-if` is in `r5rs`. Updated the post.\n<|/ c |>\n<|\
    \ a tags=scheme,racket,racket-student-languages,lisp |>\nHere's a recursive solution\
    \ that is simple and easy to understand:\n<code>", "  (cond [(= n 0)\n       \
    \  0]\n        [(= (modulo n 11) 0)\n         (+ 1 (fizz_buzz (quotient n 11)))]\n\
    \        [(= (modulo n 13) 0)\n         (+ 1 (fizz_buzz (quotient n 13)))]\n \
    \       [else\n         (+ (fizz_buzz (quotient n 10)) (fizz_buzz (quotient (quotient\
    \ n 10) 10)))]))\n", "  (cond\n    [(< n 0)\n     (printf \"~a~n\" 0)]\n    [(<\
    \ n 7)\n     (printf \"~a~n\" 0)]\n    [else\n     (cond\n       [(= (mod n 11)\
    \ 0)\n        (printf \"~a~n\" 0)]\n       [(= (mod n 13) 0)\n        (printf\
    \ \"~a~n\" 2)]\n       [else\n        (cond\n          [(= (mod n 7) 0)\n    \
    \       (printf \"~a~n\" 2)]\n          [else\n           (printf \"~a~n\" 3)]\n\
    \         )])]))\n", "  (cond [(= n 0) (- 1 0)]\n        [(= n 1) (- 1 0)]\n \
    \       [(= (mod n 11) 0) (+ 1 (fizz_buzz (quotient n 11)))]\n        [(= (mod\
    \ n 13) 0) (+ 1 (fizz_buzz (quotient n 13)))]\n        [else (+ 1 (fizz_buzz (quotient\
    \ n 11)))]))\n", "  (define (loop x count)\n    (if (= (mod x 11) 7) (loop x (+\
    \ count 1))\n      (if (= (mod x 13) 7) (loop x (+ count 1))\n        count)))\n\
    \  (loop n (- count 1)))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
