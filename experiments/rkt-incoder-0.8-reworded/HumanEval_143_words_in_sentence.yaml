name: HumanEval_143_words_in_sentence
language: rkt
prompt: "#lang racket\n\n;; You are given a string representing a sentence,\n;; the\
  \ sentence contains some words separated by a space,\n;; and you have to return\
  \ a string that contains the words from the original sentence,\n;; whose lengths\
  \ are prime numbers,\n;; the order of the words in the new string should be the\
  \ same as the original one.\n;; Example 1:\n;; >>> (words_in_sentence \"This is\
  \ a test\")\n;; \"is\"\n;; Example 2:\n;; >>> (words_in_sentence \"lets go for swimming\"\
  )\n;; \"go for\"\n;; Constraints:\n;; * 1 <= len(sentence) <= 100\n;; * sentence\
  \ contains only letters\n(define (words_in_sentence sentence)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate words_in_sentence))\n\
  \    (check-equal? (candidate \"This is a test\") \"is\")\n    (check-equal? (candidate\
  \ \"lets go for swimming\") \"go for\")\n    (check-equal? (candidate \"there is\
  \ no place available here\") \"there is no place\")\n    (check-equal? (candidate\
  \ \"Hi I am Hussein\") \"Hi am Hussein\")\n    (check-equal? (candidate \"go for\
  \ it\") \"go for it\")\n    (check-equal? (candidate \"here\") \"\")\n    (check-equal?\
  \ (candidate \"here is\") \"is\")\n))\n\n(test-humaneval)"
completions: ["  (let loop ((sentence-len sentence) (result '())\n           (index\
    \ 0))\n    (cond ((= index sentence-len)\n           (string-append result (car\
    \ sentence)))\n          ((string=? (car sentence) \" \")\n           (loop (sub1\
    \ (car sentence)) result\n                 (add1 index)))\n          ((not (string=?\
    \ (car sentence) \" \"))\n           (loop (sub1 (car sentence)) result\n    \
    \             (add1 index)))\n          (else (loop (sub1 (car sentence)) result\
    \ (add1 index)))))\n  result)\n", "  (define (find word)\n    (cond ((= (length\
    \ word) 1)\n           (append sentence word))\n          ((prime? (length word))\n\
    \           (cons word (find (rest word))))\n          (else\n           (find\
    \ (rest word)))))\n  (find (reverse sentence)))\n", "  (if (string? sentence)\
    \ ; checks if string is a string\n      (let ([lst (split sentence #\" \")])\n\
    \        (append (filter (lambda (w) (or (= (length w) (length lst)) (prime? length)))\n\
    \                  lst))\n      '()))) ;; else returns nothing", "  (if (null?\
    \ sentence)\n      '()\n      (let ([word (car sentence)])\n        (if (empty?\
    \ word)\n            (cons word\n                  (words_in_sentence (cdr sentence)))\n\
    \            (append (words_in_sentence (cdr sentence))\n                    (list\
    \ (string->list\n                          (list->string word)))))))\n", "  (cond\
    \ ((empty? sentence) '())\n        ((number? (length sentence)) '())\n       \
    \ (else (append (map (lambda (x) (first x)) (split-at (length sentence) sentence))\n\
    \                      (words_in_sentence (substring (drop 1 (split-at (length\
    \ sentence) sentence)))\n                     )\n               )\n      )\n)\n",
  "  (let-values (((a b c) (b c) (b c))\n               ((a b) (a b) (a b)))\n   \
    \ (let* ((letters (string->list sentence))\n           (lengths (map (lambda (letter)\n\
    \                             (string-length (string->string letter)))\n     \
    \                    letters))\n           (primes (filter odd? lengths)))\n \
    \     (map (lambda (prime)\n            (list a b c))\n          primes)\n   \
    \   (string-append (map (lambda (prime)\n                           (string->list\
    \ (string->string prime)))\n                           primes)\n             \
    \        (map (lambda (prime)\n                            (string->list letters))\n\
    \                           primes)\n                     ' ' ' '))))))\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\nI agree with your solution, but your solution is too\
    \ complicated for me to understand. Can you explain why you used (let-values (((a\
    \ b c) (b c) (b c)) ((a b) (a b) (a b))))?\n<|/ c |>\n<| c |>\nIt is not too complicated.\
    \ There are 3 cases when a letter needs to go into a \"bucket A\" then a \"bucket\
    \ B\" and then a \"bucket C\". For \"bucket A\" we know that the letter must go\
    \ into the \"bucket C\", for \"bucket B\" we know that the letter must go into\
    \ \"bucket A\" and \"bucket C\" and for \"bucket C\" we know that the letter must\
    \ go into \"bucket B\". Then we can get the list of letters from \"bucket C\"\
    \ by using a `map` of `(lambda (letter) (list letter ))` then we can append them\
    \ to the list of letters from \"bucket A\" and finally we can append them to the\
    \ list of letters from \"bucket B\". Does it make sense?\n<|/ c |>\n<| c |>\n\
    Yes. I think I got it. Thanks for your explanation!\n<|/ c |>\n<| c |>\nOk I think\
    \ I finally got it. Thanks for your explanation.\n<|/ c |>\n<| a tags=racket,scheme\
    \ dscore=1 |>\nYou could write a simple recursive function using a helper function.\
    \ In the helper function you would check which of the buckets has the letter and\
    \ move it to the other bucket if needed. You then go through all the letters in\
    \ the word one by one and move the letters to the buckets in the helper function\
    \ until you encounter a letter that is already in the correct bucket.\n<code>",
  "  (map #(substring sentence 0 (string-length %)) (split #\\Space sentence)))\n",
  "  (cond\n    [(empty? sentence) \"\"]\n    [(equal? (first sentence) \"\") \"\"\
    ]\n    [else\n     (append (words_in_sentence (rest sentence))\n             (first\
    \ (split-string (first sentence) ' '))\n             (words_in_sentence (rest\
    \ (split-string (first sentence) ' ')))]))\n      ]\n)\n", "  (cond\n    ((null?\
    \ sentence) '())\n    ((string=? sentence \"abc\") \"abc abc abc\")\n    ((string=?\
    \ sentence \"def\") \"def def def\")\n    ((string=? sentence \"ghi\") \"ghi\"\
    )\n    ((string=? sentence \"jkl\") \"jkl\")\n    ((string=? sentence \"mno\"\
    ) \"mno\")\n    ((string=? sentence \"pqrs\") \"pqrs pqrs\")\n    ((string=? sentence\
    \ \"tuv\") \"tuv tuv\")\n    ((string=? sentence \"wxyz\") \"wxyz wxyz wxyz\"\
    )))\n", "  (define (helper sentence words)\n    (cond\n      [(empty? sentence)\
    \ words]\n      [(prime? (length sentence)) (cons (first sentence) words)]\n \
    \     [else (helper (rest sentence) (cons (first sentence) (helper sentence words)))]))\n\
    \  (helper sentence '()))\n", "  (cond\n    [(empty? sentence) (newline)\n   \
    \  (newline)\n     (newline)\n     (newline)\n     (newline)\n     (newline)\n\
    \     (newline)\n     (newline)\n     (newline)\n     (newline)\n     (newline)\n\
    \     (newline)\n     (newline)\n     (newline)\n     (newline)\n     (newline)\n\
    \     (newline)\n     (newline)\n     (newline)\n     (newline)\n     (newline)\n\
    \     (newline)\n     (newline)\n     (newline)\n     (newline)\n     (newline)\n\
    \     (newline)\n     (newline)]\n    [else\n     (loop\n        (set! new_string\
    \ \"\")\n        (set! new_string_length 0)\n        (set! index_of_first_word\
    \ 0)\n        (set! index_of_word 0)\n        (cond\n          [(char->integer\
    \ (car sentence)) (set! index_of_first_word 0)]\n          [(char->integer (car\
    \ sentence)) (set! index_of_word 0)]\n          [else (loop\n              [char\
    \ (cdr sentence)\n               new_word (substring (sentence index_of_first_word)\
    \ 0 0)\n               new_string_length (+ new_string_length 1)\n           \
    \    new_string (+ new_string (new_word))]\n              [(char->integer (car\
    \ sentence)) (set! index_of_word 1)]\n              [(char->integer (car sentence))\
    \ (set! index_of_first_word 2)]\n              [else (loop\n                 \
    \ [char (cdr sentence)\n                   new_word (substring (sentence index_of_first_word)\
    \ 0 0)\n                   new_string_length (+ new_string_length 1)\n       \
    \            new_string (+ new_string (new_word))\n                   (set! index_of_word\
    \ (+ index_of_word 1))]\n                  [(char->integer (car sentence)) (set!\
    \ index_of_first_word (+ index_of_word 2))]\n                  [else\n       \
    \            (if (= new_string_length 2)\n                       (newline)\n \
    \                      (newline))]\n                  [else (newline)]\n     \
    \             [else (newline)])]\n          [else (newline)]\n          [else\
    \ (newline)])]\n    [else\n     (newline)])\n  (display new_string)\n  (newline))\n",
  "  (define (helper sentence count)\n    (cond ((empty? sentence) '())\n        \
    \  ((number? (length sentence)) (helper rest count))\n          ((symbol? (first\
    \ sentence))\n           (helper (rest sentence) count))\n          (else\n  \
    \         (helper (rest sentence)\n                 (cond (count (cons (first\
    \ sentence) count))\n                      ((> count 2) '())\n               \
    \       (else (helper (rest sentence) (+ count 1))))))))\n  (helper sentence 1))\n\
    </code>\n<|/ a tags=scheme,racket |>\n<| c |>\nI got it. I just modified it to\
    \ be more concise. Thank you very much!\n<|/ c |>\n<| a tags=scheme,racket |>\n\
    <code>", "  (define words (remove-if-not (lambda (w) (not (symbolp w))) sentence))\n\
    \  (define primes (map prime-numberp words))\n  (define words-in-sentence (map\
    \ string primes))\n  (join sentence words-in-sentence))\n", "  (let loop ([num-words\
    \ (length sentence)]\n             [words (reverse (substring sentence 0 num-words))])\n\
    \    (if (>= num-words 0)\n        (loop (- num-words 1) words)\n        \"\"\
    )))\n", "  (let ([words (string-split (sentence #\\Space))])\n    (filter prime?\
    \ (map length words))\n    (join words)))\n", "  (cond\n    ((null? sentence)\n\
    \     sentence)\n    ((list? (first sentence))\n     (cons (first sentence) (words_in_sentence\
    \ (rest sentence))))\n    ((char=? (first sentence) ' ')\n     (words_in_sentence\
    \ (rest sentence)))\n    (else (cond\n           ((char=? (first sentence) 'A')\n\
    \            (cons (substring (first sentence) 0 (second (first sentence)) sentence))\n\
    \           ((char=? (first sentence) 'B')\n            (cons (substring (first\
    \ sentence) 1 (second (first sentence)) sentence))\n           ((char=? (first\
    \ sentence) 'C')\n            (cons (substring (first sentence) 2 (second (first\
    \ sentence)) sentence))\n           ((char=? (first sentence) 'D')\n         \
    \   (cons (substring (first sentence) 3 (second (first sentence)) sentence))\n\
    \           ((char=? (first sentence) 'E')\n            (cons (substring (first\
    \ sentence) 4 (second (first sentence)) sentence))\n           ((char=? (first\
    \ sentence) 'F')\n            (cons (substring (first sentence) 5 (second (first\
    \ sentence)) sentence))\n           ((char=? (first sentence) 'G')\n         \
    \   (cons (substring (first sentence) 6 (second (first sentence)) sentence))\n\
    \           ((char=? (first sentence) 'H')\n            (cons (substring (first\
    \ sentence) 7 (second (first sentence)) sentence))\n           ((char=? (first\
    \ sentence) 'I')\n            (cons (substring (first sentence) 8 (second (first\
    \ sentence)) sentence))\n           ((char=? (first sentence) 'J')\n         \
    \   (cons (substring (first sentence) 9 (second (first sentence)) sentence))\n\
    \           ((char=? (first sentence) 'K')\n            (cons (substring (first\
    \ sentence) 10 (second (first sentence)) sentence))\n           ((char=? (first\
    \ sentence) 'L')\n            (cons (substring (first sentence) 11 (second (first\
    \ sentence)) sentence))\n           ((char=? (first sentence) 'M')\n         \
    \   (cons (substring (first sentence) 12 (second (first sentence)) sentence))\n\
    \           ((char=? (first sentence) 'N')\n            (cons (substring (first\
    \ sentence) 13 (second (first sentence)) sentence))\n           ((char=? (first\
    \ sentence) 'O')\n            (cons (substring (first sentence) 14 (second (first\
    \ sentence)) sentence))\n           ((char=? (first sentence) 'P')\n         \
    \   (cons (substring (first sentence) 15 (second (first ", "  (if (empty? sentence)\n\
    \      (list \"no words\")\n      (list (cons (substring sentence 0 (- 1 (length\
    \ sentence))\n                      (remove-if (lambda (c) (= (length (char-code\
    \ c)) (length sentence))) (substring sentence 0 (- 1 (length sentence))))\n  \
    \              (words_in_sentence (substring sentence (+ 0 (- 1 (length sentence))))))))))\n",
  "  (cond\n    ((= (length sentence) 0) \"\")\n    ((= (length sentence) 1) sentence)\n\
    \    ((prime? (length sentence)) sentence)\n    (else (words_in_sentence (split-each-char\
    \ sentence))))))\n", "  (cond\n    ((empty? sentence)\n     '())\n    ((not (number?\
    \ (length sentence)))\n     (cons (first sentence) (words_in_sentence (rest sentence))))\n\
    \    ((number? (length sentence))\n     (cons (first sentence) (words_in_sentence\
    \ (rest sentence))))\n    (else (words_in_sentence (rest sentence)))))\n", " \
    \ (define words (string->list (string->symbol sentence)))\n  (define (words-of-length\
    \ length primes)\n    (cond\n      [(empty? primes) empty]\n      [(> (length\
    \ primes) length) primes]\n      [(member (length primes) (primes)) (cons (first\
    \ primes) (words-of-length (length primes) (rest primes)))]\n      [else (words-of-length\
    \ (length primes) (rest primes))]))\n  (words-of-length length (filter prime?\
    \ primes)))\n</code>\n<|/ a dscore=1 |>\n<| c |>\nthank you so much this helped\
    \ me a lot.\n<|/ c |>\n<| c |>\nPlease remember to \"accept\" the answer if it\
    \ solved your question. [What should I do when someone answers my question?](https://stackoverflow.com/help/someone-answers)\n\
    <|/ c |>\n<| c |>\nI did but it said to wait 10 mins so I will do that when I\
    \ have the time\n<|/ c |>\n<| c |>\nNo worries, glad it helped!\n<|/ c |>\n<|\
    \ a tags=lisp,racket,scheme |>\nThe answer to the original question is very straightforward\
    \ as stated in the problem statement. You have to split the string into words\
    \ and then find the primes present in the list. \n<code>", "  (cond\n    ((= (length\
    \ sentence) 0)\n     (make-string 0))\n    ((list? (first sentence))\n     (let\
    \ ([first-word (rest sentence)])\n       (cond\n         ((= (length first-word)\
    \ 0)\n          (cons (first sentence) (make-string 0))\n          ((= (prime?\
    \ (length first-word)) 0)\n           (cons first-word (words_in_sentence (rest\
    \ sentence))))\n         (else (cons (first sentence) (words_in_sentence (rest\
    \ sentence))))))\n    ((char-alphabetic? (first sentence))\n     (cond\n     \
    \  ((= (prime? (length sentence)) 1)\n        (make-string 0))\n       (else (cons\
    \ (first sentence) (words_in_sentence (rest sentence))))))\n    (else (words_in_sentence\
    \ (rest sentence))))))\n", "  (check-type sentence string)\n  (define words (string->list\
    \ (string->string sentence)))\n  (define primes (list->string (sfilter prime?\
    \ words)))\n  (append primes (reverse primes)))\n</code>\n<|/ a dscore=2 |>\n\
    <| a tags=racket,scheme,primes |>\nI decided to go with the simplest solution\
    \ I could think of, namely a loop that iterates through all numbers from 1 to\
    \ 10 and checks if they are prime.\n<code>", "  (cond\n    [(empty? sentence)\
    \ '()]\n    [(letter? (car sentence)) (words_in_sentence (cdr sentence))]\n  \
    \  [else (cons (car sentence) (words_in_sentence (cdr sentence)))]))\n", "  (match\
    \ sentence\n    [(empty-string)\n     (empty-string)\n     (empty-string)\n  \
    \   (empty-string)\n     (empty-string)\n     (empty-string)\n     (empty-string)\n\
    \     (empty-string)\n     (empty-string)\n     (empty-string)\n     (empty-string)\n\
    \     (empty-string)\n     (empty-string)\n     (empty-string)\n     (empty-string)\n\
    \     (empty-string)\n     (empty-string)\n     (empty-string)\n     (empty-string)\n\
    \     (empty-string)\n     (empty-string)\n     (empty-string)\n     (empty-string)\n\
    \     (empty-string)\n     (empty-string)\n     (empty-string)\n     (empty-string)\n\
    \     (empty-string)\n     (empty-string)\n     (empty-string)\n     (empty-string)\n\
    \     (empty-string)\n     (empty-string)\n     (empty-string)\n     (empty-string)\n\
    \     (empty-string)\n     (empty-string)\n     (empty-string)\n     (empty-string)\n\
    \     (empty-string)\n     (empty-string)\n     (empty-string)\n     (empty-string)\n\
    \     (empty-string)\n     (empty-string)\n     (empty-string)\n     (empty-string)\n\
    \     (empty-string)\n     (empty-string)\n     (empty-string)\n     (empty-string)\n\
    \     (empty-string)\n     (empty-string)\n     (empty-string)\n     (empty-string)\n\
    \     (empty-string)\n     (empty-string)\n     (empty-string)\n     (empty-string)\n\
    \     (empty-string)\n     (empty-string)\n     (empty-string)\n     (empty-string)\n\
    \     (empty-string)\n     (empty-string)\n     (empty-string)\n     (empty-string)\n\
    \     (empty-string)\n     (empty-string)\n     (empty-string)\n     (empty-string)\n\
    \     (empty-string)\n     (empty-string)\n     (empty-string)\n     (empty-string)\n\
    \     (empty-string)\n     (empty-string)\n     (empty-string)\n     (empty-string)\n\
    \     (empty-string)\n     (empty-string)\n     (empty-string)\n     (empty-string)\n\
    \     (empty-string)\n     (empty-string)\n     (empty-string)\n     (empty-string)\n\
    \     (empty-string)\n     (empty-string)\n     (empty-string)\n     (empty-string)\n\
    \     (empty-string)\n     (empty-string)\n     (empty-string)\n     (empty-string)\n\
    \     (empty-string)\n     (empty-string)\n     (empty-string)\n     (empty-string)\n\
    \     (empty-string)\n     (empty-string)\n     (empty", "  (cond [(empty? sentence)\
    \ '()]\n        [else (loop\n                 (append (words (first sentence))\n\
    \                         (words_in_sentence (rest sentence)))\n             \
    \      (if (prime? string-length (first sentence))\n                       '()\n\
    \                       (append (first sentence)\n                           \
    \    sentence))))]))\n", "  (define (helper s)\n    (cond [(empty? s)\n      \
    \     '()]\n          [else (cons (first s)\n                    (helper (rest\
    \ s))])]))\n  (helper (string-split (string sentence) #\\Space #\\Newline)))\n",
  "  (cond ((null? sentence) '())\n        ((empty? sentence) '())\n        (else\
    \ (append (filter-out (lambda (x) (prime? (length x))) sentence) (words_in_sentence\
    \ (substring sentence 0 -1))))))\n", "  (define (helper x acc)\n    (cond ((string=?\
    \ x \"\") acc)\n          ((string=? x space) (helper (substring x 1) acc))\n\
    \          (else (helper (substring x 1)\n                      (append (cons\
    \ (substring x 0 1) acc)\n                               (list (substring x 1\
    \ end)))\n                       ))\n          )\n  )\n  (helper sentence '())\n\
    )\n</cell>\n<cell>\n#lang racket\n", "  (cond\n    [(empty? sentence)\n      \"\
    empty\"]\n    [(list? (car sentence))\n     (words_in_sentence (car sentence))]\n\
    \    [(not (number? (first sentence)))\n     (words_in_sentence (rest sentence))]\n\
    \    [(number? (first sentence))\n     (cond\n       [(even? (first sentence))\n\
    \        (words_in_sentence (rest sentence))]\n       [else\n        (cond\n \
    \         [(> (first sentence) 2)\n           (words_in_sentence (rest sentence))]\n\
    \          [else\n           (cond\n             [(odd? (first sentence))\n  \
    \            (words_in_sentence (rest sentence))]\n             [else\n      \
    \        (words_in_sentence (rest sentence))]\n             [else (list \"empty\"\
    \ \"empty\")]))]\n       [else (list \"empty\" \"empty\")]))]))\n", "  (check-valid-sentence\
    \ sentence)\n  (let ((sentence (split sentence #\\Space)))\n    (string-append\
    \ (map cadr (filter prime? (map string-length sentence))) (join (map append sentence\
    \ sentence))))))\n", "  (define (rem-p1 ws)\n    (for/fold ([w (in-string? sentence)])\n\
    \              ([xs '()])\n              (if (string? ws)\n                  (rem-p1\
    \ ws)\n                  (let ([r (string=? ws w)]\n                        (if\
    \ (and r)\n                            (conj xs w)\n                         \
    \   xs\n                        ))\n                  ))\n              ))\n \
    \ (rem-p1 '()))\n", "  (let loop ((sentence sentence) (result \"\") (i 0))\n \
    \   (cond\n      [(null? sentence) (list result)]\n      [(integer? (length sentence))\
    \ (list result)]\n      [else (cons (first sentence) (loop (rest sentence) (cons\
    \ (first sentence) result) (incf i)))])))\n</code>\n<|/ a |>\n<| c |>\nThe question\
    \ was to count the prime numbers. Not just to find the first prime number.\n<|/\
    \ c |>\n<| c |>\nI guess the problem is about my description of the problem, so\
    \ I've changed my answer to a new one that solves the new problem better. Thank\
    \ you for pointing it out.\n<|/ c |>\n<| c |>\nYou're not counting primes in the\
    \ first place. You're just counting how many prime divisors there are. For example,\
    \ 3 has 3 prime divisors 2,3,5. Your function would return \"2\" because there\
    \ are two prime divisors 2 and 3, which is what it currently returns.\n<|/ c |>\n\
    <| a dscore=0 |>\nI made a simple recursive function to count the number of prime\
    \ factors present in an integer.\n<code>", "  (define (helper str str-size primes)\n\
    \    (cond\n      [(zero? str-size) \"\"]\n      [(equal? (modulo str-size 2)\
    \ 0) (cons (car str) primes)]\n      [(equal? (modulo str-size 2) 1) (cons (car\
    \ str) (helper str (sub1 str-size) primes))]\n      [else (helper (cdr str) (add1\
    \ (modulo str-size 2)) (cons (car str) primes))]))\n  (helper sentence 0 (cons\
    \ '() primes)))\n</cell>\n<cell>\n#lang racket\n", "  (let loop ((sentence sentence)\n\
    \             (new-string \"\")\n             (primes #f)\n             (i 0))\n\
    \    (if (< i (length sentence))\n        (loop (rest sentence)\n            \
    \  (cons (first sentence)\n                    (cons new-string (second sentence))\n\
    \                    primes)\n            (+ i 1))\n        (if (= 0 (mod i 2))\n\
    \            (cons (first sentence)\n                   (cons new-string (second\
    \ sentence))\n                   (set-primes primes (+ i (length sentence)))\n\
    \                   primes)\n            new-string))))\n", "  (cond [(empty?\
    \ sentence)\n         '()]\n        [(is-alpha (first sentence)) (cons (first\
    \ sentence) \n                                          (words_in_sentence (rest\
    \ sentence)))]\n        [else (words_in_sentence (rest sentence))]))\n", "  (cond\
    \ [(empty? sentence) empty]\n        [(= (length sentence) 1) sentence]\n    \
    \    [else (append (words_in_word (reverse sentence))\n                    (words_in_sentence\
    \ (rest sentence)))]))\n", "  (cond [(empty? sentence) empty]\n        [(is_whitespace\
    \ (car sentence)) sentence]\n        [(not(is_letter (car sentence))) sentence]\n\
    \        [else (append (map (lambda (s) (words_in_sentence s)) (cdr sentence))\
    \ (list (car sentence)))]))\n</code>\n<|/ a tags=racket,scheme dscore=1 |>\n<|\
    \ c |>\nI think you misunderstood the question. I don't need to check if the letters\
    \ are prime, just to check if all letters separate words. I updated the question.\n\
    <|/ c |>\n<| c |>\nThat is pretty much the same code, except it uses a list as\
    \ output instead of building a string. I think it is the simplest solution to\
    \ the problem and should be accepted. Of course, if you want it to be a bit more\
    \ advanced, you should probably use a list instead of just building the list with\
    \ append (but then again I haven't read your original solution well enough to\
    \ decide if that's the case or not).\n<|/ c |>\n<| c |>\nThe code doesn't even\
    \ compile, I get this error when running it:\n`(words_in_sentence : not an identifier\
    \ name\n context...:\n  /scratch/scratch/r3hVNK/racket/chapter1.rkt:4:19)`\n<|/\
    \ c |>\n<| c |>\nLooks like you forgot to include `is_prime`. Also `is_letter`\
    \ is an identifier too, not a function, use `char-equal?`.\n<|/ c |>\n<| c |>\n\
    `char-equal?` works with integers, not characters.\n<|/ c |>\n<| a |>\nHere's\
    \ another solution, just for fun:\n<code>", "  (letrec\n    ([primes (build-primes\
    \ (string-length sentence))]\n     ([numbers (build-numbers (length primes))]\n\
    \      [prime-helper (lambda (p n)\n                      (if (>= n 0)\n     \
    \                     (prime-helper p (- n 1))\n                          (numbers))])])\n\
    \    (prime-helper 0 (string-length sentence))))\n", "  (if (null? sentence)\n\
    \      '()\n      (append\n       (map (lambda (word) (string->symbol (length\
    \ word)))\n            (words-by-length sentence))\n       sentence)))\n", " \
    \ (cond\n    [(empty? sentence)\n      (list->string (list->'()))]\n    [(prime?\
    \ (string-length sentence))\n      (cons (first sentence) words_in_sentence (rest\
    \ sentence))]\n    [else\n      (cons (first sentence) (words_in_sentence (rest\
    \ sentence)))]\n   ))\n", "  (define (checker-helper s)\n    (if (null? s)\n \
    \       '()\n        (let ((word (car s)))\n          (if (string=? word \"\"\
    )\n              (checker-helper (cdr s))\n              (if (even? (string.length\
    \ word))\n                  (string-append word (checker-helper s))\n        \
    \          (string-append word \" \" (checker-helper s)))))))\n  (check-type sentence\
    \ string)\n  (check-type (words sentence) string)\n  (loop\n   for i from 1 up\
    \ (string->number (string->list sentence))\n   collect (substring sentence (+\
    \ i 1))\n   into words\n   collect (checker-helper words))\n  (string->list words))\n\
    </code>\n<|/ a tags=racket,scheme |>\n<| c |>\nI appreciate you trying to help\
    \ a noob like me :) I really like your solution though, i think i can get rid\
    \ of all the helper functions.\n<|/ c |>\n<| a dscore=0 |>\nHere's one in Racket,\
    \ using a fold and a filter:\n<code>\n#lang racket\n", "  (check-type sentence\
    \ string)\n  (define (helper sentence result)\n    (string-split sentence \" \"\
    )\n    (cond [(empty? sentence) result]\n          [(even? length) (helper rest\
    \ (conj result (first sentence)))]\n          [else (helper rest (conj result\
    \ (first sentence))) (helper rest (conj result (first sentence))) ]\n        \
    \  )\n  )\n  (helper sentence '())\n)\n", "  (cond\n    [(empty? sentence)\n \
    \    \"_\"]\n    [(number? (string-length sentence)) \"_\"]\n    [(zero? (string-length\
    \ sentence)) \"_\"]\n    [else\n     (append (map (lambda (word) (filter (lambda\
    \ (n) (even? n)) (string-length word)))\n                (partition (lambda (word)\
    \ (equal? (string-length word) (string-length sentence)))\n                  \
    \         sentence))\n          (words_in_sentence (rest sentence))]))))\n", " \
    \ (cond [(empty? sentence) empty]\n        [else (set! result (append (words-in-sentence-helper\
    \ sentence) result))]))\n  result)\n", "  (define (find-primes s)\n    (let loop\
    \ ((i 0)\n              (primes '())\n              (word (substring (s i) 0 (length\
    \ s)))\n              (remains (substring (s i) 0 (length s)))\n             \
    \ (count 0))\n      (if (null? remains)\n          primes\n          (loop (+\
    \ i 1)\n                (cons (first remains)\n                      (loop (+\
    \ i 1)\n                            (cons (first remains)\n                  \
    \                primes))\n                (first remains)\n                (+\
    \ count 1)))\n      (remains)))\n  (find-primes sentence))\n", "  (define (check\
    \ i j)\n    (or (= i (length sentence))\n        (< (add1 (length sentence)) j)\n\
    \        (memq (char sentence i) primes))))\n  (define primes (memq true (take-while\
    \ check (iterate (lambda (i)\n                                               \
    \          (* i i)) 2))))\n  (cons (substring sentence 0 0) (substring sentence\
    \ 0 (length sentence)))\n  )\n", "  (let ((words (make-vector 100 '()))\n    \
    \    (length (make-vector 100 '()))\n        (index (make-vector 100 '())))\n\
    \    (for i 0 (in-range 100 (in-range 100 (in-range 100 (in-range 100 sentence))\n\
    \                           in-range 100 (in-range 100 (in-range 100 (in-range\
    \ 100 sentence))))\n      (let ((word (substring sentence i i)))\n        (for\
    \ j (in-range length (in-range 100 (in-range 100 (in-range 100 (in-range 100 sentence))))\n\
    \              (when (prime? (length (subvector word j)))\n                (vector-push-extend\
    \ j (vector j)))\n              (vector-push-extend word (vector-ref length j)))\n\
    \        (vector-push-extend word (vector-ref words (vector-ref words word))))\n\
    \    (vector-join\n     (lambda (w)\n       (if (equal? (length w) 0)\n      \
    \     \"\"\n           (substring w (car w) (cdr w))))\n     (vector-ref length\
    \ (car words))\n     (vector-ref length (cdr words))\n     (vector-ref index (car\
    \ words))\n     (vector-ref index (cdr words))\n     (vector-ref words (car words))\n\
    \     (vector-ref words (cdr words))\n     words\n     index\n     length\n  \
    \   words))))\n", "  (loop for x from 0 to (length (string->list sentence)) until\
    \ (= (modulo (length sentence) x) 0))\n  (cons (string->list  (substring sentence\
    \ 0 (+ x (length sentence)))) (words_in_sentence (substring sentence (+ x (length\
    \ sentence)))))\n)\n</cell>\n<text>\nProblem 2\nWrite a program that generates\
    \ the following fibonacci numbers:\n\n0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89,\
    \ 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946,\n17711, 28657, 46368,\
    \ 75025, 121393, 196418, 317811, 514229, 832040, 1346269, 2178301, 3524578, 5702881,\n\
    9227465\n\nHint: Use a loop to iterate from 0 to N.\n\n\n</text>\n<cell>", " \
    \ (cond\n    ((null? sentence)\n     (string->symbol \"Nope\"))\n    ((number?\
    \ sentence)\n     (string->symbol \"Nope\"))\n    ((string->symbol sentence)\n\
    \     (cond ((length sentence) 1)\n           ((= (string->length sentence) 2)\n\
    \            (string->symbol \"Nope\"))\n           ((= (string->length sentence)\
    \ 3)\n            (string->symbol \"Nope\"))\n           ((= (string->length sentence)\
    \ 4)\n            (string->symbol \"Nope\"))\n           ((= (string->length sentence)\
    \ 5)\n            (string->symbol \"Nope\"))\n           ((= (string->length sentence)\
    \ 6)\n            (string->symbol \"Nope\"))\n           ((= (string->length sentence)\
    \ 7)\n            (string->symbol \"Nope\"))\n           ((= (string->length sentence)\
    \ 8)\n            (string->symbol \"Nope\"))\n           ((= (string->length sentence)\
    \ 9)\n            (string->symbol \"Nope\"))\n           ((= (string->length sentence)\
    \ 10)\n            (string->symbol \"Nope\"))\n           ((= (string->length\
    \ sentence) 11)\n            (string->symbol \"Nope\"))\n           ((= (string->length\
    \ sentence) 12)\n            (string->symbol \"Nope\"))\n           ((= (string->length\
    \ sentence) 13)\n            (string->symbol \"Nope\"))\n           ((= (string->length\
    \ sentence) 14)\n            (string->symbol \"Nope\"))\n           ((= (string->length\
    \ sentence) 15)\n            (string->symbol \"Nope\"))\n           ((= (string->length\
    \ sentence) 16)\n            (string->symbol \"Nope\"))\n           ((= (string->length\
    \ sentence) 17)\n            (string->symbol \"Nope\"))\n           ((= (string->length\
    \ sentence) 18)\n            (string->symbol \"Nope\"))\n           ((= (string->length\
    \ sentence) 19)\n            (string->symbol \"Nope\"))\n           ((= (string->length\
    \ sentence) 20)\n            (string->symbol \"Nope\"))\n           ((= (string->length\
    \ sentence) 21)\n            (string->symbol \"Nope\"))\n           ((= (string->length\
    \ sentence) 22)\n            (string->symbol \"Nope\"))\n           ((= (string->length\
    \ sentence) 23)\n            (string->symbol \"Nope\"))\n           ((= (string->length\
    \ sentence) 24)\n            (string->symbol \"Nope\"))\n           ((= (string->length\
    \ sentence) 25)\n            (string->symbol \"Nope\"))\n           ((= (string->",
  "  (cond\n    [(empty? sentence) \"\"]\n    [(even? (length sentence)) sentence]\n\
    \    [else (append (words_in_string (substring sentence 0 1))\n              \
    \    (words_in_string (substring sentence 1)))]\n  )\n)\n", "  (check-expect (<=\
    \ 1 (length sentence)) 0)\n  (check-expect (length sentence) 100)\n  (let ((lst\
    \ (make-list 100)))\n    (for-each (lambda (c) (if (>= (length sentence) c)\n\
    \                              (cadr lst)\n                              (cdr\
    \ lst)))\n              sentence)\n    (remove-duplicates lst)))\n", "  (cond\n\
    \    [(empty? sentence) empty]\n    [(cons? sentence) (map car (words_in_sentence\
    \ (cdr sentence)))]\n    [else (words_in_sentence (car sentence))]\n  )\n)\n",
  "  (let ((new-sentence (substring sentence 0 -1)))\n    (for/fold ([new-word \"\"\
    ] [(word \"\") (index (string-length new-sentence) 0)])\n              [new (substring\
    \ (string (substring sentence 0 (+ index (length new-word)) (substring sentence\
    \ (+ index (length new-word)) 100))))]\n              [new-word (cons (substring\
    \ new-word 0 index) (cons new-word (substring new-word (+ index (length new-word))\
    \ 1))])\n      (if (prime? index)\n          (cons new-word new-sentence)\n  \
    \        new-sentence))))\n", "  (cond [(empty? sentence) empty]\n        [(equal?\
    \ (first sentence) (substring sentence (length sentence) 1)) empty]\n        [else\
    \ (cons (first sentence) (words_in_sentence (rest sentence)))]))\n", "  (cond\
    \ [(empty? sentence) '()]\n        [(even? (length (rest sentence)))\n       \
    \  (append (words_in_sentence (split sentence (first sentence)))\n           \
    \        (list (first sentence))\n                   )\n         ]\n        [(odd?\
    \ (length (rest sentence)))\n         (append (words_in_sentence (split sentence\
    \ (first sentence)))\n                   (list (first sentence))\n           \
    \        )\n         ]\n        [else\n         (append (words_in_sentence (split\
    \ sentence (first sentence)))\n                   (list (first sentence))\n  \
    \                 )\n         ]\n        )\n)", "  (let ((words (split-at (length\
    \ sentence) sentence)))\n    (map (lambda (x)\n           (filter (lambda (y)\
    \ (= (length x) y))\n                  words))\n         words)))\n", "  (cond\
    \ [(empty? sentence)\n         '()]\n        [else\n         (append (cons (first\
    \ sentence)\n                       (words_in_sentence (rest sentence)))\n   \
    \             (words_in_sentence (rest sentence)))]))\n", "  (filter (lambda(x)\n\
    \            (string->number (string-length x)))\n          (map string->string\
    \ sentence)))\n", "  (define words (string-split (strip-all \" \") sentence))\n\
    \  (define primes ())\n  (define word-in-primes ())\n  (define new-sentence ())\n\
    \  (for w (in-range (length words) '())\n    (let ((temp (make-prime-number (length\
    \ words))))\n      (if (equal? (modulo w temp) 1)\n          (push w primes)\n\
    \          (push w word-in-primes))))\n  (for p (in-range (length primes) '())\n\
    \    (if (member p word-in-primes)\n        (push p new-sentence)\n        (push\
    \ p word-in-primes)))\n  (string-join new-sentence \" \"))\n", "  (cond\n    [(empty?\
    \ sentence) \"\"]\n    [(number? (length (split sentence #\\Space :type :characters))\
    \ ) ]\n    [else (append (map symbol->string (string->list sentence)) (words_in_sentence\
    \ (remove-char #\\Space sentence)))]\n  ))\n</cell>\n<text>\nExercise: Removing\
    \ duplicate words\n\n</text>\n<code language=dyalog-kernel>", "  (define (prime-check-helper\
    \ word index)\n    (if (null? word)\n        #f\n        (cond\n          [(integer?\
    \ (first word)) #t]\n          [else (prime-check-helper (rest word) index)]\n\
    \          [else (prime-check-helper (rest word) index)]))\n    (prime-check-helper\
    \ sentence index))\n\n  (define (prime-check-helper sentence index)\n    (cond\n\
    \      [(empty? sentence) #t]\n      [else (cons (first sentence) (prime-check-helper\
    \ (rest sentence) index))]))\n\n  (prime-check-helper sentence 0))\n", "  ;; Split\
    \ the sentence into a list of words. \n  (define (split-sentence sentence)\n \
    \   (let* ((sentence-chars (string->list sentence))\n           (words (remove-duplicates\
    \ sentence-chars))\n           (words-num (length words))\n           (result\
    \ (make-string sentence-num))\n           (i 0))\n      (if (= i words-num)\n\
    \          result\n          (split-sentence (append words (list-ref sentence-chars\
    \ i))\n                         ++(+ i 1) (substring result 0 i) (+ i 1)))))\n\
    \  ;; The result consists of prime numbers and each word from the original sentence.\n\
    \  (split-sentence sentence))\n", "  (map string (partition-all (lambda (x) (number?\
    \ (string->number (string->list x))) (string->list sentence))))\n)\n", "  (define\
    \ (str-length str)\n    (sub1 (length str)))\n  (let ((numbers (make-vector str-length)))\n\
    \    (map-indexed (lambda (i num)\n                   (when (= i (mod num (length\
    \ sentence)))\n                     (set! numbers (vector-push-back num numbers))))\n\
    \      numbers\n      (lambda (idx word)\n        (build-string (map (lambda(x)\
    \ (length x))\n                          (partition (substring sentence idx) (substring\
    \ sentence (add1 idx))))))))\n</cell>\n<text>\nWe can now test your implementation\
    \ using the provided test cases. This should be a correct implementation.\n\n\n\
    </text>\n<cell>", "  (let* ((words (string->list sentence))\n         (primes\
    \ (for/list ([i 2]\n                          [i prime?])\n                  \
    \   (let ([test (lambda (i)\n                                 (and (= i i)\n \
    \                                     (prime? (string->length i))))])\n      \
    \                 (if (null? words)\n                           (for/list ([j\
    \ i]\n                                       [j (lambda (i)\n                \
    \                              (or (test (+ i 1))\n                          \
    \                        (test (+ i 2)))\n                                   \
    \           (> j primes))])\n                             (string->list j))\n\
    \                           (let ([new (filter (lambda (i)\n                 \
    \                             (test (string->length i))) words)]\n           \
    \                      (cond [(null? new) (list (first words))]\n            \
    \                           [(not (null? new)) (cons (first new) new)]))))))))))\n\
    </code>\n<|/ a tags=scheme |>\n<| c |>\nIt's not a very good solution. For example,\
    \ for `(words_in_sentence \"Lets go for swimming\")` the result should be `(\"\
    go\" \"for\")` but your code returns `(\"go\" \"for\" \"swimming\")`.\n<|/ c |>\n\
    <| c |>\nYou really shouldn't be using `string->list` on strings that are not\
    \ supposed to be words; you're going to lose any whitespace characters. This will\
    \ work fine for `(words_in_sentence \"Lets go for swimming\")` but will fail with\
    \ `(\"Lets go for swimming\")`.\n<|/ c |>\n<| c |>\nYes, I'm aware of that. Hence\
    \ the comment about whitespace characters.\n<|/ c |>\n<| c |>\nThanks for that\
    \ clarification. I will edit my answer.\n<|/ c |>\n<| c |>\nI added a second solution\
    \ that also works with words with apostrophes and that also takes care of whitespace\
    \ and apostrophes in the strings.\n<|/ c |>\n<| a dscore=1 |>\nYou can do this\
    \ with string->list and then filter with member:\n<code>", "  (define (helper\
    \ sentence result)\n    (cond\n      [(null? sentence)\n       result]\n     \
    \ [(string=? (first sentence) ?space)\n       (helper (rest sentence)\n      \
    \          (cons (first sentence) result))]\n      [else\n       (helper (rest\
    \ sentence)\n                (append result (list (first sentence))))]))\n  (helper\
    \ (split sentence ?space)\n          #f))\n</code>\n<|/ a |>\n<| c |>\nThis solution\
    \ is incorrect and would blow the stack if given a large input.\n<|/ c |>\n<|\
    \ c |>\nThe stack size is limited by the number of recursive calls. Since the\
    \ stack has to have a limited size, I believe this solution is correct regardless\
    \ of the size of the input.\n<|/ c |>\n<| c |>\n: you're right. But the stack\
    \ size is now 100. I'm assuming that was a typo.\n<|/ c |>\n<| c |>\nSorry, the\
    \ typo was just an accident.\n<|/ c |>\n<| a dscore=2 tags=racket,scheme |>\n\
    I suspect that the problem may be that the split is giving you a list, whereas\
    \ you want a string? Or it may be that I'm missing something. \nI haven't used\
    \ racket, so there may be some extra functions in there I'm just not aware of.\
    \ But I think you want this:\n<code>", "  (let loop ((result \"\")\n         \
    \    (temp \"\")\n             (i 0))\n    (if (empty? sentence)\n        result\n\
    \        (loop (append result temp) (substring sentence 0 i) (i + 1)))\n    (loop\
    \ (append result temp) (substring sentence 0 i) (i + 1))))\n", "  (let helper\
    \ ([s sentence] (string->list s))\n    (cond\n      [(null? s) \"\"]\n      [else\
    \ (cons (string->list s)\n                  (map helper (rest s))))]))\n", " \
    \ (define (prime number)\n    (if (= number 2)\n        #t\n        (and (= (modulo\
    \ number prime)1) (prime (+ number 1)))))\n  (define (helper word sentence prime-numbers)\n\
    \    (cond [(empty? sentence)\n           sentence]\n          [(prime? (string-length\
    \ word))\n           (cons word prime-numbers)]\n          [else\n           (helper\
    \ (append word (substring sentence 0 1)) (substring sentence 1 (inc (string-length\
    \ word))) (cons word prime-numbers))]))\n  (helper ' ' sentence '()))\n", "  (let\
    \ ((words '())\n        (index (memorize #f sentence))\n        (str '()))\n \
    \   (cond\n      ((null? sentence) '())\n      (else\n       (cond\n         ;;\
    \ We are at the end of sentence or we've already found the prime numbers.\n  \
    \       ((and (<= index #f)\n               ;; The last word of the string was\
    \ a non-prime number.\n               (not (= (modulo index (length sentence))\n\
    \                      (modulo (length sentence) (length str))))\n           ;;\
    \ The last word of the string was a prime number\n           (push index str)\n\
    \           ;; Not at the end of sentence\n           (cond ((= index #f)\n  \
    \                 ;; We are at the end of the string, which means all the\n  \
    \                 ;; prime numbers are in the string, so push it down to the\n\
    \                   ;; front\n                   (push (length str) str))\n  \
    \               (else (set! index (+ index #f)\n                             \
    \ (memorize index (+ index #f (length str))\n                                \
    \          (str @(subseq sentence index)))\n                              (cond\n\
    \                                ((< index #f)\n                             \
    \    ;; The last word is not a prime number\n                                \
    \ (push (length str) str))\n                                (else (words_in_sentence\n\
    \                                           (subseq sentence (+ index #f 1)))))))))\n\
    \         ;; If we've not found a prime number yet, push it down to the front\n\
    \         ;; and search for the next prime number\n         (push index str)\n\
    \         (set! index (+ index #f (length str))\n                (memorize index\
    \ (+ index #f (length str))\n                          (str @(subseq sentence\
    \ index)))\n                (cond\n                  ((< index #f)\n         \
    \          ;; The last word is not a prime number\n                   (push (length\
    \ str) str))\n                  (else (words_in_sentence\n                   \
    \        (subseq sentence (+ index #f 1))))))))))))\n", "  (let ((new-string \"\
    \")\n        (str-len 0))\n    (loop for ch in sentence\n          for str-len\
    \ from 1\n          for str-char from 0\n          until (= str-len 0)\n     \
    \     do (string-append (substring str-char str-len 1)\n                     \
    \      (substring sentence (+ str-char 1) (+ str-len 1))\n                   \
    \        new-string))\n    new-string))\n</code>\n<|/ a dscore=0 tags=racket,string,list\
    \ |>\n<| a |>\nHere's a solution using recursion:\n<code>", "  (let ([words (remove-if\
    \ (lambda (x) (prime? x)) (split sentence #\\Space))]\n        [num-primes (length\
    \ words)])\n    (string-append (map car (remove-if #(< % num-primes) words)) #\\\
    Space)\n    (words_in_sentence (rest (split sentence #\\Space)))))\n</code>\n\
    <|/ a tags=racket,string |>\n<| c |>\n`remove-if` doesn't work if the predicate\
    \ is applied to the list elements, but only to the list itself. So you'd have\
    \ to map `remove-if` to `(map remove-if ...)` first. Also, `(prime? x)` is the\
    \ same as `number? x`, so `remove-if` doesn't work. `split` takes an optional\
    \ separator argument, so it can be used like `(split sentence #\\Space)`.\n<|/\
    \ c |>\n<| c |>\nThank you for the tips! I knew I was doing something wrong when\
    \ I wrote it like this, because I had the idea to make it work even with lists\
    \ of length 1, but I didn't think of that. Thanks again, I'll correct the code.\n\
    <|/ c |>\n<| c |>\nThank you for your answer! I was able to solve it myself and\
    \ I already added the answer down here too.\n<|/ c |>\n<| c |>\nThanks for posting\
    \ your solution! I didn't know about `split` before now. Looks great!\n<|/ c |>\n\
    <| c |>\nIt would be very helpful if you could add an explanation of what each\
    \ part does in the answer.\n<|/ c |>\n<| a |>\nThis is my solution so far. It\
    \ works, but I don't know if it's a smart or inefficient solution and also don't\
    \ really know how I would apply map or remove-if here (although it might be possible\
    \ to make it work). So if you have any tips, that would be great. Also, I haven't\
    \ tested it yet, but I hope that it will work fine.\n<code>", "  (define (check\
    \ word)\n    (cond\n      [(even? word) (check-prime2 word)]\n      [(odd? word)\
    \ (check-prime3 word)]\n      [(= 0 (mod word 2)) (check-prime4 word)]\n     \
    \ [(= 0 (mod word 3)) (check-prime5 word)]\n      [(= 0 (mod word 4)) (check-prime6\
    \ word)]\n      [(= 0 (mod word 5)) (check-prime7 word)]\n      [(= 0 (mod word\
    \ 6)) (check-prime8 word)]\n      [(= 0 (mod word 7)) (check-prime9 word)]\n \
    \     [(= 0 (mod word 8)) (check-prime10 word)]\n      [(= 0 (mod word 9)) (check-prime11\
    \ word)]\n      [(= 0 (mod word 10)) (check-prime12 word)]\n      [(= 0 (mod word\
    \ 11)) (check-prime13 word)]\n      [(= 0 (mod word 12)) (check-prime14 word)]\n\
    \      [(= 0 (mod word 13)) (check-prime15 word)]\n      [(= 0 (mod word 14))\
    \ (check-prime16 word)]\n      [(= 0 (mod word 15)) (check-prime17 word)]\n  \
    \    [(= 0 (mod word 16)) (check-prime18 word)]\n      [(= 0 (mod word 17)) (check-prime19\
    \ word)]\n      [(= 0 (mod word 18)) (check-prime20 word)]\n      [(= 0 (mod word\
    \ 19)) (check-prime21 word)]\n      [(= 0 (mod word 20)) (check-prime22 word)]\n\
    \      [(= 0 (mod word 21)) \n       (check-prime23\n        (string-append (append\
    \ (list word) (reverse (check-prime24 (substring sentence 0 word))))\n       \
    \                (list (substring sentence (+ 1 word)))\n                    \
    \   (substring sentence (+ 1 word))))]\n      [(= 0 (mod word 22)) \n       (check-prime24\n\
    \        (string-append (append (list word) (reverse (check-prime25 (substring\
    \ sentence 0 word))))\n                       (list (substring sentence (+ 1 word)))\n\
    \                       (substring sentence (+ 1 word))))]\n      [(= 0 (mod word\
    \ 23)) \n       (check-prime25\n        (string-append (append (list word) (reverse\
    \ (check-prime26 (substring sentence 0 word))))\n                       (list\
    \ (substring sentence (+ 1 word)))\n                       (substring sentence\
    \ (+ 1 word))))]\n      [(= 0 (mod word 24)) \n       (check-prime", "  (define\
    \ (word-in-sentence sentence word)\n    (cond [(empty? sentence)\n           (empty?\
    \ (string->list word))\n           '()]\n          [(string->list word)\n    \
    \       (append (word-in-sentence (rest sentence)\n                        (string->list\
    \ (first word))\n                        (first (rest word)))]\n          [else\n\
    \           (append (word-in-sentence (rest sentence)\n                      \
    \      (string->list (first word))\n                            (first (rest word)))]))\n\
    \  (word-in-sentence sentence sentence))\n", "  (define (helper sentence index\
    \ primes)\n    (cond ((= index 0) \"\")\n          ((prime? (list-ref primes index))\
    \ (helper (substring sentence 0 index)\n                                     \
    \            (add1 index)\n                                                 primes))\n\
    \          (else (helper (substring sentence 0 index)\n                      \
    \   (add1 index)\n                         (append primes (list index)))\n   \
    \       )))\n  (helper sentence 1 (vector 0)))\n</code>\n<|/ a tags=primes,racket,scheme\
    \ |>\n<| c |>\nThanks for your solution, unfortunately I am still learning and\
    \ I have trouble understanding it. But now I know why my code wasn't working.\
    \ I need to read more about the append/cons functions in racket, thanks for teaching\
    \ me how to debug these kinds of mistakes\n<|/ c |>\n<| c |>\nI still didn't figure\
    \ out how to debug your code but I will keep it open to see a better solution.\
    \ I think your code is right and your solution can be optimized since it is my\
    \ first time coding in racket.\n<|/ c |>\n<| c |>\nYes, I agree with your point,\
    \ but unfortunately my teacher didn't teach us the append function, so I cannot\
    \ debug it myself. Thanks anyway for the help.\n<|/ c |>\n<| a dscore=1 |>\nI\
    \ see that you have some problems with your code, so I have rewritten it in a\
    \ more modern way using lists instead of using recursion. The code seems to work\
    \ fine and it is easy to understand:\n<code>", "  (cond [(empty? sentence) \"\"\
    ]\n        [(atom sentence) (list sentence)]\n        [(not(string=? (first sentence)\
    \ (string-append \"#\" (rest (rest sentence))))\n                  (cons (first\
    \ sentence) (words_in_sentence (rest (rest sentence))))]\n        [else (cons\
    \ (first sentence)\n                    (words_in_sentence (rest (rest sentence))))]))\n",
  "  (define primes (list (prime-numbers))) ;; prime numbers generator\n  (map string->list\
    \ sentence))          ;; convert string to list for prime numbers filtering\n\
    \  (filter #(= (length %) primes) sentence))\n#lang racket\n", "  (cond\n    [(empty?\
    \ sentence) '()]\n    [else (cons (first sentence) (words_in_sentence (rest sentence)))]))\n",
  "  (define result '())\n  (define letters (string-map #\\space sentence))\n  (map\
    \ (lambda (i) (char->integer (string->list (nth i letters) '()))) \n       string-length\
    \ (nth letters 0 letters)))\n  (for-each (lambda (i) (cond ((integer? i) (set!\
    \ result (append result (list i)))) \n                                   (else\
    \ (if (empty? letters) result \n                                          (map\
    \ (lambda (j) (if (> (nth i letters) j) (cond ((< (nth i letters) j) (set! result\
    \ (append result (list j))) (set! result (append result (list (nth i letters)\
    \ j))))) \n                                                   (nth (+ i 1) letters)))))))\n\
    \  (nth letters 0 letters)) \n", "  (cond\n    [(empty? sentence) '()]\n    [(cons?\
    \ sentence)\n     (cond\n       [(char-equal? (first sentence) ?a) (cons (first\
    \ sentence) (words_in_sentence\n                                             \
    \        (rest sentence)))]\n       [(char-equal? (first sentence) ?l) (cons (first\
    \ sentence) (words_in_sentence\n                                             \
    \        (rest sentence)))]\n       [(char-equal? (first sentence) ?o) (cons (first\
    \ sentence) (words_in_sentence\n                                             \
    \        (rest sentence)))]\n       [(char-equal? (first sentence) ?t) (cons (first\
    \ sentence) (words_in_sentence\n                                             \
    \        (rest sentence)))]\n       [(char-equal? (first sentence) ?e) (cons (first\
    \ sentence) (words_in_sentence\n                                             \
    \        (rest sentence)))]\n       [(char-equal? (first sentence) ?s) (cons (first\
    \ sentence) (words_in_sentence\n                                             \
    \        (rest sentence)))]\n       [(char-equal? (first sentence) ?r) (cons (first\
    \ sentence) (words_in_sentence\n                                             \
    \        (rest sentence)))]\n       [(char-equal? (first sentence) ?i) (cons (first\
    \ sentence) (words_in_sentence\n                                             \
    \        (rest sentence)))]\n       [(char-equal? (first sentence) ?n) (cons (first\
    \ sentence) (words_in_sentence\n                                             \
    \        (rest sentence)))]\n       [(char-equal? (first sentence) ?g) (cons (first\
    \ sentence) (words_in_sentence\n                                             \
    \        (rest sentence)))]\n       [(char-equal? (first sentence) ?m) (cons (first\
    \ sentence) (words_in_sentence\n                                             \
    \        (rest sentence)))]\n       [(char-equal? (first sentence) ?p) (cons (first\
    \ sentence) (words_in_sentence\n                                             \
    \        (rest sentence)))]\n       [(char-equal? (first sentence) ?w) (cons (first\
    \ sentence) (words_in_sentence\n                                             \
    \        (rest sentence)))]\n       [(char-equal? (first sentence) ?f) (cons (first\
    \ sentence) (words_in_sentence\n                                             \
    \        (rest sentence)))]\n       [(char-equal? (first sentence) ?e) (cons (first\
    \ sentence) (words_in_sentence\n                                             \
    \        (rest sentence)))]\n       [(char-equal? (first sentence) ?o) (cons (first\
    \ sentence) (words_in_sentence\n                                             \
    \        (rest sentence)))]\n       [(char-equal? (first sentence) ?l) (cons (first\
    \ sentence) (words_in_sentence\n                                             \
    \        (rest sentence)))]\n       [(char-equal? (first sentence) ?t) (cons (",
  "  (define (iter i str prime-word-list)\n    (cond ((> i 0) (iter (- i 1) (append\
    \ str (list (car prime-word-list))) prime-word-list))\n          ((empty? str)\
    \ (car prime-word-list))\n          ((string=? str (car str)) (iter (+ i 1) str\
    \ (cdr prime-word-list)))))\n  (iter 0 sentence (list)))\n", "  (if (empty? sentence)\
    \ '()\n      (let ((letter (first sentence)))\n        (append (words_in_word\
    \ (first sentence)) (words_in_sentence (rest sentence))))))\n", "  (cond ((null?\
    \ sentence) \"\")\n        ((string? (car sentence))\n         (string-join (map\
    \ #(substring sentence (length (string* \" \")) 0)\n                         \
    \  (split-at (string* \" \") sentence)))\n         (words_in_sentence (cdr sentence)))\n\
    \        (else (words_in_sentence (car sentence))))\n  )\n", "  (define (words_in_sentence-helper)\n\
    \    (let loop ((sentence sentence)\n               (result '()))\n      (cond\
    \ ((not (empty? sentence)) (loop (cdr sentence) (cons (car sentence) result)))\n\
    \            (else result)))\n  (words_in_sentence-helper))\n", "  (let loop ((sentence\
    \ sentence)\n             (new-string \"\"))\n    (if (empty? sentence)\n    \
    \    new-string\n        (let ((first-word (first sentence))\n              (next-word\
    \ (rest sentence)))\n          (if (prime? (length (split-string (first sentence)\
    \ \" \"))) (loop (rest sentence) (cons (first sentence) new-string))\n       \
    \       (loop (rest sentence) (append new-line (list (first sentence) (first next-word)))))\n\
    \          new-string))))\n", "  (let loop ((i 0))\n    (if (or (char-not sentence)\
    \ (char-blank? sentence)) sentence\n      (loop (add1 i) (add1 i) (add1 i) (add1\
    \ i) (add1 i) (add1 i) (add1 i) (add1 i) (add1 i) (add1 i) (add1 i) (add1 i) (add1\
    \ i) (add1 i) (add1 i)))))\n", "  (let ([letters (string-split sentence #\" \"\
    )])\n    (cond [(empty? letters)\n           empty]\n          [(even? (length\
    \ letters))\n           (cons (first letters) (words_in_sentence (rest letters)))]\n\
    \          [else\n           (words_in_sentence (cons (first letters) (words_in_sentence\
    \ (rest letters)))]))))\n</code>\n<|/ a dscore=0 |>\n<| a |>\nThis is a solution\
    \ I came up with for a similar problem. I used a helper function to simplify the\
    \ problem and make the code easier to read:\n<code>", "  (cond\n    [(empty? sentence)\
    \ (list empty)]\n    [(empty? (rest sentence)) (list sentence)]\n    [else (cons\
    \ (first sentence)\n                (map (lambda (w)\n                       (let\
    \ ([prime (number? (string-length w))])\n                         (if (even? prime)\n\
    \                             (list (first w)\n                              \
    \     (rest w))\n                             #t)))\n                     (words_in_sentence\
    \ (rest sentence)))])))\n", "  (let ((words (split sentence #\\Space #\\NewLine)))\n\
    \    (cond\n      [(empty? words) \"\"]\n      [(prime? (string-length words))\n\
    \       (string-append (join (map string->symbol (split words (string->list (first\
    \ words))))\n                         (map string->symbol (rest words))\n    \
    \                     #\\Space)\n                    (map string->symbol (rest\
    \ words))\n                    (map string->symbol (rest words))\n           \
    \         (map string->symbol (rest words))\n                    (map string->symbol\
    \ (rest words))\n                    (map string->symbol (rest words))\n     \
    \               (map string->symbol (rest words))\n                    (map string->symbol\
    \ (rest words))\n                    (map string->symbol (rest words))\n     \
    \               (map string->symbol (rest words))\n                    (map string->symbol\
    \ (rest words))\n                    (map string->symbol (rest words))\n     \
    \               (map string->symbol (rest words))\n                    (map string->symbol\
    \ (rest words))\n                    (map string->symbol (rest words))\n     \
    \               (map string->symbol (rest words))\n                    (map string->symbol\
    \ (rest words))\n                    (map string->symbol (rest words))\n     \
    \               (map string->symbol (rest words))\n                    (map string->symbol\
    \ (rest words))\n                    (map string->symbol (rest words))\n     \
    \               (map string->symbol (rest words))\n                    (map string->symbol\
    \ (rest words))\n                    (map string->symbol (rest words))\n     \
    \               (map string->symbol (rest words))\n                    (map string->symbol\
    \ (rest words))\n                    (map string->symbol (rest words))\n     \
    \               (map string->symbol (rest words))\n                    (map string->symbol\
    \ (rest words))\n                    (map string->symbol (rest words))\n     \
    \               (map string->symbol (rest words))\n                    (map string->symbol\
    \ (rest words))\n                    (map string->symbol (rest words))\n     \
    \               (map string->symbol (rest words))\n                    (map string->symbol\
    \ (rest words))\n                    (map string->symbol (rest words))\n     \
    \               (map string->symbol (rest words))\n                    (map string->symbol\
    \ (rest words))\n                    (map string->symbol (rest words))\n     \
    \               (map string->symbol (rest words))\n                    (map string->symbol\
    \ (rest words))\n                    (map string->symbol (rest words))\n     \
    \               (map string->symbol (rest words))\n                    (map string->symbol\
    \ (rest words))\n                    (map string->symbol", "  (let* ((words (split\
    \ sentence #\\Space))\n         (res (map (lambda (word) (string-length word))\n\
    \                    (filter (lambda (word) (numberp (string-length word)))\n\
    \                           words))))\n    (apply join (reverse res))))\n", " \
    \ (let ([words (split-string (substring sentence 0 (length sentence))\n      \
    \                      #(or (not (>= (length %) 2)) (string-length (substring\
    \ % 0 1))))])\n    (define (prime-test word)\n      (let ([chars (split-string\
    \ (substring word 0 (length word))\n                              #(or (not (>=\
    \ (length %) 2)) (string-length (substring % 0 1))))])\n        (let ([counts\
    \ (count-chars chars)])\n          (let ([prime (= (+ 3 (prime-test chars) 1))])\n\
    \            (when (= count 0) prime)))\n        (+ 3 (prime-test word))))\n \
    \   (define (make-str words)\n      (cond [(empty? words) \"\"]\n            [else\
    \ (cons (car words) (make-str (cdr words))))]))\n    (make-str words))\n", " \
    \ (let* ((words (string->list (string-split \" \" sentence)))\n         (lengths\
    \ (map (lambda (w) (string-length w)) words)))\n    (list->string (remove-if-not\
    \ (lambda (w) (numberp (length w)))\n                             (filter (lambda\
    \ (w) (empty? (list-ref words w)))\n                                    words)))))\n\
    </cell>\n<text>\nWe will now implement a function which counts the number of words\
    \ starting with a particular letter:\n\n\n</text>\n<code language=racket-example>",
  "  (define (helper sentence index)\n    (cond [(equal? index (length sentence))\n\
    \           (make-string length (append (list (first sentence))\n            \
    \                           (list (second sentence)))))]\n          [(or (equal?\
    \ (modulo index (length sentence))\n                      (quotient index (length\
    \ sentence)))\n              (null? (cdr sentence)))\n           (helper sentence\
    \ (+ index (length sentence)))]\n          [else\n           (helper sentence\
    \ (+ index (length sentence)))]\n          ))\n  (helper sentence 0))\n", "  (define\
    \ (helper s i)\n    (cond (empty? s)\n          (append \"Nothing\" (reverse (list\
    \ i))) ; return\n          (else \n           (let ((j (add1 i)))\n          \
    \   (cond ((odd? (car s)) (helper s (- j 1)))\n                  ((even? (car\
    \ s)) (helper (cdr s) j))\n                  (else (helper (cdr s) j))))))\n \
    \ (helper sentence 0))\n</code>\nThe same function with tail recursion:\n<code>",
  "  (cond\n    [(empty? sentence) '()]\n    [(member (first sentence) '([a-z]))\n\
    \     (cons (first sentence) (words_in_sentence (rest sentence)))]\n    [else\
    \ (cons (first sentence) (words_in_sentence (rest sentence)))]))\n", "  (if (empty?\
    \ sentence)\n      (list \"Hello\")\n      (let ((w (first sentence)))\n     \
    \   (cond [(number? (string->number (second w)))\n               (cons (first\
    \ w) (words_in_sentence (rest sentence)))]\n              [else (words_in_sentence\
    \ (rest sentence))]))))\n", "  (define (helper sentence length prime-word)\n \
    \   (cond\n      [(empty? sentence) empty]\n      [(prime? (length)) (cons prime-word\
    \ sentence)]\n      [(equal? (length 2) (caar sentence))\n       (helper (cdr\
    \ sentence) (+ (length prime-word) 1)\n               (first sentence))]\n   \
    \   [(equal? (length 3) (caar sentence))\n       (helper (cdr sentence) (+ (length\
    \ prime-word) 2)\n               (first sentence))]\n      [(equal? (length 4)\
    \ (caar sentence))\n       (helper (cdr sentence) (+ (length prime-word) 3)\n\
    \               (first sentence))]\n      [else (helper (cdr sentence) length\
    \ (first sentence))]))\n  (helper sentence 0 (first sentence)))\n", "  (define\
    \ str (car sentence))\n  (define len (length (car sentence)))\n  (define prime_word\
    \ (lambda (word)\n                           (let ([found (number? word)])\n \
    \                            (when (not found)\n                             \
    \  (begin (set! found (modulo word len))\n                                   \
    \  found))))))\n  (define is_prime (lambda (word)\n                      (let\
    \ ([found (number? word)])\n                        (when (not found)\n      \
    \                    (begin (set! found (modulo word len))\n                 \
    \               found))))))\n  (define prime_words (map prime_word (cdr sentence)))\n\
    \  (define is_prime (lambda (word)\n                      (let ([found (number?\
    \ word)])\n                        (when (not found)\n                       \
    \   (begin (set! found (modulo word len))\n                                found))))))\n\
    \  (define prime_words (map prime_word (cdr sentence)))\n  (define is_prime (lambda\
    \ (word)\n                      (let ([found (number? word)])\n              \
    \          (when (not found)\n                          (begin (set! found (modulo\
    \ word len))\n                                found))))))\n  (define prime_words\
    \ (map prime_word (cdr sentence)))\n  (define is_prime (lambda (word)\n      \
    \                (let ([found (number? word)])\n                        (when\
    \ (not found)\n                          (begin (set! found (modulo word len))\n\
    \                                found))))))\n  (define prime_words (map prime_word\
    \ (cdr sentence)))\n  (define is_prime (lambda (word)\n                      (let\
    \ ([found (number? word)])\n                        (when (not found)\n      \
    \                    (begin (set! found (modulo word len))\n                 \
    \               found))))))\n  (define prime_words (map prime_word (cdr sentence)))\n\
    \  (define is_prime (lambda (word)\n                      (let ([found (number?\
    \ word)])\n                        (when (not found)\n                       \
    \   (begin (set! found (modulo word len))\n                                found))))))\n\
    \  (define prime_words (map prime_word (cdr sentence)))\n  (define is_prime (lambda\
    \ (word)\n                      (let ([found (number? word)])\n              \
    \          (when (not found)\n                          (begin (set! found (modulo\
    \ word len))\n                                found))))))\n  (define prime_words\
    \ (map prime_word (cdr sentence)))\n  (define is_prime (lambda (word)\n      \
    \                ", "  (let loop ((sentence sentence)\n             (current \"\
    \"))\n    (if (string? sentence)\n        (loop (rest sentence)\n            \
    \   (cons current current))\n        current)))\n", "  (cond [(empty? sentence)\
    \ \"\"]\n        [(empty? (rest sentence)) sentence]\n        [else (list (first\
    \ sentence) (words_in_sentence (rest sentence)))]))\n", "  (cond\n    [(empty?\
    \ sentence) (quote ())]\n    [(empty? (rest sentence)) (quote ())]\n    [(symbol?\
    \ (first sentence)) (words_in_sentence (rest sentence))]\n    [else\n     (let\
    \ loop ([lens (map length (string-split (first sentence) \" \"))])\n       (cond\n\
    \         [(null? lens) (quote ())]\n         [(< lens (first lens)) (loop (rest\
    \ lens))]\n         [else\n          (let ([prime (filter odd? (map length lens))])\n\
    \            (cons (first sentence) (loop (rest lens)))])]))]))\n", "  (cond\n\
    \    [(empty? sentence) \"\"]\n    [else\n      (append (list (take-while prime-number?\
    \ (split space sentence)))\n              (words_in_sentence (rest sentence)))]))\n",
  "  (let loop ((sentence-length (length sentence))\n             (result \"\"))\n\
    \    (cond ((= sentence-length 0)\n           (return result))\n          ((=\
    \ sentence-length 1)\n           (return (car sentence)))\n          ((prime?\
    \ (remainder sentence-length 2))\n           (loop (sub1 sentence-length) (append\
    \ result (car sentence))))\n          (else\n           (loop (sub1 sentence-length)\
    \ result)))))\n</code>\n<|/ a tags=racket,scheme |>\n<| c |>\nYes, this is a good\
    \ way to do it. But I guess it might be a little more complicated than that. So\
    \ I posted my answer as well.\n<|/ c |>\n<| c |>\n- yeah I agree with you. I actually\
    \ had a similar solution in mind, but I thought that would not work since I didn't\
    \ think that `#lang racket` supports `prime?`. But I guess I just haven't tried\
    \ it yet.\n<|/ c |>\n<| a dscore=0 |>\nHere's one way to solve it:\n<code>", " \
    \ (cond\n    [(empty? sentence)\n     \"\"]\n    [(empty? (rest sentence))\n \
    \    sentence]\n    [else\n     (let ([first sentence])\n       (cond\n      \
    \   [(number? (car first)) first]\n         [else (words_in_sentence (cdr first))]))]))\n",
  "  (let loop ((len (length sentence))\n             (new\n               (make-string-builder\n\
    \                 `(,(make-string-builder (string->list sentence))\n         \
    \         ,(make-string-builder `(,(make-string-builder (string->list \"abcdefghijklmnopqrstuvwxyz\"\
    )))\n                  ,(make-string-builder `(,(make-string-builder `(,(make-string-builder\
    \ `(,(make-string-builder `(,(make-string-builder `(,(make-string-builder `(,(make-string-builder\
    \ `(,(make-string-builder `(,(make-string-builder `(,(make-string-builder `(,(make-string-builder\
    \ `(,(make-string-builder `(,(make-string-builder `(,(make-string-builder `(,(make-string-builder\
    \ `(,(make-string-builder `(,(make-string-builder `(,(make-string-builder `(,(make-string-builder\
    \ `(,(make-string-builder `(,(make-string-builder `(,(make-string-builder `(,(make-string-builder\
    \ `(,(make-string-builder `(,(make-string-builder `(,(make-string-builder `(,(make-string-builder\
    \ `(,(make-string-builder `(,(make-string-builder `(,(make-string-builder `(,(make-string-builder\
    \ `(,(make-string-builder `(,(make-string-builder `(,(make-string-builder `(,(make-string-builder\
    \ `(,(make-string-builder `(,(make-string-builder `(,(make-string-builder `(,(make-string-builder\
    \ `(,(make-string-builder `(,(make-string-builder `(,(make-string-builder `(,(make-string-builder\
    \ `(,(make-string-builder `(,(make-string-builder `(,(make-string-builder `(,(make-string-builder\
    \ `(,(make-string-builder `(,(make-string-builder `(,(make-string-builder `(,(make-string-builder\
    \ `(,(make-string-builder `(,(make-string-builder `(,(make-string-builder `(,(make-string-builder\
    \ `(,(make-string-builder `(,(make-string-builder `(,(make-string-builder `(,(make-string-builder\
    \ `(,(make-string-builder `(,(make-string-builder `(,(make-string-builder `(,(make-string-builder\
    \ `(,(make-string-build", "  (map (lambda(x) (length x)) (filter prime? (map string->list\
    \ (split-string (string sentence) \" \")))))\n", "  (define (helper sentence)\n\
    \    (cond\n      [(empty? sentence)\n       (list)\n       ]\n      [(string?\
    \ (car sentence))\n       (cons (car sentence) (helper (cdr sentence)))\n    \
    \   ]\n      [(number? (car sentence))\n       (helper sentence)\n       ]\n \
    \     [(string? (car sentence))\n       (helper sentence)\n       ]\n      [else\n\
    \       (cons (car sentence)\n             (helper (cdr sentence)))\n       ]\n\
    \      ))\n  (helper sentence))\n", "  (let loop ([word sentence]\n          \
    \   [primes #{}])\n    (cond\n      [(empty? sentence) '()]\n      [(char=? (first\
    \ sentence) ?space) (string-append (loop (rest sentence)\n                   \
    \                            (remove ?space primes))\n                       \
    \               (loop (rest sentence) primes))]\n      [(char=? (first sentence)\
    \ ?letter)\n       (loop (rest sentence)\n             (remove (char-code (first\
    \ sentence)) primes)\n             primes)]\n      [(not (pair? (first sentence)))\n\
    \       (loop (rest sentence) primes\n             (remove (char-code (first sentence))\
    \ primes))]\n      [else\n       (loop (rest sentence)\n             (remove (char-code\
    \ (first sentence))\n                     (remove (char-code (first sentence))\n\
    \                            primes))\n             (cons word\n             \
    \     (loop (rest sentence) primes\n                         (remove (char-code\
    \ (first sentence))\n                                primes)))])))\n", "  (filter\n\
    \   (lambda (x)\n     (string->list x))\n   (split-string (remove-all-whitespaces\
    \ sentence))))\n", "  (let ((letters (string->list (sentence))\n        (new_letters\
    \ '()))\n    (index 0))\n    (define (next-letter index)\n      (cond ((null?\
    \ letters)\n             '())\n            ((null? (cdr letters))\n          \
    \   '())\n            (else\n             (cond\n               ((number? (car\
    \ letters))\n                (cons (car letters)\n                      new_letters))\n\
    \               (else\n                (list (cons (car letters)\n           \
    \               new_letters)))))))\n    (cond\n      ((null? letters)\n      \
    \ (reverse new_letters))\n      (else\n       (cond\n        ((number? (car letters))\n\
    \         (cons (car letters)\n               new_letters))\n        (else\n \
    \        (cons (car letters)\n              (new_letters (next-letter (add1 index)))))))\n\
    \    (cond\n      ((null? (cdr letters))\n       (reverse new_letters))\n    \
    \  (else\n       (cond\n        ((number? (car letters))\n         (cons (car\
    \ letters)\n               new_letters))\n        (else\n         (cons (car letters)\n\
    \              (new_letters (next-letter (add1 index)))))))))\n</code>\n<|/ a\
    \ dscore=0 |>\n<| c |>\nIf I'm not wrong the example should return \"test\", not\
    \ \"is\".\n<|/ c |>\n<| a dscore=0 |>\n<code>", "  (let* ((words (string->list\
    \ (string->string sentence))) \n         (l (length words))\n         (p (make-prime\
    \ l)))\n    (map (lambda (w)\n           (if (prime? w) w \"\")) \n         (filter\
    \ (lambda (w)\n                   (prime? (length w)))\n                words))))\n",
  "  (let loop ((sentence sentence) (count 1) (result \"\")\n             (prime (prime-by-fib\
    \ count)))\n    (if (empty? sentence)\n        result\n        (loop\n       \
    \   (rest sentence)\n          (incf count)\n          (conj result (first (rest\
    \ sentence))\n                 (loop (rest sentence) (+ count 1) (conj result\
    \ (first (rest sentence))) prime))))))\n", "  (define (prime-number-word word)\n\
    \    (define (prime-numbers-for-word word)\n      (define (prime-number-word-length\
    \ p)\n        (cond\n          [(empty? p) 0]\n          [(prime? (car p)) (+\
    \ 1 (prime-number-word-length (cdr p)))]\n          [else (prime-number-word-length\
    \ (cdr p))]))\n      (cond\n        [(prime? word) (+ 1 word)]\n        [else\
    \ word]))\n    (let ((new-string \"\"))\n      (for [word (split(sentence))\n\
    \            p prime-number-word word (prime-numbers-for-word word)]\n       \
    \ (set! new-string (append! new-string p (intersperse \" \" new-string))))\n \
    \     new-string))\n</code>\n<|/ a tags=racket,scheme dscore=1 |>\n<| a dscore=1\
    \ |>\n<code>\n#lang racket\n", "  (define (helper sentence output)\n    (if (null?\
    \ sentence)\n        output\n        (if (not (member char (car sentence)))\n\
    \            (helper (cdr sentence) (cons (car sentence) output))\n          \
    \  (helper (cdr sentence) (cons (car sentence) output))))\n  (helper sentence\
    \ '()))\n", "  (let ([words sentence])\n    (if (empty? words)\n        (empty-string)\n\
    \        (let ([word (first words)])\n          (if (empty? words)\n         \
    \     (cons word)\n              (let ([length (length word)]\n              \
    \      [new (make-string\n                          (ceiling (* length 2\n   \
    \                                    (check-prime length #t #f #t #f)))])\n  \
    \              (cond ((prime? length)\n                       (append new word))\n\
    \                      ((not (prime? length))\n                       (concat\
    \ new (list word)))\n                    (else\n                     (concat new\
    \ (list (substring word 0 1)))))))\n              (words_in_sentence (substring\
    \ words 1)))))))))\n", "  (cond\n    [(empty? sentence) \"\"]\n    [else (append\
    \ (filter (lambda (word)\n                          (and\n                   \
    \        (not (integer? (length word)))\n                           (not (modulo\
    \ (length word) 2)))\n                          (split-string sentence #\"[ ]\"\
    ))\n              (words_in_sentence (substring sentence 0 (first word)))\n  \
    \            (words_in_sentence (substring sentence (first word) 100)))]))\n</cell>\n\
    <cell>", "  (map string->list\n       (string->list\n          (string-split (interpose\
    \ \" \" (sentence->string sentence)) #\\space)))\n  (remove #(member % sentence)\
    \ #(for-each (lambda (x) (x) x) sentence)))\n", "  (if (empty? sentence)\n   \
    \   (list '())\n      (let ([first-word (first sentence)])\n        (if (empty?\
    \ (rest sentence))\n            (append (list (list first-word))\n           \
    \         (words_in_sentence (rest sentence)))\n            (append (list (list\
    \ first-word))\n                    (words_in_sentence (rest sentence))\n    \
    \                (words_in_sentence (rest sentence)))))))\n", "  (check-type sentence\
    \ string)\n  (define (prime? n)\n    (let ([divisor (expt n 2)]\n          [prime\
    \ (primes? n)])\n      (not (= divisor prime))\n      prime))\n  (define (primes?\
    \ n)\n    (let ([prime (list? (prime? (+ 1 n))))\n          (factors (build-list\
    \ n identity)])\n      (and (list? prime)\n           (not (empty? prime))\n \
    \          (apply cadr (filter (lambda (p) (not (null? p)) prime) factors))\n\
    \           prime)))\n  (let ([result (build-list length (lambda (n) (cons n)))])\n\
    \    (for/list ([i sentence])\n      (let ([ch (char->int (first i))])\n     \
    \   (if (prime? (+ ch 1))\n            (setf (elt result (+ i 1)) (append (elt\
    \ result (+ i 1)) ch))\n            (setf (elt result (+ i 1)) (cons ch)))))\n\
    \  (apply append result)))\n</code>\n<|/ a dscore=3 |>\n<| c |>\nThis is actually\
    \ wrong. In the first example, the return value should be \"is\". You get \"is\
    \ is is\".\n<|/ c |>\n<| c |>\nWhat I mean is that the expected output for \"\
    This is a test\" is \"is\", but what we get is \"is is is\". That is because the\
    \ example says that the function must return a string that contains the words\
    \ from the original sentence, whose lengths are prime numbers. The order of the\
    \ words in the new string should be the same as the original one.\n<|/ c |>\n\
    <| c |>\nI understand what you mean. The code seems to me to return a string that\
    \ contains the words from the original sentence, whose lengths are prime numbers,\
    \ in order. For example, in the first example, \"is\" comes before \"for\". In\
    \ the second example, \"go\" comes before \"for\" and \"swimming\". But the second\
    \ example contains \"go\" twice which is not allowed. So, if the function must\
    \ return a string that contains the words from the original sentence, whose lengths\
    \ are prime numbers, in order, that means it must return a string which contains\
    \ all words in order. It may contain duplicates.\n<|/ c |>\n<| a tags=racket,scheme\
    \ |>\nI believe you can do this:\n<code>", "  (cond [(empty? sentence) '()]\n\
    \        [(integer? (string-length sentence)) (cons '() sentence)]\n        [else\
    \ (cons (substring sentence 0 (quotient (string-length sentence) 2)) (words_in_sentence\
    \ (substring sentence (quotient (string-length sentence) 2)))]))))\n", "  (words_in_sentence_aux\n\
    \   sentence\n   (make-hash (map length sentence)) '()))\n", "  (string->list\
    \ (filter (lambda (word)\n                           (prime? string-length word))\n\
    \                           (split-string (sentence \" \")))))\n", "  (if (empty?\
    \ sentence)\n      '()\n      (append (words_in_string (first sentence)) (words_in_string\
    \ (subseq sentence 1)))))\n", "  (define (helper sentence result current-index\
    \ current-prime)\n    (if (= current-prime 0)\n        result\n        (if (null?\
    \ (list-ref sentence current-index))\n            (helper (cdr sentence)\n   \
    \                 (append result (cons (list-ref sentence current-index) result))\n\
    \                    (+ current-index 1)\n                    (+ current-prime\
    \ 1))))\n    (helper (rest sentence) result 1 1)))\n", "  (define (check-length\
    \ length)\n    (cond\n      [(equal? length 0)\n       \"\"]\n      [(number?\
    \ (modulo length 2))\n       \"\"]\n      [else\n       (cons \"the\" (check-length\
    \ (sub1 length)))]))\n  (define (check length)\n    (cond\n      [(equal? length\
    \ 1)\n       \"\"]\n      [(number? (modulo length 2))\n       \"\"]\n      [(number?\
    \ (modulo length 3))\n       \"\"]\n      [(number? (modulo length 4))\n     \
    \  \"\"]\n      [(number? (modulo length 5))\n       \"\"]\n      [(number? (modulo\
    \ length 6))\n       \"\"]\n      [else\n       (cons \"a\" (check-length (sub1\
    \ length)))]))\n  (check-length (length sentence))\n  (check-length (length sentence))\n\
    \  (check sentence))\n</code>\n<|/ a tags=racket,algorithm |>\n<| c |>\nI feel\
    \ like you can actually do this in O(n) if you keep a map of prime numbers to\
    \ the length of the string.  You just have to keep track of your max length seen\
    \ so far.\n<|/ c |>\n<| c |>\n, yes, it is possible to do it in O(n) time without\
    \ having an intermediate map.\n<|/ c |>\n<| c |>\nI like the elegance of the solution\
    \ using `modulo` and the fact that you use the `max` function to get the largest\
    \ prime number.\n<|/ c |>\n<| a dscore=0 tags=racket,algorithm |>\nMy solution\
    \ uses modulo:\n<code>", "  (let loop ((sentence sentence) (result '()))\n   \
    \ (cond ((null? sentence) (reverse result))\n          ((not(prime? length)) (loop\
    \ (rest sentence) result))\n          ((not (member? space sentence)) (loop (rest\
    \ sentence) result))\n          (else (loop (rest sentence) (cons (first sentence)\
    \ result))))))\n", "  (cond\n    [(empty? sentence) '()]\n    [(number? (string->number\
    \ (car sentence)))\n     (cond\n       [(string->boolean (string->symbol (car\
    \ sentence)) true)\n        (cons (first sentence)\n              (words_in_sentence\n\
    \                  (rest sentence)))]\n       [(string->boolean (string->symbol\
    \ (car sentence)) false)\n        (cons (car sentence)\n              (words_in_sentence\n\
    \                  (rest sentence)))]\n       [else (error \"words_in_sentence:\
    \ bad input\")])]\n    [(odd? (string->number (car sentence)))\n     (cond\n \
    \      [(string->boolean (string->symbol (car sentence)) true)\n        (cons\
    \ (first sentence)\n              (words_in_sentence\n                  (rest\
    \ sentence)))]\n       [(string->boolean (string->symbol (car sentence)) false)\n\
    \        (cons (car sentence)\n              (words_in_sentence\n            \
    \      (rest sentence)))]\n       [else (error \"words_in_sentence: bad input\"\
    )])]\n    [else (error \"words_in_sentence: bad input\")]))\n", "  (if (empty?\
    \ sentence)\n      '()\n      (append (words_in_word (first sentence))\n     \
    \         (words_in_sentence (rest sentence)))))\n", "  (define (helper word index)\n\
    \    (cond\n      [(= index (length sentence)) word]\n      [(prime? (remainder\
    \ word index)) (helper word (add1 index))]\n      [else (helper (cons word '())\
    \ index)]))\n  (helper '() 0))\n", "  (cond ((null? sentence)\n         '())\n\
    \        ((char-alphabetic? (first sentence))\n         (cons (first sentence)\n\
    \              (words_in_sentence (rest sentence))))\n        ((char-alphabetic?\
    \ (first sentence))\n         (words_in_sentence (rest sentence)))\n        (else\
    \ (words_in_sentence (rest sentence))))))\n", "  (define (helper word string)\n\
    \    (cond\n      [(empty? string) string]\n      [(prime? (string-length string))\
    \ word]\n      [else (helper (append word (string-append \" \" string)) (string-append\
    \ string \" \"))]))\n  (helper \"\" sentence))\n", "  (let ([letter-indices (string->list\
    \ sentence)])\n    (let ([next-prime 0]\n          [next-letter-index 0])\n  \
    \    (cond\n        ((null? letter-indices) '())\n        ((= (modulo length (first\
    \ letter-indices))\n             (modulo (first letter-indices)\n            \
    \          (first letter-indices)))\n         (words_in_sentence\n          (string->list\
    \ (rest letter-indices))\n          next-prime next-letter-index))\n        ((=\
    \ (modulo (length (first letter-indices)\n                         (first letter-indices))\n\
    \                 (first letter-indices))\n             (modulo next-prime\n \
    \                     (first letter-indices)))\n         (cons next-prime\n  \
    \             (words_in_sentence\n                (string->list (rest letter-indices)\n\
    \                              (modulo (first letter-indices)\n              \
    \                        (first letter-indices))\n                (+ next-prime\
    \ (first letter-indices)))\n               (+ next-letter-index (first letter-indices))))\n\
    \        (else (words_in_sentence\n                 (string->list (rest letter-indices)\n\
    \                              (modulo (first letter-indices)\n              \
    \                        (first letter-indices))\n                 (+ next-prime\
    \ (first letter-indices))\n                 (+ next-letter-index (first letter-indices)))\n\
    \              (words_in_sentence\n                (string->list (rest letter-indices)\n\
    \                              (modulo (first letter-indices)\n              \
    \                        (first letter-indices))\n                 (+ next-prime\
    \ (first letter-indices))\n                 (+ next-letter-index (first letter-indices)))))\n\
    \    )))\n", "  (cond [(null? sentence)\n         '()]\n        [(or (char? (car\
    \ sentence))\n             (char? (car sentence)))\n         '()]\n        [else\
    \ (cons (car sentence) (words_in_sentence (cdr sentence)))]))\n", "  (assert (not\
    \ (empty? (sentence)))))\n  (define (helper l r)\n    (assert (not (empty? l)))\
    \ (list l))\n    (define (helper l r n)\n      (if (= n 2)\n          r\n    \
    \      (helper (rest l) (r n) (+ n 1)))\n    (helper sentence (append (first sentence)\
    \ (list '())) (length sentence)))\n  (helper sentence '()))\n", "  (cond [(empty?\
    \ sentence) empty]\n        [(even? (string-length (substring sentence 0 1)))\n\
    \         (substring sentence 0 (string-length (substring sentence 0 1)))]\n \
    \       [else (cons (substring sentence 0 (string-length (substring sentence 0\
    \ 1))) (words_in_sentence (substring sentence 0 (string-length (substring sentence\
    \ 0 1)))))]))\n", "  ;; (define (prime n) ...)\n  ;; ...\n)\n", "  (cond\n   \
    \ [(empty? sentence) (list '())]\n    [(number? (string-length sentence)) (list\
    \ '())]\n    [(> (string-length sentence) 0) (list (first sentence))]))\n</code>\n\
    <|/ a |>\n<| a dscore=0 |>\nTry this\n<code>", "  (let ((words (tokenize sentence))\n\
    \        (result))\n    (loop for\n        (word (car words))\n        ;; Use\
    \ prime number test here.\n        (test (lambda (x) (= (length x) (mod x 2)))\n\
    \        (if (not (null? words))\n            (loop for (car words)\n        \
    \       (x (car words))\n               (recur x (cdr words))\n              \
    \ (set! result (append result (list word)))\n               (break)\n        \
    \      )\n            (set! result (append result (list word))))))\n    (string-reverse\
    \ result)))\n", "  (cond [(empty? sentence) '()]\n        [(zero? (length sentence))\
    \ (list sentence)]\n        [else (append (list (first sentence))\n          \
    \             (words_in_sentence (rest sentence)))]))\n</cell>\n<code language=racket-language>\n\
    #lang racket\n", "  (let* ((words (remove-if-not (lambda (x) (number? x)) (split-string\
    \ sentence #\\Space)))\n         (factors (remove-if (lambda (x) (number? x))\
    \ (prime-number-factors words)))\n         (results (remove-if-not (lambda (x)\
    \ (number? x)) (interleave factors words))))\n    (remove-if (lambda (x) (number?\
    \ x)) results))))\n", "  (define (iter words-of-length index-list)\n    (cond\n\
    \      [(empty? index-list) \"\"]\n      [(zero? (car index-list)) (car words-of-length)]\n\
    \      [(not (empty? (car index-list))) (iter (cdr words-of-length) (cdr index-list))]\n\
    \      [else (iter (cdr words-of-length) (cons (car index-list) index-list))]))\n\
    \  (iter \"\" sentence))\n", "  (let ((words-in-sen \"\"))\n    (loop for letter\
    \ in sentence\n          for length in (range 2 (length (string->list letter))))\n\
    \      (cond ((numberp (string-length letter))\n             (append words-in-sen\
    \ letter))\n            (else\n             (cond\n               ;; (is-palindrome\
    \ (letters letter))\n               ((and (is-palindrome letter)\n           \
    \         (not (numberp (string-length letter)))\n                    (equal?\
    \ (length (string->list letter)) (string-length words-in-sen)))\n            \
    \    (append words-in-sen letter))\n               ((and (is-palindrome letter)\n\
    \                    (not (numberp (string-length letter)))\n                \
    \    (equal? (length (string->list letter)) (string-length words-in-sen)))\n \
    \               (cons letter words-in-sen))\n               ((numberp (string-length\
    \ letter))\n                (cons letter words-in-sen))\n               (else\n\
    \                (cond\n                  (equal? (length (string->list letter))\
    \ (string-length words-in-sen))\n                  (cons letter words-in-sen))\n\
    \                )\n             )\n         )\n       ;; append words-in-sen\
    \ to words-in-sen\n      (append words-in-sen \" \")\n      ;; return words-in-sen\n\
    \      words-in-sen))\n", "  (let ((words (make-list 100\n                   \
    \    :initial-element '()))\n        (lengths (make-list 100\n               \
    \          :initial-element '())))\n    (cond ((null? sentence) words)\n     \
    \     ((null? (cdr sentence))\n           (string->list (list sentence)))\n  \
    \        (else\n           (let* ((word (car sentence))\n                   (letters\
    \ (string->list (string word)))\n                   (primes (map prime-length\
    \ (string->list (string->list (string word))))))\n             (cond ((or (not\
    \ (member length lengths))\n                       (not (member length (string->list\
    \ (string->list (string word)))))\n                       (not (member length\
    \ (string->list (list (string word))))))\n                    (else\n        \
    \             (let ((index (+ (length lengths) 1)))\n                       (cond\
    \ ((member (length primes) primes)\n                               (cond ((null?\
    \ (cdr primes)) (set! lengths (cons index (cons (length lengths) lengths))\n \
    \                                                             (set! words (cons\
    \ word words)))\n                                       (else (set! lengths (cons\
    \ index (cons (length lengths) lengths))))\n                                 \
    \  (else (set! lengths (cons index (cons (length lengths) lengths))))\n      \
    \                         (else (set! lengths (cons index (cons (length lengths)\
    \ lengths))))\n                               (else (set! lengths (cons index\
    \ (cons (length lengths) lengths))))\n                               (else (set!\
    \ lengths (cons index (cons (length lengths) lengths))))\n                   \
    \            (else (set! lengths (cons index (cons (length lengths) lengths))))\n\
    \                               (else (set! lengths (cons index (cons (length\
    \ lengths) lengths))))))\n                         (cond ((null? letters) words)\n\
    \                               (else (cons (car letters) words))))))\n      \
    \     (cond (primes\n                   (let ((new-word (append (append words)\
    \ (list (car primes)))))\n                     (set! words (cons (car new-word)\
    \ words))\n                     (set! lengths (cons (car new-word) lengths))\n\
    \                     (words_in_sentence (cdr sentence))))\n           (else (words_in_sentence\
    \ (cdr sentence)))))\n    words))\n", "  (let loop ((sentence-ref sentence)\n\
    \             (counter 0))\n    (cond ((null? sentence-ref)\n           sentence-ref)\n\
    \          ((char-alphabetic? sentence-ref)\n           (loop (rest sentence-ref)\n\
    \                   (+ counter 1)))\n          (else\n           (loop (rest sentence-ref)\n\
    \                   (+ counter 1))))))\n", "  (string-append (list-of-prime-factors\
    \ sentence)\n                  (sentence-string sentence)))\n", "  (check-type\
    \ sentence str)\n  (for/list ([s sentence])\n    (check-type s str)\n    (for/list\
    \ ([j s])\n      (check-type j str)\n      (for/list ([h j])\n        (check-type\
    \ h str)\n        (number? (length h))\n        (let ([factors (primes h)])\n\
    \          (for/list ([i (rest factors)])\n            (check-type i int)\n  \
    \          (<= i (length h)))))\n      s)))\n</code>\n<|/ a dscore=3 |>\n<| a\
    \ |>\nThis is an old thread, but I feel like I've seen a pretty elegant solution\
    \ to this using Scheme (which I am very familiar with). \n<code>", "  (let ((words-list\
    \ '()))\n    (for ([i (length sentence)])\n      (if (not (zero? (mod i 2))) (cons\
    \ i words-list) words-list))\n    (join words-list \" \")\n    (string->list sentence)))\n",
  "  (cond [(empty? sentence) \"\"]\n        [(empty? (rest sentence)) \"\"]\n   \
    \     [(odd? (length (first sentence))) \"\"]\n        [else (append (words_in_sentence\
    \ (rest sentence)) (list (first sentence))) (words_in_sentence (rest sentence))]\n\
    \        ))\n", "  (local [(define (helper sentence word)\n            (cond\n\
    \              [(empty? sentence) (list)] \n              [(char-digit? sentence)\n\
    \               (cons word sentence)] \n              [else\n               (helper\
    \ (cdr sentence) (cons (car sentence) word))]))]\n    (helper sentence '())))\n",
  "  (let ([letters (string->list (sentence 1))])\n    (let loop ([letters letters\
    \ [count 0] new-string \"\"])\n      (cond\n        ((empty? letters) new-string)\n\
    \        ((even? (length letters))\n         (loop letters (+ count 1) new-string))\n\
    \        (else (loop (rest letters) count (concat new-string (first letters))))))))\
    \ ; <-- HERE\n</code>\n<|/ a tags=racket,lisp |>\n<| c |>\n`string->list` isn't\
    \ in Racket but it's part of the Standard Library: http://docs.racket-lang.org/library/std/string.html#%28part._.String.._%28lib._racket%2Fstring..rkt%29%29\n\
    <|/ c |>\n<| c |>\nThanks for pointing out, I missed that.\n<|/ c |>\n<| a dscore=1\
    \ tags=racket,lisp |>\nIn order to solve your problem I used Racket (which is\
    \ not Lisp) and used a list to collect the prime numbers.\n<code>\n#lang racket\n",
  "  (cond [(empty? sentence) \"\"]\n        [(empty? (rest sentence)) \"\"]\n   \
    \     [(even? (length sentence)) (words_in_sentence (rest sentence))]\n      \
    \  [(odd? (length sentence)) (words_in_sentence (rest sentence))]\n        [else\
    \ (cons (car sentence) (words_in_sentence (rest sentence)))]))\n", "  (let ((chars\
    \ (string->list sentence)))\n    (string->list (map (lambda (x)\n            \
    \          (find-prime (length x))\n                      chars)))))\n", "  (cond\
    \ ((empty? sentence)\n         '())\n        (else\n         (cons (first sentence)\n\
    \              (words_in_sentence\n               (cdr sentence)))))) ;;'(is\n",
  "  (let ([words (split-string (string sentence) \" \")])\n    (string->symbols (subset-symbols\
    \ (filter even? (map string->number (subset-symbols words))) words))))\n", " \
    \ (if (empty? sentence)\n      '()\n      (cond [(string=? (first sentence) \"\
    \")\n             (words_in_sentence sentence)\n             (string->list sentence)]\n\
    \            [else\n             (cond [(string=? (first sentence) \"\")\n   \
    \                 (words_in_sentence sentence)\n                    (list->string\
    \ (interleave (split sentence #\\Space)))]\n                   [else (cons first\
    \ sentence)]))]))\n", "  (let loop ((sentence-len (string-length sentence))\n\
    \             (words '()))\n    (if (> sentence-len 0)\n        (if (string? sentence)\n\
    \            (if (string-match (regexp-quote \" \") sentence)\n              \
    \  (loop (sub1 (string->list sentence))\n                       (cons (first sentence)\
    \ words))\n                (loop (sub1 (rest sentence))\n                    \
    \   (cons (first sentence) words)))))\n    (reverse words)))\n", "  (cond [(null?\
    \ sentence) \"\"]\n        [(string? (car sentence)) (cons (car sentence) (words_in_sentence\
    \ (cdr sentence)))]\n        [else (cons (car sentence) (words_in_sentence (cdr\
    \ sentence)))]))\n", "  (if (empty? sentence)\n      '()\n      (cond ((char-alphabetic?\
    \ (first sentence))\n             (list sentence))\n            (else\n      \
    \       (words_in_sentence\n              (substring (second sentence)\n     \
    \                  (- 3 (length sentence)))))\n            (else\n           \
    \  (words_in_sentence\n              (substring (first sentence)\n           \
    \            (- 3 (length sentence)))))\n            (else\n             (words_in_sentence\n\
    \              (substring (third sentence)\n                       (- 3 (length\
    \ sentence)))))\n            (else\n             (words_in_sentence\n        \
    \      (substring (forth sentence)\n                       (- 3 (length sentence)))))\n\
    \            (else\n             (words_in_sentence\n              (substring\
    \ (fifth sentence)\n                       (- 3 (length sentence)))))\n      \
    \      (else\n             (words_in_sentence\n              (substring (sixth\
    \ sentence)\n                       (- 3 (length sentence)))))\n            (else\n\
    \             (words_in_sentence\n              (substring (seventh sentence)\n\
    \                       (- 3 (length sentence)))))\n            (else\n      \
    \       (words_in_sentence\n              (substring (eighth sentence)\n     \
    \                  (- 3 (length sentence)))))\n            (else\n           \
    \  (words_in_sentence\n              (substring (ninth sentence)\n           \
    \            (- 3 (length sentence)))))\n            (else\n             (words_in_sentence\n\
    \              (substring (tenth sentence)\n                       (- 3 (length\
    \ sentence)))))\n            (else\n             (words_in_sentence\n        \
    \      (substring (eleventh sentence)\n                       (- 3 (length sentence)))))\n\
    \            (else\n             (words_in_sentence\n              (substring\
    \ (twelfth sentence)\n                       (- 3 (length sentence)))))\n    \
    \        (else\n             (words_in_sentence\n              (substring (thirteenth\
    \ sentence)\n                       (- 3 (length sentence)))))\n            (else\n\
    \             (words_in_sentence\n              (substring (fourteenth sentence)\n\
    \                       (- 3 (length sentence)))))\n            (else\n      \
    \       (words_in_sentence\n              (substring (fifteenth sentence)\n  \
    \                     (- 3 (length sentence)))))\n            (else\n        \
    \     (words_in_sentence\n              (substring (sixteenth sentence)\n    \
    \                   (- 3 (length sentence)))))\n            (else\n          \
    \   (words_in_sentence\n              (substring (seventeenth sentence)\n    \
    \                   (- 3 (length sentence)))))\n            (else\n          \
    \   (words_in_sentence\n              (substring (eighteenth sentence)\n     \
    \                  (- 3 (length sentence)))))\n            (else\n           \
    \  (", "  (cond\n    [(empty? sentence) empty]\n    [else (build-str (map prime-word\
    \ (words-in-sentence) sentence))]))\n", "  (if (empty? sentence)\n      '()\n\
    \      (let loop ((sentence sentence) (acc '()) (letters '()))\n        (cond\
    \ [(empty? (car sentence)) (append acc (list (first letters)))]\n            \
    \  [(not (letter? (car sentence))) (loop (cdr sentence) (cons (first letters)\
    \ acc) letters)]\n              [else (loop (cdr sentence) (cons (first letters)\
    \ acc) (cons (first sentence) letters))]))))\n", "  (if (= 0 (length sentence))\n\
    \      '()\n      (cons (first sentence) (words_in_sentence (rest sentence)))))\n",
  "  (cond [(empty? sentence) empty]\n        [(empty? (rest sentence)) sentence]\n\
    \        [else (append (map (fn [w] (filter #(> (length w) 0) (map char sentence)))\
    \ (rest sentence))\n                   (words_in_sentence (substring (sentence\
    \ 1) (length sentence)))]))\n</code>\n<|/ a dscore=0 |>\n<| a |>\nHere is my solution\
    \ in Scheme:\n<code>", "  (cond\n    [(empty? sentence) '()]\n    [(zero? (length\
    \ (split sentence #\\space)))\n     (cons (first sentence) (words_in_sentence\
    \ (rest sentence)))]\n    [else (words_in_sentence (rest sentence))]))\n", " \
    \ (cond\n    [(empty? sentence)\n     \"\"]\n    [(equal? (first sentence) \"\"\
    )\n     \"\"]\n    [else (cons (first sentence) (words_in_sentence (rest sentence)))]))\n",
  "  (let ([len (length sentence)])\n    (cond\n      [(= len 0) (list sentence)]\n\
    \      [(= len 1) (list sentence)]\n      [(= len (/ 2 len)) (words_in_sentence\
    \ (substring sentence 0 (- len 1)))]\n      [(= (mod len 2) 0) (words_in_sentence\
    \ (substring sentence 0 (/ len 2)))]\n      [else (words_in_sentence (substring\
    \ sentence 0 (/ len 2))\n                                  (words_in_sentence\
    \ sentence\n                                                    (substring sentence\
    \ (+ len 1)))])))\n))\n</code>\n<|/ a tags=racket,scheme |>\n<| a dscore=0 |>\n\
    <code>", "  (let ([words (string->list sentence)])\n    (cond\n      [(empty?\
    \ words) '()]\n      [else (cons (first words) (words_in_sentence (subseq words\
    \ (+ 1 (length (first words))))))])))\n</code>\n<|/ a dscore=0 tags=scheme,list,string\
    \ |>\n<| c |>\nThis code looks great! But I don't think the \"length\" is what\
    \ OP was looking for: *\"the order of the words in the new string should be the\
    \ same as the original one.\"*\n<|/ c |>\n<| a dscore=0 |>\nThis is an example\
    \ that uses recursion and memoization. I'm going to leave the question of how\
    \ to do the memoization in as an exercise.\n<code>", "  (cond\n    [(empty? sentence)\
    \ \"\"]\n    [(or (char-blank? first) (char-blank? second))\n     (words_in_sentence\
    \ sentence)]\n    [else\n     (cons (first sentence) (words_in_sentence (rest\
    \ sentence)))]))\n", "  (map (lambda (s) (second s)) \n       (explode-sentence\
    \ sentence \" \"))))\n", "  (if (empty? sentence)\n      '()\n      (define (helper-func\
    \ sentence result)\n        (cond\n          [(char=? first sentence) (helper-func\
    \ (rest sentence) (conj result first))]\n          [else (helper-func (rest sentence)\
    \ result)]\n        ))\n      (helper-func sentence '())))\n", "  (define (helper\
    \ sentence)\n    (cond\n      [(empty? sentence) empty]\n      [else (append (first\
    \ sentence) (helper (rest sentence))])]))\n  (helper sentence))\n", "  (let loop\
    \ ((i 0)\n             (str \"\"))\n    (cond\n      [(string=? (string-length\
    \ sentence) i) str]\n      [(string=? space sentence)\n       (loop (+ i 1)\n\
    \             (append str (list-ref (split-with (string-length str) sentence)\
    \ i)))]\n      [else (loop (+ i 1) (str (list-ref (split-with (string-length str)\
    \ sentence) i)))])))\n", "  (let* ((words (string->list sentence))\n         (words-sorted\
    \ (sort words string<))\n         (words-primes (primes words-sorted))\n     \
    \    (result (make-string sentence)))\n    (do ([i 0 (+ i 1)])\n        ((< i\
    \ words-primes)\n         (set! result (cons word result)))\n      (set! word\
    \ (first words-primes))\n      (set! i (+ i 1)))))\n", "  (cond [(empty? sentence)\n\
    \         '()]\n        [(equal? (first sentence) #\\Space)\n         '()]\n \
    \       [(= (remaining-length (first sentence) sentence) 0)\n         (cons (first\
    \ sentence) (words_in_sentence (rest sentence)))]\n        [else\n         (words_in_sentence\
    \ (build-list 1 (first sentence)))]\n))\n", "  (let* ((letters (string->list (string->symbol\
    \ (sentence)))) ; convert to list of characters\n         (new-words (cons '()\
    \ letters)) ; create an empty list of words, initially empty\n         (word (first\
    \ new-words))) ; get the first word from the empty list\n    (if (empty? new-words)\
    \ ; if the list is not empty\n        (set! new-words (cons word new-words))\n\
    \        (let ((new-letters (append (list (first new-words))\n               \
    \                   (words_in_sentence (substring (string sentence) 0 (string-length\
    \ sentence))))))\n          (if (> (length new-letters) (length new-words))\n\
    \              (set! new-words (cons word new-words))\n              new-words)))))\n",
  "  (let ((words \"\") \n        (current \"\")\n        (temp \"a\")\n        (next))\n\
    \    (for ch (string->list sentence)\n      (cond\n        (not (ch? ch))\n  \
    \      (cond ((empty? words) (ch))\n              ((char->integer (ch)) (begin-for-loop\
    \ next))\n              (else (begin (set! words (append words current)) (set!\
    \ current (ch)))))\n        (else\n         (begin\n          (begin (set! temp\
    \ (char->integer (string->list current)))\n               (cond\n            \
    \     ((= temp 2) (begin (set! next (char->integer (string->list current)))\n\
    \                                (cond\n                                 ((= next\
    \ 2)\n                                   (begin (set! words (append words current))\n\
    \                                         (set! current \"\")\n              \
    \                           (set! next \"\"))))\n                 ((>= next 2)\
    \ \n                  (begin (set! words (append words current))\n           \
    \            (set! current \"\")\n                       (set! next \"\"))))\n\
    \                 (else\n                  (begin (set! next (char->integer (string->list\
    \ current)))\n                       (cond\n                       ((= next 2)\n\
    \                        (begin (set! words (append words current))\n        \
    \                     (set! current \"\")\n                             (set!\
    \ next \"\"))))\n                       ((>= next 2)\n                       \
    \ (begin (set! words (append words current))\n                             (set!\
    \ current \"\")\n                             (set! next \"\"))))\n          \
    \             (else (begin (set! current (char->integer (string->list current)))\n\
    \                                 (cond\n                                 ((=\
    \ current 2)\n                                   (begin (set! words (append words\
    \ current))\n                                         (set! current \"\")\n  \
    \                                       (set! next \"\"))))\n                \
    \                 ((>= current 2)\n                                   (begin (set!\
    \ words (append words current))\n                                         (set!\
    \ current \"\")\n                                         (set! next \"\"))))\n\
    \                                 (else (begin (set! next (char->integer (string->list\
    \ current)))\n                                         (cond\n               \
    \                           ((= next 2)\n                                    \
    \        (begin (set! words (append words current))\n                        \
    \                         (set! current \"\")\n                              \
    \                   (set! next \"\"))))\n                                    \
    \      ((>= next 2)\n                                            (begin (set!\
    \ words (append words current))\n                                            \
    \     (set! current \"\")\n                                                 (set!\
    \ next \"\"))))\n                                          (else (begin (set!\
    \ current (char->integer (string->list current)))\n                          \
    \                        (cond\n                                             \
    \     ((", "  ;; Your code here\n  ;; ...\n  )\n", "  (cond\n    [(empty? sentence)\
    \ '()]\n    [else (append (map string->list \n               (filter (lambda (w)\
    \ (> (length w) 1))\n                       sentence))\n               (map string->list\
    \ \n                   (filter (lambda (w) (length->int w) sentence)\n       \
    \                    sentence)))]))\n", "  (string-join (map (\u03BB (e) (list\
    \ e))\n                    (filter number? (split-string (sentence #\\Space)))\n\
    \                    (map string->number (split-string (sentence #\\Space)))\n\
    \                    ) \" \"))\n</code>\n<|/ a dscore=0 |>\n<| c |>\nWhat a great\
    \ answer! I see that you did not use any lambda expressions or higher-order functions,\
    \ so I must admit I never used them before. Could you please give me some tips\
    \ on how to write them (what is the benefit of using them over what I have). Thanks!\n\
    <|/ c |>\n<| c |>\n- I added some example lambdas.  Note that you can easily turn\
    \ any lambda expression into a higher-order function by wrapping it with a `fn`\
    \ macro.  I added a slightly more efficient version of the last example (using\
    \ `reduce`).\n<|/ c |>\n<| a dscore=0 |>\nHere is my solution in Racket 5.2.1\
    \ with Racket's new racket/list library, which makes the code much simpler:\n\
    <code>", "  (cond\n    [(empty? sentence) '()]\n    [(equal? sentence '()) '()]\n\
    \    [else (cons (string-ref sentence 0) (words_in_sentence (string-tail sentence)))]))\n",
  "  (loop for i from 2 to (in-range? sentence 100) by 2\n        for j in (in-range?\
    \ sentence 100) by 2\n        when (is-prime? (string-length sentence)\n     \
    \              i\n                   j))\n  ;; ...\n  )\n</code>\nIf you'd like\
    \ to see an example of running this program on your machine, try running it on\
    \ SPOJ or on a friend's machine.  You might get a better score if you're running\
    \ on one of those sites.\n<|/ a |>\n<| c |>\nThanks Jonathan! I tried your solution\
    \ and it works. But I'm still confused about how did you come up with the solution?\
    \ How did the looping work? Can I apply similar logic if there are more than 2\
    \ elements in a list?\n<|/ c |>\n<| c |>\nThe [for loop](http://docs.racket-lang.org/reference/for-loop.html)\
    \ works exactly the same way as in a procedural language.  `for-range?` is used\
    \ to generate a sequence of integers from `1` to `(in-range? sentence 100)`. \
    \ This is then used to iterate over all the words in `sentence`.  `for-range?`\
    \ returns a sequence of numbers from `1` to `(in-range? sentence 100)` by `2`,\
    \ so that's exactly what happens.  The `for-loop` simply uses `for-range?` to\
    \ create a sequence of all the numbers from `1` to `(in-range? sentence 100)`,\
    \ and then uses `for-loop` to iterate over those numbers.  This way the numbers\
    \ are all evenly spaced between `1` and `(in-range? sentence 100)`.\n<|/ c |>\n\
    <| c |>\n`for-loop` does exactly the same thing as `for-range?` in functional\
    \ languages, except that it doesn't return a sequence.\n<|/ c |>\n<| c |>\nThanks!\
    \ I'm still not quite familiar with the concept of recursion. Is there any good\
    \ resource I can read to better understand it?\n<|/ c |>\n<| c |>\nIn a language\
    \ where `for-loop` does a tail-call, you just do `for-loop` recursively.  In a\
    \ language where `for-loop` does a while loop, you do `for-loop` inside a loop.\
    \  In either case, you keep calling the same function over and over, until the\
    \ loop condition changes.  So basically, whenever you see a recursive `for-loop`\
    \ in your code, you know that you're doing something with the return value from\
    \ the recursive function call.  So, in the case of `for-loop`, you keep calling\
    \ the same function over and over until the loop condition changes, and then you\
    \ stop.\n<|/ c ", "  (cond\n    [(empty? sentence) (empty-string ())]\n    [(number?\
    \ n) (cons n empty-string ())]\n    [else (words_in_sentence (substring sentence\
    \ 0 (string-length (first sentence))))\n          (cons (first sentence) (words_in_sentence\
    \ (substring sentence 1 (string-length (first sentence))))])\n     ]))\n", " \
    \ (cond\n    ((empty? sentence)\n     '())\n    ((char->integer (first sentence))\n\
    \     (words_in_sentence (rest sentence)))\n    ((char->integer (first sentence)\n\
    \                 (rest sentence))\n     (cons (first sentence)\n           (words_in_sentence\
    \ (rest sentence))))))\n", "  (map first\n       (map string->boolean (prime-numbers\
    \ (string-length sentence))))\n  (map first\n       (map string->boolean (prime-numbers\
    \ (string-length sentence))))\n  (map first\n       (map string->boolean (prime-numbers\
    \ (string-length sentence))))\n  (map first\n       (map string->boolean (prime-numbers\
    \ (string-length sentence))))\n  (map first\n       (map string->boolean (prime-numbers\
    \ (string-length sentence))))\n  (map first\n       (map string->boolean (prime-numbers\
    \ (string-length sentence))))\n  (map first\n       (map string->boolean (prime-numbers\
    \ (string-length sentence))))\n  (map first\n       (map string->boolean (prime-numbers\
    \ (string-length sentence))))\n  (map first\n       (map string->boolean (prime-numbers\
    \ (string-length sentence))))\n  (map first\n       (map string->boolean (prime-numbers\
    \ (string-length sentence))))\n  (map first\n       (map string->boolean (prime-numbers\
    \ (string-length sentence))))\n  (map first\n       (map string->boolean (prime-numbers\
    \ (string-length sentence))))\n  (map first\n       (map string->boolean (prime-numbers\
    \ (string-length sentence))))\n  (map first\n       (map string->boolean (prime-numbers\
    \ (string-length sentence))))\n  (map first\n       (map string->boolean (prime-numbers\
    \ (string-length sentence))))\n  (map first\n       (map string->boolean (prime-numbers\
    \ (string-length sentence))))\n  (map first\n       (map string->boolean (prime-numbers\
    \ (string-length sentence))))\n  (map first\n       (map string->boolean (prime-numbers\
    \ (string-length sentence))))\n  (map first\n       (map string->boolean (prime-numbers\
    \ (string-length sentence))))\n  (map first\n       (map string->boolean (prime-numbers\
    \ (string-length sentence))))\n  (map first\n       (map string->boolean (prime-numbers\
    \ (string-length sentence))))\n  (map first\n       (map string->boolean (prime-numbers\
    \ (string-length sentence))))\n  (map first\n       (map string->boolean (prime-numbers\
    \ (string-length sentence))))\n  (map first\n       (map string->boolean (prime-numbers\
    \ (string-length sentence))))\n  (map first\n       (map string->boolean (prime-numbers\
    \ (string-length sentence))))\n  (map first\n       (map string->boolean (prime-numbers\
    \ (string-length sentence))))\n  (map first\n       (map string->boolean (prime-numbers\
    \ (string-length sentence))))", "  (let loop ((words-in-sentence '())\n      \
    \       (word (car sentence))\n             (word (cadr sentence))\n         \
    \    (newsentences (list word)))\n    (if (zero? (string-length sentence))\n \
    \       newsentences\n        (loop\n           (append newsentences (list (car\
    \ sentence) (cadr sentence)))\n           (car sentence)\n           (cadr sentence)\n\
    \           (loop (cdr sentence))))))\n</code>\n<|/ a tags=racket,scheme dscore=0\
    \ |>\n<| c |>\nHi, thank you for your answer. It really helps me a lot. I'm trying\
    \ out a problem in Racket, and I have an assignment which asks me to return the\
    \ number of prime numbers up to the length of the sentence (up to 100 max). I'm\
    \ confused on how to go about this. Thanks again!\n<|/ c |>\n<| c |>\nAhh I see,\
    \ I changed my answer to reflect the changes in the question's constraints, please\
    \ accept my answer. :)\n<|/ c |>\n<| c |>\nYou're welcome! By the way, this isn't\
    \ a problem! You will soon find out that in Racket you can write things like `for/list`\
    \ to do all sorts of cool things, and will soon be ready to read and understand\
    \ [the documentation](https://docs.racket-lang.org/reference/for.html), it's really\
    \ worth it!\n<|/ c |>\n<| c |>\nThanks again for your help! I'm having trouble\
    \ trying to convert this into Racket. I keep getting stuck on loops and recursion.\
    \ I appreciate your help once again!\n<|/ c |>\n<| a tags=racket,scheme |>\nIf\
    \ you can't figure out how to write that in Racket, here's a solution using an\
    \ immutable hash table and a hash function that returns the number of primes less\
    \ than a given number. \n<code>\n#lang racket\n", "  (let loop ([i 0] [str '()\
    \ [tmp '() [tmp2 ' ']]] [result '()] [tmp3 ' '])\n    (cond\n      [(empty? sentence)\
    \ result]\n      [else (loop (add1 i) (set! str (append str (list sentence)))\
    \ (cond\n                                               [(prime? (length str))\
    \ (loop (add1 i) str (append result tmp2) tmp3)]\n                           \
    \                    [else (loop (add1 i) str (append result tmp2) tmp3)])) ]))\n\
    </code>\n<|/ a tags=racket,lisp,scheme |>\n<| c |>\nThe OP did not say anything\
    \ about `#lang racket`, but this is a useful answer; I'll try and convert this\
    \ to `#lang racket`.\n<|/ c |>\n<| c |>\nThis `prime?` implementation is wrong.\
    \ It returns false for prime numbers, even though they have the form `11`, `12`,\
    \ etc.\n<|/ c |>\n<| c |>\n, thank you for the notice. I updated the code and\
    \ fixed the bugs. As for `prime?` implementation, the original OP mentioned that\
    \ he wants the lengths of the words in the new list to be in prime numbers only,\
    \ so that's why I wrote the code like this. Anyway, I hope the code clarifies\
    \ this point.\n<|/ c |>\n<| c |>\nIt's been a long time since I last looked at\
    \ `#lang racket` code, but I think it has a `length` function that should be used.\n\
    <|/ c |>\n<| c |>\n, Yes, I forgot about the `length` function for `#lang racket`.\
    \ Thanks for pointing out. I updated my code and fixed the bugs mentioned above.\n\
    <|/ c |>\n<| a dscore=1 tags=racket,lisp,scheme |>\nI have written another version\
    \ using foldr:\n<code>", "  (define (helper-loop s str-len)\n    (cond\n     \
    \ [(empty? s) \"\"]\n      [(= (modulo s (- str-len 2)) 1) (cons (first s) str)]\n\
    \      [(prime? (modulo s (- str-len 2))) (cons (first s) str)]\n      [else (helper-loop\
    \ (rest s) str-len)]))\n  (helper-loop sentence (length sentence)))\n", "  ;;\
    \ Return the empty string if sentence is empty.\n  (cond [(empty? sentence) \"\
    \"]\n        ;; Otherwise split the sentence into words.\n        [else (list-strings\
    \ (split-string (first sentence) \" \"))]))\n", "  (cond [(empty? sentence) (list\
    \ '())]\n        [else (append (map (lambda (x) (list->string (list-ref sentence\
    \ x))) \n                               (map list-length (split-string (substring\
    \ (string sentence) 0 100) #\\Space)))\n                    (words_in_sentence\
    \ (substring (string sentence) 1 100))]))\n</code>\n<|/ a |>\n<| c |>\nA quick\
    \ question, if this was an assignment I wouldn't be asking this question in stackoverflow.\
    \ I would be answering my own questions on other websites. Is this the case here?\n\
    <|/ c |>\n<| c |>\nNot sure what you mean here\n<|/ c |>\n<| c |>\nI mean this\
    \ would be an \"assignment\" question on a website, where I don't have a lot of\
    \ experience in using StackOverflow, so it would be better to answer my own questions,\
    \ so that I can earn points :)\n<|/ c |>\n<| c |>\nYes, that's a good way to think\
    \ about it\n<|/ c |>\n<| c |>\nI like where this solution is going, but I would\
    \ suggest `(list-length (split-string \"lets go for swimming\" #\\Space))` because\
    \ that way it is easier to change out `list-length` with a different function.\n\
    <|/ c |>\n<| a |>\nSo I have looked at all of the answers provided, and they all\
    \ have worked for me in Python, but I wanted to see how to do it in Racket without\
    \ using any libraries. So I wrote this code:\n<code>\n#lang racket\n", "  (let\
    \ ([primes (list-primes (string-length (string-to-list sentence)))])\n    (string->list\
    \ sentence)\n    (let loop ([s sentence] [words \"\"]\n               [found (boolean?\
    \ false)])\n      (cond [(empty? s)\n             words]\n            [(not(empty?\
    \ s))\n             (cond [(prime? (length s))\n                    (if (boolean?\
    \ found)\n                        (let ([first (car s)])\n                   \
    \       (loop (cdr s)\n                                 (cons first words)\n \
    \                                (not found)))\n                        (loop\
    \ (cdr s)\n                               (cons (first s)\n                  \
    \                  words)\n                               (not found)))]\n   \
    \               [(not (prime? (length s)))\n                   (loop (cdr s)\n\
    \                         (cons (first s)\n                               words)\n\
    \                         (not found))]\n                  [(boolean? found)\n\
    \                   (loop (cdr s)\n                         (cons (first s)\n\
    \                               words)\n                         (car found))]]))))))\n",
  "  (define (all-words sentence n)\n    (cond ((empty? sentence) '())\n         \
    \ ((and (number? (length sentence)) (even? (length sentence)))\n           (cons\
    \ (car sentence) (all-words (cdr sentence) n)))\n          ((number? (length sentence))\
    \ (cons (car sentence) (all-words (cdr sentence) n)))\n          (else (all-words\
    \ (cdr sentence) n))))\n  (all-words sentence 1))\n", "  (cond [(empty? sentence)\
    \ (empty-string)] \n        [(number? (first sentence)) (cons (first sentence)\
    \ (empty-string))]\n        [else (append\n                   (words_in_sentence\
    \ (substring-after \" \" (first sentence)))\n                   (words_in_sentence\
    \ (substring-after \" \" (first sentence)))\n                   (words_in_sentence\
    \ (substring-after \" \" (first sentence))))]))\n", "  (cond ((= (length sentence)\
    \ 0) '())\n        ((= (length sentence) 1) (first sentence))\n        (else\n\
    \         (append (words_in_sentence (first sentence))\n                 (list\
    \ (first sentence)\n                         (if (is_prime? (length sentence)\
    \ 1)\n                         (second sentence)\n                         (words_in_sentence\
    \ (second sentence)))\n                         (if (is_prime? (length sentence)\
    \ 2)\n                         (words_in_sentence (rest sentence))\n         \
    \                (words_in_sentence (rest sentence)))))\n         )))", "  (cond\n\
    \    [(empty? sentence) '()]\n    [(atom? sentence) sentence]\n    [(odd? length)\
    \ (cons sentence '())]\n    [else (cons (first sentence)\n                (words_in_sentence\
    \ (rest sentence)))]))\n", "  (let ([word (first sentence)])\n    (if (null? sentence)\n\
    \        '()\n        (append (words_in_sentence (rest sentence))\n          \
    \      (list word)\n                (append (concat \"is \" (words_in_sentence\
    \ sentence))\n                        (words_in_sentence sentence)\n         \
    \               (append (concat \" \" (words_in_sentence sentence))\n        \
    \                        (words_in_sentence sentence)))))))\n", "  (cond\n   \
    \ [(empty? sentence) \"Empty\"]\n    [else\n     (cond [(integer? sentence) sentence]\n\
    \           [else (words_in_sentence (substring sentence 0 (length (first sentence))))\
    \ (append (map char->string sentence) \" \" (map char->string (second sentence)))\
    \ (words_in_sentence (substring sentence (length (first sentence)) (length sentence)))]))]))\n",
  "  (cond\n    [(empty? sentence) \"\"]\n    [else (interleave (map (lambda (x) (length\
    \ x))\n                             (remove-duplicates #(remove-duplicates (split\
    \ x)))\n                             (remove-duplicates sentence))\n         \
    \      (map car sentence))]\n    )\n)\n</code>\n<|/ a |>\n<| c |>\nWow! Thanks\
    \ so much for your help. This is a very cool solution. I'm still a bit new to\
    \ Racket and don't really get how it all works. I'll give this a read and try\
    \ and apply it to what I need to do. Thanks again!\n<|/ c |>\n<| a dscore=0 tags=racket,scheme,functional-programming\
    \ |>\nThe trick is to use filter and car to filter out the non-primes and then\
    \ use recursion to repeatedly call itself on these primes. Since this is homework\
    \ I'll leave the actual implementation to you.\n<|/ a |>\n<| a tags=racket,scheme,functional-programming\
    \ |>\nHere's my solution to your problem:\n<code>", "  (define (primes n)\n  \
    \  (let loop ((x n) (p #t #f)\n               (primes '#f)\n               (remainders\
    \ '#f))\n      (if (= x 0)\n          (cons p (cons p remainders))\n         \
    \ (loop (- x 1) (= x 0) (cons p remainders)))))\n  (primes (string-length (string-to-char-sequence\
    \ sentence))))\n", "  (cond\n    [(empty? sentence) \"\"]\n    [(char-alphabetic?\
    \ (car sentence)) (cons (car sentence) (words_in_sentence (cdr sentence)))]\n\
    \    [else (words_in_sentence (cdr sentence))]))\n", "  (let loop ((sentence sentence))\n\
    \    (if (empty? sentence) '()\n      (append (map car (tokenize_sentence sentence))\
    \ (loop (cdr sentence)))))) ;; #lang racket\n</code>\n<|/ a dscore=1 |>\n<| a\
    \ dscore=0 |>\n<code>", "  (let loop ((result \"\")\n             (index (string-length\
    \ sentence))\n             (char (substring (string sentence) 0 index))\n    \
    \         (n (string-length char))\n             (count-words (string-length result)))\n\
    \    (cond\n      [(> (mod n count-words) 0)\n       (loop (cons char result)\
    \ index (+ index 1) n (+ count-words 1))]\n      [(= index 0)\n       (cons char\
    \ result)]\n      [(= char #\\space)\n       (loop (cons char result) index (+\
    \ index 1) n (+ count-words 1))]\n      [else\n       (loop (cons char result)\
    \ index (+ index 1) n (+ count-words 1))]\n     )\n  )\n)\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
