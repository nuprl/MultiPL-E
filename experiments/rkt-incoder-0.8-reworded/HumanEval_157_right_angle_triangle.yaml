name: HumanEval_157_right_angle_triangle
language: rkt
prompt: "#lang racket\n\n;; Given the lengths of the three sides of a triangle. Return\
  \ #t if the three\n;; sides form a right-angled triangle, #f otherwise.\n;; A right-angled\
  \ triangle is a triangle in which one angle is right angle or \n;; 90 degree.\n\
  ;; Example:\n;; >>> (right_angle_triangle 3 4 5)\n;; #t\n;; >>> (right_angle_triangle\
  \ 1 2 3)\n;; #f\n(define (right_angle_triangle a b c)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate right_angle_triangle))\n\
  \    (check-equal? (candidate 3 4 5) #t)\n    (check-equal? (candidate 1 2 3) #f)\n\
  \    (check-equal? (candidate 10 6 8) #t)\n    (check-equal? (candidate 2 2 2) #f)\n\
  \    (check-equal? (candidate 7 24 25) #t)\n    (check-equal? (candidate 10 5 7)\
  \ #f)\n    (check-equal? (candidate 5 12 13) #t)\n    (check-equal? (candidate 15\
  \ 8 17) #t)\n    (check-equal? (candidate 48 55 73) #t)\n    (check-equal? (candidate\
  \ 1 1 1) #f)\n    (check-equal? (candidate 2 2 10) #f)\n))\n\n(test-humaneval)"
completions: ["  (< (- (square a) (square b) (square c)) 1))\n", "  (< (abs (- (length\
    \ a) (length b))) (abs (- (length a) (length c))))\n  (< (abs (- (length b) (length\
    \ c))) (abs (- (length b) (length a))))\n  (< (abs (- (length c) (length a)))\
    \ (abs (- (length c) (length b))))\n  (< (abs (- (length a) (length c))) (abs\
    \ (- (length b) (length c))))\n  (< (abs (- (length b) (length a))) (abs (- (length\
    \ c) (length a))))\n  (< (abs (- (length c) (length b))) (abs (- (length a) (length\
    \ c))))\n  (< (abs (- (length a) (length b))) (abs (- (length c) (length b))))\n\
    \  (< (abs (- (length b) (length a))) (abs (- (length a) (length c))))\n  (< (abs\
    \ (- (length c) (length a))) (abs (- (length b) (length a))))\n  (< (abs (- (length\
    \ a) (length b))) (abs (- (length c) (length b))))\n  (< (abs (- (length b) (length\
    \ a))) (abs (- (length c) (length a))))\n  (< (abs (- (length c) (length b)))\
    \ (abs (- (length a) (length c))))\n  (< (abs (- (length a) (length b))) (abs\
    \ (- (length c) (length b))))\n  (< (abs (- (length b) (length a))) (abs (- (length\
    \ c) (length a))))\n  (< (abs (- (length c) (length a))) (abs (- (length a) (length\
    \ c))))\n  (< (abs (- (length a) (length b))) (abs (- (length c) (length b))))\n\
    \  (< (abs (- (length b) (length a))) (abs (- (length c) (length a))))\n  (< (abs\
    \ (- (length c) (length a))) (abs (- (length a) (length c))))\n  (< (abs (- (length\
    \ a) (length b))) (abs (- (length c) (length b))))\n  (< (abs (- (length b) (length\
    \ a))) (abs (- (length c) (length a))))\n  (< (abs (- (length c) (length a)))\
    \ (abs (- (length a) (length c))))\n  (< (abs (- (length a) (length b))) (abs\
    \ (- (length c) (length b))))\n  (< (abs (- (length b) (length a))) (abs (- (length\
    \ c) (length a))))\n  (< (abs (- (length c) (length a))) (abs (- (length a) (length\
    \ c))))\n  (< (abs (- (length ", "  (< (abs (- a b)) (abs (- a c)))\n  (< (abs\
    \ (- b c)) (abs (- a c)))\n  (< (abs (- c a)) (abs (- b c)))\n  (< (abs (- c b))\
    \ (abs (- a c)))\n  (< (abs (- c c)) (abs (- a b)))\n  (< (abs (- b a)) (abs (-\
    \ b c)))\n  (< (abs (- b b)) (abs (- c a)))\n  (< (abs (- b c)) (abs (- c b)))\n\
    \  (< (abs (- c a)) (abs (- c c)))\n  (< (abs (- c b)) (abs (- c c)))\n  (< (abs\
    \ (- a a)) (abs (- b b)))\n  (< (abs (- a b)) (abs (- c c)))\n  (< (abs (- a c))\
    \ (abs (- c a)))\n  (< (abs (- b c)) (abs (- c b)))\n  (< (abs (- c a)) (abs (-\
    \ c c)))\n  (< (abs (- c b)) (abs (- c c))))", "  (if (= (abs a) (abs b) (abs\
    \ c))\n      #t\n      (< (abs a) (abs b)) (< (abs a) (abs c)) (< (abs b) (abs\
    \ c))\n      (< (abs a) (abs c)) (< (abs b) (abs c)) (< (abs c) (abs a))\n   \
    \   (< (abs b) (abs c)))))\n", "  (< (abs (- (square (- a b)) (square (- c b))))\n\
    \      (abs (- (square (- a c)) (square (- c a))))))\n", "  (< (abs (- (square\
    \ a) (square b) (square c)))\n     (abs (- (square a) (square b) (square c)))))\
    \ ;; check whether abs (- (square a) (square b) (square c)) is positive (positive-or-negative)\
    \ number\n\n", "  (< (abs a) (car c)) \n  (< (abs b) (car b)) \n  (< (abs c) (car\
    \ a)))", "  (< a b c)\n  (or (< b c a)\n      (< c a b)))\n", "  (< (abs (- a\
    \ b)) (abs (- b c)))\n  (< (abs (- a c)) (abs (- b c)))\n  (< (abs (- a b)) (abs\
    \ (- c b)))\n  (< (abs (- a c)) (abs (- c b)))\n  (< (abs (- a b)) (abs (- c c)))\n\
    \  (< (abs (- a c)) (abs (- c c))))\n", "  (= (abs (- a b) (- a c) (- b c)) (/\
    \ 3 2)))\n", "  (= (abs a) (abs b) (abs c))\n  (= (mod a b) (mod b c))\n  (= (mod\
    \ c b) (mod b a)))\n", "  (cond\n    [(= a b) (= c a)]\n    [(= a c) (= b c)]\n\
    \    [(= a b) (= c c)]\n    [(= b c) (= c a)]\n    [else #f]))\n", "  (or (= (*\
    \ a b) (* b c)) (= (* a c) (* c b))))\n", "  (or (= (abs a) (abs b) (abs c))\n\
    \      (= (abs a) (abs b) c) \n      (= (abs a) (abs c) b) \n      (= (abs b)\
    \ (abs c) a) \n      (= (abs a) (abs c) c) \n      (= (abs b) (abs c) b)))\n",
  "  (= (modulo a (/ b c)) (/ b (- (/ c a) b))))\n", "  (cond\n    [(= a c) (= b c)\
    \ (= a b)]\n    [(= c b) (= a c)]\n    [else\n     (< (- a b) (- c a)) (< (- b\
    \ c) (- a b))]))\n", "  (< (abs (- a b)) (abs (- a c))) (< (abs (- a c)) (abs\
    \ (- b c))))\n", "  (and (equal? a b) (equal? b c))\n  (or (equal? a c) (equal?\
    \ b c)))\n", "  (< (abs a) (abs b) (abs c)))\n", "  (cond\n    [(= (mod c a) (mod\
    \ c b)) #t]\n    [(= (mod c a) (mod c c)) #t]\n    [(= (mod c b) (mod c c)) #t]\n\
    \    [#t (= (mod c a) (mod c b)) #t]\n    [#t (= (mod c b) (mod c c)) #t]\n  \
    \  [#t (= (mod c c) (mod c a)) #t]\n    [#t (= (mod c c) (mod c b)) #t]\n    [#t\
    \ (= (mod c c) (mod c c)) #f]))\n", "  (cond\n    [(and (equal? a b) (equal? b\
    \ c))\n     (equal? a c)]\n    [(equal? a b)\n     (equal? c b)]\n    [(equal?\
    \ b c)\n     (equal? a c)]\n    [else\n     (equal? (angle_of_triangle a b c)\
    \ (angle_of_triangle b a c))]))\n", "  (letrec\n      ((triangle (\u03BB (a b\
    \ c) (if (> a b) (+ a b) (+ b c) (+ c a)))\n            (\u03BB (a b c) (if (>\
    \ b c) (+ b c) (+ c a) (+ a b)))\n            (\u03BB (a b c) (if (> c a) (+ c\
    \ a) (+ a b) (+ b c))))\n    (= (triangle a b c) a)))\n", "  (< (abs (- (* a b)\
    \ (* b c))) 180)\n  (or (= (abs (- (* a b) (* c b))) 180) (= (abs (- (* b c) (*\
    \ c a))) 180)))", "  (<= (modulo (+ a b c) 180)\n       (modulo (+ b c a) 180)\n\
    \       (modulo (+ c a b) 180)))", "  (< (abs (- a b) (- a c) (- b c)) 180))\n",
  "  (< a b c))\n", "  (cond [(= a b c) ?a]\n        [(= b c a) ?b]\n        [(= c\
    \ a b) ?c]\n        [else #f]))\n", "  (or (= c a)\n      (= c b)\n      (< a\
    \ b c)\n      (< (- b) a c)\n      (< (- a) b c)\n      (< (- b) c (- a))\n  \
    \    (< (- c) a b)\n      (< (- c) b (- a))\n      (< (- a) a b)\n      (< (-\
    \ a) b (- b))))\n", "  (< (abs (- a b)) (abs (- a c)) (abs (- b c)))\n  )\n",
  "  (< (abs (- a b)) (abs (- a c)))\n  (< (abs (- b c)) (abs (- b a)))\n  (< (abs\
    \ (- c b)) (abs (- c a)))\n  (> (abs (- a b)) (abs (- a c)))\n  (> (abs (- b a))\
    \ (abs (- b c)))\n  (> (abs (- c a)) (abs (- c b)))\n)\n\n", "  (< (abs (- b c))\
    \ (abs (- a b))))\n", "  (< (- b c) a))\n#lang racket\n", "  (< (abs (- a b))\
    \ (abs (- c b)))\n  (= (abs (- b c)) (abs (- a c)))\n  (= (abs (- c a)) (abs (-\
    \ b a)))\n  (= (abs (- a b)) (abs (- c c)))\n  (= (abs (- b c)) (abs (- a c)))\n\
    \  (= (abs (- c a)) (abs (- b a)))\n  (= (abs (- a b)) (abs (- c c)))))\n", " \
    \ (= (if (>= (- c b) (- a c))\n          (/ a c) (/ b c))\n      (/ (- a b) (-\
    \ a c) (- b c))\n      )\n  )\n", "  ;; Formula: (a + b + c) / (2 * a * b) \n\
    \  ;; Where a = lside, c = rside, and b = (lside + rside) / 2 = rside / 2.\n \
    \ (< (+ a b c) (/ (+ a b) (* 2 a))))\n", "  (> (abs (- a b)) (abs (- a c)) (abs\
    \ (- b c))))\n", "  (let ((sum (+ a b c)))\n    (cond\n      [(< sum 0) #f]\n\
    \      [(> sum 0) #t]\n      [else (= (/ sum 2) 0)]\n    )\n  )\n)\n</code>\n\
    <|/ a |>\n<| c |>\nNice answer. Minor nitpick: it looks like the OP was asking\
    \ for `right_angle_triangle` to return `#f` if *any* of its arguments are negative,\
    \ since they are using `<` and `>` to compare them. Your version doesn't check\
    \ for that, though.\n<|/ c |>\n<| c |>\nThanks for the suggestion. I changed it\
    \ to use `<` and `>` instead of `=`.\n<|/ c |>\n<| a dscore=1 tags=scheme,racket,sicp\
    \ |>\nI suggest a more general (and also more readable and understandable) answer.\
    \ \n<code>", "  (< (abs (- a b)) (abs (- a c)) (abs (- b c))))\n  ", "  (cond\
    \ (< a b) (< b c) (< c a)\n        (= a (abs a)) (= b (abs b)) (= c (abs c))\n\
    \        (= b (abs a)) (= c (abs b)) (= a (abs c))\n        (= b (abs c)) (= c\
    \ (abs a)) (= a (abs b))\n        (= c (abs a)) (= a (abs c)) (= b (abs b))\n\
    \        (= c (abs b)) (= b (abs c)) (= a (abs b)))\n  (if (= a b) (= c b) false)\n\
    \  (if (= b c) (= a c) false)\n  (if (= c a) (= b a) false)\n  (if (< a b) (<\
    \ b c) (< c a) false)\n  (if (< b c) (< a c) (< c b) false)\n  (if (< c a) (<\
    \ a b) (< b c) false)\n  (if (< a b) (< b c) (< c a) false)\n  (if (< b c) (<\
    \ a c) (< c b) false)\n  (if (< c a) (< a b) (< b c) false))\n", "  (= (* a b)\
    \ (+ (* c b) (* a c))))\n", "  (= (+ (* 2 a c) (* 2 b a)) (+ (* 2 b c) (* 2 a\
    \ b))))\n", "  (< a b c)\n  (and (< b a c)\n       (< c a b)\n       (< a (+ c\
    \ b) c)))\n", "  (< a b c \n      (+ a b c) \n      (+ (* a b) (* a c) (* b c))\n\
    \      ))\n", "  (or (= a b)\n      (= a c)\n      (= b c)))\n", "  (and (= a\
    \ c)\n       (= b c)\n       (= a b)))\n", "  (< (abs (- (+ a b) c)) (/ 180 180)))\n",
  "  (cond\n    ((= a b) (= b c))\n    ((= a c) (= c b))\n    (else\n      (let ((p1\
    \ b)\n            (q1 c)\n            (q2 a))\n        (and (= p1 q1)\n      \
    \       (= p1 q2)\n             (= q1 q2)))))\n", "  (= (sqr (+ (* a a) (* b b)\
    \ (* c c)))\n     (* 180 45)))\n", "  (cond [(< a b c) (< (+ b c) a c)\n     \
    \    (< b c a) (< (+ c a) b c)\n         (< c a b) (< (+ a b) c a)]\n        [else\
    \ #f]))\n</cell>\n<cell>\n#lang racket", "  (< (+ (* a c) (* b a)) (* b c)))\n",
  "  (< (abs a) (abs b) (abs c)))\n", "  (let ((det (a * b)) (sqrt (+ (* a a) (* b\
    \ b) (* c c))))\n    (if (< det 0)\n        (> det 180)\n        #t)))\n", " \
    \ (equal? (angle-between-angles a b c) 0))\n", "  (<= (abs a) (abs b) (abs c))\n\
    \  (<= a b c))\n", "  (cond\n    [(or (= a b)\n         (= a c))\n     (= (* 2\
    \ a) (+ b c))\n     ]\n    [(or (= a c)\n         (= b c))\n     (= (* 2 b) (+\
    \ a c))\n     ]\n    [(or (= a b)\n         (= b c))\n     (= (* 2 a) (+ a c))\n\
    \     ]\n    [else\n     #f])))\n", "  (< (abs (- a b)) (abs (- c b))))\n", " \
    \ (< (abs (- (sqrt (+ (square a) (square b)) (square c)))) (abs (- (sqrt (+ (square\
    \ a) (square b)) (square c)))))\n  )\n", "  (cond\n    [(and (> a b) (> b c))\
    \ #t]\n    [(and (> a c) (> c b)) #t]\n    [(and (> b a) (> c a)) #t]\n    [(and\
    \ (> b c) (> c b)) #t]\n    [else #f]\n  ))\n", "  (< (* a b) (* c a) (* c b)))\n",
  "  (< (abs (- a b)) (abs (- b c)))\n  (< (abs (- a c)) (abs (- b c)))\n  (< (abs\
    \ (- a b)) (abs (- c b)))\n  (< (abs (- b c)) (abs (- c a))))\n</cell>\n<text>\n\
    Part III\n\n</text>\n<text>", "  (= (remainder b 2) 0)\n  (= (remainder c 2) 0)\n\
    \  (= a b)\n  (= a c)\n  (= b c)\n  (< (abs (- a b)) (abs (- a c))) (< a b))\n\
    \  (< (abs (- b c)) (abs (- a c))) (< b c))", '  (> (abs a) (abs b) (abs c)))',
  "  (= (mod a 2)\n     (= (mod b 2)\n      (= (mod c 2)\n       #t))))\n", "  (<\
    \ (abs (- a b))\n      (abs (- c b))))\n", "  (< (* a b) (* c a)))\n", "  (< (abs\
    \ a) (abs b) (abs c))\n  (= (abs a) (abs b)) (= (abs a) (abs c))\n  (= (abs b)\
    \ (abs c))\n  (= (abs a) (abs c))\n  (= (abs b) (abs c))\n  (<= (abs a) (abs b)\
    \ (abs c))\n  (>= (abs a) (abs b) (abs c))\n  (= (abs a) (abs b))\n  (= (abs a)\
    \ (abs c))\n  (= (abs b) (abs c))\n  (= (abs a) (abs c))\n  (= (abs b) (abs c))\n\
    \  (= (abs a) (abs b))\n  (= (abs a) (abs c))\n  (= (abs b) (abs c))\n  (= (abs\
    \ a) (abs c))\n  (= (abs b) (abs c))\n  (= (abs a) (abs b))\n  (= (abs a) (abs\
    \ c))\n  (= (abs b) (abs c))\n  (= (abs a) (abs c))\n  (= (abs b) (abs c))\n \
    \ (= (abs a) (abs b))\n  (= (abs a) (abs c))\n  (= (abs b) (abs c))\n  (= (abs\
    \ a) (abs c))\n  (= (abs b) (abs c))\n  (= (abs a) (abs b))\n  (= (abs a) (abs\
    \ c))\n  (= (abs b) (abs c))\n  (= (abs a) (abs c))\n  (= (abs b) (abs c))\n \
    \ (= (abs a) (abs b))\n  (= (abs a) (abs c))\n  (= (abs b) (abs c))\n  (= (abs\
    \ a) (abs c))\n  (= (abs b) (abs c))\n  (= (abs a) (abs b))\n  (= (abs a) (abs\
    \ c))\n  (= (abs b) (abs c))\n  (= (abs a) (abs c))\n  (= (abs ", "  (< (* a b)\
    \ c))\n", "  (= (angle-between-vectors ((vector a (vector b c))) \n          \
    \                       ((vector a b) (vector b c))) 0))\n", "  (< (abs a) (abs\
    \ b) (abs c)))\n", "  (= a b) \n  (= b c)\n  (= c a)\n  (= (mod a 2) 1)\n  (=\
    \ (mod b 2) 1)\n  (= (mod c 2) 1)\n  (= (mod (- (- a b) c) 2) 1)\n  (= (mod (-\
    \ (- b c) a) 2) 1)\n  (= (mod (- (- c a) b) 2) 1)\n  (= (mod (- (- a b) (- c a))\
    \ 2) 1)\n  (= (mod (- (- a b) (- b c)) 2) 1)\n  (= (mod (- (- b c) (- a b)) 2)\
    \ 1)\n  (= (mod (- (- b c) (- c a)) 2) 1)\n  (= (mod (- (- c a) (- a b)) 2) 1)\n\
    \  (= (mod (- (- c a) (- b c)) 2) 1)\n  (= (mod (- (- c a) (- c b)) 2) 1))\n",
  "  (< a b c))\n", "  (< (- (+ a b) c) (* 0.5 (- (+ a b) c)))\n)\n", "  (> (abs (-\
    \ (angle-of a) angle-of b) (angle-of c)) (angle-of a)))\n", "  (cond ((= a b)\
    \ (= b c))\n        ((= b a) (= c a))\n        ((= c b) (= a b))\n        ((=\
    \ a c) (= b c))\n        ((< a b) (< b c) (< c a))\n        ((< b a) (< c a) (<\
    \ a b))\n        ((< c b) (< a b) (< b c))\n        (else\n         (< a b) (<\
    \ b c) (< c a) #f)))\n", "  (= (+ a b) (+ b c) (+ a c)))\n", "  (= (mod a 2) (mod\
    \ b 2) (mod c 2)))\n", "  (< (abs (- (angle a b) (-angle b c))) 180)\n  ;; a >\
    \ b > c\n  ;; b ~ a > c\n  ;; c ~ a > b\n  ;; b ~ c ~ a > a\n  ;; c ~ b ~ a >\
    \ b\n  ;; a ~ b ~ c ~ a > b\n  ;; a ~ c ~ b ~ a > c\n  ;; a ~ c ~ b ~ b > a\n\
    \  ;; a ~ c ~ b ~ c > a\n  ;; a ~ c ~ c ~ b ~ a > b\n  ;; a ~ c ~ c ~ b ~ b >\
    \ a\n  ;; a ~ c ~ c ~ b ~ c > a\n  ;; a ~ c ~ c ~ c ~ a > b\n  ;; a ~ c ~ c ~\
    \ c ~ b > a\n  ;; a ~ c ~ c ~ c ~ c > a\n  ;; a ~ c ~ c ~ c ~ c ~ a > b\n  ;;\
    \ a ~ c ~ c ~ c ~ c ~ b > a\n  ;; a ~ c ~ c ~ c ~ c ~ c > a\n  ;; a ~ c ~ c ~\
    \ c ~ c ~ c ~ a > b\n  ;; a ~ c ~ c ~ c ~ c ~ b ~ a > c\n  ;; a ~ c ~ c ~ c ~\
    \ c ~ b > a\n  ;; a ~ c ~ c ~ c ~ c ~ c > a\n  ;; a ~ c ~ c ~ c ~ c ~ c ~ a >\
    \ b\n  ;; a ~ c ~ c ~ c ~ c ~ b ~ a > c\n  ;; a ~ c ~ c ~ c ~ c ~ b ~ b > a\n\
    \  ;; a ~ c ~ c ~ c ~ c ~ b ~ c > a\n  ;; a ~ c ~ c ~ c ~ c ~ b ~ c ~ a > b\n\
    \  ;; a ~ c ~ c ~ c ~ c ~ b ~ c ~ b > a\n  ;; a ~ c ~ c ~ c ~ c ~ b ~ c ~ c >\
    \ a\n  ;; a ~ c ~ c ~ c ~ c ~ b ~ c ~ c ~ a > b\n  ;; a ~ c ~ c ~ c ~ c ~ c ~\
    \ b > a", "  (cond\n    [(= a b) (cdr c)]\n    [(= b c) (cond\n              \
    \ [(= a c) (cons '#t (cdr c))]\n               [else (cons '#f (cdr c))])]\n \
    \   [(= c a) (cons '#f (cdr c))]\n    [else (cons '#f (cdr c))]))\n", "  (< (abs\
    \ (- a b c)) (/ a b)))\n", "  \n  ;; Check that the three sides are all valid.\n\
    \  (and (>= a b) (>= b c) (>= a c))\n  \n  ;; Check that the three sides form\
    \ a right-angled triangle.\n  \n  (if (and (>= a c) (>= b c) (< c b))\n    #t\n\
    \    #f)\n  \n  ;; Check that the three sides form a right-angled triangle.\n\
    \  \n  (if (and (> c a) (> b a) (< a b))\n    #t\n    #f)\n  \n  ;; All three\
    \ sides form a right-angled triangle.\n  \n  (if (and (> a b) (> b c) (> c a))\n\
    \    #t\n    #f)\n  )", "  (< (abs (- a b)) (abs (- c b)))\n  )\n", "  (let ((abs\
    \ (abs a)))\n    (if (= abs 0)\n        #f\n        (or (= (* b c) abs)\n    \
    \        (= (* a c) abs)\n            (= (* c b) abs)))))\n</cell>\n<code language=racket-language>\n\
    #lang racket\n", "  ;; See if two angles are equal (right angle or 90 degree).\n\
    \  (and (= (+ a b c) (/ 90 a))\n       (= (+ a c b) (/ 90 b)))\n  ;; If so, return\
    \ #t.\n  (= (/ a b) (/ 90 a))\n  (= (/ b c) (/ 90 b))\n  (= (/ a c) (/ 90 c))\n\
    \  ;; Otherwise return #f.\n  )\n", "  (< (abs (- a b)) (abs (- a c))) (< (abs\
    \ (- b c)) (abs (- a c))))\n", "  (cond\n    [(> a b) (< c a)]\n    [(> b c) (<\
    \ a b)]\n    [(> a c) (< b a)]\n    [else #f]))\n</code>\n<|/ a tags=lisp,common-lisp\
    \ |>\n<| c |>\n`(= (defun right_angle_triangle (a b c)\n                  (cond\n\
    \                    [(> a b) (< c a)]\n                    [(> b c) (< a b)]\n\
    \                    [(> a c) (< b a)]\n                    [else #f]))\n    \
    \            :lambda)` works, too, and is shorter and clearer.\n<|/ c |>\n<| a\
    \ tags=lisp,common-lisp dscore=3 |>\nThe shortest way is just to check if the\
    \ area of triangle is less than or equal to (abs (a+b+c)) divided by 2\n<|/ a\
    \ |>\n<| a dscore=3 |>\nAs a Lisp newbie I wanted to refactor the answers above\
    \ in a way that makes clear what they are doing.\n<code>", "  ;; (define (helper\
    \ n a b c) (if (< a b) (helper n (+ a 1) (+ b 1) c) #f))\n  (define (helper n\
    \ a b c)\n    (cond ((= n 0)\n           (= a b)\n           (= c b))\n      \
    \    ((= n 1)\n           (= b c)\n           (= a a))\n          ((= n 2)\n \
    \          (= a c)\n           (= b b))\n          (else (helper n (+ a 1) b (+\
    \ b 1)))))\n  (helper a b c #t))\n", "  (> (* a b) (* c a) \n      (* c b) (*\
    \ a c) ))\n", "  (cond ((> a b) (> b c))\n        ((< a b) (< b c))\n        ((<\
    \ a c) (< c b))\n        ((< b a) (< a c))\n        ((< b c) (< c a))\n      \
    \  ((< c a) (< a b))\n        ((< c b) (< b a))\n        (else #f)))\n", "  (<\
    \ (abs (- (- a b) (- c a))) 180))\n", "  (< (abs a) (abs b) (abs c)))\n", "  (<\
    \ (abs a) (car b))\n  (< (abs b) (car a))\n  (< (abs c) (car (cdr a)))\n  (< (abs\
    \ b) (car (cdr c)))\n  (< (abs a) (car (cdr b)))\n  (< (abs c) (car (cdr (cdr\
    \ a))))\n  (< (abs a) (car (cdr (cdr c))))\n  (< (abs b) (car (cdr (cdr (cdr a))))))\n",
  "  (cond\n    [(or (= a b) (= b c))\n     (and (= a c) (= b c))\n     (= a c)]\n\
    \    [else #f]))\n", "  (< (abs (- a b) c) (abs (- b c) c) \n       (abs (- a\
    \ c) c)))\n", "  (or (> a b) (> b c) (> c a)))\n", "  (< (+ c a) b (+ b a) c))\n",
  "  (= a (sqrt (+ (* a a) (* b b) (* c c))) \n     (if (< a b) (< c b)\n       (<\
    \ a c) (< c a))))\n", "  (< (abs (- c a))\n     (abs (- a b)))\n  )\n", "  (=\
    \ (square-root (+ (square (- a b)) (square (- b c)))) (square (- b c)))) ;;; #lang\
    \ racket\n", "  (= (abs (- a b c)) (sqrt (+ (* a a) (* b b) (* c c))))))\n</cell>\n\
    <cell>\n#lang racket\n", "  (if (= a b c)\n      #t\n      (if (< a b c)\n   \
    \       (if (= a b)\n              (if (= b c)\n                  #t\n       \
    \           #f)\n              (if (= b c)\n                  #t\n           \
    \       (if (< b a)\n                      #t\n                      #f))))))\n",
  "  (< (abs (- a b)) (abs (- a c))))\n  ", "  (> (expt a 2) (expt b 2))\n  (or (>\
    \ (expt b 2) (expt c 2)) (> (expt c 2) (expt a 2))))\n", "  \n  (if (and (< a\
    \ b) (< b c))\n      (< (- a b) (- b c))\n      (< (- b a) (- c b)))) ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;",
  "  ;; Formula from wikipedia: \n  ;; (a^2 + b^2 - c^2) / (2ab)\n  (= (square-root\
    \ (square-root (square-root (+ (* a a b) \n                                  \
    \        (* b b c))\n                                    (- (* c c a))\n     \
    \                               (* a a b))\n                               2)\n\
    \              2))\n)\n", "  (< (abs (- a b)) (abs (- a c))) (< (abs (- a c))\
    \ (abs (- b c))))\n", "  (< (abs a) (abs b) (abs c))\n  (let ((d (abs (a-b)) (d-b\
    \ (abs c)) (d-c (abs b))))\n    (< (* d d) 0)\n    (< (* d d) a) (< (* d d) b)\n\
    \    (< (* d d) c)))\n", "  (< (abs (- a c)) (abs (- b c)))\n  (> (abs (- b a))\
    \ (abs (- c b)))\n  (> (abs (- c a)) (abs (- b c))))\n  \n", "  (<= a (abs b)\
    \ (abs c))\n  (or (= (mod a 2) 1)\n      (= (mod b 2) 1)\n      (= (mod c 2) 1)))",
  "  (< (abs a) (abs b) (abs c)) \n  (or (> (abs a) (abs b)) (> (abs a) (abs c)) (>\
    \ (abs b) (abs c))))\n", "  (> (- a b c) (* c b a)))\n", "  (or (> (abs (- a b))\
    \ (abs (- a c)) (abs (- b c)))\n      (< (abs (- a b)) (abs (- c b)) (abs (- c\
    \ a)))\n      (< (abs (- b c)) (abs (- c a)) (abs (- a c))))) ;#lang racket\n",
  "  (if (< a b c)\n      #t\n      (if (< b c a)\n          #t\n          (if (<\
    \ c a b)\n              #t\n              #f))))\n", "  (< (abs a) (abs b) (abs\
    \ c)) \n  (false \n   (and (= (abs a) (abs b) (abs c)) \n        (= a (abs b)\
    \ (abs c)) \n        (= a (abs c) (abs b)) \n        (= b (abs c) (abs a)) \n\
    \        (= b (abs a) (abs c)) \n        (= c (abs a) (abs b)) \n        (= c\
    \ (abs b) (abs a)))))\n</code>\n<code>\n#lang racket", "  (and (= a b)\n     \
    \  (= b c)\n       (= c a)))\n", "  (let ((angle_to_right_a (- (* b a) (car c))))\n\
    \    (= (cdr c) (* angle_to_right_a (* a b))))))\n", "  (let ((sum (+ a b c)))\n\
    \    (if (and (< sum 0) (< sum (/ a 3)))\n        #t\n        #f)))\n", "  (or\
    \ (= (* a b) (* b c))\n      (= (* b a) (* c b))\n      (= (* c a) (* a c))\n\
    \      (= (* a b) (* b a))\n      (= (* a c) (* c a))\n      (= (* b c) (* c b))))\n",
  "  (= (mod c 2) (mod b 2)))\n</code>\n<|/ a dscore=2 |>\n<| c |>\nI think it's better\
    \ to use `mod` instead of `remainder` in this case.\n<|/ c |>\n<| a tags=racket,lisp,scheme,lisp\
    \ |>\nI implemented it in Racket using recursion. Hope this helps!\n<code>", " \
    \ (< (abs a) (abs b) (abs c))\n  )\n", "  (< (abs a) (abs b) (abs c)) \n  ;; Check\
    \ that the sides are all positive.\n  ;; If they're all positive, that's a right-angled\
    \ triangle.\n  ;; But if they're all negative, that's not a right-angled triangle.\n\
    \  (and (>= a b) (>= b c) (>= c a))\n  ;; Check that the sum of the two sides\
    \ is twice the hypotenuse.\n  ;; If it's not a triangle, return #f.\n  (and (=\
    \ (+ (abs a) (abs b)) (+ (abs a) (abs c))) \n       (= (+ (abs b) (abs c)) (+\
    \ (abs b) (abs a)))\n       (= (+ (abs c) (abs a)) (+ (abs c) (abs b)))\n    \
    \   (= (+ (abs a) (abs b)) (+ (abs b) (abs c))) \n       (= (+ (abs b) (abs c))\
    \ (+ (abs c) (abs a)))\n       (= (+ (abs c) (abs a)) (+ (abs c) (abs b)))\n \
    \      (= (+ (abs a) (abs b)) (+ (abs b) (abs c))) \n       (= (+ (abs b) (abs\
    \ c)) (+ (abs c) (abs a)))\n       (= (+ (abs c) (abs a)) (+ (abs c) (abs b))))\n\
    \  ;; Return #t if it's a right angled triangle. Otherwise, return #f.\n  (right_angle_triangle\
    \ a b c)\n  )\n", "  (< (* a b) (* c a)))\n", "  (= (abs (- a c))\n     (abs (-\
    \ b c))\n     )\n  )\n  ;; O(n)\n  ;; #lang racket\n", "  (cond\n    [(= a b)\n\
    \     (< c b) ; 90 degree\n    ]\n    [(= b c)\n     (< a c) ; 90 degree\n   \
    \ ]\n    [else\n     (and (< a b)\n          (< c b))\n    ]\n  )\n)\n", "  (=\
    \ (angle-between-sides b c) (angle-between-sides a b))\n  )\n", "  (< (abs (-\
    \ a b) (- a c)) (abs (- b c) (- b a) (- c a) (- c b))))\n", "  (< a b c\n    \
    \  ;; Check whether three sides are equal\n      (< (+ a b c) a)\n      ;; Check\
    \ whether two of three sides are equal\n      (< (+ b c a) b)\n      ;; Check\
    \ whether one of three sides is equal\n      (< (+ c a b) c)))\n", "  (= (* a\
    \ b c) (/ (+ (* a a) (* b b) (* c c)) (+ (* b b) (* c c) (* a a)))))\n", "  (cond\n\
    \    [(< a b) (or (>= c a) (>= c b) (>= c c))]\n    [else #t]))\n", "  (> (* b\
    \ c) (* a c)))\n", "  (= (modulo b (+ (* a c) a)) (modulo (+ a c) b)))\n", " \
    \ (and (or (eq? a b) (eq? b c))\n       (or (eq? b c) (eq? c a))))\n", "  (let\
    \ ((d (abs (a-b) (c-b)))\n        (e (abs (b-a) (c-a)))\n        (flip (abs (a-c)\
    \ (b-c))))\n    (<= d e)))\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThe code does\
    \ not work, it returns false when given `1 2 3`. And also when given `2 3 4`.\n\
    <|/ c |>\n<| a tags=racket,scheme |>\nIf you're using Racket and would like to\
    \ solve this problem with that language, then you can do the following:\n<code>",
  "  (= (sqr (+ (* a a) (* b b) (* c c))) \n     (* 180 (- (* b c) (* a b)))))\n",
  "  (<= (abs a) (abs b) (abs c) (* a b c)))\n", "  (= (- c b) a)\n  (and (= a b)\
    \ (= c b)))\n", "  (letrec (\n          (sides (lambda (a b c)\n             \
    \   (cond\n                  [(= a b) (+ c a)]\n                  [(= a c) (+\
    \ b a)]\n                  [(= b c) (+ a b)]\n                  [else (/ a b)]))\n\
    \          )\n          (congruent_angles (lambda (a b c)\n                  \
    \          (cond [(= a b) (+ c a)]\n                                  [(= a c)\
    \ (+ b a)]\n                                  [(= b c) (+ a b)]\n            \
    \                      [else (/ a b)]))\n          )\n          (is_right_angle\
    \ (lambda (a b c)\n                            (cond [(= a b) (+ c a)]\n     \
    \                             [(= a c) (+ b a)]\n                            \
    \      [(= b c) (+ a b)]\n                                  [else (/ a b)]))\n\
    \          )\n          (is_right_angle_triangle? (lambda (a b c)\n          \
    \                            (cond [(= sides a b c) (is_right_angle a b c)]\n\
    \                                            [(= sides b c a) (is_right_angle\
    \ b c a)]\n                                            [(= sides c a b) (is_right_angle\
    \ c a b)]\n                                            [else #f])\n          )\n\
    \          (is_right_angle_triangle (lambda (a b c)\n                        \
    \            (cond [(= sides a b c) (congruent_angles a b c)]\n              \
    \                            [(= sides b c a) (congruent_angles b c a)]\n    \
    \                                      [(= sides c a b) (congruent_angles c a\
    \ b)]\n                                          [else #f])\n          )\n   \
    \       )\n    (cond [(is_right_angle_triangle? (a b c)]\n          [(is_right_angle_triangle\
    \ (a b c)]\n          [(is_right_angle_triangle b c a)\n          #t]\n      \
    \    [(is_right_angle_triangle c a b)\n          #t]\n          [else #f]\n  \
    \        )\n      )\n    )\n  )\n", "  (< (abs (- a c)) (abs (- b c))))\n", " \
    \ (= (abs a) (abs b) (abs c)))\n#lang racket\n", "  (< (abs a) (abs b) (abs c)))\n",
  "  (and (< a b)\n       (< b c)\n       (< c a)))\n", "  \n  (cond ((= a b) (= b\
    \ c))\n        ((= c a) (= a b))\n        ((< a b) (< b c) (< a c))\n        ((<\
    \ b c) (< c a) (< b a))\n        ((< c a) (< a c) (< c b)))\n  \n  (let ((x (car\
    \ b)) (y (cdr b)) (z (car a)) (t (cdr a)))\n    (cond (\n           (= x y) (<\
    \ x z) (< y z))\n          ((= x z) (< x t) (< y t))\n          ((= y z) (< y\
    \ t) (< x t)))\n    (not (= x y))))\n", "  (< (expt a 2) (expt b 2) (expt c 2)))\n",
  "  (< (* a b) (c (+ a b) c)))\n", "  (cond \n    ((< (abs (- a b) (abs (- c a))))\
    \ (abs (- a b)))\n    ((< (abs (- b c) (abs (- a b)))) (abs (- b c)))\n    ((<\
    \ (abs (- c a) (abs (- b c)))) (abs (- c a))\n    (else #f)))\n", "  (= (* a b)\
    \ (* c a) (* b c)))\n", "  (< (- b a) (- c a))\n  (< c a))\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\n`(cdr (list a))` looks like an error.\n<|/ c |>\n<| c |>\n, Yes,\
    \ I should have said `(list a)`, of course.  I guess `(cdr (cdr ...))` means `(cdr\
    \ (list (car ...)))` but it doesn't make any sense to me.  I think it should be\
    \ `(list (car ...))`\n<|/ c |>\n<| c |>\nYes, I meant `(cdr (list a))` (note the\
    \ extra pair of parentheses). I'll fix it now.\n<|/ c |>\n<| c |>\n, Oh, right,\
    \ I forgot that `list` returns `(a b c)` instead of `(a b . c)`.\n<|/ c |>\n<|\
    \ c |>\n`(list (car ...))` won't work for any input size that is smaller than\
    \ 3.  You need a way to know when you have reached the last list element in the\
    \ recursion.\n<|/ c |>\n<| a dscore=2 |>\nThe solution\nI guess it is the most\
    \ readable one:\n<code>", "  (< (abs (- (square (- a b)) (square (- b c))))\n\
    \     (abs (- (square (- b a)) (square (- c b))))\n     (abs (- (square (- c a))\
    \ (square (- a c))))))\n", "  (< (abs (- a b)) (abs (- c b)))\n  (or (= (* a b)\
    \ 0)\n      (= (* c b) 0)\n      (= (* b c) 0)\n      (= (* a c) 0)))\n", "  (<\
    \ (* a b) (* a c) (* b c)))\n", "  (< (abs (- a b) c)\n     (abs (- b c) c)))\n",
  "  (< (abs a) (abs b) (abs c)))\n", "  (< (abs (- a b) (- a c) (- b c))) 90))\n",
  "  (let ((length (- a b c))\n        (sign (if (< a b) (+ a b) (- (+ a c) b))))\n\
    \    (< (abs length) (abs sign))))\n", "  (< (abs (- (- b c) a)) (abs (- (- a\
    \ c) b))))\n", "  (or (= (length a) 3)\n      (= (length b) 3)\n      (= (length\
    \ c) 3)))\n", "  (cond\n    [(zero? a) (equal? b c)]\n    [(zero? b) (equal? a\
    \ c)]\n    [(zero? c) (equal? a b)]\n    [else (equal? (angle_to_angle a b) (angle_to_angle\
    \ a c))]))\n", "  (> (* a b) (* c a)))\n", "  (cond\n    ((= a b)\n     (< c b))\n\
    \    ((= a c)\n     (= b c))\n    ((= b c)\n     (< a b))\n    (else #f)))\n",
  "  (< (- b a) (- c a)) \n  (or ((equal? a b) (equal? b c)) \n      (equal? (- a\
    \ b) (- b c))\n      (equal? (- a c) (- c b))))\n", "  (cond\n    [(and (< a b)\
    \ (< b c)) (and (<= c a) (>= b c))]\n    [(and (< a c) (< c b)) (and (<= b a)\
    \ (>= c b))]\n    [else #f]\n  ))\n", "  (< (abs (- a b))\n     (abs (- b c))\n\
    \     (abs (- a c))))\n", "  (<= 0 a b c))\n", "  (< (abs (- a c)) (abs (- b c)))\n\
    \  (or (equal (abs (- a b)) (abs (- c b))) (equal (abs (- a c)) (abs (- b c))))\n\
    \  (or (equal (abs (- b a)) (abs (- c a))) (equal (abs (- b c)) (abs (- c b))))\n\
    \  (or (equal (abs (- c a)) (abs (- a b))) (equal (abs (- c b)) (abs (- a b))))\n\
    \  (or (equal (abs (- a b)) (abs (- c a))) (equal (abs (- b c)) (abs (- c a))))\n\
    \  (or (equal (abs (- a c)) (abs (- b a))) (equal (abs (- b b)) (abs (- a b))))\n\
    \  (or (equal (abs (- b a)) (abs (- a c))) (equal (abs (- b c)) (abs (- a c))))\n\
    \  (or (equal (abs (- a b)) (abs (- b c))) (equal (abs (- a c)) (abs (- b c))))\n\
    \  (or (equal (abs (- b a)) (abs (- c a))) (equal (abs (- b c)) (abs (- c a))))\n\
    \  (or (equal (abs (- c a)) (abs (- a b))) (equal (abs (- c b)) (abs (- a b))))\n\
    \  (or (equal (abs (- a c)) (abs (- b a))) (equal (abs (- b b)) (abs (- a b))))\n\
    \  (or (equal (abs (- b a)) (abs (- c a))) (equal (abs (- b c)) (abs (- c a))))\n\
    \  (or (equal (abs (- c a)) (abs (- a b))) (equal (abs (- c b)) (abs (- a b))))\n\
    \  (or (equal (abs (- a b)) (abs (- b c))) (equal (abs (- a c)) (abs (- b c))))\n\
    \  (or (equal (abs (- b a)) (abs (- c a))) (equal (abs (- b c)) (abs (- c a))))\n\
    \  (or (equal (abs (- c a)) (abs (- a b))) (equal (abs (- c b)) (abs (- a b",
  "  (< (- (/ a b) (/ a c))\n      (- (/ b c) (/ a c))))\n", "  (and (< a b) (< b\
    \ c) (< c a) (>= (* a b c) (* b c a))))\n", "  (< (abs a) (abs b) (abs c)))\n",
  "  (< a b c))\n", "  (< (abs a) (abs b) (abs c)))\n", "  (<= a b c)\n  (<= b c a)\n\
    \  (<= c a b))\n", "  (< (abs (- (sqrt a) (sqrt b) (sqrt c)))\n     (* a (* b\
    \ c))))\n", "  (< (abs a) (abs b) (abs c))\n  (< b (abs a) (abs c))\n  (< c (abs\
    \ b) (abs a)))\n", "  (cond \n    [(and (<= a b) (<= a c) (<= b c)) #t]\n    [(or\
    \ (<= b a) (<= c a)) #f]\n    [else #f]))\n", "  (< (abs a) (abs b) (abs c)))\n",
  "  (< (abs a) (abs b) (abs c))\n  (or (< (abs b) (abs c)) (< (abs a) (abs c))) \n\
    \  (< (abs c) (abs a))\n  (< (abs b) (abs a))\n  ))\n", "  (= (mod a b) (mod c\
    \ b)))\n", "  (< (abs (- a b)) (abs (- a c)) (abs (- b c))) ))\n", "  (< (abs\
    \ a) (abs b) (abs c)))\n", "  (cond\n    [(< a b) (< (- b a) (- c a))] \n    [else\
    \ #f]\n  )\n)\n", "  (< (abs (- a b)) (abs (- a c)) (abs (- b c))))\n", "  (<\
    \ (abs (- a b)) (abs (- a c))) \n  (< (abs (- a c)) (abs (- b c))))\n", "  (<\
    \ (abs a) (car b))\n  (or (= (abs a) (car b)) (= (abs a) (car c))))", "  (< (abs\
    \ a) (abs b)\n     (abs c))\n)\n", "  (cond (< a b) (< a c) (< b c))\n  (cond\
    \ (< a b) (< b c) (< c a))\n  (cond (< b c) (< c a) (< a b)))\n", "  (cond [(<\
    \ a b) (< b c)\n         (< a c)\n         (< c b)\n         (< b a)\n       \
    \  (< c a)]\n        [else\n         (> (abs (- a b)) (abs (- b c)))\n       \
    \  (> (abs (- a c)) (abs (- c b)))\n         (> (abs (- a b)) (abs (- b a)))\n\
    \         (> (abs (- a c)) (abs (- c a)))]))\n", "  \n  (cond\n    [(< a b) (<\
    \ b c) (< c a) '#f]\n    [(< a b) (< b c) (< c a) (< a c) (< c b)] #t\n    [(<\
    \ a b) (< b c) (< c a) (< a c) (< a b)] #t\n    [(< a b) (< b c) (< c a) (< b\
    \ c) (< b a)] #t\n    [(< a b) (< b c) (< c a) (< b c) (< b a)] #t\n    [(< a\
    \ b) (< b c) (< c a) (< b c) (< b a)] #t\n    [(< a b) (< b c) (< c a) (< b c)\
    \ (< a b)] #t\n    [(< a b) (< b c) (< c a) (< b c) (< a b)] #t\n    [(< a b)\
    \ (< b c) (< c a) (< b c) (< a b)] #t\n    [(< a b) (< b c) (< c a) (< b c) (<\
    \ a b)] #t\n    [(< a b) (< b c) (< c a) (< b c) (< a b)] #t\n    [(< a b) (<\
    \ b c) (< c a) (< b c) (< a b)] #t\n    [(< a b) (< b c) (< c a) (< b c) (< a\
    \ b)] #t\n    [(< a b) (< b c) (< c a) (< b c) (< a b)] #t\n    [(< a b) (< b\
    \ c) (< c a) (< b c) (< a b)] #t\n    [(< a b) (< b c) (< c a) (< b c) (< a b)]\
    \ #t\n    [(< a b) (< b c) (< c a) (< b c) (< a b)] #t\n    [(< a b) (< b c) (<\
    \ c a) (< b c) (< a b)] #t\n    [(< a b) (< b c) (< c a) (< b c) (< a b)] #t\n\
    \    [(< a b) (< b c) (< c a) (< b c) (< a b)] #t\n    [(< a b) (< b c) (< c a)\
    \ (", "  (< (abs a) (abs b) (abs c))\n  (< (abs b) (abs a) (abs c))\n  (< (abs\
    \ c) (abs a) (abs b)))\n", "  (< (abs (- c a)) (abs (- b a)))) \n", "  (let ((l\
    \ (+ (* a a) (* b b) (* c c)))\n        (u (- l (* a b) (* b c)))\n        (x\
    \ (- u (* b c))))\n    (cond\n      [(< l u) (* l x)]\n      [(< u x) (* u x)]\n\
    \      [else #f])))\n", "  (= (mod c 2)\n      (or (= (mod b a) (mod c a)) (=\
    \ (mod b c) (mod c c)))))\n", "  (= (abs (- a b)) (abs (- b c)) (abs (- c a))))\n",
  "  (equal? (abs (- c a) (- c b))\n          (abs (- a b) (- b c))\n          1e-6))\n",
  "  (<= a (* b c) (abs b) (abs c)))\n", "  (> (- (square (- a b) c) (* c b)) (/ a\
    \ b)))\n", "  (and (or (= a b) (= b c) (= c a)) (or (= a c) (= b a) (= c b))))\n",
  "  (let ((c (* c c)))\n    (< a b c)\n    (< a c b)\n    (< b c a)\n    (< c b a)\n\
    \    (< c a b)\n    (< c b c)))\n", "  (< (* a b) (* c c)))\n", "  (< (abs (-\
    \ a b)) (abs (- a c)) (abs (- b c))))\n", "  (let ((x a))\n    (if (or (= x b)\
    \ (= x c))\n        (= a b)\n        (= a c)\n        (= b c))\n      (= (mod\
    \ x 2) 0)\n      (= (mod x 3) 0)\n      (= x 1)\n      (= x 2)\n      (= x 3)\n\
    \      (= x 4))\n    (not (= (mod x 3) 0))))\n", "  (= a b) (= a c) (= b c))\n",
  '  (< a b) (< b c) (< c a))']
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
