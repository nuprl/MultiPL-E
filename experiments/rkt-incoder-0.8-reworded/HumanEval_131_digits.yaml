name: HumanEval_131_digits
language: rkt
prompt: "#lang racket\n\n;; Given a positive integer n, return the product of the\
  \ odd digits.\n;; Return 0 if all digits are even.\n;; For example:\n;; >>> (digits\
  \ 1)\n;; 1\n;; >>> (digits 4)\n;; 0\n;; >>> (digits 235)\n;; 15\n(define (digits\
  \ n)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate digits))\n\
  \    (check-equal? (candidate 5) 5)\n    (check-equal? (candidate 54) 5)\n    (check-equal?\
  \ (candidate 120) 1)\n    (check-equal? (candidate 5014) 5)\n    (check-equal? (candidate\
  \ 98765) 315)\n    (check-equal? (candidate 5576543) 2625)\n    (check-equal? (candidate\
  \ 2468) 0)\n))\n\n(test-humaneval)"
completions: ["  (if (= n 0)\n      0\n      (* 2 (digits (cdr n))))) ; 2 is odd,\
    \ 3 is even, 4 is odd, etc\n", "  (local ([digits 0])\n    (let ([remainder (quotient\
    \ n 10)]\n          [last-digit (modulo n 10)]\n          [last-digit (modulo\
    \ last-digit 10)])\n      (set! n (- n remainder))\n      (cond\n        ((= last-digit\
    \ 0) (quotient n 10))\n        ((= last-digit 1) (* n 10))\n        (else (digits\
    \ n)))))) ;; (digits 235) returns 15\n", "  (cond\n    [(= n 0) 0]\n    [(= n\
    \ 1) 1]\n    [else (* 3 (digits (remainder n 10)))]))\n", "  (if (even? n)\n \
    \     0\n      (* n\n           (digits (remainder n 10))))) ;; <-- Recursive\
    \ call\n", "  (cond\n    [(= n 1) 1]\n    [(= (mod n 10) 0) (* n (digits (rem\
    \ n 10)))]\n    [else (digits (rem n 10))]))\n", "  (let loop ()\n    (if (zero?\
    \ n)\n        0\n        (if (even? (modulo n 10))\n            (* n 10)\n   \
    \         (loop))))))\n", "  (cond [(< n 0) 0]\n        [(= n 0) 1]\n        [else\
    \ (* 3 (digits (- n 1)))]))\n", "  (let loop ((n n) (digits '()))\n    (cond\n\
    \      ((= n 0) (set! digits '1))\n      ((= n (quotient n 10)) (set! digits (list\
    \ n)))\n      (else (loop (quotient n 10) (append digits (quotient n 10)))))))\n\
    </code>\nEDIT: Here's the racket version. I'm guessing there's room for improvement\
    \ here, but at least it's more readable.\n<code>", "  (cond\n    [(< n 0) 0]\n\
    \    [(= (modulo (+ n 1) 10) 0) (+ (modulo n 10) 1)]\n    [else (* 3 (digits n))]\n\
    \  ))\n", "  (let ((m (odds-factors n)))\n    (if (null? m)\n        0\n     \
    \   (* 0 (first m)))))\n", "  (cond\n    [(= n 0) 1]\n    [(= n 1) 1]\n    [else\
    \ (* 0 (modulo (modulo (digits n) (floor n 6)) 10))]))\n", "  (if (= n 0)\n  \
    \    0\n      (* 10 (digits (remainder n 10))))\n  )\n", "  (cond\n    [(= n 0)\
    \ 0]\n    [(= n 1) (/ n 2)]\n    [(odd? n) (* n (digits (quotient n 2)))]))\n",
  "  (if (even? n)\n      (* n (digits (quotient n 2)))\n      0))\n", "  (define\
    \ (loop d n0)\n    (if (= n0 0)\n        0\n        (* d (remainder n0 10))\n\
    \        (loop (+ d 1) (remainder n0 10))))\n  (loop (+ n 1) 0))\n", "  (if (=\
    \ n 0)\n      0\n      (let ((product 1))\n        (for-each (lambda (x) (set!\
    \ product (* product x))) (reverse (quotient n 2))) (* product (digits (remainder\
    \ n 2))))))\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThank you! But I can't use defines.\
    \ I'm suppose to use lambda (just like in the book), but I can't use defines.\n\
    <|/ c |>\n<| c |>\nI've just fixed that in my answer. I was going to say that\
    \ lambda is just like define, but it's not, they aren't exactly the same.\n<|/\
    \ c |>\n<| c |>\nIt isn't exactly the same but it is similar enough to demonstrate\
    \ the use of `for-each`. You can think of it as `map` but for a different purpose.\n\
    <|/ c |>\n<| c |>\nThank you! Your answer is very helpful!\n<|/ c |>\n<| a dscore=0\
    \ tags=racket,lambda,scheme |>\nI couldn't find an exact duplicate of this question,\
    \ perhaps because it's been asked before, but I have a solution that's fairly\
    \ simple.\n<code>", "  (let loop ((num n) (res '()))\n    (cond\n      [(= num\
    \ 0) 0]\n      [(= (modulo num 10) 0) (cons num (reverse res))]\n      [else (loop\
    \ (quotient num 10) (res (modulo num 10)))])))\n", "  (cond\n    [(even? n) n]\n\
    \    [(odd? n) (* 10 (digits (rem n 10)))]\n    [else 0]))\n", "  (if (even? n)\n\
    \      (* 2 (digits (remainder n)))\n      0))", "  (reverse\n   (map (\u03BB\
    \ (x) (* n x)) (quotient n 10))\n   (reverse (quotient n 10))\n  ))\n", "  (cond\n\
    \    [(< n 0) 0]\n    [else (even? (remainder n 2)))\n          ((digits (remainder\
    \ n 2))\n           (* (remainder n 2) (remainder (quotient n 2) 10)))\n     \
    \     (else (even? (quotient n 2)))\n          ((digits (remainder (quotient n\
    \ 2) 10))\n           (* (quotient n 2) (remainder (quotient (quotient n 2) 10)\
    \ 10)))\n          (else (odd? (remainder n 2)))]\n    [else (odd? (remainder\
    \ n 2)))]\n    [else (* 0 (digits (remainder n 10)))]\n  )\n)\n", "  (cond\n \
    \   [(zero? n) (* n 1)]\n    [else (* 10 (digits (rem n 10))) (rem n 10)]))\n",
  "  (cond [(< n 0)\n         0]\n        [(= (mod n 10) (even? n))\n         (* n\
    \ (digits (rem n 10)))]\n        [else\n         (digits (rem n 10))]))\n</code>\n\
    For reference, here is the same solution written in racket, with a different style\
    \ of writing, and with comments removed:\n<code>", "  (if (even? n)\n      (*\
    \ n digits (digits (remainder n 10)))\n      (zero? n)))\n", "  (cond\n    [(even?\
    \ n) (* n n)] \n    [else 0]))\n", "  (cond\n    [(< n 0) 0]\n    [(= (modulo\
    \ n 10) 0) (* n n)]\n    [else (digits (remainder n 10))]))\n", "  (if (positive?\
    \ n) \n      (even? (modulo n 10)) (* n (digits (rem n 10)))\n      0))\n", " \
    \ (if (zero? n)\n      0\n      (let loop ((n n) (acc 0))\n        (if (even?\
    \ n)\n            (loop (quotient n 10) (incf acc))\n            (loop (quotient\
    \ n 10) (* acc 10))))))\n", "  (cond [(= n 0) 0]\n        [else (* n (digits (remainder\
    \ n 10)))]))\n", "  ; We only care about even digits here.\n  ; (check-expect\
    \ (even? n) true)\n  (check-expect (positive? n) true)\n  (check-expect (positive?\
    \ n) (>= n 0))\n  (let (result 0)\n    (set-mem-requirement result (mem-ref 0\
    \ 0))\n    (mem-loop [(n n) (i 1) (j 1)\n               (c 0) (r '())]\n     \
    \ (when (even? n) (set-mem-requirement r (mem-ref r 0 (+ i j))))\n      (when\
    \ (odd? n) (set-mem-requirement r (mem-ref r 0 (+ i j) (+ c 1))))\n      (set!\
    \ n (/ n 10))\n      (set! i (+ i 1))\n      (set! j (+ j 1))\n      (set! c (+\
    \ c 1))\n      (r))\n    result))\n", "  (cond [(= n 0) 0]\n        [(odd? n)\
    \ (* n n (digits (quotient n 2)))]\n        [else (digits (quotient n 2))]))\n",
  "  (cond [(= n 0) 0]\n        [(odd? n) (* n (digits (rem n 2)))]\n        [else\
    \ 0]))\n</cell>\n<text>\nExercise\nA palindrome is a string that reads the same\
    \ backward as forward, for example\n\"racecar\", \"racecars\", \"racecarcars\"\
    .\nA palindrome is a valid English word: the first and last characters have to\
    \ be the same.\nWrite a procedure that checks if a word is a palindrome.\n\nAsk\
    \ a user to input a word. Make sure you check the user input's length.\n\nAsk\
    \ the user to input a second word. Make sure you check the second word's length.\n\
    \nReturn true if the first word is a palindrome and the second word is the same\
    \ as the first word.\nReturn false otherwise. For example:\n>>> is_palindrome\
    \ \"hello\"\ntrue\n>>> is_palindrome \"racecar\"\nfalse\n>>> is_palindrome \"\
    racecars\"\ntrue\n>>> is_palindrome \"racecarcar\"\nfalse\n>>> is_palindrome \"\
    racecarcars\"\ntrue\n>>> is_palindrome \"racecarcarc\"\nfalse\n>>> is_palindrome\
    \ \"racecarcarcs\"\nfalse\n>>> is_palindrome \"racecarcarcsc\"\nfalse\n>>> is_palindrome\
    \ \"racecarcarcsca\"\nfalse\n>>> is_palindrome \"racecarcarcscah\"\nfalse\n>>>\
    \ is_palindrome \"racecarcarcscahs\"\nfalse\n>>> is_palindrome \"racecarcarcscah\"\
    \nFalse\n>>> is_palindrome \"racecarcarcscahs\"\nFalse\n>>> is_palindrome \"racecarcarcscahs\"\
    \nFalse\n>>> is_palindrome \"racecarcarcscahs\"\nFalse\n>>> is_palindrome \"racecarcarcscahs\"\
    \nFalse\n>>> is_palindrome \"racecarcarcscahs\"\nFalse\n>>> is_palindrome \"racecarcarcscahs\"\
    \nFalse\n>>> is_palindrome \"racecarcarcscahs\"\nFalse\n>>> is_palindrome \"racecarcarcscahs\"\
    \nFalse\n>>> is_palindrome \"racecarcarcscahs\"\nFalse\n>>> is_palindrome \"racecarcarcscahs\"\
    \nFalse\n>>> is_palin", "  (if (positive? n)\n      (let ([m (quotient n 2)])\n\
    \        (if (even? m)\n            (* m n)\n            (* n m))))\n  0)\n",
  "  (cond\n    [(< n 0) 0]\n    [else (* 2 (digits (remainder n 10)))]))\n", "  (*\
    \ n (expt 2 n))) ;; <-- #1 Racket\n", "  (cond\n    ((= n 0) 0)\n    ((= n 1)\
    \ 1)\n    (else\n     (* \n      (* \n      (digits \n       (quotient n 2)) \n\
    \      (* \n       (digits (remainder n 2)))) \n     (* \n      (digits \n   \
    \    (quotient n 4)) \n      (* \n       (digits (remainder n 4)))))))\n", " \
    \ (cond [(= n 0) 1]\n        [else (* 3 (digits (rem n 10)))]))\n", "  (check-type\
    \ n integer)\n  (if (even? n) 0\n      (let ([d (modulo n 10)])\n        (* d\
    \ (digits (remainder n 10)))))) \n", "  (cond\n    ((= n 1) (even? (digits (cdr\
    \ n))))\n    ((even? (car n)) (* n (digit (cdr n))))\n    (else (digit (cdr n)))))\
    \ ;; #lang racket\n</code>\n<|/ a |>\n<| c |>\nI think you mean \"`digits` takes\
    \ an integer `N` as its argument\" (`digits` is called `digits`, not `digit`,\
    \ so perhaps you meant `digits`, not `digit`?) The code you've given doesn't look\
    \ like it's working with negative numbers, either.\n<|/ c |>\n<| a tags=racket,scheme\
    \ dscore=0 |>\nHere is a solution I came up with:\n<code>", "  (if (< n 0)\n \
    \     0\n      (* n ((digits (remainder (remainder n 10) (quotient n 10)) 10))))\n",
  "  (if (even? n)\n      0\n      (* 1 (digits (remainder n 10))))) \n", "  (if (positive?\
    \ n)\n      (* n\n         (digits (quotient n 10)))\n      0))\n", "  (check-expect\
    \ (< n 0) 0)\n  (let digit-product ([n n])\n    (cond\n      [(= n 0) 1]\n   \
    \   [(odd? n) (* n digit-product)]\n      [else (digit-product (quotient n 10))]))))\n",
  "  (cond ((= n 0) 0)\n        ((even? (modulo n 10)) (* 10 n))\n        (else (digits\
    \ (n-1))))) ;; #lang racket\n", "  (if (zero? n)\n      0\n      (/ (* n (expt\
    \ 2 (- n 1)))\n         (expt 2 (- n 1)))))\n", "  (if (even? n) 1\n      (* (digits\
    \ (quotient n 10)) ((remainder n 10))))\n  )\n</code>\n<|/ a tags=scheme,racket,sicp\
    \ |>\n<| c |>\nThanks for the explanation.\n<|/ c |>\n<| c |>\nI made a correction\
    \ to the `digits` function, the new function should work for all positive integers.\n\
    <|/ c |>\n<| c |>\nThanks, I corrected the typo!\n<|/ c |>\n<| a tags=scheme,racket,sicp\
    \ dscore=0 |>\nI couldn't follow the other answers. Here's my take on the problem.\
    \ \n<code>", "  (cond [(= n 0)\n         0]\n        [(even? (remainder n 10))\n\
    \         (* n (digits (remainder n 10)))]\n        [else\n         (* n (digits\
    \ (remainder n 10)))))\n", "  (cond [(= n 0) 1]\n        [(even? (remainder n\
    \ 10)) (* 1 (digits (remainder n 10)))]\n        [else 0]))\n", "  (if (< n 0)\n\
    \      0\n      (* n (digits (n-1)))))\n</code>\nNow, we can write a function\
    \ that computes the GCD of two numbers:\n<code>", "  (cond [(< n 10) 0]\n    \
    \    [else (* n (digits (quotient n 10)))]))\n", "  (cond\n    [(< n 0) 0]\n \
    \   [(> n 10) 0]\n    [(= (mod n 10) 0) (* n 10) (digits n-1)]\n    [else (* n\
    \ (digits (n-factor)))]))\n", "  (cond [(< n 0) 0]\n        [(even? (remainder\
    \ n 2))\n         (* (remainder n 2) (remainder n 2))]\n        [else (+ n 1)]))\n",
  "  (if (= n 0)\n      0\n      (if (odd? n)\n          (* n (digits (quotient n\
    \ 2)))\n          (* n (digits (quotient n 2))))))\n", "  (cond [(= n 0) 1]\n\
    \        [(= (modulo n 10) 0) 0]\n        [else (* 3 (digits (remainder n 10)))]))\n",
  "  (let loop ((n n) (acc 0))\n    (cond ((< n 0) 0)\n          ((even? (modulo n\
    \ 10)) (* acc (modulo n 10)))\n          (else (loop (quotient n 10)\n       \
    \                (* acc (quotient n 10)))))))\n", "  (if (odd? n)\n      (* n\
    \ (digits (remainder n 10)))\n      0))\n", "  (if (= n 0)\n      0\n      (*\
    \ n (digits (quotient n 2)))))\n", "  (cond ((< n 0) 0)\n        ((even? n) (*\
    \ n (digits (quotient n 2))))\n        (else (digits (remainder n 2)))))\n", " \
    \ (cond\n    [(= n 0) 0]\n    [(even? n) (* 10 (digits (remainder n 10)))]\n \
    \   [else (* 10 (digit (remainder n 10)))]))\n", "  (if (< n 0)\n      0\n   \
    \   (let ((digits '()))\n        (loop for i from 0 to (- n 2) by 2\n        \
    \      collect (+ (quotient i 10) digits))))\n", "  ;; A helper function returning\
    \ product of odd-indexed digits.\n  ;; Takes an integer and returns the product\
    \ of the odd-indexed digits.\n  ;; If the number is odd, returns 0.\n  (if (odd?\
    \ n)\n      0\n      (even? (digits (cdr n))))) ;; A helper function", "  (cond\
    \ [(= n 0) 0]\n        [(even? (remainder n 10)) (remainder (remainder n 10) (*\
    \ 2 10))]\n        [else (+ 1 (digits (quotient n 10)))]))\n", "  (if (= n 0)\n\
    \      0\n      (* n (digits (quotient n 2)))))\n", "  (cond [(< n 1) 0]\n   \
    \     [(= (mod n 10) 0) 0]\n        [else (* 10 (digits (rem n 10)))))\n", " \
    \ (cond\n    ((= n 0)\n     (set! n (expt 2 n)))\n    ((odd? n)\n     (set! n\
    \ (/ (mod n 10) 10)))\n    ((even? n)\n     (set! n (* n n)))\n    (else 0)))\n",
  "  (cond [(= n 0) 1]\n        [(even? (remainder n 10)) (remainder n 10)]))\n",
  "  (if (= n 0)\n      0\n      (let ([product (* 2 (digit n))]\n            ;; If\
    \ all digits are even, the product is zero and we return zero.\n            (even?\
    \ n (digits (n-1))))\n        (if (even? n)\n            0\n            product))))\n",
  "  (if (= n 0)\n      0\n      (* n ((digits (remainder n 10))))))\n", "  (cond\n\
    \    [(zero? n) 0]\n    [(even? n) (* (digits (remainder n 10)) 2)]\n    [else\
    \ (digits (remainder n 10))]))\n", "  (cond [(< n 0) 0]\n        [(or (= (mod\
    \ n 10) 0) (even? (rem n 10)))\n         (* n (digits (rem n 10)))]\n        [else\
    \ (digits (rem n 10))]))\n", "  (let loop ((n n) (acc 1))\n    (if (= n 0)\n \
    \       acc\n        (loop (quotient n 10) (* (quotient n 10) (+ acc 1))))))\n",
  "  (cond\n    [(= n 0) 0]\n    [(= (remainder n 10) 0) (quotient n 10)]\n    [else\
    \ (* 2 (quotient n 10))]))\n", "  (cond [(= n 0)                        0\n  \
    \       (zero? (remainder n 10))        (* (remainder n 10) (digits (remainder\
    \ n 10)))]\n        [(even? (remainder n 10))         (* n (digits (remainder\
    \ n 10)))]\n        [else                            (digits (remainder n 10))]))\n",
  "  (cond\n    [(= n 0) 0]\n    [(even? (modulo n 10)) (* 10 (digits (rem n 10)))\
    \ (digits (rem n 10))]\n    [else 0]))\n", "  (if (even? (remainder n 10))\n \
    \     (* 3 (digits (remainder n 10))) \n      0))\n", "  (if (= n 0)\n      0\n\
    \      (let ([d (quotient n 10)\n            n (mod n 10)])\n        (+ (product\
    \ d) (digits n))))\n  )\n", "  (if (= n 0)\n      0\n      (* n (odd? (- n 1)))))\n",
  "  (if (even? n) 0\n      (* 10 (digits (quotient n 10))))\n)\n", "  (cond [(= n\
    \ 0)\n         0]\n        [(even? n)\n         (* n n (digits (/ n 2)))]\n  \
    \      [(odd? n)\n         (* n n (digits (/ n 2)))]\n        [else\n        \
    \ (digits n (quotient n 10))]))\n", "  (cond\n    [(= n 0) 0]\n    [(odd? (mod\
    \ n 10)) (* n 10)\n      (if (odd? (/ n 10)) (* 10 (digits (rem n 10)))\n    \
    \    (digits (rem n 10)))]\n    [else (digits (rem n 10))]))\n", "  (assert (positive?\
    \ n))\n  (define (odd digits)\n    (if (= digits 0) 0\n      (if (even? digits)\n\
    \        (* digits 2)\n        0)))\n  (if (= n 0) 0\n    (+ n (odd (nmod n 10))))))\n",
  "  (cond [(= n 0) 0]\n        [(even? (remainder n 10)) (remainder n 10)])\n   \
    \     (else (* 10 (digits (remainder n 10)))))\n", "  (define (aux i)\n    (define\
    \ (aux2 ((x i))\n      (if (even? x)\n          (* x (aux2 (+ i 1)))\n       \
    \   0))\n    (aux2 (+ i 1)))\n  (aux n))\n", "  (if (even? n)\n      (* n (odd?\
    \ n)))\n      (if (even? (remainder n 10))\n          (* n (even? n))\n      \
    \    (* n (odd (remainder n 10)))))) ; This could probably be written a lot nicer\n\
    </code>\n<|/ a dscore=1 tags=racket,scheme |>\n<| c |>\nA couple things. 1) the\
    \ second if statement in the first define is wrong; it should be `(if (even? (remainder\
    \ n 10)) (* n (even? n)) (* n (odd (remainder n 10))))`. 2) The OP was asking\
    \ about how to avoid nested if-statements. I took a stab at doing it with less\
    \ nested if-statements than OP had, but I felt it was an exercise for the reader.\
    \ 3) I like your use of recursion and fold.\n<|/ c |>\n<| c |>\nThanks for the\
    \ catch. I've fixed the second if. Regarding the second question, I was thinking\
    \ that I didn't want to use an if-statement and wanted to avoid nesting but I\
    \ just didn't know how! I guess I could have made the same mistake in the second\
    \ define though.\n<|/ c |>\n<| c |>\nNo problem. I actually thought you wanted\
    \ an if-statement to check for odd or even to prevent a nested if-statement but\
    \ I guess you just don't know how to use it.\n<|/ c |>\n<| c |>\nI really like\
    \ this solution.  I think it's beautiful.  I especially like the use of fold and\
    \ foldr.\n<|/ c |>\n<| a tags=racket,scheme dscore=1 |>\nHere is another option\
    \ that avoids the use of fold or foldr (which is not as elegant as the solutions\
    \ others have proposed):\n<code>", "  (cond [(> n 0) 0]\n        [(= (modulo n\
    \ 10) 0) 0]\n        [(= (modulo n 10) 1) (* n (digits (rem n 10)))]\n       \
    \ [else (digits (rem n 10))]))\n", "  (cond [(= n 0)         0]\n        [(zero?\
    \ (remainder n 10)) 0]\n        [else            (* 2 (digits (quotient n 10)))]))\n",
  "  (cond [(= n 0) 1]\n        [(even? n) (* n (digits (quotient n 2)))]\n      \
    \  [else 0]))\n", "  (cond\n    [(zero? n) 0]\n    [(odd? n) (* n (digits (remainder\
    \ n 10)))]))\n", "  (cond [(= n 0) 0]\n        [(= n 1) 1]\n        [(= (% n 10)\
    \ 0) 0]\n        [else (* 10 (digits n-1))]))\n", "  (if (= n 0)\n      0\n  \
    \    (if (even? (remainder n 10)) (remainder n 10)\n          (remainder (quotient\
    \ n 10) 10))))\n", "  (rem n 10 2))\n", "  (check-type n (positive-integer 0))\n\
    \  (let loop ((n n) (result 1))\n    (cond\n      ((= n 0) (check-type result\
    \ (positive-integer 0)))\n      (else (loop (quotient n 10)\n                \
    \   (* 10 result)))))) \n</cell>\n<cell>", "  (check-expect (number? n) true)\n\
    \  (let loop ((n n) (result 1))\n    (if (zero? n)\n        result\n        (loop\
    \ (quotient n 10) (rest (quotient n 10)))\n      )\n    ))\n", "  (cond [(= n\
    \ 0) 1]\n        [(odd? (modulo n 10)) (* (digits n 2) (digits (quotient n 10)))]\n\
    \        [else 0]))\n", "  (cond [(= n 0) 0]\n        [(= (remainder n 10) 0)\
    \ 1]\n        [else (* 3 (digits (remainder n 10)))]))\n", "  (* 3 (remainder\
    \ (quotient n 10) (floor n 10))))\n", "  (if (= n 0)\n      0\n      (let ((product\
    \ 1))\n        (loop\n           (when (< n 9)\n             (set! product (*\
    \ (expt 2 product) (expt n number))\n                    (- n 1))\n          \
    \   (set! n (- n 1))\n             (- n))\n         (if (= n 0)\n            \
    \ product\n             0))))\n", "  (cond [(= n 0) 1]\n        [(= (remainder\
    \ n 10) 0) 0]\n        [else (remainder n 10)]))\n", "  (cond [(= n 0) 0]\n  \
    \      [(even? (remainder n 10)) (* (remainder n 10) 10)]))\n", "  (if (= n 0)\n\
    \      0\n      (* 3 (digits (n-1)))))\n", "  (if (= n 0)\n      0\n      (* 10\
    \ (digits (quotient n 10))))) ; digit n / 10\n</cell>\n<code language=dyalog-kernel>",
  "  (* 10 (/ n 10)))\n", "  (let loop ((n n) (product 1))\n    (if (= n 0)\n    \
    \    product\n        (loop (quotient n 2)\n             (* product (modulo n\
    \ 2))))))\n", "  (check-type n integer)\n  (assert (> n 0))\n  (let loop ((n n)\n\
    \             (acc 1))\n    (cond ((= n 0)\n           acc)\n          ((even?\
    \ n)\n           (loop (/ n 2)\n                   (* acc (modulo n 10))))\n \
    \         (else\n           (loop (/ n 2)\n                   (* acc (modulo n\
    \ 10)))))\n    acc))\n", "  (let loop ((x n) (acc 1))\n    (cond ((= x 0) (if\
    \ (even? x) (* acc x) (* acc 0))))\n          ((even? (modulo x 10)) (loop (quotient\
    \ x 10) (* (quotient x 10) (* acc 1)))\n                                     \
    \   (loop (quotient x 10) (* (quotient x 10) (* acc 0)))\n                   \
    \                     (loop (quotient x 10) acc))\n          (else (loop (quotient\
    \ x 10) acc))))\n", "  (cond\n    [(zero? n) (exact->inexact 0)]\n    [(even?\
    \ n) (expt (- n (floor n)) 2)]\n    [else (expt n 3)]))\n", "  (cond [(= 0 (modulo\
    \ n 10)) 0]\n        [(= 0 (modulo n 10)) 0]\n        [else (* 10 (digits (remainder\
    \ n 10))) (* 10 (digits (remainder n 10)))]))\n", "  (cond\n    ((= n 0) 0)\n\
    \    ((odd? n) (* n (digits (remainder n 2))))\n    (else (digits (remainder n\
    \ 2)))))\n", "  (cond\n    ((= n 0) 0)\n    ((even? (remainder n 10)) (remainder\
    \ n 10))\n    (else (* n (digits (remainder n 10))))))\n", "  (let loop ((n n)\
    \ (c 1))\n    (if (zero? n)\n        c\n        (loop (quotient n 10) (c *(if\
    \ (odd? n) -1 1))))))\n", "  ; base case\n  (if (= n 0)\n      0\n      (* n (odd?\
    \ (- n 1)))))\n", "  (if (= n 0)\n      0\n      (let loop ((n n) (result 0))\n\
    \        (cond\n          (> (modulo n 10) 0)\n          ((even? (modulo n 10))\
    \ (loop (quotient n 10) (* (quotient n 10) result)))\n          (else (loop (quotient\
    \ n 10) result))))))\n", "  ;; We are working with integers, so we need to make\
    \ sure we don't run off the end of the number.\n  ;; If the number has digits,\
    \ we'll need to multiply them by 2.\n  (if (positive? n)\n      (if (= (digits\
    \ n) 0)\n          1\n          (* 2 (digits n)))\n      0))\n", "  (cond [(=\
    \ n 0) 0]\n        [(zero? (remainder n 10)) (remainder n 10)])\n        (else\
    \ (* n (digits (remainder n 10))))))\n", "  (cond [(> n 0) 1]\n        [(= n 0)\
    \ 0]\n        [else (* 0 (digits-odd n))]))\n", "  (cond [(= n 0) 1]\n       \
    \ [(even? (modulo n 10))\n         (even? (* 2 (digits (n/10))))]\n        [else\n\
    \         (* 2 (digits (n/10)))]))\n", "  (cond [(= n 0)\n         (* 2 0)]\n\
    \        [(even? n)\n         (* 2 (digits (rem n 10)))]\n        [(odd? n)\n\
    \         (* 2 n)]))\n", "  (cond [(zero? n) 0]\n        [(odd? n) (* (quotient\
    \ n 2) 3)]))\n", "  (let loop ((n n)\n             (s 1))\n    (if (zero? n)\n\
    \        (list s)\n        (let ((digit (quotient n 10)))\n          (loop (quotient\
    \ n 10)\n                (* s digit)))))) \n</cell>\n<cell>\n#lang racket", " \
    \ (cond\n    ((= n 0) 0)\n    ((even? n) 0)\n    (else (* n (digits (remainder\
    \ n 10))))))\n", "  (if (< n 0)\n      0\n      (+ (last (rest n)) (last (rest\
    \ n))))\n  )\n", "  (cond\n    ((< n 0) 0)\n    ((odd? n) (* (digit-odd n) (digit-odd\
    \ n)))\n    (else (digits n-1))))\n", '  (reverse (cons (* (modulo (+ n 1) 10)
    10) (remainder (+ n 1) 10))))', "  (if (= n 0)\n      0\n      (* n\n        \
    \ (digits (quotient n 10))))) ; n / 10\n</cell>\n<cell>", "  (* n (/ 10 n) (modulo\
    \ (modulo (/ 10 n) 2) 9)))\n", "  (cond [(= (modulo n 10) (= 0 (modulo n 10)))\n\
    \         (* 2 (digits (rem n 10)))]\n        [else\n         (* 10 (digits (rem\
    \ n 10)))]))\n", "  (local ([n n])\n    (if (even? n)\n        (* n n)\n     \
    \   (digits-odd? n)\n      )\n    )\n  )\n  ", "  (if (> n 0)\n      (* n (digits\
    \ (remainder n 10)))\n      0))\n", "  (cond [(= n 0) 0]\n        [(odd (digit-chars\
    \ n)) (* 2 (digits (remainder n)))]\n        [else (digits (remainder n))]))\n",
  "  (check-type n integer)\n  (check-positive n)\n  (let loop ((n n) (product 1)\
    \ (product 0))\n    (cond\n      [(= (mod n 10) 0)\n       (if (= (mod n 100)\
    \ 0)\n           (* product 2)\n           (* product 3))]\n      [(= (mod n 10)\
    \ 1)\n       (if (= (mod n 100) 0)\n           (* product 3)\n           (* product\
    \ 4))]\n      [(= (mod n 10) 2)\n       (if (= (mod n 100) 0)\n           (* product\
    \ 4)\n           (* product 5))]\n      [(= (mod n 10) 3)\n       (if (= (mod\
    \ n 100) 0)\n           (* product 5)\n           (* product 6))]\n      [(= (mod\
    \ n 10) 4)\n       (if (= (mod n 100) 0)\n           (* product 6)\n         \
    \  (* product 7))]]\n      (else (loop (sub1 n) (* product 2) product)))))\n</cell>\n\
    <cell>\n#lang racket\n", "  (cond [(= n 0) 0]\n        [(even? n) (* (/ n 2) (digits\
    \ (quotient n 2)))]\n        [else (* n (digits (quotient n 2)))]))\n", "  (if\
    \ (= n 0)\n      0\n      (* n (digits (remainder n 10))))) ;) ;; #lang racket\n",
  "  ;; This algorithm works by finding the greatest product of digits > n.\n  ;;\
    \ We start with the product of digits 0 through n.\n  (define p (* 10 n))\n  ;;\
    \ Loop over all digits starting with the greatest one.\n  (for ((i n))\n    ;;\
    \ Multiply current digit by previous greatest product.\n    (set! p (* p i)))\n\
    \  p)\n", "  (if (< n 0)\n      0\n      (even-product (quotient n 10))))\n",
  "  (cond\n    ((= n 0) 0)\n    ((odd? n) (* n (digits (remainder n 2))))\n    (else\
    \ (digits (quotient n 10)))\n  ))\n", "  (cond\n    [(zero? n) 1]\n    [(odd?\
    \ n) (* n (digits (rem n 2)))]))\n", "  (let loop ([n n]\n             [acc 0])\n\
    \    (cond\n      [(= n 0)\n       acc]\n      [(odd? (mod n 2))\n       (loop\
    \ (quotient n 2)\n             (* acc 2))]\n      [else\n       (loop (quotient\
    \ n 2)\n             (+ acc (odd? (mod n 2))))])))\n", "  (define (loop n n)\n\
    \    (if (< n 0)\n        n\n        (loop (quotient n 10) \n               (quotient\
    \ n 10 modulo 10))\n      n))\n  (loop n 0))\n", "  (cond\n    [(= n 0) 0]\n \
    \   [(= n 1) (floor (/ n 2))]\n    [else (+ 1 (* (digits (n-1)) (/ n 2)))]))\n",
  "  (let loop ((n n) (acc 1))\n    (cond [(= n 0) (if (even? acc) (- acc) (* n acc))]\n\
    \          [(odd? n) (loop (quotient n 2) (+ acc (modulo n 2)))]\n          [else\
    \ (loop (quotient n 10) (* acc 10))])))\n", "  (if (= n 0)\n      0\n      (even?\
    \ n (quotient n 2))))\n", "  (if (= n 0) 0\n      (* 1 (quotient n 10))))\n",
  "  (cond [(zero? n)\n         0]\n        [(zero? (remainder n 10))\n         0]\n\
    \        [(odd-digit? n)\n         (* 2 (digits (remainder n 10)))]))\n", "  (cond\
    \ [(= n 0) 0]\n        [else (* n (digits-odd (cdr n)))]))\n", "  (if (= n 0)\n\
    \      0\n      (* n (digits (rem n 2)))))\n", "  (if (= n 0)\n      0\n     \
    \ (* 10 (digits (n-1)))))\n", "  (cond\n    ((< n 10) 0)\n    ((= (modulo n 10)\
    \ 0) (* n (digits (rem n 10))))\n    (else (digits (rem n 10)))))\n", "  (if (=\
    \ n 0)\n      0\n      (* 2 (digits (n-1))))) ; recursive call\n", "  (cond [(=\
    \ n 0) 0]\n        [(zero? (modulo n 10)) (* 10 (digits (remainder n 10)))]\n\
    \        [else (* 10 (digit (quotient n 10))\n                   (digits (remainder\
    \ n 10)))]))\n", "  (if (zero? n)\n      0\n      (let ((result (* 2 (modulo (expt\
    \ n 2) 10))) (digits (quotient n 10)))\n        (if (null? (modulo result 10))\n\
    \            (* result 10)\n            result))))\n", "  (cond [(< n 10) (* n\
    \ n)]\n        [else (let ([result (digits (n/ 2))])\n                (+ result\
    \ (* n (remainder n 2)))\n                result)]))\n", "  (let loop ((n n) (d\
    \ 0))\n    (if (= n 0)\n        (/ 1 d)\n        (let ((d (* 10 d) (/ n 10)))\n\
    \          (if (= (modulo n 10) 0)\n              (loop (quotient n 10) d)\n \
    \             (loop (quotient n 10) d))))))\n", "  (if (zero? n) 0\n      (let\
    \ ((rem (modulo n 10)))\n        (if (even? rem) (rem * 2)\n            (if (odd?\
    \ rem) (rem * 10)\n                (rem * 1)\n              )\n            )\n\
    \        )\n      )\n  )\n", "  (cond [(= n 0) 0]\n        [(= (modulo n 10) 0)\
    \ (* n (digits (remainder n 10)))]\n        [else (* n (digits (remainder n 10)))]))\n",
  "  (if (= n 0)\n      0\n      (* 10 (digits (cdr n)))))\n", "  (if (= n 0)\n  \
    \    0\n      (* n (* (expt 10 n) (cdr n)))))\n", "  (let loop ((n n) (product\
    \ 1))\n    (cond [(< n 0)\n           0]\n          [else (loop (/ n 10) product)]))\n\
    \  product)\n", "  (if (even? n) (* n n) (* n n)))\n", "  (let loop ((n n))\n\
    \    (cond\n      [(= n 0) 0]\n      [(even? (remainder n 2)) (* n 2)\n      \
    \ (loop (quotient n 2))]\n      [(odd? (remainder n 2)) (loop (quotient n 2))]\n\
    \      [else (* n n)])))\n", "  (let loop ((n n))\n    (if (> n 0)\n        (let\
    \ ((rem (modulo n 10)))\n          (if (= rem 0)\n              (recur (sub1 n))\n\
    \              (loop (sub1 n))))\n        0)))\n", "  (if (= n 0)\n      0\n \
    \     (* 10 (digits (quotient n 10))))) ; #lang racket\n", "  (if (negative? n)\n\
    \      0\n      (even? (remainder n 10)))) ; even?\n</textarea></form>\n\n   \
    \ <script>\n      var editor = CodeMirror.fromTextArea(document.getElementById(\"\
    code\"), {\n        lineNumbers: true,\n        matchBrackets: true,\n       \
    \ theme: \"racket\"\n      });\n    </script>\n\n    <p><strong>MIME types defined:</strong>\
    \ <code>text/x-racket</code>.</p>\n  </article>\n\n<|/ file filename=index.html\
    \ ext=.html |>\n<| c |>\nI notice that if you type something into that textarea,\
    \ the cursor doesn't move on refresh (on Chrome at least). You can see what it\
    \ looks like by typing the word \"try\" in the textarea and then refreshing.\n\
    <|/ c |>\n<| c |>\nInteresting; it seems like a bug or at least strange behavior.\
    \ I'm using Chrome 32 on Linux, and after reloading the page the cursor stays\
    \ where it should be.\n<|/ c |>\n<| c |>\nAhhh ok thanks so much for confirming.\
    \ I guess I may just be on a different version of Chrome or something.\n<|/ c\
    \ |>\n<| c |>\nI tested on Firefox 29 and it works just like it should. I assume\
    \ Chrome should work as well.\n<|/ c |>\n<| c |>\n: This was a bug that was fixed\
    \ in Chrome 33. See this issue for details: https://code.google.com/p/chromium/issues/detail?id=339985\n\
    <|/ c |>\n<| a |>\nThe way I have seen this done is using a hidden field and set\
    \ its value to n.\n<code>\n<form action=\".\" method=\"post\">\n  <textarea name=\"\
    input\" rows=\"10\" cols=\"50\"></textarea>\n  <input type=\"hidden\" name=\"\
    n\" value=\"0\" />\n  <input type=\"submit\" value=\"Check\" />\n</form>\n</code>\n\
    Then all you have to do is to grab n from the request parameters.\n<code>", " \
    \ (if (= n 0)\n      0\n      (* n (digits ((quotient n 10) 2)))))\n", "  (if\
    \ (= n 0)\n      0\n      (* n\n         (* (remainder n 10)\n             (remainder\
    \ (quotient n 10) 10)))))\n", "  (let loop ([n n])\n    (cond\n      ((= n 0)\
    \ 0)\n      ((even? n) 1)\n      (else\n       (loop (sub1 n))))))\n", "  ;; Iterate\
    \ from n down to 1.\n  ;; Iterate n down to 1 because we want n odd digits first.\n\
    \  (define (odddigits n count)\n    (cond [(= count 1) n (odddigits n (sub1 count))])\n\
    \    (odddigits n (sub1 count)))\n\n  ;; Iterate from n down to 1.\n  (odddigits\
    \ n (sub1 n)))\n", "  (let loop ((n n))\n    (cond\n      ((= n 0) 0)\n      ((even?\
    \ (remainder n 10)) (remainder n (* 2 10)))\n      (else (loop (quotient n 10))))))\n",
  "  (cond\n    [(= n 0) 0]\n    [(even? n) (* 2 (digits (rem n 2)))]\n    [else (*\
    \ 2 (digits (rem n 2)) (digits (rem n 2)))]\n  ))\n", "  (if (= n 0) 0\n     \
    \ (* 2 (digits (remainder n 10))))) ;; #lang racket\n", "  (if (= n 0)\n     \
    \ 0\n      (* n ((digits (remainder n 10))))))\n", "  (if (even? n)\n      (*\
    \ n (digits (remainder n 10)))\n      (if (odd? n)\n          (* n 10)\n     \
    \     0)))\n", "  (define (digit-product n p)\n    (if (= p 0) n\n      (digit-product\
    \ (quotient n p) (sub1 p))))\n  (digit-product n n))\n", "  (let loop ((n n) (result\
    \ 1))\n    (cond [(< n 10) result]\n          [(even? n) (loop n (* result n))]\n\
    \          [else (loop (quotient n 10) result)])))\n", "  (if (zero? n) 0\n  \
    \    (* n (digits (quotient n 10))))))", "  (cond\n    [(< n 10) 0]\n    [else\
    \ (* n (digit (quotient n 10)))]))\n", "  (if (= n 0)\n      0\n      (/ n (modulo\
    \ (expt 2 n))))\n)\n", "  (let ([s (fold-right (*) 1 n)]\n        [d (take-odd-digits\
    \ s)])\n    (if (= n 0)\n        0\n        (* d 10))))\n", "  (if (positive?\
    \ n)\n      (* (mod n 10) 10)\n      0))\n", "  (cond [(= 0 (remainder n 10))\
    \ 0]\n        [(and (not (even? (remainder n 10)))\n               (odd? (remainder\
    \ n 10)))\n         (* 10 (digits (remainder n 10)))]\n        [else (digits (remainder\
    \ n 10))]))\n", "  (remainder (mod n 10) 2))\n", "  (cond\n    [(< n 0)\n    \
    \ 0]\n    [(= (modulo n 10) 0)\n     (* n n)]\n    [(even? (modulo n 10))\n  \
    \   (* n (digits (modulo n 10)))]\n    [else\n     (digits ((quotient n 10)))]))\n",
  "  (cond\n    [(= n 0) 0]\n    [(zero? (remainder n 10)) (remainder n 10)]\n   \
    \ [else (* 1 (remainder n 10))]))\n", "  (cond ((= n 0) 1)\n        ((even? (modulo\
    \ n 10)) (even? (modulo (modulo n 10) 10))\n         (* n (digits (remainder n\
    \ 10)))))\n        (else 0))\n</code>\n<|/ a dscore=3 tags=scheme,racket,algorithm\
    \ |>\n<| c |>\n: You're right. I've added some comments to the code.\n<|/ c |>\n\
    <| a dscore=2 |>\nOne way to do this is to rewrite (digits x) as (digits x) in\
    \ terms of multiplication, then use Euclid's algorithm to find the GCD of the\
    \ two numbers.  Then you just need to take the digits of that number and multiply\
    \ them together.\n<|/ a tags=scheme,racket,algorithm |>\n<| c |>\nThat sounds\
    \ easy; do you know how I'd go about doing that?\n<|/ c |>\n<| c |>\nJust use\
    \ Euclid's algorithm to find the GCD.  Then just use that GCD to find the digits\
    \ of your number.\n<|/ c |>\n<| c |>\nI'm sorry, but I'm new to Scheme and I'm\
    \ having trouble following what you're saying. Can you provide some more details?\n\
    <|/ c |>\n<| a dscore=2 |>\nHere's a very simple solution using Scheme and Racket\
    \ (I wrote this in Racket):\n<code>\n#lang racket", "  (if (= n 0)\n      0\n\
    \      (/ (* n (expt 2 (modulo n 10)) (expt 2 (modulo n 10)))\n        (expt 2\
    \ (modulo n 10))))))\n", "  (if (= n 0)\n      0\n      (let ((d (/ n 10)))\n\
    \        (if (even? d)\n            (* d (digits (remainder n 10)))\n        \
    \    (* d (digits (remainder n 10))))))))\n", "  (cond [(= n 0) 0]\n        [(=\
    \ (% n 10) 0) (/ n 10)]\n        [else (+ (/ n 10) (* (/ n 10) 10))]))\n", " \
    \ (if (even? n)\n      (even-digit n)\n      (odd-digit n)))\n", "  (if (= n 0)\n\
    \      0\n      (* n ((digits (remainder n 10)) 10))))\n", "  (cond ((= n 0) 0)\n\
    \        ((even? n) (* n (digits (rem n 2)))) \n        (else (* 1 (digits (rem\
    \ n 2))))))\n", "  (cond ((= n 0) 1)\n        (else (* 10 (digits (rem n 10)))))\n\
    )\n", "  (if (= n 0)\n      0\n      (* 3 (digits (remainder n 10))))) ; 3 because\
    \ n is odd\n</cell>\n<text>\nExercise 2 - Write a function that returns the sum\
    \ of the digits of its argument:\n\n\n</text>\n<code language=racket-lang>", " \
    \ (check-type n int)\n  (if (> n 0)\n      (let loop ((n n) (digits '()))\n  \
    \      (if (zero? (remainder n 10))\n            (loop (quotient n 10) (remainder\
    \ n 10))\n            (let ((tens (quotient n 10)))\n              (if (null?\
    \ digits)\n                  (set! digits '())\n                  (set! digits\
    \ (append (append digits tens) digits))\n                  (loop (quotient n 10)\
    \ (remainder n 10)))))\n            (append digits '(modulo n 10))))))\n", " \
    \ (cond\n    [(zero? n) 0]\n    [(even? (remainder n 10)) (remainder n 10)]\n\
    \    [else (* n (digits (remainder n 10)))]))\n", "  (if (odd? n)\n      (* n\
    \ (digits (rem n 2))) 0))\n", "  (cond\n    ((= n 0)  0)\n    ((< n 10)  n)\n\
    \    (else      (* n (digits (quotient n 10))))))\n", "  (cond ((= n 0) 0)\n \
    \       ((odd? (modulo n 10)) (* 10 (digits (cdr n))))\n        (else (* 10 (digits\
    \ (cdr n))))))\n", "  (let loop ((n n) (digits '()))\n    (cond [(< n 10)\n  \
    \         (cons n (digits '()))]\n          [(even? (cdr n)) (loop (cdr n) (cons\
    \ (car n) (digits '())))]\n          [else (loop (quotient n 10) (cdr n) (cons\
    \ (car n) (digits '())))]\n         )\n    ))\n", "  (if (= n 0)\n      0\n  \
    \    (* n (digits (remainder n 10)))))\n", "  (if (= n 0)\n      0\n      (* n\
    \ (digits (rem n 2)))))\n", "  (if (= n 0)\n      0\n      (* n (digits (quotient\
    \ n 10)))))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
