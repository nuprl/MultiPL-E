name: HumanEval_29_filter_by_prefix
language: rkt
prompt: "#lang racket\n\n;; Filter an input list of strings only for ones that start\
  \ with a given prefix.\n;; >>> (filter_by_prefix (list ) \"a\")\n;; (list )\n;;\
  \ >>> (filter_by_prefix (list \"abc\" \"bcd\" \"cde\" \"array\") \"a\")\n;; (list\
  \ \"abc\" \"array\")\n(define (filter_by_prefix strings prefix)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate filter_by_prefix))\n\
  \    (check-equal? (candidate (list ) \"john\") (list ))\n    (check-equal? (candidate\
  \ (list \"xxx\" \"asd\" \"xxy\" \"john doe\" \"xxxAAA\" \"xxx\") \"xxx\") (list\
  \ \"xxx\" \"xxxAAA\" \"xxx\"))\n))\n\n(test-humaneval)"
completions: ["  (if (null? strings) '()\n      (if (equal? prefix \"\") (strings)\n\
    \          (if (equal? (first strings) prefix)\n              (cons (first strings)\
    \ (filter_by_prefix (rest strings) prefix))\n              (cons (first strings)\n\
    \                    (filter_by_prefix (rest strings) (first strings))))))))\n",
  "  (cond [(empty? strings) strings]\n        [(not (list? (first strings))) strings]\n\
    \        [(prefix? (first strings)) (cons (first strings) (filter_by_prefix (rest\
    \ strings) prefix))]\n        [else (filter_by_prefix (rest strings) prefix)]))\n",
  "  (cond\n    [(empty? strings) '()]\n    [(equal? (first strings) prefix) (cons\
    \ prefix strings)]\n    [else (cons (first strings)\n              (filter_by_prefix\
    \ (rest strings) prefix))]))\n", "  (filter (lambda (str)\n            (string-match\
    \ prefix str)))\n  (strings))\n", "  (define (f s)\n    (string=? (string-ref\
    \ s 0) prefix))\n  (filter (lambda (s) (f s)) strings))\n", "  (filter (lambda\
    \ (s) (string-match-p prefix s)) strings))\n</code>\nAnd here's the string-match-p\
    \ function from the standard library:\n<code>\n#lang racket\n", "  (cond [(null?\
    \ strings) strings]\n        [(string-match prefix strings) (cons (string->string\
    \ strings)\n                                          (filter_by_prefix (rest\
    \ strings)\n                                                         prefix))]\n\
    \        [else (filter_by_prefix (rest strings) prefix)]))\n", "  (cond\n    [(empty?\
    \ strings) '()]\n    [(equal? (car strings) prefix) (cdr strings)]\n    [else\
    \ (cons (car strings)\n                (filter_by_prefix (cdr strings) prefix))]))\n",
  "  (if (null? strings)\n      (list)\n      (cons (substring (first strings) 0 (string-length\
    \ prefix)) \n            (filter_by_prefix (rest strings) prefix))))\n", "  (define\
    \ (helper l prefix)\n    (cond\n      [(empty? l) '()]\n      [(string=? (car\
    \ l) prefix) l]\n      [else (helper (cdr l) prefix)]\n    ))\n  (helper (cdr\
    \ strings) prefix))\n", "  (if (or (null? strings) (string-empty? prefix))\n \
    \     '()\n      (if (string-match prefix strings)\n          (append strings\
    \ (filter_by_prefix (cdr strings) prefix))\n          (string-append prefix (first\
    \ strings)))))\n", "  (if (null? strings)\n      '()\n      (if (= (first strings)\
    \ prefix)\n          (cons prefix strings)\n          (append (filter_by_prefix\
    \ (rest strings) prefix) strings))))\n", "  (cond (empty? strings)\n         '()\n\
    \       ((equal? (first strings) prefix)\n        (rest (filter_by_prefix (rest\
    \ strings) prefix)))\n       (else (cons (first strings)\n                   \
    \ (filter_by_prefix (rest strings) prefix))))))\n</code>\n<|/ a tags=scheme,racket,list\
    \ dscore=0 |>\n<| a tags=scheme,racket,list |>\n<code>", "  (cond\n    [(empty?\
    \ strings) strings]\n    [(eqv? (first strings) prefix) (cons (first strings)\
    \ strings)]\n    [else (filter_by_prefix (rest strings) prefix)]))\n", "  (filter\
    \ identity\n         (map (fn [s] (string->list\n                       (string->string\
    \ s\n                                (append (string->string prefix) (string->string\
    \ s))))\n              strings)))", "  (if (null? strings)\n      '()\n      (if\
    \ (equal? (car strings) prefix)\n          (strings strings)\n          (cons\
    \ (car strings)\n                (filter_by_prefix (cdr strings) prefix)))))\n",
  "  (filter (lambda (x) (string=? prefix x)) strings))\n", "  (let ((ls (filter strings-start-with\
    \ strings prefix)))\n    (map first (filter (not strings-start-with prefix) strings))))\n",
  "  (cond\n    [(empty? strings) empty]\n    [(empty? (first strings)) strings]\n\
    \    [(eqv? (first strings) prefix) (cons (first strings) strings)]\n    [else\
    \ (cons (first strings)\n               (filter_by_prefix (rest strings) prefix))]))\n",
  "  (cond\n    [(empty? strings) '()]\n    [(string-equal? (first strings) prefix)\
    \ (cons (first strings) (filter_by_prefix (rest strings) prefix))]\n    [else\
    \ (filter_by_prefix (rest strings) prefix)]))\n", "  (define (filter-helper strings\
    \ prefix acc)\n    (cond [(empty? strings) (list acc)]\n          [(equal? (first\
    \ strings) prefix) (filter-helper (rest strings) prefix acc)]\n          [else\
    \ (filter-helper (rest strings) prefix (cons (first strings) acc))]))\n  (filter-helper\
    \ strings prefix '()))\n", "  (map #(if (string-starts-with? % prefix) %)\n  \
    \     (filter (lambda (x) (string-prefix? x prefix)) strings))\n)\n", "  (if (null?\
    \ strings)\n      '()\n      (if (equal? (first strings) prefix)\n          (rest\
    \ strings)\n          (cons (first strings) (filter_by_prefix (rest strings) prefix)))))\n",
  "  (cond [(null? strings) '()]\n        [(string-ref strings 0)\n         (filter_by_prefix\
    \ (rest strings) prefix)]\n        [else (string-ref strings (string-length prefix)\n\
    \                            (filter_by_prefix (rest strings) prefix))]))\n",
  "  (map (\u03BB (s) (if (string-starts-with? s prefix) s \"\")) strings))\n", " \
    \ (cond\n    [(string-null? strings)\n     strings]\n    [(equal? (string-ref\
    \ strings 0) prefix)\n     strings]\n    [else\n     (append\n      (filter_by_prefix\
    \ (rest strings) prefix)\n      (cons (string-ref strings 0) (filter_by_prefix\
    \ (rest strings) prefix)))]))\n", "  (let loop ((remaining-strings strings)\n\
    \             (current-prefix (string-ref prefix 0))\n             (next-prefix\
    \ #f)\n             (filtered-strings #f)\n             (index 0))\n    (cond\n\
    \      [(empty? remaining-strings)\n       filtered-strings]\n      [(equal? current-prefix\
    \ (string-ref remaining-strings index))\n       (loop (rest remaining-strings)\n\
    \             (string-ref prefix index)\n             (not next-prefix)\n    \
    \         (cons current-prefix\n                  (loop (rest remaining-strings)\n\
    \                         (string-ref prefix index)\n                        \
    \ next-prefix\n                         (cons current-prefix\n               \
    \                (filter_by_prefix (rest remaining-strings)\n                \
    \                                prefix))))]\n      [else\n       (loop (rest\
    \ remaining-strings)\n             (string-ref prefix index)\n             (next-prefix)\n\
    \             (cons current-prefix\n                  (loop (rest remaining-strings)\n\
    \                         (string-ref prefix index)\n                        \
    \ next-prefix\n                         (cons current-prefix\n               \
    \                (filter_by_prefix (rest remaining-strings)\n                \
    \                                prefix))))])))", "  (if (null? strings)\n   \
    \   '()\n      (cons (string->symbol (substring prefix 0)) (filter_by_prefix (rest\
    \ strings) prefix))))\n", "  (cond [(empty? strings) strings]\n        [(equal?\
    \ (first strings) prefix) (cons (first strings) strings)]\n        [else (filter_by_prefix\
    \ (rest strings) prefix)]))\n", "  (define (fn str)\n    (cond (eq? str #\\A)\
    \ '()\n          (eq? str prefix) (list str)\n          (else (cons (car str)\
    \ (filter_by_prefix strings (cdr str))))))\n  (foldr (lambda (x y) (fn y) strings))\n\
    \  )\n", "  (cond [(null? strings) '()]\n        [(eqv? (car strings) prefix)\
    \ (cons (car strings) '())]\n        [(null? (cdr strings)) (cons (car strings)\
    \ '())]\n        [(eqv? (car strings) (prefix (cdr strings))) (cons (car strings)\
    \ '())]\n        [else (cons (car strings) (filter_by_prefix (cdr strings) prefix))]))\n",
  "  (filter (lambda (string) (string-match prefix string)) strings))\n", "  (let\
    \ loop ((strings strings)\n             (prefix-len string-length prefix))\n \
    \   (cond [(empty? strings) strings]\n          [(strings-starts-with? prefix\
    \ strings) strings]\n          [else\n           (loop (rest strings)\n      \
    \           (- prefix-len 1))])))\n", "  (if (null? strings)\n      '()\n    \
    \  (if (string? (car strings))\n          (if (string-starts-with (car strings)\
    \ prefix)\n              (cons (car strings) (filter_by_prefix (cdr strings) prefix))\n\
    \              (filter_by_prefix (cdr strings) prefix)))\n          (filter_by_prefix\
    \ (cdr strings) prefix))))\n", "  (cond ((null? strings) strings)\n        ((eq?\
    \ (car strings) prefix)\n         (filter_by_prefix (cdr strings) prefix))\n \
    \       (else (cons (car strings)\n                   (filter_by_prefix (cdr strings)\
    \ prefix))))) ;;#lang racket\n", "  (filter \n   (lambda (string)\n     (string-match\
    \ prefix string))\n   strings))\n", "  (cond [(empty? strings) '()]\n        [(string=?\
    \ (car strings) prefix) (cons (car strings) (filter_by_prefix (cdr strings) prefix))]\n\
    \        [else (filter_by_prefix (cdr strings) prefix)]))\n", "  (cond\n    [(empty?\
    \ strings) '()]\n    [(equal? (car strings) prefix) (cons (car strings) (filter_by_prefix\
    \ (cdr strings) prefix))]\n    [else (filter_by_prefix (cdr strings) prefix)]))\n",
  "  (cond [(empty? strings) '()]\n        [(starts-with-prefix? prefix (car strings))\n\
    \         (cons (car strings) (filter_by_prefix (cdr strings) prefix))]\n    \
    \    [else (filter_by_prefix (cdr strings) prefix)]\n        )\n      )\n", " \
    \ (cond\n    ((empty? strings) '())\n    ((string-match? prefix head 'exact)\n\
    \     (cons head (filter_by_prefix strings (cdr head))))\n    (else (cons head\
    \ (filter_by_prefix strings (cdr head)))))\n)\n", "  (cond [(empty? strings) (list\
    \ ())]\n        [(string? (first strings)) (cons (first strings) (filter_by_prefix\
    \ (rest strings) prefix))]\n        [else (filter_by_prefix (rest strings) prefix)]))\n",
  "  (if (null? strings)\n      (list)\n      (if (string->list (car strings))\n \
    \         (if (string-equal? (substring (substring (string->list prefix) 0) 1)\n\
    \                           (substring (string->list prefix) 1))\n           \
    \   (cons prefix (filter_by_prefix (cdr strings) prefix))\n              (cons\
    \ (car strings) (filter_by_prefix (cdr strings) prefix)))\n          (cons (car\
    \ strings) (filter_by_prefix (cdr strings) prefix))))))\n</cell>\n<code language=racket-jupyter>\n\
    #lang racket\n", "  (filter (lambda (x) (not (string prefix)))\n          strings))\n",
  "  (filter (lambda (x)\n           (string-match prefix x))\n          strings))\n",
  "  (cond\n    [(string-empty? strings) '()]\n    [(string-equal? prefix string)\
    \ (cons string strings)]\n    [else (cons (first strings)\n               (filter_by_prefix\
    \ (rest strings) prefix))]))\n", "  (filter (lambda (str)\n           (string=\
    \ (str prefix) prefix))\n         strings))", "  (cond [(empty? strings) '()]\n\
    \        [(equal? (first strings) prefix) (tail strings)]\n        [else (cons\
    \ (first strings) (filter_by_prefix (rest strings) prefix))]))\n", "  (remove-if-not\
    \ (lambda (str) (starts-with? str prefix))\n                 strings))\n", " \
    \ (cond [(empty? strings) empty]\n        [(not (eq? (first strings) prefix))\
    \ (cons (first strings) strings)]\n        [else (filter_by_prefix (rest strings)\
    \ prefix)]\n        ))\n", "  (cond\n    [(empty? strings) strings]\n    [(equal?\
    \ (first strings) prefix) (cons (first strings) strings)]\n    [else (filter_by_prefix\
    \ (rest strings) prefix)]\n    )\n  )\n", "  (filter (\u03BB (x) (string-prefix-p\
    \ prefix x))\n         strings))\n", "  (filter string? (take-while string=? prefix\
    \ strings)))\n", "  (if (empty? strings) '()\n      (if (equal? (first strings)\
    \ prefix)\n          (cons (first strings) (filter_by_prefix (rest strings) prefix))\n\
    \          (cons (first strings)\n                (filter_by_prefix (rest strings)\n\
    \                                 (append prefix (first strings)))))))\n", " \
    \ (cond [(empty? strings) empty]\n        [(string-equal prefix (first strings))\
    \ (cons (first strings) (rest strings))]\n        [else (filter_by_prefix (rest\
    \ strings) prefix)]))\n", "  (cond [(empty? strings) strings]\n        [(eq? (first\
    \ strings) prefix) (cons (first strings) strings)]\n        [else (filter_by_prefix\
    \ (rest strings) prefix)]))\n", "  (let loop ((strings strings)\n            \
    \ (prefix prefix))\n    (cond\n      ((null? strings) (strings))\n      ((string?\
    \ (first strings)) (strings))\n      ((eq? prefix (first strings)) (loop (rest\
    \ strings) prefix))\n      (else (loop (rest strings) prefix)))))\n</code>\n<|/\
    \ a tags=racket,scheme |>\n<| c |>\nNit: `strings` could also be a prefix of itself.\
    \ To deal with this case you might need to keep track of whether you found a match\
    \ or not, and either return `(strings)` when all strings have been found or return\
    \ the prefix if there are no more matches.\n<|/ c |>\n<| a dscore=1 |>\nHere is\
    \ a simple solution that uses string-intern to find a match of a string in a list\
    \ of strings.  It also uses a recursive function to find the next prefix of another\
    \ string. \n<code>", "  (cond\n    [(empty? strings) '()]\n    [(equal? (car strings)\
    \ prefix) (cons (car strings) '())]\n    [else (cons (car strings)\n         \
    \        (filter_by_prefix (cdr strings) prefix))]))\n", "  (cond [(null? strings)\
    \ strings]\n        [(string-beginning prefix strings) (filter_by_prefix (cdr\
    \ strings) prefix)]\n        [else (string-append strings (car strings))]))\n",
  "  (if (empty? strings)\n      '()\n      (if (eq? (first strings) prefix)\n   \
    \       (cons (first strings) (filter_by_prefix (rest strings) prefix))\n    \
    \      (cons (first strings) (filter_by_prefix (rest strings) prefix))))))\n",
  "  (map string->string\n       (filter (string=? (first strings) prefix))))\n",
  "  (filter \n   (lambda (x)\n     (string-starts-with? x prefix))\n   strings))\n",
  "  (if (null? strings) '()\n      (if (string->boolean (substring prefix 0 string->length)\
    \ false)\n          (cons (substring strings 0 string->length) \n            \
    \    (filter_by_prefix (substring strings string->length) prefix))\n         \
    \ (filter_by_prefix (substring strings string->length) prefix)))))", "  (cond\
    \ (null? strings) '()\n        (null? (car strings)) (cons prefix (car strings))\n\
    \        (string? (car strings)) (cons (car strings) (filter_by_prefix (cdr strings)\
    \ prefix))\n        (else (cons (car strings) (filter_by_prefix (cdr strings)\
    \ prefix))))))\n", "  (filter strings? (string->list prefix)))\n  ", "  (cond\
    \ [(empty? strings) strings]\n        [(starts-with? prefix (first strings)) (rest\
    \ strings)]\n        [else (cons (first strings) (filter_by_prefix (rest strings)\
    \ prefix))]))\n", "  (define (matcher str p)\n    (and (eq? p (string-tail str))\n\
    \         (eq? p (string-prefix str))))\n  (remove-if-not (lambda (str) (matcher\
    \ str prefix)) strings))\n", "  (cond [(null? strings) '()]\n        [(eq? (first\
    \ strings) prefix) (cons (first strings) (filter_by_prefix (rest strings) prefix))]\n\
    \        [else (filter_by_prefix (rest strings) prefix)])\n  )\n", "  (filter\
    \ \n   (lambda (s) (string-match s \"^\" prefix))\n   strings))\n", "  (if (null?\
    \ strings)\n      strings\n      (cond ((equal? prefix (car strings))\n      \
    \       (filter_by_prefix (cdr strings) prefix))\n            ((null? (car strings))\n\
    \             strings)\n            (else\n             (cons (car strings)\n\
    \                   (filter_by_prefix (cdr strings) prefix))))))\n", "  (if (null?\
    \ strings) strings)\n  (if (string-starts? prefix strings)\n      (cons (substring\
    \ strings 0 (string-length prefix)) (filter_by_prefix (rest strings) prefix))\n\
    \      (filter_by_prefix (rest strings) prefix)))\n", "  (map #(if (string-starts?\
    \ prefix %)\n            %\n            %))\n        strings ))\n</code>\n<|/\
    \ a tags=racket |>\n<| c |>\nThis works great! I just added it to the top of my\
    \ `filter_by_prefix` definition so I can call it whenever I want. Thanks!\n<|/\
    \ c |>\n<| c |>\nYou could also make it a `filter` procedure if you wanted to.\n\
    <|/ c |>\n<| a dscore=3 |>\nA variation of the first answer, using a fold. First\
    \ of all, you need to define a helper function \"filter\" that takes a list and\
    \ applies a predicate to each element in the list:\n<code>", "  (cond [(or (empty?\
    \ strings) (null? prefix)) strings]\n        [(eq? prefix (first strings)) (cons\
    \ prefix strings)]\n        [else (filter_by_prefix (rest strings) prefix)]\n\
    ))\n", "  (if (null? strings) nil\n      (if (eq? (car strings) prefix)\n    \
    \      (cons (car strings)\n                (filter_by_prefix (cdr strings) prefix))\n\
    \          (filter_by_prefix (cdr strings) prefix))))\n", "  (cond (empty? strings)\
    \ empty\n        (string? (first strings))\n        (strings-starts-with strings\
    \ prefix)\n        (else (filter_by_prefix (rest strings) prefix))\n      )\n\
    \  )\n", "  (cond\n    ((null? strings) '())\n    ((= (string-ref strings 0) prefix)\
    \ (strings))\n    (else (cons (string-ref strings 0)\n               (filter_by_prefix\
    \ (rest strings) prefix)))))\n", "  (remove-if\n   (lambda (x) (not (equal? (substring\
    \ x 0) prefix)))\n   strings))\n", "  (let loop ((strings strings)\n         \
    \    (prefix prefix))\n    (cond [(empty? strings) (list prefix)]\n          [(char=?\
    \ (first strings) prefix) (loop (rest strings) prefix)]\n          [else (cons\
    \ (first strings) (loop (rest strings) prefix))]))))\n", "  (if (empty? strings)\
    \ '()\n      (if (equal? (first strings) prefix)\n          (cons (first strings)\
    \ (filter_by_prefix (rest strings) prefix))\n          (cons (first strings) (filter_by_prefix\
    \ (rest strings) prefix)))))\n", "  (filter (lambda (s)\n            (string=?\
    \ s prefix))\n          strings))\n", "  (cond\n    [(empty? strings) strings]\n\
    \    [(equal? (first strings) prefix) strings]\n    [else (cons (first strings)\n\
    \               (filter_by_prefix (rest strings) prefix))]))\n", "  (filter #(equal?\
    \ (string %) prefix)\n          strings))", "  (define (match-string string prefix)\n\
    \    (string=? string prefix))\n  (filter match-string strings))\n", "  (cond\n\
    \    ((null? strings) '())\n    ((eq? prefix (car strings))\n     (cons (car strings)\
    \ (filter_by_prefix (cdr strings) prefix)))\n    ((not (eq? prefix (car strings))\n\
    \           (filter_by_prefix (cdr strings) prefix)))\n    (else (filter_by_prefix\
    \ (cdr strings) prefix))))\n</code>\n<|/ a tags=racket,scheme |>\n<| a tags=racket,scheme\
    \ dscore=1 |>\nJust in case someone wants to do this using recursion without using\
    \ fold-right or foldr, here's a solution:\n<code>\n#lang racket\n", "  (if (empty?\
    \ strings)\n      strings\n      (if (string-prefix? (car strings) prefix)\n \
    \         (cons (car strings) (filter_by_prefix (cdr strings) prefix))\n     \
    \     (filter_by_prefix (cdr strings) prefix))))\n", "  (cond [(empty? strings)\
    \ strings]\n        [(symbol=? (first strings) prefix) (filter_by_prefix (rest\
    \ strings) prefix)]\n        [else (string-append (first strings) (filter_by_prefix\
    \ (rest strings) prefix))]))\n", "  (for/fold ((string '()))\n            ((prefix\
    \ '()))\n            (let ([strings (cons string strings)])\n              (when\
    \ (strings-prefix prefix strings)\n                (return strings))))\n  (for/fold\
    \ ((prefix '()))\n            (strings strings)\n            (let ([prefix (cons\
    \ prefix prefix)])\n              (when (strings-prefix prefix strings)\n    \
    \            (return (cons string prefix)))))\n  (for/fold ((prefix '()))\n  \
    \          (strings strings)\n            (let ([prefix (cons prefix prefix)])\n\
    \              (when (strings-prefix prefix strings)\n                (return\
    \ (cons string prefix))))))\n", "  (cond [(empty? strings) strings]\n        [(eq?\
    \ (first strings) prefix) strings]\n        [else (cons (first strings)\n    \
    \                (filter_by_prefix (rest strings) prefix))]))\n", "  (cond\n \
    \   [(empty? strings) '()]\n    [(eq? (first strings) prefix) (cons (first strings)\
    \ (filter_by_prefix (rest strings) prefix))]\n    [(< (length prefix) 1) (cons\
    \ (first strings) (filter_by_prefix (rest strings) prefix))]\n    [else (filter_by_prefix\
    \ (rest strings) prefix)])\n  )\n", "  (if (null? strings)\n      '()\n      (if\
    \ (equal? prefix (car strings))\n          (filter_by_prefix (cdr strings) prefix)\n\
    \          (cons (car strings) (filter_by_prefix (cdr strings) prefix)))))\n",
  "  (cond [(empty? strings) '()]\n        [(equal? (first strings) prefix) (cons\
    \ (first strings) (rest strings))]\n        [else (filter_by_prefix (rest strings)\
    \ prefix)]))\n", "  (cond\n    ((null? strings) '())\n    ((= 0 (string-length\
    \ prefix)) (append strings '()))\n    ((string= prefix (string-ref strings (string-length\
    \ prefix))) (filter_by_prefix strings (substring prefix 0 (string-length prefix)))\n\
    \    (else (filter_by_prefix (rest strings) prefix))))\n", "  (cond\n    ((null?\
    \ strings) '())\n    ((string-match prefix string) (string-match prefix string))\n\
    \    (else (string-match prefix string) (filter_by_prefix strings (cdr string))))))\n",
  "  (cond\n    [(string? (first strings)) (cons (first strings) (filter_by_prefix\
    \ (rest strings) prefix))]\n    [else (filter_by_prefix (rest strings) prefix)]))",
  "  (if (null? strings)\n      nil\n      (if (string-match prefix strings)\n   \
    \       (cons strings (filter_by_prefix (cdr strings) prefix))\n          (cons\
    \ (car strings) (filter_by_prefix (cdr strings) prefix)))))\n", "  (let loop ((strings\
    \ strings)\n             (prefix prefix))\n    (cond [(empty? strings) '()]\n\
    \          [(equal? (first strings) prefix) (loop (rest strings) prefix)]\n  \
    \        [else (cons (first strings)\n                       (loop (rest strings)\n\
    \                            (cons prefix (first strings))))]))))\n", "  (if (empty?\
    \ strings)\n      '()\n      (if (string-starts-with? prefix strings)\n      \
    \    (reverse strings)\n          (string-append (substring prefix 0) strings))))\n",
  "  (let ([i 0])\n    (define (loop i)\n      (cond ((null? strings) (list '()))\n\
    \            ((string=? (string-ref strings i) prefix) (loop (+ i 1)))\n     \
    \       (else (loop (+ i 1)))))\n    (loop i)))\n", "  (if (empty? strings) '()\n\
    \      (if (string=? prefix (car strings))\n          (recur strings)\n      \
    \    (cons (car strings)\n                (filter_by_prefix (cdr strings) prefix)))))\n",
  "  (cond (empty? strings) empty\n        (= 0 (string-length prefix))\n        (string-starts-with\
    \ (car strings) prefix) \n        (filter_by_prefix (cdr strings) prefix)))\n",
  "  (cond [(or (empty? strings) (null? prefix)) strings]\n        [(equal? (car prefix)\
    \ (car strings)) (filter_by_prefix (cdr strings) prefix)]\n        [else (cons\
    \ (car strings) (filter_by_prefix (cdr strings) prefix))]))\n", "  (if (null?\
    \ strings) '()\n      (cond [(string? (first strings))\n             (cond\n \
    \             [(string=? (first strings) prefix)\n               (cons (first\
    \ strings)\n                     (filter_by_prefix (rest strings) prefix))]\n\
    \              [else\n               (filter_by_prefix (rest strings) prefix)]\n\
    \              )]))))\n", "  (if (empty? strings)\n      ()\n      (cons (first\
    \ strings)\n            (filter_by_prefix (rest strings)\n                   \
    \          prefix))))\n", "  (cond [(empty? strings) '()]\n        [(eq? (first\
    \ strings) prefix) strings]\n        [else (cons (first strings) (filter_by_prefix\
    \ (rest strings) prefix))]))\n</code>\n<|/ a dscore=1 tags=racket,scheme |>\n\
    <| c |>\nThanks a lot. I am a beginner so i am not familiar with cond. So i will\
    \ try to read it up and understand it. Thanks a lot for your help\n<|/ c |>\n\
    <| a dscore=1 |>\nI see there are already great answers posted here and I have\
    \ just thought of another way to do this using a fold.\n<code>", "  (let loop\
    \ ((idx 0) (list '()))\n    (if (null? strings)\n        list\n      (if (string-starts-with?\
    \ strings prefix)\n          (loop (+ idx 1) (cons (car strings) list))\n    \
    \      (loop (+ idx 1) (cons (car strings) list)))))\n  (loop (length strings)\
    \ '()))\n", "  (cond [(empty? strings) strings]\n        [else (cons (caar strings)\n\
    \                   (filter_by_prefix (cdr strings)\n                        \
    \            prefix))]))\n", "  (cond [(empty? strings) empty]\n        [(equal?\
    \ (first strings) prefix) (cons (first strings) strings)]\n        [else (cons\
    \ (first strings)\n                    (filter_by_prefix (rest strings) prefix))]))\n",
  "  (filter (lambda (s)\n            (string=? (string-ref s 0) prefix))\n      \
    \    strings))\n", "  (let loop ((i 0) (strings strings) (prefix prefix) (result\
    \ '()))\n    (cond\n      [(empty? strings) result]\n      [else (cond\n     \
    \        [(= i (length prefix)) result]\n             [else (loop (+ i 1) (tail\
    \ strings) prefix (cons (car strings) result))])]\n     )))\n", "  (define (match-prefix\
    \ s prefix)\n    (string=? prefix s))\n  (filter (lambda (s)\n            (match\
    \ s prefix [true '()] ([false s; false]))) strings))\n", "  (cond\n    [(string?\
    \ (car strings)) (cons (car strings)\n                               (filter_by_prefix\
    \ (cdr strings) prefix))]\n    [(string? (cdr strings)) (filter_by_prefix (car\
    \ strings) prefix)]\n    [(and (string? prefix) (equal? (car strings) prefix))\
    \ (cons (car strings)\n                                                      \
    \              (filter_by_prefix (cdr strings) prefix))]\n    [else (filter_by_prefix\
    \ (cdr strings) prefix)])\n  )\n", "  (if (empty? strings)\n      empty\n    \
    \  (if (equal? (first strings) prefix)\n          (cons (first strings) (filter_by_prefix\
    \ (rest strings) prefix))\n          (filter_by_prefix (rest strings) prefix))))\n",
  "  (if (empty? strings) '()\n      (cons (substring (first strings) 0 prefix) (filter_by_prefix\
    \ (rest strings) prefix))))\n", "  (if (null? strings)\n      '()\n      (if (string-starts-with?\
    \ prefix (car strings))\n          (recur (cdr strings) prefix)\n          (cons\
    \ (car strings) (filter_by_prefix (cdr strings) prefix)))))\n", "  (cond [(empty?\
    \ strings) empty]\n        [(equal? (first strings) prefix) (list strings)]\n\
    \        [else (append (filter_by_prefix (rest strings) prefix) (list strings)])\n\
    \        ))\n", "  (filter (lambda (item)\n            (string= (substring item\
    \ 0) prefix))\n          strings))\n", "  (map (\u03BB (x) (when (eqv? prefix\
    \ x) x)) strings))\n", "  (cond [(empty? strings) strings]\n        [(equal? (first\
    \ strings) prefix) (filter_by_prefix (rest strings) prefix)]\n        [else (cons\
    \ (first strings)\n                    (filter_by_prefix (rest strings) prefix))]))\n",
  "  (cond\n    [(empty? strings) (list)] \n    [(not (starts-with? prefix strings))\
    \ (cons strings (filter_by_prefix (rest strings) prefix))]))\n", "  (filter (lambda\
    \ (str)\n            (string=? (substring str 0) prefix))\n          strings))\n\
    </cell>\n<code language=racket-transformer>", "  (cond [(empty? strings) empty]\n\
    \        [(starts-with prefix strings) (cons prefix strings)]\n        [else (filter_by_prefix\
    \ (rest strings) prefix)]))\n", "  (if (null? strings) strings\n      (let loop\
    \ ((strings (reverse strings)) (prefix (reverse prefix)))\n        (cond\n   \
    \       ((null? prefix) (strings strings))\n          ((string-match prefix strings)\
    \ (strings strings))\n          (else (loop (rest strings) (string-match (rest\
    \ prefix) (rest strings)))))))\n</code>\nThis code is far more efficient than\
    \ using string-match:\n<code>", "  (cond [(empty? strings) (list empty)]\n   \
    \     [(equal? prefix (first strings)) (cons (first strings) empty)]\n       \
    \ [else (cons (first strings)\n                   (filter_by_prefix (rest strings)\
    \ prefix))]))\n", "  (cond\n    ((null? strings) strings)\n    ((string-eq? (string-ref\
    \ strings 0) prefix) (cons (string-ref strings 0) strings))\n    (else (filter_by_prefix\
    \ (cdr strings) prefix))))\n", "  (cond [(empty? strings) strings]\n        [(not\
    \ (empty? (first strings))) strings]\n        [(equal prefix (first strings))\
    \ (filter_by_prefix (rest strings) prefix)]\n        [else (cons (first strings)\n\
    \                  (filter_by_prefix (rest strings) prefix))]))\n", "  (filter\
    \ (lambda (s)\n            (string=? (prefix s) (string-trim s)))\n          strings))\n",
  "  (filter #(and (char-string-start %) (string-equal? % prefix))\n          strings))\n",
  "  (cond [(empty? strings) '()]\n        [(eq? (first strings) prefix) (filter_by_prefix\
    \ (rest strings) prefix)]\n        [else (cons (first strings) (filter_by_prefix\
    \ (rest strings) prefix))]))\n", "  (filter strings-starts-with prefix))\n", " \
    \ (let loop ((acc '()) (strings strings))\n    (cond\n      [(empty? strings)\
    \ acc]\n      [else (loop (cons (first strings) acc) (drop 1 strings))]))\n</code>\n\
    <|/ a tags=scheme dscore=2 |>\n<| a |>\nIf you want a recursive function, you\
    \ can use this:\n<code>", "  (cond\n    ((null? strings) strings)\n    ((list?\
    \ (first strings)) (cons (first strings)\n                                 (filter_by_prefix\
    \ (rest strings) prefix)))\n    ((string=? (first strings) prefix) (cons (first\
    \ strings)\n                                          (filter_by_prefix (rest\
    \ strings) prefix)))\n    (else (filter_by_prefix (rest strings) prefix))))\n",
  "  (cond ((null? strings) '())\n        ((equal? (car strings) prefix) (filter_by_prefix\
    \ (cdr strings) prefix))\n        (else (cons (car strings)\n                \
    \    (filter_by_prefix (cdr strings) prefix))))))\n", "  (map string->boolean\
    \ (filter (lambda (s) (string->boolean (string-match prefix s)) strings))))\n",
  "  (if (null? strings)\n      strings\n      (if (string=? prefix car strings)\n\
    \          (filter_by_prefix (cdr strings) prefix)\n          (cons (car strings)\
    \ (filter_by_prefix (cdr strings) prefix)))))\n", "  (for/list ((s strings))\n\
    \    (when (string=? prefix s)\n      (if (string=? prefix (substring s 0 (string-length\
    \ prefix)))\n          (cons s empty)\n          (cons s strings)))))\n", "  (let\
    \ loop ((strings strings)\n             (prefix prefix))\n    (cond\n      [(empty?\
    \ strings) (strings prefix)]\n      [(equal? (first strings) prefix) (loop (rest\
    \ strings) prefix)]\n      [else (cons (first strings) (loop rest prefix))]))))\n",
  "  (filter string? (lambda (s) (equal? s prefix))))\n", "  (cond [(empty? strings)\
    \ strings]\n        [(= (length prefix) 0)\n         (empty? strings)\n      \
    \   strings]\n        [else\n         (let ((string (sub1 (first strings))))\n\
    \           (filter_by_prefix (rest strings) (sub1 prefix))\n           (cons\
    \ (cons string strings) strings)]\n        ))\n", "  (cond\n    [(empty? strings)\
    \ strings]\n    [(equal? (first strings) prefix) (filter_by_prefix (rest strings)\
    \ prefix)]\n    [else (cons (first strings)\n               (filter_by_prefix\
    \ (rest strings) prefix))]))\n", "  (cond [(empty? strings) strings]\n       \
    \ [(equal? (first strings) prefix) (cons (first strings) strings)]\n        [else\
    \ (filter_by_prefix (rest strings) prefix)]))\n", "  (cond\n    [(empty? strings)\
    \ '()]\n    [(string? (car strings)) (cons (car strings) (filter_by_prefix (cdr\
    \ strings) prefix))]\n    [else (filter_by_prefix (cdr strings) prefix)]))\n",
  "  (let loop ((strings strings)\n             (prefix prefix))\n    (cond\n    \
    \  [(null? strings) (string->list prefix)]\n      [(string=? (first strings) prefix)\
    \ (loop (rest strings) prefix)]\n      [else (cons \n               (first strings)\n\
    \               (loop (rest strings) \n                     (first prefix)\n \
    \                    (rest prefix)))])))\n", "  (cond\n    [(string-equal? prefix\
    \ \"\") strings]\n    [(string-equal? (substring prefix 0) \"\") strings]\n  \
    \  [(empty? strings) '()]\n    [else (cons (first strings) (filter_by_prefix (rest\
    \ strings) prefix))]))\n", "  (cond [(empty? strings) strings]\n        [else\
    \ (let ([head (car strings)])\n                (cond [(string-prefix? head prefix)\
    \ \n                        (filter_by_prefix (cdr strings) prefix)]\n       \
    \                 [else (strings head)]))]))\n", "  (let ((l (length (strings)))\n\
    \        (lprefix (string-length prefix)))\n    (cond ((or (= l lprefix)\n   \
    \            (null? strings))\n           strings)\n          ((char=? (car strings)\
    \ prefix)\n           (filter_by_prefix (cdr strings) prefix))\n          (t (filter_by_prefix\
    \ (cdr strings) prefix)\n             (append prefix (list (car strings)))))))\n",
  "  (filter (lambda (substring) (string-prefix-p prefix substring))\n          strings))\n",
  "  (filter strings-starts-with prefix (reverse strings)))\n", "  (cond\n    [(empty?\
    \ strings) (list '())]\n    [(eq? (first strings) prefix) (cons (first strings)\
    \ strings)]\n    [(cons? strings)\n     (cond (prefix? (first strings)) (filter_by_prefix\
    \ (rest strings) prefix))\n           (else (filter_by_prefix (rest strings) prefix))]))\n",
  "  (let loop ((found (list)) (strings strings)\n             (prefix prefix))\n\
    \    (if (empty? strings)\n        (reverse found)\n        (loop (cons (car strings)\n\
    \                    (if (string-prefix? prefix prefix)\n                    \
    \    (loop (cons (car strings) found) (cdr strings)\n                        \
    \       (cdr prefix))\n                        found))\n              (cdr strings)\n\
    \              prefix))))\n", "  (if (empty? strings)\n      nil\n      (if (string-match?\
    \ (car strings) prefix)\n          (cons (car strings) (filter_by_prefix (cdr\
    \ strings) prefix))\n          (filter_by_prefix (cdr strings) prefix))))\n",
  "  (filter (lambda (x) (string-match prefix x)) strings))\n", "  (cond\n    [(string?\
    \ (car strings)) (cons (car strings) (filter_by_prefix (cdr strings) prefix))]\n\
    \    [(prefix? (car strings)) (cons (car strings) (filter_by_prefix (cdr strings)\
    \ prefix))]\n    [else (filter_by_prefix (cdr strings) prefix)]))\n", "  (cond\
    \ [(empty? strings) strings]\n        [(starts-with? (car strings) prefix) \n\
    \         (filter_by_prefix (cdr strings) prefix)]\n        [else (cons (car strings)\
    \ (filter_by_prefix (cdr strings) prefix))]))\n</code>\n<|/ a dscore=0 |>\n<|\
    \ a dscore=0 |>\n<code>", "  (cond\n    ((empty? strings) '())\n    ((equal? (car\
    \ strings) prefix) (filter_by_prefix (cdr strings) prefix))\n    (else (cons (car\
    \ strings) (filter_by_prefix (cdr strings) prefix))))\n  )\n", "  (if (null? strings)\n\
    \      '()\n      (cond [(equal? (car strings) prefix) (cons (car strings) (rest\
    \ strings))]\n            [else (cons (car strings) (filter_by_prefix (cdr strings)\
    \ prefix))]))\n</code>\n<|/ a tags=racket,scheme |>\n<| a tags=racket,scheme |>\n\
    I think what you need is recursion.\n<code>", "  (cond\n    [(empty? strings)\
    \ empty]\n    [(string-prefix? prefix string) (cons prefix strings)]\n    [else\
    \ (cons string strings)]))\n", "  (if (null? strings)\n      '()\n      (cons\
    \ (first strings)\n            (filter_by_prefix (rest strings) prefix)))))\n",
  "  (define (loop strings prefix acc)\n    (cond [(empty? strings) (cons (reverse\
    \ acc) empty)]\n          [(eqv? prefix (first strings)) (loop (rest strings)\
    \ prefix (cons (first strings) acc))]\n          [else (loop (rest strings) prefix\
    \ (cons (first strings) acc))]))\n  (loop strings prefix empty))\n", "  (cond\n\
    \    [(empty? strings) strings]\n    [else (cons (string->string (rest (first\
    \ strings)) (filter_by_prefix (rest strings) prefix)) (filter_by_prefix (rest\
    \ strings) prefix))]\n  ))\n", "  (cond (empty? strings) (strings)\n        (string?\
    \ (first strings))\n        (string-equal? (first strings) prefix) (filter_by_prefix\
    \ (rest strings) prefix)\n        :else (cons (first strings) (filter_by_prefix\
    \ (rest strings) prefix))))\n", "  (cond\n    [(empty? strings) '()]\n    [(eq?\
    \ (first strings) prefix) (tail strings)]\n    [else (cons (first strings)\n \
    \               (filter_by_prefix (rest strings) prefix))]))", "  (cond\n    [(string-null\
    \ strings) '()]\n    [(or (string-eq prefix (string-ref (string-first strings)\
    \ 0))\n          (string-eq prefix (string-ref (string-first strings) 1)))\n \
    \    strings]\n    [else (filter_by_prefix (subseq strings 0 (string-length prefix))\n\
    \                          (append prefix (string-first strings)))))\n", "  (if\
    \ (null? strings)\n      '()\n      (cond [(equal? (first strings) prefix) strings]\n\
    \            [else (cons (first strings)\n                       (filter_by_prefix\
    \ (rest strings)\n                                       prefix))]))\n", "  (cond\
    \ [(empty? strings) strings]\n        [(string? (car strings)) (cons (car strings)\
    \ (filter_by_prefix (cdr strings) prefix))]\n        [(prefix? (car strings) prefix)\
    \ (cons (car strings) (filter_by_prefix (cdr strings) prefix))]\n        [else\
    \ (cons (car strings) (filter_by_prefix (cdr strings) prefix))]))\n", "  (cond\
    \ [(empty? strings) '()]\n        [(eq? (first strings) prefix) (cons strings\
    \ (filter_by_prefix (rest strings) prefix))]\n        [else (cons (first strings)\
    \ (filter_by_prefix (rest strings) prefix))]))\n", "  (define (loop idx result)\n\
    \    (cond\n      [(zero? idx) result]\n      [else (loop (add1 idx) (cons (sub1\
    \ (string-length prefix)) result))]\n      ))\n  (loop 0 (list prefix)))\n", " \
    \ (cond\n    [(empty? strings) strings]\n    [(equal? (car strings) prefix) (cons\
    \ (car strings) (filter_by_prefix (cdr strings) prefix))]\n    [else (filter_by_prefix\
    \ (cdr strings) prefix)]))\n", "  (filter #(= (substring % 0 prefix) %)\n    \
    \      strings))\n", "  (if (null? strings) '()\n      (if (or (string-match prefix\
    \ string) (null? prefix))\n          (cons strings ) \n          (cons (car strings)\
    \ (filter_by_prefix (cdr strings) prefix)))))\n", "  (if (empty? strings)\n  \
    \    (list prefix)\n      (cons (substring (car strings) 0 (string-length prefix))\n\
    \            (filter_by_prefix (cdr strings) prefix))))\n", "  (cond\n    ((null?\
    \ strings) strings)\n    ((memstart? prefix strings) strings)\n    ((string-prefix?\
    \ prefix string) (string-substring strings 0 (string->length (string-append prefix\
    \ string)))))\n)\n", "  (let loop ((result '())\n             (strings (reverse\
    \ strings))\n             (prefix (reverse prefix)))\n    (cond ((null? strings)\
    \ result)\n          ((null? (cdr strings)) result)\n          ((eq? prefix (car\
    \ strings)) (loop (cons (car strings) result) (cdr strings) prefix))\n       \
    \   (else (loop (cons (car strings) result) (cons (cdr strings) strings) prefix))))\n\
    \  result)\n", "  (cond\n    [(string-null? strings) strings]\n    [(equal? prefix\
    \ (substring (string-ref strings 0)) strings)\n     (substring strings 1)]\n \
    \   [else\n     (filter_by_prefix (substring strings 1) prefix)]))\n", "  (cond\
    \ [(empty? strings) strings]\n        [(equal? (first strings) prefix) (drop 1\
    \ strings)]\n        [else (cons (first strings)\n                    (filter_by_prefix\
    \ (rest strings)\n                                    prefix))]))\n", "  (filter\
    \ (lambda (x) (memq x prefix)) strings))\n", "  (filter (lambda (s) (starts-with\
    \ s prefix)) strings))\n", "  (if (empty? strings) '()\n      (if (string-prefix?\
    \ prefix string)\n          (cons (string string) (filter_by_prefix (rest strings)\
    \ prefix))\n          (filter_by_prefix (rest strings) prefix))))\n", "  (cond\
    \ [(empty? strings) empty]\n        [(equal? (first strings) prefix) (cons (first\
    \ strings) strings)]\n        [else (cons (first strings)\n                  \
    \  (filter_by_prefix (rest strings)\n                                     prefix))]))\n",
  "  (cond\n    [(empty? strings) strings]\n    [(string-match? prefix string) strings]\n\
    \    [else (cons (car strings)\n                (filter_by_prefix (cdr strings)\
    \ prefix))]))", '  (filter (lambda (x) (starts-with x prefix)) strings))', " \
    \ (cond\n    [(empty? strings) (strings)] \n    [(eq? prefix (first strings))\n\
    \     (cons (first strings) (strings))]\n    [else\n     (filter_by_prefix (rest\
    \ strings) prefix)]))\n", "  (filter (lambda (str)\n            (string-starts-with?\
    \ str prefix))\n          strings))", "  (cond [(empty? strings) empty]\n    \
    \    [(equal? (first strings) prefix) (tail strings)]\n        [(starts-with?\
    \ prefix strings) (filter_by_prefix (rest strings) prefix)]\n        [else (strings\
    \ prefix)])\n)\n", "  (cond [(empty? strings) empty]\n        [(empty? (first\
    \ strings)) (cons prefix strings)]\n        [(equal? (first strings) prefix) (cons\
    \ (first strings) strings)]\n        [else (cons (first strings)\n           \
    \         (filter_by_prefix (rest strings)\n                                 \
    \   prefix))]))\n", "  (cond [(empty? strings) '()]\n        [(not (equal? (first\
    \ strings) prefix)) (strings prefix)]\n        [else (append (filter_by_prefix\
    \ (rest strings) prefix) (strings prefix))]))\n", "  (if (empty? strings) '()\n\
    \      (if (string=? prefix head) \n          (cons head strings)\n          (filter_by_prefix\
    \ (rest strings) prefix))\n      )\n  )\n", "  (cond [(empty? strings) strings]\n\
    \        [(not (eq? (car strings) prefix)) strings]\n        [else (cons (car\
    \ strings)\n                   (filter_by_prefix (cdr strings) prefix))]))\n",
  "  (filter (lambda (s) (string-match prefix s)) strings))\n", "  (cond [(empty?\
    \ strings) strings]\n        [(equal? (first strings) prefix) (cons (first strings)\
    \ strings)]\n        [else (filter_by_prefix (rest strings) prefix)]))\n", " \
    \ (filter (lambda (str) (begins_with str prefix)) strings))\n", "  (remove-if\n\
    \   (lambda (x)\n     (string=? x (make-string (string-length prefix) #\\0)\n\
    \                  :start prefix))\n   strings))\n", "  (cond\n    [(null? strings)\
    \ strings]\n    [(eq? (car strings) prefix) (cons prefix strings)]\n    [(equal?\
    \ (car strings) (cons (car strings) prefix))\n     (filter_by_prefix (cdr strings)\
    \ prefix)]\n    [else (cons (car strings) (filter_by_prefix (cdr strings) prefix))]))\n",
  "  (filter prefix (interleave strings empty?)))\n", "  (cond\n    ((empty? strings)\
    \ '())\n    ((equal? (first strings) prefix) (filter_by_prefix (rest strings)\
    \ prefix))\n    (else (cons (first strings) (filter_by_prefix (rest strings) prefix))))\n\
    )\n", "  (cond [(empty? strings) strings]\n        [(eq? (car strings) prefix)\
    \ (cons (car strings) strings)]\n        [else (filter_by_prefix (cdr strings)\
    \ prefix)]))\n", "  (cond [(empty? strings) strings]\n        [(eq? prefix first-symbol)\
    \ strings]\n        [(prefix-match? prefix strings)\n         (cons (car strings)\
    \ (filter_by_prefix (cdr strings) prefix))]\n        [else (filter_by_prefix (cdr\
    \ strings) prefix)]))\n", "  (cond\n    [(empty? strings) strings]\n    [(not\
    \ (starts-with? prefix string)) strings]\n    [else (filter_by_prefix (rest strings)\
    \ prefix)]\n  ))\n", "  (filter (lambda (str)\n            (and (string-prefix?\
    \ prefix str))\n            str))\n          strings))\n", "  (filter (lambda\
    \ (x) (startswith x prefix)) strings))\n", "  (if (null? strings)\n      '()\n\
    \      (cons (first strings)\n            (filter_by_prefix (rest strings)\n \
    \                             prefix)))))\n", "  (cond\n    [(null? strings) '()]\n\
    \    [(string=? (first strings) prefix) (cons (first strings) (filter_by_prefix\
    \ (rest strings) prefix))]\n    [else (filter_by_prefix (rest strings) prefix)]))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
