name: HumanEval_120_maximum
language: rkt
prompt: "#lang racket\n\n;; Given a list arr of integers and a positive integer k,\
  \ return a sorted list \n;; of length k with the maximum k numbers in arr.\n;; Example\
  \ 1:\n;; >>> (maximum (list -3 -4 5) 3)\n;; (list -4 -3 5)\n;; Example 2:\n;; >>>\
  \ (maximum (list 4 -4 4) 2)\n;; (list 4 4)\n;; Example 3:\n;; >>> (maximum (list\
  \ -3 2 1 2 -1 -2 1) 1)\n;; (list 2)\n;; Note:\n;; 1. The length of the list will\
  \ be in the range of [1, 1000].\n;; 2. The elements in the list will be in the range\
  \ of [-1000, 1000].\n;; 3. 0 <= k <= len(arr)\n(define (maximum arr k)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate maximum))\n\
  \    (check-equal? (candidate (list -3 -4 5) 3) (list -4 -3 5))\n    (check-equal?\
  \ (candidate (list 4 -4 4) 2) (list 4 4))\n    (check-equal? (candidate (list -3\
  \ 2 1 2 -1 -2 1) 1) (list 2))\n    (check-equal? (candidate (list 123 -123 20 0\
  \ 1 2 -3) 3) (list 2 20 123))\n    (check-equal? (candidate (list -123 20 0 1 2\
  \ -3) 4) (list 0 1 2 20))\n    (check-equal? (candidate (list 5 15 0 3 -13 -8 0)\
  \ 7) (list -13 -8 0 0 3 5 15))\n    (check-equal? (candidate (list -1 0 2 5 3 -10)\
  \ 2) (list 3 5))\n    (check-equal? (candidate (list 1 0 5 -7) 1) (list 5))\n  \
  \  (check-equal? (candidate (list 4 -4) 2) (list -4 4))\n    (check-equal? (candidate\
  \ (list -10 10) 2) (list -10 10))\n    (check-equal? (candidate (list 1 2 3 -23\
  \ 243 -400 0) 0) (list ))\n))\n\n(test-humaneval)"
completions: ["  (cond\n    [(<= (length arr) k) arr]\n    [else (if (> k 0)\n   \
    \          (append (maximum (rest arr) (sub1 k)) (first arr))\n             (maximum\
    \ (rest arr) k))]\n  ))\n", "  (cond\n    [(empty? arr) empty]\n    [(< k (length\
    \ (first arr)))\n     (append (max (rest arr) k) (first arr))] \n    [else (append\
    \ (max (rest arr) k) (first arr))]))\n", "  (if (empty? arr)\n      '()\n    \
    \  (if (= k 0)\n          (append (list (first arr)) (maximum (rest arr) 1))\n\
    \          (append (list (first arr)) (maximum (rest arr) (sub1 k))))))\n</cell>\n\
    <code language=ocaml-jupyter>\n#lang racket\n", "  (cond [(empty? arr) (list ())]\n\
    \        [(= 0 (length arr)) (list arr)]\n        [(= k (length arr)) arr]\n \
    \       [else (append (sort-highest (rest arr) (- k 1))\n                    \
    \  (maximum (rest arr) (- k 1)))]))\n", "  (cond\n    ((= k 0) arr)\n    ((> (length\
    \ arr) k) (list 0))\n    (else (let loop ((i 0) (max nil) (arr (cdr arr)))\n \
    \              (cond\n                ((null? arr) arr)\n                ((= i\
    \ (- k 1)) max)\n                ((< (car arr) max) (loop (+ i 1) (max max arr)\
    \ (cdr arr)))\n                (else (loop (+ i 1) (max max arr) (cons (car arr)\
    \ arr))))))))\n", "  (define (helper l k)\n    (cond ((< k 0)\n           (if\
    \ (empty? l)\n               (list 0)\n               (helper tail k)))\n    \
    \      ((< k 1)\n           (if (null? l)\n               (list 0)\n         \
    \      (helper tail (sub1 k))))\n          ((< k (length l))\n           (if (>\
    \ (car l) (max-int k))\n               (helper (cdr l) k-(car l))\n          \
    \     (helper (cdr l) (sub1 k))))\n          (else\n           (helper (cdr l)\
    \ k)))))\n  (helper arr k))\n", "  (let loop ((l '()) (m '()) (max '()))\n   \
    \ (if (null? arr)\n        (reverse max)\n        (let ((m (maximum (cdr arr)\
    \ k)))\n          (if (= m k)\n              (reverse l)\n              (loop\
    \ (cons m l) (cons m m) (cons (car arr) max)))))))\n", "  (cond\n    [(empty?\
    \ arr) '()]\n    [(>= k 0) '()]\n    [else (append (maximum arr (sub1 k)) (list\
    \ max (first arr) (second arr) (third arr) (forth arr) (fifth arr)))]))\n", " \
    \ (if (or (< k 0) (equal? k 0))\n      '()\n      (append (sort (append (take\
    \ (length arr) arr) (list (last arr)))\n                   (lambda (x y) (if (>\
    \ x y) (sub1 x) x))\n                   (lambda (x y) (if (< x y) (sub1 y) y))\n\
    \                   (lambda (x y) (if (= x y) (sub1 x) y))\n                 \
    \  (lambda (x y) (if (= x y) (sub1 y) y))\n                   (lambda (x y) (if\
    \ (= x y) x y))))))\n", "  (define (iter index max)\n    (cond [(empty? arr) (list\
    \ max)]\n          [else (if (= (max max) (car arr))\n                  (iter\
    \ (+ index 1) max)\n                  (iter index (cons (car arr) max)))]))\n\
    \  (iter 0 '()))\n", "  (if (= k 0)\n      (list 0)\n      (let ([max-el (first\
    \ arr)])\n        (append (maximum (rest arr) (sub1 k))\n                (list\
    \ (max max-el (first arr)))))))\n", "  (cond [(empty? arr) empty]\n        [(>=\
    \ k 0)\n         (cons (first arr) (maximum (rest arr) (k - 1)))]\n        [else\n\
    \         (maximum (rest arr) k)]\n      )\n)\n", "  (let* ((result (sublist\n\
    \                   (sort\n                     ;; If the first k-1 elements are\
    \ less than or equal to\n                     ;; the second k-1 elements, the\
    \ list will be reversed.\n                     (sort (build-list k (lambda (x)\
    \ (cond \n                                                  [(<= (car arr) (cdr\
    \ arr)) (cons (cdr arr) result)]\n                                           \
    \       [(<= (car arr) (max 0 (car arr)))\n                                  \
    \                 (cons (car arr) (result))]\n                               \
    \                   [(<= (cdr arr) (cdr arr))\n                              \
    \                     (cons (cdr arr) (cons arr (cdr result)))]\n            \
    \                                      [else\n                               \
    \                    (cons (car arr) (cons (max 0 (car arr)) result))]))\n   \
    \                  ;; Otherwise, the list will be ordered.\n                 \
    \    (reverse (build-list k (lambda (x) (cond (<= (car arr) (cdr arr)) (cons (cdr\
    \ arr) result))\n                                              [(<= (cdr arr)\
    \ (cdr arr))\n                                               (cons (cdr arr) (cons\
    \ arr (cdr result)))]\n                                              [else\n \
    \                                              (cons (car arr) (cons (car result)\
    \ (cons (car result) (cdr result))))])))\n                 (tail (build-list 1\
    \ (lambda (x) (cons (car arr) x)))\n                  (iter (lambda (l) (set!\
    \ result (cons (car l) result)))\n                         (reverse tail)))\n\
    \    (set! tail (cdr tail))\n    (cond [(< k 0) result]\n          [(< k (length\
    \ result)) (list tail result)]\n          [else (append tail (list result))]))))\n",
  "  (if (= k 0)\n      (list -1)\n      (let ([max-so-far (first arr)])\n       \
    \ (if (= (length arr) k)\n            (list max-so-far)\n            (append (maximum\
    \ (rest arr) (sub1 k)) (list max-so-far)))))) \n", "  (cond [(< k 0)\n       \
    \  '()]\n        [(= k 0)\n         (list arr)]\n        [else\n         (append\
    \ (sort (append arr (list (max arr (- k 1))))\n                         (lambda\
    \ (a b) (< (car a) (car b))))\n                 (maximum (sort (append arr (list\
    \ (- k 1))) \n                             (lambda (a b) (< (car b) (car a))))\n\
    \                         (- k 1))]))) ;don't know why this has to be sorted...\n\
    \      ", "  (if (= k 0)\n      (append arr (list #max))\n      (let ([max-el\
    \ (first arr)])\n        (if (> max-el (first arr)) \n            (append arr\
    \ (list max-el))\n            (maximum (rest arr) (sub1 k))))))\n", "  (define\
    \ (helper a b i j)\n    (if (< i (length a)) (if (< b (length b))\n          \
    \              (helper (cdr a) (cdr b) (+ i 1) j)\n                        (helper\
    \ (cdr a) (cdr b) i (+ j 1)))))\n  (helper arr '() 0 k))\n", "  (if (null? arr)\n\
    \      '()\n      (cons (max (car arr) (maximum (cdr arr) k)))))\n  ", "  (sort\
    \ (list arr) <))\n", "  (let ([i 0])\n    (cond [(empty? arr) empty]\n       \
    \   [else\n           (let* ([max-el (list-ref (sort arr (< k i)) i)]\n      \
    \             (new-i i))\n             (cond [(< new-k new-i)\n              \
    \      (set! i (+ i 1))\n                    (set! k (- k 1))]\n             \
    \      [else (cons max-el \n                                 (maximum (sort arr\
    \ (< k new-i))\n                                         k))])))]))\n</code>\n\
    <|/ a tags=scheme,racket,list |>\n<| a |>\nHere is a simple implementation in\
    \ Racket that works for any list input. \n<code>", "  (cond\n    [(null? arr)\
    \ '()]\n    [(= k 0) (append (list (first arr)) (maximum (rest arr) (k - 1)))]\n\
    \    [else (append (list max (first arr)) (maximum (rest arr) (sub1 k)))]\n  )\n\
    )", "  (define (helper arr k)\n    (if (null? arr)\n        '()\n        (if (=\
    \ k 0)\n            (cons (car arr) (helper (cdr arr) 0))\n            (helper\
    \ (cdr arr) (sub1 k))))))\n  (helper arr k))\n", "  (sort (append (take-k arr\
    \ k)\n                  (take-k arr (- k 1))) >))\n", "  (if (> k 0)\n      (append\
    \ (subseq (arr 0 k) (max 0 (+ k 1))) (maximum arr (- k 1))) \n      (list)))\n",
  "  (let loop ([n 0])\n    (if (or (< n k) (>= n 0))\n        (cons (car arr)\n \
    \             (loop (+ n 1) (cdr arr)))\n        (loop (+ n 1) (cons (car arr)\
    \ '())))))\n", "  (let ([len (length arr)]\n        [max-k (sub1 (min (+ k len)\
    \ len))])\n    (if (= len 0) '()\n        (if (= k 0) (first arr)\n          \
    \  (let ([i (first arr)]\n                  [j (max 0 (rest arr))]\n         \
    \         [max-i (car max-k)]\n                  [max-j (cdr max-k)])\n      \
    \        (if (> i j)\n                  (cons i max-k)\n                  (cons\
    \ j max-k))))))))\n", "  (cond\n    [(null? arr) '()]\n    [(= k 0) (cons (car\
    \ arr) (maximum (cdr arr) (sub1 k)))]\n    [else\n     (cons (car arr) (maximum\
    \ (cdr arr) (sub1 k)))]\n  )\n)", "  (define (helper arr accum k)\n    (cond\n\
    \      [(empty? arr) (append accum empty)]\n      [(<= k 0) (helper arr accum\
    \ (- k 1))]\n      [(= (first arr) (- (first accum) (rest accum)))\n       (helper\
    \ (rest arr) (cons (first arr) accum) k)]\n      [else (helper (rest arr) (cons\
    \ (first arr) (cons (first accum) accum)) k)]\n    )\n  )\n  (helper arr empty\
    \ k))\n</code>\n<|/ a tags=scheme,functional-programming dscore=1 |>\n<| c |>\n\
    Please consider accepting my answer if it works for you, rather than leaving me\
    \ a comment explaining why not. Thanks!\n<|/ c |>\n<| c |>\nI did try your solution\
    \ and it worked for me too, but it took me long enough to understand why my solution\
    \ doesn't work. I will try to add my answer later.\n<|/ c |>\n<| a dscore=1 tags=scheme,functional-programming\
    \ |>\nThis answer is a little different than the others because of the requirements\
    \ I had:\n1. We have to do this in racket.\n2. The solutions have to run in O(n),\
    \ where n represents the length of the array.\n3. The solutions should run in\
    \ O(n), where n is the length of the list.\n4. Only solutions using the append\
    \ function can be used. This is why I used the cons function to append the list\
    \ to the front of the front of the list.\nThe solutions I came up with aren't\
    \ pretty, but it works.\n<code>", "  (if (= k 0)\n      (list 0)\n      (if (null?\
    \ (rest arr))\n          (cons (car arr) (maximum (rest arr) (sub1 k)))\n    \
    \      (append (cons (car arr) (maximum (rest arr) (sub1 k)))\n              \
    \    (maximum (rest arr) (sub1 k)))))) ; recur case", "  (cond\n    [(empty? arr)\
    \ (empty-list k)]\n    [(= k 0) (first arr)]\n    [else (cons (first arr) (maximum\
    \ (rest arr) (sub1 k)))]))", "  (let loop ((arr arr) (i 0) (max '()) (count 0))\n\
    \    (cond\n      [(or (>= i k) (< i 100)) (if (= (length arr) (+ count i)) \n\
    \                                     max \n                                 \
    \    (loop (rest arr) (+ i 1) (append (list max) (rest arr)) count))]\n      [(<\
    \ i k) (if (< count k) (loop (rest arr) (+ i 1) '() count))\n       (append (list\
    \ max) (rest arr))]\n      [else (if (< count k) (loop (rest arr) (+ i 1) '()\
    \ count))\n             (append (list max) (rest arr))]))))\n", "  (cond [(empty?\
    \ arr) empty]\n        [(< k length) (append (list (maximum (rest arr) k))\n \
    \                             (maximum (rest arr) (sub1 k)))]\n        [else (append\
    \ (maximum (rest arr) k)\n                        (maximum (rest arr) (sub1 k)))]))\n",
  "  (if (or (zero? k) (null? arr))\n      (list 0)\n      (append (maximum (rest\
    \ arr) (k - 1)) \n              (cons (car arr) (maximum (cdr arr) k)))))\n",
  "  (cond\n    ((null? arr) '())\n    ((= k 0) (first arr))\n    ((= k (length arr))\
    \ (last arr))\n    (else (append (maximum (rest arr) (- k 1))\n              \
    \    (list (first arr)))))) \n</code>\n<|/ a dscore=3 |>\n<| c |>\nThank you for\
    \ taking the time to write this solution. This is a great solution and I will\
    \ definitely remember it for my future questions. However, this doesn't solve\
    \ the problem that the other solutions don't take into account the fact that the\
    \ numbers in the list are not in the correct order. This is what I was trying\
    \ to find out how to do. I can always ask a question next time about how to do\
    \ something like this and see if I can get some help with this but this isn't\
    \ what I was asking for. Thank you though for taking the time to answer my question!\n\
    <|/ c |>\n<| c |>\nI see what you mean. I've edited my answer to include a solution\
    \ that considers the numbers in order.\n<|/ c |>\n<| c |>\nThanks again, this\
    \ is exactly what I needed.\n<|/ c |>\n<| c |>\nGlad I could help!\n<|/ c |>\n\
    <| a |>\nA simple recursive approach could be a solution:\n<code>", "  (if (=\
    \ k 0)\n      (list 0)\n      (let ([largest (list-tail (maximum-sublist arr 0\
    \ k)))]\n            (if (< k 0)\n                (list largest)\n           \
    \     (list largest (list-tail (maximum-sublist arr 1 k)))))) ))\n", "  (sort\
    \ (append (take arr (sub1 k))\n                 (take arr (add1 k)))\n       \
    \  (lambda (x y)\n           (or (> (first x) y)\n              (< (first y) x)))))\n\
    </code>\n<|/ a tags=scheme |>\n<| a dscore=1 tags=scheme |>\n<code>", "  (cond\n\
    \    [(or (empty? arr) (<= (length arr) k)) empty]\n    [(= k 0) arr]\n    [else\
    \ (append (append (take arr (quotient k (length arr)))\n                     \
    \   (maximum (drop arr (quotient k (length arr)))\n                          \
    \        (sub1 k)))\n                  (maximum (drop arr (quotient k (length\
    \ arr))))]))))\n", "  (if (= k 0)\n      (list -1)\n      (append (list) (maximum\
    \ (rest arr) (- k 1)))))\n", "  (cond\n    [(< k 0)\n     '()]\n    [(null? arr)\
    \ '()]\n    [(= (length arr) 0) '()]\n    [(= (length arr) k)\n     (list arr)]\n\
    \    [else\n     (append (sort (max 0 (car arr)) (lambda (x) (<= x arr)))\n  \
    \           (maximum (cdr arr) (sub1 (+ k 1))))]))\n", "  (if (or (= k 0) (< k\
    \ 100) (< (length arr) 0))\n      '()\n      (if (< (length arr) (+ k 1))\n  \
    \    (cons (max arr (- k 1)) (maximum arr (- k 1)))\n      (cons (first arr) (maximum\
    \ arr (- k 1))))))\n", "  (cond\n    [(<= k 1) (append arr [])]\n    [else (append\
    \ (if (> (apply max (car arr)) (apply max (cdr arr)))\n                     arr\n\
    \                     (append (car arr)\n                            (maximum\
    \ (cdr arr) (- k 1))))\n                k (maximum (cdr arr) (- k 1))])))\n",
  "  (cond [(empty? arr) empty]\n        [else (append (max (rest arr) k) (maximum\
    \ (rest arr) (k - 1))))]))\n", "  (cond\n    [(empty? arr) (empty-list k)]\n \
    \   [(= k 0) (list #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f\
    \ #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f\
    \ #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f\
    \ #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f\
    \ #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f\
    \ #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f\
    \ #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f\
    \ #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f\
    \ #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f\
    \ #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f #f ", "  (if (or (not (eq? k\
    \ 0))\n          (null? arr))\n      (list 0)\n      (let ([max (car arr)]\n \
    \           [tmp (cdr arr)])\n        (if (or (not (eq? max 0))\n            \
    \    (null? tmp))\n            (cons max tmp)\n            (if (= k 0)\n     \
    \           (cons max tmp)\n                (maximum (append tmp (list max)) (-\
    \ k 1))))))))\n", "  (if (empty? arr)\n      (list nil)\n      (let ([m (max 0\
    \ (- (car arr) (cadr arr))))]\n        (append (cons (car arr) nil) (maximum (cdr\
    \ arr) (add1 k))))))", "  (cond\n    ((null? arr) '())\n    ((> k 0) (append (maximum\
    \ \n                      (sub1 arr)\n                      (min k (length arr))\n\
    \                      arr)\n                    (maximum (rest arr) k-(length\
    \ arr)))\n    ((< k 0) (append (maximum (rest arr) k) arr))\n    (else arr)))\n",
  "  (define max-helper helper k arr)\n  (define (helper i arr k)\n    (cond\n   \
    \   [(< (length arr) k) (list arr 0)]\n      [(equal? (- i k) (length arr)) (cons\
    \ (car arr) (cons 0 0))]\n      [else (cons (car arr) \n                  (helper\
    \ (+ i 1) \n                         (append (rest arr) (list i)))]))\n  (helper\
    \ 0 arr k))\n", "  (if (< k 0)\n      (list -1)\n      (let ((x (car arr)))\n\
    \        (if (> (car arr) x)\n            (cons x \n                  (maximum\
    \ (cdr arr) (- k 1))\n                  (maximum (cdr arr) k)))))) ; call recursively\n\
    <|/ file dstars=0 source=github |>\n<| c |>\nThanks for your help and time. I\
    \ have edited the code to give the correct output for k=0.\n<|/ c |>\n<| c |>\n\
    No need to edit my answer.\n<|/ c |>\n<| c |>\nIt's good to know that I have made\
    \ my edits. I will edit my answer in the future for better understanding of the\
    \ code. Also, could you please explain to me the purpose of the (+ k (car arr))?\
    \ I have not seen this before.\n<|/ c |>\n<| c |>\nBecause you need to find the\
    \ maximum for each sublist. The max of the head should be the current max of the\
    \ tail. That's why you need a counter.\n<|/ c |>\n<| c |>\nBut why do we need\
    \ to use a counter when we can just use the last value we found? I see that we\
    \ have used the counter to find the maximum from the list, but why not just use\
    \ the last value we found to determine the maximum of the entire list?\n<|/ c\
    \ |>\n<| a tags=racket,scheme |>\nIf you use a fold, you can do it like this:\n\
    <code>", "  (if (>= k 0) (if (<= (length arr) (- k 1))\n                  (cons\
    \ (car arr) (maximum (cdr arr) (k - 1))))\n                  (if (<= (length arr)\
    \ (- k 1))\n                  (cons (car arr) (maximum (cdr arr) (- k 1)))\n \
    \                 (list))))\n", "  (check-expect (< k k) (> k 0))\n  (check-expect\
    \ (< arr (list 0))\n              (> arr (list 0)))\n  (sort (append arr\n   \
    \             (list 0))\n        (lambda (x y)\n          (if (< x y)\n      \
    \        (< x y)\n              (> x y)))\n        (lambda (x y)\n          (if\
    \ (< x y)\n              (< x y)\n              (> x y))))\n  (cdr (last arr)))\n\
    </code>\n<|/ a tags=lisp,list,racket,scheme dscore=3 |>\n<| a dscore=2 |>\nHere\
    \ is a solution that uses sort:\n<code>", "  (if (= k 0)\n      '()\n      (cons\
    \ (max (car arr) (maximum (cdr arr) (sub1 k)))\n            (maximum (cdr arr)\
    \ (sub1 k))))))\n", "  (let ((max-list '()))\n    (cond ((= k 0) max-list)\n \
    \         ((= (length arr) k) arr)\n          ((< (car arr) (cadr max-list))\n\
    \           (cons (car arr) max-list))\n          (else (maximum (cdr arr) (add1\
    \ k)))))) \n", "  (if (= k 0)\n      (list ())\n      (let ((largest (car arr))\n\
    \            (max-index (car max-index)))\n        (if (> largest largest)\n \
    \           (let ((max-index (add1 max-index)))\n              (if (>= max-index\
    \ k)\n                  (list largest)\n                  (append (list (largest))\
    \ (maximum (cdr arr) (sub1 k)))))))) \n", "  (cond [(empty? arr) empty]\n    \
    \    [(= k 0) (list arr)]\n        [else (append (maximum (append (rest arr) (list\
    \ (first arr)))) \n                      (maximum (rest arr) (k - 1))))]))", " \
    \ (if (= k 0)\n      arr\n      (if (null? arr)\n          (if (null? (cdr arr))\n\
    \              '()\n              (cons (car arr) (cdr (cdr arr))))\n        \
    \  (if (> (car arr) (car (cdr arr)))\n              (cons (car arr) (maximum (cdr\
    \ arr) (sub1 k)))\n              (maximum (cdr arr) (sub1 k))))))\n", "  (let\
    \ loop ((i 0) (max #f) (rest (subseq arr 0 k)))\n    (cond ((= i k) max)\n   \
    \       ((= 0 (length rest)) (reverse (cons (first rest) max)))\n          (else\
    \ (loop (+ i 1) (cons (first rest) max) (subseq rest 1))))))\n", "  (cond ((empty?\
    \ arr) (list 0))\n        ((= (length arr) k) (list 0))\n        (else (maximo\
    \ arr (+ k 1)))))\n", "  (define (helper cur k max-so-far)\n    (cond [(< k 0)\n\
    \           (reverse max-so-far)]\n          [(> k (length arr))\n           (reverse\
    \ cur)]\n          [else\n           (if (> (car arr) max-so-far)\n          \
    \     (helper (cdr cur) k (car arr))\n               (helper (cons (car cur) cur)\
    \ k (car arr)))]))\n  (helper '() (length arr) 0))\n", "  (if (= k 0)\n      (list\
    \ 0)\n      (define (helper n cur max) (cond [(> n k) (cons cur max)]\n      \
    \                                     [(= n 0) (list cur)]\n                 \
    \                          [(< n k) (helper (- n 1) (cons cur max) (cons max 0))]\n\
    \                                           [else (helper (- n 1) (cons cur max)\
    \ cur)]))\n      (helper 0 '() '()))) ;; (helper 0 '() '()))\n", "  (cond [(empty?\
    \ arr) (list '() '() '())]\n        [(or (zero? (car arr))\n             (< (car\
    \ arr) k))\n         (append (list '() '() '())\n                 (maximum (cdr\
    \ arr) (- k 1)))]\n        [(or (zero? (car arr))\n             (> (car arr) k))\n\
    \         (append (maximum (cdr arr) k)\n                 (list '() '() '())])\n\
    \        [else\n         (append (maximum (cdr arr) k)\n                 (list\
    \ '() '() '())])))\n", "  (if (< k 0)\n      '()\n      (append (sort (apply >\
    \ (rest arr))) \n              (maximum (rest arr) (- k 1)))))", "  (define (helper\
    \ lst acc)\n    (cond\n      [(empty? lst) (append acc '())]\n      [(< (first\
    \ lst) acc) (helper (rest lst) acc)]\n      [else (helper (rest lst) (cons (first\
    \ lst) acc))]\n    ))\n  (helper arr '()))\n", "  (define (sort a-list)\n    (if\
    \ (empty? a-list)\n        a-list\n        (append (sort (sub1 a-list)) (list\
    \ (max (car a-list) (car a-list)) a-list))))\n  (sort (sort (sort arr (- k 1)))))\n\
    </code>\n<|/ a tags=lisp,scheme |>\n<| a tags=lisp,scheme |>\nThe idea behind\
    \ this problem is to find the kth largest element in the given list. We can do\
    \ this by traversing the list twice and find the element in the first list which\
    \ has same value and second one has bigger value. \nNow we can return this element\
    \ as we traverse the list once but we can still do better by not traversing the\
    \ list twice.\n<code>", "  (if (= k 0)\n      arr\n      (let ([curr (car arr)])\n\
    \        (if (< (car arr) curr)\n            (cons curr (maximum (cdr arr) (sub1\
    \ k)))\n            (maximum (cdr arr) (sub1 k))))))\n", "  (if (<= k 0)\n   \
    \   (list)\n      (if (empty? arr)\n          (list -1)\n          (append (sort\
    \ (max 0 k) (+ k k)) (sort (first arr) (+ k k))))))\n", "  (if (zero? k)\n   \
    \   (cons (car arr) nil)\n      (let ([max-so-far (car arr)]\n            [max-so-far-index\
    \ (car arr)])\n        (cond ((> k max-so-far-index)\n               (cons max-so-far\
    \ nil))\n              ((<= k max-so-far-index)\n               (cons (car arr)\
    \ (maximum (cdr arr) (- k 1))))\n              (t (maximum (cdr arr) (- k 1))))))))\n",
  "  (if (= k 0)\n      (list)\n      (if (null? arr)\n          (list) \n       \
    \   (cons (max (first arr) (first arr) (sub1 k)) \n               (maximum (rest\
    \ arr) (sub1 k))))))\n", "  (check-range arr (list -1000 (length arr)))\n  (check-range\
    \ k (list 1 (length arr)))\n  (define (max-helper arr k i)\n    (cond\n      [(<\
    \ k i) arr]\n      [(= 0 (- k i)) (append arr (list (first arr)))]\n      [else\
    \ (max-helper (append arr (list (first arr)))\n                        (- k i)\n\
    \                        (+ i 1))]))\n  (max-helper arr k 0))\n", "  (cond [(empty?\
    \ arr) empty]\n        [(empty? (rest arr)) (list arr)]\n        [(= 0 (length\
    \ arr)) (list arr)]\n        [(= k 0) (list arr)]\n        [else (if (< k (length\
    \ arr))\n                  (append (max (rest arr) (- k 1)) (max arr (- k 1)))\n\
    \                  (max arr (- k 1)))]\n))\n", "  (check-range k 0 1000)\n  (check-range\
    \ (length arr) 1 1000)\n  (build-list k #:(max (car arr) (maximum (cdr arr) (-\
    \ k 1)))))\n", "  (cond [(null? (rest arr)) (list)]\n        [else (append (maximum\
    \ (rest arr) (sub1 k)) (list max (car arr)))]))\n</code>\n<|/ a tags=racket,scheme,list\
    \ |>\n<| a dscore=0 |>\n<code>", "  (if (= k 0)\n      '()\n      (let ([max (car\
    \ arr)]\n            [rest (cdr arr)])\n        (if (or (= 0 k) (< k 0))\n   \
    \         (cons max rest)\n            (let ([head (maximum (rest rest) (sub1\
    \ k)))]\n                   (cons head max)))))) \n</cell>\n<text>\nExercise 2.7\n\
    Write a function that takes a string and returns true if it is a palindrome, and\
    \ false if it is not.\n\nHint: Look at the solution for Exercise 2.6. Remember\
    \ that cons inserts at a certain point in a list.\n\n\n</text>\n<cell>\n#lang\
    \ racket\n", "  (if (= k 0)\n      '()\n      (append (take (maximum-helper-helper\
    \ arr arr k) k)\n              (maximum-helper-helper arr arr (- k 1)))))\n",
  "  (if (= k 0)\n      arr\n      (maximum-aux (rest arr) (first arr) (max (rest\
    \ k) k))\n  )\n)\n", "  (if (<= k 0)\n      '()\n      (append (if (> (max arr)\
    \ (max arr (rest arr)))\n                   (list max)\n                   (list\
    \ max (rest arr)))\n               (maximum (rest arr) (- k 1)))))", "  (cond\n\
    \    [(empty? arr) empty]\n    [(= k 0) (first arr)]\n    [else (append (maximum\
    \ (rest arr) (- k 1))\n                  (list (first arr))\n                \
    \  (maximum (rest arr) (- k 1)))]))\n", "  (let ([len (length arr)]\n        ;;\
    \ find the maximum k numbers in the list arr\n        ;; by doing an insert sort\
    \ on arr with the first element as maximum\n        ;; and the rest as smaller\
    \ numbers\n        ;; so by first inserting the max into arr\n        ;; then\
    \ inserting the remaining numbers into arr\n        ([max (insert max-arr arr\
    \ 0)])\n        ([tmp (cdr max-arr)])\n        ([max-arr (list max-arr (car tmp))])\n\
    \        ([cur (car tmp)])\n        (\n          [next (cons cur max-arr)]\n \
    \         [max-arr (cdr max-arr)])\n          [cur (car tmp)])\n          [next\
    \ (cons cur max-arr)])\n    ;; if the length of the array is smaller than k then\
    \ return the max number\n    [if (< len k) (list max)]\n    ;; if the length of\
    \ the array is equal to k\n    ;; then find the maximum of arr and append it to\
    \ the list\n    [if (= len k) (cons (car max) (maximum (cdr max-arr) k))]))\n\
    #lang racket\n", "  (if (= (sub1 k) (sub1 (length arr)))\n      (sub1 (sort (append\
    \ (sub1 arr) (reverse (sub1 (reverse arr))) (reverse (sub1 (reverse (sort (append\
    \ (reverse arr) (sub1 arr))))))))\n      (cons (max (sub1 arr) (sub1 (sub1 arr\
    \ k))))))\n  \n", "  (let loop ((arr arr) (k k) (result '()))\n    (cond ((null?\
    \ arr) (reverse result))\n          ((null? (cdr arr)) (if (= k 0) result (loop\
    \ (cdr arr) (k -1)\n                                                  (append\
    \ result (list (car arr)))))\n                      (loop (cdr arr) (- k (length\
    \ arr)) result)))\n          ((< (car arr) (cadr arr)) (loop (cdr arr) (- k (length\
    \ arr))\n                                              (append result (list (car\
    \ arr)))))\n          (else (loop (cdr arr) (- k (length arr)) result)))))\n",
  "  (if (= k 0)\n      (list)\n      (append (list-tail (sort (sort arr (lambda (e1\
    \ e2) (< (first e1) (first e2))))) k) (maximum (list-tail arr (sub1 k)) (sub1\
    \ k)))))\n", "  (let ([x (sort arr)])\n    (if (zero? k)\n        (list x)\n \
    \       (cons x (maximum (rest x) (sub1 k))))))\n    ", "  (cond\n    [(empty?\
    \ arr) (list empty)]\n    [(= k 0) (list arr)]\n    [else (append (maximum (rest\
    \ arr) (k-1))\n                    (cons (max (first arr)) (maximum (rest arr)\
    \ (sub1 k))))]))\n", "  (let loop ((i 0) (max-arr ()) (arr arr) (k k) (max-k 0))\n\
    \    (cond ((< i k) (loop (+ i 1) max-arr arr k max-k))\n          ((< max-k k)\
    \ (loop (+ i 1) (append max-arr (list (car arr))) (cdr arr) k max-k))\n      \
    \    (else (loop (+ i 1) max-arr (append arr (list (car arr))) (+ k 1) max-k))))\n\
    \  \n  ", "  (if (= 0 k)\n      '()\n      (if (>= (length arr) (+ k 1))\n   \
    \       (append (if (> (car arr) (cadr arr)) (car arr) (cadr arr))\n         \
    \          (maximum (cdr arr) (- k 1)))))))\n", "  (cond [(null? arr)\n      \
    \   '()]\n        [(= (length arr) k)\n         (reverse arr)]\n        [else\
    \ (append (sort (append arr\n                                   (reverse (sublist-from-end\
    \ arr k (length arr)))))\n                       (maximum (sublist-from-end arr\
    \ k (length arr)))]))))\n", "  (define (aux arr k max-so-far max-so-far-idx max-so-far-idx-idx\n\
    \           max-so-far-idx-idx new-max-so-far)\n    (cond [(empty? arr) (list\
    \ new-max-so-far)]\n          [(< (first arr) max-so-far)\n           (aux rest\
    \ (+ k 1)\n                 (+ max-so-far-idx 1)\n                 (+ max-so-far-idx-idx\
    \ 1)\n                 (+ (- max-so-far-idx-idx 2) 1)\n                 (first\
    \ arr)\n                 new-max-so-far)\n          ]\n          [else\n     \
    \      (aux (rest arr)\n                 (- k 1)\n                 (+ max-so-far-idx\
    \ 1)\n                 (+ max-so-far-idx-idx 1)\n                 (+ (- max-so-far-idx-idx\
    \ 2) 1)\n                 (first arr)\n                 (first arr) (+ new-max-so-far\
    \ (first arr)))))\n  (aux arr k 0 0 1 0 0))\n", "  (if (< k 0)\n      (list nil)\n\
    \      (let ([arr-tail (rest arr)]\n            [largest-tail (first arr-tail)]\n\
    \            [largest-ele (first arr-tail)])\n        (if (null? arr-tail)\n \
    \           (list largest-ele largest-tail)\n            (if (> largest-ele largest-tail)\n\
    \                (let ([larger-tail (maximum (rest arr-tail) (k - 1))]\n     \
    \                 [larger-ele (first larger-tail)])\n                  (cons (cons\
    \ largest-ele larger-ele) (cons largest-tail larger-tail))))))))\n", "  (define\
    \ (helper num count temp)\n    (if (= count k)\n        temp\n        (if (> num\
    \ arr) \n            (helper (car temp) (+ count 1) (cdr temp))\n            (helper\
    \ (car temp) count (cdr temp)))))\n  (helper 0 1 (cons 0 (cdr arr))))\n</code>\n\
    <|/ a dscore=0 |>\n<| a tags=scheme |>\nI didn't use scheme for a while, but it\
    \ looks like you want a sorted list, but don't have a proper sorting function.\
    \  You can find something close in some languages in libraries.\n<|/ a dscore=0\
    \ |>\n<| a tags=scheme |>\n<code>", "  (if (or (zero? k) (empty? arr))\n     \
    \ (list)\n      (let ((max-length (+ k (length arr))) (max-arr (copy-list arr)))\n\
    \        (if (>= max-length 0)\n            (cons (max arr max-arr)\n        \
    \          (maximum (rest arr) (- k max-length)))\n            (cons (max arr\
    \ max-arr) (maximum (rest arr) k)))))) ; else break\n", "  (sort (take arr (-\
    \ k 1))\n        >\n        (lambda (x) (>= (length x) (- k 1))\n            \
    \        (<= x (first arr))\n                    (< x (second arr)))))\n", " \
    \ (cond\n    [(empty? arr) (list empty)]\n    [(= k (length arr)) (list arr)]\n\
    \    [(< k (length arr)) (sort (maximum (sub1 arr) k) greater?)]\n    [else (sort\
    \ (maximum (rest arr) k) greater?)]))\n", "  (cond (<? (length arr) 1000)\n  \
    \      (<? (< (length arr) k) 1000)\n        (= k (length arr))\n        (< (first\
    \ arr) <?)\n        (< (first arr) <?)\n        (maximum (rest arr) (- k 1))\n\
    \        (maximum (rest arr) (- k 1))\n        (maximum (rest arr) (- k 1))\n\
    \        (maximum (rest arr) (- k 1)))\n  (cond\n    (<? (first arr) <?)\n   \
    \ (<? (first arr) <?)\n    (<? (first arr) <?)\n    (<? (first arr) <?)\n    (<?\
    \ (first arr) <?)\n    (<? (first arr) <?)\n    (maximum (rest arr) k))\n  (cond\n\
    \    (<? (first arr) <?)\n    (<? (first arr) <?)\n    (<? (first arr) <?)\n \
    \   (<? (first arr) <?)\n    (<? (first arr) <?)\n    (<? (first arr) <?)\n  \
    \  (<? (first arr) <?)\n    (maximum (rest arr) k))\n  (cond\n    (<? (first arr)\
    \ <?)\n    (<? (first arr) <?)\n    (<? (first arr) <?)\n    (<? (first arr) <?)\n\
    \    (<? (first arr) <?)\n    (<? (first arr) <?)\n    (<? (first arr) <?)\n \
    \   (maximum (rest arr) k))\n  (cond\n    (<? (first arr) <?)\n    (<? (first\
    \ arr) <?)\n    (<? (first arr) <?)\n    (<? (first arr) <?)\n    (<? (first arr)\
    \ <?)\n    (<? (first arr) <?)\n    (<? (first arr) <?)\n    (maximum (rest arr)\
    \ k))\n  (cond\n    (<? (first arr) <?)\n    (<? (first arr) <?)\n    (<? (first\
    \ arr) <?)\n    (<? (first arr) <?)\n    (<? (first arr) <?)\n    (<? (first arr)\
    \ <?)\n    (<? (first arr) <?)\n    (maximum (rest arr) k))\n  (cond\n    (<?\
    \ (first arr) <?)\n    (<? (first arr) <?)\n    (<? (first arr) <?)\n    (<? (first\
    \ arr) <?)\n    (<? (first arr) <?)\n    (<? (first arr) <?)\n    (<? (first arr)\
    \ <?)\n", "  (if (= k 0)\n      (list)\n      (let ([max-arr (maximum (rest arr)\
    \ (k-1))])\n        (append (list (max 0 (first max-arr))) max-arr))))\n", " \
    \ (sort arr (lambda (a b) (< (length a) (length b)) :key (sub (length a) (length\
    \ b)))\n         (lambda (a b) (< (car a) (car b)) :key (sub (car a) (car b)))\n\
    \         :reverse #t :key (lambda (x) (sub (length x) (car x)))\n         :reverse\
    \ #t :key (lambda (x) (sub (car x) (car x))))\n</code>\n<|/ a tags=max,list,scheme,max\
    \ |>\n<| a |>\nYou can use a fold:\n<code>", "  (cond\n    ((null? arr) '())\n\
    \    ((= (length arr) k) (list 0))\n    ((< (first arr) (- (first arr) k)) (cons\
    \ (first arr) (maximum (rest arr) (- k 1))))\n    ((>= (first arr) k) (cons (first\
    \ arr) (maximum (rest arr) (+ k 1)))))\n", "  (sort arr (\u03BB (x y) \n     \
    \         (or (< x y) \n                  (> y x))))\n  (cdr arr))\n", "  (if\
    \ (< k 0)\n      (list null)\n      (let ([max-so-far null])\n        (for-each\
    \ ([x arr]\n                    (if (= x null)\n                        (begin\n\
    \                          (set! max-so-far x)\n                          (return))\n\
    \                        (set! max-so-far (max x max-so-far))\n              \
    \          (return)))\n                    (if (= max-so-far x)\n            \
    \            (begin (set! max-so-far (+ max-so-far k)) (return) (return))\n  \
    \                      (begin\n                          (set! max-so-far x)\n\
    \                          (return)\n                          (return)))))\n\
    \        (if (= max-so-far 0)\n            (begin (set! max-so-far (+ max-so-far\
    \ k)) (return) (return))\n            (begin\n              (set! max-so-far 0)\n\
    \              (return)\n              (return))))))\n", '  (sort arr (lambda
    (x y) (if (greater x y) x y))))', "  (if (= k 0)\n      arr\n      (if (> (first\
    \ arr) (first arr (+ k 1)))\n          (cons (first arr (+ k 1)) (maximum (rest\
    \ arr) (- k 1))))\n          (maximum (rest arr) (- k 1)))))", "  (define (helper\
    \ l r k)\n    (if (>= k 0)\n        (cons (if (> r (car l)) (car l) (car r)) (helper\
    \ (cdr l) (r r (- k 1))))\n        '()))\n  (helper arr '() k))\n", "  (cond [(empty?\
    \ arr) (list '())]\n        [(< k length) (cons (car arr) (maximum (cdr arr) (-\
    \ k 1)))]\n        [else (cons (car arr) (maximum (cdr arr) k))]))\n", "  (if\
    \ (= k 0)\n      (list 0)\n      (append (sort (take arr (quotient k 2))) \n \
    \              (maximum (take arr (- k 2)) (k - 1)))))", "  (sort arr\n      \
    \  (lambda (x y) (< (- y x) k))\n        (reverse false)))\n", "  (cond [(empty?\
    \ arr) empty]\n        [else (append (max (car arr) (+ 1 k)) (maximum (cdr arr)\
    \ k)])))\n</code>\n<|/ a dscore=1 tags=scheme,lisp,racket,sicp,racket-student-language\
    \ |>\n<| a tags=scheme,lisp,racket,sicp,racket-student-language dscore=1 |>\n\
    A simple recursive version:\n<code>", "  (define (max-helper arr k result)\n \
    \   (if (= k 0)\n        (reverse result)\n        (max-helper\n         (cdr\
    \ arr)\n         (sub1 k)\n         (cons (max (car arr)) result))))\n  (max-helper\
    \ arr k '()))\n", "  (cond [(null? arr) '()]\n        [(= k (length arr)) (cons\
    \ (car arr) '())]\n        [else (maximum (cdr arr) (- k 1))]))", "  (cond [(empty?\
    \ arr) '()]\n        [(= k 0) arr]\n        [else (cons (max arr (- k 1))\n  \
    \                  (maximum arr (- k 1)))]))\n</code>\n<|/ a dscore=2 tags=scheme\
    \ |>\n<| a dscore=0 |>\nHere is another solution:\n<code>", "  (cond\n    [(<\
    \ k 0)\n     (error \"k is out of range\" 'invalid-argument)]\n    [(empty? arr)\n\
    \     (error \"empty list\" 'empty-list)]\n    [else\n     (append (list-tail\
    \ (sort arr (lambda (x y) (< (first x) (first y))))\n                     (take\
    \ k arr))\n             (maximum (rest arr) (sub1 k))]\n    )\n  )\n)", "  (cond\
    \ [(empty? arr) empty]\n        [(< k (length arr)) (cons (car arr) (maximum (cdr\
    \ arr) (sub1 k)))]\n        [else (maximum (cdr arr) (sub1 k))]))\n", "  (if (<=\
    \ k 0)\n      '()\n      (if (empty? arr)\n          '()\n          (let ((max\
    \ (car arr))\n                (arr1 (cdr arr)))\n            (cond ((= k (length\
    \ arr)) max)\n                   ((< k max) (cons max arr1))\n               \
    \    (else (maximum (append arr1 (list (max max))) k))))))", "  (cond [(null?\
    \ arr) '()]\n        [(= k 0) (cons (car arr) '())]\n        [else\n         (cons\
    \ (max arr (- k (length arr))) \n               (maximum (rest arr) (- k 1))])))\n",
  "  (define (max a b)\n    (if (< a b) a b))\n  (define (helper a b k)\n    (cond\
    \ ((> k 0) (list b)) \n          ((= a b) (list a)))\n    (if (< a b)\n      \
    \  (helper (+ a 1) b k)\n        (helper (+ b 1) a k)))\n  (helper 0 1 (sub1 k)))\n",
  "  (sort (take arr (- k 1)) (- (length arr) k)))\n", "  (cond [(empty? arr) (list)]\n\
    \        [(= (length arr) k) arr]\n        [else (append (maximum (rest arr) (-\
    \ k 1)) \n                      (list (car arr)))]))\n", "  (if (<= k 0) '()\n\
    \      (append (subst k 1 (sort (append (subst 1 k arr)) (lambda (x y) \n    \
    \      (compare x y))))\n              (maximum (rest arr) (k - 1)))))\n", " \
    \ (sort arr (lambda (x y)\n            (if (< x (car arr)) x (car arr))\n    \
    \        (if (< y (car arr)) y (car arr))))\n          (< k (length arr)))\n)\n\
    </code>\n<|/ a dscore=1 tags=racket,sorting |>\n<| c |>\nThis has quadratic performance\
    \ on large lists.\n<|/ c |>\n<| a dscore=1 |>\nAn improved version of's answer,\
    \ which works for  lists of any length:\n<code>\n#lang racket\n", "  (cond (<???>\
    \ <???> <???>)\n        ((and (<???> <???> <???>) (< k <???> <???>)) <???>)\n\
    \        (<???> <???> <???>)\n        (else (<???> <???> <???>))))\n</code>\n\
    <|/ q |>\n<| a |>\nIn general, to solve this problem you first need to recognize\
    \ that there is a binary relationship between k and arr. With this relationship\
    \ you can write k + arr which will always be the max of k and the sum of arr which\
    \ can then be used to generate the desired list of max numbers.\nWe can solve\
    \ this problem using our relationship as follows:\n\nThe relationship between\
    \ the k and arr is k-arr >= k for all valid k and arr.\nWe can solve this problem\
    \ using binary search by splitting arr in two halves until we get to the middle\
    \ and then using the relationship k-arr >= k to decide which half to split and\
    \ what to return to the calling function.\nWhen we reach the middle we split the\
    \ smaller half and recurse on the larger half. If the relation holds then arr\
    \ is greater than or equal to k and therefore the smaller half should be split\
    \ in half and the function will recurse on the larger half.\nThe recursive calls\
    \ will always return k or k + arr depending on the relation between the k and\
    \ arr.\nWe now need to decide what to do when the relation does not hold - return\
    \ k + arr or k for the smaller half.\n\nPutting this all together, we arrive at\
    \ the following solution:\n<code>", "  (if (= k 0)\n      (cons (car arr) nil)\n\
    \      (let ([max-i (+ (car arr) (maximum (cdr arr) (sub1 k)))])\n        (cond\
    \ [(< max-i 0) (maximum (cdr arr) (k (- k 1)))]\n              [else (cons (car\
    \ arr) \n                          (maximum (cdr arr) (sub1 k)))])))) \n</cell>\n\
    <text>\nmax\nA general procedure for finding the maximum element in a list. Works\
    \ by traversing each element of the list in order, comparing each element to the\
    \ maximum value we've seen, then updating the maximum value seen if the current\
    \ element is greater than the maximum.\n\nThe procedure is defined as follows:\n\
    \nmax? : List -> Number\nReturns true if and only if x is the maximum element\
    \ of l.\n\n\nA list with more than one element returns the single element as the\
    \ maximum.\n\n\nThe first element of a list is the minimum element of the list,\
    \ but is not necessarily the maximum.\n\n\n\n\n</text>\n<code language=ocaml-jupyter>\n\
    #lang racket\n", "  (let ([max-so-far 0])\n    (define (helper arr accum max-so-far)\n\
    \      (if (null? arr)\n          (if (> accum (- max-so-far k))\n           \
    \   (cons accum (- max-so-far k))\n              (cons (first arr) (helper (rest\
    \ arr) (second arr) (+ max-so-far k))))\n          (helper (rest arr) (first arr)\
    \ max-so-far)))\n    (helper arr '() max-so-far)))\n", "  (let loop ((max #f)\n\
    \             (arr arr arr arr arr arr arr arr arr arr arr arr arr arr arr arr\
    \ arr arr arr arr arr arr arr arr arr arr arr arr arr arr arr arr arr arr arr\
    \ arr arr arr arr arr arr arr arr arr arr arr arr arr arr arr arr arr arr arr\
    \ arr arr arr arr arr arr arr arr arr arr arr arr arr arr arr arr arr arr arr\
    \ arr arr arr arr arr arr arr arr arr arr arr arr arr arr arr arr arr arr arr\
    \ arr arr arr arr arr arr arr arr arr arr arr arr arr arr arr arr arr arr arr\
    \ arr arr arr arr arr arr arr arr arr arr arr arr arr arr arr arr arr arr arr\
    \ arr arr arr arr arr arr arr arr arr arr arr arr arr arr arr arr arr arr arr\
    \ arr arr arr arr arr arr arr arr arr arr arr arr arr arr arr arr arr arr arr\
    \ arr arr arr arr arr arr arr arr arr arr arr arr arr arr arr arr arr arr arr\
    \ arr arr arr arr arr arr arr arr arr arr arr arr arr arr arr arr arr arr arr\
    \ arr arr arr arr arr arr arr arr arr arr arr arr arr arr arr arr arr arr arr\
    \ arr arr arr arr arr arr arr arr arr arr arr arr arr arr arr arr arr arr arr\
    \ arr arr arr arr arr arr arr ", "  (sort (subseq arr 0 k) (lambda (x) (compare\
    \ x <???>))\n        descending: t))", "  (if (<= k 0) \n      (list 0)\n    \
    \  (let* ((pivot (car arr))\n             (max-tail (maximum (rest arr) (k - 1))))\n\
    \        (cond ((< pivot max-tail) max-tail)\n              ((<= pivot max-tail)\
    \ (cons pivot (maximum (rest arr) (sub1 k))))\n              ((> pivot max-tail)\n\
    \               (maximum (rest arr) (sub1 k)))))) \n", "  (cond\n    [(empty?\
    \ arr) (list -1)]\n    [(= k 0) (first (head arr))]\n    [(= k 1) (last (head\
    \ arr))]\n    [else (append (maximum (rest arr) (- k 1)) (list (maximum (first\
    \ arr) k)))]))\n", "  (cond ((null? arr) (list 0))\n        ((= k 0) (list arr))\n\
    \        (else (append (append (maximum (rest arr) (k-1)) \n                 \
    \             (list (first arr)))\n                     (maximum (rest arr) (sub1\
    \ k))))))\n", "  (if (or (< k 0) (> (length arr) k))\n      (list nil)\n     \
    \ (let ([head (first arr)])\n        (if (or (< head -1000)\n                \
    \ (< head 1000) \n                 (< k 1)\n                 (< (length arr) k))\n\
    \            (list head))\n        (maximum (rest arr) (sub1 k)))\n      ;; When\
    \ k equals to 0, the result must return the empty list.\n      (if (and (< k (length\
    \ arr)) (< head -1000)) (list head) (list nil))))\n", "  (if (= k 0)\n      (list\
    \ arr)\n      (let ([max (apply max (reverse arr k))]\n            [tail (maximum\
    \ (sub1 arr) k-1)])\n        (cons (max tail) (maximum (sub1 arr) (sub1 k))))))\n",
  "  (if (or (= k 0) (= (length arr) 0)) arr\n    (let ([left (maximum (rest arr)\
    \ (sub1 k))]\n          [right (maximum (rest arr) (add1 k))])\n      (cons (max\
    \ left right) (rest arr)))))\n", "  (if (null? arr)\n      '()\n      (if (= k\
    \ 0)\n          (cons (car arr) (maximum (cdr arr) (sub1 k)))\n          (maximum\
    \ (cdr arr) (sub1 k))))))\n", "  (let loop ((lst lst)\n             (max -1000))\n\
    \    (if (or (< k 0) (null? lst))\n        (list max)\n        (let ([e (car lst)])\n\
    \          (if (> e max)\n              (set! max (car lst))\n              (loop\
    \ (cdr lst) (max e)))))))\n", "  (let recur ((max -inf)\n             (arr arr))\n\
    \    (cond ((< k 0)\n           (reverse arr))\n          ((< 0 (length arr))\
    \ (reverse (list max)))\n          ((< 0 (- (length arr) k)) (recur (max (car\
    \ arr) (- k 1))\n                                       (cdr arr)))\n        \
    \  ((> (length arr) k) (recur (max (car arr) (- k (- (length arr) k)))\n     \
    \                                 (cdr arr)))\n          ((> (length arr) (+ k\
    \ 1)) (recur (max (car arr) k)\n                                        (cdr arr)))\n\
    \          ((> k 0) (recur (max (car arr) (- k 1))\n                       (cdr\
    \ arr)))))\n</code>\n<|/ a |>\n<| c |>\nThis doesn't work, try it with your examples\
    \ again.  (I get a \"stack overflow\".)\n<|/ c |>\n<| c |>\nThis also doesn't\
    \ work.  I get a \"stack overflow\" error when I try it with the examples I gave.\
    \  Also, I didn't realize that I could simply call `reverse` on an infinite list!\
    \  Nice.  (+1 for that, but I'm accepting Thomas' answer since he was a little\
    \ earlier.  Thanks anyway.)\n<|/ c |>\n<| c |>\nIt's strange you get that error.\
    \ I tested it and it works for me. Make sure you are typing exactly the same code\
    \ I gave you, with the exception of my changes. By the way, I did some research\
    \ and found the exact same solution to this problem in section 7.3.2 of [The Scheme\
    \ Programming Language](http://www.scheme.com/tspl3/chapter7.html). In section\
    \ 7.3.2 they explain the `max` procedure for lists. I added my answer to this\
    \ question to show the solution as well.\n<|/ c |>\n<| c |>\nYeah, I just found\
    \ that section as well.  I didn't realize that you can put `reverse` on infinite\
    \ lists, though.  Oh, and I noticed you changed your `max` to `max-infinity`.\
    \  That's interesting too!  Thanks!\n<|/ c |>\n<| a tags=racket,scheme |>\nThis\
    \ works:\n<code>", "  (if (= k 0)\n      (list max)\n      (let ([max-list (maximum\
    \ (rest arr) (k-1))])\n        (if (null? max-list)\n            (list max)\n\
    \            (append max-list (list (max arr (car max-list))) )))))\n", "  (cond\n\
    \    [(empty? arr) empty]\n    [(= k 0) (first arr)]\n    [else (maximum (rest\
    \ arr) (sub1 k))]))\n", "  (define (loop lst curr)\n    (if (null? lst)\n    \
    \    lst\n        (if (< (length lst) k)\n            (loop (rest lst) (max curr\
    \ first (first lst)))\n            (loop (rest lst) curr))))\n  (loop arr 0))\n",
  "  (cond\n    [(empty? arr) (list -1)]\n    [(= k (length arr)) (sort arr)]\n  \
    \  [else (append (maximum (rest arr) (sub1 k)) (maximum (first arr) (sub1 k)))]))\n",
  "  (sort (subseq arr 0 k) ; O(n) \n        :key (lambda (x)\n               (max\
    \ (- x 1000) 0) ; O(log n)\n               (< x 1000) ; O(log n)\n           \
    \    (< (- x) 1000))) ; O(log n)\n        :reverse #f)) ; O(n log n) \n</code>\n\
    <|/ a dscore=2 tags=racket,scheme,max |>\n<| c |>\nO(n) solution is good, but\
    \ not good enough. It works ok for small lists, but for large lists it takes a\
    \ huge amount of time\n<|/ c |>\n<| c |>\n, why do you think so? It works for\
    \ me, giving a runtime of 0.5 seconds for a list of 1 million integers.\n<|/ c\
    \ |>\n<| a dscore=1 |>\nHere is one solution in Racket:\n<code>", "  (cond\n \
    \   ((or (zero? k) (null arr))\n     (list* k nil))\n    ((= (length arr) k)\n\
    \     (reverse (cons (car arr) nil)))\n    ((< k 0)\n     (maximum (rest arr)\
    \ (k - 1)))\n    (else (append (maximum (rest arr) (quotient k 2))\n         \
    \        (cons (car arr) (maximum (rest arr) (quotient k 2)))))))\n", "  (cond\
    \ [(empty? arr) empty]\n        [(equal? (first arr) -inf) (first arr)]\n    \
    \    [else (cons (maximum (rest arr) (sub1 k)) (maximum (rest arr) (sub1 k)))]\n\
    \        ))\n", "  (cond\n    [(empty? arr) empty]\n    [(= k 0) (first arr)]\n\
    \    [(= k 1) (first arr)]\n    [else (cons (max (rest arr) k)\n             \
    \    (maximum (rest arr) (sub1 k)))]))\n", "  (if (or (= 0 (length arr)) (< k\
    \ (length arr)))\n      '()\n      (append (sort (take arr k)) (maximum (drop\
    \ arr k) (- k 1)))))\n", "  (if (<= k 0)\n      (list arr)\n      (let ([largest\
    \ (car arr)])\n        (if (> k 0)\n            (if (< largest largest)\n    \
    \            (cons largest largest)\n                (maximum (cdr arr) (sub1\
    \ k)))\n            (maximum (cdr arr) k))))))\n", "  (cond [(empty? arr) '()]\n\
    \        [else (let ([max (first arr)])\n                (if (< k 0)\n       \
    \             (maximum (rest arr) (- k 1))\n                    (if (< max max)\n\
    \                        (cons max max)\n                        (maximum (rest\
    \ arr) (- k 1))))\n                (maximum (rest arr) 0))]))\n", "  (let ((max-list\
    \ (make-empty-queue (ceiling (length arr) k))))\n    (for-each\n     (lambda (x)\n\
    \       (cond ((= (length arr) 0)\n               (push (max x 0) max-list))\n\
    \             ((> x arr (car max-list))\n               (push (max x 0) max-list))\n\
    \             ((= x arr (car (car max-list)))\n               (push (max x 0)\
    \ max-list))\n             (else (push (max x 0) max-list))\n           ))\n \
    \    max-list)\n   )\n  )", "  (if (= k 0)\n      (list 0)\n      (append (maximum-aux\
    \ (car arr) (cdr arr) k) (maximum-aux arr (cdr arr) (sub1 k))))) \n", "  (cond\n\
    \    ((null? arr) '())\n    ((= k 0) (first arr))\n    ((< k 0) (maximum (rest\
    \ arr) (sub1 k)))\n    (else (maximum (rest arr) (sub1 k)) (first arr))\n    ))\n",
  "  (if (= k 0)\n      arr\n      (maximum (max (car arr) (cadr arr)) (sub1 k))))\n",
  "  (define (helper-max-helper arr k max-helper)\n    (cond\n      [(empty? arr)\
    \ max-helper]\n      [(< k (length arr)) (helper-max-helper\n                \
    \               (append arr (list max-helper))\n                             \
    \  (- k 1)\n                               (first arr))]\n      [(> k (length\
    \ arr)) (helper-max-helper\n                               (append max-helper\
    \ (list arr))\n                               (- k 1)\n                      \
    \         (first arr))]\n      [else (helper-max-helper\n              (append\
    \ arr (list max-helper))\n              k\n              (first arr))]\n     \
    \ ))\n  (helper-max-helper arr k #f))\n                          ", "  (cond\n\
    \    ((< k 0) (error \"k should be greater than 0\"))\n    ((= k 0) (list 0))\n\
    \    ((= (length arr) 0) (error \"arr should be not empty\"))\n    ((= k 1) arr)\n\
    \    ((< k (length arr)) (maximum-aux (take-k arr (- k 1)) k))\n    (else (maximum-aux\
    \ (take-k arr (- k 1)) k))))\n", "  (if (= k 0)\n      (list)\n      (let ((max-k\
    \ (car arr))\n            (new-arr (cdr arr)))\n        (if (> k max-k)\n    \
    \        (maximum (new-arr (- k 1))\n                      (- k 1))\n        \
    \    (append (list max-k)\n                    (maximum (new-arr k)\n        \
    \                     (- k 1))))))) ;; #lang racket\n", "  (sort arr >\n     \
    \     (lambda (x y)\n            (<= (length x) k)\n            (<= (length y)\
    \ k))))\n</code>\n<|/ a tags=scheme dscore=0 |>\n<| a tags=scheme |>\nThis is\
    \ a fairly straightforward extension to your previous answer that makes it easy\
    \ to generalize the solution by making use of Racket's built-in sort! procedure.\
    \  Specifically, the idea is to create a function that will call sort! with a\
    \ function that compares the current element to all other elements in the list.\
    \  \nThe function will be called for each element of the list until it fails to\
    \ compare the current element with any other element.  For each element, it calls\
    \ itself recursively on the list but with only those elements that should be considered\
    \ when doing the comparison.  \nFinally, once all the elements are considered,\
    \ the sort! procedure will be called on the list to sort it according to the specified\
    \ predicate.\n<code>", "  (if (= k 0)\n      (list 0)\n      (let ([head (first\
    \ arr)])\n        (if (empty? arr)\n            (list (max head (first arr)))\n\
    \            (let ([next-head (maximum (rest arr) (k - 1))])\n              (if\
    \ (< head next-head)\n                  (cons head (cons next-head (cons (max\
    \ head (first arr)) \n                                              (list k)))\n\
    \                  (cons head (cons next-head (list k))))))))\n</code>\n<|/ a\
    \ tags=functional-programming,scheme |>\n<| a dscore=1 |>\n<code>", "  (letrec\
    \ ([helper (lambda (i arr k ans)\n                    (if (< k 0) ans \n     \
    \                   (helper (+ i 1) arr (- k i) (rest ans))))])\n    (if (< k\
    \ 0) (list nil) \n      (helper (length arr) arr k (reverse (helper 0 arr k (rest\
    \ ans)))))))\n", "  (define (helper-maximum-k num-greater-ks max-k arr)\n    (if\
    \ (> max-k k)\n        (cons max-k (helper-maximum-k (cdr num-greater-ks) max-k\
    \ (car arr)))\n        (if (null? num-greater-ks)\n            (cons (car arr)\
    \ max-k)\n            (helper-maximum-k (cdr num-greater-ks) max-k (car arr)))))\n\
    \  (helper-maximum-k arr k arr))\n", "  (if (= k 0) arr\n      (let ([head (car\
    \ arr)])\n        (maximum (cdr arr) (sub1 k)) ;; recur\n        (if (> head (max\
    \ head (max head))) head (max head (max head)))\n        (if (< k 1) (list head)\
    \ \n            (append (maximum (append head (list head)) (sub1 k)) (list head))))))\n",
  "  (let* ((l (length arr))\n         (r (range -1000 (sub1 l))))\n    (if (= k l)\n\
    \        (reverse arr)\n        (let ((max-so-far (first (sort (cdr (take k arr)))\n\
    \                                  (< 0 (sub1 k))))\n              (next-max-so-far\
    \ (second (sort (cdr (take k arr)))\n                                    (< 0\
    \ (sub1 k))))\n              (next-max (if (<= k l)\n                        \
    \   (maximum arr (sub1 k))\n                           (maximum arr k)))\n   \
    \       (cond (null? max-so-far)\n                 ;; All elements of arr are\
    \ less than or equal to max-so-far.\n                 (cons max-so-far next-max-so-far)\n\
    \                 ;; All elements of arr are equal to max-so-far.\n          \
    \       (list max-so-far next-max-so-far)\n                 ;; All elements of\
    \ arr are greater than max-so-far.\n                 (cons max-so-far next-max-so-far)\n\
    \                 ;; Some elements of arr are greater than max-so-far but\n  \
    \               ;; not all of arr. Add next-max to the beginning of max-so-far.\n\
    \                 (cons next-max max-so-far)\n                 ;; Some elements\
    \ of arr are less than or equal to max-so-far.\n                 (cons max-so-far\
    \ next-max)\n                 ;; None of arr are greater than or equal to max-so-far.\n\
    \                 (list max-so-far next-max)))))", "  (let ([i 0]\n        [max\
    \ 0])\n    (if (< k i)\n        (recur (+ i 1) max)\n        (if (= max 0)\n \
    \           (append (sublist arr 0 k) (sublist arr (+ i 1) k))\n            (append\
    \ (sublist arr 0 max) (sublist arr (+ i 1) max)))))\n</code>\n<|/ a tags=racket,scheme,lisp\
    \ |>\n<| a |>\nThis is probably not the best approach, but I'll keep it for now.\
    \ This code is in Scheme but I'm sure the function will look similar in other\
    \ programming languages.\n<code>", "  (cond [(< k 0) (list (car arr))]\n     \
    \   [(> (length (rest arr)) k) (maximum (rest arr) k)]\n        [else (cons (max\
    \ (car arr) (- k 1)) (maximum (cdr arr) k))]\n    )\n)\n", "  (if (<= k 1)\n \
    \     (append (list arr) (list (first arr))) \n      (append (list (first arr))\
    \ (list (max (rest arr) k)))))", "  (let* ((arr (sort arr))\n         (tail (rest\
    \ arr))\n         (max (reverse (apply max arr tail)))\n         (maxes (apply\
    \ append (subseq arr (+ k 1))\n                          (list max)))\n      \
    \   (max (apply max maxes))\n         (maxes (map max maxes (subseq arr 0 k))))\n\
    \    (append (subseq arr 0 k) max)))\n", "  (if (= k 0)\n      (cons (car arr)\
    \ '())\n      (append (maximum (cdr arr) (- k 1))\n              (list (maximum\
    \ (cdr arr) (- k 1))))\n      )\n  )\n", "  (cond\n    ((zero? k) '())\n    ((zero?\
    \ (cdr arr)) (cons (car arr) (maximum (cdr arr) (k - 1))))\n    (else (cons (car\
    \ arr)\n              (maximum (cdr arr) (sub1 (car arr)))))\n    )\n  )\n)\n",
  "  (let ((max (car arr))\n        (j (car (remove-duplicates arr)))\n        (i\
    \ 0))\n    (cond\n      [(empty? j) empty]\n      [(= i k) (list max)]\n     \
    \ [(>= max j) (list (car j))]\n      [(<= max j) (maximum (append (remove (list\
    \ max) j) arr) (- k 1))]\n      [else (maximum (append (remove (list max) j) arr)\
    \ (+ k 1))])))\n", "  (check-type arr list)\n  (check-type k integer)\n  (cond\
    \ [(empty? arr) '()]\n        [(= 0 (length arr)) (cons (first arr) (maximum (rest\
    \ arr) (sub1 k)))]\n        [else (cons (max (first arr) (maximum (rest arr) (sub1\
    \ k))))\n               (maximum (rest arr) (sub1 k))]))", "  (cond [(empty? arr)\
    \ empty]\n        [(= k 0) (first arr)]\n        [else (let ([max (first arr)])\n\
    \                   (append (maximum (rest arr) (k-1))\n                     \
    \     (list max)))]))\n", "  (if (= k 0)\n      (list 0)\n      (append (maximum\
    \ (rest arr) (k-1))\n              (list (first arr)))))\n", "  (cond [(null?\
    \ arr) empty]\n        [(= k 0) (first arr)]\n        [else (cons (first (maximum\
    \ arr (- k 1))) (maximum (rest arr) (- k 1))))]))\n", "  (if (= k (length arr))\n\
    \      (list arr)\n      (append (list-tail arr (sub1 (length arr)) k) (list-tail\
    \ (maximum (list-tail arr (sub1 (length arr)) k)) (sub1 k 1)))))", "  (if (= k\
    \ 0)\n      '()\n      (cond [(< k (length arr)) arr]\n            [(= k (length\
    \ arr)) '()]\n            [else (cons (max (rest arr) k) (maximum (rest arr) (sub1\
    \ k)))])))\n</code>\n<|/ a tags=lisp,scheme dscore=1 |>\n<| a tags=lisp,scheme\
    \ |>\nThis seems to work for me:\n<code>", "  (sort arr (lambda (x y) (if (< (car\
    \ x) (car y)) -1 1)))\n    (reverse (range 1 k))))\n", "  (cond ((zero? k) (list\
    \ arr))\n        ((< k 0) (error \"k should be in the range of (0, len(arr))\"\
    ))\n        ((< 0 (car arr))\n         (maximum (car arr) (sub1 k)))\n       \
    \ (else (append (maximum (car arr) (sub1 k)) (maximum (cdr arr) (sub1 k)))))\n\
    \  )\n", "  (cond\n    [(empty? arr) (list empty)]\n    [(= 0 k) (list arr)]\n\
    \    [(= (length arr) k) (list arr)]\n    [else (cond\n             [(< k 0) (cons\
    \ (first arr) (maximum (rest arr) (- k 1)))]\n             [(>= k 0) (cons (first\
    \ arr) (maximum (rest arr) (- k 1))) (cons (first arr) (maximum (rest arr) (-\
    \ k 1)))]\n             [else (cons (first arr) (maximum (rest arr) (- k 1)))]))]))\n",
  "  (let ([m1 (- 1000)])\n    (if (= k 0)\n        (list)\n        (let ([m (max\
    \ m1 (car arr))])\n          (if (= m m1)\n              (list m)\n          \
    \    (cons m (maximum (cdr arr) (sub1 k))))))))\n", "  (define (loop n lst)\n\
    \    (if (< n k)\n        lst\n        (loop (+ n 1) (append (list n) lst))))\n\
    \  (loop 1 '()))\n", "  (define (helper l accum k)\n    (if (null? l)\n      \
    \  (append accum [(sub1 (car l) k)]) \n        (helper (cdr l) (append accum [(max\
    \ (car l) k)]) k))) \n  (helper arr [] k))\n", "  (if (= k 0)\n      (cons (car\
    \ arr)\n            (maximum (cdr arr) (sub1 k)))\n      (maxium (cdr arr)\n \
    \              (cons (car arr)\n                     (maximum (cdr arr) (sub1\
    \ k))))))\n", "  (cond\n    ((> (length arr) k) #f)\n    ((<= k 0) '())\n    (else\
    \ (let ([max '()])\n      (cond\n        ((null? arr) (cons max max))\n      \
    \  ((< (car arr) max) \n         (cons (car arr) (maximum (cdr arr) (k - 1))))\n\
    \        (else (cons (car arr) max)))))))\n", "  (cond\n    [(empty? arr) (list\
    \ 0)]\n    [(= k (length (rest arr)))\n     (cons (first arr) (maximum (rest arr)\
    \ (sub1 k)))]\n    [else (maximum (rest arr) (sub1 k))]))\n", "  (if (= k 0) (list\
    \ arr) (append (sort arr (< arr (car arr))) (maximum (sort (cdr arr) (> arr (car\
    \ arr)) k))))) ; \n</code>\n<|/ a tags=racket,scheme |>\n<| a dscore=1 |>\nI got\
    \ it working, sort by length first, then by maximum value. Just had to change\
    \ some code around, though.\n<code>", "  (cond\n    [(null? (rest arr)) (list\
    \ (last arr))] \n    [(>= (length arr) k) (list arr)]\n    [(< k (length arr))\
    \ (append (sort (take (- k k) arr)) (list (last arr)))]\n    [else (append (sort\
    \ (take k arr)) (list (last arr)))]))\n</code>\n<|/ a tags=lisp,racket,scheme\
    \ |>\n<| a tags=lisp,racket,scheme |>\nThis is not an answer per se, but I am\
    \ putting this here, because the question is not exactly what you are looking\
    \ for. Hence, I am putting it here.\nI do not know much about scheme, yet I came\
    \ across this question. I had to implement a function to return the maximum of\
    \ a list with n numbers, in racket, scheme using only cons cells and recursion.\
    \ So, I had to make a helper function max_of_list that returns a list with as\
    \ many elements as it has to contain the maximum of its input list and a number,\
    \ called num. \nMy solution is the following:\n<code>", "  (cond\n    [(empty?\
    \ arr) empty]\n    [(= (length arr) k) (cons (first arr) (maximum (rest arr) 1))]\n\
    \    [else (cons (max (first arr) (maximum (rest arr) (- k 1))) (maximum (rest\
    \ arr) (- k 1)))]))\n", "  (cond\n    [(empty? arr) (list)]\n    [(null? (rest\
    \ arr)) (list arr)]\n    [(= k (length arr)) (sort arr (reverse empty))]\n   \
    \ [else (append (sort (max arr (cdr arr)) (reverse empty)) (maximum (rest arr)\
    \ (sub1 k)))]))\n</code>\n<|/ a dscore=0 |>\n<| c |>\nI cannot understand how\
    \ the answer can return a list of `k` max numbers, but not just the max number.\
    \ Could you explain more?\n<|/ c |>\n<| c |>\nThanks for your answer. I found\
    \ a simpler answer without using sort and append.\n<|/ c |>\n<| a dscore=0 tags=scheme\
    \ |>\nI found a simpler answer without using sort and append.\nThe max function\
    \ below is a recursive function. It receives a list and two parameters, the first\
    \ one being the maximum number of the list while the second one is the current\
    \ number of recursion.\nIf the second number is less than k, then it returns the\
    \ list. If the second number is greater than k, the list must be reversed and\
    \ recursively call the function with the new list and k-1.\nIf the second number\
    \ is equal to k, it returns the list.\n<code>", "  (cond [(null? arr) '()]\n \
    \       [(= k 0) arr]\n        [(< k 0) (list '() arr)]\n        [else (append\
    \ (append (list (first arr)) (list (first arr)))\n                      (maximum\
    \ (rest arr)\n                              (- k 1))]))))\n", "  (sort (list arr)\
    \ >\n        lambda (x y)\n        (cond\n          ((< (cdr x) (cdr y)) y)\n\
    \          ((> x y) x)\n          (else (max (cdr x) (cdr y))))))\n</code>\n<|/\
    \ a tags=scheme,racket,sorting |>\n<| a tags=scheme,racket,sorting |>\n<code>",
  "  (sort arr > (lambda (x) (sub1 (+ (- x (first arr)) (length arr))))\n    (< k\
    \ k #t)\n    (lambda (x) (sub1 (+ (- x (first arr)) (length arr))))))\n</code>\n\
    <|/ a |>\n<| c |>\nI added my own solution using recursion and it seems to be\
    \ working fine. Thanks guys.\n<|/ c |>\n<| c |>\n: How can this be improved? Ask\
    \ a new question.\n<|/ c |>\n<| c |>\nI am not sure about it. I also thought about\
    \ posting it as an answer, but since I haven't tested it I thought that it's better\
    \ to ask here.\n<|/ c |>\n<| a dscore=1 |>\nThis works (for my definition of \"\
    max\"). It also uses tail recursion, instead of recursion that might overflow\
    \ the stack.\n<code>", "  (if (zero? k)\n      arr\n      (if (> (length (subseq\
    \ (reverse arr) 0 k)) k)\n          (cons (first arr)\n                (maximum\
    \ (rest arr) (- k 1))) ; note reversal is required\n          (maximum (rest arr)\
    \ (- k 1)))))\n", "  (if (= k 0)\n      (list 0)\n      (let ([x (car arr)])\n\
    \        (if (> (car arr) x)\n            (cons (car arr) (maximum (cdr arr) (sub1\
    \ k)))\n            (maximum (cdr arr) (sub1 k))))))\n", "  (if (or (< k 0) (null?\
    \ arr))\n      (list -1)\n      (append (max (rest arr) k) (maximum (cdr arr)\
    \ (- k 1)))))\n", "  (if (= k 0)\n      (reverse arr)\n      (let loop ((lst (sub1\
    \ (maximum-helper arr k))))\n        (cond\n          ((= (length lst) k) lst)\n\
    \          ((> k 0)\n           (loop (sub1 (maximum-helper arr (sub1 k))))))))\n",
  "  (cond\n    [(empty? arr) '()]\n    [(= k (length arr)) (cons (car arr) '())]\n\
    \    [else (cons (car arr) (maximum (cdr arr) (sub1 k)))]))\n", "  (if (= k 0)\n\
    \      arr\n      (cons (max (first arr) (maximum (rest arr) (sub1 k)))\n    \
    \        (maximum (rest arr) (sub1 k))))) \n", "  (let ([num (max arr (length\
    \ arr))])\n    (if (= k num)\n        (reverse arr)\n        (let ([max-i (sub1\
    \ (maximum-helper (sub1 arr) k)))]\n          (append (maximum-helper arr (sub1\
    \ k)) (list max-i)))))\n</code>\nThe function maximum-helper is used recursively\
    \ and has two cases:\n\nWhen the length of the array is equal to k, then the return\
    \ list will be the same as the input array.\nWhen the length of the array is not\
    \ equal to k, then we will calculate the max value of the last k numbers and append\
    \ it to the input array and return the resulting array.\n<|/ a dscore=1 tags=scheme,racket\
    \ |>\n<| a dscore=0 |>\nHere is the solution I came up with.  A variation of this\
    \ solution works for the case when k is negative or when k is greater than the\
    \ length of the list.  It also works in the case where k is 0 or less.\n<code>",
  "  (cond\n    [(empty? arr) (list nil)]\n    [(= k (length arr)) (cons (car arr)\
    \ (list nil))]\n    [else (let ([max-list (sub (length arr) k)\n             \
    \         max-index (first max-list)])\n             (append (sub (cdr max-list)\
    \ max-index)\n                     (maximum (sub (car max-list)\n            \
    \                     max-index)\n                          (sub (+ 1 k) k))))]))\n",
  "  (let loop ((arr arr) (k k))\n    (if (= k 0)\n        (reverse arr)\n       \
    \ (loop (append (take (elt arr (sub1 k)) arr) (maximum (elt arr (sub1 k)) (sub1\
    \ k)))\n              (sub1 k)))\n    ))\n", "  (cond\n    [(empty? arr) '()]\n\
    \    [else (cons (max (rest arr)) (maximum (rest arr) k))]))", "  (cond\n    [(empty?\
    \ arr) (list ())]\n    [(= k (length arr)) (list arr)]\n    [else (append (list\
    \ (car arr)) (maximum (cdr arr) (- k 1))))]))\n", "  (if (null? arr) \n      (list\
    \ '()) \n      (let ((largest (car arr)) (largest-index (car arr)))\n        (cond\
    \ \n          ((< k largest-index) (append largest (maximum (cdr arr) (add1 k))))\
    \ \n          ((= k largest-index) (list largest)) \n          (t (maximum (cdr\
    \ arr) (add1 k))) ))))\n", "  (sort arr\n        (lambda (x y)\n          (if\
    \ (< (length x) k)\n              (cons x y)\n              (cons y (cons x nil))))))\n\
    </code>\n<|/ a dscore=2 tags=scheme |>\n<| a |>\nThe solution posted by user5402\
    \ doesn't work if the list contains negative numbers.\nThe solution is to use\
    \ the sort function in Scheme. It will find the maximum in the list and return\
    \ the result in a new list. The sort function will sort the list according to\
    \ the supplied function.\n<code>", "  (if (null? arr)\n      (list '())\n    \
    \  (let ([largest (first arr)])\n        (if (= k (length arr))\n            (append\
    \ (list (max largest (first arr)))\n                    (maximum (rest arr) (sub1\
    \ k)))\n            (append (list (max largest (first arr)))\n               \
    \     (maximum (rest arr) (sub1 k))\n                    (maximum (rest arr) (sub1\
    \ k))))))\n", "  (cond\n    [(empty? arr) empty]\n    [(= k 0) (first arr)]\n\
    \    [else (maximum (rest arr) (- k 1))]))\n</code>\n<|/ a tags=scheme,racket,max,list\
    \ |>\n<| c |>\nThe second last line should read `(maximum (rest arr) (- k 1))`\
    \ instead of `(maximum (rest arr) (- k (length arr)))`. Otherwise you are just\
    \ taking k times the length of the list.\n<|/ c |>\n<| a dscore=1 |>\nAn alternate\
    \ solution which uses sorting:\n<code>", "  (cond [(null? arr) (list -1)]\n  \
    \      [(= k 0)(list -1)]\n        [(= k (length arr))(list)]\n        [(= 0 (remainder\
    \ k 1))\n         (cons (max (cdr arr) (k - 1))\n              (append (list (car\
    \ arr)))\n              (maximum (cdr arr) (k - 1)))]\n        [else (cons (max\
    \ (car arr) k)\n                    (append (list (car arr)))\n              \
    \      (maximum (cdr arr) k))]))\n", "  (cond\n    [(empty? arr) empty]\n    [(=\
    \ k (length arr)) arr]\n    [else (append (take arr (floor (/ k 2))) (maximum\
    \ (drop arr (floor (/ k 2))) (- k 2))]\n    )\n  )\n)"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
