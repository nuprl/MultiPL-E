name: HumanEval_156_int_to_mini_roman
language: rkt
prompt: "#lang racket\n\n;; Given a positive integer, obtain its roman numeral equivalent\
  \ as a string,\n;; and return it in lowercase.\n;; Restrictions: 1 <= num <= 1000\n\
  ;; Examples:\n;; >>> (int_to_mini_roman 19)\n;; \"xix\"\n;; >>> (int_to_mini_roman\
  \ 152)\n;; \"clii\"\n;; >>> (int_to_mini_roman 426)\n;; \"cdxxvi\"\n(define (int_to_mini_roman\
  \ number)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate int_to_mini_roman))\n\
  \    (check-equal? (candidate 19) \"xix\")\n    (check-equal? (candidate 152) \"\
  clii\")\n    (check-equal? (candidate 251) \"ccli\")\n    (check-equal? (candidate\
  \ 426) \"cdxxvi\")\n    (check-equal? (candidate 500) \"d\")\n    (check-equal?\
  \ (candidate 1) \"i\")\n    (check-equal? (candidate 4) \"iv\")\n    (check-equal?\
  \ (candidate 43) \"xliii\")\n    (check-equal? (candidate 90) \"xc\")\n    (check-equal?\
  \ (candidate 94) \"xciv\")\n    (check-equal? (candidate 532) \"dxxxii\")\n    (check-equal?\
  \ (candidate 900) \"cm\")\n    (check-equal? (candidate 994) \"cmxciv\")\n    (check-equal?\
  \ (candidate 1000) \"m\")\n))\n\n(test-humaneval)"
completions: ["  (cond\n    ((< 1 number)\n     (string-append \"-1\"\n          \
    \     (string-to-int (substring (string-append \"I\" (string->list (string->char\
    \ (char->list 'M)))) number 1))))\n    ((< 10 number)\n     (string-append \"\
    X\"\n               (int_to_mini_roman number)))\n    ((< 100 number)\n     (string-append\
    \ \"C\"\n               (int_to_mini_roman number)))\n    ((< 1000 number)\n \
    \    (string-append \"D\"\n               (int_to_mini_roman number)))\n    ((<\
    \ 10000 number)\n     (string-append \"M\"\n               (int_to_mini_roman\
    \ number)))\n    ((< 1000000 number)\n     (string-append \"M\"\n            \
    \   (int_to_mini_roman number)))\n    ((< 1000000000 number)\n     (string-append\
    \ \"B\"\n               (int_to_mini_roman number)))\n    ((< 1000000000000 number)\n\
    \     (string-append \"B\"\n               (int_to_mini_roman number)))\n    ((<\
    \ 1000000000000000 number)\n     (string-append \"I\"\n               (int_to_mini_roman\
    \ number)))\n    ((< 100000000000000000 number)\n     (string-append \"I\"\n \
    \              (int_to_mini_roman number)))\n    ((< 1000000000000000000 number)\n\
    \     (string-append \"V\"\n               (int_to_mini_roman number)))\n    ((<\
    \ 1000000000000000000000 number)\n     (string-append \"X\"\n               (int_to_mini_roman\
    \ number)))\n    ((< 1000000000000000000000000 number)\n     (string-append \"\
    C\"\n               (int_to_mini_roman number)))\n    ((< 100000000000000000000000000\
    \ number)\n     (string-append \"C\"\n               (int_to_mini_roman number)))\n\
    \    ((< 100000000000000000000000000000 number)\n     (string-append \"C\"\n \
    \              (int_to_mini_roman number)))\n    ((< 100000000000000000000000000000000\
    \ number)\n     (string-append \"C\"\n               (int_to_mini_roman number)))\n\
    \    ((< 10000000000000000000000000000000000 number)\n     (string-append \"C\"\
    \n               (int_to_mini_roman number)))\n    ((< 10000000000000000000000000000000000000\
    \ number)\n     (string-append \"C\"\n               (int_to_mini_roman number)))\n\
    \    ((< 10000000000000000000000000000000000000000 number)\n     (string-append\
    \ \"C\"\n               (int_to_mini_roman number)))\n    ((< 100000000000000000000000000000000000000000\
    \ number)", "  (cond [(< number 1)\n         (make-string (- number 1) #\\0)]\n\
    \        [(< number 1000)\n         (string-append (int_to_mini_roman 1000) (mini_roman_numeral_string\
    \ number))]\n        [(= (modulo number 1000) 0)\n         (string-append (int_to_mini_roman\
    \ 1000) (mini_roman_numeral_string (quotient number 1000))\n                 \
    \     (mini_roman_numeral_string (- number (quotient number 1000))))]))\n", " \
    \ (let loop ((i number)\n             (result '()))\n    (if (= i 0)\n       \
    \ result\n        (loop (sub1 i) (cons (cond [(< i 19) (char 'x)\n           \
    \                        (> i 20) (char 'i)]\n                               \
    \ [(< i 39) (char 'c)\n                                   (> i 40) (char 'l)]\n\
    \                                [(< i 59) (char 'd)\n                       \
    \            (> i 60) (char 'm)]\n                                [(< i 89) (char\
    \ 'x)\n                                   (> i 90) (char 'l)]\n              \
    \                  [(< i 99) (char 'x)\n                                   (>\
    \ i 100) (char 'x)]\n                                [(< i 999) (char (sub1 (modulo\
    \ i 100)))\n                                   (> i 1000) (char ?s)]) result))))))\n",
  "  (cond\n    [(or (not (number)) (< number 0))\n     (error 'int_to_mini_roman\
    \ \"Not a valid number: '~a'.\" number)]\n    [(= number 0)\n     (error 'int_to_mini_roman\
    \ \"Not a valid number: '~a'.\" number)]\n    [(< number 1000)\n     (cond [(=\
    \ (number) (1+ number))\n            (return \"x\")]\n            [(= (number)\
    \ (2+ number))\n            (return \"xu\")]\n            [(= (number) (3+ number))\n\
    \            (return \"ix\")]\n            [else\n            (error 'int_to_mini_roman\
    \ \"Not a valid number: '~a'.\" number)]])]\n    [else\n    (cond [(= (number)\
    \ (10+ number))\n           (return \"c\")]\n           [else\n           (error\
    \ 'int_to_mini_roman \"Not a valid number: '~a'.\" number)]]))\n", "  (define\
    \ (helper num remainder acc)\n    (cond\n      [(= 0 remainder) acc]\n      [(=\
    \ 1 remainder) (helper num (- remainder) (cons acc '()))]\n      [(= 2 remainder)\
    \ (helper num (- remainder) (cons 'a acc))]\n      [(= 3 remainder) (helper num\
    \ (- remainder) (cons 'b acc))]\n      [(= 4 remainder) (helper num (- remainder)\
    \ (cons 'c acc))]\n      [(= 5 remainder) (helper num (- remainder) (cons 'd acc))]\n\
    \      [(= 6 remainder) (helper num (- remainder) (cons 'e acc))]\n      [(= 7\
    \ remainder) (helper num (- remainder) (cons 'f acc))]\n      [(= 8 remainder)\
    \ (helper num (- remainder) (cons 'g acc))]\n      [(= 9 remainder) (helper num\
    \ (- remainder) (cons 'h acc))]\n      [(<= 10 remainder) (helper num (- remainder)\
    \ (cons 'i acc))]\n      [(<= 11 remainder) (helper num (- remainder) (cons 'j\
    \ acc))]\n      [(<= 12 remainder) (helper num (- remainder) (cons 'k acc))]\n\
    \      [(<= 13 remainder) (helper num (- remainder) (cons 'l acc))]\n      [(<=\
    \ 14 remainder) (helper num (- remainder) (cons 'm acc))]\n      [(<= 15 remainder)\
    \ (helper num (- remainder) (cons 'n acc))]\n      [(<= 16 remainder) (helper\
    \ num (- remainder) (cons 'o acc))]\n      [(<= 17 remainder) (helper num (- remainder)\
    \ (cons 'p acc))]\n      [(<= 18 remainder) (helper num (- remainder) (cons 'q\
    \ acc))]\n      [(<= 19 remainder) (helper num (- remainder) (cons 'r acc))]\n\
    \      [(<= 20 remainder) (helper num (- remainder) (cons 's acc))]\n      [(<=\
    \ 21 remainder) (helper num (- remainder) (cons 't acc))]\n      [(<= 22 remainder)\
    \ (helper num (- remainder) (cons 'u acc))]\n      [(<= 23 remainder) (helper\
    \ num (- remainder) (cons 'v acc))]\n      [(<= 24 remainder) (helper num (- remainder)\
    \ (cons 'w acc))]\n      [(<= 25 remainder) (helper ", "  (cond [(< number 0)\
    \ \"\"]\n        [(< number 1000) (cond [(< number 10) \"vi\"]\n             \
    \                 [(< number 90) \"lx\"]\n                              [(< number\
    \ 80) \"c\"]\n                              [(< number 70) \"d\"]\n          \
    \                    [(< number 60) \"x\"]\n                              [(<\
    \ number 50) \"m\"]\n                              [(< number 40) \"a\"]\n   \
    \                           [(< number 30) \"n\"]\n                          \
    \    [(< number 20) \"m\"]\n                              [(< number 10) \"x\"\
    ]\n                              [(< number 0) \"\"]\n                       \
    \       [(< number 9) \"xl\"]\n                              [(< number 8) \"\
    c\"]\n                              [(< number 7) \"d\"]\n                   \
    \           [(< number 6) \"x\"]\n                              [(< number 5)\
    \ \"m\"]\n                              [(< number 4) \"a\"]\n               \
    \               [(< number 3) \"n\"]\n                              [(< number\
    \ 2) \"m\"]\n                              [(< number 1) \"x\"]\n            \
    \                  [(< number 0) \"\"])]\n        [(< number 900) (cond [(< number\
    \ 1000) \"vi\"]\n                              [(< number 900) \"lx\"]\n     \
    \                         [(< number 800) \"c\"]\n                           \
    \   [(< number 700) \"d\"]\n                              [(< number 600) \"x\"\
    ]\n                              [(< number 500) \"m\"]\n                    \
    \          [(< number 400) \"a\"]\n                              [(< number 300)\
    \ \"n\"]\n                              [(< number 200) \"m\"]\n             \
    \                 [(< number 100) \"x\"]\n                              [(< number\
    \ 90) \"xl\"]\n                              [(< number 80) \"c\"]\n         \
    \                     [(< number 70) \"d\"]\n                              [(<\
    \ number 60) \"x\"]\n                              [(< number 50) \"m\"]\n   \
    \                           [(< number 40) \"a\"]\n                          \
    \    [(< number 30) \"n\"]\n                              [(< number 20) \"m\"\
    ]\n                              [(< number 10) \"x\"]\n                     \
    \         [(< number 0) \"\"]\n                              [(< number 9) \"\
    xl\"]\n                              [(< number 8) \"c\"]\n                  \
    \            [(< number 7) \"d\"]\n                              [(< number 6)\
    \ \"x\"]\n                              [(< number 5) \"m\"]\n               \
    \               [(< number 4) \"a\"]\n                              [(< number\
    \ 3) \"n\"]\n                              [(< number 2) \"m\"]\n            \
    \                  [(< number 1) \"x\"]\n                              [(< number\
    \ 0) \"\"])]\n        [(< number 800) (cond [(< number 900) \"vi\"]\n        \
    \                      [(< number 800) \"lx\"]\n                              ",
  "  (cond [(<= number 0) \"0\"]\n        [(<= number 1) \"x\"]\n        [(<= number\
    \ 2) \"ix\"]\n        [(<= number 3) \"xix\"]\n        [(<= number 4) \"v\"]\n\
    \        [(<= number 5) \"iv\"]\n        [(<= number 6) \"vi\"]\n        [(<=\
    \ number 7) \"vix\"]\n        [(<= number 8) \"ixv\"]\n        [(<= number 9)\
    \ \"xixv\"]\n        [(<= number 10) \"x\"]\n        [(<= number 11) \"xi\"]\n\
    \        [(<= number 12) \"xii\"]\n        [(<= number 13) \"xiv\"]\n        [(<=\
    \ number 14) \"xixv\"]\n        [(<= number 15) \"11\"]\n        [(<= number 16)\
    \ \"11i\"]\n        [(<= number 17) \"11ii\"]\n        [(<= number 18) \"11ii\"\
    ]\n        [(<= number 19) \"11ii\"]\n        [(<= number 20) \"11ii\"]\n    \
    \    [(<= number 21) \"111\"]\n        [(<= number 22) \"111i\"]\n        [(<=\
    \ number 23) \"111ii\"]\n        [(<= number 24) \"111ii\"]\n        [(<= number\
    \ 25) \"111ii\"]\n        [(<= number 26) \"111ii\"]\n        [(<= number 27)\
    \ \"111ii\"]\n        [(<= number 28) \"111ii\"]\n        [(<= number 29) \"111ii\"\
    ]\n        [(<= number 30) \"111ii\"]\n        [(<= number 31) \"111iii\"]\n \
    \       [(<= number 32) \"111iii\"]\n        [(<= number 33) \"111iii\"]\n   \
    \     [(<= number 34) \"111iii\"]\n        [(<= number 35) \"111iii\"]\n     \
    \   [(<= number 36) \"111iii\"]\n        [(<= number 37) \"111iii\"]\n       \
    \ [(<= number 38) \"111iii\"]\n        [(<= number 39) \"111iii\"]\n        [(<=\
    \ number 40) \"111iii\"]\n        [(<= number 41) \"111iii\"]\n        [(<= number\
    \ 42) \"111iii\"]\n        [(<= number 43) \"111iii\"]\n        [(<= number 44)\
    \ \"111iii\"]\n        [(<= number 45) \"111iii\"]\n        [(<= number 46) \"\
    111iii\"]\n        [(<= number 47) \"111iii\"]\n        [(<= number 48) \"111iii\"\
    ]\n        [(<= number 49) \"111iii", "  (let loop ((acc '())\n             (num\
    \ (- number 1)))\n    (cond ((= num 0)\n           (string-append acc 'm))\n \
    \         ((< num 1000)\n           (loop (cons num (list-ref acc 1)) (- num 1)))\n\
    \          (else\n           (loop (cons num (list-ref acc 1)) num)))))\n", " \
    \ (cond [(< number 1) \"\"]\n        [else (int_to_mini_roman number '())]))\n",
  "  (define (get-roman n)\n    (cond\n      [(<= n 1) (if (> n 1) \"I\" \"Ix\")]\n\
    \      [(= n 2) \"II\"]\n      [(= n 3) \"III\"]\n      [(= n 4) (if (> n 4) \"\
    IV\" \"IVx\")]\n      [(= n 5) (if (> n 5) (if (> n 1) \"V\" \"Vx\") \"VI\")]\n\
    \      [(= n 6) (if (> n 6) (if (> n 1) \"VI\" \"VII\") \"VIII\")]\n      [(=\
    \ n 7) (if (> n 7) \"VIII\" \"IX\")]\n      [(= n 8) (if (> n 8) \"IX\" \"X\"\
    )]\n      [(= n 9) (if (> n 9) \"XI\" \"XII\")]\n      [(= n 10) (if (> n 10)\
    \ \"XII\" \"XIII\")]\n      [(= n 11) \"XIII\" \"XIIII\"]\n      [(= n 12) (if\
    \ (> n 12) \"XIV\" \"XV\")]\n      [(= n 13) \"XV\" \"XVI\"]\n      [(= n 14)\
    \ (if (> n 14) \"XVI\" \"XVII\")]\n      [(= n 15) \"XVII\" \"XVIII\"]\n     \
    \ [(= n 16) (if (> n 16) \"XVIII\" \"XIX\")]\n      [(= n 17) \"XIX\" \"XIII\"\
    ]\n      [(= n 18) (if (> n 18) \"XIXI\" \"XX\")]\n      [(= n 19) \"XX\" \"XXI\"\
    ]\n      [(= n 20) \"XXI\" \"XXII\"]\n      [(= n 21) \"XXII\" \"XXIII\"]\n  \
    \    [(= n 22) \"XXIII\" \"XXIV\"]\n      [(= n 23) \"XXIV\" \"XXV\"]\n      [(=\
    \ n 24) \"XXV\" \"XXVI\"]\n      [(= n 25) \"XXVI\" \"XXVII\"]\n      [(= n 26)\
    \ \"XXVII\" \"XXVIII\"]\n      [(= n 27) \"XXVIII\" \"XXIX\"]\n      [(= n 28)\
    \ \"XXIX\" \"XXII\"]\n      [(= n 29) \"XXI\" \"XXI\"]\n      [(= n 30) \"XXI\"\
    \ \"XXII\"]\n      [(= n 31) \"XXII\" \"XXIII\"]\n      [(= n 32) \"XXIII", " \
    \ (cond\n    ((= number 0)\n     (string-append \"i\"))\n    ((= number 1)\n \
    \    (string-append \"v\"))\n    ((= number 2)\n     (string-append \"vi\"))\n\
    \    ((= number 3)\n     (string-append \"ivi\"))\n    ((< number 4)\n     (cond\n\
    \       ((= (mod number 4) 0)\n        (string-append \"i\"))\n       ((= (mod\
    \ number 4) 1)\n        (string-append \"vi\"))\n       ((= (mod number 4) 2)\n\
    \        (string-append \"vii\"))\n       ((= (mod number 4) 3)\n        (string-append\
    \ \"ix\"))\n       ((= (mod number 4) 4)\n        (string-append \"x\"))\n   \
    \    ((= (mod number 4) 5)\n        (string-append \"ex\"))\n       ((= (mod number\
    \ 4) 6)\n        (string-append \"e\"))\n       ((= (mod number 4) 7)\n      \
    \  (string-append \"e\"))\n       ((= (mod number 4) 8)\n        (string-append\
    \ \"e\"))\n       ((= (mod number 4) 9)\n        (string-append \"e\"))\n    \
    \   (else\n        (int_to_mini_roman number))))\n    (else\n     (cond\n    \
    \   ((= (mod number 5) 0)\n        (string-append \"m\"))\n       ((= (mod number\
    \ 5) 1)\n        (string-append \"mu\"))\n       ((= (mod number 5) 2)\n     \
    \   (string-append \"mut\"))\n       ((= (mod number 5) 3)\n        (string-append\
    \ \"muta\"))\n       ((= (mod number 5) 4)\n        (string-append \"mutan\"))\n\
    \       ((= (mod number 5) 5)\n        (string-append \"mutan\"))\n       ((=\
    \ (mod number 5) 6)\n        (string-append \"mutane\"))\n       ((= (mod number\
    \ 5) 7)\n        (string-append \"mutando\"))\n       ((= (mod number 5) 8)\n\
    \        (string-append \"mutando\"))\n       ((= (mod number 5) 9)\n        (string-append\
    \ \"mutando\"))\n       (else\n        (int_to_mini_roman number))))))\n", " \
    \ (cond\n    [(< number 1) \"\"]\n    [(< number 1000) (int_to_mini_roman number)]\n\
    \    [else (string-append\n            (int_to_mini_roman floor (/ number 1000))\n\
    \            (mini_roman_numeral_letter_of_digit (% number 1000)))]))\n", "  (if\
    \ (= number 0)\n      \"0\"\n      (concat (int_to_mini_roman number/10)\n   \
    \           (mini_roman_numeral (- number 10) 'i)))) ; #lang racket\n", "  (define\
    \ (int_to_roman-helper num acc)\n    (if (or (< num 1000) (< num 0))\n       \
    \ acc\n        (int_to_roman-helper (- num 1000) (append (list (cons (- num 100)\
    \ 'x))\n                                        (int_to_roman-helper num acc))))\n\
    \  (int_to_roman-helper number '()))\n", "  (let loop ((num number) \n       \
    \      (s \"\")\n             (i '()))\n    (cond\n      [(= num 0) (cons s i)]\n\
    \      [(< num 1000) (loop (/ num 100) (cons (modulo_to_char num) s) (cons i (cons\
    \ num '')))]\n      [(< num 1000)\n       (loop (/ num 100) s (cons i (cons (modulo_to_char\
    \ num) s))\n             (cons num '()))]\n      [else \n       (loop (/ num 10)\n\
    \             (cons s (modulo_to_char num))\n             (cons i (cons num '')))]\n\
    \      )))\n", "  (cond\n    [(< number 1) \"x\"]\n    [(< number 4) \"L\"]\n\
    \    [(< number 5) \"M\"]\n    [(< number 9) \"C\"]\n    [else (let ([nums (in-range\
    \ (- number 1) 1000)])\n              (let ([i (min nums (- number 1))])\n   \
    \             (cond\n                  [(< i 1) \"X\"]\n                  [(<\
    \ i 4) \"L\"]\n                  [(< i 5) \"M\"]\n                  [(< i 9) \"\
    C\"]\n                  [else (let ([j (in-range (+ i 1) 1000)])\n           \
    \               (cond\n                            [(< j 1) \"X\"]\n         \
    \                   [(< j 4) \"L\"]\n                            [(< j 5) \"M\"\
    ]\n                            [(< j 9) \"C\"]\n                            [else\
    \ (substring (string-append (string-append (string-append (string-append \"I\"\
    ) (substring (mini-roman-digit nums i) 1)) (mini-roman-digit nums j))\n      \
    \                                    0 1)\n                                  \
    \ 1)]))]))]))\n", "  (cond\n    [(= number 0) \"\"]\n    [(< number 1000) (mini_roman\
    \ number \"i\")]\n    [else (mini_roman number \"x\")]))\n", "  (let loop ((num\
    \ number) (out \"\") (c 'A))\n    (if (<= num 1000)\n      (cond ((= num 0) (append\
    \ out c))\n            ((even? num) (loop (sub1 num) (append out (char c (/ num\
    \ 10))) (char c 0))\n            (else (loop (sub1 num) (append out (char c 0))\
    \ (char c (/ num 10))))))\n      (loop (sub1 num) (append out (char c 0)) (char\
    \ c (/ num 10))))))\n", "  (let loop ((i number) (acc \"\"))\n    (cond [(> i\
    \ 1000)\n           acc]\n          [(char->integer (char->string (+ i 1000)))\
    \ (loop (+ i 1000) (cons (char->integer (char->string (+ i 1000))) acc))]\n  \
    \        [else (loop (+ i 1000) (cons (char->string (+ i 1000))\n            \
    \                        (loop (+ i 1000) \"\"))))]))\n", "  (let loop ((number\
    \ number) (acc '()))\n    (cond [(= number 0) (set! acc '())]\n          [(< number\
    \ 10) (set! acc (cons (- number 10) (append acc (list number))))]\n          [else\
    \ (set! acc (cons (- number 100) (append acc (int_to_mini_roman (/ number 10)))))]\n\
    \          [else acc]))\n", "  (cond [(= number 0)\n         (string-append \"\
    0\"\n                        (int_to_mini_roman 1))]\n        [(even? number)\n\
    \         (string-append (int_to_mini_roman floor (/ number 2))\n            \
    \            (int_to_mini_roman floor (mod number 2)))]\n        [else\n     \
    \    (string-append (int_to_mini_roman floor (/ number 1000))\n              \
    \          (int_to_mini_roman floor (mod number 1000))\n                     \
    \   (int_to_mini_roman floor (mod number 100)))]))\n", "  (cond\n    [(< number\
    \ 0) '0]\n    [(< number 999) (string-append \"m\" (int_to_mini_roman number 1000))]\n\
    \    [else (string-append (int_to_mini_roman number num) (int_to_mini_roman number\
    \ (- num 1000))) ]\n  ))\n", "  (let* ((result \"\")\n         (remainder (modulo\
    \ (abs number) 1000))\n         (remainder-suffix (cond [(= remainder 0) \"-\"\
    ]\n                              [(< remainder 100) \"\"]\n                  \
    \            [else \"\"]))\n         (quotient (quotient number 1000))\n     \
    \    (quotient-suffix (cond [(= quotient 0) \"\"]\n                          \
    \   [(< quotient 100) \"\"]\n                             [else \"\"])))\n   \
    \ (cond [(< number 1000)\n           (format nil \"~a\" '~a)\n           (append\
    \ result '~a)\n           (append result remainder-suffix)\n           (append\
    \ result quotient-suffix)\n           (append result \"M\")]\n          [(> number\
    \ 1000)\n           (format nil \"~a\" '~a)\n           (append result '~a)\n\
    \           (append result \"CM\")]\n          [else\n           (format nil \"\
    ~a\" '~a)\n           (append result '~a)\n           (append result \"D\")]\n\
    \          [(> number 1000)\n           (format nil \"~a\" '~a)\n           (append\
    \ result '~a)\n           (append result \"CD\")]\n          [else\n         \
    \  (format nil \"~a\" '~a)\n           (append result '~a)\n           (append\
    \ result \"C\")]\n          [(> number 1000)\n           (format nil \"~a\" '~a)\n\
    \           (append result '~a)\n           (append result \"XC\")]\n        \
    \  [else\n           (format nil \"~a\" '~a)\n           (append result '~a)\n\
    \           (append result \"L\")]\n          [(> number 1000)\n           (format\
    \ nil \"~a\" '~a)\n           (append result '~a)\n           (append result \"\
    XL\")]\n          [else\n           (format nil \"~a\" '~a)\n           (append\
    \ result '~a)\n           (append result \"X\")]\n          [(> number 1000)\n\
    \           (format nil \"~a\" '~a)\n           (append result '~a)\n        \
    \   (append result \"IX\")]\n          [else\n           (format nil \"~a\" '~a)\n\
    \           (append result '~a)\n           (append result \"V\")]\n         \
    \ [(> number 1000)\n           (format nil \"~a\" '~a)\n           (append result\
    \ '~a)\n           (append result \"IV\")]\n          [else\n           (format\
    \ nil \"~a\" '~a)\n           (append result '~a)\n           (append result \"\
    I\")]))\n", "  (define (roman-numeral n)\n    (cond ((= n 0)\n           'zero)\n\
    \          ((= n 1)\n           'one)\n          ((= n 2)\n           'two)\n\
    \          ((= n 3)\n           'three)\n          ((= n 4)\n           'four)\n\
    \          ((= n 5)\n           'five)\n          ((= n 6)\n           'six)\n\
    \          ((= n 7)\n           'seven)\n          ((= n 8)\n           'eight)\n\
    \          ((= n 9)\n           'nine)\n          (else\n           (string-append\
    \ (string-to-lower-case (symbol->string 'zero))\n                        (string-to-lower-case\
    \ (symbol->string 'one))\n                        (string-to-lower-case (symbol->string\
    \ 'two))\n                        (string-to-lower-case (symbol->string 'three))\n\
    \                        (string-to-lower-case (symbol->string 'four))\n     \
    \                   (string-to-lower-case (symbol->string 'five))\n          \
    \              (string-to-lower-case (symbol->string 'six))\n                \
    \        (string-to-lower-case (symbol->string 'seven))\n                    \
    \    (string-to-lower-case (symbol->string 'eight))\n                        (string-to-lower-case\
    \ (symbol->string 'nine))))))\n\n  (define (iter n acc)\n    (cond ((= n 0) acc)\n\
    \          ((< n 9) (iter (sub1 n) (roman-numeral (sub1 n))))\n          (else\
    \ (iter (sub1 n) (string-append acc (roman-numeral (sub1 n)))))) ))\n", "  (cond\n\
    \    ((= number 0) \"\")\n    ((< number 999) (string-append (int_to_mini_roman_part\
    \ number) \"\"))\n    (else (string-append (int_to_mini_roman_part (modulo (+\
    \ number 1) 1000))\n                          (int_to_mini_roman_part (modulo\
    \ (quotient number 1000))\n                                                  ))))))\n",
  "  (cond [(< number 1) \"\"]\n        [(< number 10) (string-append \"i\" (int_to_mini_roman\
    \ number 1))]\n        [(< number 100) (string-append \"v\" (int_to_mini_roman\
    \ number 10))]\n        [(< number 500) (string-append \"x\" (int_to_mini_roman\
    \ number 100))]\n        [(< number 1000) (string-append \"l\" (int_to_mini_roman\
    \ number 500))]))\n", "  (define (num-rom (number->roman (number)))\n    (string-append\
    \ (num-rom \"i\") (mini_roman->num (mini_roman->roman (num-rom \"iv\")))))\n \
    \ (cond\n    [(= number 0) \"\"]\n    [(= number 1) \"I\"]\n    [(= number 2)\
    \ \"II\"]\n    [(= number 3) \"III\"]\n    [(= number 4) \"IV\"]\n    [(= number\
    \ 5) \"V\"]\n    [(= number 6) \"VI\"]\n    [(= number 7) \"VII\"]\n    [(= number\
    \ 8) \"VIII\"]\n    [(= number 9) \"IX\"]\n    [(= number 10) \"X\"]\n    [(=\
    \ number 11) \"XI\"]\n    [(= number 12) \"XII\"]\n    [(= number 13) \"XIII\"\
    ]\n    [(= number 14) \"XIV\"]\n    [(= number 15) \"XV\"]\n    [(= number 16)\
    \ \"XVI\"]\n    [(= number 17) \"XVII\"]\n    [(= number 18) \"XVIII\"]\n    [(=\
    \ number 19) \"XIX\"]\n    [(= number 20) \"XX\"]\n    [(= number 21) \"XXI\"\
    ]\n    [(= number 22) \"XXII\"]\n    [(= number 23) \"XXIII\"]\n    [(= number\
    \ 24) \"XXIV\"]\n    [(= number 25) \"XXV\"]\n    [(= number 26) \"XXVI\"]\n \
    \   [(= number 27) \"XXVII\"]\n    [(= number 28) \"XXVIII\"]\n    [(= number\
    \ 29) \"XXIX\"]\n    [(= number 30) \"XXX\"]\n    [(= number 31) \"XXXI\"]\n \
    \   [(= number 32) \"XXXII\"]\n    [(= number 33) \"XXXIII\"]\n    [(= number\
    \ 34) \"XXXIV\"]\n    [(= number 35) \"XXXV\"]\n    [(= number 36) \"XXXVI\"]\n\
    \    [(= number 37) \"XXXVII\"]\n    [(= number 38) \"XXXVIII\"]\n    [(= number\
    \ 39) \"XXXIX\"]\n    [(= number 40) \"XL\"]\n    [(= number 41) \"L\"]\n    [(=\
    \ number 42) \"LX\"]\n    [(= number 43) \"LXC\"]\n    [(= number 44) \"LXCC\"\
    ]\n    [(", "  (let ((roman-numeral (make-hash (hash-roman (number-roman (+ number\
    \ 1))))) (roman-numeral (make-hash (hash-roman (number-roman (- number 1))))))\n\
    \    (let loop ((i number) (o empty) (f empty))\n      (cond [(<= i 1000) (append\
    \ (hash-get roman-numeral i) roman-numeral)]\n            [else (cond [(hash-get\
    \ roman-numeral i) roman-numeral]\n                      [(< i (floor (/ i 1000)))\n\
    \                       (cond [(hash-get roman-numeral (ceiling (/ i 1000))) roman-numeral]\n\
    \                             [(hash-get roman-numeral (floor (/ i 1000))) roman-numeral]\n\
    \                             [else (hash-set roman-numeral (ceiling (/ i 1000))\
    \ (cons (cons 'i roman-numeral) (hash-get roman-numeral (floor (/ i 1000))))])]\n\
    \                      [else (cond [(hash-get roman-numeral (ceiling (/ i 1000)))\n\
    \                                 (cons (cons (cons i roman-numeral) (hash-get\
    \ roman-numeral (floor (/ i 1000)))))]\n                             [(hash-get\
    \ roman-numeral (floor (/ i 1000)))\n                                 (cons (cons\
    \ i roman-numeral) (hash-get roman-numeral (floor (/ i 1000))))]\n           \
    \                  [else (hash-set roman-numeral (floor (/ i 1000)) (cons (cons\
    \ i roman-numeral) (hash-get roman-numeral (floor (/ i 1000))))])]\n         \
    \             [(hash-get roman-numeral i) roman-numeral]\n                   \
    \   [(hash-get roman-numeral (ceiling (/ i 1000)))\n                       (hash-set\
    \ roman-numeral (ceiling (/ i 1000)) (cons (cons i roman-numeral) (hash-get roman-numeral\
    \ (floor (/ i 1000))))]\n                      [(hash-get roman-numeral (floor\
    \ (/ i 1000)))\n                       (hash-set roman-numeral (floor (/ i 1000))\
    \ (cons (cons i roman-numeral) (hash-get roman-", "  (let* ((romans (map int_to_roman_numeral\
    \ [1000 1000 9 9 9 7 7 7 7 5 4 4 4 3 2 1]\n                             [x i x\
    \ i x i x i i i i i i i]))\n         (roman '()))\n    (let loop ((num number)\
    \ (roman '()))\n      (cond ((= num 0)\n             (reverse roman))\n      \
    \      ((< num 0)\n             (loop (- num 1)\n                  (cons num\n\
    \                        roman)))\n            (else (loop (quotient num 10)\n\
    \                         (cons (car roman)\n                              (loop\
    \ (- num 10)\n                                    (cdr roman))))))))\n", "  (define\
    \ (helper number remainder prefix)\n    (if (= number 0)\n        (string-append\
    \ prefix (substring prefix 1 1))\n        (helper (quotient number 10) (remainder\
    \ (quotient number 10))\n              (substring prefix 1 1)\n              )\n\
    \        )\n  )\n  (helper number 0 \"\")\n)\n", "  (cond\n    [(< number 1)\n\
    \     \"x\"]\n    [(< number 10)\n     (char->string number)]\n    [(< number\
    \ 100)\n     (cond\n       [(< number 1000)\n        (\"xix\" \"xx\")]\n     \
    \  [(< number 1000)\n        (\"ccc\" \"c\")]\n       [(< number 1000)\n     \
    \   (\"d\" \"d\")]\n       [(< number 1000)\n        (\"ii\" \"i\")]\n       [(<\
    \ number 1000)\n        (\"ii\" \"i\")]\n       [(< number 1000)\n        (\"\
    ii\" \"i\")]\n       [(< number 1000)\n        (\"ii\" \"i\")]\n       [(< number\
    \ 1000)\n        (\"v\" \"v\")]\n       [(< number 1000)\n        (\"vi\" \"v\"\
    )]\n       [(< number 1000)\n        (\"vi\" \"v\")]\n       [(< number 1000)\n\
    \        (\"vi\" \"v\")]\n       [(< number 1000)\n        (\"vi\" \"v\")]\n \
    \      [(< number 1000)\n        (\"vi\" \"v\")]\n       [(< number 1000)\n  \
    \      (\"vi\" \"v\")]\n       [(< number 1000)\n        (\"vi\" \"v\")]\n   \
    \    [(< number 1000)\n        (\"vi\" \"v\")]\n       [(< number 1000)\n    \
    \    (\"vi\" \"v\")]\n       [(< number 1000)\n        (\"vi\" \"v\")]\n     \
    \  [(< number 1000)\n        (\"vi\" \"v\")]\n       [(< number 1000)\n      \
    \  (\"vi\" \"v\")]\n       [(< number 1000)\n        (\"vi\" \"v\")]\n       [(<\
    \ number 1000)\n        (\"vi\" \"v\")]\n       [(< number 1000)\n        (\"\
    vi\" \"v\")]\n       [(< number 1000)\n        (\"vi\" \"v\")]\n       [(< number\
    \ 1000)\n        (\"vi\" \"v\")]\n       [(< number 1000)\n        (\"vi\" \"\
    v\")]\n       [(< number 1000)\n        (\"vi\" \"v\")]\n       [(< number 1000)\n\
    \        (\"vi\" \"v\")]\n       [(< number 1000)\n        (\"vi\" \"v\")]\n \
    \      [(< number 1000)\n        (\"vi\" \"v\")]\n       [(< number 1000)\n  \
    \      (\"vi\" \"v\")]\n       [(< number 1000)\n        (\"vi\" \"v\")]\n   \
    \    [(< number 1000)\n        (\"vi\" \"v\")]\n       [(< number 1000)\n    \
    \    (\"vi\" \"v\")]\n       [(< number 1000)\n        (\"vi\" \"v\")]\n     \
    \  [(< number 1000)\n        (\"vi\" \"v\")]\n       [(< number 1000)\n      \
    \  (\"vi\" \"v\")]\n       [(< number 1000)\n        (\"vi\" \"v\")]\n       [(<\
    \ number 1000)\n        (\"vi\" \"v\")]\n       [(< number 1000)\n        (\"",
  "  (define (helper number roman i)\n    (if (> i 0)\n        (cond (= number 0)\n\
    \              (append roman (string->list \"M\"))\n              (= (number mod\
    \ 100) 0)\n              (helper (quotient number 100) roman (- i 1))\n      \
    \        (helper (quotient number 100) (cons (string->list (char->string i)))\
    \ 0))\n        roman))\n  (helper (quotient number 100) '() 0))\n", "  (cond [(<\
    \ number 1) (error \"Invalid number: ~S.\" number)]\n        [(and (< number 999)\
    \ (< number 1000)) (mini_to_roman (- number 1))]\n        [(or (= (modulo number\
    \ 100) 0) (= (modulo number 1000) 0)) \n         (mini_to_roman (- number 1000))]\n\
    \        [else (mini_to_roman (- number 1000))]))\n", "  (if (< number 1)\n  \
    \    (error \"Argument must be greater than one\")\n      (let ((str '())\n  \
    \          (cur (cond ((< number 10) (append str (string->list (number->string\
    \ number 10))))\n                     ((< number 100) (append str (string->list\
    \ (number->string number 100))))\n                     ((< number 1000)\n    \
    \                  (append str (string->list (number->string number 1000)))))\n\
    \            (new (substring str 0 cur)))\n        (string-append \"i\" (mini_roman\
    \ new)))))\n", "  (cond\n    [(and (number? number) \n           (>= number 1))\n\
    \     (string-append \"x\" (int_to_mini_roman 0 (- number 1)))]\n    [(and (number?\
    \ number) \n           (= number 2))\n     (string-append \"c\" (int_to_mini_roman\
    \ 1 (- number 1)))]\n    [(and (number? number) \n           (= number 3))\n \
    \    (string-append \"i\" (int_to_mini_roman 2 (- number 1)))]\n    [(and (number?\
    \ number) \n           (= number 4))\n     (string-append \"v\" (int_to_mini_roman\
    \ 3 (- number 1)))]\n    [(and (number? number) \n           (= number 5))\n \
    \    (string-append \"i\" (int_to_mini_roman 4 (- number 1)))]\n    [(and (number?\
    \ number) \n           (= number 6))\n     (string-append \"x\" (int_to_mini_roman\
    \ 5 (- number 1)))]\n    [(and (number? number) \n           (= number 7))\n \
    \    (string-append \"l\" (int_to_mini_roman 6 (- number 1)))]\n    [(and (number?\
    \ number) \n           (= number 8))\n     (string-append \"x\" (int_to_mini_roman\
    \ 7 (- number 1)))]\n    [(and (number? number) \n           (= number 9))\n \
    \    (string-append \"l\" (int_to_mini_roman 8 (- number 1)))]\n    [else\n  \
    \   (int_to_mini_roman number)]\n  ))\n", "  (if (< number 1000)\n      (roman-numeral-equivalent\
    \ number)\n      (if (>= (/ number 100) 3)\n          (mini-roman-numeral-equivalent\
    \ (/ number 100) (+ number 1))\n          (mini-roman-numeral-equivalent (/ number\
    \ 100) (+ number 1)))))\n", "  (cond [(< number 1) (error \"Number too small!\"\
    )]\n        [(< number 1000) (error \"Number too large!\")]\n        [else\n \
    \        (let ([remainder num (quotient number 1000)])\n           (cond [(< remainder\
    \ 1) (error \"Number too small!\")]\n                 [(< remainder 100) (error\
    \ \"Number too large!\")]\n                 [(< remainder 1000) (define (loop\
    \ i acc)\n                                                  (if (< i 1000)\n \
    \                                                 (loop i (cons remainder (loop\
    \ (+ i 1) acc))))\n                                                  (loop (+\
    \ i 1) acc))\n                                                  (loop i acc))]\n\
    \                 [else (define (loop i acc)\n                              (if\
    \ (< i 1000)\n                              (loop (+ i 1) (cons remainder (loop\
    \ (+ i 1) acc))))\n                              (loop (+ i 1) acc))]\n      \
    \           acc)]))\n", "  (if (positive? number)\n      (mini-roman-numeral number)\n\
    \      '0))\n", "  (let ((strings '()))\n    (cond\n      [(< number 1)\n    \
    \   (list '1)\n       ]\n      [(< number 10)\n       (append (list (char->string\
    \ (char->integer 'M)))\n              (string_to_roman_numeral (- number 1)))\n\
    \       ]\n      [(< number 100)\n       (append (string_to_roman_numeral (- number\
    \ 10))\n              (string_to_roman_numeral (- number 1)))\n       ]\n    \
    \  [(< number 1000)\n       (let ((remainder (- number 100)))\n         (append\
    \ (string_to_roman_numeral (- remainder 10)) (string_to_mini_roman remainder))\n\
    \       ]\n      [else\n       (cond\n         [(< number 400)\n          (append\
    \ (string_to_roman_numeral (- number 1000))\n                  (string_to_roman_numeral\
    \ (- number 900))\n                  (string_to_roman_numeral (- number 500))\n\
    \                  (string_to_roman_numeral (- number 400))\n                \
    \  (string_to_roman_numeral (- number 300))\n                  (string_to_roman_numeral\
    \ (- number 200))\n                  (string_to_roman_numeral (- number 100))\n\
    \                  (string_to_roman_numeral (- number 90))\n                 \
    \ (string_to_roman_numeral (- number 50))\n                  (string_to_roman_numeral\
    \ (- number 40))\n                  (string_to_roman_numeral (- number 30))\n\
    \                  (string_to_roman_numeral (- number 20))\n                 \
    \ (string_to_roman_numeral (- number 10))\n                  (string_to_roman_numeral\
    \ (- number 1))\n                  (string_to_roman_numeral number)\n        \
    \          )\n         ]\n         [(< number 900)\n          (append (string_to_roman_numeral\
    \ (- number 400))\n                  (string_to_roman_numeral (- number 300))\n\
    \                  (string_to_roman_numeral (- number 200))\n                \
    \  (string_to_roman_numeral (- number 100))\n                  (string_to_roman_numeral\
    \ (- number 90))\n                  (string_to_roman_numeral (- number 50))\n\
    \                  (string_to_roman_numeral (- number 40))\n                 \
    \ (string_to_roman_numeral (- number 30))\n                  (string_to_roman_numeral\
    \ (- number 20))\n                  (string_to_roman_numeral (- number 10))\n\
    \                  (string_to_roman_numeral (- number 1))\n                  (string_to_roman_numeral\
    \ number)\n                  )\n         ]\n         [(< number 500)", "  (cond\n\
    \    [(< number 1) \"x\"]\n    [(< number 4) \"c\"]\n    [(< number 10) \"l\"\
    ]\n    [(< number 100) \"c\"]\n    [(< number 400) \"xc\"]\n    [else (cons \"\
    i\" (int_to_mini_roman number / 10))]))\n", "  (cond\n    [(<= 0 number 1000)\
    \ \"error 1\"]\n    [(= 1 number) \"i\"]\n    [(= 2 number) \"ii\"]\n    [(= 3\
    \ number) \"iii\"]\n    [(= 4 number) \"iv\"]\n    [(= 5 number) \"vi\"]\n   \
    \ [(= 6 number) \"vii\"]\n    [(= 7 number) \"viii\"]\n    [(= 8 number) \"ix\"\
    ]\n    [(= 9 number) \"x\"]\n    [else (make-roman-numeral (- number (floor number\
    \ 1000)))]))\n", "  (cond\n    [(< number 100) \"\"]\n    [(< number 900) \"\"\
    ]\n    [else (cond\n            [(< number 5000) \"\"]\n            [else (cond\n\
    \                    [((>= number 5000)\n                      ((< number 10000)\n\
    \                       (append (int_to_mini_roman floor (/ number 1000))\n  \
    \                            (mini_roman_to_char number))))]\n               \
    \     [else (cond\n                            [(< number 100000) \"\"]\n    \
    \                        [(< number 1000000)\n                             (append\
    \ (int_to_mini_roman floor (/ number 1000000))\n                             \
    \        (mini_roman_to_char number))])]))]))", "  (cond\n    [(<= 1 number) '?x]\n\
    \    [(<= 100 number) '?x]\n    [(<= 1000 number) '?x]\n    [else (cond [(> number\
    \ 100) '?x]\n               [(> number 900) '?v]\n               [(> number 500)\
    \ '?c]\n               [(> number 400) '?v]\n               [(> number 300) '?c]\n\
    \               [(> number 200) '?v]\n               [(> number 100) '?c]\n  \
    \             [(> number 90) '?v]\n               [(> number 50) '?c]\n      \
    \         [(> number 40) '?v]\n               [(> number 30) '?c]\n          \
    \     [(> number 20) '?v]\n               [(> number 10) '?c]\n              \
    \ [(> number 9) '?v]\n               [(> number 5) '?c]\n               [(> number\
    \ 4) '?v]\n               [(> number 3) '?c]\n               [(> number 2) '?v]\n\
    \               [(> number 1) '?c]\n               [(> number 0) '?x]]))\n", " \
    \ (define (roman_numeral_to_string roman index)\n    (cond ((> roman 0) \"z\"\
    )\n          ((< roman 0) \"m\")\n          ((= roman 0) \"\")\n          ((>\
    \ index 0) (cons (substring roman 0 (+ index 1)) \n                          \
    \ (cons (substring roman 1 (+ index 1)) (roman_numeral_to_string (substring roman\
    \ index 1) (+ index 1)))))\n          ((< index 0) (cons (substring roman 0 (+\
    \ index 1)) \n                           (cons (substring roman 1 index) (roman_numeral_to_string\
    \ (substring roman 1 index) (+ index 1)))))\n          ((= index 0) (cons (substring\
    \ roman 0) \"m\")\n                       (roman_numeral_to_string (substring\
    \ roman index) index)))\n  (roman_numeral_to_string (substring (string-to-list\
    \ \"IIOU\" '()) (+ number 1))\n  (/ number 1000))\n", "  (cond\n    [(<= number\
    \ 1) \"\"]\n    [(< number 1000) (string-append \"m\" (int_to_mini_roman 1000-number))]\n\
    \    [else (string-append (int_to_mini_roman 1000-(quotient number 1000))\n  \
    \                        (if (> number 1000)\n                               (int_to_mini_roman\
    \ 1000)\n                               \"\"))]))\n", "  (cond [(< number 100)\
    \ \"\"]\n        [else (makeRoman number)]))\n", "  (cond\n    ((< number 1) (error\
    \ \"Argument must be greater than 1\"))\n    ((< number 1000) (error \"Argument\
    \ must be less than 1000\"))\n    (else (let ([a (quotient number 10)\n      \
    \            b (quotient (modulo number 10) 10)\n                  c (modulo (modulo\
    \ number 10) 10)])\n              (string-append (mini_roman_numerals a) b)\n\
    \              (if (= (- number 10) 10)\n                  (mini_roman_numerals\
    \ a)\n                  (mini_roman_numerals a) ))))))\n", "  (let* ((roman-letters\
    \ (make-list number+1))\n         (remainder (modulo number 1000))\n         (last\
    \ (subseq roman-letters 0 (- number 1000)))\n         (last-letter (subseq roman-letters\
    \ (+ number 1000) (length roman-letters))))\n    (if (= remainder 0)\n       \
    \ (string-append last last-letter)\n        (let loop ((i number) (remainder remainder))\n\
    \          (cond (> i 0) (loop (- i 1) remainder)\n                (= i 0) (subseq\
    \ roman-letters 0 (- i 1) last-letter)\n                (= remainder 0)\n    \
    \            (= remainder 1000) (subseq roman-letters (+ i 1) (length roman-letters))\n\
    \                (true) (cons last-letter (loop i (/ remainder 1000)))\n     \
    \           (true) (cons (subseq roman-letters 0 (- i 1) last-letter) (loop (-\
    \ i 1) (/ remainder 1000)))))))\n", "  (cond\n    [(= number 0) \"\"]\n    [(<\
    \ number 1) (string-append \"x\" int_to_mini_roman (sub1 number))]\n    [(< number\
    \ 4) (string-append \"i\" int_to_mini_roman (sub1 number))]\n    [else\n     (string-append\
    \ (int_to_mini_roman number (+ 1 4)) (string-append \"v\" int_to_mini_roman (sub1\
    \ number)))]))\n", "  (let ((roman (make-string 100 '#)))\n    (loop\n       (cond\
    \ [(= number 0)\n              (set! roman 0)]\n             [(< number 1)\n \
    \             (set! roman 'x)]\n             [else\n              (set! roman\
    \ 'x)]\n             [else\n              (set! roman 'x)]\n             [else\n\
    \              (set! roman 'x)]\n             [else\n              (set! roman\
    \ 'x)]\n             [else\n              (set! roman 'x)]\n             [else\n\
    \              (set! roman 'x)]\n             [else\n              (set! roman\
    \ 'x)]\n             [else\n              (set! roman 'x)]\n             [else\n\
    \              (set! roman 'x)]\n             [else\n              (set! roman\
    \ 'x)]\n             [else\n              (set! roman 'x)]\n             [else\n\
    \              (set! roman 'x)]\n             [else\n              (set! roman\
    \ 'x)]\n             [else\n              (set! roman 'x)]\n             [else\n\
    \              (set! roman 'x)]\n             [else\n              (set! roman\
    \ 'x)]\n             [else\n              (set! roman 'x)]\n             [else\n\
    \              (set! roman 'x)]\n             [else\n              (set! roman\
    \ 'x)]\n             [else\n              (set! roman 'x)]\n             [else\n\
    \              (set! roman 'x)]\n             [else\n              (set! roman\
    \ 'x)]\n             [else\n              (set! roman 'x)]\n             [else\n\
    \              (set! roman 'x)]\n             [else\n              (set! roman\
    \ 'x)]\n             [else\n              (set! roman 'x)]\n             [else\n\
    \              (set! roman 'x)]\n             [else\n              (set! roman\
    \ 'x)]\n             [else\n              (set! roman 'x)]\n             [else\n\
    \              (set! roman 'x)]\n             [else\n              (set! roman\
    \ 'x)]\n             [else\n              (set! roman 'x)]\n             [else\n\
    \              (set! roman 'x)]\n             ", "  (let ((roman_numeral (make-array\
    \ (- number 1) #:element-type 'string)))\n    (if (< number 1)\n        roman_numeral\n\
    \        (loop ((i 0) (j roman_numeral) (len 0))\n              (< i number)\n\
    \              (< len 0)\n              (let* ((dig (modulo number i))\n     \
    \                (newj (string->list (substring j len))))\n                (set!\
    \ len (+ len 1))\n                (if (< j len)\n                    (set! newj\
    \ (append newj (substring j len)))\n                    (set! newj (append newj\
    \ dig))\n                    (set! roman_numeral (cons newj roman_numeral))\n\
    \                    (set! i (+ i 1))))))))\n", "  (cond\n    [(= number 0) \"\
    0\"]\n    [(= number 1) \"x\"]\n    [(= number 2) \"ix\"]\n    [(= number 3) \"\
    v\"]\n    [(= number 4) \"vi\"]\n    [(= number 5) \"iv\"]\n    [(= number 6)\
    \ \"xvi\"]\n    [(= number 7) \"ixv\"]\n    [(= number 8) \"xxv\"]\n    [(= number\
    \ 9) \"xixv\"]\n    [(= number 10) \"vix\"]\n    [(= number 11) \"vixx\"]\n  \
    \  [(= number 12) \"vxxx\"]\n    [(= number 13) \"ivx\"]\n    [(= number 14) \"\
    ivxx\"]\n    [(= number 15) \"iixx\"]\n    [(= number 16) \"iii\"]\n    [(= number\
    \ 17) \"ii\"]\n    [(= number 18) \"i\"]\n    [(= number 19) \"x\"]\n    [(= number\
    \ 20) \"xix\"]\n    [(= number 21) \"xx\"]\n    [(= number 22) \"xixv\"]\n   \
    \ [(= number 23) \"xxv\"]\n    [(= number 24) \"xixvi\"]\n    [(= number 25) \"\
    xxvi\"]\n    [(= number 26) \"xixvix\"]\n    [(= number 27) \"xxvix\"]\n    [(=\
    \ number 28) \"xixvixx\"]\n    [(= number 29) \"xxvixx\"]\n    [(= number 30)\
    \ \"xixvixxi\"]\n    [(= number 31) \"xxvixxi\"]\n    [(= number 32) \"xixvixxx\"\
    ]\n    [(= number 33) \"xxvixxx\"]\n    [(= number 34) \"xixvixxxi\"]\n    [(=\
    \ number 35) \"xxvixxxi\"]\n    [(= number 36) \"xixvixxxx\"]\n    [(= number\
    \ 37) \"xxvixxxx\"]\n    [(= number 38) \"xixvixxxxx\"]\n    [(= number 39) \"\
    xxvixxxxx\"]\n    [(= number 40) \"xixvixxxxxx\"]\n    [(= number 41) \"xxvixxxxxx\"\
    ]\n    [(= number 42) \"xixvixxxxxxi\"]\n    [(= number 43) \"xxvixxxxxxi\"]\n\
    \    [(= number 44) \"xixvixxxxxxx\"]\n    [(= number 45) \"xxvixxxxxxx\"]\n \
    \   [(= number 46) \"xixvi", "  (let loop ((n number) (res '()))\n    (cond ((<\
    \ n 100)\n           (reverse res))\n          ((< n 1000)\n           (loop (add1\
    \ n) (cons n (reverse res))))\n          (else\n           (loop (add1 n) (cons\
    \ n (reverse res)))))\n    (loop (add1 n) res)))\n", "  (cond\n    [(<= number\
    \ 0) \"0\"]\n    [(= number 1) \"x\"]\n    [else (cons (int_to_mini_roman (/ number\
    \ 26)) (concat (int_to_mini_roman number) (string \"x\")))]))\n", "  (cond\n \
    \   [(= number 0) \"\"]\n    [(< number 1) (int_to_mini_roman number)]\n    [(even?\
    \ (remainder number 3)) (cons \"x\" (remainder number 3))]\n    [else (cons \"\
    v\" (int_to_mini_roman (remainder number 3)))]))\n", "  (cond\n    [(= number\
    \ 0) \"\"]\n    [(= number 1) \"x\"]\n    [(= (modulo number 100) 0) \"d\"]\n\
    \    [(= (modulo number 100) 1) \"c\"]\n    [(= (modulo number 100) 2) \"x\"]\n\
    \    [else (int_to_mini_roman number)])\n  )\n", "  (cond\n    [(< 1 number)\n\
    \     (error \"Must be a positive number\")\n     (int_to_mini_roman number)]\n\
    \    [else\n     (let ([remainder (modulo (number) (1000))]\n           [tens\
    \ (modulo (modulo (number) 10) (10))])\n       (cond\n         [(< remainder 10)\n\
    \          (int_to_mini_roman remainder)]\n         [(< tens 1)\n          (int_to_mini_roman\
    \ tens)\n          (if (< remainder 10)\n            (append (int_to_mini_roman\
    \ remainder)\n                   (mini_roman_numeral (- remainder 10))\n     \
    \              (mini_roman_numeral tens))]\n         [else\n          (append\
    \ (mini_roman_numeral (- remainder 10))\n                   (mini_roman_numeral\
    \ tens)\n                   (int_to_mini_roman remainder)]\n         (string->list\
    \ (string->string (string->number (string->list number))))])))]\n    ))\n", " \
    \ (cond\n    [(> number 1000) \"\"]\n    [(< number 1) \"X\"]\n    [else (string-append\
    \ (int_to_mini_roman number (- number 1000) \"i\") \"x\")]))\n", "  (let ((x number))\n\
    \    (cond\n      [(< x 1000)\n       (string-append (number->string x)\n    \
    \                (number->string x)\n                    \"'\")]\n      [else\n\
    \       (string-append (number->string x)\n                    (number->string\
    \ x)\n                    (number->string x)\n                    \"'\")]))))\n",
  "  (let loop ([i number] [s \"\"] [roman '()])\n    (cond\n      [(= i 0) (cons\
    \ s roman)\n       (loop (add1 i) (append s (string->symbol (char #{\\i \\I \\\
    e \\a \\o \\U \\O \\r (\\r \\r \\)})) (cons (char->string (char #{\\m \\M})) (cons\
    \ (char->string (char #{\\m \\M}) roman))))]\n      [(= i 1) (cons s roman)\n\
    \       (loop (add1 i) (append s (string->symbol (char #{\\a \\A \\e \\e \\i \\\
    I \\o \\O \\r \\)}) (cons (char->string (char #{\\m \\M})) (cons (char->string\
    \ (char #{\\m \\M}) roman))))]\n      [else\n       (loop (sub1 i) (append s (char->string\
    \ (char #{\\A \\B \\C \\D \\E \\F \\G \\H \\I \\J \\K \\L \\M \\N \\O \\P \\Q\
    \ \\R \\S \\T \\U \\V \\W \\x \\Y (\\y \\z)})) (cons (char->string (char #{\\\
    i})) (cons (char->string (char #{\\i}) roman))))]))))\n", '  (romanize (int_to_roman_numeral
    number) 1))', "  (if (= number 0)\n      '0\n      (let ((remainder (remainder\
    \ number 1000)))\n        (cond ((= remainder 0)\n              (list '0\n   \
    \                 (int_to_mini_roman 0 number))\n              ((and (< remainder\
    \ 100)\n                    (< number 1000))\n              (list 'I\n       \
    \             (int_to_mini_roman remainder number))\n              ((and (< remainder\
    \ 100)\n                    (< number 1000000))\n              (list 'I'\n   \
    \                 (int_to_mini_roman remainder number)\n                    'X))\n\
    \              ((and (< remainder 1000)\n                    (< number 10000000))\n\
    \              (list 'I'\n                    (int_to_mini_roman remainder number)\n\
    \                    'X\n                    'X))\n              ((and (< remainder\
    \ 1000000)\n                    (< number 100000000))\n              (list 'I'\n\
    \                    (int_to_mini_roman remainder number)\n                  \
    \  'X\n                    'X\n                    'X))\n              ((and (<\
    \ remainder 10000000)\n                    (< number 10000000000))\n         \
    \     (list 'I'\n                    (int_to_mini_roman remainder number)\n  \
    \                  'X\n                    'X\n                    'X\n      \
    \              'X))\n              ((and (< remainder 1000000000)\n          \
    \          (< number 100000000000))\n              (list 'I'\n               \
    \     (int_to_mini_roman remainder number)\n                    'X\n         \
    \           'X\n                    'X\n                    'X\n             \
    \       'X))\n              ((and (< remainder 100000000000)\n               \
    \     (< number 10000000000000))\n              (list 'I'\n                  \
    \  (int_to_mini_roman remainder number)\n                    'X\n            \
    \        'X\n                    'X\n                    'X\n                \
    \    'X\n                    'X))\n              ((and (< remainder 10000000000000)\n\
    \                    (< number 100000000000000))\n              (list 'I'\n  \
    \                  (int_to_mini_roman remainder number)\n                    'X\n\
    \                    'X\n                    'X\n                    'X\n    \
    \                'X\n                    'X\n                    'X))\n      \
    \        ((and (< remainder 1000000000000000)\n                    (< number 10000000000000000))\n\
    \              (list 'I'\n                    (int_to_mini_roman remainder number)\n\
    \                    'X\n                    'X\n                    'X\n    \
    \                'X\n                    'X\n                    'X\n        \
    \            'X))\n              ((and (< remainder 100000000000000000)\n    \
    \                (< number 1000000000000000000))\n              (list 'I'\n  \
    \                  (int_to_mini_roman remainder number)\n                    'X\n\
    \                    'X\n                    'X\n                    'X\n    \
    \                'X\n                    '", "  (cond [(< number 1)\n        \
    \ (string-append \"x\" #:number)]\n        [(< number 1000)\n         (string-append\
    \ (int_to_mini_roman / 100) #:roman)\n         (int_to_mini_roman - (* 100 number))\n\
    \         (string-append #:roman)]\n        [else\n         (string-append (int_to_mini_roman\
    \ / 10) #:roman)\n         (int_to_mini_roman - (* 10 number))\n         (string-append\
    \ #:roman)\n         (string-append (int_to_mini_roman % 10) #:number)]))\n",
  "  (cond\n    [(> number 1000) \"Error\"]\n    [(< number 1) \"Error\"]\n    [else\n\
    \     (string-append (int_to_mini_roman_char number) (int_to_mini_roman_char number))]))\n",
  "  (let* ((roman '())\n         (num (modulo (+ number 1) 1000))\n         (tens\
    \ (modulo (+ number 10) 100)))\n    (cond\n      [(< number 1000) (append roman\
    \ 'm) (append roman 'a)]\n      [(< num 100) (append roman 'l) (append roman 'i)]\n\
    \      [(< tens 100) (append roman 'c) (append roman 'l)]\n      [(< num 10) (append\
    \ roman 'x)]\n      [else (append roman 'd) (append roman 'o)]\n      )\n    (let*\
    \ ((result (append (int_to_mini_roman num) (mini_to_int_roman roman))))\n    \
    \  (if result result '0)))\n", "  (cond\n    [(< number 1) \"\"]\n    [(< number\
    \ 1000) (string-append \"i\" (int_to_mini_roman number))]\n    [else (let ([roman\
    \ \"M\"])\n             (cond\n              [(< number 400) (set! roman \"D\"\
    )]\n              [(< number 800) (set! roman \"C\")]\n              [(< number\
    \ 1200) (set! roman \"L\")]\n              [(< number 1600) (set! roman \"X\"\
    )]\n              [(< number 2000) (set! roman \"V\")]\n              [(< number\
    \ 2400) (set! roman \"I\")]\n              [else (set! roman \"M\")])])\n    \
    \       (string-append roman \"i\" (int_to_mini_roman number))]))\n", "  (let\
    \ ((iroman '())\n        (digit '()))\n    (cond [(< number 1) (set! iroman '())\n\
    \           (set! digit (substring '(1 i) (- number 1)))]\n          [(< number\
    \ 999) (set! iroman '())\n               (set! digit (substring '(1 i) number))\n\
    \               (cond [(< number 1000) (set! iroman '())\n                   \
    \    (set! digit (substring '(1 i) number))\n                       (set! iroman\
    \ digit)]\n                       [else (set! iroman digit \"M\"))]]))\n", " \
    \ (let loop ([result '()]\n             [number number]\n             [len 0])\n\
    \    (cond [(< number 1000)\n           (append result (make_roman_numeral number))]\n\
    \          [(>= number 1)\n           (loop (append result (make_roman_numeral\
    \ number)) (- number 1) (+ len 1))]\n          [else\n           (loop (append\
    \ result (make_roman_numeral number)) 0 len)])))\n", "  (let loop ((num number)\
    \ (folded '()))\n    (cond ((< num 1000) (fold-right (lambda (a b)\n         \
    \                              (string-append (mini_roman-to-int a) b))\n    \
    \                             (mini-roman-to-int num)))\n          ((< num 900)\
    \ (string-append (mini-roman-to-int (/ num (floor num 9)))\n                 \
    \                    (mini-roman-to-int (- num (floor num 9)))))\n          (else\
    \ (string-append (mini-roman-to-int (/ num (floor num 10)))\n                \
    \               (mini-roman-to-int (- num (floor num 10))))))))\n", "  (let* ((tens\
    \     (/ (expt 10 number) 10))\n         (hundreds (/ (expt 5 number) 10))\n \
    \        (thousands (/ (expt 4 number) 10))\n         (tens-tens (/ (expt 10 number)\
    \ 10))\n         (ones (- (expt 10 number) 10))\n         (tens-ones (- (expt\
    \ 10 number) 10))\n         (hundreds-ones (- (expt 5 number) 10))\n         (thousands-ones\
    \ (- (expt 4 number) 10)))\n    (cond\n      [(< thousands 1) (make-string (-\
    \ thousands 1) #\\0)]\n      [(< hundreds 1) (make-string (- hundreds 1) #\\0)]\n\
    \      [(< tens-tens 1) (make-string (- tens-tens 1) #\\0)]\n      [(< ones 1)\
    \ (make-string (- ones 1) #\\0)]\n      [(< tens-ones 1) (make-string (- tens-ones\
    \ 1) #\\0)]\n      [(< hundreds-ones 1) (make-string (- hundreds-ones 1) #\\0)]\n\
    \      [(< thousands-ones 1) (make-string (- thousands-ones 1) #\\0)]\n      [(<\
    \ thousands 1) (make-string (- thousands 1) #\\0)]\n      [(< hundreds 1) (make-string\
    \ (- hundreds 1) #\\0)]\n      [(< tens-tens 1) (make-string (- tens-tens 1) #\\\
    0)]\n      [(< ones 1) (make-string (- ones 1) #\\0)]\n      [(< tens-ones 1)\
    \ (make-string (- tens-ones 1) #\\0)]\n      [(< hundreds-ones 1) (make-string\
    \ (- hundreds-ones 1) #\\0)]\n      [(< thousands-ones 1) (make-string (- thousands-ones\
    \ 1) #\\0)]\n      [else (make-string (- thousands 1) #\\0)]\n      [else (make-string\
    \ (- hundreds 1) #\\0)]\n      [else (make-string (- tens-tens 1) #\\0)]\n   \
    \   [else (make-string (- ones 1) #\\0)]\n      [else (make-string (- tens-ones\
    \ 1) #\\0)]\n      [else (make-string (- hundreds-ones 1) #\\0)]\n      [else\
    \ (make-string (- thousands-ones 1) #\\0)])))\n", "  (cond\n    [(< number 1)\
    \ \"x\"]\n    [(< number 4) \"c\"]\n    [(< number 10) \"xc\"]\n    [(< number\
    \ 20) \"cc\"]\n    [else (int_to_mini_roman \n             (- number (floor (/\
    \ number 10))))\n          (+ number (floor (/ number 10)))]))\n", "  (cond [(<\
    \ number 1000) (int_to_mini_roman_to_digits number 0 \"\")]\n        [else (int_to_mini_roman_to_digits\
    \ number 1 \"i\")]))\n", "  (cond\n    ((= number 0) '0)\n    ((< number 1000)\
    \ (string-append \"x\" (int_to_mini_roman number)))\n    ((< number 1000000)\n\
    \     (string->number\n      (string-append (int_to_mini_roman floor (/ number\
    \ 1000))\n                    (roman-numeral-string number)))\n    ((< number\
    \ 1000000000)\n     (string->number\n      (string-append (int_to_mini_roman floor\
    \ (/ number 1000000))\n                    (roman-numeral-string number)\n   \
    \                 \"m\"))\n    ((< number 1000000000000)\n     (string->number\n\
    \      (string-append (int_to_mini_roman floor (/ number 1000000000))\n      \
    \              (roman-numeral-string number)\n                    \"cm\"))\n \
    \   ((< number 1000000000000000)\n     (string->number\n      (string-append (int_to_mini_roman\
    \ floor (/ number 1000000000000))\n                    (roman-numeral-string number)\n\
    \                    \"d\"))\n    ((< number 100000000000000000)\n     (string->number\n\
    \      (string-append (int_to_mini_roman floor (/ number 1000000000000000))\n\
    \                    (roman-numeral-string number)\n                    \"cd\"\
    ))\n    ((< number 100000000000000000) \n     (string->number\n      (string-append\
    \ (int_to_mini_roman floor (/ number 10000000000000000))\n                   \
    \ (roman-numeral-string number)\n                    \"xc\"))\n    ((< number\
    \ 1000000000000000000) \n     (string->number\n      (string-append (int_to_mini_roman\
    \ floor (/ number 100000000000000000))\n                    (roman-numeral-string\
    \ number)\n                    \"ix\"))\n    ((< number 100000000000000000000)\
    \ \n     (string->number\n      (string-append (int_to_mini_roman floor (/ number\
    \ 1000000000000000000))\n                    (roman-numeral-string number)\n \
    \                   \"v\"))\n    ((< number 10000000000000000000000)\n     (string->number\n\
    \      (string-append (int_to_mini_roman floor (/ number 100000000000000000000))\n\
    \                    (roman-numeral-string number)\n                    \"i\"\
    ))\n    ((< number 1000000000000000000000000)\n     (string->number\n      (string-append\
    \ (int_to_mini_roman floor (/ number 10000000000000000000000))\n             \
    \       (roman-numeral-string number)\n                    \"x\"))\n    ((< number\
    \ 10000000000000000000000000) \n     (string->number\n      (string-append (int_to_mini_roman\
    \ floor (/ number 1000000000000000000000000))\n                    (roman", " \
    \ (cond\n    [(< number 1) \"one\"]\n    [(< number 4) \"four\"]\n    [(< number\
    \ 10) \"ten\"]\n    [(< number 100) \"hundred\"]\n    [else (cond\n          \
    \  [(< number 400) \"thousand\"]\n            [(< number 200) \"hundred thousand\"\
    ]\n            [(< number 1000) \"thousand hundred\"]\n            [else (cond\n\
    \                    [(< number 1000) \"hundred thousand\"]\n                \
    \    [(< number 100) \"hundred\"]\n                    [(< number 10) \"ten\"\
    ]\n                    [(< number 4) \"four\"]\n                    [else \"one\"\
    ])]))])", "  (cond\n    [(<= 0 number) (error \"Not positive number: ~a\" number)]\n\
    \    [(= number 1) \"i\"]\n    [(= number 2) \"i\"]\n    [(= number 3) \"ii\"\
    ]\n    [(= number 4) \"iii\"]\n    [(= number 5) \"iv\"]\n    [(= number 6) \"\
    vi\"]\n    [(= number 7) \"vii\"]\n    [(= number 8) \"viii\"]\n    [(= number\
    \ 9) \"ix\"]\n    [(= number 10) \"x\"]\n    [(= number 11) \"xii\"]\n    [(=\
    \ number 12) \"xiii\"]\n    [(= number 13) \"xiv\"]\n    [(= number 14) \"xvi\"\
    ]\n    [(= number 15) \"xvii\"]\n    [(= number 16) \"xviii\"]\n    [(= number\
    \ 17) \"xi\"]\n    [(= number 18) \"xii\"]\n    [(= number 19) \"xiii\"]\n   \
    \ [(= number 20) \"xiv\"]\n    [(= number 21) \"xvi\"]\n    [(= number 22) \"\
    xvii\"]\n    [(= number 23) \"xviii\"]\n    [(= number 24) \"xix\"]\n    [(= number\
    \ 25) \"xx\"]\n    [(= number 26) \"xxi\"]\n    [(= number 27) \"xxii\"]\n   \
    \ [(= number 28) \"xxiii\"]\n    [(= number 29) \"xxiv\"]\n    [(= number 30)\
    \ \"xxvi\"]\n    [(= number 31) \"xxvii\"]\n    [(= number 32) \"xxviii\"]\n \
    \   [(= number 33) \"xxix\"]\n    [(= number 34) \"xxx\"]\n    [(= number 35)\
    \ \"xxxi\"]\n    [(= number 36) \"xxxii\"]\n    [(= number 37) \"xxxiii\"]\n \
    \   [(= number 38) \"xxxiv\"]\n    [(= number 39) \"xxxvi\"]\n    [(= number 40)\
    \ \"xxxvii\"]\n    [(= number 41) \"xxxviii\"]\n    [(= number 42) \"xxxix\"]\n\
    \    [(= number 43) \"xxxx\"]\n    [(= number 44) \"xxxxi\"]\n    [(= number 45)\
    \ \"xxxxii\"]\n    [(= number 46) \"xxxxiii\"]\n    [(= number 47) \"xxxxiv\"\
    ]\n    [(= number 48) \"xxxxvi\"]\n    [(= number 49) \"xxxxvii", "  (cond [(<=\
    \ number 1) \"x\"]\n        [(<= number 4) \"v\"]\n        [(<= number 9) \"i\"\
    ]\n        [(<= number 10) \"xii\"]\n        [(<= number 50) \"c\"]\n        [(<=\
    \ number 100) \"xc\"]\n        [(<= number 500) \"c\"]\n        [(<= number 1000)\
    \ \"xc\"]\n        [(<= number 5000)\n         (string->char\n          (string->string\n\
    \           (string-append \"cd\" (mini_roman_numeral number))))]\n        [else\n\
    \         (string->char\n          (string->string\n           (string-append\
    \ \"cm\" (mini_roman_numeral number))))]\n        )\n      )\n", "  (let loop\
    \ ((num number) (res '())\n             (i 0))\n    (cond\n      ((< num 1000)\n\
    \       (if (= i 0)\n           (loop (sub1 num) (cons num (reverse res)) (add1\
    \ i))\n           (loop (sub1 num) (cons (- num (expt i 3)) (reverse res)) (add1\
    \ i))))\n      ((< num 100000)\n       (if (= i 0)\n           (loop (sub1 num)\
    \ (cons num (reverse res)) (add1 i))\n           (loop (sub1 num) (cons (- num\
    \ (expt i 4)) (reverse res)) (add1 i))))\n      (else\n       (if (= i 0)\n  \
    \         (loop (sub1 num) (cons num (reverse res)) (add1 i))\n           (loop\
    \ (sub1 num) (cons (- num (expt i 5)) (reverse res)) (add1 i))))\n    (string-append\
    \ (sub1 (expt i 3)) res)))\n", "  (define i 0)\n  (define str '())\n  (define\
    \ len 0)\n  (define base '())\n  (define roman '())\n  (define remainder 0)\n\
    \  (define count 0)\n  (let loop ([num number] [i 0])\n    (cond [(< i 1000)\n\
    \           (begin (set! i (+ i 1))\n                  (set! len (length str))\n\
    \                  (set! base (substring str 0 i))\n                  (set! roman\
    \ (substring str i len))\n                  (set! remainder (remainder num base\
    \ len))\n                  (set! count (count base len roman remainder))\n   \
    \               (set! str (concat (substring str 0 i)\n                      \
    \             'x\n                                   roman\n                 \
    \                  \"x\"\n                                   (substring str i\
    \ (+ len (+ i 1)))\n                                   '\n                   \
    \                count))\n                  (set! i (+ i 1))\n               \
    \   (loop (quotient num 10) (+ i 1))\n                  (set! num (quotient num\
    \ 10))]\n          [(< num 0) (set! num (quotient num 10))\n                 \
    \ (set! count (count base len roman remainder))]\n          [else (set! count\
    \ (count base len roman remainder))\n                (set! str (concat (substring\
    \ str 0 i)\n                                   roman\n                       \
    \            \"x\"\n                                   (substring str i (+ len\
    \ (+ i 1)))\n                                   '\n                          \
    \         count))\n                (set! i (+ i 1))\n                (loop (quotient\
    \ num 10) (+ i 1))]\n         )\n      )\n      str\n    )\n  )\n", "  (if (<\
    \ number 1000)\n      (int_to_mini_roman (sub1 number))\n      (let ((remainder\
    \ (modulo number 1000)))\n        (string->symbol (+ (symbol->string (sub1 (symbol->string\
    \ \"M\")) remainder))\n                      (int_to_mini_roman remainder)))))\
    \ ; string->symbol is for R6RS compatibility\n", "  (cond\n    [(= number 0)\n\
    \     '']\n    [(= number 1)\n     'i]\n    [(= (mod number 5) 0)\n     'c']\n\
    \    [(= (mod number 5) 1)\n     'l']\n    [(= (mod number 5) 2)\n     'm']\n\
    \    [else\n     (let ([i 0]\n           [numerals '(m l c x))])\n       (cond\n\
    \         [(= (mod number 5) 3)\n          (append numerals '(di di di di))\n\
    \         [else\n          (append numerals (string->list '(f m f f m f f f)))]\n\
    \         [else\n          (let ([x number])\n            (cond\n            \
    \  [(= x 1)\n               (cond\n                 [(= (mod x 4) 0)\n       \
    \           'i]\n                 [else\n                  (append numerals (string->list\
    \ '(f f m m f f m m f)))]\n                 [else\n                  (append numerals\
    \ (string->list '(f f f m m m m m)))]\n                 )])]\n              [(=\
    \ x 2)\n               (cond\n                 [(= (mod x 4) 0)\n            \
    \      'v]\n                 [else\n                  (append numerals (string->list\
    \ '(f f f f m m m m)))]\n                 [else\n                  (append numerals\
    \ (string->list '(f f f f f m m m)))]\n                 )])]\n              [(=\
    \ x 3)\n               (cond\n                 [(= (mod x 4) 0)\n            \
    \      'x)]\n                 [else\n                  (append numerals (string->list\
    \ '(f f f f f f m m)))]\n                 [else\n                  (append numerals\
    \ (string->list '(f f f f f f f m)))]\n                 )])]\n              [else\n\
    \              (append numerals (string->list '(f f f f f f f f m)))]\n      \
    \        [else\n              (let ([y number])\n                (cond\n     \
    \             [(= y 4)\n                   (cond\n                     [(= (mod\
    \ y 2) 0)\n                      'd]\n                     [else\n           \
    \           (append numerals (string->list '(f f f f f f f f f f)))]\n       \
    \              [else\n                      (append numerals (string->list '(f\
    \ f f f f f f f f f f)))]\n                     )])]\n                  [(= y ",
  "  (if (> number 0)\n      (string-append (int_to_mini_roman_numeral number) \"\"\
    )\n      'invalid))\n", "  (define roman '())\n  (define (roman-numeral-helper\
    \ num roman)\n    (cond ((> num 1) (cons roman '()))\n          ((< num 0) (error\
    \ \"Not a positive integer!\"))\n          ((char=? (char #\\M) (char num))\n\
    \           (cons (char num) (roman-numeral-helper (- num 1) (cons roman '()))))\n\
    \          (else (roman-numeral-helper (- num 1) (cons roman '()))))\n  (roman-numeral-helper\
    \ number roman))\n", "  (letrec\n    ((roman-char (lambda (x)\n\t\t   (cond\n\t\
    \t   ((> x 0) 'i)\n\t\t   ((= x 1) 'x)\n\t\t   ((= x 2) 'v)\n\t\t   ((= x 3) 'x)\n\
    \t\t   ((= x 4) 'l)\n\t\t   ((= x 5) 'x)\n\t\t   ((= x 6) 'h)\n\t\t   ((= x 7)\
    \ 'c)\n\t\t   ((= x 8) 'l')\n\t\t   ((= x 9) 'c')\n\t\t   ((= x 10) 'd')\n\t\t\
    \   ((= x 100) 'm))\n\t\t   ((> x 100) 'd))\n      (string->list (string->symbols\
    \ (roman-char x))))))\n    (string->lower (string->list (string->symbols (roman-char\
    \ number)))))\n\n", "  (let* ((result (cond\n                 ((= number 1) (list\
    \ (list \"i\")))\n                 ((= number 2) (list (list \"ii\")))\n     \
    \            ((= number 3) (list (list \"iii\")))\n                 ((= number\
    \ 4) (list (list \"iv\")))\n                 ((= number 5) (list (list \"v\")))\n\
    \                 ((= number 6) (list (list \"vi\")))\n                 ((= number\
    \ 7) (list (list \"vii\")))\n                 ((= number 8) (list (list \"viii\"\
    )))\n                 ((= number 9) (list (list \"ix\")))\n                 ((=\
    \ number 10) (list (list \"x\")))\n                 ((= number 11) (list (list\
    \ \"xi\")))\n                 ((= number 12) (list (list \"xii\")))\n        \
    \         ((= number 13) (list (list \"xiv\")))\n                 ((= number 14)\
    \ (list (list \"xv\")))\n                 ((= number 15) (list (list \"xvi\")))\n\
    \                 ((= number 16) (list (list \"xvii\")))\n                 ((=\
    \ number 17) (list (list \"xviii\")))\n                 ((= number 18) (list (list\
    \ \"xivi\")))\n                 ((= number 19) (list (list \"xix\")))\n      \
    \           ((= number 20) (list (list \"xxx\")))\n                 ((= number\
    \ 30) (list (list \"xxxvi\")))\n                 ((= number 40) (list (list \"\
    xxxvii\")))\n                 ((= number 50) (list (list \"xxxviii\")))\n    \
    \             ((= number 60) (list (list \"xxxix\")))\n                 ((= number\
    \ 100) (list (list \"xx\")))\n                 ((= number 200) (list (list \"\
    xxi\")))\n                 ((= number 300) (list (list \"xxii\")))\n         \
    \        ((= number 400) (list (list \"xxiii\")))\n                 ((= number\
    \ 500) (list (list \"xxiv\")))\n                 ((= number 600) (list (list \"\
    xxv\")))\n                 ((= number 700) (list (list \"xxvi\")))\n         \
    \        ((= number 800) (list (list \"xxvii\")))\n                 ((= number\
    \ 900) (list (list \"xxviii\")))\n                 ((= number 1000) (list (list\
    \ \"xxx\")))\n                 (else (error \"int_to_mini_roman expects a number\
    \ between 1 and 1000\"))))\n         (result (cons (reverse result) (map (\u03BB\
    \ (x) (* (length x) x)\n                                                (substring\
    \ number (- (length number) 1))))))))\n", "  (define (iter i roman)\n    (cond\
    \ [(= i number) (string roman)]\n          [else (iter (+ i 1) (append roman \"\
    M\"))]))\n  (iter 1 \"\"))\n", "  (cond [(< number 1) \"x\"]\n        [(< number\
    \ 5) \"v\"]\n        [(< number 10) \"l\"]\n        [else (if (< number (- 1000\
    \ 1)) (int_to_mini_roman 100 (- number 1)) (int_to_mini_roman 1000 (- number 1))\n\
    \                   (if (< number (- 10 1)) (int_to_mini_roman 10 (- number 1))\
    \ (int_to_mini_roman 100 (- number 1))\n                   #error \"number too\
    \ big\"))]))\n", "  (cond\n    [(< number 1)\n     (string-append \"I\" empty)]\n\
    \    [(< number 10)\n     (string-append \"X\" empty)]\n    [(< number 100)\n\
    \     (string-append \"C\" empty)]\n    [(< number 1000)\n     (string-append\
    \ \"D\" empty)]\n    [else\n     (let ([result (substring (string-append \"M\"\
    \ empty) 0 3)])\n       (cond\n         [(< number 1000)\n          (string-append\
    \ result empty)]\n         [(< number 900)\n          (string-append result empty)]\n\
    \         [(< number 800)\n          (string-append result (string-append \"V\"\
    \ empty))]\n         [(< number 700)\n          (string-append result (string-append\
    \ \"I\" empty))]\n         [(< number 600)\n          (string-append result (string-append\
    \ \"II\" empty))]\n         [(< number 500)\n          (string-append result (string-append\
    \ \"III\" empty))]\n         [(< number 400)\n          (string-append result\
    \ (string-append \"IV\" empty))]\n         [(< number 300)\n          (string-append\
    \ result (string-append \"V\" empty))]\n         [(< number 200)\n          (string-append\
    \ result (string-append \"IV\" empty))]\n         [(< number 100)\n          (string-append\
    \ result (string-append \"V\" empty))]\n         [(< number 10)\n          (string-append\
    \ result (string-append \"I\" empty))]\n         [else\n          (string-append\
    \ result (string-append (int_to_mini_roman number / 10) empty))]\n       )\n \
    \    )\n    )]\n  )\n)\n", "  (let* ((digits (string-length (number->string number)))\n\
    \         (n (string->number (number->string number)))\n         (roman (make-array\
    \ (+ n digits) (+ digits digits))))\n    (make-roman-numeral-table! roman n)\n\
    \    (loop [idx 0 acc (make-roman-numeral-table! roman 0)]\n      (cond\n    \
    \    ((< idx number) (string-append (number->string acc) \"\"))\n        ((or\
    \ (= idx number) (= idx digits)\n               (= 0 (modulo (- idx digits) n))\n\
    \               (= 0 (modulo (+ idx digits) n))\n               (= 0 (modulo idx\
    \ n))\n               (= 1 (modulo (- idx n) n)))\n          (string-append (number->string\
    \ acc) \"\"))\n        (else (set! acc (make-roman-numeral-table! roman idx))\n\
    \               (set! idx (+ idx 1)))\n        (else (set! acc (make-roman-numeral-table!\
    \ roman idx))\n               (set! idx (+ idx 1))))))\n</code>\nRacket is a dialect\
    \ of Lisp, so it can be used without modification. Most of the code is identical\
    \ in most of the implementations. I used a bunch of let* to make it clear what\
    \ happens at each step, but this is not necessary in Scheme or Common Lisp.\n\
    <|/ a dscore=0 |>\n<| c |>\nI like the solution, but I'd like to see a solution\
    \ that does not use recursion. I understand that it's possible in languages that\
    \ support recursion such as Scheme or Common Lisp but I don't see how this can\
    \ be done in Clojure.\n<|/ c |>\n<| c |>\n: I think you can do it without recursion\
    \ in CL.\n<|/ c |>\n<| c |>\n: You can do it in Scheme. Scheme, however, has recursion.\
    \ Just turn it into tail recursion.\n<|/ c |>\n<| c |>\n: Thanks for the suggestion\
    \ but that's not quite the same thing as the code I posted. The code I posted\
    \ is more like what I need: To take a number and to output the smallest number\
    \ of roman numerals needed to convert that number to text.\n<|/ c |>\n<| c |>\n\
    : But your code is also a solution that doesn't use recursion. Or am I missing\
    \ something?\n<|/ c |>\n<| a |>\nOk, I think I have found the solution I need.\
    \ It's not as straightforward as I would have hope", "  (if (< number 1000)\n\
    \      (let ([remainder (modulo number 1000)])\n        (string-append (int_to_mini_roman\
    \ remainder) (string-append \"M\" (remainder-to-int remainder)))\n        (let\
    \ ([remainder (remainder 1000)])\n          (int_to_mini_roman remainder)))))\n",
  "  (cond\n    ((< number 0)\n     \"-1\")\n    ((< number 1000)\n     (str_append\
    \ \"x\" string))\n    ((< number 4000)\n     (str_append \"i\" string))\n    ((<\
    \ number 8000)\n     (str_append \"ii\" string))\n    ((< number 16000)\n    \
    \ (str_append \"iii\" string))\n    ((< number 32000)\n     (str_append \"iv\"\
    \ string))\n    ((< number 64000)\n     (str_append \"v\" string))\n    ((< number\
    \ 128000)\n     (str_append \"vi\" string))\n    ((< number 256000)\n     (str_append\
    \ \"vii\" string))\n    ((< number 512000)\n     (str_append \"viii\" string))\n\
    \    ((< number 1024000)\n     (str_append \"ix\" string))\n    ((< number 2048000)\n\
    \     (str_append \"x\" string))\n    ((< number 4096000)\n     (str_append \"\
    x\" string))\n    ((< number 1600000)\n     (str_append \"x\" string))\n    ((<\
    \ number 3200000)\n     (str_append \"x\" string))\n    ((< number 6400000)\n\
    \     (str_append \"x\" string))\n    ((< number 12800000)\n     (str_append \"\
    x\" string))\n    ((< number 25600000)\n     (str_append \"x\" string))\n    ((<\
    \ number 51200000)\n     (str_append \"x\" string))\n    ((< number 102400000)\n\
    \     (str_append \"x\" string))\n    ((< number 204800000)\n     (str_append\
    \ \"x\" string))\n    ((< number 409600000)\n     (str_append \"x\" string))\n\
    \    ((< number 160000000)\n     (str_append \"x\" string))\n    ((< number 320000000)\n\
    \     (str_append \"x\" string))\n    ((< number 640000000)\n     (str_append\
    \ \"x\" string))\n    ((< number 1280000000)\n     (str_append \"x\" string))\n\
    \    ((< number 2560000000)\n     (str_append \"x\" string))\n    ((< number 5120000000)\n\
    \     (str_append \"x\" string))\n    ((< number 10240000000)\n     (str_append\
    \ \"x\" string))\n    ((< number 20480000000)\n     (str_append \"x\" string))\n\
    \    ((< number 40960000000)\n     (str_append \"x\" string))\n    ((< number\
    \ 1600000000)\n     (str_append \"x\" string))\n    ((< number 3200000000)", " \
    \ (if (< number 0)\n      (error \"Argument must be greater than 0.\" number)\n\
    \      (let ([remainder (modulo number 10)])\n        (cond ((= remainder 0) '0)\n\
    \              ((= remainder 1) 'i)\n              ((= remainder 2) 'x)\n    \
    \          ((= remainder 3) 'g)\n              ((= remainder 4) 'm)\n        \
    \      ((= remainder 5) 'l)\n              ((= remainder 6) 'c)\n            \
    \  ((= remainder 7) 'v)\n              ((= remainder 8) 'x)\n              ((=\
    \ remainder 9) 'x)\n              ((= remainder 10) 'c)\n              ((= remainder\
    \ 11) 'x)\n              ((= remainder 12) 'l)\n              ((= remainder 13)\
    \ 'm)\n              ((= remainder 14) 'g)\n              ((= remainder 15) 'v)\n\
    \              (else (int_to_mini_roman number)\n                    (- number\
    \ (modulo number 10))))))\n", "  (let ((roman_numerals '(\n                  \
    \  '(i ii)\n                    '(xi xii)\n                    '(ci cii)\n   \
    \                 '(vi vii)\n                    '(xc xci)\n                 \
    \   '(c ci)\n                    '(v vi)\n                    '(xl xci)\n    \
    \                '(l ci)\n                    '(xo xci)\n                    '(o\
    \ ci)\n                    '(vc vi)\n                    '(x xc)\n           \
    \         '(c x)\n                    '(v v)\n                    '(xl xc)\n \
    \                   '(l c)\n                    '(xo xc)\n                   \
    \ '(o c)\n                    '(vl vc)\n                    '(x l)\n         \
    \           '(c x)\n                    '(v l)\n                    '(xl l)\n\
    \                    '(l x)\n                    '(xo l)\n                   \
    \ '(o x)\n                    '(vl v)\n                    '(x o)\n          \
    \          '(c o)\n                    '(v o)\n                    '(xl o)\n \
    \                   '(l o)\n                    '(xo o)\n                    '(o\
    \ o)\n                    '(vl vc)\n                    '(x v)\n             \
    \       '(c x)\n                    '(v x)\n                    '(xl x)\n    \
    \                '(l x)\n                    '(xo x)\n                    '(o\
    \ x)\n                    '(vl l)\n                    '(x x)\n              \
    \      '(c x)\n                    '(v x)\n                    '(xl x)\n     \
    \               '(l x)\n                    '(xo x)\n                    '(o x)\n\
    \                    '(vc x)\n                    '(x x)\n                   \
    \ '(c x)\n                    '(v x)\n                    '(xl x)\n          \
    \          '(l x)\n                    '(xo x)\n                    '(o x)\n \
    \                   '(vl x)\n                    '(x x)\n                    '(c\
    \ x)\n                    '(v x)\n                    '(xl x)\n              \
    \      '(l x)\n                    '(xo x)\n                    '(o x)\n     \
    \               '(vc x)\n                    '(x x)\n                    '(c x)\n\
    \                    '(v x)\n                    '(xl x)\n                   \
    \ '(l x)\n                    '(xo x)\n                    '(o x)\n          \
    \          '(vl x)\n                    '(x x)\n                    '(c x)\n \
    \                   '(v x)\n                    '(xl x)\n                    '(l\
    \ x)\n                    '(xo x)\n                    '(o x)\n              \
    \      '(vc x)\n                    '(x x)\n                    '(c x)\n     \
    \               '(v x)\n                    '(xl x)\n                    '(l x)\n\
    \                    '(xo x)\n                    '(o x)\n                   \
    \ '(vl x)\n                    '(x x)\n                    '(c x)\n          \
    \          '(v x)\n                    '(xl x)\n", "  (cond [(< number 1)\n  \
    \       '()]\n        [(< number 1000)\n         (mini-roman number (+ number\
    \ ((- number 1) (expt 2 number))) (make-roman number))\n         (append (int_to_mini_roman\
    \ number (+ number ((- number 1) (expt 2 number))))\n                (mini-roman\
    \ number (expt 2 number) '())])\n        [else\n         (mini-roman number (expt\
    \ 2 number) '())]))\n", "  (if (zero? number)\n      '()\n      (append (roman_numeral\
    \ (- number 1000) 'vi) (string-downcase (mini_roman number))))) ;; #lang racket\n",
  "  (cond\n    [(<= 0 number 1000)\n     (string-append (roman number) (lower-case\
    \ (mini_roman number)))]\n    [else\n     (int_to_mini_roman number + 1)]))\n",
  "  (let loop ((num number) (roman \"\"))\n    (cond\n      [(> num 1000)\n     \
    \  (format #t \"~a\" roman)\n       roman]\n      [(= num (mod num 1000))\n  \
    \     (loop (/ num 1000)\n              (append roman \"M\"))]\n      [else\n\
    \       (loop (mod num 1000)\n              (append roman \"V\"))])))\n", "  (cond\
    \ [(< number 1000) (mini_roman_numeral_to_string number)]\n        [else (int_to_mini_roman\
    \ (- number 1000))]))\n", "  (cond\n    [(< number 1)\n      (list->string '())]\n\
    \    [(< number 1000)\n      (list \"x\")\n      (append (int_to_mini_roman number)\
    \ (list \"xix\"))]\n    [else\n      (let\n          [result (list->string '())\n\
    \            i (- number 1)]\n        (cond\n          [(< i 6)\n            (append\
    \ result (list \"c\"))]\n          [(< i 9)\n            (append result (list\
    \ \"cc\"))]\n          [(< i 12)\n            (append result (list \"ccc\"))]\n\
    \          [(< i 15)\n            (append result (list \"cccc\"))]\n         \
    \ [(< i 18)\n            (append result (list \"ccccc\"))]\n          [(< i 21)\n\
    \            (append result (list \"cccccc\"))]\n          [(< i 24)\n       \
    \     (append result (list \"ccccccc\"))]\n          [(< i 27)\n            (append\
    \ result (list \"ccccccc\"))]\n          [(< i 30)\n            (append result\
    \ (list \"ccccccc\"))]\n          [(< i 33)\n            (append result (list\
    \ \"ccccccc\"))]\n          [(< i 36)\n            (append result (list \"ccccccc\"\
    ))]\n          [(< i 39)\n            (append result (list \"ccccccc\"))]\n  \
    \        [(< i 42)\n            (append result (list \"ccccccc\"))]\n        \
    \  [(< i 45)\n            (append result (list \"ccccccc\"))]\n          [(< i\
    \ 48)\n            (append result (list \"ccccccc\"))]\n          [(< i 51)\n\
    \            (append result (list \"ccccccc\"))]\n          [(< i 54)\n      \
    \      (append result (list \"ccccccc\"))]\n          [(< i 57)\n            (append\
    \ result (list \"ccccccc\"))]\n          [(< i 60)\n            (append result\
    \ (list \"ccccccc\"))]\n          [(< i 62)\n            (append result (list\
    \ \"ccccccc\"))]\n          [(< i 65)\n            (append result (list \"ccccccc\"\
    ))]\n          [(< i 68)\n            (append result (list \"ccccccc\"))]\n  \
    \        [(< i 71)\n            (append result (list \"ccccccc\"))]\n        \
    \  [(< i 74)\n            (append result (list \"ccccccc\"))]\n          [(< ",
  "  (let loop ([i number] [s \"\"])\n    (if (< i 1000)\n        (loop (+ i 1) (cons\
    \ i (reverse s))) (let ([t (string->list (number->roman i))])\n          (cond\
    \ [(< i 100) (concat [\"x\"(string->list (number->roman i/10))] s)\n         \
    \       (= i 1000) (string->list s)\n                (else (string-append (number->roman\
    \ i/10) (number->roman i) (number->roman i/10) (number->roman i/10))\n       \
    \         (string->list s))]))))\n", "  (cond\n    ((= number 0)\n      \"0\"\
    )\n    ((< number 1000)\n      \"x\")\n    ((< number 199)\n      \"l\")\n   \
    \ ((< number 399)\n      \"c\")\n    ((< number 699)\n      \"d\")\n    ((< number\
    \ 899)\n      \"e\")\n    ((< number 1199)\n      \"f\")\n    ((< number 1399)\n\
    \      \"g\")\n    ((< number 1599)\n      \"h\")\n    ((< number 1799)\n    \
    \  \"i\")\n    ((< number 1900)\n      \"j\")\n    ((< number 2100)\n      \"\
    k\")\n    ((< number 2200)\n      \"l\")\n    ((< number 2300)\n      \"m\")\n\
    \    ((< number 2400)\n      \"n\")\n    ((< number 2500)\n      \"o\")\n    ((<\
    \ number 2600)\n      \"p\")\n    ((< number 2700)\n      \"q\")\n    ((< number\
    \ 2800)\n      \"r\")\n    ((< number 2900)\n      \"s\")\n    ((< number 3000)\n\
    \      \"t\")\n    ((< number 3100)\n      \"u\")\n    ((< number 3200)\n    \
    \  \"v\")\n    ((< number 3300)\n      \"w\")\n    ((< number 3400)\n      \"\
    x\")\n    ((< number 3500)\n      \"y\")\n    ((< number 3600)\n      \"z\")\n\
    \    ((< number 3700)\n      \"a\")\n    ((< number 3800)\n      \"b\")\n    ((<\
    \ number 3900)\n      \"c\")\n    ((< number 4000)\n      \"d\")\n    ((< number\
    \ 4100)\n      \"e\")\n    ((< number 4200)\n      \"f\")\n    ((< number 4300)\n\
    \      \"g\")\n    ((< number 4400)\n      \"h\")\n    ((< number 4500)\n    \
    \  \"i\")\n    ((< number 4600)\n      \"j\")\n    ((< number 4700)\n      \"\
    k\")\n    ((< number 4800)\n      \"l\")\n    ((< number 4900)\n      \"m\")\n\
    \    ((< number 5000)\n      \"n\")\n    ((< number 5100)\n      \"o\")\n    ((<\
    \ number 5200)\n      \"p\")\n    ((< number 5300)\n      \"q\")\n    ((< number\
    \ 5400)\n      \"r\")\n    ((< number 5500)\n      \"s\")\n    ((< number 5600)\n\
    \      \"t\")\n    ((< number 5700)\n      \"u\")\n    ((< number 5800)\n    \
    \  \"v\")\n    ((< number 5900)\n      \"w\")\n    ((< number 6000)\n      \"\
    x\")\n    ((< number 6100)\n", "  (define (helper num str cur)\n    (if (= num\
    \ 0)\n        (reverse str)\n        (helper (sub1 num) \n                (cons\
    \ (char num (char-code #\\))) \n                (add str cur)))))\n  (helper number\
    \ #\\1 0))\n</code>\n<|/ a |>\n<| c |>\nThanks for your answer. Is there a way\
    \ to do the same without using \"define\", since I did not learn it yet and it\
    \ would be easier for me to not use it? I used the define for my own purposes\
    \ but would like to do the same without using it.\n<|/ c |>\n<| c |>\nWhat do\
    \ you mean? `define` is already in Racket (and Scheme). It is used to define the\
    \ function `helper` within the `int_to_mini_roman` function. It is already there.\
    \ Without it, you'd need to use `let` to define `helper`. Why would you want to\
    \ avoid `define`?\n<|/ c |>\n<| a dscore=0 |>\nHere is a simple solution which\
    \ uses only basic racket functions. However, it doesn't use define or recursion.\n\
    <code>", "  (cond\n    [(< number 1)\n     (printf \"x\")\n     (int_to_mini_roman\
    \ number)]\n    [(< number 10)\n     (printf \"d\")\n     (int_to_mini_roman number)]\n\
    \    [(< number 100)\n     (printf \"c\")\n     (int_to_mini_roman number)]\n\
    \    [(< number 1000)\n     (printf \"m\")\n     (int_to_mini_roman number)]\n\
    \    [else\n     (printf \"m\")\n     (int_to_mini_roman number)]\n  ))\n", " \
    \ (cond\n    [(< number 0) \"0\"]\n    [(< number 999) \"thousand\"]\n    [(<\
    \ number 199) \"million\"]\n    [(< number 999) (incf number (-999))\n    ;; The\
    \ following two lines are commented out because the\n    ;; result is an infinite\
    \ recursion.\n    ;; (decf number (-999))\n    (if (= number (car roman_numerals))\n\
    \        (string-append (car roman_numerals) (int_to_mini_roman number))\n   \
    \     (int_to_mini_roman number)))]))\n", "  (let ((result (make-string-builder)))\n\
    \    (loop\n       (cond\n         ((< number 999)\n          (append-string (number->roman-numeral\
    \ number) result))\n         (else\n          (append-string (number->roman-numeral\
    \ (- number 1000)) result)\n          (return-from int_to_mini_roman result)))))\n\
    \  (string-lower (string-append (current-output-stream) \"\\n\")))\n", "  (cond\n\
    \    [(or (= number 0) (= number 1000)) (make-string 0 \"\")] \n    [(< number\
    \ 1) (make-string 0 \"\")] \n    [else (loop for i below number collect (int_to_mini_roman\
    \ i))]))\n", "  (cond\n    [(< number 1)\n     (string-append \"x\" (int_to_mini_roman\
    \ 0 (sub1 number)))]\n    [else\n     (let ([digits (string->list (string->symbol\
    \ number))]\n           [remainder (modulo number 10)])\n       (cond\n      \
    \   [(= remainder 0)\n          (string-append (mini_roman_numeral_for_digit digits)\
    \ \"i\")]\n         [(even? remainder)\n          (string-append (int_to_mini_roman\
    \ 0 (sub1 number)) (mini_roman_numeral_for_digit digits))]\n         [else\n \
    \         (string-append (int_to_mini_roman 0 (sub1 number)) (mini_roman_numeral_for_digit\
    \ digits))])))]))\n", "  (cond\n    ((= number 0) \"\")\n    ((< number 1) (int_to_mini_roman\
    \ number) (cons (char (roman-numeral-code-for number 'I) 'I int_to_mini_roman))\n\
    \                               (int_to_mini_roman number) (cons (char (roman-numeral-code-for\
    \ number 'V) 'V int_to_mini_roman))\n                               (int_to_mini_roman\
    \ number) (cons (char (roman-numeral-code-for number 'X) 'X int_to_mini_roman))\n\
    \                               (int_to_mini_roman number) (cons (char (roman-numeral-code-for\
    \ number 'L) 'L int_to_mini_roman))\n                               (int_to_mini_roman\
    \ number) (cons (char (roman-numeral-code-for number 'C) 'C int_to_mini_roman))\n\
    \                               (int_to_mini_roman number) (cons (char (roman-numeral-code-for\
    \ number 'D) 'D int_to_mini_roman))\n                               (int_to_mini_roman\
    \ number) (cons (char (roman-numeral-code-for number 'M) 'M int_to_mini_roman))\n\
    \                               (int_to_mini_roman number) (cons (char (roman-numeral-code-for\
    \ number 'M') 'M int_to_mini_roman)))\n    ((= number 1000) (int_to_mini_roman\
    \ number) (cons (char (roman-numeral-code-for number 'I) 'I int_to_mini_roman))\n\
    \                               (int_to_mini_roman number) (cons (char (roman-numeral-code-for\
    \ number 'V) 'V int_to_mini_roman))\n                               (int_to_mini_roman\
    \ number) (cons (char (roman-numeral-code-for number 'X) 'X int_to_mini_roman))\n\
    \                               (int_to_mini_roman number) (cons (char (roman-numeral-code-for\
    \ number 'L) 'L int_to_mini_roman))\n                               (int_to_mini_roman\
    \ number) (cons (char (roman-numeral-code-for number 'C) 'C int_to_mini_roman))\n\
    \                               (int_to_mini_roman number) (cons (char (roman-numeral-code-for\
    \ number 'D) 'D int_", "  (let loop ((i number) (n '())) (if (> i 1000) (append\
    \ n 'x) (loop (+ i 1) (append n (string->list i)))))\n    (apply string-append\
    \ n)))\n", "  (if (>= number 0)\n      (let ((roman (cons (int_to_roman (modulo\
    \ number 1000)) '())))\n        (string-append (string-append (int_to_roman (modulo\
    \ number 1000)) '\n                                            (if (>= (modulo\
    \ number 1000) 100)\n                                                'ii\n   \
    \                                             (if (>= (modulo number 1000) 500)\n\
    \                                                    'iii'\n                 \
    \                                   (if (>= (modulo number 1000) 1000)\n     \
    \                                                   'iv\n                    \
    \                                    'v))))))\n      '))\n", "  (define (helper\
    \ number result accumulator)\n    (cond\n      [(= accumulator \"\") (cons number\
    \ result)]\n      [(zero? (number-mod number 1000)) (helper number\n         \
    \                               (cons (car (reverse accumulator))\n          \
    \                                    result)\n                               \
    \         (append (cdr (reverse accumulator))\n                              \
    \                  (list number)))]\n      [else (helper (number-mod number 1000)\n\
    \                  (cons (car (reverse accumulator))\n                       \
    \ (cons (number-mod number 1000)\n                              result))\n   \
    \               (append (cdr (reverse accumulator))\n                        \
    \  (list number)))]))\n  (helper number '() (list number)))\n", "  (if (negative?\
    \ number)\n      (error 'int_to_mini_roman \"Cannot convert negative number to\
    \ mini roman.\" (number))\n      (let ((str (make-string\n                   (+\
    \ 2 number)\n                   #:initial-element 'x)))\n        (cond [(< number\
    \ 1) (error 'int_to_mini_roman \"Invalid input. \" number)]\n              [(<\
    \ number 1000) (error 'int_to_mini_roman \"Invalid input. \" number)]\n      \
    \        [else (loop for i from 0 below (+ 2 number) collect (if (> i number)\
    \ (cons str i) (cons 'i (cons str i))) (append str str)])))\n</code>\n<|/ a dscore=2\
    \ |>\n<| a tags=scheme,racket |>\nAnother solution:\n<code>", "  (let ((n number))\n\
    \    (cond\n      [(= n 1) (symbol \"x\")]\n      [(= n 9) (symbol \"x\")]\n \
    \     [(< n 10) (symbol \"c\")]\n      [(< n 100) (symbol \"d\")]\n      [(< n\
    \ 1000) (symbol \"l\")]\n      [(< n 10000) (symbol \"m\")]\n      [(< n 10000)\
    \ (symbol \"n\")]\n      [(< n 100000) (symbol \"x\")]\n      [(< n 100000) (symbol\
    \ \"i\")]\n      [(< n 1000000) (symbol \"v\")]\n      [(< n 1000000) (symbol\
    \ \"i\")]\n      [(< n 10000000) (symbol \"x\")]\n      [(< n 100000000) (symbol\
    \ \"l\")]\n      [(< n 100000000) (symbol \"i\")]\n      [(< n 1000000000) (symbol\
    \ \"x\")]\n      [(< n 1000000000) (symbol \"v\")]\n      [(< n 10000000000) (symbol\
    \ \"c\")]\n      [(< n 10000000000) (symbol \"l\")]\n      [(< n 100000000000)\
    \ (symbol \"x\")]\n      [(< n 100000000000) (symbol \"v\")]\n      [(< n 1000000000000)\
    \ (symbol \"x\")]\n      [(< n 1000000000000) (symbol \"c\")]\n      [(< n 10000000000000)\
    \ (symbol \"i\")]\n      [(< n 100000000000000) (symbol \"x\")]\n      [(< n 100000000000000)\
    \ (symbol \"v\")]\n      [(< n 1000000000000000) (symbol \"i\")]\n      [(< n\
    \ 10000000000000000) (symbol \"x\")]\n      [(< n 10000000000000000) (symbol \"\
    c\")]\n      [(< n 100000000000000000) (symbol \"i\")]\n      [(< n 1000000000000000000)\
    \ (symbol \"x\")]\n      [(< n 1000000000000000000) (symbol \"c\")]\n      [(<\
    \ n 10000000000000000000) (symbol \"i\")]\n      [(< n 100000000000000000000)\
    \ (symbol \"x\")]\n      [(< n 100000000000000000000) (symbol \"c\")]\n      [(<\
    \ n 1000000000000000000000) (symbol \"i\")]\n      [(< n 10000000000000000000000)\
    \ (symbol \"x\")]\n      [(< n 10000000000000000000000) (symbol \"c\")]\n    \
    \  [(< n 1000000000000000000000000) (symbol \"i\")]\n      [(< n 10000000000000000000000000)\
    \ (symbol \"x\")]\n      [(< n 10000000000000000000000000) (symbol \"c\")]\n \
    \     [(< n 100000000000000000000000000) (symbol \"i", "  (let* ([remainder (modulo\
    \ number 100)]\n         [remainder2 (modulo (+ remainder 100) 100)]\n       \
    \  [remainder3 (modulo (+ remainder2 100) 100)]\n         [remainder4 (modulo\
    \ (+ remainder3 100) 100)])\n    (if (>= number 100)\n        (string-append (int_to_mini_roman\
    \ remainder) 'vi)\n        (string-append (int_to_mini_roman remainder2) 'vi)))\n\
    #lang racket\n", "  (if (< number 1000)\n      (let ((numeral (int_to_roman_numeral\
    \ number)))\n        (string-append (char_at (substring numeral 0 1)) (char_at\
    \ (substring numeral 1 1))))\n      \"Error - input out of range\"))", "  (cond\
    \ [(< number 0) \"zero\"]\n        [(< number 1000) (int_to_mini_roman 100 (-\
    \ number 1000))\n         (substring \"MCMXCIV\" 0 (- number 1000) (+ number 1000)\n\
    \                    (+ number 100) (+ number 10) (+ number 1))\n         (substring\
    \ \"MDCLXVI\" 0 (- number 1000) (+ number 1000)\n                    (+ number\
    \ 100) (+ number 10) (+ number 1))\n         (substring \"MNCLXVI\" 0 (- number\
    \ 1000) (+ number 1000)\n                    (+ number 100) (+ number 10) (+ number\
    \ 1))\n         (substring \"MMXCVI\" 0 (- number 1000) (+ number 1000)\n    \
    \                (+ number 100) (+ number 10) (+ number 1))\n         (substring\
    \ \"MCMXVII\" 0 (- number 1000) (+ number 1000)\n                    (+ number\
    \ 100) (+ number 10) (+ number 1))\n         (substring \"MDCVII\" 0 (- number\
    \ 1000) (+ number 1000)\n                    (+ number 100) (+ number 10) (+ number\
    \ 1))\n         (substring \"MNCLXVII\" 0 (- number 1000) (+ number 1000)\n  \
    \                  (+ number 100) (+ number 10) (+ number 1))\n         (substring\
    \ \"MMXVIII\" 0 (- number 1000) (+ number 1000)\n                    (+ number\
    \ 100) (+ number 10) (+ number 1))\n         (substring \"MCMXIX\" 0 (- number\
    \ 1000) (+ number 1000)\n                    (+ number 100) (+ number 10) (+ number\
    \ 1))\n         (substring \"MDCVIII\" 0 (- number 1000) (+ number 1000)\n   \
    \                 (+ number 100) (+ number 10) (+ number 1))\n         (substring\
    \ \"MNCLXIX\" 0 (- number 1000) (+ number 1000)\n                    (+ number\
    \ 100) (+ number 10) (+ number 1))\n         (substring \"MMXVIIX\" 0 (- number\
    \ 1000) (+ number 1000)\n                    (+ number 100) (+ number 10) (+ number\
    \ 1))\n         (substring \"MNCLXXV\" 0 (- number 1000) (+ number 1000)\n   \
    \                 (+ number 100) (+ number 10) (+ number 1))\n         (substring\
    \ \"MMXVIII\" 0 (- number 1000) (+ number 1000)\n                    (+ number\
    \ 100) (+ number 10) (+ number 1))\n         (substring \"MCMXIV\" 0 (- number\
    \ 1000) (+ number 1000)\n                    (+ number ", "  (let loop ([i number]\
    \ [s \"\"])\n    (cond\n      [(or (< i 100) (i= number 0))\n       (cond\n  \
    \       [(= i (string->list \"0\")) (set! s (string->list \"I\"))]\n         [(=\
    \ i (string->list \"1\")) (set! s (string->list \"II\"))]\n         [(= i (string->list\
    \ \"2\")) (set! s (string->list \"III\"))]\n         [(= i (string->list \"3\"\
    )) (set! s (string->list \"IV\"))]\n         [(= i (string->list \"4\")) (set!\
    \ s (string->list \"V\"))]\n         [(= i (string->list \"5\")) (set! s (string->list\
    \ \"VI\"))]\n         [(= i (string->list \"6\")) (set! s (string->list \"VII\"\
    ))]\n         [(= i (string->list \"7\")) (set! s (string->list \"VIII\"))]\n\
    \         [(= i (string->list \"8\")) (set! s (string->list \"IX\"))]\n      \
    \   [(= i (string->list \"9\")) (set! s (string->list \"X\"))]\n         [(= i\
    \ (string->list \"10\")) (set! s (string->list \"XI\"))]\n         [(= i (string->list\
    \ \"11\")) (set! s (string->list \"XII\"))]\n         [(= i (string->list \"12\"\
    )) (set! s (string->list \"XIII\"))]\n         [(= i (string->list \"13\")) (set!\
    \ s (string->list \"XIV\"))]\n         [(= i (string->list \"14\")) (set! s (string->list\
    \ \"XV\"))]\n         [(= i (string->list \"15\")) (set! s (string->list \"XVI\"\
    ))]\n         [(= i (string->list \"16\")) (set! s (string->list \"XVII\"))]\n\
    \         [(= i (string->list \"17\")) (set! s (string->list \"XVIII\"))]\n  \
    \       [(= i (string->list \"18\")) (set! s (string->list \"XIX\"))]\n      \
    \   [(= i (string->list \"19\")) (set! s (string->list \"XX\"))]\n         [(=\
    \ i (string->list \"20\")) (set! s (string->list \"XXI\"))]\n         [(= i (string->list ",
  "  (if (not (= number 0))\n      (cond [(= (% number 1000) 0) (mini_roman number)]\n\
    \            [else (mini_roman (/ number 1000))]))\n  (mini_roman number))\n",
  "  (cond [(<= number 1000)\n         (string-append (substring (list (symbol->string\
    \ 'M) (symbol->string 'D) (symbol->string 'C) (symbol->string 'L) (symbol->string\
    \ 'X) (symbol->string 'V) (symbol->string 'I) (symbol->string 'I))\n         \
    \             (substring (list (symbol->string 'I) (symbol->string 'V) (symbol->string\
    \ 'X) (symbol->string 'L) (symbol->string 'C) (symbol->string 'D) (symbol->string\
    \ 'M))\n                      (substring (list (symbol->string 'I) (symbol->string\
    \ 'V) (symbol->string 'X) (symbol->string 'L) (symbol->string 'C) (symbol->string\
    \ 'D) (symbol->string 'M))\n                      (substring (list (symbol->string\
    \ 'I) (symbol->string 'V) (symbol->string 'X) (symbol->string 'L) (symbol->string\
    \ 'C) (symbol->string 'D) (symbol->string 'M))\n                      (substring\
    \ (list (symbol->string 'I) (symbol->string 'V) (symbol->string 'X) (symbol->string\
    \ 'L) (symbol->string 'C) (symbol->string 'D) (symbol->string 'M))\n         \
    \             (substring (list (symbol->string 'I) (symbol->string 'V) (symbol->string\
    \ 'X) (symbol->string 'L) (symbol->string 'C) (symbol->string 'D) (symbol->string\
    \ 'M))\n                      (substring (list (symbol->string 'I) (symbol->string\
    \ 'V) (symbol->string 'X) (symbol->string 'L) (symbol->string 'C) (symbol->string\
    \ 'D) (symbol->string 'M))\n                      (substring (list (symbol->string\
    \ 'I) (symbol->string 'V) (symbol->string 'X) (symbol->string 'L) (symbol->string\
    \ 'C) (symbol->string 'D) (symbol->string 'M))\n                      (substring\
    \ (list (symbol->string 'I) (symbol->string 'V) (symbol->string 'X) (symbol->string\
    \ 'L) (symbol->string 'C) (symbol->string 'D) (symbol->string 'M))\n         \
    \             (substring (list (symbol->string 'I) (symbol->string 'V) (symbol->string\
    \ 'X) (symbol->string 'L) (symbol->string 'C) (symbol->string 'D) (symbol->string\
    \ 'M))\n                      (substring (list (symbol->string 'I) (symbol->string\
    \ 'V", "  (cond\n    [(< number 1)\n     \"M\"]\n    [(< number 1000)\n     (cons\
    \ \"I\" (int_to_mini_roman 1 (+ number 1)))]\n    [else\n     (let ([numerals\
    \ (make-array 16 :initial-element \"IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII",
  "  (cond [(or (< number 1) (< number 1000)) #f]\n        [(= number 1) 'x]\n   \
    \     [(= number 2) 'c]\n        [(= number 3) 'l]\n        [(= number 4) 'm]\n\
    \        [(= number 5) 'n]\n        [(= number 6) 'xi]\n        [(= number 7)\
    \ 'ci]\n        [(= number 8) 'li]\n        [(= number 9) 'mi]\n        [(= number\
    \ 10) 'ni]\n        [(= number 11) 'xii]\n        [(= number 12) 'cii]\n     \
    \   [(= number 13) 'lii]\n        [(= number 14) 'mii]\n        [(= number 15)\
    \ 'nii]\n        [(= number 16) 'xiii]\n        [(= number 17) 'ciii]\n      \
    \  [(= number 18) 'liii]\n        [(= number 19) 'miii]\n        [(= number 20)\
    \ 'niii]\n        [(= number 21) 'xiiii]\n        [(= number 22) 'ciiii]\n   \
    \     [(= number 23) 'liiii]\n        [(= number 24) 'miiii]\n        [(= number\
    \ 25) 'niiii]\n        [(= number 26) 'xiiiii]\n        [(= number 27) 'ciiiii]\n\
    \        [(= number 28) 'liiiii]\n        [(= number 29) 'miiiii]\n        [(=\
    \ number 30) 'niiiii]\n        [(= number 31) 'xiiiiii]\n        [(= number 32)\
    \ 'ciiiiii]\n        [(= number 33) 'liiiiii]\n        [(= number 34) 'miiiiii]\n\
    \        [(= number 35) 'niiiiii]\n        [(= number 36) 'xiiiiiii]\n       \
    \ [(= number 37) 'ciiiiiii]\n        [(= number 38) 'liiiiiii]\n        [(= number\
    \ 39) 'miiiiiii]\n        [(= number 40) 'niiiiiii]\n        [(= number 41) 'xiiiiiiii]\n\
    \        [(= number 42) 'ciiiiiiii]\n        [(= number 43) 'liiiiiiii]\n    \
    \    [(= number 44) 'miiiiiiii]\n        [(= number 45) ", "  (cond\n    [(> number\
    \ 0) \"M\"]\n    [(> number 1000) \"MM\"]\n    [(> number 2000) \"MMM\"]\n   \
    \ [(> number 3000) \"MMMM\"]\n    [else (int_to_mini_roman number) (list_to_mini_roman\
    \ number)])) ; this one should be in the base case", "  (let ([numeral (reverse\
    \ (string->list \"MCMXCIV\"))])\n    (cond ((= 0 number)\n           (reverse\
    \ (list numeral)))\n          ((< number 1000)\n           (let ([place (divmod\
    \ number 10)])\n             (if (= 0 place)\n                 (reverse (list\
    \ (append numeral (string-append (list place))))\n                       (+ (+\
    \ place 1) (length (string-append numeral)))))\n               (reverse (list\
    \ (append numeral (string-append (list place))))))))))\n", "  (let ((chars \n\
    \         (append (list \"M\" \n                      (loop for i from 2 to 1000\n\
    \                         collect (format #f \"C%d\" i))))\n           (list \"\
    I\" \n                  (loop for i from 2 to 1000\n                     collect\
    \ (format #f \"X%d\" i))))\n        (result \"\"))\n    (cond ((< number 0)\n\
    \           (error \"Invalid input: number must be >= 0\"))\n          ((< number\
    \ 1000)\n           (let ((num-mod \n                  (mod (- number 1000) 10)))\n\
    \             (loop for i from 1 upto num-mod \n                   for char\n\
    \                   in chars\n                   collect (format #f \"M%d\" i)))\n\
    \           (for i from 2 upto number\n             (let ((digit-mod \n      \
    \              (mod i 10)))\n               (loop for char \n                \
    \     in chars\n                   for j of (char-name char) \n              \
    \     collect (format #f \"I%d\" \n                                   (* i 10\
    \ + digit-mod + j))))\n           (for i from 2 upto number\n             (let\
    \ ((digit-mod \n                    (mod i 10)))\n               (loop for char\
    \ \n                     in chars\n                   for j of (char-name char)\
    \ \n                   collect (format #f \"X%d\" \n                         \
    \          (* i 10 + digit-mod + j))))\n           (for i from 2 upto number\n\
    \             (let ((digit-mod \n                    (mod i 10)))\n          \
    \     (loop for char \n                     in chars\n                   for j\
    \ of (char-name char) \n                   collect (format #f \"C%d\" \n     \
    \                              (* i 10 + digit-mod + j))))))\n    (cond ((< result\
    \ \"\")\n           (error \"Invalid input: result must be non empty\"))\n   \
    \       (t (append result (format #f \"~s\" chars))))))\n", "  (if (<= number\
    \ 1000)\n      (cons (mod number 10)\n            (int_to_mini_roman \n      \
    \       (div (+ number 10) 10)))\n      (cons \"x\" (int_to_mini_roman \n    \
    \               (div (+ number 100) 10)))))\n", "  (cond\n    [(> number 0) \"\
    none\"]\n    [(>= number 100) \"none\"]\n    [(>= number 200) (string-append \"\
    c\" (int_to_mini_roman 100))]\n    [else (string-append \"d\" (int_to_mini_roman\
    \ 100))]\n    [else (string-append \"c\" (int_to_mini_roman 100))]\n    [else\
    \ (string-append \"d\" (int_to_mini_roman 100))]\n    [else (string-append \"\
    c\" (int_to_mini_roman 100))]\n    [else (string-append \"d\" (int_to_mini_roman\
    \ 100))]\n    [else (string-append \"c\" (int_to_mini_roman 100))]\n    [else\
    \ (string-append \"d\" (int_to_mini_roman 100))]\n    [else (string-append \"\
    c\" (int_to_mini_roman 100))]\n    [else (string-append \"d\" (int_to_mini_roman\
    \ 100))]\n    [else (string-append \"c\" (int_to_mini_roman 100))]\n    [else\
    \ (string-append \"d\" (int_to_mini_roman 100))]\n    [else (string-append \"\
    c\" (int_to_mini_roman 100))]\n    [else (string-append \"d\" (int_to_mini_roman\
    \ 100))]\n    [else (string-append \"c\" (int_to_mini_roman 100))]\n    [else\
    \ (string-append \"d\" (int_to_mini_roman 100))]\n    [else (string-append \"\
    c\" (int_to_mini_roman 100))]\n    [else (string-append \"d\" (int_to_mini_roman\
    \ 100))]\n    [else (string-append \"c\" (int_to_mini_roman 100))]\n    [else\
    \ (string-append \"d\" (int_to_mini_roman 100))]\n    [else (string-append \"\
    c\" (int_to_mini_roman 100))]\n    [else (string-append \"d\" (int_to_mini_roman\
    \ 100))]\n    [else (string-append \"c\" (int_to_mini_roman 100))]\n    [else\
    \ (string-append \"d\" (int_to_mini_roman 100))]\n    [else (string-append \"\
    c\" (int_to_mini_roman 100))]\n    [else (string-append \"d\" (int_to_mini_roman\
    \ 100))]\n    [else (string-append \"c\" (int_to_mini_roman 100))]\n    [else\
    \ (string-append \"d\" (int_to_mini_roman 100))]\n    [else (string-append \"\
    c\" (int_to_mini", "  (let ([roman (make-string '() #:initial-element 'm)])\n\
    \    (loop for i from 0 below (+ number 1) until (> i 1000)\n      do (if (= (mod\
    \ i 100) 0) (append roman 'cm) (append roman 'm))\n      collect (/ (* i 100)\
    \ (modulo i 100)))\n    (string-append roman 'm)))\n", "  (roman-numeral-to-string\
    \ number))\n", "  (define (iter n sum)\n    (cond [(< n 1000) (cons (string->char\
    \ (mod n 100)) (iter (quotient n 100) sum))]\n          [(< n 1000)\n        \
    \   (cons (string->char (mod n 1000))\n                 (iter (quotient n 1000)\
    \ sum (+ sum (string->char (mod n 1000))))])\n          [(< n 10) (cons (string->char\
    \ (mod n 10))\n                        (iter (quotient n 10) sum (+ sum (string->char\
    \ (mod n 10))))])\n          [else (cons (string->char (mod n 1))\n          \
    \           (iter (quotient n 1) sum (+ sum (string->char (mod n 1))))]))\n  (iter\
    \ number 0))\n", "  (let* ((f (if (<= number 1)\n                (- number\n \
    \                 (floor (/ (- number 1) (+ number 1))))\n                (- number\n\
    \                  (floor (/ (- number 10) (+ number 1))))))\n    (cond\n    \
    \  [(zero? f)\n       (string '())]\n      [(zero? (remainder f 10))\n       (cons\
    \ (substring (string (quotient f 10)) 1 1)\n             (int_to_mini_roman f)))]\n\
    \      [(zero? (remainder f 100))\n       (cons (substring (string (quotient f\
    \ 10)) 1 1)\n             (int_to_mini_roman f))\n       (cons (substring string\
    \ 1 1)\n             (int_to_mini_roman f))]))))\n", "  (cond\n    [(<= 0 number)\
    \ \"\"]\n    [else (cons (cons (int_to_roman number) \"i\") (int_to_mini_roman\
    \ (- number 1)))]))\n", "  (let* ((roman (make-hash-table :test 'equal))\n   \
    \      (num (modulo (modulo-of number 1000)\n                        (floor number\
    \ 1000)))\n         (i (length roman)\n          (quotient number 1000)))\n  \
    \  (set! roman (+ (hash-table-count roman i)\n                 (hash-table-count\
    \ (roman-of num i) i)))\n    (roman-of num i) number)))\n", "  (cond\n    [(<\
    \ number 1) (error \"Not a positive integer.\")]\n    [(< number 999) (error \"\
    Not a positive integer <= 999.\" number)]\n    [else (string-append (roman-numeral\
    \ (quotient number 1000))\n                        (string (string-lower (char-code\
    \ (modulo number 100)))\n                              (int_to_mini_roman \n \
    \                                (quotient (modulo number 1000) 10))))]))\n",
  "  (cond [(zero? number) \"\"]\n        [(< number 1000)\n         (int_to_mini_roman\
    \ (/ number 10) (+ 1 number))]\n        [(= (/ number 100) 10)\n         (int_to_mini_roman\
    \ (/ number 10) 10)]\n        [else\n         (cons (digit->string number)\n \
    \              (int_to_mini_roman (- number 100)\n                           \
    \      (+ number 1)))]))\n", "  (let ((x (floor number)))\n    (cond\n      [(<\
    \ number 0) '']\n      [(< x 100) (string-append 'one 'zero)]\n      [(< x 10)\
    \ (if (< x 10) (string-append 'one 'ten) (string-append '(if (= (modulo x 10)\
    \ 0) (string \"one\") \"ten\")))]\n      [(< x 1000) (let ((n (- x 100)))\n  \
    \                   (cond\n                      [(< n 0) '']\n              \
    \        [(< n 10) (string-append 'one 'ten)]\n                      [(< n 100)\
    \ (if (< n 100) (string-append 'one 'hundred) (if (= (modulo n 100) 0) (string-append\
    \ \"one\" \"hundred\")))]\n                      [(< n 1000) (let ((m (- n 1000)))\n\
    \                                     (cond\n                                \
    \      [(< m 0) '']\n                                      [(< m 10) (string-append\
    \ 'one 'ten)]\n                                      [(< m 100) (if (< m 100)\
    \ (string-append 'one 'hundred) (if (= (modulo m 100) 0) (string-append \"one\"\
    \ \"hundred\")))]\n                                      [(< m 1000) (string-append\
    \ '(int_to_mini_roman m) \"hundred\")]\n                                     \
    \ [(< m 1001) (string-append '(int_to_mini_roman m) \"hundred \"(string-append\
    \ 'one 'thousand))])])]))]))\n", "  (let ((roman-numerals '((i \"i\" ii) (c \"\
    c\" cc) (m \"m\" mm) (a \"a\" aa) (e \"e\" ee)\n                             \
    \  (g \"g\" gg) (t \"t\" tt) (y \"y\" yy)))\n    (cond\n      [(< number 1)\n\
    \       (error \"Can't make sense of negative or zero numbers.\")]\n      [(=\
    \ number 0)\n       (error \"Can't make sense of 0 roman numerals.\")]\n     \
    \ [(< number 1000)\n       (string-append (roman-numerals [(- number 1)])\n  \
    \                   (string-append \"M\")]))]))\n", "  (cond [(<= number 1) 'x]\n\
    \        [(<= number 6) (string-append 'cmr \"vi\")\n         (cond [(<= number\
    \ 7) 'v]\n               [else (string-append 'v \"x\")]\n               )]\n\
    \        [else (string-append (int_to_mini_roman number / 10) (int_to_mini_roman\
    \ number mod 10))]))\n", "  (let loop ((num number)\n             (string \"\"\
    ))\n    (if (< num 1000)\n        (loop (sub1 num) (cons string (string-append\
    \ (sub1 (mod num 100) 100) \"-\" (char 100)))\n               (sub1 num))\n  \
    \      (loop (sub1 num) (append (sub1 (mod num 100) 100) \"-\" (sub1 (mod num\
    \ 100) 10))\n               (sub1 num))))))\n", "  (let ([remainder (mod number\
    \ 1000)])\n    (cond [(= remainder 0)\n           (char->string ((char->int 'M)\
    \ (/ number 1000)))]\n          [else\n           (int_to_mini_roman remainder)]))))\n\
    </code>\nThe above code is O(log n) where n is the number passed in. That's an\
    \ important property of converting numbers to roman numerals. A more efficient\
    \ algorithm is based on the fact that each number is divisible by 100. So you\
    \ could use this function and just loop from 1000 to 1, converting each number\
    \ you come across until you reach 1.\n<code>", "  (cond\n    [(zero? number) 'one]\n\
    \    [(equal? number 1) 'one]\n    [(= (floor (/ number 4)) 0)\n     (cond\n \
    \      [(zero? (remainder number 4))\n        'zero]\n       [(zero? (remainder\
    \ number 9))\n        'one]\n       [(zero? (remainder number 4))\n        'two]\n\
    \       [(zero? (remainder number 3))\n        'three]\n       [(zero? (remainder\
    \ number 9))\n        'four]\n       [(zero? (remainder number 4))\n        'five]\n\
    \       [(zero? (remainder number 9))\n        'six]\n       [(zero? (remainder\
    \ number 4))\n        'seven]\n       [(zero? (remainder number 9))\n        'eight]\n\
    \       [(zero? (remainder number 4))\n        'nine]\n       [(zero? (remainder\
    \ number 9))\n        'ten]\n       [(zero? (remainder number 4))\n        'eleven]\n\
    \       [(zero? (remainder number 9))\n        'twelve]\n       [(zero? (remainder\
    \ number 4))\n        'thirteen]\n       [(zero? (remainder number 9))\n     \
    \   'fourteen]\n       [(zero? (remainder number 4))\n        'fifteen]\n    \
    \   [(zero? (remainder number 9))\n        'sixteen]\n       [(zero? (remainder\
    \ number 4))\n        'seventeen]\n       [(zero? (remainder number 9))\n    \
    \    'eighteen]\n       [(zero? (remainder number 4))\n        'nineteen]\n  \
    \     [(zero? (remainder number 9))\n        'twenty]\n       [else\n        'other])]\n\
    \    [else\n     (cond\n       [(= (floor (/ number 100)) 0)\n        (int_to_mini_roman\
    \ number 1)]\n       [(zero? (remainder number 100))\n        (int_to_mini_roman\
    \ number 101)]\n       [(zero? (remainder number 100))\n        (int_to_mini_roman\
    \ number 102)]\n       [(zero? (remainder number 100))\n        (int_to_mini_roman\
    \ number 103)]\n       [(zero? (remainder number 100))\n        (int_to_mini_roman\
    \ number 104)]\n       [(zero? (remainder number 100))\n        (int_to_mini_roman\
    \ number 105)]\n       [(zero? (remainder number 100))\n        (int_to_mini_roman\
    \ number 106)]\n       [(zero? (remainder number 100))\n        (int_to_mini_roman\
    \ number ", "  (cond\n    ((= number 1) (string 'x))\n    ((= number 5) (string-append\
    \ \"i\" (string 'x)))\n    ((= number 10) (string-append \"c\" (string 'x)))\n\
    \    ((= number 15) (string-append \"d\" (string 'x)))\n    ((= number 20) (string-append\
    \ \"e\" (string 'x)))\n    ((= number 25) (string-append \"f\" (string 'x)))\n\
    \    ((= number 30) (string-append \"g\" (string 'x)))\n    ((= number 35) (string-append\
    \ \"h\" (string 'x)))\n    ((= number 40) (string-append \"i\" (string 'x)))\n\
    \    ((= number 45) (string-append \"j\" (string 'x)))\n    ((= number 50) (string-append\
    \ \"k\" (string 'x)))\n    ((= number 55) (string-append \"l\" (string 'x)))\n\
    \    ((= number 60) (string-append \"m\" (string 'x)))\n    ((= number 65) (string-append\
    \ \"n\" (string 'x)))\n    ((= number 70) (string-append \"o\" (string 'x)))\n\
    \    ((= number 75) (string-append \"p\" (string 'x)))\n    ((= number 80) (string-append\
    \ \"q\" (string 'x)))\n    ((= number 85) (string-append \"r\" (string 'x)))\n\
    \    ((= number 90) (string-append \"s\" (string 'x)))\n    ((= number 95) (string-append\
    \ \"t\" (string 'x)))\n    ((= number 100) (string-append \"u\" (string 'x)))\n\
    \    ((= number 105) (string-append \"v\" (string 'x)))\n    ((= number 110) (string-append\
    \ \"w\" (string 'x)))\n    ((= number 115) (string-append \"x\" (string 'x)))\n\
    \    ((= number 120) (string-append \"y\" (string 'x)))\n    ((= number 125) (string-append\
    \ \"z\" (string 'x)))\n    ((= number 140) (string-append \"a\" (string 'x)))\n\
    \    ((= number 145) (string-append \"b\" (string 'x)))\n    ((= number 150) (string-append\
    \ \"c\" (string 'x)))\n    ((= number 155) (string-append \"d\" (string 'x)))\n\
    \    ((= number 160) (string-append \"e\" (string 'x)))\n    ((= number 165) (string-append\
    \ \"f\" (string 'x)))\n    ((= number 170) (string", "  (cond\n    [(< number\
    \ 1)\n     \"\"]\n    [(< number 1000)\n     (char-ref (roman-numeral number)\
    \ 0)]\n    [else\n     (string-append\n      (int_to_mini_roman \n        (floor\
    \ (/ number 100)))\n      (roman-numeral (floor (/ number 100)) 1)]))) ;; <----\
    \ here\n</cell>\n<text>\nProblem 2: Mini Roman (continued)\nDefine a function\
    \ roman_numeral_to_int that takes the roman numerals given above and\nconverts\
    \ them into integers. Return 0 if the argument is not in the roman numeral \n\
    alphabet.\n\n\n</text>\n<code language=dyalog-kernel>", "  (cond [(or (= number\
    \ 0) (= number 1000)) #\\X]\n        [(= number 1)\n         (cond [(< number\
    \ 10) #\\I]\n               [(= number 10) #\\X]\n               [else (cond [(=\
    \ number 9) #\\M]\n                             [else #\\U])])]\n        [(= number\
    \ 10)\n         (cond [(< number 100) #\\L]\n               [(= number 100) #\\\
    C]\n               [else (cond [(= number 99) #\\D]\n                        \
    \     [else #\\V])])]\n        [(= number 100)\n         (cond [(< number 999)\
    \ #\\L]\n               [(= number 999) #\\C]\n               [else (cond [(=\
    \ number 9) #\\M]\n                             [else #\\U])])]\n        [(= number\
    \ 1000)\n         (cond [(< number 10000) #\\L]\n               [(= number 10000)\
    \ #\\C]\n               [(= number 9900) #\\D]\n               [(= number 9000)\
    \ #\\E]\n               [(= number 8000) #\\F]\n               [(= number 7000)\
    \ #\\G]\n               [(= number 6000) #\\H]\n               [(= number 5000)\
    \ #\\J]\n               [(= number 4000) #\\K]\n               [(= number 3000)\
    \ #\\L]\n               [(= number 2000) #\\M]\n               [(= number 1000)\
    \ #\\N]\n               [(= number 9000) #\\X]\n               [(= number 8000)\
    \ #\\X]\n               [(= number 7000) #\\X]\n               [(= number 6000)\
    \ #\\X]\n               [(= number 5000) #\\X]\n               [(= number 4000)\
    \ #\\X]\n               [(= number 3000) #\\X]\n               [(= number 2000)\
    \ #\\X]\n               [(= number 1000) #\\X]\n               [(= number 8000)\
    \ #\\X]\n               [(= number 7000) #\\X]\n               [(= number 6000)\
    \ #\\X]\n               [(= number 5000) #\\X]\n               [(= number 4000)\
    \ #\\X]\n               [(= number 3000) #\\X]\n               [(= number 2000)\
    \ #\\X]\n               [(= number 1000) #\\X]\n               [(= number 8000)\
    \ #\\X]\n               [(= number 7000) #\\X]\n               [(", "  (define\
    \ (to_roman num)\n    (cond ((< num 1000)\n           (cond ((< num 10)\n    \
    \               (cons (- num '10) 'cli))\n                   (else (cons (- num\
    \ '1000) 'cdx))))\n          ((< num 1000)\n           (cond ((< num 10)\n   \
    \                (cons 'i (cons (- num '10) 'ix)))\n                  ((< num\
    \ 100)\n                   (cons 'v (cons (- num '10 '100) 'v)))\n           \
    \       ((< num 1000)\n                   (cons 'l (cons (- num '100 '1000) 'l)))\n\
    \                  (else (cons 'c (cons (- num '1000 '1000) 'c)))))\n        \
    \  ((< num 1000)\n           (cons 'd (cons (- num '100 '100) 'd)))\n        \
    \  ((< num 1000)\n           (cons 'm (cons (- num '1000 '100) 'm)))\n       \
    \   (else (cons 'm (cons (- num '1000 '1000) 'm)))))\n  (define (roman_num_char\
    \ char)\n    (cond ((< char 100)\n           (cons 'i (cons 'i (cons (- char '10)\
    \ 'ix)))\n           (else (cons (- char '100) 'x)))))\n  (define (roman num)\n\
    \    (cond ((< num 1000)\n           (cond ((< num 10)\n                   (cons\
    \ 'i (cons 'i (cons (- num '10) 'ix)))\n                   (else (cons (- num\
    \ '1000) 'x)))))\n          ((< num 1000)\n           (cons 'v (cons 'v (cons\
    \ (- num '100) 'v)))\n          ((< num 1000)\n           (cons 'l (cons 'l (cons\
    \ (- num '1000) 'l)))\n          ((< num 1000)\n           (cons 'c (cons 'c (cons\
    \ (- num '1000) 'c))))\n          ((< num 1000)\n           (cons 'd (cons 'd\
    \ (cons (- num '100) 'd)))\n          ((< num 1000)\n           (cons 'm (cons\
    \ 'm (cons (- num '1000) 'm)))\n          ((< num 1000)\n           (cons 'c (cons\
    \ 'c (cons (- num '1000) 'c))))\n          (else (cons 'm (cons 'm (cons (- num\
    \ '100) 'm)))))\n  (let* ((result '())\n", "  (cond\n    [(zero? number) \"\"\
    ]\n    [(= number 1) \"x\"]\n    [(< number 1) (int_to_mini_roman number 2)])\n\
    )\n", "  (if (< number 1000)\n      (cond\n        ((= number 0) \"\")\n     \
    \   ((= (- number 1) 0) (substring \"MCMXCIV\" 0 (- number 1)))\n        ((= (-\
    \ number 1) 1) (substring \"MCMX\" 0 (- number 1)))\n        ((= (- number 1)\
    \ 2) (substring \"MMXC\" 0 (- number 1)))\n        ((= (- number 1) 3) (substring\
    \ \"MMMX\" 0 (- number 1)))\n        ((= (- number 1) 4) (substring \"MMMM\" 0\
    \ (- number 1)))\n        ((= (- number 1) 5) (substring \"MMMD\" 0 (- number\
    \ 1)))\n        ((= (- number 1) 6) (substring \"MMCC\" 0 (- number 1)))\n   \
    \     ((= (- number 1) 7) (substring \"MMXC\" 0 (- number 1)))\n        ((= (-\
    \ number 1) 8) (substring \"MCMX\" 0 (- number 1)))\n        ((= (- number 1)\
    \ 9) (substring \"CMXX\" 0 (- number 1)))\n        (else (substring \"DGCXI\"\
    \ 0 (- number 1))))))\n", "  (cond\n    [(< number 1) \"\"]\n    [(< number 1000)\
    \ (int_to_mini_roman 100)]\n    [else (cond\n             [(< number 100) (int_to_mini_roman\
    \ 10)]\n             [(< number 10) (cons \"\" int_to_mini_roman (sub1 number))]\n\
    \             [else (cons \"\" int_to_mini_roman (sub1 number) (int_to_mini_roman\
    \ 10))])]))\n", "  (let loop ([roman '()]\n             [current (quotient number\
    \ 100)]\n             [remainder number])\n    (cond [(= current 1)\n        \
    \   (string-append roman \n                           (list 'x (- remainder 10)))]\n\
    \          [(< current 1000)\n           (loop (string->list roman)\n        \
    \         (add1 current)\n                 (- remainder))]\n          [else\n\
    \           (loop (list->string roman)\n                 (add1 current)\n    \
    \             (- remainder))])))\n", "  (if (or (< number 1)\n          (< number\
    \ 1000))\n      (error 'int_to_mini_roman \"number must be between 1 and 1000\"\
    \n             (number number))\n      (let ([roman \"M\"])\n        (cond [(<\
    \ number 10)\n                (cond\n                 [(= number (mod number 10)\n\
    \                        (mod number 10))]\n                 [(= number (mod number\
    \ 10)\n                        (mod number 10) + 1)\n                 `(~racket/string/append\
    \ roman \"x\")]\n                 [(= number (mod number 10)\n               \
    \         (mod number 10) + 10)\n                 `(~racket/string/append roman\
    \ \"l\")]\n                 [(= number (mod number 10)\n                     \
    \   (mod number 10) + 50)\n                 `(~racket/string/append roman \"c\"\
    )]\n                 [(= number (mod number 10)\n                        (mod\
    \ number 10) + 90)\n                 `(~racket/string/append roman \"d\")]\n \
    \                [(= number (mod number 10)\n                        (mod number\
    \ 10) + 40)\n                 `(~racket/string/append roman \"v\")]\n        \
    \         [(= number (mod number 10)\n                        (mod number 10)\
    \ + 10)\n                 `(~racket/string/append roman \"i\")]\n            \
    \     [(= number (mod number 10)\n                        (mod number 10) + 5)\n\
    \                 `(~racket/string/append roman \"x\")]\n                 [(=\
    \ number (mod number 10)\n                        (mod number 10) + 1)\n     \
    \            `(~racket/string/append roman \"c\")]\n                 [(= number\
    \ (mod number 10)\n                        (mod number 10) + 6)\n            \
    \     `(~racket/string/append roman \"l\")]\n                 [(= number (mod\
    \ number 10)\n                        (mod number 10) + 3)\n                 `(~racket/string/append\
    \ roman \"x\")]\n                 [(= number (mod number 10)\n               \
    \         (mod number 10) + 2)\n                 `(~racket/string/append roman\
    \ \"c\")]\n                 [(= number (mod number 10)\n                     \
    \   (mod number 10) + 4)\n                 `(~racket/string/append roman \"l\"\
    )]\n                 [(= number (mod number 10)\n                        (mod\
    \ number 10) + 0)\n                 `(~racket/string/append roman \"x\")]\n  \
    \               [(= number (mod number 10)\n                        (mod number\
    \ 10) + 1)\n                 `(~racket/string/append roman \"c\")]\n         \
    \        [(= number (mod number 10)\n                        (mod number 10) +\
    \ 7)\n                 `(~racket/string", "  (let ((roman (make-array '(6) '(#\\\
    e #\\i #\\o #\\x #\\s #\\v))))\n    (set! roman (+ (roman (sub1 (logand number\
    \ 1000)))\n                  (sub1 number))\n      (cond\n       ((= number 0)\
    \ \"\")\n       ((= number 1) (char roman (sub1 (array-ref roman 0) 0) #f))\n\
    \       ((= number 2) (char roman (sub1 (array-ref roman 0) 0) #f))\n       ((=\
    \ number 3) (char roman (sub1 (array-ref roman 0) 0) #f))\n       ((= number 4)\
    \ (char roman (sub1 (array-ref roman 0) 0) #f))\n       ((= number 5) (char roman\
    \ (sub1 (array-ref roman 0) 0) #f))\n       ((< number 1000) (char roman (sub1\
    \ (array-ref roman 0) 0) #f))\n       (else (let ((remainder (sub1 number)))\n\
    \                (cond\n                 ((= remainder 0) (char roman (sub1 (array-ref\
    \ roman 0) 0) #f))\n                 ((= remainder 1) (char roman (sub1 (array-ref\
    \ roman 0) 0) #f))\n                 ((= remainder 2) (char roman (sub1 (array-ref\
    \ roman 0) 0) #f))\n                 ((= remainder 3) (char roman (sub1 (array-ref\
    \ roman 0) 0) #f))\n                 ((= remainder 4) (char roman (sub1 (array-ref\
    \ roman 0) 0) #f))\n                 ((= remainder 5) (char roman (sub1 (array-ref\
    \ roman 0) 0) #f))\n                 ((< remainder 1000) (char roman (sub1 (array-ref\
    \ roman 0) 0) #f))\n                 (else (let ((quotient (/ remainder 1000)))\n\
    \                          (cond\n                           ((= quotient 0) (char\
    \ roman (sub1 (array-ref roman 0) 0) #f))\n                           ((= quotient\
    \ 1) (char roman (sub1 (array-ref roman 0) 0) #f))\n                         \
    \  ((= quotient 2) (char roman (sub1 (array-ref roman 0) 0) #f))\n           \
    \                ((= quotient 3) (char roman (sub1 (array-ref roman 0) 0) #f))\n\
    \                           ((= quotient 4) (char roman (sub1 (array-ref roman\
    \ 0) ", "  (cond\n    [(<= number 1) \"i\"]\n    [(<= number 4) \"x\"]\n    [(<=\
    \ number 10) \"l\"]\n    [(<= number 100) \"c\"]\n    [(<= number 500) \"d\"]\n\
    \    [(<= number 1000) \"m\"]\n    [else \"n\"]))\n", "  (let loop ((num number)\n\
    \             (out '()))\n    (cond\n      [(< num 1000)\n       (cons (char->string\
    \ num) out)]\n      [(< num (floor-divide (sqrt num) 10))\n       (loop (floor-divide\
    \ (sqrt num) 10)\n             (append (list (char->string num)) out))]\n    \
    \  [(< num (floor-divide (sqrt num) 100))\n       (loop (floor-divide (sqrt num)\
    \ 100)\n             (append (list (char->string num)) out))\n       (loop (floor-divide\
    \ (sqrt num) 10)\n             (append (list (char->string num)) out))\n     \
    \  (loop (floor-divide (sqrt num) 1)\n             (append (list (char->string\
    \ num)) out))]\n      [(< num (floor-divide (sqrt num) 1000))\n       (loop (floor-divide\
    \ (sqrt num) 1000)\n             (append (list (char->string num)) out))\n   \
    \    (loop (floor-divide (sqrt num) 100)\n             (append (list (char->string\
    \ num)) out))\n       (loop (floor-divide (sqrt num) 10)\n             (append\
    \ (list (char->string num)) out))\n       (loop (floor-divide (sqrt num) 1)\n\
    \             (append (list (char->string num)) out))\n       (loop (floor-divide\
    \ (sqrt num) 10)\n             (append (list (char->string num)) out))\n     \
    \  (loop (floor-divide (sqrt num) 100)\n             (append (list (char->string\
    \ num)) out))\n       (loop (floor-divide (sqrt num) 1000)\n             (append\
    \ (list (char->string num)) out))\n       (loop (floor-divide (sqrt num) 10000)\n\
    \             (append (list (char->string num)) out))\n       (loop (floor-divide\
    \ (sqrt num) 100000)\n             (append (list (char->string num)) out))\n \
    \      (loop (floor-divide (sqrt num) 1000000)\n             (append (list (char->string\
    \ num)) out))\n       (loop (floor-divide (sqrt num) 10000000)\n             (append\
    \ (list (char->string num)) out))\n       (loop (floor-divide (sqrt num) 100000000)\n\
    \             (append (list (char->string num)) out))\n       (loop (floor-divide\
    \ (sqrt num) 1000000000)\n             (append (list (char->string num)) out))\n",
  "  (cond\n    [(< number 1) \"\"]\n    [(<= number 1000) (string-append (int_to_mini_roman\
    \ number / 10) \"\")\n                 (string-to-lower-case (int_to_mini_roman\
    \ number / 10))]\n    [else (int_to_mini_roman number / 10)\n          (string-append\
    \ (string-to-lower-case (int_to_mini_roman number / 10))\n                   \
    \     (int_to_mini_roman number % 10))]))\n</cell>\n<cell>\n#lang racket", " \
    \ (cond\n    [(< number 0) \"zero\"]\n    [(< number 1000) (append (substring\
    \ '(i x vi x x i) number) 'i)]\n    [else (int_to_mini_roman number-1)]))\n",
  "  (cond [(<= number 1)\n         '1]\n        [else\n         (let ([remainder\n\
    \                    (mod number 100)\n                    (roman (cons \"M\"\
    \ (int_to_mini_roman remainder)))\n                    (numeral (cons \"D\" (int_to_mini_roman\
    \ remainder)))\n                    (numeral (cons \"C\" (int_to_mini_roman remainder)))\n\
    \                    (numeral (cons \"L\" (int_to_mini_roman remainder)))\n  \
    \                  (numeral (cons \"X\" (int_to_mini_roman remainder)))\n    \
    \                (numeral (cons \"V\" (int_to_mini_roman remainder)))\n      \
    \              (numeral (cons \"I\" (int_to_mini_roman remainder)))])\n      \
    \     (cond [(= remainder 10)\n                 (string-append (roman) (numeral))\n\
    \                 (string-append numeral (roman))\n                 (string-append\
    \ roman (numeral))\n                 (string-append numeral (roman))]\n      \
    \             [else\n                   (string-append roman (numeral)\n     \
    \                           (roman (cons \"M\" (int_to_mini_roman remainder))))]\n\
    \                   (string-append numeral (roman (cons \"M\" (int_to_mini_roman\
    \ remainder))))]\n                   (string-append numeral (roman (cons \"M\"\
    \ (int_to_mini_roman remainder))))]\n                   (string-append numeral\
    \ (roman (cons \"M\" (int_to_mini_roman remainder))))]\n                   (string-append\
    \ numeral (roman (cons \"M\" (int_to_mini_roman remainder))))]\n             \
    \      (string-append numeral (roman (cons \"M\" (int_to_mini_roman remainder))))]\n\
    \                   (string-append numeral (roman (cons \"M\" (int_to_mini_roman\
    \ remainder))))]\n                   (string-append numeral (roman (cons \"M\"\
    \ (int_to_mini_roman remainder))))]\n                   (string-append numeral\
    \ (roman (cons \"M\" (int_to_mini_roman remainder))))]\n                   (string-append\
    \ numeral (roman (cons \"M\" (int_to_mini_roman remainder))))]\n             \
    \      (string-append numeral (roman (cons \"M\" (int_to_mini_roman remainder))))]\n\
    \                   (string-append numeral (roman (cons \"M\" (int_to_mini_roman\
    \ remainder))))]\n", "  (define (roman_numeral n base acc)\n    (if (= n 0)\n\
    \        acc\n        (roman_numeral (- n base)\n                      base\n\
    \                      (cons (+ (- n base)\n                              (list->string\
    \ acc))\n                            acc))))\n  (roman_numeral number 1 '()))\n",
  "  (let loop ((number number) (cs '()) (i '()))\n    (cond\n      ((< number 0)\n\
    \       (reverse cs))\n      ((< i 9) (loop (- number 1) (cs (string->list \"\
    a\")) i))\n      ((< i 10)\n       (loop (- number 10) (cs (string->list \"x\"\
    )) (+ i 1)))\n      ((< i 13)\n       (loop (- number 100) (append cs (string->list\
    \ \"i\"))\n             (+ i 1)))\n      ((< i 16)\n       (loop (- number 1000)\
    \ (append cs (string->list \"ii\"))\n             (+ i 1)))\n      (else\n   \
    \    (loop (- number 1000000) (append cs (string->list \"vi\")) (+ i 1)))))\n\
    </code>\n<|/ a |>\n<| a tags=algorithm,racket,scheme dscore=1 |>\nHere is my solution.\n\
    <code>\n#lang racket\n", "  (define roman\n    (map (lambda (i)\n           (string->symbol\
    \ (string->string i)))\n         [ (if (= (modulo number 1000) 0) 'I (string->symbol\
    \ 'II))\n           (if (= (modulo number 100) 0) 'III (string->symbol 'IV))\n\
    \           (if (= (modulo number 10) 0) 'V (string->symbol 'V))\n           (if\
    \ (= (modulo number 1) 0) 'X (string->symbol 'X))]))\n  (lambda ()\n    (cond\
    \ [(< number 1)\n           (symbol->string roman (- number 1))]\n          [(<\
    \ number 10)\n           (symbol->string roman 0)]\n          [else\n        \
    \   (symbol->string roman number)]))))\n", "  (let loop ((number-as-string '())\
    \ (accum '()))\n    (cond ((= number 0) (append accum (string->list number-as-string)))\n\
    \          ((< number 1000) (loop (number->string number) accum (number->string\
    \ ((quotient number 1000))))\n          (else (loop (number->string number) (string->list\
    \ number-as-string) (number->string ((quotient number 1000))))))\n    (reverse\
    \ accum)))\n", "  (cond\n    [(<= number 1) \"i\"]\n    [(<= number 5) \"ivi\"\
    ]\n    [(<= number 10) \"l\"]\n    [(<= number 50) \"xvi\"]\n    [else (int_to_mini_roman\
    \ number\n                    (quotient number 5))\n      (cons digit \"ivi\"\
    )]))\n", "  (cond\n    [(<= 0 number 1000) '']\n    [(number%10 eq 0) (list 'm\
    \ number)]\n    [else\n     (let [remainder (modulo number 10)\n           next]\
    \ (append (int_to_mini_roman remainder) (list next))]))\n", "  (cond\n    [(or\
    \ (< number 1) (< number 1000)) #f]\n    [else (mini_roman number)]))\n", "  (define\
    \ (helper number result remainder)\n    (if (= remainder 0)\n        result\n\
    \        (helper (quotient number 10) (string-append result (list-ref (list->string\
    \ (remainder - 10)) 0)) (remainder - 10))))\n  (if (= number 0)\n      \"0\"\n\
    \      (helper (quotient number 10) \"i\" (quotient number 10))))\n", "  (let\
    \ loop ([num number] [rest '()])\n    (if (< num 1000)\n        (cons (roman-numeral\
    \ (quotient num 100)) rest)\n        (loop (quotient num 100) rest)))))\n", " \
    \ (cond [(< number 1)\n         '1]\n        [(<= number 999)\n         (string->list\
    \ '(xi xi xi x))]\n        [else\n         (string->list '(x c l d))]))", "  (cond\
    \ [(< number 1)\n         \"1\"]\n        [(< number 5)\n         \"i\"]\n   \
    \     [(< number 10)\n         (cond\n            [[(> number 9) (> number 8)\
    \ (< number 10) (< number 1)]\n             \"x\"]\n            [(< number 9)\
    \ (< number 8) (< number 10) (< number 1)]\n            [(< number 9) (< number\
    \ 8) (< number 10) (< number 1)]\n            [(< number 9) (< number 8) (< number\
    \ 10) (< number 1)]\n            [(< number 9) (< number 8) (< number 10) (< number\
    \ 1)]\n            [(< number 9) (< number 8) (< number 10) (< number 1)]\n  \
    \          [(< number 9) (< number 8) (< number 10) (< number 1)]\n          \
    \  [(< number 9) (< number 8) (< number 10) (< number 1)]\n            [(< number\
    \ 9) (< number 8) (< number 10) (< number 1)]\n            [(< number 9) (< number\
    \ 8) (< number 10) (< number 1)]\n            [(< number 9) (< number 8) (< number\
    \ 10) (< number 1)]\n            [(< number 9) (< number 8) (< number 10) (< number\
    \ 1)]\n            [(< number 9) (< number 8) (< number 10) (< number 1)]\n  \
    \          [(< number 9) (< number 8) (< number 10) (< number 1)]\n          \
    \  [(< number 9) (< number 8) (< number 10) (< number 1)]\n            [(< number\
    \ 9) (< number 8) (< number 10) (< number 1)]\n            [(< number 9) (< number\
    \ 8) (< number 10) (< number 1)]\n            [(< number 9) (< number 8) (< number\
    \ 10) (< number 1)]\n            [(< number 9) (< number 8) (< number 10) (< number\
    \ 1)]\n            [(< number 9) (< number 8) (< number 10) (< number 1)]\n  \
    \          [(< number 9) (< number 8) (< number 10) (< number 1)]\n          \
    \  [(< number 9) (< number 8) (< number 10) (< number 1)]\n            [(< number\
    \ 9) (< number 8) (< number 10) (< number 1)]\n            [(< number 9) (< number\
    \ 8) (< number 10) (< number 1)]\n            [(< number 9) (< number 8) (< number\
    \ 10) (< number 1)]\n            [(< number 9) (< number 8) (< number 10) (< number\
    \ 1)]\n            [(< number 9) (< number ", "  (let ((result '()))\n    (cond\
    \ ((< number 1000)\n           (let ((remainder (modulo (- number 1000) (mod number\
    \ 10)))\n                 (remainder-roman (roman_numerals remainder)))\n    \
    \         (if (null? remainder-roman)\n                 (append result (list-ref\
    \ remainder-roman 0))\n                 (append result (list-ref remainder-roman\
    \ 0) (list_to remainder))))\n          ((>= number 0)\n           (let ((remainder\
    \ (modulo number 10))\n                 (remainder-roman (roman_numerals remainder)))\n\
    \             (if (null? remainder-roman)\n                 (append result (list-ref\
    \ remainder-roman 0))\n                 (append result (list-ref remainder-roman\
    \ 0))\n                 (append result (list-to remainder))))))\n    (append result\
    \ 'x)))\n", "  (let ((a (make-array '(0 5 4 9 5 8 4 7 4 5 6 5 4 5 6 6 6 6 6 6\
    \ 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6\
    \ 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6\
    \ 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6\
    \ 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6\
    \ 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6\
    \ 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6\
    \ 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6\
    \ 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6\
    \ 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6\
    \ 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6\
    \ 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6\
    \ 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6\
    \ 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 ", "  (cond\n    [(<\
    \ number 1) \"\"]\n    [(< number 10) \"\"]\n    [else (roman-numeral-from-ring\
    \ number)])\n)\n", "  (if (< number 1000)\n      (string-append (mini_roman_to_int\
    \ (- number 1000)) \"\")\n      (mini_roman_to_int number)))\n", "  (roman-to-int-string\
    \ roman number))\n", "  (cond\n    [(> number 0) \"z\"]\n    [(> number 1) \"\
    x\"]\n    [(> number 2) \"c\"]\n    [(> number 3) \"m\"]\n    [(> number 4) \"\
    l\"]\n    [(> number 5) \"o\"]\n    [(> number 6) \"s\"]\n    [(> number 7) \"\
    xs\"]\n    [(> number 8) \"csh\"]\n    [(> number 9) \"ch\"]\n    [(> number 10)\
    \ \"mch\"]\n    [(> number 100) \"ld\"]\n    [(> number 101) \"ld\"]\n    [(>\
    \ number 110) \"lde\"]\n    [(> number 111) \"le\"]\n    [(> number 146) \"cd\"\
    ]\n    [(> number 147) \"cd\"]\n    [(> number 148) \"cm\"]\n    [(> number 149)\
    \ \"cm\"]\n    [(> number 150) \"dl\"]\n    [(> number 151) \"dl\"]\n    [(> number\
    \ 152) \"dl\"]\n    [(> number 203) \"mrd\"]\n    [(> number 204) \"mrd\"]\n \
    \   [(> number 205) \"mrd\"]\n    [(> number 206) \"mrd\"]\n    [(> number 207)\
    \ \"mrd\"]\n    [(> number 215) \"v\"]\n    [(> number 216) \"v\"]\n    [(> number\
    \ 217) \"v\"]\n    [(> number 218) \"v\"]\n    [(> number 219) \"v\"]\n    [(>\
    \ number 220) \"v\"]\n    [(> number 221) \"v\"]\n    [(> number 222) \"v\"]\n\
    \    [(> number 224) \"v\"]\n    [(> number 225) \"v\"]\n    [(> number 228) \"\
    v\"]\n    [(> number 229) \"v\"]\n    [(> number 230) \"v\"]\n    [(> number 233)\
    \ \"v\"]\n    [(> number 234) \"v\"]\n    [(> number 235) \"v\"]\n    [(> number\
    \ 237) \"v\"]\n    [(> number 238) \"v\"]\n    [(> number 239) \"v\"]\n    [(>\
    \ number 240) \"v\"]\n    [(> number 241) \"v\"]\n    [(> number 242) \"v\"]\n\
    \    [(> number 247) \"v\"]\n    [(> number 248) \"v\"]\n    [(> number 249) \"\
    v\"]\n    [(> number 250) \"v\"]\n    [(> number 252) \"v\"]\n    [", "  (cond\n\
    \    [(= number 0) \"\"]\n    [(= number 1) \"i\"]\n    [(= number 2) \"vi\"]\n\
    \    [(< number 1000) (int_to_mini_roman 100)(+ number 100) \n      (int_to_mini_roman\
    \ 1000)]))\n", "  (let loop ((num number) (num-string \"\"))\n    (cond [(< num\
    \ 1000)\n           (cons (char->string (roman->int (char->string 'i'))) num-string)\n\
    \           (loop (- num 1000) (cons (char->string (roman->int (char->string 'x')))\
    \ num-string))\n           ]\n          [(> num 1000)\n           (cons (char->string\
    \ (roman->int (char->string 'i'))) (cons (char->string (roman->int (char->string\
    \ 'x'))) num-string))\n           (loop (- num 1000) num-string)]\n          [else\n\
    \           (cons (char->string (roman->int (char->string 'i'))) (cons (char->string\
    \ (roman->int (char->string 'x'))) num-string))])))\n", "  (cond [(< number 1)\
    \ \"\"]\n        [else (cond\n                [(< number 10) \"\"]\n         \
    \       [(< number 100) \"\"]\n                [(< number 400) \"\"]\n       \
    \         [(< number 800) \"\"]\n                [(< number 1600) \"\"]\n    \
    \            [(< number 3200) \"\"]\n                [(< number 6400) \"\"]\n\
    \                [(< number 12800) \"\"]\n                [(< number 25600) \"\
    \"]\n                [else (append (mini_roman-char 'm) (int_to_mini_roman number)])]))\n",
  "  (cond\n    [(zero? number) #f]\n    [(< number 1000) (string-append (string-to-mini-roman\
    \ number) \"i\")]\n    [(< number 5000) (string-append (string-to-mini-roman number)\
    \ \"m\")]\n    [else (int_to_mini_roman #f number)]\n  )\n)\n", "  (if (< number\
    \ 1000) (list (substring '(i ii iii iv vi vii viii) number))\n      (list (substring\
    \ '(c c cc cd de dc dcc) number))\n      (list (substring '(b bb bbb bc bcc) number))\n\
    \      (list (substring '(m m mm mm mm m mmm) number))\n      (list (substring\
    \ '(m m m m m) number))))\n", "  (let ([i number]\n        [roman_numerals '(m\
    \ d c l x o vi ix x i)])\n    (cond [(< i 1000)\n           roman_numerals]\n\
    \          [(< i 10)\n           (set! roman_numerals (cons i roman_numerals))]\n\
    \          [(< i 1000)\n           (set! roman_numerals (append roman_numerals\
    \ (int_to_mini_roman (- i 10))))]\n          [(= i 0)\n           (set! roman_numerals\
    \ '())]\n          [else\n           (set! roman_numerals (append roman_numerals\
    \ (int_to_mini_roman (- i 1)))]))))\n", "  (if (< number 1000)\n      (string-append\
    \ (let ([base (floor (/ number 1000))])\n                       (cond\n      \
    \                  [(= base 1)\n                         (if (= number 0) \"\"\
    \n                             (cons (char-code (char-code #\\0)) (int_to_mini_roman\
    \ number (- base 1)))]\n                        [else\n                      \
    \   (cons (char-code (char-code #\\0)) (int_to_mini_roman number (- base 1))\n\
    \                               (char-code (char-code (char-code #\\0) base 100))])]\n\
    \                        [(= base 10)\n                         (cons (char-code\
    \ (char-code #\\0)) (int_to_mini_roman number (- base 10)))]\n               \
    \         [else (int_to_mini_roman number (- base 10) (- base 10))]\n        \
    \              ))\n      (int_to_mini_roman number (/ number 1000) (/ number 1000))))\n",
  "  (cond [(< number 1)\n         (string \"x\")\n         ]\n        [(< number\
    \ 100)\n         (string \"c\")\n         ]\n        [(< number 400)\n       \
    \  (string \"d\")\n         ]\n        [(< number 500)\n         (string \"e\"\
    )\n         ]\n        [else\n         (string \"i\")\n         ]\n        ))\n",
  "  (define (next-char x)\n    (cond\n      [(< x 90) (- 10 (char->integer x))])\n\
    \    (char->integer x))\n  (define (roman-char x)\n    (cond\n      [(< x 9) 'v]\n\
    \      [(< x 50) 'l]\n      [(< x 100) 'c]\n      [(< x 500) 'd]\n      [(< x\
    \ 1000) 'm]\n      [(< x 5000) 'y]\n      [(< x 10000) 'k]\n      [(< x 50000)\
    \ 'q]\n      [(< x 100000) 'q]\n      [(< x 500000) 'w]\n      [(< x 100000) 'w]\n\
    \      [(< x 5000000) 'f]\n      [(< x 1000000) 'f]\n      [(< x 50000000) 'v]\n\
    \      [(< x 100000000) 'v]\n      [(< x 500000000) 'l]\n      [(< x 1000000000)\
    \ 'l]\n      [(< x 5000000000) 'c]\n      [(< x 10000000000) 'c]\n      [(< x\
    \ 50000000000) 'd]\n      [(< x 100000000000) 'd]\n      [(< x 500000000000) 'm]\n\
    \      [(< x 1000000000000) 'm]\n      [(< x 5000000000000) 'y]\n      [(< x 10000000000000)\
    \ 'y]\n      [(< x 50000000000000) 'k]\n      [(< x 100000000000000) 'k]\n   \
    \   [(< x 500000000000000) 'q]\n      [(< x 1000000000000000) 'q]\n      [(< x\
    \ 5000000000000000) 'w]\n      [(< x 10000000000000000) 'w]\n      [(< x 50000000000000000)\
    \ 'f]\n      [(< x 1000000000000000000) 'f]\n      [(< x 500000000000000000) 'v]\n\
    \      [(< x 10000000000000000000) 'v]\n      [(< x 500000000000000000000) 'l]\n\
    \      [(< x 1000000000000000000000) 'l]\n      [(< x 5000000000000000000000)\
    \ 'c]\n      [(< x 10000000000000000000000) 'c]\n      [(< x 50000000000000000000000)\
    \ 'd]\n      [(< x 100000000000000000000000) 'd]\n      [(< x 500000000000000000000000)\
    \ 'm]\n      [(< x 1000000000000000000000000) '", "  (let* ((i number)\n     \
    \    (m (floor (/ number 1000)))\n         (r (modulo number 1000))\n        \
    \ (f (floor (/ r 100)))\n         (f (modulo f 100))\n         (v (floor (/ f\
    \ 10)))\n         (v (modulo v 10)))\n    (cond\n      [(< i 1000) \"x\"]\n  \
    \    [(< i 500) \"cm\"]\n      [(< i 100) \"d\"]\n      [(< i 50) \"cd\"]\n  \
    \    [(< i 10) \"c\"]\n      [(< i 5) \"xc\"]\n      [else (cond\n           \
    \    [(< m 0) \"m\"]\n               [(< m 100) \"dm\"]\n               [(< m\
    \ 500) \"cm\"]\n               [(< m 1000) \"d\"]\n               [(< m 50) \"\
    cd\"]\n               [(< m 10) \"c\"]\n               [(< m 5) \"xc\"]\n    \
    \           [else \"xx\"])]\n    ; (cond\n    ;   [(< r 0) \"m\"]\n    ;   [(<\
    \ r 100) \"dm\"]\n    ;   [(< r 500) \"cm\"]\n    ;   [(< r 1000) \"d\"]\n   \
    \ ;   [(< r 50) \"cd\"]\n    ;   [(< r 10) \"c\"]\n    ;   [(< r 5) \"xc\"]\n\
    \    ;   [else \"xx\"]\n    ;   [(< v 0) \"c\"]\n    ;   [(< v 10) \"xc\"]\n \
    \   ;   [(< v 100) \"ix\"]\n    ;   [(< v 500) \"iv\"]\n    ;   [(< v 1000) \"\
    v\"]\n    ;   [else (cond\n    ;             [(< f 0) \"i\"]\n    ;          \
    \   [(< f 10) \"ii\"]\n    ;             [(< f 100) \"iii\"]\n    ;          \
    \   [(< f 1000) \"iv\"]\n    ;             [(< f 500) \"v\"]\n    ;          \
    \   [(< f 1000) \"vi\"]\n    ;             [(< f 5000)\n    ;              \"\
    vii\"]\n    ;             [else \"iv\"])]\n    ;   [(< f 0) \"i\"]\n    ;   [(<\
    \ f 10) \"ii\"]\n    ;   [(< f 100) \"iii\"]\n    ;   [(< f 1000) \"iv\"]\n  \
    \  ;   [(< f 500) \"v\"]\n    ", "  (cond [(<= number 1) \"x\"]\n        [(<=\
    \ number 4) \"i\"]\n        [(<= number 9) \"vi\"]\n        [(<= number 27) \"\
    xvi\"]\n        [else (int_to_mini_roman number) (cons (- number 1) \"\")]))\n",
  "  (define (iter n acc)\n    (if (> n 0)\n      (iter (- n 1) (append acc (mini_roman_numeral\
    \ (modulo (* 10 n) (+ 1 n))))\n           '())\n      acc))\n  (iter number '()))\n",
  "  (cond\n    [(zero? number) 'zero]\n    [(> number 1000) 'hundred (int_to_mini_roman\
    \ number 1000)]\n    [else (cond [(< number 100) 'thousand (int_to_mini_roman\
    \ number (/ 100 10))]\n               [(< number 10)   'ten (int_to_mini_roman\
    \ number (/ 10 10))]\n               [(< number 1)    'one (int_to_mini_roman\
    \ number (/ 1 10))]\n               [else            'other (int_to_mini_roman\
    \ number (/ 1 10))]))]))\n", "  (let ([num (sub1 number)])\n    (cond\n      [(=\
    \ num 1) \"x\"]\n      [(< num 1) (str_append \"-\" (int_to_mini_roman num))]\n\
    \      [else (str_append (int_to_mini_roman num) (str_append \"i\"))])))\n", " \
    \ (define (integer-to-roman number)\n    (cond\n      [(= number 0) 'zero]\n \
    \     [(= number 1) 'one]\n      [(= number 2) 'two]\n      [(= number 3) 'three]\n\
    \      [(= number 4) 'four]\n      [(= number 5) 'five]\n      [(= number 6) 'six]\n\
    \      [(= number 7) 'seven]\n      [(= number 8) 'eight]\n      [(= number 9)\
    \ 'nine]\n      [else (cons 'minus 'minus-one)])\n  )\n  (define (roman-to-integer\
    \ roman)\n    (cond\n      [(equal? roman 'zero) 0]\n      [(equal? roman 'one)\
    \ 1]\n      [(equal? roman 'two) 2]\n      [(equal? roman 'three) 3]\n      [(equal?\
    \ roman 'four) 4]\n      [(equal? roman 'five) 5]\n      [(equal? roman 'six)\
    \ 6]\n      [(equal? roman 'seven) 7]\n      [(equal? roman 'eight) 8]\n     \
    \ [(equal? roman 'nine) 9]\n      [(equal? roman 'minus) -10]\n      [(equal?\
    \ roman 'minus-one) -1]\n      (else (error \"Unknown roman numeral ~S.\" roman)))\n\
    \    (if (< number 1000)\n        (let ([numeral (integer-to-roman number)])\n\
    \          (append (roman-to-integer numeral)\n                   (cons (char\
    \ 'letter #f)\n                        roman-to-integer (rest numeral)))))\n \
    \   (error \"Out of bounds int to mini roman number ~D.\" number))\n  (if (< number\
    \ 1000)\n      (let ([numeral (integer-to-roman number)])\n        (append (roman-to-integer\
    \ numeral)\n                (cons (char 'letter #f)\n                      roman-to-integer\
    \ (rest numeral))))))\n", "  (cond\n    [(< number 100) (string-append (int_to_mini_roman_roman\
    \ number number 'i))]\n    [else (string-append (int_to_mini_roman_roman number\
    \ number 'v))]))", "  (if (<= number 1000)\n      (cond\n        ((= number 0)\n\
    \         'zero)\n        ((even? number)\n         (mini_roman number 'one))\n\
    \        (else\n         (mini_roman number 'ten))\n      )\n      (mini_roman\
    \ number 'hundred)))\n", "  (cond\n    [(= number 0) \"\"]\n    [(= number 1)\
    \ \"x\"]\n    [(= (modulo number 1000) 0) \"M\"]\n    [(= (modulo number 1000)\
    \ 1) \"CM\"]\n    [(= (modulo number 1000) 2) \"CD\"]\n    [(= (modulo number\
    \ 1000) 3) \"CCL\"]\n    [(= (modulo number 1000) 4) \"CCCL\"]\n    [(= (modulo\
    \ number 1000) 5) \"CDL\"]\n    [(= (modulo number 1000) 6) \"CL\"]\n    [(= (modulo\
    \ number 1000) 7) \"CLL\"]\n    [(= (modulo number 1000) 8) \"CXL\"]\n    [(=\
    \ (modulo number 1000) 9) \"CXCL\"]\n    [(= (modulo number 1000) 10) \"CXXL\"\
    ]\n    [else (int_to_mini_roman \n             (- number 1)\n             (append\
    \ '(\"I\") (int_to_mini_roman (- number 1)))])]))\n", "  (let ([num (mod number\
    \ 1000)])\n    (cond\n      [(= num 0) \"\"]\n      [(< num 100) (string-append\
    \ \"C\" (int_to_mini_roman 0 (- number num)))]\n      [(< num 400) (string-append\
    \ \"D\" (int_to_mini_roman 0 (- number num)))]\n      [(< num 900) (string-append\
    \ \"M\" (int_to_mini_roman 0 (- number num)))]\n      [(< num 4000) (string-append\
    \ \"M\" (int_to_mini_roman 0 (- number num)))]\n      [(< num 9999) (string-append\
    \ \"M\" (int_to_mini_roman 0 (- number num)))]\n      [(< num 10000) (string-append\
    \ \"CM\" (int_to_mini_roman 0 (- number num)))]\n      [(< num 25000) (string-append\
    \ \"D\" (int_to_mini_roman 0 (- number num)))]\n      [(< num 50000) (string-append\
    \ \"CM\" (int_to_mini_roman 0 (- number num)))]\n      [(< num 100000) (string-append\
    \ \"C\" (int_to_mini_roman 0 (- number num)))]\n      [(< num 250000) (string-append\
    \ \"M\" (int_to_mini_roman 0 (- number num)))]\n      [(< num 500000) (string-append\
    \ \"CM\" (int_to_mini_roman 0 (- number num)))]\n      [(< num 1000000) (string-append\
    \ \"C\" (int_to_mini_roman 0 (- number num)))]\n      [(< num 2500000) (string-append\
    \ \"D\" (int_to_mini_roman 0 (- number num)))]\n      [(< num 500000) (string-append\
    \ \"CM\" (int_to_mini_roman 0 (- number num)))]\n      [(< num 10000000) (string-append\
    \ \"C\" (int_to_mini_roman 0 (- number num)))]\n      [(< num 2500000) (string-append\
    \ \"D\" (int_to_mini_roman 0 (- number num)))]\n      [(< num 500000) (string-append\
    \ \"CM\" (int_to_mini_roman 0 (- number num)))]\n      [(< num 100000000) (string-append\
    \ \"C\" (int_to_mini_roman 0 (- number num)))]\n      [(< num 25000000) (string-append\
    \ \"D\" (int_to_mini_roman 0 (- number num)))]\n      [(< num 5000000", "  (cond\n\
    \    [(= number 0) \"\"]\n    [(< number 1) (int_to_mini_roman number)]\n    [else\
    \ (cons number\n               (map (lambda (n) (cons n \"m\"))\n            \
    \        (expt number 12)\n                    (expt number 6))]))))\n", "  (define\
    \ (int_to_roman x)\n    (if (< x 10)\n        (char (+ 48 x))\n        (char (+\
    \ 80 x))))\n  (define (roman x)\n    (cond\n      [(< x 1000)\n       (char (char-code\
    \ (char-value 'a)))]\n      [(< x 900)\n       (char (char-code (char-value 'v)))]\n\
    \      [(< x 500)\n       (char (char-code (char-value 'x)))]\n      [(< x 400)\n\
    \       (char (char-code (char-value 'l)))]\n      [(< x 100)\n       (char (char-code\
    \ (char-value 'c)))]\n      [(< x 90)\n       (char (char-code (char-value 'd)))]\n\
    \      [(< x 50)\n       (char (char-code (char-value 'm)))]\n      [(< x 40)\n\
    \       (char (char-code (char-value 'n')))]\n      [(< x 10)\n       (char (char-code\
    \ (char-value 'd')))]\n      [else\n       (char (char-code (char-value 'm')))]\n\
    \      [(_ > x)\n       (char (char-code (char-value 'm')))]\n      [else\n  \
    \     (char (char-code (char-value 'd')))]\n      [(_ > x)\n       (char (char-code\
    \ (char-value 'd')))]\n      [else\n       (char (char-code (char-value 'c')))]\n\
    \      [(_ > x)\n       (char (char-code (char-value 'c')))]\n      [else\n  \
    \     (char (char-code (char-value 'x')))]\n      [(_ > x)\n       (char (char-code\
    \ (char-value 'x')))]\n      [else\n       (char (char-code (char-value 'v')))]\n\
    \      [(_ > x)\n       (char (char-code (char-value 'v')))]\n      [else\n  \
    \     (char (char-code (char-value 'l')))]\n      [(_ > x)\n       (char (char-code\
    \ (char-value 'l')))]\n      [else\n       (char (char-code (char-value 'n')))]\n\
    \      [(_ > x)\n       (char (char-code (char-value 'n')))]\n      [else\n  \
    \     (char (char-code (char-value 'a')))]\n      [else\n       (char (char-code\
    \ (char-value 'z')))]\n      [(_ > x)", "  (let loop ((num number) (result '()))\n\
    \    (cond [(< num 1000)\n           (loop (- num 1000)\n                  (cons\
    \ ((num / 1000 mod 10)\n                           ((- num / 1000 mod 100) mod\
    \ 10)\n                           ((- num / 1000 mod 1000) mod 10))\n        \
    \             result))]\n          [else (loop (- num 1000)\n                \
    \      (cons (list\n                             ((char-to-digit (char num 0))\n\
    \                              (char-to-digit (char num 1)))\n               \
    \               (char-to-digit (char num 2)))\n                            result))]\n\
    \          [else (loop (- num 1000)\n                      (cons (list\n     \
    \                        ((char-to-digit (char num 0))\n                     \
    \         (char-to-digit (char num 1))\n                              (char-to-digit\
    \ (char num 2)))\n                            (list\n                        \
    \      (char-to-digit (char num 3))\n                              (char-to-digit\
    \ (char num 4))\n                              (char-to-digit (char num 5)))\n\
    \                            result))]\n          [else (loop (- num 1000)\n \
    \                     (cons (list\n                             ((char-to-digit\
    \ (char num 0))\n                              (char-to-digit (char num 1))\n\
    \                              (char-to-digit (char num 2)))\n               \
    \             (list\n                              (char-to-digit (char num 3))\n\
    \                              (char-to-digit (char num 4))\n                \
    \              (char-to-digit (char num 5))\n                              (char-to-digit\
    \ (char num 6)))\n                            result))]\n          [else (loop\
    \ (- num 1000)\n                      (cons (list\n                          \
    \   ((char-to-digit (char num 0))\n                              (char-to-digit\
    \ (char num 1))\n                              (char-to-digit (char num 2))\n\
    \                              (char-to-digit (char num 3))\n                \
    \              (char-to-digit (char num 4))\n                              (char-to-digit\
    \ (char num 5))\n                              (char-to-digit (char num 6))\n\
    \                              (char-to-digit (char num 7)))\n               \
    \             (list\n                              (char-to-digit (char num 8))\n\
    \                              (char-to-digit (char num 9)))\n               \
    \             result))]\n          [else (loop (- num 1000)\n                \
    \      (cons (list\n                             ((char-to-digit (char num 0))\n\
    \                              (char-to-digit (char num 1))\n                \
    \              (char-to-digit (char num 2))\n                              (char-to-digit\
    \ (char num 3))\n                              (char-to-digit (char num 4))\n\
    \                              (char-to-digit (char num 5))\n                \
    \              (char-to-digit (char num 6))\n                              (char-to-digit\
    \ (char num 7))\n                              (char-to-digit (char num 8))\n\
    \                              (char-to-digit (char num 9))\n                \
    \              (char", "  (cond\n    [(< number 1)\n     (string-append \"1\"\
    \ (int_to_mini_roman 0 (add1 number)))]\n    [else\n     (let*\n         ([remainder\
    \ (modulo number 1000)])\n         ([numerals (list\n                       (cond\
    \ [(zero? remainder)\n                             \"\"]\n                   \
    \          [(even? remainder)\n                              (cons ((char_at \"\
    M\" 0))\n                                     (int_to_mini_roman 1 (add1 remainder)))]\n\
    \                             [(odd? remainder)\n                            \
    \  (cons ((char_at \"D\" 0))\n                                     (int_to_mini_roman\
    \ 10 (add1 remainder)))]\n                             [(even? (add1 remainder))\n\
    \                              (cons ((char_at \"C\" 0))\n                   \
    \                  (int_to_mini_roman 100 (add1 remainder)))]\n              \
    \               [(odd? (add1 remainder))\n                              (cons\
    \ ((char_at \"L\" 0))\n                                     (int_to_mini_roman\
    \ 1000 (add1 remainder)))])])]\n         ([mini-romans (list\n               \
    \          (cond\n                          [(empty? numerals)\n             \
    \              \"\"]\n                          [(char-equal? (char_at (car numerals)\
    \ 0) (car numerals))\n                           (string-append (char_at (car\
    \ numerals) 0)\n                                         (mini-romans (cdr numerals)))]\n\
    \                          [(char-equal? (char_at (car numerals) 1) (car numerals))\n\
    \                           (string-append (char_at (car numerals) 1)\n      \
    \                                   (mini-romans (cdr numerals)))]\n         \
    \                 [(char-equal? (char_at (car numerals) 2) (car numerals))\n \
    \                          (string-append (char_at (car numerals) 2)\n       \
    \                                  (mini-romans (cdr numerals)))]\n          \
    \                [(char-equal? (char_at (car numerals) 3) (car numerals))\n  \
    \                         (string-append (char_at (car numerals) 3)\n        \
    \                                 (mini-romans (cdr numerals)))]\n           \
    \               [(char-equal? (char_at (car numerals) 4) (car numerals))\n   \
    \                        (string-append (char_at (car numerals) 4)\n         \
    \                                (mini-romans (cdr numerals)))]\n            \
    \              [(char-equal? (char_at (car numerals) 5) (c", "  (cond\n    [(<\
    \ number 1) (error \"Number too small.\")]\n    [(< number 1000) (error \"Number\
    \ too large.\")]\n    [else (cond\n            [(< number (div (+ (* 10 number)\
    \ (- 97 1)))) (error \"Number too big.\")]\n            [else (cons ((if (> number\
    \ 10) \"M\" (if (> number 100) \"CM\" (if (> number 400) \"D\" (if (> number 1000)\
    \ \"CD\" (if (> number 4000) \"C\" (if (> number 10000) \"XC\" (if (> number 100000)\
    \ \"L\" (if (> number 1000000) \"X\" (if (> number 100000000) \"XL\" (if (> number\
    \ 10000000000) \"XC\" (if (> number 100000000000) \"C\" (if (> number 1000000000000)\
    \ \"IV\" (if (> number 10000000000000) \"II\" (if (> number 100000000000000) \"\
    III\" (if (> number 1000000000000000) \"IV\" (if (> number 10000000000000000)\
    \ \"V\" (if (> number 10000000000000000) \"VI\" (if (> number 100000000000000000)\
    \ \"VII\" (if (> number 1000000000000000000) \"VIII\" (if (> number 10000000000000000000)\
    \ \"I\" (if (> number 100000000000000000000) \"I\" (if (> number 1000000000000000000000)\
    \ \"I\" (if (> number 10000000000000000000000) \"I\" (if (> number 100000000000000000000000)\
    \ \"I\" (error \"Number too big.\"))))))))))))))))))))))))))]\n  )\n)\n", "  (cond\
    \ [(< number 1) (error \"Number must be positive.\")]\n        [(< number 1000)\
    \ (error \"Number too large.\")]\n        [else (mini_roman_numeral number)])\n\
    \  )\n", "  (define (iter roman number acc)\n    (if (= number 0)\n        roman\n\
    \        (iter (append roman acc) (sub1 number) \"\")))\n  (iter '() number \"\
    \"))\n", "  (if (< number 1000)\n      (int_to_mini_roman (floor number)) (cond\
    \ [(< number 100) (cons \"I\" (int_to_mini_roman (- number (floor number))))]\n\
    \                                                                   [(< number\
    \ 400)\n                                                                    (cons\
    \ \"IV\"\n                                                                   \
    \         (int_to_mini_roman (- number (floor number)) (- 400 (floor number))))]\n\
    \                                                                   [else (cons\
    \ \"III\" (int_to_mini_roman (- number (floor number)) (- 400 (floor number)))\
    \ (int_to_mini_roman (- number (floor number))))])))\n", "  (let ([roman '()])\n\
    \    (if (= number 0)\n        (reverse roman)\n        (let* ([value (- number\
    \ 1)])\n          (cond\n            [(< value 0) (error \"Negative value not\
    \ allowed\")]\n            [(< value 1000) (cons (char (- value 'a)) roman)] \n\
    \            [else (cons (char (- value 'a)) \n                       (int_to_mini_roman\
    \ value)))]\n          )\n        )\n      )\n    )\n  )\n  ", "  (cond [(< number\
    \ 1) (error \"Invalid value\")]\n        [else (let ([digits (map (lambda (n)\n\
    \                                        (if (< n 10)\n                      \
    \                      (+ n '0)\n                                            'x))\n\
    \                              (range 10 (quotient number 10))))\n           \
    \       (append (map (lambda (digit)\n                               (if (even?\
    \ digit)\n                                   \"x\"\n                         \
    \          \"m\"))\n                          digits)\n                    (map\
    \ (lambda (digit)\n                           (if (even? digit)\n            \
    \                   \"i\"\n                               \"v\"))\n          \
    \                digits)\n                  (map (lambda (digit)\n           \
    \                (if (even? digit)\n                               \"x\"\n   \
    \                            \"m\"))\n                          digits)\n    \
    \              (map (lambda (digit)\n                           (if (even? digit)\n\
    \                               \"c\"\n                               \"m\"))\n\
    \                          digits)\n                  (map (lambda (digit)\n \
    \                          (if (even? digit)\n                               \"\
    d\"\n                               \"m\"))\n                          digits)\n\
    \                  (map (lambda (digit)\n                           (if (even?\
    \ digit)\n                               \"c\"\n                             \
    \  \"m\"))\n                          digits)\n                  (map (lambda\
    \ (digit)\n                           (if (even? digit)\n                    \
    \           \"l\")\n                               \"m\"))\n                 \
    \ (map (lambda (digit)\n                           (if (even? digit)\n       \
    \                        \"x\"\n                               \"m\"))\n     \
    \                     digits)\n                  (map (lambda (digit)\n      \
    \                     (if (even? digit)\n                               \"l\"\
    )\n                               \"m\"))\n                  (map (lambda (digit)\n\
    \                           (if (even? digit)\n                              \
    \ \"x\"\n                               \"m\"))\n                          digits)\n\
    \                  (map (lambda (digit)\n                           (if (even?\
    \ digit)\n                               \"c\"\n                             \
    \  \"m\"))\n                          digits)\n                  (map (lambda\
    \ (digit)\n                           (if (even? digit)\n                    \
    \           \"x\"\n                               \"m\"))\n                  \
    \        digits)\n                  (map (lambda (digit)\n                   \
    \        (if (even? digit)\n                               \"l\")\n          \
    \                     \"m\"))\n                  (map (lambda (digit)\n      \
    \                     (if (even? digit)\n                               \"x\"\n\
    \                               \"m\"))\n                          digits)\n \
    \                 (map (lambda (digit)\n                           (if (even?\
    \ digit)\n                               \"l\")\n                            \
    \   \"m\"))\n                  (map (lambda (digit)\n                        \
    \   (if (even? digit)\n                               \"x\"\n                \
    \               \"m\"))\n                          digits)\n                 \
    \ (map (lambda (digit"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
