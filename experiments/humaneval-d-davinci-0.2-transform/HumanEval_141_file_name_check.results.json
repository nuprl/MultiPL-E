{
  "language": "d",
  "name": "HumanEval_141_file_name_check",
  "results": [
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n    int dot_index = file_name.find(\".\");\n    string extension = file_name[dot_index+1..$];\n    string name = file_name[0..dot_index-1];\n    int digits_count = 0;\n    foreach(c; name)\n    {\n        if(c >= '0' && c <= '9')\n            digits_count++;\n    }\n    if(digits_count > 3)\n        return \"No\";\n    if(extension !in valid_extensions)\n        return \"No\";\n    if(name.length == 0)\n        return \"No\";\n    if(name[0] < 'a' || name[0] > 'z')\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpt76l2rgz.d(23): Error: no property `find` for type `string`\n/tmp/tmpt76l2rgz.d(34): Error: incompatible types for `(extension) in (valid_extensions)`: `string` and `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt76l2rgz.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164539
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    // your code here\n    auto dot_pos = file_name.find('.');\n    if (dot_pos == -1) return \"No\";\n    if (dot_pos == 0) return \"No\";\n    if (dot_pos == file_name.length - 1) return \"No\";\n    auto dot_pos_ext = file_name.find('.', dot_pos + 1);\n    if (dot_pos_ext != -1) return \"No\";\n    auto ext = file_name.substr(dot_pos + 1);\n    if (ext != \"txt\" && ext != \"exe\" && ext != \"dll\") return \"No\";\n    auto name = file_name.substr(0, dot_pos);\n    if (name.length == 0) return \"No\";\n    if (name[0] < 'a' || name[0] > 'z') return \"No\";\n    if (name[0] < 'A' || name[0] > 'Z') return \"No\";\n    int count = 0;\n    for (auto c : name)\n    {\n        if (c >= '0' && c <= '9') count++;\n    }\n    if (count > 3) return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpnb6tn4r5.d(36): Error: no identifier for declarator `c`\n/tmp/tmpnb6tn4r5.d(36): Error: expression expected, not `:`\n/tmp/tmpnb6tn4r5.d(36): Error: found `name` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpnb6tn4r5.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164539
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_index = file_name.find('.');\n    if (dot_index == -1)\n        return \"No\";\n    string before_dot = file_name[0..dot_index];\n    string after_dot = file_name[dot_index+1..$];\n    if (before_dot.length == 0 || before_dot.length > 8)\n        return \"No\";\n    if (after_dot.length == 0 || after_dot.length > 3)\n        return \"No\";\n    if (after_dot != \"txt\" && after_dot != \"exe\" && after_dot != \"dll\")\n        return \"No\";\n    int digit_count = 0;\n    foreach (c; before_dot)\n    {\n        if (c >= '0' && c <= '9')\n            digit_count++;\n    }\n    if (digit_count > 3)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp2_b2o2wd.d(22): Error: no property `find` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2_b2o2wd.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164539
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n    string[] file_name_parts = file_name.split(\".\");\n    if (file_name_parts.length != 2)\n        return \"No\";\n    if (file_name_parts[0].length == 0)\n        return \"No\";\n    if (file_name_parts[0].count(\"0-9\") > 3)\n        return \"No\";\n    if (file_name_parts[0][0] < 'a' || file_name_parts[0][0] > 'z')\n        return \"No\";\n    if (file_name_parts[1] !in valid_extensions)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmppxs4ivcp.d(23): Error: no property `split` for type `string`\n/tmp/tmppxs4ivcp.d(28): Error: no property `count` for type `string`\n/tmp/tmppxs4ivcp.d(32): Error: incompatible types for `(file_name_parts[1]) in (valid_extensions)`: `string` and `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppxs4ivcp.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164539
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_count = 0;\n    int digit_count = 0;\n    bool is_valid = true;\n    foreach(char c; file_name)\n    {\n        if(c == '.')\n        {\n            dot_count++;\n        }\n        else if(c >= '0' && c <= '9')\n        {\n            digit_count++;\n        }\n    }\n    if(dot_count != 1 || digit_count > 3)\n    {\n        is_valid = false;\n    }\n    else\n    {\n        string[] file_name_parts = file_name.split(\".\");\n        if(file_name_parts.length != 2)\n        {\n            is_valid = false;\n        }\n        else\n        {\n            if(file_name_parts[0].length == 0 || !(file_name_parts[0][0] >= 'a' && file_name_parts[0][0] <= 'z') && !(file_name_parts[0][0] >= 'A' && file_name_parts[0][0] <= 'Z'))\n            {\n                is_valid = false;\n            }\n            else\n            {\n                if(file_name_parts[1] != \"txt\" && file_name_parts[1] != \"exe\" && file_name_parts[1] != \"dll\")\n                {\n                    is_valid = false;\n                }\n            }\n        }\n    }\n    return is_valid ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmptxzill6f.d(42): Error: no property `split` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmptxzill6f.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164539
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n    string[] file_name_parts = file_name.split(\".\");\n    if (file_name_parts.length != 2)\n        return \"No\";\n    if (file_name_parts[0].length == 0)\n        return \"No\";\n    if (file_name_parts[0].count(\"0-9\") > 3)\n        return \"No\";\n    if (file_name_parts[0][0] < 'a' || file_name_parts[0][0] > 'z')\n        return \"No\";\n    if (valid_extensions.find(file_name_parts[1]) == -1)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpeucb9ob2.d(23): Error: no property `split` for type `string`\n/tmp/tmpeucb9ob2.d(28): Error: no property `count` for type `string`\n/tmp/tmpeucb9ob2.d(32): Error: no property `find` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpeucb9ob2.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164539
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n    auto dot_index = file_name.indexOf('.');\n    if (dot_index == -1)\n        return \"No\";\n    string extension = file_name[dot_index + 1 .. $];\n    if (!valid_extensions.canFind(extension))\n        return \"No\";\n    string name = file_name[0 .. dot_index];\n    if (name.length == 0)\n        return \"No\";\n    if (!isAlpha(name[0]))\n        return \"No\";\n    int digits_count = 0;\n    foreach (c; name)\n    {\n        if (isDigit(c))\n            digits_count++;\n    }\n    if (digits_count > 3)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpqk2kfq7w.d(23): Error: no property `indexOf` for type `string`\n/tmp/tmpqk2kfq7w.d(27): Error: no property `canFind` for type `string[]`\n/tmp/tmpqk2kfq7w.d(32): Error: undefined identifier `isAlpha`\n/tmp/tmpqk2kfq7w.d(37): Error: undefined identifier `isDigit`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqk2kfq7w.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164539
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int count = 0;\n    int dot_pos = 0;\n    int dot_count = 0;\n    string result = \"No\";\n    string extension = \"\";\n    string valid_extensions[] = [\"txt\", \"exe\", \"dll\"];\n    foreach(i, c; file_name)\n    {\n        if(c == '.')\n        {\n            dot_pos = i;\n            dot_count++;\n        }\n        if(c >= '0' && c <= '9')\n        {\n            count++;\n        }\n    }\n    if(count <= 3 && dot_count == 1)\n    {\n        extension = file_name[dot_pos+1..$];\n        if(extension in valid_extensions)\n        {\n            result = \"Yes\";\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpfa8g0y7e.d(27): Deprecation: instead of C-style syntax, use D-style syntax `string[] valid_extensions`\n/tmp/tmpfa8g0y7e.d(32): Error: cannot implicitly convert expression `i` of type `ulong` to `int`\n/tmp/tmpfa8g0y7e.d(43): Error: incompatible types for `(extension) in (valid_extensions)`: `string` and `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfa8g0y7e.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164539
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_index = file_name.find('.');\n    if (dot_index == -1)\n        return \"No\";\n    string before_dot = file_name[0..dot_index];\n    string after_dot = file_name[dot_index+1..$];\n    if (before_dot.length == 0 || !isalpha(before_dot[0]))\n        return \"No\";\n    if (after_dot != \"txt\" && after_dot != \"exe\" && after_dot != \"dll\")\n        return \"No\";\n    int num_digits = 0;\n    foreach (c; before_dot)\n    {\n        if (isdigit(c))\n            num_digits++;\n    }\n    if (num_digits > 3)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpzrg7gs94.d(22): Error: no property `find` for type `string`\n/tmp/tmpzrg7gs94.d(27): Error: undefined identifier `isalpha`\n/tmp/tmpzrg7gs94.d(34): Error: undefined identifier `isdigit`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpzrg7gs94.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164539
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n    string[] file_name_parts = split(file_name, \".\");\n    if (file_name_parts.length != 2)\n        return \"No\";\n    if (file_name_parts[0].length == 0)\n        return \"No\";\n    if (file_name_parts[0].count('0', '9') > 3)\n        return \"No\";\n    if (file_name_parts[0][0] < 'a' || file_name_parts[0][0] > 'z')\n        return \"No\";\n    if (file_name_parts[1] !in valid_extensions)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpqvr6r8ix.d(23): Error: undefined identifier `split`\n/tmp/tmpqvr6r8ix.d(28): Error: no property `count` for type `string`\n/tmp/tmpqvr6r8ix.d(32): Error: incompatible types for `(file_name_parts[1]) in (valid_extensions)`: `string` and `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqvr6r8ix.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164539
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_index = file_name.find('.');\n    string extension = file_name.substr(dot_index + 1);\n    string name = file_name.substr(0, dot_index);\n    int digits = 0;\n    foreach(c; name)\n    {\n        if(c >= '0' && c <= '9')\n            digits++;\n    }\n    if(digits > 3)\n        return \"No\";\n    if(extension != \"txt\" && extension != \"exe\" && extension != \"dll\")\n        return \"No\";\n    if(name.length == 0)\n        return \"No\";\n    if(!(name[0] >= 'a' && name[0] <= 'z') && !(name[0] >= 'A' && name[0] <= 'Z'))\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpot6_vyv4.d(22): Error: no property `find` for type `string`\n/tmp/tmpot6_vyv4.d(23): Error: no property `substr` for type `string`\n/tmp/tmpot6_vyv4.d(24): Error: no property `substr` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpot6_vyv4.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164539
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n    int dot_index = file_name.find('.');\n    string extension = file_name.substr(dot_index + 1);\n    string name = file_name.substr(0, dot_index);\n    int digits_count = 0;\n    foreach(c; name)\n    {\n        if(c >= '0' && c <= '9')\n            digits_count++;\n    }\n    if(digits_count > 3 || dot_index == -1 || name.length == 0 || !(name[0] >= 'a' && name[0] <= 'z' || name[0] >= 'A' && name[0] <= 'Z'))\n        return \"No\";\n    foreach(ext; valid_extensions)\n    {\n        if(ext == extension)\n            return \"Yes\";\n    }\n    return \"No\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmphnq__6me.d(23): Error: no property `find` for type `string`\n/tmp/tmphnq__6me.d(24): Error: no property `substr` for type `string`\n/tmp/tmphnq__6me.d(25): Error: no property `substr` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphnq__6me.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164539
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n    string[] file_name_parts = file_name.split(\".\");\n    if (file_name_parts.length != 2)\n        return \"No\";\n    if (file_name_parts[0].length == 0)\n        return \"No\";\n    if (file_name_parts[0].count('0', '9') > 3)\n        return \"No\";\n    if (file_name_parts[0][0] < 'a' || file_name_parts[0][0] > 'z')\n        return \"No\";\n    if (file_name_parts[1] !in valid_extensions)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpggs2sbnn.d(23): Error: no property `split` for type `string`\n/tmp/tmpggs2sbnn.d(28): Error: no property `count` for type `string`\n/tmp/tmpggs2sbnn.d(32): Error: incompatible types for `(file_name_parts[1]) in (valid_extensions)`: `string` and `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpggs2sbnn.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164539
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n    int dot_pos = file_name.find(\".\");\n    string extension = file_name[dot_pos+1..$];\n    string name = file_name[0..dot_pos-1];\n    int digits_count = 0;\n    foreach(c; name)\n    {\n        if(c >= '0' && c <= '9')\n            digits_count++;\n    }\n    if(digits_count > 3)\n        return \"No\";\n    if(!(name[0] >= 'a' && name[0] <= 'z') && !(name[0] >= 'A' && name[0] <= 'Z'))\n        return \"No\";\n    if(!valid_extensions.canFind(extension))\n        return \"No\";\n    return \"Yes\";\n}\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n    int dot_pos = file_name.find(\".\");\n    string extension = file_name[dot_pos+1..$];\n    string name = file_name[0..dot_pos-1];\n    int\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmplvs30d0q.d(64): Error: no identifier for declarator `int`\n/tmp/tmplvs30d0q.d(64): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmplvs30d0q.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164539
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n    string[] file_name_parts = file_name.split(\".\");\n    if (file_name_parts.length != 2)\n        return \"No\";\n    if (file_name_parts[0].length == 0)\n        return \"No\";\n    if (file_name_parts[0].count(\"0-9\") > 3)\n        return \"No\";\n    if (file_name_parts[0][0] < 'a' || file_name_parts[0][0] > 'z')\n        return \"No\";\n    if (valid_extensions.count(file_name_parts[1]) == 0)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmppz8nd86z.d(23): Error: no property `split` for type `string`\n/tmp/tmppz8nd86z.d(28): Error: no property `count` for type `string`\n/tmp/tmppz8nd86z.d(32): Error: no property `count` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppz8nd86z.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164539
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n    string[] file_name_parts = file_name.split(\".\");\n    if (file_name_parts.length != 2) return \"No\";\n    if (file_name_parts[0].length == 0) return \"No\";\n    if (file_name_parts[0].count(\"0-9\") > 3) return \"No\";\n    if (file_name_parts[0][0] < 'a' || file_name_parts[0][0] > 'z') return \"No\";\n    if (valid_extensions.find(file_name_parts[1]) == -1) return \"No\";\n    return \"Yes\";\n}\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n    string[] file_name_parts = file_name.split(\".\");\n    if (file_name_parts.length != 2) return \"No\";\n    if (file_name_parts[0].length == 0) return \"No\";\n    if (file_name_parts[0].count(\"0-9\") > 3) return \"No\";\n    if (file_name_parts\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpvrtvywy8.d(56): Error: found `unittest` when expecting `)`\n/tmp/tmpvrtvywy8.d(87): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvrtvywy8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164539
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    if(file_name.count('.') != 1)\n        return \"No\";\n    string[] parts = file_name.split('.');\n    if(parts[0].length == 0 || parts[1].length == 0)\n        return \"No\";\n    if(parts[0].count('0','9') > 3)\n        return \"No\";\n    if(!(parts[1] == \"txt\" || parts[1] == \"exe\" || parts[1] == \"dll\"))\n        return \"No\";\n    if(!(parts[0][0] >= 'a' && parts[0][0] <= 'z' || parts[0][0] >= 'A' && parts[0][0] <= 'Z'))\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpq3elvir2.d(22): Error: no property `count` for type `string`\n/tmp/tmpq3elvir2.d(24): Error: no property `split` for type `string`\n/tmp/tmpq3elvir2.d(27): Error: no property `count` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpq3elvir2.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164539
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_index = file_name.find('.');\n    if (dot_index == -1)\n        return \"No\";\n    string before_dot = file_name[0..dot_index];\n    string after_dot = file_name[dot_index+1..$];\n    if (before_dot.length == 0 || before_dot.length > 8)\n        return \"No\";\n    if (after_dot.length == 0 || after_dot.length > 3)\n        return \"No\";\n    if (after_dot != \"txt\" && after_dot != \"exe\" && after_dot != \"dll\")\n        return \"No\";\n    int digit_count = 0;\n    foreach (c; before_dot)\n    {\n        if (c >= '0' && c <= '9')\n            digit_count++;\n    }\n    if (digit_count > 3)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp2_b2o2wd.d(22): Error: no property `find` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2_b2o2wd.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164539
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_pos = file_name.find(\".\");\n    string ext = file_name.substr(dot_pos+1);\n    string name = file_name.substr(0, dot_pos);\n    int digits = 0;\n    foreach(c; name)\n    {\n        if(c >= '0' && c <= '9')\n            digits++;\n    }\n    if(digits > 3)\n        return \"No\";\n    if(ext != \"txt\" && ext != \"exe\" && ext != \"dll\")\n        return \"No\";\n    if(!(name[0] >= 'a' && name[0] <= 'z') && !(name[0] >= 'A' && name[0] <= 'Z'))\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp1oncxfyb.d(22): Error: no property `find` for type `string`\n/tmp/tmp1oncxfyb.d(23): Error: no property `substr` for type `string`\n/tmp/tmp1oncxfyb.d(24): Error: no property `substr` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1oncxfyb.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164539
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_index = file_name.find('.');\n    string file_name_without_extension = file_name.substr(0, dot_index);\n    string file_name_extension = file_name.substr(dot_index + 1);\n    int digits_count = 0;\n    foreach(char c; file_name_without_extension)\n    {\n        if(c >= '0' && c <= '9')\n        {\n            digits_count++;\n        }\n    }\n    if(digits_count > 3)\n    {\n        return \"No\";\n    }\n    if(file_name_without_extension.length == 0)\n    {\n        return \"No\";\n    }\n    if(!(file_name_without_extension[0] >= 'a' && file_name_without_extension[0] <= 'z') &&\n       !(file_name_without_extension[0] >= 'A' && file_name_without_extension[0] <= 'Z'))\n    {\n        return \"No\";\n    }\n    if(file_name_extension != \"txt\" && file_name_extension != \"exe\" && file_name_extension != \"dll\")\n    {\n        return \"No\";\n    }\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpxdt4z8i9.d(22): Error: no property `find` for type `string`\n/tmp/tmpxdt4z8i9.d(23): Error: no property `substr` for type `string`\n/tmp/tmpxdt4z8i9.d(24): Error: no property `substr` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxdt4z8i9.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164539
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n    string[] file_name_parts = file_name.split(\".\");\n    if (file_name_parts.length != 2)\n        return \"No\";\n    if (file_name_parts[0].length == 0)\n        return \"No\";\n    if (file_name_parts[0].count(\"0-9\") > 3)\n        return \"No\";\n    if (file_name_parts[0][0] < 'a' || file_name_parts[0][0] > 'z')\n        return \"No\";\n    if (valid_extensions.find(file_name_parts[1]) == -1)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpeucb9ob2.d(23): Error: no property `split` for type `string`\n/tmp/tmpeucb9ob2.d(28): Error: no property `count` for type `string`\n/tmp/tmpeucb9ob2.d(32): Error: no property `find` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpeucb9ob2.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164539
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_index = file_name.find(\".\");\n    string extension = file_name.substr(dot_index + 1);\n    string name = file_name.substr(0, dot_index);\n    int digits = 0;\n    foreach(c; name)\n    {\n        if(c >= '0' && c <= '9')\n            digits++;\n    }\n    if(digits > 3)\n        return \"No\";\n    if(extension != \"txt\" && extension != \"exe\" && extension != \"dll\")\n        return \"No\";\n    if(name.length == 0)\n        return \"No\";\n    if(name[0] < 'a' || name[0] > 'z' && name[0] < 'A' || name[0] > 'Z')\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpr3i_47cw.d(22): Error: no property `find` for type `string`\n/tmp/tmpr3i_47cw.d(23): Error: no property `substr` for type `string`\n/tmp/tmpr3i_47cw.d(24): Error: no property `substr` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpr3i_47cw.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164539
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n    string extension = file_name.split(\".\")[1];\n    string name = file_name.split(\".\")[0];\n    int digits = 0;\n    foreach(c; name)\n    {\n        if(c >= '0' && c <= '9')\n            digits++;\n    }\n    if(digits > 3)\n        return \"No\";\n    if(!(extension in valid_extensions))\n        return \"No\";\n    if(name.length == 0)\n        return \"No\";\n    if(!(name[0] >= 'a' && name[0] <= 'z') && !(name[0] >= 'A' && name[0] <= 'Z'))\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp91dm603p.d(23): Error: no property `split` for type `string`\n/tmp/tmp91dm603p.d(24): Error: no property `split` for type `string`\n/tmp/tmp91dm603p.d(33): Error: incompatible types for `(extension) in (valid_extensions)`: `string` and `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp91dm603p.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164539
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_index = file_name.find('.');\n    if (dot_index == -1) return \"No\";\n    string before_dot = file_name[0..dot_index];\n    string after_dot = file_name[dot_index+1..$];\n    if (before_dot.length == 0) return \"No\";\n    if (before_dot[0] < 'a' || before_dot[0] > 'z') return \"No\";\n    if (after_dot != \"txt\" && after_dot != \"exe\" && after_dot != \"dll\") return \"No\";\n    int num_digits = 0;\n    foreach (c; before_dot)\n    {\n        if (c >= '0' && c <= '9') num_digits++;\n    }\n    if (num_digits > 3) return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpoiss1sh7.d(22): Error: no property `find` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpoiss1sh7.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164539
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_pos = file_name.find('.');\n    string ext = file_name.substr(dot_pos + 1);\n    string name = file_name.substr(0, dot_pos);\n    if (ext != \"txt\" && ext != \"exe\" && ext != \"dll\")\n        return \"No\";\n    if (name.length == 0)\n        return \"No\";\n    if (name[0] < 'a' || name[0] > 'z' && name[0] < 'A' || name[0] > 'Z')\n        return \"No\";\n    int count = 0;\n    foreach (c; name)\n    {\n        if (c >= '0' && c <= '9')\n            count++;\n    }\n    if (count > 3)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp84xolakn.d(22): Error: no property `find` for type `string`\n/tmp/tmp84xolakn.d(23): Error: no property `substr` for type `string`\n/tmp/tmp84xolakn.d(24): Error: no property `substr` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp84xolakn.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164539
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n    string[] file_name_parts = file_name.split(\".\");\n    if (file_name_parts.length != 2)\n        return \"No\";\n    if (file_name_parts[0].length == 0)\n        return \"No\";\n    if (file_name_parts[0].count(\"0-9\") > 3)\n        return \"No\";\n    if (file_name_parts[0][0] < 'a' || file_name_parts[0][0] > 'z')\n        return \"No\";\n    if (valid_extensions.count(file_name_parts[1]) == 0)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmppz8nd86z.d(23): Error: no property `split` for type `string`\n/tmp/tmppz8nd86z.d(28): Error: no property `count` for type `string`\n/tmp/tmppz8nd86z.d(32): Error: no property `count` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppz8nd86z.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164539
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n    int dot_index = file_name.find(\".\");\n    string extension = file_name[dot_index + 1 .. $];\n    string name = file_name[0 .. dot_index - 1];\n    int digits_count = 0;\n    foreach(char c; name)\n    {\n        if(c >= '0' && c <= '9')\n        {\n            digits_count++;\n        }\n    }\n    if(digits_count > 3)\n    {\n        return \"No\";\n    }\n    if(!(name[0] >= 'a' && name[0] <= 'z') && !(name[0] >= 'A' && name[0] <= 'Z'))\n    {\n        return \"No\";\n    }\n    if(!valid_extensions.canFind(extension))\n    {\n        return \"No\";\n    }\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpdtt2u1gj.d(23): Error: no property `find` for type `string`\n/tmp/tmpdtt2u1gj.d(42): Error: no property `canFind` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdtt2u1gj.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164539
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_pos = file_name.find('.');\n    if (dot_pos == -1)\n        return \"No\";\n    string before_dot = file_name[0..dot_pos];\n    string after_dot = file_name[dot_pos+1..$];\n    if (before_dot.length == 0 || before_dot.count('0'..'9') > 3)\n        return \"No\";\n    if (after_dot != \"txt\" && after_dot != \"exe\" && after_dot != \"dll\")\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpjz4cyd2g.d(27): Error: found `..` when expecting `,`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjz4cyd2g.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164539
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n    string[] file_name_parts = file_name.split(\".\");\n    if (file_name_parts.length != 2) return \"No\";\n    if (file_name_parts[0].length == 0) return \"No\";\n    if (file_name_parts[0].count(\"0-9\") > 3) return \"No\";\n    if (file_name_parts[0][0] < 'a' || file_name_parts[0][0] > 'z') return \"No\";\n    if (file_name_parts[0][0] < 'A' || file_name_parts[0][0] > 'Z') return \"No\";\n    if (valid_extensions.find(file_name_parts[1]) == -1) return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpx6ci7xgq.d(23): Error: no property `split` for type `string`\n/tmp/tmpx6ci7xgq.d(26): Error: no property `count` for type `string`\n/tmp/tmpx6ci7xgq.d(29): Error: no property `find` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpx6ci7xgq.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164539
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n    string[] file_name_parts = file_name.split(\".\");\n    if (file_name_parts.length != 2)\n        return \"No\";\n    if (file_name_parts[0].length == 0)\n        return \"No\";\n    if (file_name_parts[0].count('0', '9') > 3)\n        return \"No\";\n    if (file_name_parts[0][0] < 'a' || file_name_parts[0][0] > 'z')\n        return \"No\";\n    if (valid_extensions.find(file_name_parts[1]) == -1)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp79d_1iu1.d(23): Error: no property `split` for type `string`\n/tmp/tmp79d_1iu1.d(28): Error: no property `count` for type `string`\n/tmp/tmp79d_1iu1.d(32): Error: no property `find` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp79d_1iu1.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164539
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_index = file_name.find('.');\n    if (dot_index == -1)\n        return \"No\";\n    string before_dot = file_name[0..dot_index];\n    string after_dot = file_name[dot_index+1..$];\n    if (before_dot.length == 0 || !isalpha(before_dot[0]))\n        return \"No\";\n    if (after_dot != \"txt\" && after_dot != \"exe\" && after_dot != \"dll\")\n        return \"No\";\n    int digit_count = 0;\n    foreach (c; before_dot)\n    {\n        if (isdigit(c))\n            digit_count++;\n    }\n    if (digit_count > 3)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpnk3fjuwr.d(22): Error: no property `find` for type `string`\n/tmp/tmpnk3fjuwr.d(27): Error: undefined identifier `isalpha`\n/tmp/tmpnk3fjuwr.d(34): Error: undefined identifier `isdigit`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpnk3fjuwr.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164539
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n    string[] file_name_parts = file_name.split(\".\");\n    if (file_name_parts.length != 2)\n        return \"No\";\n    if (file_name_parts[0].length == 0)\n        return \"No\";\n    if (file_name_parts[0].length > 3)\n        return \"No\";\n    if (file_name_parts[0].count(\"0-9\") > 3)\n        return \"No\";\n    if (file_name_parts[0][0] < 'a' || file_name_parts[0][0] > 'z')\n        return \"No\";\n    if (file_name_parts[0][0] < 'A' || file_name_parts[0][0] > 'Z')\n        return \"No\";\n    if (valid_extensions.count(file_name_parts[1]) == 0)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpnjzgett_.d(23): Error: no property `split` for type `string`\n/tmp/tmpnjzgett_.d(30): Error: no property `count` for type `string`\n/tmp/tmpnjzgett_.d(36): Error: no property `count` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpnjzgett_.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164539
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int count = 0;\n    int dot_count = 0;\n    int dot_index = 0;\n    int dot_index_end = 0;\n    int dot_index_begin = 0;\n    string file_name_begin;\n    string file_name_end;\n    string[] file_name_end_list = [\"txt\", \"exe\", \"dll\"];\n    foreach(i, c; file_name)\n    {\n        if(c == '.')\n        {\n            dot_count++;\n            dot_index = i;\n        }\n        if(c >= '0' && c <= '9')\n        {\n            count++;\n        }\n    }\n    if(count > 3 || dot_count != 1)\n    {\n        return \"No\";\n    }\n    dot_index_begin = dot_index;\n    dot_index_end = dot_index;\n    while(file_name[dot_index_begin] != '.')\n    {\n        dot_index_begin--;\n    }\n    while(file_name[dot_index_end] != '.')\n    {\n        dot_index_end++;\n    }\n    file_name_begin = file_name[dot_index_begin+1..dot_index];\n    file_name_end = file_name[dot_index+1..dot_index_end];\n    if(file_name_begin.length == 0 || !(file_name_begin[0] >= 'a' && file_name_begin[0] <= 'z') && !(file_name_begin[0] >= 'A' && file_name_begin[0] <= 'Z'))\n    {\n        return \"No\";\n    }\n    if(!file_name_end_list.contains(file_name_end))\n    {\n        return \"No\";\n    }\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp5x2vq_n3.d(35): Error: cannot implicitly convert expression `i` of type `ulong` to `int`\n/tmp/tmp5x2vq_n3.d(62): Error: no property `contains` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5x2vq_n3.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164539
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n    int dot_index = file_name.find(\".\");\n    if (dot_index == -1)\n        return \"No\";\n    string extension = file_name[dot_index+1..$];\n    if (extension.length == 0 || !valid_extensions.canFind(extension))\n        return \"No\";\n    string name = file_name[0..dot_index-1];\n    if (name.length == 0 || !isAlpha(name[0]))\n        return \"No\";\n    int digits_count = 0;\n    foreach (c; name)\n    {\n        if (isDigit(c))\n            digits_count++;\n    }\n    if (digits_count > 3)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpice1bssp.d(23): Error: no property `find` for type `string`\n/tmp/tmpice1bssp.d(27): Error: no property `canFind` for type `string[]`\n/tmp/tmpice1bssp.d(30): Error: undefined identifier `isAlpha`\n/tmp/tmpice1bssp.d(35): Error: undefined identifier `isDigit`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpice1bssp.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164539
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    // Your code here\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n    int dot_index = file_name.indexOf('.');\n    if (dot_index == -1)\n        return \"No\";\n    string extension = file_name[dot_index + 1 .. $];\n    if (extension.length == 0 || valid_extensions.count(extension) == 0)\n        return \"No\";\n    string name = file_name[0 .. dot_index];\n    if (name.length == 0 || !name[0].isLetter)\n        return \"No\";\n    int digit_count = 0;\n    foreach (c; name)\n        if (c.isDigit)\n            digit_count++;\n    if (digit_count > 3)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpuycjoufw.d(24): Error: no property `indexOf` for type `string`\n/tmp/tmpuycjoufw.d(28): Error: no property `count` for type `string[]`\n/tmp/tmpuycjoufw.d(31): Error: no property `isLetter` for type `immutable(char)`\n/tmp/tmpuycjoufw.d(35): Error: no property `isDigit` for type `immutable(char)`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuycjoufw.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164539
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_index = file_name.indexOf('.');\n    if (dot_index == -1)\n        return \"No\";\n    string extension = file_name.substr(dot_index + 1);\n    if (extension != \"txt\" && extension != \"exe\" && extension != \"dll\")\n        return \"No\";\n    string name = file_name.substr(0, dot_index);\n    if (name.length == 0)\n        return \"No\";\n    if (name[0] < 'a' || name[0] > 'z' && name[0] < 'A' || name[0] > 'Z')\n        return \"No\";\n    int count = 0;\n    foreach (c; name)\n    {\n        if (c >= '0' && c <= '9')\n            count++;\n    }\n    if (count > 3)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp6_d8kjft.d(22): Error: no property `indexOf` for type `string`\n/tmp/tmp6_d8kjft.d(25): Error: no property `substr` for type `string`\n/tmp/tmp6_d8kjft.d(28): Error: no property `substr` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6_d8kjft.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164539
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    auto dot_pos = file_name.find('.');\n    if (dot_pos == -1)\n        return \"No\";\n    auto ext = file_name.slice(dot_pos + 1);\n    if (ext != \"txt\" && ext != \"exe\" && ext != \"dll\")\n        return \"No\";\n    if (file_name.count('.') != 1)\n        return \"No\";\n    if (file_name.count('0', '9') > 3)\n        return \"No\";\n    if (file_name.count('a', 'z') == 0 && file_name.count('A', 'Z') == 0)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpw86oeomb.d(22): Error: no property `find` for type `string`\n/tmp/tmpw86oeomb.d(25): Error: no property `slice` for type `string`\n/tmp/tmpw86oeomb.d(28): Error: no property `count` for type `string`\n/tmp/tmpw86oeomb.d(30): Error: no property `count` for type `string`\n/tmp/tmpw86oeomb.d(32): Error: no property `count` for type `string`\n/tmp/tmpw86oeomb.d(32): Error: no property `count` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpw86oeomb.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164539
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    import std.algorithm : count;\n    import std.array : array;\n    import std.conv : to;\n    import std.range : take;\n    import std.string : split;\n    import std.typecons : tuple;\n    import std.typecons : Tuple;\n    import std.typecons : tuple;\n    import std.typecons : Tuple;\n    import std.typecons : tuple;\n    import std.typecons : Tuple;\n    import std.typecons : tuple;\n    import std.typecons : Tuple;\n    import std.typecons : tuple;\n    import std.typecons : Tuple;\n    import std.typecons : tuple;\n    import std.typecons : Tuple;\n    import std.typecons : tuple;\n    import std.typecons : Tuple;\n    import std.typecons : tuple;\n    import std.typecons : Tuple;\n    import std.typecons : tuple;\n    import std.typecons : Tuple;\n    import std.typecons : tuple;\n    import std.typecons : Tuple;\n    import std.typecons : tuple;\n    import std.typecons : Tuple;\n    import std.typecons : tuple;\n    import std.typecons : Tuple;\n    import std.typecons : tuple;\n    import std.typecons : Tuple;\n    import std.typecons : tuple;\n    import std.typecons : Tuple;\n    import std.typecons : tuple;\n    import std.typecons : Tuple;\n    import std.typecons : tuple;\n    import std.typecons : Tuple;\n    import std.typecons : tuple;\n    import std.typecons : Tuple;\n    import std.typecons : tuple;\n    import std.typecons : Tuple;\n    import std.typecons : tuple;\n    import std.typecons : Tuple;\n    import std.typecons : tuple;\n    import std.typecons : Tuple;\n    import std.typecons : tuple;\n    import std.typecons : Tuple;\n    import std.typecons : tuple;\n    import std.typecons : Tuple;\n   \nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmplzdvyta_.d(72): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmplzdvyta_.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164539
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n    string[] file_name_parts = file_name.split(\".\");\n    if (file_name_parts.length != 2)\n        return \"No\";\n    if (file_name_parts[0].length == 0)\n        return \"No\";\n    if (file_name_parts[0].count(\"0-9\") > 3)\n        return \"No\";\n    if (file_name_parts[0][0] < 'a' || file_name_parts[0][0] > 'z')\n        return \"No\";\n    if (valid_extensions.find(file_name_parts[1]) == -1)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpeucb9ob2.d(23): Error: no property `split` for type `string`\n/tmp/tmpeucb9ob2.d(28): Error: no property `count` for type `string`\n/tmp/tmpeucb9ob2.d(32): Error: no property `find` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpeucb9ob2.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164539
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    auto dot_pos = file_name.find('.');\n    if (dot_pos == -1)\n        return \"No\";\n    auto dot_pos_end = file_name.find('.', dot_pos + 1);\n    if (dot_pos_end != -1)\n        return \"No\";\n    auto before_dot = file_name[0..dot_pos];\n    auto after_dot = file_name[dot_pos + 1..$];\n    if (before_dot.length == 0 || before_dot.length > 8)\n        return \"No\";\n    if (after_dot != \"txt\" && after_dot != \"exe\" && after_dot != \"dll\")\n        return \"No\";\n    if (before_dot.count!(a => a >= '0' && a <= '9') > 3)\n        return \"No\";\n    if (!(before_dot[0] >= 'a' && before_dot[0] <= 'z' || before_dot[0] >= 'A' && before_dot[0] <= 'Z'))\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpoekglgo6.d(22): Error: no property `find` for type `string`\n/tmp/tmpoekglgo6.d(25): Error: no property `find` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpoekglgo6.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164539
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    // Check if the file name contains more than three digits\n    if (file_name.count!(char)(\"0\" .. \"9\") > 3)\n        return \"No\";\n    // Check if the file name contains exactly one dot\n    if (file_name.count!(char)(\".\") != 1)\n        return \"No\";\n    // Split the file name into two parts\n    auto parts = file_name.split(\".\");\n    // Check if the first part is empty\n    if (parts[0].empty)\n        return \"No\";\n    // Check if the first part starts with a letter\n    if (!parts[0].startsWith!(char)(\"a\" .. \"z\", \"A\" .. \"Z\"))\n        return \"No\";\n    // Check if the second part is one of the allowed extensions\n    if (parts[1] != \"txt\" && parts[1] != \"exe\" && parts[1] != \"dll\")\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp8nr_95wd.d(23): Error: found `..` when expecting `,`\n/tmp/tmp8nr_95wd.d(34): Error: found `..` when expecting `,`\n/tmp/tmp8nr_95wd.d(34): Error: found `..` when expecting `,`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8nr_95wd.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164539
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n    int dot_index = file_name.find(\".\");\n    string extension = file_name[dot_index+1..$];\n    string name = file_name[0..dot_index-1];\n    int digits_count = 0;\n    foreach(char c; name)\n    {\n        if(c >= '0' && c <= '9')\n            digits_count++;\n    }\n    if(digits_count > 3)\n        return \"No\";\n    if(dot_index == -1)\n        return \"No\";\n    if(name.length == 0)\n        return \"No\";\n    if(name[0] < 'a' || name[0] > 'z')\n        return \"No\";\n    if(!valid_extensions.canFind(extension))\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp2s2kgrrw.d(23): Error: no property `find` for type `string`\n/tmp/tmp2s2kgrrw.d(40): Error: no property `canFind` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2s2kgrrw.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164539
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n    string[] file_name_parts = file_name.split(\".\");\n    if (file_name_parts.length != 2)\n        return \"No\";\n    if (file_name_parts[0].length == 0)\n        return \"No\";\n    if (!valid_extensions.contains(file_name_parts[1]))\n        return \"No\";\n    if (file_name_parts[0].count(\"0-9\") > 3)\n        return \"No\";\n    if (file_name_parts[0][0] < 'a' || file_name_parts[0][0] > 'z')\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpeoxx6018.d(23): Error: no property `split` for type `string`\n/tmp/tmpeoxx6018.d(28): Error: no property `contains` for type `string[]`\n/tmp/tmpeoxx6018.d(30): Error: no property `count` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpeoxx6018.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164539
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int count = 0;\n    int dot_count = 0;\n    int dot_index = 0;\n    bool valid = true;\n    foreach(i, c; file_name)\n    {\n        if(c >= '0' && c <= '9')\n        {\n            count++;\n        }\n        if(c == '.')\n        {\n            dot_count++;\n            dot_index = i;\n        }\n    }\n    if(count > 3)\n    {\n        valid = false;\n    }\n    if(dot_count != 1)\n    {\n        valid = false;\n    }\n    if(dot_index == 0)\n    {\n        valid = false;\n    }\n    if(file_name[0] < 'a' || file_name[0] > 'z')\n    {\n        valid = false;\n    }\n    if(file_name[dot_index + 1 .. $] != \"txt\" && file_name[dot_index + 1 .. $] != \"exe\" && file_name[dot_index + 1 .. $] != \"dll\")\n    {\n        valid = false;\n    }\n    if(valid)\n    {\n        return \"Yes\";\n    }\n    else\n    {\n        return \"No\";\n    }\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpi23vw6j8.d(35): Error: cannot implicitly convert expression `i` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpi23vw6j8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164539
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int count = 0;\n    int dot_count = 0;\n    int dot_index = 0;\n    int i = 0;\n    int j = 0;\n    string ext = \"\";\n    string name = \"\";\n    bool valid = true;\n    bool valid_ext = false;\n    bool valid_name = false;\n    bool valid_count = false;\n    string[] valid_exts = [\"txt\", \"exe\", \"dll\"];\n    foreach(char c; file_name)\n    {\n        if(c == '.')\n        {\n            dot_count++;\n            dot_index = i;\n        }\n        if(c >= '0' && c <= '9')\n        {\n            count++;\n        }\n        i++;\n    }\n    if(dot_count == 1 && count <= 3)\n    {\n        valid_count = true;\n    }\n    if(file_name[0] >= 'a' && file_name[0] <= 'z' || file_name[0] >= 'A' && file_name[0] <= 'Z')\n    {\n        valid_name = true;\n    }\n    foreach(string s; valid_exts)\n    {\n        if(s == file_name[dot_index+1..$])\n        {\n            valid_ext = true;\n        }\n    }\n    if(valid_count && valid_name && valid_ext)\n    {\n        valid = true;\n    }\n    else\n    {\n        valid = false;\n    }\n    if(valid)\n    {\n        return \"Yes\";\n    }\n    else\n    {\n        return \"No\";\n    }\n}\n/*\nCreate a function which takes a string representing a file's name, and returns\n    the file's extension.\n    A file's extension is the substring after the last dot '.' in the file's name.\n    Examples:\n    >>> file_extension(\"example.txt\")\n    \"txt\"\n    >>> file_extension(\"example.exe\")\n    \"exe\"\n*/\nstring file_extension(string file_name) \n{\n    int dot_index = 0\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmprtcho7um.d(92): Error: semicolon expected, not `unittest`\n/tmp/tmprtcho7um.d(92): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprtcho7um.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164539
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_index = file_name.find('.');\n    string extension = file_name.substr(dot_index+1);\n    string name = file_name.substr(0, dot_index);\n    int digits = 0;\n    for (int i = 0; i < name.length; i++)\n    {\n        if (name[i] >= '0' && name[i] <= '9')\n            digits++;\n    }\n    if (digits > 3)\n        return \"No\";\n    if (extension != \"txt\" && extension != \"exe\" && extension != \"dll\")\n        return \"No\";\n    if (name.length == 0)\n        return \"No\";\n    if (name[0] < 'a' || name[0] > 'z' && name[0] < 'A' || name[0] > 'Z')\n        return \"No\";\n    return \"Yes\";\n}\n/*\n    Create a function which takes a string representing a file's name, and returns\n    the file's extension.\n    A file's extension is the substring after the last dot '.' in the file's name.\n    If the file's name doesn't contain a dot, the function should return an empty string.\n    Examples:\n    >>> file_extension(\"example.txt\")\n    \"txt\"\n    >>> file_extension(\"example\")\n    \"\"\n*/\nstring file_extension(string file_name) \n{\n    int dot_index = file_name.rfind('.');\n    if (dot_index == -1)\n        return \"\";\n    return file_name.substr(dot_index+1);\n}\n/*\n    Create a function which takes a string representing a file's name, and returns\n    the file's name without the extension.\n    A file's extension is the substring after the last dot '.' in the file's name.\n    If the file's name doesn't contain a dot, the function should return the same string.\n    Examples:\n    >>> file_name_without_extension(\"example.txt\")\n    \"example\"\n    >>> file_name_without_extension(\"example\")\n    \"example\"\n*/\nstring file_\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp1bvhv7hz.d(71): Error: semicolon expected, not `unittest`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1bvhv7hz.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164539
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n    string[] file_name_split = file_name.split(\".\");\n    if (file_name_split.length != 2)\n        return \"No\";\n    if (file_name_split[0].length == 0)\n        return \"No\";\n    if (file_name_split[0].count(\"0\", \"9\") > 3)\n        return \"No\";\n    if (file_name_split[0][0] < 'a' || file_name_split[0][0] > 'z')\n        return \"No\";\n    if (valid_extensions.find(file_name_split[1]) == -1)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpu4f9fh9g.d(23): Error: no property `split` for type `string`\n/tmp/tmpu4f9fh9g.d(28): Error: no property `count` for type `string`\n/tmp/tmpu4f9fh9g.d(32): Error: no property `find` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpu4f9fh9g.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164539
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n    string[] file_name_parts = file_name.split(\".\");\n    if (file_name_parts.length != 2)\n        return \"No\";\n    if (file_name_parts[0].length == 0)\n        return \"No\";\n    if (file_name_parts[0].count(\"0-9\") > 3)\n        return \"No\";\n    if (file_name_parts[0][0] < 'a' || file_name_parts[0][0] > 'z')\n        return \"No\";\n    if (valid_extensions.find(file_name_parts[1]) == -1)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpeucb9ob2.d(23): Error: no property `split` for type `string`\n/tmp/tmpeucb9ob2.d(28): Error: no property `count` for type `string`\n/tmp/tmpeucb9ob2.d(32): Error: no property `find` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpeucb9ob2.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164539
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n    string[] file_name_parts = split(file_name, \".\");\n    if (file_name_parts.length != 2)\n        return \"No\";\n    if (file_name_parts[0].length == 0)\n        return \"No\";\n    if (file_name_parts[0].length == 1 && !isalpha(file_name_parts[0][0]))\n        return \"No\";\n    if (file_name_parts[0].length > 1 && !isalpha(file_name_parts[0][0]))\n        return \"No\";\n    if (file_name_parts[0].length > 1 && !isdigit(file_name_parts[0][1]))\n        return \"No\";\n    if (file_name_parts[0].length > 2 && !isdigit(file_name_parts[0][2]))\n        return \"No\";\n    if (file_name_parts[0].length > 3 && !isdigit(file_name_parts[0][3]))\n        return \"No\";\n    if (file_name_parts[0].length > 4)\n        return \"No\";\n    if (file_name_parts[1] != valid_extensions[0] && file_name_parts[1] != valid_extensions[1] && file_name_parts[1] != valid_extensions[2])\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpcx95hpwo.d(23): Error: undefined identifier `split`\n/tmp/tmpcx95hpwo.d(28): Error: undefined identifier `isalpha`\n/tmp/tmpcx95hpwo.d(30): Error: undefined identifier `isalpha`\n/tmp/tmpcx95hpwo.d(32): Error: undefined identifier `isdigit`\n/tmp/tmpcx95hpwo.d(34): Error: undefined identifier `isdigit`\n/tmp/tmpcx95hpwo.d(36): Error: undefined identifier `isdigit`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcx95hpwo.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164539
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n    int dot_index = file_name.find(\".\");\n    if (dot_index == -1)\n        return \"No\";\n    string extension = file_name[dot_index+1..$];\n    if (!valid_extensions.canFind(extension))\n        return \"No\";\n    string name = file_name[0..dot_index-1];\n    if (name.length == 0)\n        return \"No\";\n    if (!isAlpha(name[0]))\n        return \"No\";\n    int digits_count = 0;\n    foreach (c; name)\n    {\n        if (isDigit(c))\n            digits_count++;\n    }\n    if (digits_count > 3)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpav7h9_1u.d(23): Error: no property `find` for type `string`\n/tmp/tmpav7h9_1u.d(27): Error: no property `canFind` for type `string[]`\n/tmp/tmpav7h9_1u.d(32): Error: undefined identifier `isAlpha`\n/tmp/tmpav7h9_1u.d(37): Error: undefined identifier `isDigit`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpav7h9_1u.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164539
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int count = 0;\n    int dot_count = 0;\n    int i = 0;\n    int j = 0;\n    string sub_str;\n    string sub_str2;\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n    foreach(char c; file_name)\n    {\n        if(c >= '0' && c <= '9')\n        {\n            count++;\n        }\n        if(c == '.')\n        {\n            dot_count++;\n        }\n    }\n    if(count > 3 || dot_count != 1)\n    {\n        return \"No\";\n    }\n    while(file_name[i] != '.')\n    {\n        i++;\n    }\n    sub_str = file_name[0..i];\n    if(sub_str.length == 0 || (sub_str[0] < 'a' || sub_str[0] > 'z') && (sub_str[0] < 'A' || sub_str[0] > 'Z'))\n    {\n        return \"No\";\n    }\n    sub_str2 = file_name[i+1..$];\n    foreach(string s; valid_extensions)\n    {\n        if(s == sub_str2)\n        {\n            return \"Yes\";\n        }\n    }\n    return \"No\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164540
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n    string[] file_name_parts = file_name.split(\".\");\n    if (file_name_parts.length != 2)\n        return \"No\";\n    string file_name_part = file_name_parts[0];\n    string extension = file_name_parts[1];\n    if (file_name_part.length == 0)\n        return \"No\";\n    if (file_name_part.count(\"0\") + file_name_part.count(\"1\") + file_name_part.count(\"2\") + file_name_part.count(\"3\") + file_name_part.count(\"4\") + file_name_part.count(\"5\") + file_name_part.count(\"6\") + file_name_part.count(\"7\") + file_name_part.count(\"8\") + file_name_part.count(\"9\") > 3)\n        return \"No\";\n    if (!(file_name_part[0] >= 'a' && file_name_part[0] <= 'z' || file_name_part[0] >= 'A' && file_name_part[0] <= 'Z'))\n        return \"No\";\n    if (!valid_extensions.contains(extension))\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpzuy937lg.d(23): Error: no property `split` for type `string`\n/tmp/tmpzuy937lg.d(30): Error: no property `count` for type `string`\n/tmp/tmpzuy937lg.d(30): Error: no property `count` for type `string`\n/tmp/tmpzuy937lg.d(30): Error: no property `count` for type `string`\n/tmp/tmpzuy937lg.d(30): Error: no property `count` for type `string`\n/tmp/tmpzuy937lg.d(30): Error: no property `count` for type `string`\n/tmp/tmpzuy937lg.d(30): Error: no property `count` for type `string`\n/tmp/tmpzuy937lg.d(30): Error: no property `count` for type `string`\n/tmp/tmpzuy937lg.d(30): Error: no property `count` for type `string`\n/tmp/tmpzuy937lg.d(30): Error: no property `count` for type `string`\n/tmp/tmpzuy937lg.d(30): Error: no property `count` for type `string`\n/tmp/tmpzuy937lg.d(34): Error: no property `contains` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpzuy937lg.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164539
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int count = 0;\n    int dot_count = 0;\n    int i = 0;\n    int j = 0;\n    string temp = \"\";\n    string temp2 = \"\";\n    string result = \"\";\n    while(i < file_name.length)\n    {\n        if(file_name[i] == '.')\n        {\n            dot_count++;\n            j = i + 1;\n        }\n        if(file_name[i] >= '0' && file_name[i] <= '9')\n        {\n            count++;\n        }\n        i++;\n    }\n    if(count > 3 || dot_count != 1)\n    {\n        result = \"No\";\n    }\n    else\n    {\n        temp = file_name[0..j-1];\n        temp2 = file_name[j..$];\n        if(temp.length == 0 || temp[0] < 'a' || temp[0] > 'z' || temp[0] < 'A' || temp[0] > 'Z')\n        {\n            result = \"No\";\n        }\n        else if(temp2 != \"txt\" && temp2 != \"exe\" && temp2 != \"dll\")\n        {\n            result = \"No\";\n        }\n        else\n        {\n            result = \"Yes\";\n        }\n    }\n    return result;\n}\n/*\nCreate a function which takes a string representing a file's name, and returns\n    the file's extension.\n    The file's extension is the substring after the last dot '.' in the file's name.\n    If there is no dot in the file's name, return an empty string.\n    Examples:\n    >>> file_extension(\"example.txt\")\n    \"txt\"\n    >>> file_extension(\"example\")\n    \"\"\n*/\nstring file_extension(string file_name) \n{\n    int i = 0;\n    int j = 0;\n    string result = \"\";\n    while(i < file_name.length)\n    {\n        if(file_name[i] == '.')\n        {\n            j = i + 1;\n        }\n        i++;\n\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpx20a4rp5.d(89): Error: found `unittest` instead of statement\n/tmp/tmpx20a4rp5.d(120): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpx20a4rp5.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164539
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_count = 0;\n    int digit_count = 0;\n    int first_letter_index = 0;\n    int last_letter_index = 0;\n    bool is_valid = true;\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n    string extension = \"\";\n    for (int i = 0; i < file_name.length; i++)\n    {\n        if (file_name[i] == '.')\n        {\n            dot_count++;\n            if (dot_count > 1)\n            {\n                is_valid = false;\n                break;\n            }\n            first_letter_index = i + 1;\n        }\n        else if (file_name[i] >= '0' && file_name[i] <= '9')\n        {\n            digit_count++;\n            if (digit_count > 3)\n            {\n                is_valid = false;\n                break;\n            }\n        }\n        else if (file_name[i] >= 'a' && file_name[i] <= 'z' ||\n                 file_name[i] >= 'A' && file_name[i] <= 'Z')\n        {\n            last_letter_index = i;\n        }\n    }\n    if (is_valid)\n    {\n        if (first_letter_index == 0 || last_letter_index == 0)\n        {\n            is_valid = false;\n        }\n        else\n        {\n            extension = file_name[first_letter_index..last_letter_index + 1];\n            if (extension.length == 0 || !valid_extensions.contains(extension))\n            {\n                is_valid = false;\n            }\n        }\n    }\n    return is_valid ? \"Yes\" : \"No\";\n}\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp1gdtoftq.d(73): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1gdtoftq.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164539
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_count = 0;\n    int digit_count = 0;\n    int dot_index = 0;\n    string extension = \"\";\n    string name = \"\";\n    foreach(i, c; file_name)\n    {\n        if(c == '.')\n        {\n            dot_count++;\n            dot_index = i;\n        }\n        if(c >= '0' && c <= '9')\n        {\n            digit_count++;\n        }\n    }\n    if(dot_count != 1 || digit_count > 3)\n    {\n        return \"No\";\n    }\n    name = file_name[0..dot_index];\n    extension = file_name[dot_index+1..$];\n    if(name.length == 0 || name[0] < 'a' || name[0] > 'z' || name[0] < 'A' || name[0] > 'Z')\n    {\n        return \"No\";\n    }\n    if(extension != \"txt\" && extension != \"exe\" && extension != \"dll\")\n    {\n        return \"No\";\n    }\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpm61jnik_.d(32): Error: cannot implicitly convert expression `i` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpm61jnik_.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164539
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_index = file_name.find('.');\n    string extension = file_name.substr(dot_index + 1);\n    string name = file_name.substr(0, dot_index);\n    int digits = 0;\n    foreach(c; name)\n    {\n        if(c >= '0' && c <= '9')\n            digits++;\n    }\n    if(digits > 3)\n        return \"No\";\n    if(extension != \"txt\" && extension != \"exe\" && extension != \"dll\")\n        return \"No\";\n    if(name.length == 0)\n        return \"No\";\n    if(!(name[0] >= 'a' && name[0] <= 'z') && !(name[0] >= 'A' && name[0] <= 'Z'))\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpot6_vyv4.d(22): Error: no property `find` for type `string`\n/tmp/tmpot6_vyv4.d(23): Error: no property `substr` for type `string`\n/tmp/tmpot6_vyv4.d(24): Error: no property `substr` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpot6_vyv4.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164539
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_pos = file_name.find('.');\n    if (dot_pos == -1)\n        return \"No\";\n    string before_dot = file_name[0..dot_pos];\n    string after_dot = file_name[dot_pos+1..$];\n    if (before_dot.length == 0)\n        return \"No\";\n    if (before_dot.count('0'..'9') > 3)\n        return \"No\";\n    if (after_dot != \"txt\" && after_dot != \"exe\" && after_dot != \"dll\")\n        return \"No\";\n    if (before_dot[0] < 'a' || before_dot[0] > 'z' && before_dot[0] < 'A' || before_dot[0] > 'Z')\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpvsfxjpbi.d(29): Error: found `..` when expecting `,`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvsfxjpbi.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164539
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_pos = file_name.find(\".\");\n    if (dot_pos == -1)\n        return \"No\";\n    string before_dot = file_name[0..dot_pos];\n    string after_dot = file_name[dot_pos+1..$];\n    if (before_dot.length == 0)\n        return \"No\";\n    if (before_dot.count(\"0123456789\") > 3)\n        return \"No\";\n    if (after_dot != \"txt\" && after_dot != \"exe\" && after_dot != \"dll\")\n        return \"No\";\n    if (before_dot[0] < 'a' || before_dot[0] > 'z')\n        if (before_dot[0] < 'A' || before_dot[0] > 'Z')\n            return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpkgm5dnna.d(22): Error: no property `find` for type `string`\n/tmp/tmpkgm5dnna.d(29): Error: no property `count` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkgm5dnna.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164539
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n    string[] file_name_parts = file_name.split(\".\");\n    if (file_name_parts.length != 2)\n        return \"No\";\n    string file_name_part = file_name_parts[0];\n    string file_extension = file_name_parts[1];\n    if (file_name_part.length == 0)\n        return \"No\";\n    if (file_name_part.count(\"0\") + file_name_part.count(\"1\") + file_name_part.count(\"2\") + file_name_part.count(\"3\") + file_name_part.count(\"4\") + file_name_part.count(\"5\") + file_name_part.count(\"6\") + file_name_part.count(\"7\") + file_name_part.count(\"8\") + file_name_part.count(\"9\") > 3)\n        return \"No\";\n    if (file_name_part[0] < 'a' || file_name_part[0] > 'z')\n        return \"No\";\n    if (file_name_part[0] < 'A' || file_name_part[0] > 'Z')\n        return \"No\";\n    if (valid_extensions.count(file_extension) == 0)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp2diedi7s.d(23): Error: no property `split` for type `string`\n/tmp/tmp2diedi7s.d(30): Error: no property `count` for type `string`\n/tmp/tmp2diedi7s.d(30): Error: no property `count` for type `string`\n/tmp/tmp2diedi7s.d(30): Error: no property `count` for type `string`\n/tmp/tmp2diedi7s.d(30): Error: no property `count` for type `string`\n/tmp/tmp2diedi7s.d(30): Error: no property `count` for type `string`\n/tmp/tmp2diedi7s.d(30): Error: no property `count` for type `string`\n/tmp/tmp2diedi7s.d(30): Error: no property `count` for type `string`\n/tmp/tmp2diedi7s.d(30): Error: no property `count` for type `string`\n/tmp/tmp2diedi7s.d(30): Error: no property `count` for type `string`\n/tmp/tmp2diedi7s.d(30): Error: no property `count` for type `string`\n/tmp/tmp2diedi7s.d(36): Error: no property `count` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2diedi7s.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164539
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n    int dot_index = file_name.find('.');\n    string extension = file_name.substr(dot_index + 1);\n    string name = file_name.substr(0, dot_index);\n    int digit_count = 0;\n    foreach(c; name)\n    {\n        if(c >= '0' && c <= '9')\n            digit_count++;\n    }\n    if(digit_count > 3 || dot_index == -1 || name.length == 0 || !(name[0] >= 'a' && name[0] <= 'z' || name[0] >= 'A' && name[0] <= 'Z'))\n        return \"No\";\n    foreach(ext; valid_extensions)\n    {\n        if(ext == extension)\n            return \"Yes\";\n    }\n    return \"No\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp45if2n1f.d(23): Error: no property `find` for type `string`\n/tmp/tmp45if2n1f.d(24): Error: no property `substr` for type `string`\n/tmp/tmp45if2n1f.d(25): Error: no property `substr` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp45if2n1f.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164539
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_pos = file_name.find('.');\n    if (dot_pos == -1)\n        return \"No\";\n    string extension = file_name.slice(dot_pos + 1);\n    if (extension != \"txt\" && extension != \"exe\" && extension != \"dll\")\n        return \"No\";\n    string name = file_name.slice(0, dot_pos);\n    if (name.length == 0)\n        return \"No\";\n    int digit_count = 0;\n    foreach (c; name)\n    {\n        if (c >= '0' && c <= '9')\n            digit_count++;\n        else if (!(c >= 'a' && c <= 'z') && !(c >= 'A' && c <= 'Z'))\n            return \"No\";\n    }\n    if (digit_count > 3)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp8uwdic1_.d(22): Error: no property `find` for type `string`\n/tmp/tmp8uwdic1_.d(25): Error: no property `slice` for type `string`\n/tmp/tmp8uwdic1_.d(28): Error: no property `slice` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8uwdic1_.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164539
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    import std.algorithm : count;\n    import std.array : array;\n    import std.conv : to;\n    import std.range : take, drop;\n    import std.string : startsWith;\n    import std.typecons : tuple;\n    import std.typecons : Tuple;\n    import std.typecons : tuple;\n    import std.typecons : Tuple;\n    import std.typecons : tuple;\n    import std.typecons : Tuple;\n    import std.typecons : tuple;\n    import std.typecons : Tuple;\n    import std.typecons : tuple;\n    import std.typecons : Tuple;\n    import std.typecons : tuple;\n    import std.typecons : Tuple;\n    import std.typecons : tuple;\n    import std.typecons : Tuple;\n    import std.typecons : tuple;\n    import std.typecons : Tuple;\n    import std.typecons : tuple;\n    import std.typecons : Tuple;\n    import std.typecons : tuple;\n    import std.typecons : Tuple;\n    import std.typecons : tuple;\n    import std.typecons : Tuple;\n    import std.typecons : tuple;\n    import std.typecons : Tuple;\n    import std.typecons : tuple;\n    import std.typecons : Tuple;\n    import std.typecons : tuple;\n    import std.typecons : Tuple;\n    import std.typecons : tuple;\n    import std.typecons : Tuple;\n    import std.typecons : tuple;\n    import std.typecons : Tuple;\n    import std.typecons : tuple;\n    import std.typecons : Tuple;\n    import std.typecons : tuple;\n    import std.typecons : Tuple;\n    import std.typecons : tuple;\n    import std.typecons : Tuple;\n    import std.typecons : tuple;\n    import std.typecons : Tuple;\n    import std.typecons : tuple;\n    import std.typecons : Tuple;\n    import std.typecons : tuple;\n    import std.typecons : Tuple\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp65k4ms5y.d(71): Error: `;` expected\n/tmp/tmp65k4ms5y.d(102): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp65k4ms5y.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164539
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_pos = file_name.find('.');\n    if (dot_pos == -1)\n        return \"No\";\n    string before_dot = file_name[0..dot_pos];\n    string after_dot = file_name[dot_pos+1..$];\n    if (before_dot.length == 0 || after_dot.length == 0)\n        return \"No\";\n    if (before_dot.count('0','9') > 3)\n        return \"No\";\n    if (before_dot[0] < 'a' || before_dot[0] > 'z')\n        return \"No\";\n    if (after_dot != \"txt\" && after_dot != \"exe\" && after_dot != \"dll\")\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmphu4hjhtk.d(22): Error: no property `find` for type `string`\n/tmp/tmphu4hjhtk.d(29): Error: no property `count` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphu4hjhtk.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164539
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_index = file_name.find('.');\n    if (dot_index == -1)\n        return \"No\";\n    string name = file_name[0..dot_index];\n    string extension = file_name[dot_index+1..$];\n    if (name.length == 0 || !(name[0] >= 'a' && name[0] <= 'z' || name[0] >= 'A' && name[0] <= 'Z'))\n        return \"No\";\n    if (extension != \"txt\" && extension != \"exe\" && extension != \"dll\")\n        return \"No\";\n    int count = 0;\n    foreach (c; name)\n        if (c >= '0' && c <= '9')\n            count++;\n    if (count > 3)\n        return \"No\";\n    return \"Yes\";\n}\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check_2(string file_name) \n{\n    int dot_index = file_name.find('.');\n    if (dot_index == -1)\n        return \"No\";\n    string name = file_name[0..dot_index];\n    string extension = file_name[dot_index+1..$];\n    if (name.length == 0 || !(\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp39l2qcu2.d(64): Error: expression expected, not `unittest`\n/tmp/tmp39l2qcu2.d(63): Error: found `{` when expecting `)`\n/tmp/tmp39l2qcu2.d(66): Error: found `alias` when expecting `)`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp39l2qcu2.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164539
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n    int dot_index = file_name.find('.');\n    string extension = file_name.substr(dot_index + 1);\n    string name = file_name.substr(0, dot_index);\n    int digits_count = 0;\n    foreach(char c; name)\n    {\n        if(c >= '0' && c <= '9')\n            digits_count++;\n    }\n    if(digits_count > 3 || dot_index == -1 || name.length == 0 || !(name[0] >= 'a' && name[0] <= 'z' || name[0] >= 'A' && name[0] <= 'Z'))\n        return \"No\";\n    foreach(string s; valid_extensions)\n    {\n        if(s == extension)\n            return \"Yes\";\n    }\n    return \"No\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp26mb_6iw.d(23): Error: no property `find` for type `string`\n/tmp/tmp26mb_6iw.d(24): Error: no property `substr` for type `string`\n/tmp/tmp26mb_6iw.d(25): Error: no property `substr` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp26mb_6iw.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164539
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_count = 0;\n    int digit_count = 0;\n    int letter_count = 0;\n    string extension;\n    string name;\n    foreach(char c; file_name)\n    {\n        if(c == '.')\n        {\n            dot_count++;\n            extension = file_name[$-3..$];\n        }\n        else if(c >= '0' && c <= '9')\n        {\n            digit_count++;\n        }\n        else if((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z'))\n        {\n            letter_count++;\n        }\n    }\n    name = file_name[0..$-4];\n    if(dot_count == 1 && digit_count <= 3 && letter_count > 0 && (extension == \"txt\" || extension == \"exe\" || extension == \"dll\"))\n    {\n        return \"Yes\";\n    }\n    else\n    {\n        return \"No\";\n    }\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp_xcd71bt.d(58): unittest failure\n----------------\n??:? _d_unittestp [0x42878d]\n??:? void tmp_xcd71bt.__unittest_L53_C1() [0x427cf4]\n??:? void tmp_xcd71bt.__modtest() [0x42850c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c4ab]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3ba]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4304d1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430980]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43045d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b391]\n??:? runModuleUnitTests [0x42c281]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428c50]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164540
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int count = 0;\n    int dot_count = 0;\n    string extension = \"\";\n    string name = \"\";\n    foreach(char c; file_name)\n    {\n        if(c == '.')\n        {\n            dot_count++;\n            continue;\n        }\n        if(dot_count == 0)\n        {\n            name ~= c;\n        }\n        else\n        {\n            extension ~= c;\n        }\n        if(c >= '0' && c <= '9')\n        {\n            count++;\n        }\n    }\n    if(count > 3 || dot_count != 1 || name.length == 0 || !(name[0] >= 'a' && name[0] <= 'z') || !(name[0] >= 'A' && name[0] <= 'Z') || !(extension == \"txt\" || extension == \"exe\" || extension == \"dll\"))\n    {\n        return \"No\";\n    }\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpwplpb9tb.d(56): unittest failure\n----------------\n??:? _d_unittestp [0x428855]\n??:? void tmpwplpb9tb.__unittest_L52_C1() [0x427d5d]\n??:? void tmpwplpb9tb.__modtest() [0x4285d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cf5f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42be6e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430845]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430cf4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4307d1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42be45]\n??:? runModuleUnitTests [0x42cd35]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428d18]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164540
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int count = 0;\n    int dot_count = 0;\n    int dot_index = 0;\n    int dot_index_end = 0;\n    int dot_index_start = 0;\n    string file_name_start;\n    string file_name_end;\n    string file_name_end_check;\n    string file_name_start_check;\n    string file_name_end_check_1;\n    string file_name_end_check_2;\n    string file_name_end_check_3;\n    string file_name_end_check_4;\n    string file_name_end_check_5;\n    string file_name_end_check_6;\n    string file_name_end_check_7;\n    string file_name_end_check_8;\n    string file_name_end_check_9;\n    string file_name_end_check_10;\n    string file_name_end_check_11;\n    string file_name_end_check_12;\n    string file_name_end_check_13;\n    string file_name_end_check_14;\n    string file_name_end_check_15;\n    string file_name_end_check_16;\n    string file_name_end_check_17;\n    string file_name_end_check_18;\n    string file_name_end_check_19;\n    string file_name_end_check_20;\n    string file_name_end_check_21;\n    string file_name_end_check_22;\n    string file_name_end_check_23;\n    string file_name_end_check_24;\n    string file_name_end_check_25;\n    string file_name_end_check_26;\n    string file_name_end_check_27;\n    string file_name_end_check_28;\n    string file_name_end_check_29;\n    string file_name_end_check_30;\n    string file_name_end_check_31;\n    string file_name_end_check_32;\n    string file_name_\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpr03s7b_h.d(63): Error: found `file_name_` when expecting `;` following statement\n/tmp/tmpr03s7b_h.d(64): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpr03s7b_h.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164539
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n    int dot_index = file_name.find(\".\");\n    string extension = file_name[dot_index+1..$];\n    string name = file_name[0..dot_index-1];\n    if(extension.length == 0 || !valid_extensions.canFind(extension))\n        return \"No\";\n    if(name.length == 0 || !isAlpha(name[0]))\n        return \"No\";\n    if(name.count(\"0\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\") > 3)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpgly9cvll.d(23): Error: no property `find` for type `string`\n/tmp/tmpgly9cvll.d(26): Error: no property `canFind` for type `string[]`\n/tmp/tmpgly9cvll.d(28): Error: undefined identifier `isAlpha`\n/tmp/tmpgly9cvll.d(30): Error: no property `count` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpgly9cvll.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164540
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n    int dot_index = file_name.find('.');\n    string extension = file_name.substr(dot_index + 1);\n    string name = file_name.substr(0, dot_index);\n    int number_of_digits = 0;\n    foreach(char c; name)\n    {\n        if(c >= '0' && c <= '9')\n            number_of_digits++;\n    }\n    return (number_of_digits <= 3 && dot_index != -1 && \n            name.length > 0 && name[0] >= 'a' && name[0] <= 'z' && \n            valid_extensions.find(extension) != -1) ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpnhlfs5wh.d(23): Error: no property `find` for type `string`\n/tmp/tmpnhlfs5wh.d(24): Error: no property `substr` for type `string`\n/tmp/tmpnhlfs5wh.d(25): Error: no property `substr` for type `string`\n/tmp/tmpnhlfs5wh.d(34): Error: no property `find` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpnhlfs5wh.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164539
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int count = 0;\n    int dot_index = 0;\n    int dot_count = 0;\n    string extension = \"\";\n    string name = \"\";\n    foreach(i, c; file_name)\n    {\n        if(c == '.')\n        {\n            dot_index = i;\n            dot_count++;\n        }\n        if(c >= '0' && c <= '9')\n        {\n            count++;\n        }\n    }\n    if(count > 3 || dot_count != 1)\n    {\n        return \"No\";\n    }\n    name = file_name[0..dot_index];\n    extension = file_name[dot_index+1..$];\n    if(name.length == 0 || (name[0] < 'a' || name[0] > 'z') && (name[0] < 'A' || name[0] > 'Z'))\n    {\n        return \"No\";\n    }\n    if(extension != \"txt\" && extension != \"exe\" && extension != \"dll\")\n    {\n        return \"No\";\n    }\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpxuihuo7g.d(31): Error: cannot implicitly convert expression `i` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxuihuo7g.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164539
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_index = file_name.find('.');\n    if (dot_index == -1)\n        return \"No\";\n    string extension = file_name.substr(dot_index + 1);\n    if (extension != \"txt\" && extension != \"exe\" && extension != \"dll\")\n        return \"No\";\n    string name = file_name.substr(0, dot_index);\n    if (name.length == 0)\n        return \"No\";\n    if (!isalpha(name[0]))\n        return \"No\";\n    int digits = 0;\n    foreach (c; name)\n    {\n        if (isdigit(c))\n            digits++;\n    }\n    if (digits > 3)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmppqiq8j__.d(22): Error: no property `find` for type `string`\n/tmp/tmppqiq8j__.d(25): Error: no property `substr` for type `string`\n/tmp/tmppqiq8j__.d(28): Error: no property `substr` for type `string`\n/tmp/tmppqiq8j__.d(31): Error: undefined identifier `isalpha`\n/tmp/tmppqiq8j__.d(36): Error: undefined identifier `isdigit`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppqiq8j__.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164539
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    if(file_name.count('.') != 1)\n        return \"No\";\n    string[] parts = file_name.split('.');\n    if(parts[0].length == 0 || parts[1].length == 0)\n        return \"No\";\n    if(parts[0].count('0') + parts[0].count('1') + parts[0].count('2') + parts[0].count('3') + parts[0].count('4') + parts[0].count('5') + parts[0].count('6') + parts[0].count('7') + parts[0].count('8') + parts[0].count('9') > 3)\n        return \"No\";\n    if(parts[1] != \"txt\" && parts[1] != \"exe\" && parts[1] != \"dll\")\n        return \"No\";\n    if(parts[0][0] < 'a' || parts[0][0] > 'z' && parts[0][0] < 'A' || parts[0][0] > 'Z')\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmps13iyrco.d(22): Error: no property `count` for type `string`\n/tmp/tmps13iyrco.d(24): Error: no property `split` for type `string`\n/tmp/tmps13iyrco.d(27): Error: no property `count` for type `string`\n/tmp/tmps13iyrco.d(27): Error: no property `count` for type `string`\n/tmp/tmps13iyrco.d(27): Error: no property `count` for type `string`\n/tmp/tmps13iyrco.d(27): Error: no property `count` for type `string`\n/tmp/tmps13iyrco.d(27): Error: no property `count` for type `string`\n/tmp/tmps13iyrco.d(27): Error: no property `count` for type `string`\n/tmp/tmps13iyrco.d(27): Error: no property `count` for type `string`\n/tmp/tmps13iyrco.d(27): Error: no property `count` for type `string`\n/tmp/tmps13iyrco.d(27): Error: no property `count` for type `string`\n/tmp/tmps13iyrco.d(27): Error: no property `count` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmps13iyrco.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164539
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_count = 0;\n    int digit_count = 0;\n    int dot_index = 0;\n    int extension_index = 0;\n    string extension = \"\";\n    string name = \"\";\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n    foreach(int i, char c; file_name)\n    {\n        if(c == '.')\n        {\n            dot_count++;\n            dot_index = i;\n        }\n        if(c >= '0' && c <= '9')\n        {\n            digit_count++;\n        }\n    }\n    if(dot_count != 1 || digit_count > 3)\n    {\n        return \"No\";\n    }\n    extension_index = dot_index + 1;\n    extension = file_name[extension_index..$];\n    if(extension !in valid_extensions)\n    {\n        return \"No\";\n    }\n    name = file_name[0..dot_index];\n    if(name.length == 0 || (name[0] < 'a' || name[0] > 'z') && (name[0] < 'A' || name[0] > 'Z'))\n    {\n        return \"No\";\n    }\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpu9bnkoqy.d(47): Error: incompatible types for `(extension) in (valid_extensions)`: `string` and `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpu9bnkoqy.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164540
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n    int dot_index = file_name.find(\".\");\n    string extension = file_name[dot_index+1..$];\n    string name = file_name[0..dot_index-1];\n    int digits_count = 0;\n    foreach(char c; name)\n    {\n        if(c >= '0' && c <= '9')\n            digits_count++;\n    }\n    if(digits_count > 3)\n        return \"No\";\n    if(dot_index == -1)\n        return \"No\";\n    if(name.length == 0)\n        return \"No\";\n    if(!(name[0] >= 'a' && name[0] <= 'z') && !(name[0] >= 'A' && name[0] <= 'Z'))\n        return \"No\";\n    if(!valid_extensions.canFind(extension))\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpn6f_qs8s.d(23): Error: no property `find` for type `string`\n/tmp/tmpn6f_qs8s.d(40): Error: no property `canFind` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpn6f_qs8s.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164539
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n    string[] file_name_parts = file_name.split(\".\");\n    if (file_name_parts.length != 2)\n        return \"No\";\n    if (file_name_parts[0].length == 0)\n        return \"No\";\n    if (file_name_parts[0].count('0', '9') > 3)\n        return \"No\";\n    if (!valid_extensions.contains(file_name_parts[1]))\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp9v474z9m.d(23): Error: no property `split` for type `string`\n/tmp/tmp9v474z9m.d(28): Error: no property `count` for type `string`\n/tmp/tmp9v474z9m.d(30): Error: no property `contains` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9v474z9m.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164539
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_count = 0;\n    int digit_count = 0;\n    int letter_count = 0;\n    int letter_index = 0;\n    bool is_valid = true;\n    string extension = \"\";\n    string prefix = \"\";\n    foreach(i, c; file_name)\n    {\n        if(c == '.')\n        {\n            dot_count++;\n            letter_index = i;\n        }\n        else if(c >= '0' && c <= '9')\n        {\n            digit_count++;\n        }\n        else if((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z'))\n        {\n            letter_count++;\n        }\n    }\n    if(dot_count != 1 || digit_count > 3 || letter_count == 0)\n    {\n        is_valid = false;\n    }\n    else\n    {\n        prefix = file_name[0..letter_index];\n        extension = file_name[letter_index+1..$];\n        if(extension != \"txt\" && extension != \"exe\" && extension != \"dll\")\n        {\n            is_valid = false;\n        }\n    }\n    return is_valid ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpx504rzo0.d(34): Error: cannot implicitly convert expression `i` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpx504rzo0.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164540
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_index = file_name.find('.');\n    if (dot_index == -1)\n        return \"No\";\n    string name = file_name[0..dot_index];\n    string ext = file_name[dot_index+1..$];\n    if (name.length == 0 || !(name[0] >= 'a' && name[0] <= 'z' || name[0] >= 'A' && name[0] <= 'Z'))\n        return \"No\";\n    if (ext != \"txt\" && ext != \"exe\" && ext != \"dll\")\n        return \"No\";\n    int num_digits = 0;\n    foreach (c; name)\n        if (c >= '0' && c <= '9')\n            num_digits++;\n    if (num_digits > 3)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpgs46mt7h.d(22): Error: no property `find` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpgs46mt7h.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164540
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_pos = file_name.find(\".\");\n    if (dot_pos == -1)\n        return \"No\";\n    string before_dot = file_name[0..dot_pos];\n    string after_dot = file_name[dot_pos+1..$];\n    if (before_dot.length == 0 || before_dot.length > 8)\n        return \"No\";\n    if (after_dot != \"txt\" && after_dot != \"exe\" && after_dot != \"dll\")\n        return \"No\";\n    int num_digits = 0;\n    foreach (c; before_dot)\n    {\n        if (c >= '0' && c <= '9')\n            num_digits++;\n        else if (!(c >= 'a' && c <= 'z') && !(c >= 'A' && c <= 'Z'))\n            return \"No\";\n    }\n    if (num_digits > 3)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp67093uqh.d(22): Error: no property `find` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp67093uqh.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164540
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n    int dot_index = file_name.find(\".\");\n    string extension = file_name[dot_index+1..$];\n    string name = file_name[0..dot_index-1];\n    int num_digits = 0;\n    foreach(char c; name)\n    {\n        if(c >= '0' && c <= '9')\n            num_digits++;\n    }\n    if(num_digits > 3)\n        return \"No\";\n    if(!(name[0] >= 'a' && name[0] <= 'z') && !(name[0] >= 'A' && name[0] <= 'Z'))\n        return \"No\";\n    if(!valid_extensions.canFind(extension))\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp8xxdccls.d(23): Error: no property `find` for type `string`\n/tmp/tmp8xxdccls.d(36): Error: no property `canFind` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8xxdccls.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164540
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_index = file_name.find(\".\");\n    if (dot_index == -1)\n        return \"No\";\n    string before_dot = file_name[0..dot_index];\n    string after_dot = file_name[dot_index+1..$];\n    if (before_dot.length == 0)\n        return \"No\";\n    if (after_dot != \"txt\" && after_dot != \"exe\" && after_dot != \"dll\")\n        return \"No\";\n    int digits_count = 0;\n    foreach (c; before_dot)\n    {\n        if (c >= '0' && c <= '9')\n            digits_count++;\n    }\n    if (digits_count > 3)\n        return \"No\";\n    if (before_dot[0] < 'a' || before_dot[0] > 'z')\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpef8lsh71.d(22): Error: no property `find` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpef8lsh71.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164540
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n    auto dot_index = file_name.find(\".\");\n    if (dot_index == -1)\n        return \"No\";\n    auto extension = file_name[dot_index + 1 .. $];\n    if (valid_extensions.count(extension) == 0)\n        return \"No\";\n    auto name = file_name[0 .. dot_index];\n    if (name.count(\"0\" .. \"9\") > 3)\n        return \"No\";\n    if (name.length == 0)\n        return \"No\";\n    if (name[0] < \"a\" || name[0] > \"z\" && name[0] < \"A\" || name[0] > \"Z\")\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp49tzcae8.d(30): Error: found `..` when expecting `,`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp49tzcae8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164539
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n    string[] file_name_parts = split(file_name, \".\");\n    if (file_name_parts.length != 2)\n        return \"No\";\n    string file_name_part = file_name_parts[0];\n    string file_extension = file_name_parts[1];\n    if (file_name_part.length == 0)\n        return \"No\";\n    if (file_name_part.length > 3)\n        return \"No\";\n    if (file_name_part.length == 3)\n    {\n        if (!isDigit(file_name_part[0]) || !isDigit(file_name_part[1]) || !isDigit(file_name_part[2]))\n            return \"No\";\n    }\n    if (file_name_part.length == 2)\n    {\n        if (!isDigit(file_name_part[0]) || !isDigit(file_name_part[1]))\n            return \"No\";\n    }\n    if (file_name_part.length == 1)\n    {\n        if (!isDigit(file_name_part[0]))\n            return \"No\";\n    }\n    if (!isAlpha(file_name_part[0]))\n        return \"No\";\n    if (!valid_extensions.contains(file_extension))\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp6f_dko98.d(23): Error: undefined identifier `split`\n/tmp/tmp6f_dko98.d(34): Error: undefined identifier `isDigit`\n/tmp/tmp6f_dko98.d(34): Error: undefined identifier `isDigit`\n/tmp/tmp6f_dko98.d(34): Error: undefined identifier `isDigit`\n/tmp/tmp6f_dko98.d(39): Error: undefined identifier `isDigit`\n/tmp/tmp6f_dko98.d(39): Error: undefined identifier `isDigit`\n/tmp/tmp6f_dko98.d(44): Error: undefined identifier `isDigit`\n/tmp/tmp6f_dko98.d(47): Error: undefined identifier `isAlpha`\n/tmp/tmp6f_dko98.d(49): Error: no property `contains` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6f_dko98.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164540
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_index = file_name.find('.');\n    string extension = file_name.substr(dot_index + 1);\n    string name = file_name.substr(0, dot_index);\n    int digit_count = 0;\n    foreach(char c; name)\n    {\n        if(c >= '0' && c <= '9')\n            digit_count++;\n    }\n    if(digit_count > 3)\n        return \"No\";\n    if(extension != \"txt\" && extension != \"exe\" && extension != \"dll\")\n        return \"No\";\n    if(name.length == 0)\n        return \"No\";\n    if(!(name[0] >= 'a' && name[0] <= 'z') && !(name[0] >= 'A' && name[0] <= 'Z'))\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpjifxcq_i.d(22): Error: no property `find` for type `string`\n/tmp/tmpjifxcq_i.d(23): Error: no property `substr` for type `string`\n/tmp/tmpjifxcq_i.d(24): Error: no property `substr` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjifxcq_i.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164540
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n    string[] file_name_parts = file_name.split(\".\");\n    if (file_name_parts.length != 2)\n        return \"No\";\n    string file_name_part = file_name_parts[0];\n    string extension = file_name_parts[1];\n    if (file_name_part.length == 0 || !file_name_part[0].isAlpha)\n        return \"No\";\n    if (valid_extensions.count(extension) == 0)\n        return \"No\";\n    if (file_name_part.count!(c => c.isDigit) > 3)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp_txco74v.d(23): Error: no property `split` for type `string`\n/tmp/tmp_txco74v.d(28): Error: no property `isAlpha` for type `immutable(char)`\n/tmp/tmp_txco74v.d(30): Error: no property `count` for type `string[]`\n/tmp/tmp_txco74v.d(32): Error: no property `count` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_txco74v.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164540
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int count = 0;\n    int dot_count = 0;\n    int dot_index = 0;\n    string sub_string_before_dot = \"\";\n    string sub_string_after_dot = \"\";\n    foreach(i, c; file_name)\n    {\n        if(c == '.')\n        {\n            dot_count++;\n            dot_index = i;\n        }\n        if(c >= '0' && c <= '9')\n        {\n            count++;\n        }\n    }\n    if(count > 3 || dot_count != 1)\n    {\n        return \"No\";\n    }\n    sub_string_before_dot = file_name[0..dot_index];\n    sub_string_after_dot = file_name[dot_index + 1..$];\n    if(sub_string_before_dot == \"\" || !(sub_string_before_dot[0] >= 'a' && sub_string_before_dot[0] <= 'z') && !(sub_string_before_dot[0] >= 'A' && sub_string_before_dot[0] <= 'Z'))\n    {\n        return \"No\";\n    }\n    if(sub_string_after_dot != \"txt\" && sub_string_after_dot != \"exe\" && sub_string_after_dot != \"dll\")\n    {\n        return \"No\";\n    }\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp89h33i7x.d(32): Error: cannot implicitly convert expression `i` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp89h33i7x.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164540
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_index = file_name.find('.');\n    if (dot_index == -1)\n        return \"No\";\n    string sub_str = file_name[0..dot_index];\n    if (sub_str.length == 0)\n        return \"No\";\n    if (sub_str.length > 3)\n        return \"No\";\n    if (sub_str[0] < 'a' || sub_str[0] > 'z')\n        return \"No\";\n    sub_str = file_name[dot_index+1..$];\n    if (sub_str != \"txt\" && sub_str != \"exe\" && sub_str != \"dll\")\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164540
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_index = file_name.find(\".\");\n    string extension = file_name.substr(dot_index + 1);\n    string name = file_name.substr(0, dot_index);\n    int digits = 0;\n    foreach(char c; name)\n    {\n        if(c >= '0' && c <= '9')\n            digits++;\n    }\n    if(digits > 3)\n        return \"No\";\n    if(extension != \"txt\" && extension != \"exe\" && extension != \"dll\")\n        return \"No\";\n    if(name.length == 0)\n        return \"No\";\n    if(!(name[0] >= 'a' && name[0] <= 'z') && !(name[0] >= 'A' && name[0] <= 'Z'))\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp2m2qhzkx.d(22): Error: no property `find` for type `string`\n/tmp/tmp2m2qhzkx.d(23): Error: no property `substr` for type `string`\n/tmp/tmp2m2qhzkx.d(24): Error: no property `substr` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2m2qhzkx.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164540
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    import std.algorithm : count;\n    import std.conv : to;\n    import std.array : array;\n    import std.range : take, drop;\n    import std.string : split;\n    import std.ascii : isAlpha;\n    import std.range : take, drop;\n    import std.array : array;\n    import std.algorithm : count;\n    import std.conv : to;\n    import std.string : split;\n    import std.ascii : isAlpha;\n    import std.range : take, drop;\n    import std.array : array;\n    import std.algorithm : count;\n    import std.conv : to;\n    import std.string : split;\n    import std.ascii : isAlpha;\n    import std.range : take, drop;\n    import std.array : array;\n    import std.algorithm : count;\n    import std.conv : to;\n    import std.string : split;\n    import std.ascii : isAlpha;\n    import std.range : take, drop;\n    import std.array : array;\n    import std.algorithm : count;\n    import std.conv : to;\n    import std.string : split;\n    import std.ascii : isAlpha;\n    import std.range : take, drop;\n    import std.array : array;\n    import std.algorithm : count;\n    import std.conv : to;\n    import std.string : split;\n    import std.ascii : isAlpha;\n    import std.range : take, drop;\n    import std.array : array;\n    import std.algorithm : count;\n    import std.conv : to;\n    import std.string : split;\n    import std.ascii : isAlpha;\n    import std.range : take, drop;\n    import std.array : array;\n    import std.algorithm : count;\n    import std.conv : to;\n    import std.string : split;\n    import std.ascii : isAlpha;\n    import std.range : take, drop;\n    import std.array : array;\n    import std.algorithm : count;\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpn8vb_ubw.d(73): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpn8vb_ubw.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164540
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    // your code here\n    int dot_pos = file_name.find('.');\n    if (dot_pos == -1) return \"No\";\n    string before_dot = file_name[0..dot_pos];\n    string after_dot = file_name[dot_pos+1..$];\n    if (before_dot.length == 0) return \"No\";\n    if (after_dot.length == 0) return \"No\";\n    if (after_dot != \"txt\" && after_dot != \"exe\" && after_dot != \"dll\") return \"No\";\n    if (before_dot.length > 3) return \"No\";\n    if (before_dot[0] < 'A' || before_dot[0] > 'z') return \"No\";\n    if (before_dot[0] > 'Z' && before_dot[0] < 'a') return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp2n7aij6n.d(23): Error: no property `find` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2n7aij6n.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164540
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int count = 0;\n    int dot_index = 0;\n    string file_extension = \"\";\n    foreach(i, c; file_name)\n    {\n        if(c == '.')\n        {\n            dot_index = i;\n            break;\n        }\n    }\n    file_extension = file_name[dot_index+1..$];\n    if(file_extension != \"txt\" && file_extension != \"exe\" && file_extension != \"dll\")\n    {\n        return \"No\";\n    }\n    foreach(i, c; file_name[0..dot_index-1])\n    {\n        if(c >= '0' && c <= '9')\n        {\n            count++;\n        }\n    }\n    if(count > 3)\n    {\n        return \"No\";\n    }\n    if(file_name[0] < 'a' || file_name[0] > 'z')\n    {\n        return \"No\";\n    }\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmprco_58ag.d(29): Error: cannot implicitly convert expression `i` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprco_58ag.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164540
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    // TODO: implement this function\n    auto dot_pos = file_name.find('.');\n    if (dot_pos == -1)\n        return \"No\";\n    auto dot_pos_next = file_name.find('.', dot_pos + 1);\n    if (dot_pos_next != -1)\n        return \"No\";\n    auto dot_pos_prev = file_name.find('.', 0, dot_pos);\n    if (dot_pos_prev != -1)\n        return \"No\";\n    auto digits_count = 0;\n    foreach (i, c; file_name)\n    {\n        if (c >= '0' && c <= '9')\n            digits_count++;\n    }\n    if (digits_count > 3)\n        return \"No\";\n    auto extension = file_name.slice(dot_pos + 1);\n    if (extension != \"txt\" && extension != \"exe\" && extension != \"dll\")\n        return \"No\";\n    auto name = file_name.slice(0, dot_pos);\n    if (name.empty)\n        return \"No\";\n    if (name[0] < 'a' || name[0] > 'z' && name[0] < 'A' || name[0] > 'Z')\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpomgawz7o.d(23): Error: no property `find` for type `string`\n/tmp/tmpomgawz7o.d(26): Error: no property `find` for type `string`\n/tmp/tmpomgawz7o.d(29): Error: no property `find` for type `string`\n/tmp/tmpomgawz7o.d(40): Error: no property `slice` for type `string`\n/tmp/tmpomgawz7o.d(43): Error: no property `slice` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpomgawz7o.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164540
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n    string[] file_name_parts = file_name.split(\".\");\n    if (file_name_parts.length != 2)\n        return \"No\";\n    if (file_name_parts[0].length == 0)\n        return \"No\";\n    if (file_name_parts[0].count(\"0-9\") > 3)\n        return \"No\";\n    if (file_name_parts[0][0] < 'a' || file_name_parts[0][0] > 'z')\n        return \"No\";\n    if (valid_extensions.count(file_name_parts[1]) == 0)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmppz8nd86z.d(23): Error: no property `split` for type `string`\n/tmp/tmppz8nd86z.d(28): Error: no property `count` for type `string`\n/tmp/tmppz8nd86z.d(32): Error: no property `count` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppz8nd86z.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164539
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_index = file_name.find('.');\n    string extension = file_name.substr(dot_index + 1);\n    string name = file_name.substr(0, dot_index);\n    int digits = 0;\n    foreach(char c; name)\n    {\n        if(c >= '0' && c <= '9')\n            digits++;\n    }\n    if(digits > 3)\n        return \"No\";\n    if(extension != \"txt\" && extension != \"exe\" && extension != \"dll\")\n        return \"No\";\n    if(name.length == 0)\n        return \"No\";\n    if(!(name[0] >= 'a' && name[0] <= 'z') && !(name[0] >= 'A' && name[0] <= 'Z'))\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp_kk64oag.d(22): Error: no property `find` for type `string`\n/tmp/tmp_kk64oag.d(23): Error: no property `substr` for type `string`\n/tmp/tmp_kk64oag.d(24): Error: no property `substr` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_kk64oag.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164540
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_pos = file_name.find('.');\n    string file_name_without_ext = file_name.substr(0, dot_pos);\n    string ext = file_name.substr(dot_pos + 1);\n    int digits_count = 0;\n    foreach(c; file_name_without_ext)\n    {\n        if(c >= '0' && c <= '9')\n            digits_count++;\n    }\n    if(digits_count > 3)\n        return \"No\";\n    if(!(file_name_without_ext[0] >= 'a' && file_name_without_ext[0] <= 'z') &&\n       !(file_name_without_ext[0] >= 'A' && file_name_without_ext[0] <= 'Z'))\n        return \"No\";\n    if(ext != \"txt\" && ext != \"exe\" && ext != \"dll\")\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp1axjv9hk.d(22): Error: no property `find` for type `string`\n/tmp/tmp1axjv9hk.d(23): Error: no property `substr` for type `string`\n/tmp/tmp1axjv9hk.d(24): Error: no property `substr` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1axjv9hk.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164540
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_index = file_name.find('.');\n    if (dot_index == -1)\n        return \"No\";\n    string before_dot = file_name[0..dot_index];\n    string after_dot = file_name[dot_index+1..$];\n    if (before_dot.length == 0 || !isalpha(before_dot[0]))\n        return \"No\";\n    if (after_dot.length == 0 || after_dot.length > 3)\n        return \"No\";\n    if (after_dot != \"txt\" && after_dot != \"exe\" && after_dot != \"dll\")\n        return \"No\";\n    int num_digits = 0;\n    foreach (c; before_dot)\n    {\n        if (isdigit(c))\n            num_digits++;\n    }\n    if (num_digits > 3)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpvtcuhxg5.d(22): Error: no property `find` for type `string`\n/tmp/tmpvtcuhxg5.d(27): Error: undefined identifier `isalpha`\n/tmp/tmpvtcuhxg5.d(36): Error: undefined identifier `isdigit`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvtcuhxg5.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164540
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n    int dot_index = file_name.find(\".\");\n    string extension = file_name[dot_index+1..$];\n    string name = file_name[0..dot_index-1];\n    int digits_count = 0;\n    foreach(c; name)\n    {\n        if(c.isDigit)\n            digits_count++;\n    }\n    if(digits_count > 3)\n        return \"No\";\n    if(!name.length)\n        return \"No\";\n    if(!name[0].isLetter)\n        return \"No\";\n    if(!valid_extensions.canFind(extension))\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp5ta7wxfb.d(23): Error: no property `find` for type `string`\n/tmp/tmp5ta7wxfb.d(29): Error: no property `isDigit` for type `immutable(char)`\n/tmp/tmp5ta7wxfb.d(36): Error: no property `isLetter` for type `immutable(char)`\n/tmp/tmp5ta7wxfb.d(38): Error: no property `canFind` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5ta7wxfb.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164540
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    if (file_name.count('.') != 1)\n        return \"No\";\n    string[] parts = file_name.split('.');\n    if (parts[0].length == 0 || parts[1].length == 0)\n        return \"No\";\n    if (parts[0].count('0', '9') > 3)\n        return \"No\";\n    if (parts[1] != \"txt\" && parts[1] != \"exe\" && parts[1] != \"dll\")\n        return \"No\";\n    if (parts[0].count('a', 'z') == 0 && parts[0].count('A', 'Z') == 0)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpyl6a14x7.d(22): Error: no property `count` for type `string`\n/tmp/tmpyl6a14x7.d(24): Error: no property `split` for type `string`\n/tmp/tmpyl6a14x7.d(27): Error: no property `count` for type `string`\n/tmp/tmpyl6a14x7.d(31): Error: no property `count` for type `string`\n/tmp/tmpyl6a14x7.d(31): Error: no property `count` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpyl6a14x7.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164540
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int count = 0;\n    int dot_count = 0;\n    int dot_index = 0;\n    string sub_str;\n    string sub_str2;\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n    foreach(i; 0..file_name.length)\n    {\n        if(file_name[i] >= '0' && file_name[i] <= '9')\n        {\n            count++;\n        }\n        if(file_name[i] == '.')\n        {\n            dot_count++;\n            dot_index = i;\n        }\n    }\n    if(count > 3 || dot_count != 1)\n    {\n        return \"No\";\n    }\n    sub_str = file_name[0..dot_index];\n    sub_str2 = file_name[dot_index+1..$];\n    if(sub_str.length == 0 || (sub_str[0] < 'a' || sub_str[0] > 'z') && (sub_str[0] < 'A' || sub_str[0] > 'Z'))\n    {\n        return \"No\";\n    }\n    if(valid_extensions.canFind(sub_str2) == false)\n    {\n        return \"No\";\n    }\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp9ch0g6p2.d(37): Error: cannot implicitly convert expression `i` of type `ulong` to `int`\n/tmp/tmp9ch0g6p2.d(50): Error: no property `canFind` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9ch0g6p2.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164540
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n    string[] file_name_parts = file_name.split(\".\");\n    if (file_name_parts.length != 2)\n        return \"No\";\n    if (file_name_parts[0].count(\"0123456789\") > 3)\n        return \"No\";\n    if (file_name_parts[0].length == 0)\n        return \"No\";\n    if (file_name_parts[0][0] < 'a' || file_name_parts[0][0] > 'z')\n        return \"No\";\n    if (valid_extensions.find(file_name_parts[1]) == -1)\n        return \"No\";\n    return \"Yes\";\n}\n/*\nCreate a function which takes a string representing a file's name, and returns\n    the file's extension.\n    A file's extension is the substring after the last dot '.' in the file's name.\n    Examples:\n    >>> file_extension(\"example.txt\")\n    \"txt\"\n    >>> file_extension(\"example.exe\")\n    \"exe\"\n*/\nstring file_extension(string file_name) \n{\n    string[] file_name_parts = file_name.split(\".\");\n    return file_name_parts[file_name_parts.length - 1];\n}\n/*\nCreate a function which takes a string representing a file's name, and returns\n    the file's name without its extension.\n    The file's name without its extension is the substring before the last dot '.' \n    in the file's name.\n    Examples:\n    >>> file_name_without_extension(\"example.txt\")\n    \"example\"\n    >>> file_name_without_extension(\"example.exe\")\n    \"example\"\n*/\nstring file_name_without_extension(string file_name) \n{\n    string[] file_name_parts = file_name.split(\".\");\n    return file_name_parts[file_name_parts.length - 2];\n}\n/*\nCreate a function which takes a string representing a file's name, and returns\n    the file's\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp_id0ncyw.d(67): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_id0ncyw.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164540
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int count = 0;\n    int dot_index = 0;\n    int dot_count = 0;\n    string extension = \"\";\n    string name = \"\";\n    foreach(i, c; file_name)\n    {\n        if(isDigit(c))\n        {\n            count++;\n        }\n        if(c == '.')\n        {\n            dot_index = i;\n            dot_count++;\n        }\n    }\n    if(count > 3 || dot_count != 1)\n    {\n        return \"No\";\n    }\n    else\n    {\n        extension = file_name[dot_index+1..$];\n        name = file_name[0..dot_index-1];\n        if(extension != \"txt\" && extension != \"exe\" && extension != \"dll\")\n        {\n            return \"No\";\n        }\n        else if(name == \"\")\n        {\n            return \"No\";\n        }\n        else if(!isAlpha(name[0]))\n        {\n            return \"No\";\n        }\n        else\n        {\n            return \"Yes\";\n        }\n    }\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp88rcf14v.d(29): Error: undefined identifier `isDigit`\n/tmp/tmp88rcf14v.d(35): Error: cannot implicitly convert expression `i` of type `ulong` to `int`\n/tmp/tmp88rcf14v.d(55): Error: undefined identifier `isAlpha`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp88rcf14v.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164540
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n    auto dot_index = file_name.find(\".\");\n    if (dot_index == -1)\n        return \"No\";\n    auto extension = file_name[dot_index + 1 .. $];\n    if (extension.length == 0 || !valid_extensions.canFind(extension))\n        return \"No\";\n    auto name = file_name[0 .. dot_index];\n    if (name.length == 0 || !name[0].isAlpha)\n        return \"No\";\n    if (name.count!(c => c.isDigit) > 3)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp7hak2n88.d(23): Error: no property `find` for type `string`\n/tmp/tmp7hak2n88.d(27): Error: no property `canFind` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7hak2n88.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164540
    },
    {
      "exit_code": 0,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_count = 0;\n    int digit_count = 0;\n    int index = 0;\n    int dot_index = 0;\n    string extension = \"\";\n    string result = \"\";\n    foreach(c; file_name)\n    {\n        if(c == '.')\n        {\n            dot_count++;\n            dot_index = index;\n        }\n        if(c >= '0' && c <= '9')\n        {\n            digit_count++;\n        }\n        index++;\n    }\n    if(dot_count != 1)\n    {\n        return \"No\";\n    }\n    if(digit_count > 3)\n    {\n        return \"No\";\n    }\n    if(file_name[0] < 'a' || file_name[0] > 'z')\n    {\n        if(file_name[0] < 'A' || file_name[0] > 'Z')\n        {\n            return \"No\";\n        }\n    }\n    extension = file_name[dot_index+1..$];\n    if(extension == \"txt\" || extension == \"exe\" || extension == \"dll\")\n    {\n        return \"Yes\";\n    }\n    return \"No\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660164540
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n    string[] file_name_parts = file_name.split(\".\");\n    if (file_name_parts.length != 2)\n        return \"No\";\n    if (file_name_parts[0].length == 0)\n        return \"No\";\n    if (file_name_parts[0].count(\"0\") + file_name_parts[0].count(\"1\") + file_name_parts[0].count(\"2\") + file_name_parts[0].count(\"3\") + file_name_parts[0].count(\"4\") + file_name_parts[0].count(\"5\") + file_name_parts[0].count(\"6\") + file_name_parts[0].count(\"7\") + file_name_parts[0].count(\"8\") + file_name_parts[0].count(\"9\") > 3)\n        return \"No\";\n    if (file_name_parts[0][0] < 'a' || file_name_parts[0][0] > 'z')\n        return \"No\";\n    if (file_name_parts[1] != valid_extensions[0] && file_name_parts[1] != valid_extensions[1] && file_name_parts[1] != valid_extensions[2])\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpvapdpfka.d(23): Error: no property `split` for type `string`\n/tmp/tmpvapdpfka.d(28): Error: no property `count` for type `string`\n/tmp/tmpvapdpfka.d(28): Error: no property `count` for type `string`\n/tmp/tmpvapdpfka.d(28): Error: no property `count` for type `string`\n/tmp/tmpvapdpfka.d(28): Error: no property `count` for type `string`\n/tmp/tmpvapdpfka.d(28): Error: no property `count` for type `string`\n/tmp/tmpvapdpfka.d(28): Error: no property `count` for type `string`\n/tmp/tmpvapdpfka.d(28): Error: no property `count` for type `string`\n/tmp/tmpvapdpfka.d(28): Error: no property `count` for type `string`\n/tmp/tmpvapdpfka.d(28): Error: no property `count` for type `string`\n/tmp/tmpvapdpfka.d(28): Error: no property `count` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvapdpfka.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164540
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_index = file_name.find('.');\n    string extension = file_name.substr(dot_index + 1);\n    string name = file_name.substr(0, dot_index);\n    int digits = 0;\n    foreach(c; name)\n    {\n        if(c >= '0' && c <= '9')\n            digits++;\n    }\n    if(digits > 3)\n        return \"No\";\n    if(extension != \"txt\" && extension != \"exe\" && extension != \"dll\")\n        return \"No\";\n    if(name.length == 0)\n        return \"No\";\n    if(!(name[0] >= 'a' && name[0] <= 'z') && !(name[0] >= 'A' && name[0] <= 'Z'))\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpot6_vyv4.d(22): Error: no property `find` for type `string`\n/tmp/tmpot6_vyv4.d(23): Error: no property `substr` for type `string`\n/tmp/tmpot6_vyv4.d(24): Error: no property `substr` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpot6_vyv4.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164539
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int count = 0;\n    int dot = 0;\n    int dot_index = 0;\n    int dot_index_2 = 0;\n    int dot_index_3 = 0;\n    int dot_index_4 = 0;\n    int dot_index_5 = 0;\n    int dot_index_6 = 0;\n    int dot_index_7 = 0;\n    int dot_index_8 = 0;\n    int dot_index_9 = 0;\n    int dot_index_10 = 0;\n    int dot_index_11 = 0;\n    int dot_index_12 = 0;\n    int dot_index_13 = 0;\n    int dot_index_14 = 0;\n    int dot_index_15 = 0;\n    int dot_index_16 = 0;\n    int dot_index_17 = 0;\n    int dot_index_18 = 0;\n    int dot_index_19 = 0;\n    int dot_index_20 = 0;\n    int dot_index_21 = 0;\n    int dot_index_22 = 0;\n    int dot_index_23 = 0;\n    int dot_index_24 = 0;\n    int dot_index_25 = 0;\n    int dot_index_26 = 0;\n    int dot_index_27 = 0;\n    int dot_index_28 = 0;\n    int dot_index_29 = 0;\n    int dot_index_30 = 0;\n    int dot_index_31 = 0;\n    int dot_index_32 = 0;\n    int dot_index_33 = 0;\n    int dot_index_34 = 0;\n    int dot_index_35 = 0;\n    int dot_index_36 = 0;\n    int dot_index_37 = 0;\n    int dot_index_38 = 0;\n    int dot_index_39 = 0;\n    int dot_index_40 = 0;\n    int dot_index_41 = 0;\n    int dot_index_42 = 0;\n    int dot_index_43 = 0;\n    int dot_index_44 = 0;\n    int dot_index_45 = 0;\n    int\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp75vu4zqn.d(70): Error: no identifier for declarator `int`\n/tmp/tmp75vu4zqn.d(70): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp75vu4zqn.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164540
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_index = file_name.find(\".\");\n    string extension = file_name.substr(dot_index + 1);\n    string name = file_name.substr(0, dot_index);\n    int digits = 0;\n    foreach(c; name)\n    {\n        if(c >= '0' && c <= '9')\n            digits++;\n    }\n    if(digits > 3)\n        return \"No\";\n    if(extension != \"txt\" && extension != \"exe\" && extension != \"dll\")\n        return \"No\";\n    if(!(name[0] >= 'a' && name[0] <= 'z') && !(name[0] >= 'A' && name[0] <= 'Z'))\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpvbblnh51.d(22): Error: no property `find` for type `string`\n/tmp/tmpvbblnh51.d(23): Error: no property `substr` for type `string`\n/tmp/tmpvbblnh51.d(24): Error: no property `substr` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvbblnh51.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164540
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n    auto dot_index = file_name.find('.');\n    if (dot_index == -1)\n        return \"No\";\n    auto extension = file_name[dot_index+1..$];\n    if (extension.length == 0 || !valid_extensions.canFind(extension))\n        return \"No\";\n    auto name = file_name[0..dot_index];\n    if (name.length == 0 || !isAlpha(name[0]))\n        return \"No\";\n    if (name.count!(c => isDigit(c)) > 3)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp2kxof1sw.d(23): Error: no property `find` for type `string`\n/tmp/tmp2kxof1sw.d(27): Error: no property `canFind` for type `string[]`\n/tmp/tmp2kxof1sw.d(30): Error: undefined identifier `isAlpha`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2kxof1sw.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164540
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n    int dot_index = file_name.find('.');\n    if (dot_index == -1)\n        return \"No\";\n    string extension = file_name[dot_index + 1 .. $];\n    if (extension.length == 0 || !valid_extensions.canFind(extension))\n        return \"No\";\n    string name = file_name[0 .. dot_index];\n    if (name.length == 0 || !isAlpha(name[0]))\n        return \"No\";\n    int digit_count = 0;\n    foreach (c; name)\n        if (isDigit(c))\n            digit_count++;\n    if (digit_count > 3)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpc88q9ehv.d(23): Error: no property `find` for type `string`\n/tmp/tmpc88q9ehv.d(27): Error: no property `canFind` for type `string[]`\n/tmp/tmpc88q9ehv.d(30): Error: undefined identifier `isAlpha`\n/tmp/tmpc88q9ehv.d(34): Error: undefined identifier `isDigit`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpc88q9ehv.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164540
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n    string[] file_name_parts = file_name.split(\".\");\n    if (file_name_parts.length != 2)\n        return \"No\";\n    if (file_name_parts[0].length == 0)\n        return \"No\";\n    if (file_name_parts[0].count(\"0\", \"9\") > 3)\n        return \"No\";\n    if (file_name_parts[0][0] < 'a' || file_name_parts[0][0] > 'z')\n        return \"No\";\n    if (valid_extensions.find(file_name_parts[1]) == -1)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpxx14qb_t.d(23): Error: no property `split` for type `string`\n/tmp/tmpxx14qb_t.d(28): Error: no property `count` for type `string`\n/tmp/tmpxx14qb_t.d(32): Error: no property `find` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxx14qb_t.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164540
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_pos = file_name.find('.');\n    if (dot_pos == -1)\n        return \"No\";\n    string before_dot = file_name[0..dot_pos];\n    string after_dot = file_name[dot_pos+1..$];\n    if (before_dot.length == 0 || before_dot.length == dot_pos)\n        return \"No\";\n    if (after_dot != \"txt\" && after_dot != \"exe\" && after_dot != \"dll\")\n        return \"No\";\n    int num_digits = 0;\n    foreach (c; before_dot)\n    {\n        if (c >= '0' && c <= '9')\n            num_digits++;\n    }\n    if (num_digits > 3)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpbwjpwigi.d(22): Error: no property `find` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpbwjpwigi.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164540
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    auto dot_index = file_name.find('.');\n    if (dot_index == -1)\n        return \"No\";\n    if (dot_index == 0)\n        return \"No\";\n    if (dot_index == file_name.length - 1)\n        return \"No\";\n    string extension = file_name[dot_index+1..$];\n    if (extension != \"txt\" && extension != \"exe\" && extension != \"dll\")\n        return \"No\";\n    string name = file_name[0..dot_index-1];\n    if (name.length == 0)\n        return \"No\";\n    if (!isAlpha(name[0]))\n        return \"No\";\n    int num_digits = 0;\n    foreach (c; name)\n    {\n        if (isDigit(c))\n            num_digits++;\n    }\n    if (num_digits > 3)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpn1t21gp_.d(22): Error: no property `find` for type `string`\n/tmp/tmpn1t21gp_.d(35): Error: undefined identifier `isAlpha`\n/tmp/tmpn1t21gp_.d(40): Error: undefined identifier `isDigit`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpn1t21gp_.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164540
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int count = 0;\n    int dot_count = 0;\n    int dot_index = 0;\n    int len = file_name.length;\n    string sub1 = \"\";\n    string sub2 = \"\";\n    string[] valid_ext = [\"txt\", \"exe\", \"dll\"];\n    foreach(i; 0..len)\n    {\n        if(file_name[i] == '.')\n        {\n            dot_count++;\n            dot_index = i;\n        }\n        if(file_name[i] >= '0' && file_name[i] <= '9')\n        {\n            count++;\n        }\n    }\n    if(count > 3 || dot_count != 1)\n    {\n        return \"No\";\n    }\n    sub1 = file_name[0..dot_index];\n    sub2 = file_name[dot_index+1..len];\n    if(sub1.length == 0 || sub1[0] < 'a' || sub1[0] > 'z' || sub1[0] < 'A' || sub1[0] > 'Z')\n    {\n        return \"No\";\n    }\n    if(sub2 != valid_ext[0] && sub2 != valid_ext[1] && sub2 != valid_ext[2])\n    {\n        return \"No\";\n    }\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpvhuhn5ls.d(25): Error: cannot implicitly convert expression `file_name.length` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvhuhn5ls.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164540
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_pos = file_name.find('.');\n    if (dot_pos == -1)\n        return \"No\";\n    string ext = file_name.substr(dot_pos + 1);\n    if (ext != \"txt\" && ext != \"exe\" && ext != \"dll\")\n        return \"No\";\n    string name = file_name.substr(0, dot_pos);\n    if (name.length == 0)\n        return \"No\";\n    if (name[0] < 'a' || name[0] > 'z' && name[0] < 'A' || name[0] > 'Z')\n        return \"No\";\n    int num_digits = 0;\n    foreach (char c; name)\n    {\n        if (c >= '0' && c <= '9')\n            num_digits++;\n    }\n    if (num_digits > 3)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmptzizmpcf.d(22): Error: no property `find` for type `string`\n/tmp/tmptzizmpcf.d(25): Error: no property `substr` for type `string`\n/tmp/tmptzizmpcf.d(28): Error: no property `substr` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmptzizmpcf.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164540
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n    string[] file_name_parts = file_name.split(\".\");\n    if (file_name_parts.length != 2) return \"No\";\n    if (file_name_parts[0].length == 0) return \"No\";\n    if (file_name_parts[0].count(\"0-9\") > 3) return \"No\";\n    if (!valid_extensions.contains(file_name_parts[1])) return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpzgh012o8.d(23): Error: no property `split` for type `string`\n/tmp/tmpzgh012o8.d(26): Error: no property `count` for type `string`\n/tmp/tmpzgh012o8.d(27): Error: no property `contains` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpzgh012o8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164540
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    // TODO: Implement me\n    int dot_count = 0;\n    int digit_count = 0;\n    int i = 0;\n    int len = file_name.length;\n    if (len <= 0)\n        return \"No\";\n    for (i = 0; i < len; i++)\n    {\n        if (file_name[i] == '.')\n        {\n            dot_count++;\n            if (dot_count > 1)\n                return \"No\";\n        }\n        else if (file_name[i] >= '0' && file_name[i] <= '9')\n        {\n            digit_count++;\n            if (digit_count > 3)\n                return \"No\";\n        }\n    }\n    if (dot_count != 1)\n        return \"No\";\n    string[] str_arr = file_name.split(\".\");\n    if (str_arr.length != 2)\n        return \"No\";\n    if (str_arr[0].length <= 0)\n        return \"No\";\n    if (str_arr[0][0] < 'a' || str_arr[0][0] > 'z')\n        return \"No\";\n    if (str_arr[1] != \"txt\" && str_arr[1] != \"exe\" && str_arr[1] != \"dll\")\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp_7qfj4r_.d(26): Error: cannot implicitly convert expression `file_name.length` of type `ulong` to `int`\n/tmp/tmp_7qfj4r_.d(46): Error: no property `split` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_7qfj4r_.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164540
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n    string[] file_name_split = file_name.split(\".\");\n    if (file_name_split.length != 2)\n        return \"No\";\n    if (file_name_split[0].length == 0)\n        return \"No\";\n    if (!(file_name_split[0][0] >= 'a' && file_name_split[0][0] <= 'z') &&\n        !(file_name_split[0][0] >= 'A' && file_name_split[0][0] <= 'Z'))\n        return \"No\";\n    if (file_name_split[0].count(\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\") > 3)\n        return \"No\";\n    if (!valid_extensions.contains(file_name_split[1]))\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpvbo_gjbf.d(23): Error: no property `split` for type `string`\n/tmp/tmpvbo_gjbf.d(31): Error: no property `count` for type `string`\n/tmp/tmpvbo_gjbf.d(33): Error: no property `contains` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvbo_gjbf.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164540
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int count = 0;\n    int dot = 0;\n    int dot_index = 0;\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int A = 0;\n    int B = 0;\n    int C = 0;\n    int D = 0;\n    int E = 0;\n    int F = 0;\n    int G = 0;\n    int H = 0;\n    int I = 0;\n    int J = 0;\n    int K = 0;\n    int L = 0;\n    int M = 0;\n    int N = 0;\n    int O = 0;\n    int P = 0;\n    int Q = 0;\n    int R = 0;\n    int S = 0;\n    int T = 0;\n    int U = 0;\n    int V = 0;\n    int W = 0;\n    int X = 0;\n    int Y = 0;\n    int Z = 0;\n    int zero = 0;\n    int one = 0;\n    int two = 0;\n    int three = 0;\n    int four = 0;\n    int five = 0;\n    int six = 0;\n    int seven = 0;\n    int eight = 0;\n    int nine = 0;\n    foreach(char c; file_name)\n    {\n        if(c == '.')\n        {\n            dot++;\n            dot_index = i;\n        }\n        if(c == '0')\n        {\n            zero++;\n        }\n        if(c == '1')\n        {\n            one++;\n        }\n        if(c == '2')\n        {\n            two++;\n        }\n        if(c == '3')\n\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpgk3hw00b.d(100): Error: found `unittest` instead of statement\n/tmp/tmpgk3hw00b.d(131): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpgk3hw00b.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164540
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_index = file_name.find('.');\n    string extension = file_name.substr(dot_index+1);\n    string name = file_name.substr(0, dot_index);\n    int digits = 0;\n    foreach(c; name)\n    {\n        if(c >= '0' && c <= '9')\n            digits++;\n    }\n    if(digits > 3)\n        return \"No\";\n    if(extension != \"txt\" && extension != \"exe\" && extension != \"dll\")\n        return \"No\";\n    if(name.length == 0)\n        return \"No\";\n    if(!(name[0] >= 'a' && name[0] <= 'z') && !(name[0] >= 'A' && name[0] <= 'Z'))\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpfdp9aqdf.d(22): Error: no property `find` for type `string`\n/tmp/tmpfdp9aqdf.d(23): Error: no property `substr` for type `string`\n/tmp/tmpfdp9aqdf.d(24): Error: no property `substr` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfdp9aqdf.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164540
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_count = 0;\n    int digit_count = 0;\n    int letter_count = 0;\n    string extension = \"\";\n    string name = \"\";\n    foreach(char c; file_name)\n    {\n        if(c == '.')\n        {\n            dot_count++;\n            extension = file_name[$-3..$];\n        }\n        else if(c >= '0' && c <= '9')\n        {\n            digit_count++;\n        }\n        else if((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z'))\n        {\n            letter_count++;\n        }\n    }\n    if(dot_count != 1 || digit_count > 3 || letter_count == 0)\n    {\n        return \"No\";\n    }\n    else if(extension != \"txt\" && extension != \"exe\" && extension != \"dll\")\n    {\n        return \"No\";\n    }\n    else\n    {\n        return \"Yes\";\n    }\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp1m7co1zy.d(61): unittest failure\n----------------\n??:? _d_unittestp [0x42876d]\n??:? void tmp1m7co1zy.__unittest_L56_C1() [0x427cd8]\n??:? void tmp1m7co1zy.__modtest() [0x4284f0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c48b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b39a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4304b1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430960]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43043d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b371]\n??:? runModuleUnitTests [0x42c261]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428c30]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164540
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n    string[] file_name_parts = file_name.split(\".\");\n    if (file_name_parts.length != 2)\n        return \"No\";\n    if (file_name_parts[0].length == 0)\n        return \"No\";\n    if (file_name_parts[0].count(\"0-9\") > 3)\n        return \"No\";\n    if (file_name_parts[0][0] < 'a' || file_name_parts[0][0] > 'z')\n        return \"No\";\n    if (valid_extensions.find(file_name_parts[1]) == -1)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpeucb9ob2.d(23): Error: no property `split` for type `string`\n/tmp/tmpeucb9ob2.d(28): Error: no property `count` for type `string`\n/tmp/tmpeucb9ob2.d(32): Error: no property `find` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpeucb9ob2.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164539
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int count = 0;\n    int dot_count = 0;\n    int dot_index = 0;\n    int dot_index_2 = 0;\n    int dot_index_3 = 0;\n    int dot_index_4 = 0;\n    int dot_index_5 = 0;\n    int dot_index_6 = 0;\n    int dot_index_7 = 0;\n    int dot_index_8 = 0;\n    int dot_index_9 = 0;\n    int dot_index_10 = 0;\n    int dot_index_11 = 0;\n    int dot_index_12 = 0;\n    int dot_index_13 = 0;\n    int dot_index_14 = 0;\n    int dot_index_15 = 0;\n    int dot_index_16 = 0;\n    int dot_index_17 = 0;\n    int dot_index_18 = 0;\n    int dot_index_19 = 0;\n    int dot_index_20 = 0;\n    int dot_index_21 = 0;\n    int dot_index_22 = 0;\n    int dot_index_23 = 0;\n    int dot_index_24 = 0;\n    int dot_index_25 = 0;\n    int dot_index_26 = 0;\n    int dot_index_27 = 0;\n    int dot_index_28 = 0;\n    int dot_index_29 = 0;\n    int dot_index_30 = 0;\n    int dot_index_31 = 0;\n    int dot_index_32 = 0;\n    int dot_index_33 = 0;\n    int dot_index_34 = 0;\n    int dot_index_35 = 0;\n    int dot_index_36 = 0;\n    int dot_index_37 = 0;\n    int dot_index_38 = 0;\n    int dot_index_39 = 0;\n    int dot_index_40 = 0;\n    int dot_index_41 = 0;\n    int dot_index_42 = 0;\n    int dot_index_43 = 0;\n    int dot_index_44 = 0;\n    int dot_index_45 = 0;\n\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpzdo5rat1.d(70): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpzdo5rat1.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164540
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n    int dot_index = file_name.find(\".\");\n    if (dot_index == -1)\n        return \"No\";\n    string extension = file_name[dot_index + 1 .. $];\n    if (extension.length == 0 || !valid_extensions.canFind(extension))\n        return \"No\";\n    string file_name_without_extension = file_name[0 .. dot_index - 1];\n    if (file_name_without_extension.length == 0)\n        return \"No\";\n    if (file_name_without_extension[0] < 'a' || file_name_without_extension[0] > 'z')\n        return \"No\";\n    int digit_count = 0;\n    foreach (i, c; file_name_without_extension)\n    {\n        if (c >= '0' && c <= '9')\n            digit_count++;\n    }\n    if (digit_count > 3)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpoeyoaep1.d(23): Error: no property `find` for type `string`\n/tmp/tmpoeyoaep1.d(27): Error: no property `canFind` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpoeyoaep1.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164540
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n    int dot_index = file_name.find('.');\n    string extension = file_name.substr(dot_index + 1);\n    string name = file_name.substr(0, dot_index);\n    int digits_count = 0;\n    foreach(c; name)\n    {\n        if(c >= '0' && c <= '9')\n            digits_count++;\n    }\n    if(digits_count > 3 || dot_index == -1 || name.length == 0 || name[0] < 'A' || name[0] > 'z' || !valid_extensions.contains(extension))\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp5mn6knca.d(23): Error: no property `find` for type `string`\n/tmp/tmp5mn6knca.d(24): Error: no property `substr` for type `string`\n/tmp/tmp5mn6knca.d(25): Error: no property `substr` for type `string`\n/tmp/tmp5mn6knca.d(32): Error: no property `contains` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5mn6knca.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164540
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_pos = file_name.find(\".\");\n    if (dot_pos == -1)\n        return \"No\";\n    string prefix = file_name[0..dot_pos];\n    string suffix = file_name[dot_pos+1..$];\n    if (prefix.length == 0)\n        return \"No\";\n    if (prefix.count(\"0123456789\") > 3)\n        return \"No\";\n    if (suffix != \"txt\" && suffix != \"exe\" && suffix != \"dll\")\n        return \"No\";\n    if (!isAlpha(prefix[0]))\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpcnejei95.d(22): Error: no property `find` for type `string`\n/tmp/tmpcnejei95.d(29): Error: no property `count` for type `string`\n/tmp/tmpcnejei95.d(33): Error: undefined identifier `isAlpha`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcnejei95.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164540
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n    int dot_index = file_name.find('.');\n    string extension = file_name.substr(dot_index + 1);\n    string name = file_name.substr(0, dot_index);\n    int digits_count = 0;\n    foreach(c; name)\n    {\n        if(c >= '0' && c <= '9')\n            digits_count++;\n    }\n    if(digits_count > 3 || dot_index == -1 || name.length == 0 || !(name[0] >= 'a' && name[0] <= 'z' || name[0] >= 'A' && name[0] <= 'Z'))\n        return \"No\";\n    foreach(ext; valid_extensions)\n    {\n        if(ext == extension)\n            return \"Yes\";\n    }\n    return \"No\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmphnq__6me.d(23): Error: no property `find` for type `string`\n/tmp/tmphnq__6me.d(24): Error: no property `substr` for type `string`\n/tmp/tmphnq__6me.d(25): Error: no property `substr` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphnq__6me.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164539
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_pos = file_name.find('.');\n    if (dot_pos == -1)\n        return \"No\";\n    string before_dot = file_name[0..dot_pos];\n    string after_dot = file_name[dot_pos+1..$];\n    if (before_dot.length == 0 || before_dot.length > 8)\n        return \"No\";\n    if (after_dot != \"txt\" && after_dot != \"exe\" && after_dot != \"dll\")\n        return \"No\";\n    if (before_dot.count!(c => c >= '0' && c <= '9') > 3)\n        return \"No\";\n    if (!(before_dot[0] >= 'a' && before_dot[0] <= 'z' || before_dot[0] >= 'A' && before_dot[0] <= 'Z'))\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp2g11p5jo.d(22): Error: no property `find` for type `string`\n/tmp/tmp2g11p5jo.d(31): Error: no property `count` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2g11p5jo.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164540
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n    int dot_index = file_name.find('.');\n    if (dot_index == -1)\n        return \"No\";\n    string extension = file_name[dot_index + 1 .. $];\n    if (extension.length == 0 || !valid_extensions.canFind(extension))\n        return \"No\";\n    string name = file_name[0 .. dot_index];\n    if (name.length == 0 || !isAlpha(name[0]))\n        return \"No\";\n    int digit_count = 0;\n    foreach (c; name)\n        if (isDigit(c))\n            digit_count++;\n    if (digit_count > 3)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpc88q9ehv.d(23): Error: no property `find` for type `string`\n/tmp/tmpc88q9ehv.d(27): Error: no property `canFind` for type `string[]`\n/tmp/tmpc88q9ehv.d(30): Error: undefined identifier `isAlpha`\n/tmp/tmpc88q9ehv.d(34): Error: undefined identifier `isDigit`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpc88q9ehv.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164540
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_pos = file_name.find('.');\n    if (dot_pos == -1)\n        return \"No\";\n    string before_dot = file_name[0..dot_pos];\n    string after_dot = file_name[dot_pos+1..$];\n    if (before_dot.length == 0 || before_dot.length > 8)\n        return \"No\";\n    if (after_dot != \"txt\" && after_dot != \"exe\" && after_dot != \"dll\")\n        return \"No\";\n    if (before_dot.count!(a => a.isDigit) > 3)\n        return \"No\";\n    if (!before_dot[0].isLetter)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmptfhggzlc.d(22): Error: no property `find` for type `string`\n/tmp/tmptfhggzlc.d(31): Error: no property `count` for type `string`\n/tmp/tmptfhggzlc.d(33): Error: no property `isLetter` for type `immutable(char)`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmptfhggzlc.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164540
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    import std.algorithm;\n    import std.array;\n    import std.conv;\n    import std.range;\n    import std.string;\n    import std.typecons;\n    import std.math;\n    import std.regex;\n    import std.stdio;\n    import std.typecons;\n    import std.math;\n    import std.regex;\n    import std.stdio;\n    import std.typecons;\n    import std.math;\n    import std.regex;\n    import std.stdio;\n    import std.typecons;\n    import std.math;\n    import std.regex;\n    import std.stdio;\n    import std.typecons;\n    import std.math;\n    import std.regex;\n    import std.stdio;\n    import std.typecons;\n    import std.math;\n    import std.regex;\n    import std.stdio;\n    import std.typecons;\n    import std.math;\n    import std.regex;\n    import std.stdio;\n    import std.typecons;\n    import std.math;\n    import std.regex;\n    import std.stdio;\n    import std.typecons;\n    import std.math;\n    import std.regex;\n    import std.stdio;\n    import std.typecons;\n    import std.math;\n    import std.regex;\n    import std.stdio;\n    import std.typecons;\n    import std.math;\n    import std.regex;\n    import std.stdio;\n    import std.typecons;\n    import std.math;\n    import std.regex;\n    import std.stdio;\n    import std.typecons;\n    import std.math;\n    import std.regex;\n    import std.stdio;\n    import std.typecons;\n    import std.math;\n    import std.regex;\n    import std.stdio;\n    import std.typecons;\n    import std.math;\n    import std.regex;\n    import std.stdio;\n    import std.typecons;\n\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp7kl_8ff3.d(89): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7kl_8ff3.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164540
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_index = file_name.find('.');\n    if (dot_index == -1)\n        return \"No\";\n    string before_dot = file_name[0..dot_index];\n    string after_dot = file_name[dot_index+1..$];\n    if (before_dot.length == 0 || before_dot.length > 8)\n        return \"No\";\n    if (after_dot.length == 0 || after_dot.length > 3)\n        return \"No\";\n    if (after_dot != \"txt\" && after_dot != \"exe\" && after_dot != \"dll\")\n        return \"No\";\n    if (before_dot.count!(a => a >= '0' && a <= '9') > 3)\n        return \"No\";\n    if (!(before_dot[0] >= 'a' && before_dot[0] <= 'z') && !(before_dot[0] >= 'A' && before_dot[0] <= 'Z'))\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpp_rbaskb.d(22): Error: no property `find` for type `string`\n/tmp/tmpp_rbaskb.d(33): Error: no property `count` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpp_rbaskb.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164540
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int count = 0;\n    int dot_count = 0;\n    int i = 0;\n    string extension = \"\";\n    string name = \"\";\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n    foreach(char c; file_name)\n    {\n        if(isDigit(c))\n        {\n            count++;\n        }\n        if(c == '.')\n        {\n            dot_count++;\n        }\n    }\n    if(count > 3 || dot_count != 1)\n    {\n        return \"No\";\n    }\n    foreach(char c; file_name)\n    {\n        if(c == '.')\n        {\n            break;\n        }\n        name ~= c;\n        i++;\n    }\n    if(name.length == 0 || !isAlpha(name[0]))\n    {\n        return \"No\";\n    }\n    for(int j = i + 1; j < file_name.length; j++)\n    {\n        extension ~= file_name[j];\n    }\n    if(!valid_extensions.contains(extension))\n    {\n        return \"No\";\n    }\n    return \"Yes\";\n}\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpp60zry90.d(84): Error: semicolon expected, not `unittest`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpp60zry90.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164540
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n    int dot_index = file_name.find('.');\n    if (dot_index == -1)\n        return \"No\";\n    string extension = file_name[dot_index + 1 .. $];\n    if (extension.length == 0 || !valid_extensions.canFind(extension))\n        return \"No\";\n    string name = file_name[0 .. dot_index];\n    if (name.length == 0 || !isAlpha(name[0]))\n        return \"No\";\n    int digits_count = 0;\n    foreach (c; name)\n        if (isDigit(c))\n            digits_count++;\n    if (digits_count > 3)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpfifzj99a.d(23): Error: no property `find` for type `string`\n/tmp/tmpfifzj99a.d(27): Error: no property `canFind` for type `string[]`\n/tmp/tmpfifzj99a.d(30): Error: undefined identifier `isAlpha`\n/tmp/tmpfifzj99a.d(34): Error: undefined identifier `isDigit`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfifzj99a.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164540
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n    string[] splitted_file_name = file_name.split(\".\");\n    if (splitted_file_name.length != 2)\n        return \"No\";\n    if (splitted_file_name[0].length == 0)\n        return \"No\";\n    if (splitted_file_name[0].count(\"0\", \"9\") > 3)\n        return \"No\";\n    if (!valid_extensions.canFind(splitted_file_name[1]))\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpyj2ji5kx.d(23): Error: no property `split` for type `string`\n/tmp/tmpyj2ji5kx.d(28): Error: no property `count` for type `string`\n/tmp/tmpyj2ji5kx.d(30): Error: no property `canFind` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpyj2ji5kx.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164540
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_pos = file_name.find('.');\n    string file_name_without_ext = file_name.substr(0, dot_pos);\n    string file_ext = file_name.substr(dot_pos + 1);\n    if (file_name_without_ext.length == 0)\n        return \"No\";\n    if (file_name_without_ext.length > 3)\n        return \"No\";\n    if (file_ext != \"txt\" && file_ext != \"exe\" && file_ext != \"dll\")\n        return \"No\";\n    if (file_name_without_ext.find('0') != -1 ||\n        file_name_without_ext.find('1') != -1 ||\n        file_name_without_ext.find('2') != -1 ||\n        file_name_without_ext.find('3') != -1 ||\n        file_name_without_ext.find('4') != -1 ||\n        file_name_without_ext.find('5') != -1 ||\n        file_name_without_ext.find('6') != -1 ||\n        file_name_without_ext.find('7') != -1 ||\n        file_name_without_ext.find('8') != -1 ||\n        file_name_without_ext.find('9') != -1)\n        return \"No\";\n    if (file_name_without_ext.find('a') == -1 &&\n        file_name_without_ext.find('b') == -1 &&\n        file_name_without_ext.find('c') == -1 &&\n        file_name_without_ext.find('d') == -1 &&\n        file_name_without_ext.find('e') == -1 &&\n        file_name_without_ext.find('f') == -1 &&\n        file_name_without_ext.find('g') == -1 &&\n        file_name_without_ext.find('h') == -1 &&\n        file_name_without_ext.find('i') == -1 &&\n        file_name_without_ext.find('j') == -1 &&\n        file_\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpbp45uo51.d(53): Error: found `unittest` when expecting `)`\n/tmp/tmpbp45uo51.d(84): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpbp45uo51.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164540
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n    int dot_index = file_name.indexOf('.');\n    if (dot_index == -1)\n        return \"No\";\n    string extension = file_name.substr(dot_index + 1);\n    if (valid_extensions.indexOf(extension) == -1)\n        return \"No\";\n    string name = file_name.substr(0, dot_index);\n    if (name.length == 0)\n        return \"No\";\n    if (name[0] < 'a' || name[0] > 'z' && name[0] < 'A' || name[0] > 'Z')\n        return \"No\";\n    int digit_count = 0;\n    foreach (c; name)\n        if (c >= '0' && c <= '9')\n            digit_count++;\n    if (digit_count > 3)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpoe1jvoxb.d(23): Error: no property `indexOf` for type `string`\n/tmp/tmpoe1jvoxb.d(26): Error: no property `substr` for type `string`\n/tmp/tmpoe1jvoxb.d(27): Error: no property `indexOf` for type `string[]`\n/tmp/tmpoe1jvoxb.d(29): Error: no property `substr` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpoe1jvoxb.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164540
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_index = file_name.find('.');\n    string extension = file_name.substr(dot_index + 1);\n    string name = file_name.substr(0, dot_index);\n    int digits = 0;\n    foreach(char c; name)\n    {\n        if(c >= '0' && c <= '9')\n            digits++;\n    }\n    if(digits > 3)\n        return \"No\";\n    if(extension != \"txt\" && extension != \"exe\" && extension != \"dll\")\n        return \"No\";\n    if(name.length == 0)\n        return \"No\";\n    if(name[0] < 'a' || name[0] > 'z' && name[0] < 'A' || name[0] > 'Z')\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpqck99rn6.d(22): Error: no property `find` for type `string`\n/tmp/tmpqck99rn6.d(23): Error: no property `substr` for type `string`\n/tmp/tmpqck99rn6.d(24): Error: no property `substr` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqck99rn6.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164540
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n    int dot_index = file_name.find(\".\");\n    string extension = file_name[dot_index+1..$];\n    string name = file_name[0..dot_index-1];\n    int digits_count = 0;\n    foreach(c; name)\n    {\n        if(c >= '0' && c <= '9')\n            digits_count++;\n    }\n    if(digits_count > 3)\n        return \"No\";\n    if(!(name[0] >= 'a' && name[0] <= 'z') && !(name[0] >= 'A' && name[0] <= 'Z'))\n        return \"No\";\n    if(!valid_extensions.canFind(extension))\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp4yv6vbfn.d(23): Error: no property `find` for type `string`\n/tmp/tmp4yv6vbfn.d(36): Error: no property `canFind` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4yv6vbfn.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164540
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int count = 0;\n    int dot_count = 0;\n    int dot_index = 0;\n    int extension_index = 0;\n    string extension = \"\";\n    string file_name_without_extension = \"\";\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n    foreach(char c; file_name)\n    {\n        if(c == '.')\n        {\n            dot_count++;\n            dot_index = count;\n        }\n        count++;\n    }\n    if(dot_count != 1)\n    {\n        return \"No\";\n    }\n    extension_index = dot_index + 1;\n    extension = file_name[extension_index..$];\n    if(extension !in valid_extensions)\n    {\n        return \"No\";\n    }\n    file_name_without_extension = file_name[0..dot_index-1];\n    if(file_name_without_extension.length == 0)\n    {\n        return \"No\";\n    }\n    if(!isAlpha(file_name_without_extension[0]))\n    {\n        return \"No\";\n    }\n    foreach(char c; file_name_without_extension)\n    {\n        if(isDigit(c))\n        {\n            return \"No\";\n        }\n    }\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp5h785_qv.d(44): Error: incompatible types for `(extension) in (valid_extensions)`: `string` and `string[]`\n/tmp/tmp5h785_qv.d(53): Error: undefined identifier `isAlpha`\n/tmp/tmp5h785_qv.d(59): Error: undefined identifier `isDigit`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5h785_qv.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164540
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_position = file_name.find('.');\n    string extension = file_name.substr(dot_position+1);\n    string name = file_name.substr(0, dot_position);\n    int digit_count = 0;\n    foreach(char c; name)\n    {\n        if(c >= '0' && c <= '9')\n            digit_count++;\n    }\n    if(digit_count > 3)\n        return \"No\";\n    if(extension != \"txt\" && extension != \"exe\" && extension != \"dll\")\n        return \"No\";\n    if(name.length == 0)\n        return \"No\";\n    if(!(name[0] >= 'a' && name[0] <= 'z') && !(name[0] >= 'A' && name[0] <= 'Z'))\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpiftb0wds.d(22): Error: no property `find` for type `string`\n/tmp/tmpiftb0wds.d(23): Error: no property `substr` for type `string`\n/tmp/tmpiftb0wds.d(24): Error: no property `substr` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpiftb0wds.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164540
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_index = file_name.find('.');\n    string file_name_without_extension = file_name.substr(0, dot_index);\n    string file_name_extension = file_name.substr(dot_index + 1);\n    int digits_count = 0;\n    foreach(char c; file_name_without_extension)\n    {\n        if(c >= '0' && c <= '9')\n        {\n            digits_count++;\n        }\n    }\n    if(digits_count > 3)\n    {\n        return \"No\";\n    }\n    if(file_name_without_extension.length == 0)\n    {\n        return \"No\";\n    }\n    if(!(file_name_without_extension[0] >= 'a' && file_name_without_extension[0] <= 'z') &&\n        !(file_name_without_extension[0] >= 'A' && file_name_without_extension[0] <= 'Z'))\n    {\n        return \"No\";\n    }\n    if(file_name_extension != \"txt\" && file_name_extension != \"exe\" && file_name_extension != \"dll\")\n    {\n        return \"No\";\n    }\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmplow3y2qi.d(22): Error: no property `find` for type `string`\n/tmp/tmplow3y2qi.d(23): Error: no property `substr` for type `string`\n/tmp/tmplow3y2qi.d(24): Error: no property `substr` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmplow3y2qi.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164540
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n    string[] file_name_parts = file_name.split(\".\");\n    if (file_name_parts.length != 2) return \"No\";\n    if (file_name_parts[0].length == 0) return \"No\";\n    if (file_name_parts[0].count(\"0-9\") > 3) return \"No\";\n    if (!valid_extensions.contains(file_name_parts[1])) return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpzgh012o8.d(23): Error: no property `split` for type `string`\n/tmp/tmpzgh012o8.d(26): Error: no property `count` for type `string`\n/tmp/tmpzgh012o8.d(27): Error: no property `contains` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpzgh012o8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164540
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n    string[] file_name_parts = split(file_name, \".\");\n    if (file_name_parts.length != 2)\n        return \"No\";\n    if (file_name_parts[0].length == 0)\n        return \"No\";\n    if (file_name_parts[0].length > 3)\n        return \"No\";\n    if (file_name_parts[0].length == 3)\n    {\n        if (file_name_parts[0].count(\"0\") + file_name_parts[0].count(\"1\") + \n            file_name_parts[0].count(\"2\") + file_name_parts[0].count(\"3\") + \n            file_name_parts[0].count(\"4\") + file_name_parts[0].count(\"5\") + \n            file_name_parts[0].count(\"6\") + file_name_parts[0].count(\"7\") + \n            file_name_parts[0].count(\"8\") + file_name_parts[0].count(\"9\") != 3)\n            return \"No\";\n    }\n    if (file_name_parts[0].length == 2)\n    {\n        if (file_name_parts[0].count(\"0\") + file_name_parts[0].count(\"1\") + \n            file_name_parts[0].count(\"2\") + file_name_parts[0].count(\"3\") + \n            file_name_parts[0].count(\"4\") + file_name_parts[0].count(\"5\") + \n            file_name_parts[0].count(\"6\") + file_name_parts[0].count(\"7\") + \n            file_name_parts[0].count(\"8\") + file_name_parts[0].count(\"9\") != 2)\n            return \"No\";\n    }\n    if (file_name_parts[0].length == 1)\n    {\n        if (file_name_parts[0].count(\"0\") + file_name_parts[0].count(\"1\") + \n            file_name_\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmptbcjf0_5.d(52): Error: found `unittest` when expecting `)`\n/tmp/tmptbcjf0_5.d(83): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmptbcjf0_5.d(83): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmptbcjf0_5.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164540
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_pos = file_name.find('.');\n    if (dot_pos == -1)\n        return \"No\";\n    string before_dot = file_name[0..dot_pos];\n    string after_dot = file_name[dot_pos+1..$];\n    if (before_dot.length == 0 || before_dot.length == dot_pos)\n        return \"No\";\n    if (after_dot != \"txt\" && after_dot != \"exe\" && after_dot != \"dll\")\n        return \"No\";\n    if (before_dot.count('0','9') > 3)\n        return \"No\";\n    if (before_dot[0] < 'a' || before_dot[0] > 'z' || before_dot[0] < 'A' || before_dot[0] > 'Z')\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpe4jitg83.d(22): Error: no property `find` for type `string`\n/tmp/tmpe4jitg83.d(31): Error: no property `count` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpe4jitg83.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164540
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n    int dot_index = file_name.find(\".\");\n    string extension = file_name[dot_index+1..$];\n    string name = file_name[0..dot_index-1];\n    int digits_count = 0;\n    foreach(c; name)\n    {\n        if(c.isDigit)\n            digits_count++;\n    }\n    if(digits_count > 3)\n        return \"No\";\n    if(!name.length)\n        return \"No\";\n    if(!name[0].isLetter)\n        return \"No\";\n    if(!valid_extensions.canFind(extension))\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp5ta7wxfb.d(23): Error: no property `find` for type `string`\n/tmp/tmp5ta7wxfb.d(29): Error: no property `isDigit` for type `immutable(char)`\n/tmp/tmp5ta7wxfb.d(36): Error: no property `isLetter` for type `immutable(char)`\n/tmp/tmp5ta7wxfb.d(38): Error: no property `canFind` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5ta7wxfb.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164540
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_index = file_name.find(\".\");\n    if (dot_index == -1)\n        return \"No\";\n    string before_dot = file_name[0..dot_index];\n    string after_dot = file_name[dot_index+1..$];\n    if (before_dot.length == 0 || before_dot.length > 8)\n        return \"No\";\n    if (after_dot != \"txt\" && after_dot != \"exe\" && after_dot != \"dll\")\n        return \"No\";\n    int digit_count = 0;\n    foreach (c; before_dot)\n    {\n        if (c >= '0' && c <= '9')\n            digit_count++;\n        else if (!(c >= 'a' && c <= 'z') && !(c >= 'A' && c <= 'Z'))\n            return \"No\";\n    }\n    if (digit_count > 3)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpcag73rfn.d(22): Error: no property `find` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcag73rfn.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164540
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int count = 0;\n    int dot_count = 0;\n    int dot_index = 0;\n    string extension = \"\";\n    string name = \"\";\n    foreach(char c; file_name)\n    {\n        if(c == '.')\n        {\n            dot_count++;\n            dot_index = count;\n        }\n        count++;\n    }\n    if(dot_count != 1)\n    {\n        return \"No\";\n    }\n    extension = file_name[dot_index+1..$];\n    if(extension != \"txt\" && extension != \"exe\" && extension != \"dll\")\n    {\n        return \"No\";\n    }\n    name = file_name[0..dot_index-1];\n    if(name.length == 0)\n    {\n        return \"No\";\n    }\n    if(name[0] < 'a' || name[0] > 'z' && name[0] < 'A' || name[0] > 'Z')\n    {\n        return \"No\";\n    }\n    foreach(char c; name)\n    {\n        if(c < '0' || c > '9')\n        {\n            return \"No\";\n        }\n    }\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpc9fwnf69.d(67): unittest failure\n----------------\n??:? _d_unittestp [0x42889d]\n??:? void tmpc9fwnf69.__unittest_L63_C1() [0x427da9]\n??:? void tmpc9fwnf69.__modtest() [0x428620]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c5bb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b4ca]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4305e1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430a90]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43056d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b4a1]\n??:? runModuleUnitTests [0x42c391]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428d60]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164540
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    auto dot_pos = file_name.find('.');\n    if (dot_pos == -1)\n        return \"No\";\n    auto ext = file_name.substr(dot_pos + 1);\n    if (ext != \"txt\" && ext != \"exe\" && ext != \"dll\")\n        return \"No\";\n    auto name = file_name.substr(0, dot_pos);\n    if (name.length == 0)\n        return \"No\";\n    if (!isAlpha(name[0]))\n        return \"No\";\n    if (name.count!(a => a >= '0' && a <= '9') > 3)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpy65gkhb4.d(22): Error: no property `find` for type `string`\n/tmp/tmpy65gkhb4.d(25): Error: no property `substr` for type `string`\n/tmp/tmpy65gkhb4.d(28): Error: no property `substr` for type `string`\n/tmp/tmpy65gkhb4.d(31): Error: undefined identifier `isAlpha`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpy65gkhb4.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164540
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_index = file_name.find('.');\n    string extension = file_name.substr(dot_index + 1);\n    string name = file_name.substr(0, dot_index);\n    int digits = 0;\n    foreach(char c; name)\n    {\n        if(c >= '0' && c <= '9')\n            digits++;\n    }\n    if(digits > 3)\n        return \"No\";\n    if(extension != \"txt\" && extension != \"exe\" && extension != \"dll\")\n        return \"No\";\n    if(name.length == 0)\n        return \"No\";\n    if(!(name[0] >= 'a' && name[0] <= 'z') && !(name[0] >= 'A' && name[0] <= 'Z'))\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp_kk64oag.d(22): Error: no property `find` for type `string`\n/tmp/tmp_kk64oag.d(23): Error: no property `substr` for type `string`\n/tmp/tmp_kk64oag.d(24): Error: no property `substr` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_kk64oag.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164540
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int count = 0;\n    int dot_index = 0;\n    string extension = \"\";\n    string name = \"\";\n    foreach(i, c; file_name)\n    {\n        if(c == '.')\n        {\n            dot_index = i;\n            break;\n        }\n    }\n    name = file_name[0..dot_index];\n    extension = file_name[dot_index+1..$];\n    foreach(c; name)\n    {\n        if(c >= '0' && c <= '9')\n        {\n            count++;\n        }\n    }\n    if(count > 3)\n    {\n        return \"No\";\n    }\n    if(!(name[0] >= 'a' && name[0] <= 'z') && !(name[0] >= 'A' && name[0] <= 'Z'))\n    {\n        return \"No\";\n    }\n    if(extension != \"txt\" && extension != \"exe\" && extension != \"dll\")\n    {\n        return \"No\";\n    }\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpl1bw_lfd.d(30): Error: cannot implicitly convert expression `i` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpl1bw_lfd.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164540
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n    int dot_index = file_name.indexOf('.');\n    string extension = file_name.substr(dot_index+1);\n    string name = file_name.substr(0, dot_index);\n    int digit_count = 0;\n    foreach(char c; name)\n    {\n        if(c >= '0' && c <= '9')\n            digit_count++;\n    }\n    if(digit_count > 3)\n        return \"No\";\n    if(!(name[0] >= 'a' && name[0] <= 'z') && !(name[0] >= 'A' && name[0] <= 'Z'))\n        return \"No\";\n    if(!valid_extensions.canFind(extension))\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpoe5o_hzj.d(23): Error: no property `indexOf` for type `string`\n/tmp/tmpoe5o_hzj.d(24): Error: no property `substr` for type `string`\n/tmp/tmpoe5o_hzj.d(25): Error: no property `substr` for type `string`\n/tmp/tmpoe5o_hzj.d(36): Error: no property `canFind` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpoe5o_hzj.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164540
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n    int dot_index = file_name.find(\".\");\n    if (dot_index == -1)\n        return \"No\";\n    string extension = file_name[dot_index+1..$];\n    if (!valid_extensions.canFind(extension))\n        return \"No\";\n    string name = file_name[0..dot_index-1];\n    if (name.length == 0)\n        return \"No\";\n    int digits_count = 0;\n    foreach (c; name)\n    {\n        if (c >= '0' && c <= '9')\n            digits_count++;\n        else if (!(c >= 'a' && c <= 'z') && !(c >= 'A' && c <= 'Z'))\n            return \"No\";\n    }\n    if (digits_count > 3)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp0kphnh86.d(23): Error: no property `find` for type `string`\n/tmp/tmp0kphnh86.d(27): Error: no property `canFind` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0kphnh86.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164540
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n    string[] file_name_parts = file_name.split(\".\");\n    if (file_name_parts.length != 2)\n        return \"No\";\n    string file_name_part = file_name_parts[0];\n    string file_extension = file_name_parts[1];\n    if (file_name_part.length == 0 || file_name_part.count(\"0-9\") > 3)\n        return \"No\";\n    if (file_name_part[0] < 'a' || file_name_part[0] > 'z' && file_name_part[0] < 'A' || file_name_part[0] > 'Z')\n        return \"No\";\n    if (valid_extensions.count(file_extension) == 0)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp83gaezh_.d(23): Error: no property `split` for type `string`\n/tmp/tmp83gaezh_.d(28): Error: no property `count` for type `string`\n/tmp/tmp83gaezh_.d(32): Error: no property `count` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp83gaezh_.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164540
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    auto dot_pos = file_name.find('.');\n    if (dot_pos == -1)\n        return \"No\";\n    auto prefix = file_name[0..dot_pos];\n    auto suffix = file_name[dot_pos + 1..$];\n    if (prefix.length == 0 || !prefix.canFind(\"[a-zA-Z]\"))\n        return \"No\";\n    if (prefix.count(\"[0-9]\") > 3)\n        return \"No\";\n    if (suffix != \"txt\" && suffix != \"exe\" && suffix != \"dll\")\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpcv1di2f_.d(22): Error: no property `find` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcv1di2f_.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164540
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    import std.algorithm;\n    import std.array;\n    import std.conv;\n    import std.range;\n    import std.string;\n    import std.typecons;\n    import std.math;\n    import std.regex;\n    import std.stdio;\n    import std.traits;\n    import std.typecons;\n    import std.uni;\n    import std.utf;\n    import std.variant;\n    import std.datetime;\n    import std.format;\n    import std.math;\n    import std.numeric;\n    import std.range;\n    import std.regex;\n    import std.algorithm;\n    import std.array;\n    import std.ascii;\n    import std.bigint;\n    import std.bitmanip;\n    import std.complex;\n    import std.conv;\n    import std.cstream;\n    import std.datetime;\n    import std.exception;\n    import std.file;\n    import std.getopt;\n    import std.internal.math.mathspecial;\n    import std.math;\n    import std.numeric;\n    import std.range;\n    import std.regex;\n    import std.stdio;\n    import std.string;\n    import std.traits;\n    import std.typecons;\n    import std.uni;\n    import std.utf;\n    import std.variant;\n    import std.algorithm;\n    import std.array;\n    import std.ascii;\n    import std.bigint;\n    import std.bitmanip;\n    import std.complex;\n    import std.conv;\n    import std.cstream;\n    import std.datetime;\n    import std.exception;\n    import std.file;\n    import std.getopt;\n    import std.internal.math.mathspecial;\n    import std.math;\n    import std.numeric;\n    import std.range;\n    import std.regex;\n    import std.stdio;\n    import std.string;\n    import std.traits;\n    import std.typecons;\n    import std\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp142lcpdd.d(88): Error: `;` expected\n/tmp/tmp142lcpdd.d(119): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp142lcpdd.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164540
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int count = 0;\n    int dot_count = 0;\n    int dot_index = 0;\n    string extension = \"\";\n    string name = \"\";\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n    foreach(i, c; file_name)\n    {\n        if(c.isDigit)\n        {\n            count++;\n        }\n        if(c == '.')\n        {\n            dot_count++;\n            dot_index = i;\n        }\n    }\n    if(count > 3 || dot_count != 1)\n    {\n        return \"No\";\n    }\n    extension = file_name[dot_index+1..$];\n    name = file_name[0..dot_index-1];\n    if(name.length == 0 || !name[0].isLetter || !valid_extensions.contains(extension))\n    {\n        return \"No\";\n    }\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpwn2vucxu.d(30): Error: no property `isDigit` for type `immutable(char)`\n/tmp/tmpwn2vucxu.d(37): Error: cannot implicitly convert expression `i` of type `ulong` to `int`\n/tmp/tmpwn2vucxu.d(46): Error: no property `isLetter` for type `immutable(char)`\n/tmp/tmpwn2vucxu.d(46): Error: no property `contains` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwn2vucxu.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164540
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n    string[] file_name_parts = file_name.split(\".\");\n    if (file_name_parts.length != 2)\n        return \"No\";\n    if (file_name_parts[0].length == 0)\n        return \"No\";\n    if (file_name_parts[0].count(\"0-9\") > 3)\n        return \"No\";\n    if (file_name_parts[0][0] < 'a' || file_name_parts[0][0] > 'z')\n        return \"No\";\n    if (valid_extensions.find(file_name_parts[1]) == -1)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpeucb9ob2.d(23): Error: no property `split` for type `string`\n/tmp/tmpeucb9ob2.d(28): Error: no property `count` for type `string`\n/tmp/tmpeucb9ob2.d(32): Error: no property `find` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpeucb9ob2.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164539
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n    string[] file_name_parts = file_name.split(\".\");\n    if (file_name_parts.length != 2)\n        return \"No\";\n    string file_name_without_extension = file_name_parts[0];\n    string file_extension = file_name_parts[1];\n    if (file_name_without_extension.length == 0)\n        return \"No\";\n    if (file_name_without_extension.count(\"0\") + file_name_without_extension.count(\"1\") + file_name_without_extension.count(\"2\") + file_name_without_extension.count(\"3\") + file_name_without_extension.count(\"4\") + file_name_without_extension.count(\"5\") + file_name_without_extension.count(\"6\") + file_name_without_extension.count(\"7\") + file_name_without_extension.count(\"8\") + file_name_without_extension.count(\"9\") > 3)\n        return \"No\";\n    if (file_name_without_extension[0] < 'a' || file_name_without_extension[0] > 'z')\n        return \"No\";\n    if (file_name_without_extension[0] < 'A' || file_name_without_extension[0] > 'Z')\n        return \"No\";\n    if (valid_extensions.count(file_extension) == 0)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp9erhxhfg.d(23): Error: no property `split` for type `string`\n/tmp/tmp9erhxhfg.d(30): Error: no property `count` for type `string`\n/tmp/tmp9erhxhfg.d(30): Error: no property `count` for type `string`\n/tmp/tmp9erhxhfg.d(30): Error: no property `count` for type `string`\n/tmp/tmp9erhxhfg.d(30): Error: no property `count` for type `string`\n/tmp/tmp9erhxhfg.d(30): Error: no property `count` for type `string`\n/tmp/tmp9erhxhfg.d(30): Error: no property `count` for type `string`\n/tmp/tmp9erhxhfg.d(30): Error: no property `count` for type `string`\n/tmp/tmp9erhxhfg.d(30): Error: no property `count` for type `string`\n/tmp/tmp9erhxhfg.d(30): Error: no property `count` for type `string`\n/tmp/tmp9erhxhfg.d(30): Error: no property `count` for type `string`\n/tmp/tmp9erhxhfg.d(36): Error: no property `count` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9erhxhfg.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164540
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n    string[] file_name_parts = file_name.split(\".\");\n    if (file_name_parts.length != 2)\n        return \"No\";\n    if (file_name_parts[0].length == 0)\n        return \"No\";\n    if (file_name_parts[0].count(\"0-9\") > 3)\n        return \"No\";\n    if (file_name_parts[0][0] < 'a' || file_name_parts[0][0] > 'z')\n        return \"No\";\n    if (valid_extensions.count(file_name_parts[1]) == 0)\n        return \"No\";\n    return \"Yes\";\n}\n/*\nCreate a function which takes a string representing a file's name, and returns\n    the file's extension.\n    A file's extension is the substring after the last dot '.' in the file's name.\n    If the file's name does not contain a dot, return an empty string.\n    Examples:\n    >>> file_extension(\"example.txt\")\n    \"txt\"\n    >>> file_extension(\"example\")\n    \"\"\n*/\nstring file_extension(string file_name) \n{\n    string[] file_name_parts = file_name.split(\".\");\n    if (file_name_parts.length == 1)\n        return \"\";\n    return file_name_parts[$-1];\n}\n/*\nCreate a function which takes a string representing a file's name, and returns\n    the file's name without its extension.\n    A file's extension is the substring after the last dot '.' in the file's name.\n    If the file's name does not contain a dot, return the file's name.\n    Examples:\n    >>> file_name_without_extension(\"example.txt\")\n    \"example\"\n    >>> file_name_without_extension(\"example\")\n    \"example\"\n*/\nstring file_name_without_extension(string file_name) \n{\n    string[] file_name_parts = file_name.split(\".\");\n    if (file_name_parts\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpfhimsvmr.d(69): Error: found `unittest` when expecting `)`\n/tmp/tmpfhimsvmr.d(100): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfhimsvmr.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164540
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_index = file_name.find('.');\n    string extension = file_name.substr(dot_index+1);\n    string name = file_name.substr(0, dot_index);\n    int digits = 0;\n    foreach(char c; name)\n    {\n        if(c >= '0' && c <= '9')\n            digits++;\n    }\n    if(digits > 3)\n        return \"No\";\n    if(extension != \"txt\" && extension != \"exe\" && extension != \"dll\")\n        return \"No\";\n    if(name.length == 0)\n        return \"No\";\n    if(!(name[0] >= 'a' && name[0] <= 'z') && !(name[0] >= 'A' && name[0] <= 'Z'))\n        return \"No\";\n    return \"Yes\";\n}\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_index = file_name.find('.');\n    string extension = file_name.substr(dot_index+1);\n    string name = file_name.substr(0, dot_index);\n    int digits = 0;\n    foreach(char c; name)\n    {\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpt14fmb0r.d(66): Error: found `unittest` instead of statement\n/tmp/tmpt14fmb0r.d(97): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt14fmb0r.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164540
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n    int dot_index = file_name.find('.');\n    string extension = file_name.substr(dot_index + 1);\n    string name = file_name.substr(0, dot_index);\n    int digits_count = 0;\n    foreach(c; name)\n    {\n        if(c.isDigit)\n            digits_count++;\n    }\n    if(digits_count > 3 || dot_index == -1 || name.empty || !name[0].isLetter || !valid_extensions.count(extension))\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpmw_wage9.d(23): Error: no property `find` for type `string`\n/tmp/tmpmw_wage9.d(24): Error: no property `substr` for type `string`\n/tmp/tmpmw_wage9.d(25): Error: no property `substr` for type `string`\n/tmp/tmpmw_wage9.d(29): Error: no property `isDigit` for type `immutable(char)`\n/tmp/tmpmw_wage9.d(32): Error: no property `empty` for type `string`\n/tmp/tmpmw_wage9.d(32): Error: no property `isLetter` for type `immutable(char)`\n/tmp/tmpmw_wage9.d(32): Error: no property `count` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmw_wage9.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164540
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n    string[] file_name_parts = file_name.split(\".\");\n    if (file_name_parts.length != 2)\n        return \"No\";\n    if (file_name_parts[0].length == 0)\n        return \"No\";\n    if (file_name_parts[0].count(\"0-9\") > 3)\n        return \"No\";\n    if (file_name_parts[0][0] < 'a' || file_name_parts[0][0] > 'z')\n        return \"No\";\n    if (valid_extensions.find(file_name_parts[1]) == -1)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpeucb9ob2.d(23): Error: no property `split` for type `string`\n/tmp/tmpeucb9ob2.d(28): Error: no property `count` for type `string`\n/tmp/tmpeucb9ob2.d(32): Error: no property `find` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpeucb9ob2.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164539
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_index = file_name.find('.');\n    string extension = file_name.substr(dot_index + 1);\n    string name = file_name.substr(0, dot_index);\n    int digits = 0;\n    for (int i = 0; i < name.length; i++)\n    {\n        if (name[i] >= '0' && name[i] <= '9')\n            digits++;\n    }\n    if (digits > 3)\n        return \"No\";\n    if (name.length == 0)\n        return \"No\";\n    if (name[0] < 'a' || name[0] > 'z' && name[0] < 'A' || name[0] > 'Z')\n        return \"No\";\n    if (extension != \"txt\" && extension != \"exe\" && extension != \"dll\")\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpjsrrzjle.d(22): Error: no property `find` for type `string`\n/tmp/tmpjsrrzjle.d(23): Error: no property `substr` for type `string`\n/tmp/tmpjsrrzjle.d(24): Error: no property `substr` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjsrrzjle.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164540
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n    int dot_index = file_name.indexOf('.');\n    string extension = file_name.substr(dot_index + 1);\n    string name = file_name.substr(0, dot_index);\n    int digits_count = 0;\n    foreach(c; name)\n    {\n        if(c >= '0' && c <= '9')\n            digits_count++;\n    }\n    if(digits_count > 3 || dot_index == -1 || name.length == 0 || !(name[0] >= 'a' && name[0] <= 'z' || name[0] >= 'A' && name[0] <= 'Z'))\n        return \"No\";\n    foreach(ext; valid_extensions)\n    {\n        if(ext == extension)\n            return \"Yes\";\n    }\n    return \"No\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpgi87niw3.d(23): Error: no property `indexOf` for type `string`\n/tmp/tmpgi87niw3.d(24): Error: no property `substr` for type `string`\n/tmp/tmpgi87niw3.d(25): Error: no property `substr` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpgi87niw3.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164540
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    import std.algorithm : count;\n    import std.array : array;\n    import std.conv : to;\n    import std.range : take, drop;\n    import std.string : toLower;\n    import std.typecons : tuple;\n    import std.typecons : Tuple;\n    import std.typecons : tuple;\n    import std.typecons : Tuple;\n    import std.typecons : tuple;\n    import std.typecons : Tuple;\n    import std.typecons : tuple;\n    import std.typecons : Tuple;\n    import std.typecons : tuple;\n    import std.typecons : Tuple;\n    import std.typecons : tuple;\n    import std.typecons : Tuple;\n    import std.typecons : tuple;\n    import std.typecons : Tuple;\n    import std.typecons : tuple;\n    import std.typecons : Tuple;\n    import std.typecons : tuple;\n    import std.typecons : Tuple;\n    import std.typecons : tuple;\n    import std.typecons : Tuple;\n    import std.typecons : tuple;\n    import std.typecons : Tuple;\n    import std.typecons : tuple;\n    import std.typecons : Tuple;\n    import std.typecons : tuple;\n    import std.typecons : Tuple;\n    import std.typecons : tuple;\n    import std.typecons : Tuple;\n    import std.typecons : tuple;\n    import std.typecons : Tuple;\n    import std.typecons : tuple;\n    import std.typecons : Tuple;\n    import std.typecons : tuple;\n    import std.typecons : Tuple;\n    import std.typecons : tuple;\n    import std.typecons : Tuple;\n    import std.typecons : tuple;\n    import std.typecons : Tuple;\n    import std.typecons : tuple;\n    import std.typecons : Tuple;\n    import std.typecons : tuple;\n    import std.typecons : Tuple;\n    import std.typecons : tuple;\n    import std.typecons : Tuple\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpbnrpkyar.d(71): Error: `;` expected\n/tmp/tmpbnrpkyar.d(102): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpbnrpkyar.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164540
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n    string[] file_name_parts = split(file_name, \".\");\n    if (file_name_parts.length != 2)\n        return \"No\";\n    if (file_name_parts[0].length == 0)\n        return \"No\";\n    if (file_name_parts[0].length == 1 && !isalpha(file_name_parts[0][0]))\n        return \"No\";\n    if (file_name_parts[0].length > 1 && !isalpha(file_name_parts[0][0]))\n        return \"No\";\n    if (file_name_parts[0].length > 1 && !isalpha(file_name_parts[0][0]))\n        return \"No\";\n    if (file_name_parts[0].length > 1 && !isalpha(file_name_parts[0][0]))\n        return \"No\";\n    if (file_name_parts[0].length > 1 && !isalpha(file_name_parts[0][0]))\n        return \"No\";\n    if (file_name_parts[0].length > 1 && !isalpha(file_name_parts[0][0]))\n        return \"No\";\n    if (file_name_parts[0].length > 1 && !isalpha(file_name_parts[0][0]))\n        return \"No\";\n    if (file_name_parts[0].length > 1 && !isalpha(file_name_parts[0][0]))\n        return \"No\";\n    if (file_name_parts[0].length > 1 && !isalpha(file_name_parts[0][0]))\n        return \"No\";\n    if (file_name_parts[0].length > 1 && !isalpha(file_name_parts[0][0]))\n        return \"No\";\n    if (file_name_parts[0].length > 1 && !isalpha(file_name_parts[0][0]))\n        return \"No\";\n    if (file_name_parts[0].length > 1 && !isalpha(file_name\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpsavvuvnv.d(51): Error: found `unittest` when expecting `,`\n/tmp/tmpsavvuvnv.d(82): Error: found `void` when expecting `,`\n/tmp/tmpsavvuvnv.d(82): Error: found `{` when expecting `,`\n/tmp/tmpsavvuvnv.d(82): Error: expression expected, not `}`\n/tmp/tmpsavvuvnv.d(82): Error: found `End of File` when expecting `,`\n/tmp/tmpsavvuvnv.d(82): Error: found `End of File` when expecting `)`\n/tmp/tmpsavvuvnv.d(82): Error: found `End of File` when expecting `)`\n/tmp/tmpsavvuvnv.d(82): Error: found `End of File` instead of statement\n/tmp/tmpsavvuvnv.d(82): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpsavvuvnv.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164540
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_index = file_name.find('.');\n    string extension = file_name.substr(dot_index + 1);\n    string name = file_name.substr(0, dot_index);\n    int digits = 0;\n    foreach(char c; name)\n    {\n        if(c >= '0' && c <= '9')\n            digits++;\n    }\n    if(digits > 3)\n        return \"No\";\n    if(extension != \"txt\" && extension != \"exe\" && extension != \"dll\")\n        return \"No\";\n    if(name.length == 0)\n        return \"No\";\n    if(!(name[0] >= 'a' && name[0] <= 'z') && !(name[0] >= 'A' && name[0] <= 'Z'))\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp_kk64oag.d(22): Error: no property `find` for type `string`\n/tmp/tmp_kk64oag.d(23): Error: no property `substr` for type `string`\n/tmp/tmp_kk64oag.d(24): Error: no property `substr` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_kk64oag.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164540
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_index = file_name.find('.');\n    string extension = file_name.substr(dot_index + 1);\n    string file_name_without_extension = file_name.substr(0, dot_index);\n    int digits_count = 0;\n    foreach(char c; file_name_without_extension)\n    {\n        if(c >= '0' && c <= '9')\n        {\n            digits_count++;\n        }\n    }\n    if(digits_count > 3)\n    {\n        return \"No\";\n    }\n    if(!(extension == \"txt\" || extension == \"exe\" || extension == \"dll\"))\n    {\n        return \"No\";\n    }\n    if(file_name_without_extension.length == 0)\n    {\n        return \"No\";\n    }\n    if(!(file_name_without_extension[0] >= 'a' && file_name_without_extension[0] <= 'z' ||\n        file_name_without_extension[0] >= 'A' && file_name_without_extension[0] <= 'Z'))\n    {\n        return \"No\";\n    }\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpatbewhte.d(22): Error: no property `find` for type `string`\n/tmp/tmpatbewhte.d(23): Error: no property `substr` for type `string`\n/tmp/tmpatbewhte.d(24): Error: no property `substr` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpatbewhte.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164540
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n    int dot_index = file_name.find(\".\");\n    if (dot_index == -1)\n        return \"No\";\n    string extension = file_name[dot_index+1..$];\n    if (extension.length == 0 || !valid_extensions.canFind(extension))\n        return \"No\";\n    string name = file_name[0..dot_index-1];\n    if (name.length == 0 || !isAlpha(name[0]))\n        return \"No\";\n    int digits_count = 0;\n    foreach (c; name)\n    {\n        if (isDigit(c))\n            digits_count++;\n    }\n    if (digits_count > 3)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpice1bssp.d(23): Error: no property `find` for type `string`\n/tmp/tmpice1bssp.d(27): Error: no property `canFind` for type `string[]`\n/tmp/tmpice1bssp.d(30): Error: undefined identifier `isAlpha`\n/tmp/tmpice1bssp.d(35): Error: undefined identifier `isDigit`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpice1bssp.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164539
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n    string[] file_name_parts = split(file_name, \".\");\n    if (file_name_parts.length != 2)\n        return \"No\";\n    if (file_name_parts[0].length == 0)\n        return \"No\";\n    if (file_name_parts[0].count(\"0-9\") > 3)\n        return \"No\";\n    if (!valid_extensions.contains(file_name_parts[1]))\n        return \"No\";\n    if (!file_name_parts[0][0].isLetter)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpy4ucc964.d(23): Error: undefined identifier `split`\n/tmp/tmpy4ucc964.d(28): Error: no property `count` for type `string`\n/tmp/tmpy4ucc964.d(30): Error: no property `contains` for type `string[]`\n/tmp/tmpy4ucc964.d(32): Error: no property `isLetter` for type `immutable(char)`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpy4ucc964.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164540
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    auto dot_pos = file_name.find('.');\n    if (dot_pos == -1)\n        return \"No\";\n    auto ext = file_name.slice(dot_pos + 1);\n    if (ext != \"txt\" && ext != \"exe\" && ext != \"dll\")\n        return \"No\";\n    auto name = file_name.slice(0, dot_pos);\n    if (name.empty || !isAlpha(name[0]))\n        return \"No\";\n    if (count(name, (c) => isDigit(c)) > 3)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpb33xc7kq.d(22): Error: no property `find` for type `string`\n/tmp/tmpb33xc7kq.d(25): Error: no property `slice` for type `string`\n/tmp/tmpb33xc7kq.d(28): Error: no property `slice` for type `string`\n/tmp/tmpb33xc7kq.d(29): Error: undefined identifier `isAlpha`\n/tmp/tmpb33xc7kq.d(31): Error: undefined identifier `count`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpb33xc7kq.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164540
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n    string[] file_name_parts = file_name.split(\".\");\n    if (file_name_parts.length != 2)\n        return \"No\";\n    if (file_name_parts[0].length == 0)\n        return \"No\";\n    if (!file_name_parts[0][0].isLetter)\n        return \"No\";\n    if (file_name_parts[0].count!(a => a.isDigit) > 3)\n        return \"No\";\n    if (valid_extensions.count!(a => a == file_name_parts[1]) == 0)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp5jqkos8n.d(23): Error: no property `split` for type `string`\n/tmp/tmp5jqkos8n.d(28): Error: no property `isLetter` for type `immutable(char)`\n/tmp/tmp5jqkos8n.d(30): Error: no property `count` for type `string`\n/tmp/tmp5jqkos8n.d(32): Error: no property `count` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5jqkos8n.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164540
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n    string[] file_name_parts = file_name.split(\".\");\n    if (file_name_parts.length != 2)\n        return \"No\";\n    string file_name_part = file_name_parts[0];\n    string file_extension = file_name_parts[1];\n    if (file_name_part.length == 0)\n        return \"No\";\n    if (file_name_part.count(\"0\") + file_name_part.count(\"1\") + file_name_part.count(\"2\") + file_name_part.count(\"3\") + file_name_part.count(\"4\") + file_name_part.count(\"5\") + file_name_part.count(\"6\") + file_name_part.count(\"7\") + file_name_part.count(\"8\") + file_name_part.count(\"9\") > 3)\n        return \"No\";\n    if (file_name_part[0] < 'a' || file_name_part[0] > 'z')\n        return \"No\";\n    if (file_extension != valid_extensions[0] && file_extension != valid_extensions[1] && file_extension != valid_extensions[2])\n        return \"No\";\n    return \"Yes\";\n}\n/*\nCreate a function which takes a string representing a file's name, and returns\n    the file's extension.\n    A file's extension is the substring after the last dot '.' in the file's name.\n    Examples:\n    >>> file_extension(\"example.txt\")\n    \"txt\"\n    >>> file_extension(\"1example.dll\")\n    \"dll\"\n*/\nstring file_extension(string file_name)\n{\n    string[] file_name_parts = file_name.split(\".\");\n    return file_name_parts[file_name_parts.length - 1];\n}\n/*\nCreate a function which takes a string representing a file's name, and returns\n    the file's name without the extension.\n    The file's name without the extension is the substring before the last dot '\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpnw9hldg3.d(53): Error: unterminated /* */ comment\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpnw9hldg3.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164540
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n    int dot_index = file_name.find(\".\");\n    string extension = file_name[dot_index+1..$];\n    string name = file_name[0..dot_index-1];\n    if(extension.length == 0 || !valid_extensions.canFind(extension))\n        return \"No\";\n    if(name.length == 0 || !isAlpha(name[0]))\n        return \"No\";\n    if(name.count(\"0\") + name.count(\"1\") + name.count(\"2\") + name.count(\"3\") + name.count(\"4\") + name.count(\"5\") + name.count(\"6\") + name.count(\"7\") + name.count(\"8\") + name.count(\"9\") > 3)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpnr__vf85.d(23): Error: no property `find` for type `string`\n/tmp/tmpnr__vf85.d(26): Error: no property `canFind` for type `string[]`\n/tmp/tmpnr__vf85.d(28): Error: undefined identifier `isAlpha`\n/tmp/tmpnr__vf85.d(30): Error: no property `count` for type `string`\n/tmp/tmpnr__vf85.d(30): Error: no property `count` for type `string`\n/tmp/tmpnr__vf85.d(30): Error: no property `count` for type `string`\n/tmp/tmpnr__vf85.d(30): Error: no property `count` for type `string`\n/tmp/tmpnr__vf85.d(30): Error: no property `count` for type `string`\n/tmp/tmpnr__vf85.d(30): Error: no property `count` for type `string`\n/tmp/tmpnr__vf85.d(30): Error: no property `count` for type `string`\n/tmp/tmpnr__vf85.d(30): Error: no property `count` for type `string`\n/tmp/tmpnr__vf85.d(30): Error: no property `count` for type `string`\n/tmp/tmpnr__vf85.d(30): Error: no property `count` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpnr__vf85.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164540
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_count = 0;\n    int digit_count = 0;\n    bool is_valid = true;\n    foreach(char c; file_name)\n    {\n        if(c == '.')\n        {\n            dot_count++;\n        }\n        else if(c >= '0' && c <= '9')\n        {\n            digit_count++;\n        }\n    }\n    if(dot_count != 1 || digit_count > 3)\n    {\n        is_valid = false;\n    }\n    else\n    {\n        string[] parts = file_name.split(\".\");\n        if(parts.length != 2)\n        {\n            is_valid = false;\n        }\n        else\n        {\n            if(parts[0].length == 0 || parts[0][0] < 'a' || parts[0][0] > 'z')\n            {\n                is_valid = false;\n            }\n            else\n            {\n                if(parts[1] != \"txt\" && parts[1] != \"exe\" && parts[1] != \"dll\")\n                {\n                    is_valid = false;\n                }\n            }\n        }\n    }\n    return is_valid ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpilh9gzeg.d(42): Error: no property `split` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpilh9gzeg.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164540
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    import std.regex;\n    import std.string;\n    import std.algorithm;\n    import std.conv;\n    import std.array;\n    import std.range;\n    import std.typecons;\n    import std.math;\n    import std.stdio;\n    import std.file;\n    import std.format;\n    import std.datetime;\n    import std.conv;\n    import std.exception;\n    import std.traits;\n    import std.typecons;\n    import std.math;\n    import std.range;\n    import std.algorithm;\n    import std.regex;\n    import std.string;\n    import std.array;\n    import std.typecons;\n    import std.math;\n    import std.range;\n    import std.algorithm;\n    import std.regex;\n    import std.string;\n    import std.array;\n    import std.typecons;\n    import std.math;\n    import std.range;\n    import std.algorithm;\n    import std.regex;\n    import std.string;\n    import std.array;\n    import std.typecons;\n    import std.math;\n    import std.range;\n    import std.algorithm;\n    import std.regex;\n    import std.string;\n    import std.array;\n    import std.typecons;\n    import std.math;\n    import std.range;\n    import std.algorithm;\n    import std.regex;\n    import std.string;\n    import std.array;\n    import std.typecons;\n    import std.math;\n    import std.range;\n    import std.algorithm;\n    import std.regex;\n    import std.string;\n    import std.array;\n    import std.typecons;\n    import std.math;\n    import std.range;\n    import std.algorithm;\n    import std.regex;\n    import std.string;\n    import std.array;\n    import std.typecons;\n    import std.math;\n    import std.range;\n    import std.algorithm;\n    import std\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpk7yadfsl.d(91): Error: `;` expected\n/tmp/tmpk7yadfsl.d(122): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpk7yadfsl.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164540
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n    string[] file_name_split = file_name.split(\".\");\n    if (file_name_split.length != 2)\n        return \"No\";\n    if (file_name_split[0].length == 0)\n        return \"No\";\n    if (file_name_split[0].count(\"0\", \"9\") > 3)\n        return \"No\";\n    if (!valid_extensions.contains(file_name_split[1]))\n        return \"No\";\n    if (!file_name_split[0][0].isLetter)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp3ov7l2cb.d(23): Error: no property `split` for type `string`\n/tmp/tmp3ov7l2cb.d(28): Error: no property `count` for type `string`\n/tmp/tmp3ov7l2cb.d(30): Error: no property `contains` for type `string[]`\n/tmp/tmp3ov7l2cb.d(32): Error: no property `isLetter` for type `immutable(char)`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3ov7l2cb.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164540
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n    int dot_index = file_name.indexOf('.');\n    string extension = file_name.substr(dot_index + 1);\n    string file_name_without_extension = file_name.substr(0, dot_index);\n    int digits_count = 0;\n    foreach(c; file_name_without_extension)\n    {\n        if(c >= '0' && c <= '9')\n        {\n            digits_count++;\n        }\n    }\n    if(digits_count > 3)\n    {\n        return \"No\";\n    }\n    if(file_name.count('.') != 1)\n    {\n        return \"No\";\n    }\n    if(file_name_without_extension.empty() || \n        !(file_name_without_extension[0] >= 'a' && file_name_without_extension[0] <= 'z' ||\n        file_name_without_extension[0] >= 'A' && file_name_without_extension[0] <= 'Z'))\n    {\n        return \"No\";\n    }\n    if(!valid_extensions.canFind(extension))\n    {\n        return \"No\";\n    }\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpog5n_0xl.d(23): Error: no property `indexOf` for type `string`\n/tmp/tmpog5n_0xl.d(24): Error: no property `substr` for type `string`\n/tmp/tmpog5n_0xl.d(25): Error: no property `substr` for type `string`\n/tmp/tmpog5n_0xl.d(38): Error: no property `count` for type `string`\n/tmp/tmpog5n_0xl.d(42): Error: no property `empty` for type `string`\n/tmp/tmpog5n_0xl.d(48): Error: no property `canFind` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpog5n_0xl.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164540
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n    string[] file_name_parts = file_name.split(\".\");\n    if (file_name_parts.length != 2)\n        return \"No\";\n    if (file_name_parts[0].length == 0)\n        return \"No\";\n    if (file_name_parts[0].count('0','9') > 3)\n        return \"No\";\n    if (!valid_extensions.contains(file_name_parts[1]))\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp1te20mnp.d(23): Error: no property `split` for type `string`\n/tmp/tmp1te20mnp.d(28): Error: no property `count` for type `string`\n/tmp/tmp1te20mnp.d(30): Error: no property `contains` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1te20mnp.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164541
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n    auto dot_index = file_name.find(\".\");\n    if (dot_index == -1)\n        return \"No\";\n    auto extension = file_name[dot_index + 1 .. $];\n    if (extension.length == 0 || !valid_extensions.canFind(extension))\n        return \"No\";\n    auto name = file_name[0 .. dot_index];\n    if (name.length == 0 || !isAlpha(name[0]))\n        return \"No\";\n    if (name.count!(c => isDigit(c)) > 3)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpxe8s033w.d(23): Error: no property `find` for type `string`\n/tmp/tmpxe8s033w.d(27): Error: no property `canFind` for type `string[]`\n/tmp/tmpxe8s033w.d(30): Error: undefined identifier `isAlpha`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxe8s033w.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164541
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_pos = file_name.find('.');\n    if (dot_pos == -1)\n        return \"No\";\n    string before_dot = file_name[0..dot_pos];\n    string after_dot = file_name[dot_pos+1..$];\n    if (before_dot.length == 0 || before_dot.count('0'..'9') > 3)\n        return \"No\";\n    if (after_dot != \"txt\" && after_dot != \"exe\" && after_dot != \"dll\")\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpjz4cyd2g.d(27): Error: found `..` when expecting `,`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjz4cyd2g.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164539
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_index = file_name.find('.');\n    string extension = file_name.substr(dot_index + 1);\n    string name = file_name.substr(0, dot_index);\n    int digits = 0;\n    foreach(char c; name)\n    {\n        if(c >= '0' && c <= '9')\n            digits++;\n    }\n    if(digits > 3)\n        return \"No\";\n    if(extension != \"txt\" && extension != \"exe\" && extension != \"dll\")\n        return \"No\";\n    if(name.length == 0)\n        return \"No\";\n    if(!(name[0] >= 'a' && name[0] <= 'z') && !(name[0] >= 'A' && name[0] <= 'Z'))\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp_kk64oag.d(22): Error: no property `find` for type `string`\n/tmp/tmp_kk64oag.d(23): Error: no property `substr` for type `string`\n/tmp/tmp_kk64oag.d(24): Error: no property `substr` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_kk64oag.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164540
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n    int dot_index = file_name.find('.');\n    if (dot_index == -1)\n        return \"No\";\n    string extension = file_name[dot_index+1..$];\n    if (extension.length == 0 || !valid_extensions.canFind(extension))\n        return \"No\";\n    string name = file_name[0..dot_index];\n    if (name.length == 0 || !isAlpha(name[0]))\n        return \"No\";\n    int digits_count = 0;\n    foreach (c; name)\n    {\n        if (isDigit(c))\n            digits_count++;\n    }\n    if (digits_count > 3)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp1r05bl1i.d(23): Error: no property `find` for type `string`\n/tmp/tmp1r05bl1i.d(27): Error: no property `canFind` for type `string[]`\n/tmp/tmp1r05bl1i.d(30): Error: undefined identifier `isAlpha`\n/tmp/tmp1r05bl1i.d(35): Error: undefined identifier `isDigit`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1r05bl1i.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164540
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_pos = file_name.find('.');\n    string ext = file_name.substr(dot_pos + 1);\n    string name = file_name.substr(0, dot_pos);\n    int digits = 0;\n    foreach(c; name)\n    {\n        if(c >= '0' && c <= '9')\n            digits++;\n    }\n    if(digits > 3)\n        return \"No\";\n    if(ext != \"txt\" && ext != \"exe\" && ext != \"dll\")\n        return \"No\";\n    if(name.length == 0)\n        return \"No\";\n    if(name[0] < 'a' || name[0] > 'z' && name[0] < 'A' || name[0] > 'Z')\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmptgsj6qfh.d(22): Error: no property `find` for type `string`\n/tmp/tmptgsj6qfh.d(23): Error: no property `substr` for type `string`\n/tmp/tmptgsj6qfh.d(24): Error: no property `substr` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmptgsj6qfh.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164540
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_index = file_name.find('.');\n    string extension = file_name.substr(dot_index + 1);\n    string name = file_name.substr(0, dot_index);\n    int count = 0;\n    for (int i = 0; i < name.length; i++)\n    {\n        if (name[i] >= '0' && name[i] <= '9')\n        {\n            count++;\n        }\n    }\n    if (count > 3)\n    {\n        return \"No\";\n    }\n    if (extension != \"txt\" && extension != \"exe\" && extension != \"dll\")\n    {\n        return \"No\";\n    }\n    if (name.length == 0)\n    {\n        return \"No\";\n    }\n    if (name[0] < 'a' || name[0] > 'z' && name[0] < 'A' || name[0] > 'Z')\n    {\n        return \"No\";\n    }\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp_kgvdh3d.d(22): Error: no property `find` for type `string`\n/tmp/tmp_kgvdh3d.d(23): Error: no property `substr` for type `string`\n/tmp/tmp_kgvdh3d.d(24): Error: no property `substr` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_kgvdh3d.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164540
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    auto dot_pos = file_name.find('.');\n    if (dot_pos == -1)\n        return \"No\";\n    auto sub_str = file_name[0..dot_pos];\n    if (sub_str.length == 0 || !isAlpha(sub_str[0]))\n        return \"No\";\n    auto digits = 0;\n    foreach (c; sub_str)\n        if (isDigit(c))\n            digits++;\n    if (digits > 3)\n        return \"No\";\n    sub_str = file_name[dot_pos + 1..$];\n    if (sub_str != \"txt\" && sub_str != \"exe\" && sub_str != \"dll\")\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpon7q4fx6.d(22): Error: no property `find` for type `string`\n/tmp/tmpon7q4fx6.d(26): Error: undefined identifier `isAlpha`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpon7q4fx6.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164540
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_pos = file_name.find('.');\n    if (dot_pos == -1)\n        return \"No\";\n    string ext = file_name.substr(dot_pos + 1);\n    if (ext != \"txt\" && ext != \"exe\" && ext != \"dll\")\n        return \"No\";\n    string name = file_name.substr(0, dot_pos);\n    if (name.length == 0)\n        return \"No\";\n    int digits = 0;\n    foreach (c; name)\n    {\n        if (c >= '0' && c <= '9')\n            digits++;\n        else if (!(c >= 'a' && c <= 'z') && !(c >= 'A' && c <= 'Z'))\n            return \"No\";\n    }\n    if (digits > 3)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpfis1c_9o.d(22): Error: no property `find` for type `string`\n/tmp/tmpfis1c_9o.d(25): Error: no property `substr` for type `string`\n/tmp/tmpfis1c_9o.d(28): Error: no property `substr` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfis1c_9o.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164541
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_pos = file_name.find('.');\n    string extension = file_name.substr(dot_pos + 1);\n    string name = file_name.substr(0, dot_pos);\n    int count = 0;\n    foreach(c; name)\n    {\n        if(c >= '0' && c <= '9')\n            count++;\n    }\n    if(count > 3)\n        return \"No\";\n    if(extension != \"txt\" && extension != \"exe\" && extension != \"dll\")\n        return \"No\";\n    if(name.length == 0)\n        return \"No\";\n    if(!(name[0] >= 'a' && name[0] <= 'z') && !(name[0] >= 'A' && name[0] <= 'Z'))\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpfhajeizj.d(22): Error: no property `find` for type `string`\n/tmp/tmpfhajeizj.d(23): Error: no property `substr` for type `string`\n/tmp/tmpfhajeizj.d(24): Error: no property `substr` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfhajeizj.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164540
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int count = 0;\n    int dot_count = 0;\n    int dot_index = 0;\n    string sub_string_before_dot = \"\";\n    string sub_string_after_dot = \"\";\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n    foreach(char c; file_name)\n    {\n        if(c == '.')\n        {\n            dot_count++;\n            dot_index = count;\n        }\n        count++;\n    }\n    if(dot_count != 1)\n    {\n        return \"No\";\n    }\n    else\n    {\n        sub_string_before_dot = file_name[0..dot_index];\n        sub_string_after_dot = file_name[dot_index+1..$];\n        if(sub_string_before_dot.length == 0 || sub_string_before_dot.length > 8)\n        {\n            return \"No\";\n        }\n        else\n        {\n            foreach(char c; sub_string_before_dot)\n            {\n                if(!(c >= 'a' && c <= 'z') && !(c >= 'A' && c <= 'Z'))\n                {\n                    return \"No\";\n                }\n            }\n            if(!(sub_string_after_dot in valid_extensions))\n            {\n                return \"No\";\n            }\n            else\n            {\n                return \"Yes\";\n            }\n        }\n    }\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpa98o31_t.d(58): Error: incompatible types for `(sub_string_after_dot) in (valid_extensions)`: `string` and `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpa98o31_t.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164540
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_count = 0;\n    int digit_count = 0;\n    int i = 0;\n    foreach(c; file_name)\n    {\n        if(c == '.')\n        {\n            dot_count++;\n        }\n        if(c >= '0' && c <= '9')\n        {\n            digit_count++;\n        }\n        i++;\n    }\n    if(dot_count != 1)\n    {\n        return \"No\";\n    }\n    if(digit_count > 3)\n    {\n        return \"No\";\n    }\n    if(file_name[0] < 'a' || (file_name[0] > 'z' && file_name[0] < 'A') || file_name[0] > 'Z')\n    {\n        return \"No\";\n    }\n    string ext = file_name[i-4..i-1];\n    if(ext != \"txt\" && ext != \"exe\" && ext != \"dll\")\n    {\n        return \"No\";\n    }\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp2ec5i8dh.d(60): unittest failure\n----------------\n??:? _d_unittestp [0x428815]\n??:? void tmp2ec5i8dh.__unittest_L56_C1() [0x427d21]\n??:? void tmp2ec5i8dh.__modtest() [0x428598]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c533]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b442]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430559]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430a08]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4304e5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b419]\n??:? runModuleUnitTests [0x42c309]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428cd8]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660164541
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n    string[] file_name_parts = file_name.split(\".\");\n    if (file_name_parts.length != 2)\n        return \"No\";\n    if (file_name_parts[0].length == 0)\n        return \"No\";\n    if (file_name_parts[0].count(\"0123456789\") > 3)\n        return \"No\";\n    if (file_name_parts[0][0] < 'a' || file_name_parts[0][0] > 'z')\n        return \"No\";\n    if (valid_extensions.count(file_name_parts[1]) == 0)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpov9i61ox.d(23): Error: no property `split` for type `string`\n/tmp/tmpov9i61ox.d(28): Error: no property `count` for type `string`\n/tmp/tmpov9i61ox.d(32): Error: no property `count` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpov9i61ox.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164541
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n    string[] file_name_parts = file_name.split(\".\");\n    if (file_name_parts.length != 2)\n        return \"No\";\n    if (file_name_parts[0].length == 0)\n        return \"No\";\n    if (file_name_parts[0].count(\"0-9\") > 3)\n        return \"No\";\n    if (!valid_extensions.contains(file_name_parts[1]))\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpatc7yj1n.d(23): Error: no property `split` for type `string`\n/tmp/tmpatc7yj1n.d(28): Error: no property `count` for type `string`\n/tmp/tmpatc7yj1n.d(30): Error: no property `contains` for type `string[]`\n",
      "stdout": "",
      "timestamp": 1660164540
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_pos = file_name.find('.');\n    string name = file_name[0..dot_pos];\n    string ext = file_name[dot_pos+1..$];\n    int digits = 0;\n    foreach(c; name)\n    {\n        if(c >= '0' && c <= '9')\n            digits++;\n    }\n    if(digits > 3)\n        return \"No\";\n    if(ext != \"txt\" && ext != \"exe\" && ext != \"dll\")\n        return \"No\";\n    if(name.length == 0)\n        return \"No\";\n    if(!(name[0] >= 'a' && name[0] <= 'z') && !(name[0] >= 'A' && name[0] <= 'Z'))\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp1h42zlct.d(22): Error: no property `find` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1h42zlct.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164540
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n    int dot_index = file_name.find('.');\n    if (dot_index == -1)\n        return \"No\";\n    string name = file_name[0..dot_index];\n    string extension = file_name[dot_index+1..$];\n    if (name.length == 0 || !isAlpha(name[0]))\n        return \"No\";\n    if (extension.length == 0 || !valid_extensions.canFind(extension))\n        return \"No\";\n    int digits_count = 0;\n    foreach (c; name)\n        if (isDigit(c))\n            digits_count++;\n    if (digits_count > 3)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpa6mz2aqn.d(23): Error: no property `find` for type `string`\n/tmp/tmpa6mz2aqn.d(28): Error: undefined identifier `isAlpha`\n/tmp/tmpa6mz2aqn.d(30): Error: no property `canFind` for type `string[]`\n/tmp/tmpa6mz2aqn.d(34): Error: undefined identifier `isDigit`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpa6mz2aqn.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164541
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_pos = file_name.find(\".\");\n    string sub_str = file_name.substr(0, dot_pos);\n    string sub_str2 = file_name.substr(dot_pos + 1);\n    if (sub_str.length == 0 || sub_str2.length == 0)\n        return \"No\";\n    if (sub_str.length > 3)\n        return \"No\";\n    if (sub_str.find(\"0\") != -1 || sub_str.find(\"1\") != -1 || sub_str.find(\"2\") != -1 || sub_str.find(\"3\") != -1 || sub_str.find(\"4\") != -1 || sub_str.find(\"5\") != -1 || sub_str.find(\"6\") != -1 || sub_str.find(\"7\") != -1 || sub_str.find(\"8\") != -1 || sub_str.find(\"9\") != -1)\n        return \"No\";\n    if (sub_str2 != \"txt\" && sub_str2 != \"exe\" && sub_str2 != \"dll\")\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpmx891cyq.d(22): Error: no property `find` for type `string`\n/tmp/tmpmx891cyq.d(23): Error: no property `substr` for type `string`\n/tmp/tmpmx891cyq.d(24): Error: no property `substr` for type `string`\n/tmp/tmpmx891cyq.d(29): Error: no property `find` for type `string`\n/tmp/tmpmx891cyq.d(29): Error: no property `find` for type `string`\n/tmp/tmpmx891cyq.d(29): Error: no property `find` for type `string`\n/tmp/tmpmx891cyq.d(29): Error: no property `find` for type `string`\n/tmp/tmpmx891cyq.d(29): Error: no property `find` for type `string`\n/tmp/tmpmx891cyq.d(29): Error: no property `find` for type `string`\n/tmp/tmpmx891cyq.d(29): Error: no property `find` for type `string`\n/tmp/tmpmx891cyq.d(29): Error: no property `find` for type `string`\n/tmp/tmpmx891cyq.d(29): Error: no property `find` for type `string`\n/tmp/tmpmx891cyq.d(29): Error: no property `find` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmx891cyq.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164541
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n    string[] parts = split(file_name, \".\");\n    if (parts.length != 2)\n        return \"No\";\n    if (parts[0].length == 0)\n        return \"No\";\n    if (parts[0][0] < 'a' || parts[0][0] > 'z')\n        return \"No\";\n    if (parts[1] !in valid_extensions)\n        return \"No\";\n    int digits = 0;\n    foreach (char c; parts[0])\n    {\n        if (c >= '0' && c <= '9')\n            digits++;\n    }\n    if (digits > 3)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpl_1p87e0.d(23): Error: undefined identifier `split`\n/tmp/tmpl_1p87e0.d(30): Error: incompatible types for `(parts[1]) in (valid_extensions)`: `string` and `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpl_1p87e0.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164541
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n    string[] file_name_parts = file_name.split(\".\");\n    if (file_name_parts.length != 2)\n        return \"No\";\n    if (file_name_parts[0].length == 0)\n        return \"No\";\n    if (file_name_parts[0].count(\"0-9\") > 3)\n        return \"No\";\n    if (file_name_parts[0][0] < 'a' || file_name_parts[0][0] > 'z')\n        return \"No\";\n    if (valid_extensions.find(file_name_parts[1]) == -1)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpeucb9ob2.d(23): Error: no property `split` for type `string`\n/tmp/tmpeucb9ob2.d(28): Error: no property `count` for type `string`\n/tmp/tmpeucb9ob2.d(32): Error: no property `find` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpeucb9ob2.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164539
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n    int dot_index = file_name.find('.');\n    string extension = file_name.substr(dot_index + 1);\n    string name = file_name.substr(0, dot_index);\n    int digits_count = 0;\n    foreach(char c; name)\n    {\n        if(c >= '0' && c <= '9')\n            digits_count++;\n    }\n    if(digits_count > 3 || dot_index == -1 || name.length == 0 || !(name[0] >= 'a' && name[0] <= 'z' || name[0] >= 'A' && name[0] <= 'Z'))\n        return \"No\";\n    foreach(string ext; valid_extensions)\n    {\n        if(ext == extension)\n            return \"Yes\";\n    }\n    return \"No\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpbont0f_e.d(23): Error: no property `find` for type `string`\n/tmp/tmpbont0f_e.d(24): Error: no property `substr` for type `string`\n/tmp/tmpbont0f_e.d(25): Error: no property `substr` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpbont0f_e.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164541
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    int dot_pos = file_name.find('.');\n    if (dot_pos == -1)\n        return \"No\";\n    string name = file_name[0..dot_pos];\n    string ext = file_name[dot_pos+1..$];\n    if (name.length == 0 || !isAlpha(name[0]))\n        return \"No\";\n    int count = 0;\n    foreach (c; name)\n        if (isDigit(c))\n            count++;\n    if (count > 3)\n        return \"No\";\n    if (ext != \"txt\" && ext != \"exe\" && ext != \"dll\")\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp_suk0doh.d(22): Error: no property `find` for type `string`\n/tmp/tmp_suk0doh.d(27): Error: undefined identifier `isAlpha`\n/tmp/tmp_suk0doh.d(31): Error: undefined identifier `isDigit`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_suk0doh.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164541
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nCreate a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check(\"example.txt\")\n    \"Yes\"\n    >>> file_name_check(\"1example.dll\")\n    \"No\"\n    \n*/\nstring file_name_check(string file_name) \n{\n    string[] valid_extensions = [\"txt\", \"exe\", \"dll\"];\n    int dot_index = file_name.find(\".\");\n    if (dot_index == -1)\n        return \"No\";\n    string extension = file_name[dot_index + 1 .. $];\n    if (extension.length == 0 || !valid_extensions.canFind(extension))\n        return \"No\";\n    string name = file_name[0 .. dot_index];\n    if (name.length == 0)\n        return \"No\";\n    int digits_count = 0;\n    foreach (c; name)\n    {\n        if (c >= '0' && c <= '9')\n            digits_count++;\n        else if (!(c >= 'a' && c <= 'z') && !(c >= 'A' && c <= 'Z'))\n            return \"No\";\n    }\n    if (digits_count > 3)\n        return \"No\";\n    return \"Yes\";\n}\nunittest\n{\n    alias candidate = file_name_check;\n\n    assert(candidate(\"example.txt\") == \"Yes\");\n    assert(candidate(\"1example.dll\") == \"No\");\n    assert(candidate(\"s1sdf3.asd\") == \"No\");\n    assert(candidate(\"K.dll\") == \"Yes\");\n    assert(candidate(\"MY16FILE3.exe\") == \"Yes\");\n    assert(candidate(\"His12FILE94.exe\") == \"No\");\n    assert(candidate(\"_Y.txt\") == \"No\");\n    assert(candidate(\"?aREYA.exe\") == \"No\");\n    assert(candidate(\"/this_is_valid.dll\") == \"No\");\n    assert(candidate(\"this_is_valid.wow\") == \"No\");\n    assert(candidate(\"this_is_valid.txt\") == \"Yes\");\n    assert(candidate(\"this_is_valid.txtexe\") == \"No\");\n    assert(candidate(\"#this2_i4s_5valid.ten\") == \"No\");\n    assert(candidate(\"@this1_is6_valid.exe\") == \"No\");\n    assert(candidate(\"this_is_12valid.6exe4.txt\") == \"No\");\n    assert(candidate(\"all.exe.txt\") == \"No\");\n    assert(candidate(\"I563_No.exe\") == \"Yes\");\n    assert(candidate(\"Is3youfault.txt\") == \"Yes\");\n    assert(candidate(\"no_one#knows.dll\") == \"Yes\");\n    assert(candidate(\"1I563_Yes3.exe\") == \"No\");\n    assert(candidate(\"I563_Yes3.txtt\") == \"No\");\n    assert(candidate(\"final..txt\") == \"No\");\n    assert(candidate(\"final132\") == \"No\");\n    assert(candidate(\"_f4indsartal132.\") == \"No\");\n    assert(candidate(\".txt\") == \"No\");\n    assert(candidate(\"s.\") == \"No\");\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpa_2xgmu4.d(23): Error: no property `find` for type `string`\n/tmp/tmpa_2xgmu4.d(27): Error: no property `canFind` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpa_2xgmu4.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660164541
    }
  ]
}