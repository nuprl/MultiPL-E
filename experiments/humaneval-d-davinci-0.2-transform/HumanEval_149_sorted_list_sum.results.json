{
  "language": "d",
  "name": "HumanEval_149_sorted_list_sum",
  "results": [
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    lst.sort();\n    string[] result;\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpjx6utp61.d(23): Error: no property `sort` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjx6utp61.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163089
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] new_lst = new string[0];\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            new_lst ~= s;\n        }\n    }\n    return new_lst;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpff7kbs56.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x42927d]\n??:? void tmpff7kbs56.__unittest_L33_C1() [0x427e4f]\n??:? void tmpff7kbs56.__modtest() [0x4284e4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42e59f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428fd6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42b44d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42b4dc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42b3d9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428fad]\n??:? runModuleUnitTests [0x42e375]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4296cc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result;\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpt9c8e26x.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x429275]\n??:? void tmpt9c8e26x.__unittest_L33_C1() [0x427e4b]\n??:? void tmpt9c8e26x.__modtest() [0x4284e0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42e53b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428fce]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42b3e9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42b478]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42b375]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428fa5]\n??:? runModuleUnitTests [0x42e311]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4296c4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    int[] len_lst = new int[lst.length];\n    foreach(int i, string s; lst)\n    {\n        len_lst[i] = s.length;\n    }\n    int[] sorted_len_lst = sort(len_lst);\n    string[] sorted_lst = new string[lst.length];\n    foreach(int i, int len; sorted_len_lst)\n    {\n        foreach(int j, string s; lst)\n        {\n            if(s.length == len)\n            {\n                sorted_lst[i] = s;\n                break;\n            }\n        }\n    }\n    return sorted_lst;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpa2msgsn5.d(26): Error: cannot implicitly convert expression `s.length` of type `ulong` to `int`\n/tmp/tmpa2msgsn5.d(28): Error: undefined identifier `sort`, did you mean function `sqrt`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpa2msgsn5.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163089
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result;\n    foreach(string s; lst) \n    {\n        if(s.length % 2 == 0) \n        {\n            result ~= s;\n        }\n    }\n    return result.sort;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp80dj_jib.d(31): Error: no property `sort` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp80dj_jib.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163089
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result;\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    return result.sort;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp1krbhn5f.d(31): Error: no property `sort` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1krbhn5f.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163089
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result = [];\n    foreach(string s; lst) \n    {\n        if(s.length % 2 == 0) \n        {\n            result ~= s;\n        }\n    }\n    return result.sort();\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp5_dovyh5.d(31): Error: no property `sort` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5_dovyh5.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163089
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result = [];\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    sort(result);\n    return result;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpa999f_u7.d(31): Error: undefined identifier `sort`, did you mean function `sqrt`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpa999f_u7.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163089
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result = [];\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpdg0eu_3w.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x429285]\n??:? void tmpdg0eu_3w.__unittest_L33_C1() [0x427e57]\n??:? void tmpdg0eu_3w.__modtest() [0x4284ec]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42e54b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428fde]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42b3f9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42b488]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42b385]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428fb5]\n??:? runModuleUnitTests [0x42e321]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4296d4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result = [];\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpdg0eu_3w.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x429285]\n??:? void tmpdg0eu_3w.__unittest_L33_C1() [0x427e57]\n??:? void tmpdg0eu_3w.__modtest() [0x4284ec]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42e54b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428fde]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42b3f9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42b488]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42b385]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428fb5]\n??:? runModuleUnitTests [0x42e321]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4296d4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result = [];\n    foreach(string i; lst)\n    {\n        if(i.length % 2 == 0)\n        {\n            result ~= i;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp2pv7pnc_.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x429285]\n??:? void tmp2pv7pnc_.__unittest_L33_C1() [0x427e57]\n??:? void tmp2pv7pnc_.__modtest() [0x4284ec]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42e54b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428fde]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42b3f9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42b488]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42b385]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428fb5]\n??:? runModuleUnitTests [0x42e321]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4296d4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result = [];\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpdg0eu_3w.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x429285]\n??:? void tmpdg0eu_3w.__unittest_L33_C1() [0x427e57]\n??:? void tmpdg0eu_3w.__modtest() [0x4284ec]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42e54b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428fde]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42b3f9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42b488]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42b385]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428fb5]\n??:? runModuleUnitTests [0x42e321]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4296d4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result = [];\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpdg0eu_3w.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x429285]\n??:? void tmpdg0eu_3w.__unittest_L33_C1() [0x427e57]\n??:? void tmpdg0eu_3w.__modtest() [0x4284ec]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42e54b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428fde]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42b3f9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42b488]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42b385]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428fb5]\n??:? runModuleUnitTests [0x42e321]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4296d4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result = [];\n    foreach(string s; lst) \n    {\n        if(s.length % 2 == 0) \n        {\n            result ~= s;\n        }\n    }\n    return result.sort();\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp5_dovyh5.d(31): Error: no property `sort` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5_dovyh5.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163089
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result = [];\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpdg0eu_3w.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x429285]\n??:? void tmpdg0eu_3w.__unittest_L33_C1() [0x427e57]\n??:? void tmpdg0eu_3w.__modtest() [0x4284ec]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42e54b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428fde]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42b3f9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42b488]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42b385]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428fb5]\n??:? runModuleUnitTests [0x42e321]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4296d4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result = [];\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpdg0eu_3w.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x429285]\n??:? void tmpdg0eu_3w.__unittest_L33_C1() [0x427e57]\n??:? void tmpdg0eu_3w.__modtest() [0x4284ec]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42e54b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428fde]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42b3f9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42b488]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42b385]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428fb5]\n??:? runModuleUnitTests [0x42e321]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4296d4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result;\n    int sum = 0;\n    foreach(string s; lst)\n    {\n        sum += s.length;\n    }\n    if(sum % 2 == 0)\n    {\n        result = lst;\n    }\n    else\n    {\n        result = lst[0..$-1];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpvv64r3he.d(43): unittest failure\n----------------\n??:? _d_unittestp [0x42929d]\n??:? void tmpvv64r3he.__unittest_L39_C1() [0x427d40]\n??:? void tmpvv64r3he.__modtest() [0x428504]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42dbeb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428ff6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42aa99]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ab28]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42aa25]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428fcd]\n??:? runModuleUnitTests [0x42d9c1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429760]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result;\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    return result.sort;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp1krbhn5f.d(31): Error: no property `sort` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1krbhn5f.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163089
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] new_lst;\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            new_lst ~= s;\n        }\n    }\n    sort(new_lst);\n    return new_lst;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpvem4yq_c.d(31): Error: undefined identifier `sort`, did you mean function `sqrt`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvem4yq_c.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163089
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result;\n    foreach(string s; lst) \n    {\n        if(s.length % 2 == 0) \n        {\n            result ~= s;\n        }\n    }\n    return result.sort();\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpjx4p6zud.d(31): Error: no property `sort` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjx4p6zud.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163089
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result = [];\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    sort(result);\n    return result;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpa999f_u7.d(31): Error: undefined identifier `sort`, did you mean function `sqrt`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpa999f_u7.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163089
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result = [];\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpdg0eu_3w.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x429285]\n??:? void tmpdg0eu_3w.__unittest_L33_C1() [0x427e57]\n??:? void tmpdg0eu_3w.__modtest() [0x4284ec]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42e54b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428fde]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42b3f9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42b488]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42b385]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428fb5]\n??:? runModuleUnitTests [0x42e321]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4296d4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result = [];\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpdg0eu_3w.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x429285]\n??:? void tmpdg0eu_3w.__unittest_L33_C1() [0x427e57]\n??:? void tmpdg0eu_3w.__modtest() [0x4284ec]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42e54b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428fde]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42b3f9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42b488]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42b385]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428fb5]\n??:? runModuleUnitTests [0x42e321]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4296d4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result;\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    return result.sort;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp1krbhn5f.d(31): Error: no property `sort` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1krbhn5f.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163089
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result = [];\n    foreach(string s; lst)\n    {\n        int sum = 0;\n        foreach(char c; s)\n        {\n            sum += c;\n        }\n        if(sum % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpav_r7f9f.d(43): unittest failure\n----------------\n??:? _d_unittestp [0x4292e5]\n??:? void tmpav_r7f9f.__unittest_L38_C1() [0x427ebb]\n??:? void tmpav_r7f9f.__modtest() [0x428550]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42e5ab]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42903e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42b459]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42b4e8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42b3e5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x429015]\n??:? runModuleUnitTests [0x42e381]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429734]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result = [];\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpdg0eu_3w.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x429285]\n??:? void tmpdg0eu_3w.__unittest_L33_C1() [0x427e57]\n??:? void tmpdg0eu_3w.__modtest() [0x4284ec]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42e54b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428fde]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42b3f9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42b488]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42b385]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428fb5]\n??:? runModuleUnitTests [0x42e321]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4296d4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result = [];\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpdg0eu_3w.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x429285]\n??:? void tmpdg0eu_3w.__unittest_L33_C1() [0x427e57]\n??:? void tmpdg0eu_3w.__modtest() [0x4284ec]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42e54b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428fde]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42b3f9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42b488]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42b385]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428fb5]\n??:? runModuleUnitTests [0x42e321]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4296d4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result;\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    return result.sort();\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpsowl3_3x.d(31): Error: no property `sort` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpsowl3_3x.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163089
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result = new string[0];\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    return result.sort();\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp3v4u7exy.d(31): Error: no property `sort` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3v4u7exy.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163089
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result;\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    return result.sort;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp1krbhn5f.d(31): Error: no property `sort` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1krbhn5f.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163089
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result;\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    return result.sort;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp1krbhn5f.d(31): Error: no property `sort` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1krbhn5f.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163089
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result;\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    return result.sort;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp1krbhn5f.d(31): Error: no property `sort` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1krbhn5f.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163089
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result = [];\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpdg0eu_3w.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x429285]\n??:? void tmpdg0eu_3w.__unittest_L33_C1() [0x427e57]\n??:? void tmpdg0eu_3w.__modtest() [0x4284ec]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42e54b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428fde]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42b3f9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42b488]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42b385]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428fb5]\n??:? runModuleUnitTests [0x42e321]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4296d4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result;\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    return result.sort;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp1krbhn5f.d(31): Error: no property `sort` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1krbhn5f.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163089
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result = [];\n    foreach(string s; lst) \n    {\n        if(s.length % 2 == 0) \n        {\n            result ~= s;\n        }\n    }\n    return result.sort;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpzysb44te.d(31): Error: no property `sort` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpzysb44te.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163089
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result = [];\n    foreach(string s; lst) \n    {\n        if(s.length % 2 == 0) \n        {\n            result ~= s;\n        }\n    }\n    sort(result);\n    return result;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpmbkzpyxs.d(31): Error: undefined identifier `sort`, did you mean function `sqrt`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmbkzpyxs.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163089
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result = [];\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpdg0eu_3w.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x429285]\n??:? void tmpdg0eu_3w.__unittest_L33_C1() [0x427e57]\n??:? void tmpdg0eu_3w.__modtest() [0x4284ec]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42e54b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428fde]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42b3f9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42b488]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42b385]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428fb5]\n??:? runModuleUnitTests [0x42e321]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4296d4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    int[] lst_len = new int[lst.length];\n    foreach(int i, string s; lst)\n    {\n        lst_len[i] = s.length;\n    }\n    int[] lst_len_sorted = lst_len.dup;\n    lst_len_sorted.sort;\n    string[] lst_sorted = new string[lst.length];\n    foreach(int i, int j; lst_len_sorted)\n    {\n        lst_sorted[i] = lst[j];\n    }\n    return lst_sorted;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpvutczpx0.d(26): Error: cannot implicitly convert expression `s.length` of type `ulong` to `int`\n/tmp/tmpvutczpx0.d(29): Error: no property `sort` for type `int[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvutczpx0.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163089
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result = [];\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpdg0eu_3w.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x429285]\n??:? void tmpdg0eu_3w.__unittest_L33_C1() [0x427e57]\n??:? void tmpdg0eu_3w.__modtest() [0x4284ec]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42e54b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428fde]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42b3f9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42b488]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42b385]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428fb5]\n??:? runModuleUnitTests [0x42e321]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4296d4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result = [];\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpdg0eu_3w.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x429285]\n??:? void tmpdg0eu_3w.__unittest_L33_C1() [0x427e57]\n??:? void tmpdg0eu_3w.__modtest() [0x4284ec]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42e54b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428fde]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42b3f9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42b488]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42b385]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428fb5]\n??:? runModuleUnitTests [0x42e321]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4296d4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    int[] lengths = new int[lst.length];\n    foreach(i, item; lst)\n    {\n        lengths[i] = item.length;\n    }\n    int[] sorted_lengths = sort(lengths);\n    string[] result = new string[sorted_lengths.length];\n    foreach(i, item; sorted_lengths)\n    {\n        foreach(j, item2; lst)\n        {\n            if(item == item2.length)\n            {\n                result[i] = item2;\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmppifsjtdt.d(26): Error: cannot implicitly convert expression `item.length` of type `ulong` to `int`\n/tmp/tmppifsjtdt.d(28): Error: undefined identifier `sort`, did you mean function `sqrt`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppifsjtdt.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163089
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result = [];\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpdg0eu_3w.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x429285]\n??:? void tmpdg0eu_3w.__unittest_L33_C1() [0x427e57]\n??:? void tmpdg0eu_3w.__modtest() [0x4284ec]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42e54b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428fde]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42b3f9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42b488]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42b385]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428fb5]\n??:? runModuleUnitTests [0x42e321]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4296d4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    lst = lst.filter!(a => a.length % 2 == 0).sort!((a, b) => a.length < b.length);\n    return lst;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpn5et5gcm.d(23): Error: no property `filter` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpn5et5gcm.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163089
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result = [];\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpdg0eu_3w.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x429285]\n??:? void tmpdg0eu_3w.__unittest_L33_C1() [0x427e57]\n??:? void tmpdg0eu_3w.__modtest() [0x4284ec]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42e54b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428fde]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42b3f9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42b488]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42b385]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428fb5]\n??:? runModuleUnitTests [0x42e321]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4296d4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result = new string[0];\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    return result.sort;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpfrq1omlm.d(31): Error: no property `sort` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfrq1omlm.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163089
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result;\n    int[] sum;\n    foreach(string s; lst)\n    {\n        int sum_s = 0;\n        foreach(char c; s)\n        {\n            sum_s += c;\n        }\n        sum ~= sum_s;\n    }\n    sort(sum);\n    foreach(int s; sum)\n    {\n        foreach(string ss; lst)\n        {\n            int sum_ss = 0;\n            foreach(char c; ss)\n            {\n                sum_ss += c;\n            }\n            if(s == sum_ss)\n            {\n                result ~= ss;\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp_dragazm.d(34): Error: undefined identifier `sort`, did you mean function `sqrt`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_dragazm.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163089
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result;\n    foreach(string s; lst) \n    {\n        if(s.length % 2 == 0) \n        {\n            result ~= s;\n        }\n    }\n    return result.sort();\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpjx4p6zud.d(31): Error: no property `sort` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjx4p6zud.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163089
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] new_list;\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            new_list ~= s;\n        }\n    }\n    return new_list.sort;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp6gumqqj7.d(31): Error: no property `sort` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6gumqqj7.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result = [];\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    sort(result);\n    return result;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpa999f_u7.d(31): Error: undefined identifier `sort`, did you mean function `sqrt`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpa999f_u7.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163089
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result;\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    return result.sort;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp1krbhn5f.d(31): Error: no property `sort` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1krbhn5f.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163089
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result;\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    return result.sort;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp1krbhn5f.d(31): Error: no property `sort` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1krbhn5f.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163089
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result;\n    foreach(string s; lst) \n    {\n        if(s.length % 2 == 0) \n        {\n            result ~= s;\n        }\n    }\n    return result.sort;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp80dj_jib.d(31): Error: no property `sort` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp80dj_jib.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163089
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result = [];\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpdg0eu_3w.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x429285]\n??:? void tmpdg0eu_3w.__unittest_L33_C1() [0x427e57]\n??:? void tmpdg0eu_3w.__modtest() [0x4284ec]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42e54b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428fde]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42b3f9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42b488]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42b385]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428fb5]\n??:? runModuleUnitTests [0x42e321]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4296d4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result;\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    return result.sort;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp1krbhn5f.d(31): Error: no property `sort` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1krbhn5f.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163089
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result;\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    return result.sort;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp1krbhn5f.d(31): Error: no property `sort` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1krbhn5f.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163089
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result;\n    foreach(string s; lst) \n    {\n        if(s.length % 2 == 0) \n        {\n            result ~= s;\n        }\n    }\n    return result.sort;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp80dj_jib.d(31): Error: no property `sort` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp80dj_jib.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163089
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result;\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    return result.sort;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp1krbhn5f.d(31): Error: no property `sort` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1krbhn5f.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163089
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] new_lst;\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            new_lst ~= s;\n        }\n    }\n    new_lst.sort;\n    return new_lst;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpw73u5ioq.d(31): Error: no property `sort` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpw73u5ioq.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] res;\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            res ~= s;\n        }\n    }\n    sort(res);\n    return res;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp2o3verza.d(31): Error: undefined identifier `sort`, did you mean function `sqrt`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2o3verza.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result = [];\n    foreach(string s; lst) \n    {\n        if(s.length % 2 == 0) \n        {\n            result ~= s;\n        }\n    }\n    return result.sort;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpzysb44te.d(31): Error: no property `sort` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpzysb44te.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163089
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result = [];\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpdg0eu_3w.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x429285]\n??:? void tmpdg0eu_3w.__unittest_L33_C1() [0x427e57]\n??:? void tmpdg0eu_3w.__modtest() [0x4284ec]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42e54b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428fde]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42b3f9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42b488]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42b385]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428fb5]\n??:? runModuleUnitTests [0x42e321]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4296d4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result;\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    return result.sort;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp1krbhn5f.d(31): Error: no property `sort` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1krbhn5f.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163089
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result = [];\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpdg0eu_3w.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x429285]\n??:? void tmpdg0eu_3w.__unittest_L33_C1() [0x427e57]\n??:? void tmpdg0eu_3w.__modtest() [0x4284ec]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42e54b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428fde]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42b3f9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42b488]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42b385]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428fb5]\n??:? runModuleUnitTests [0x42e321]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4296d4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result = [];\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpdg0eu_3w.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x429285]\n??:? void tmpdg0eu_3w.__unittest_L33_C1() [0x427e57]\n??:? void tmpdg0eu_3w.__modtest() [0x4284ec]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42e54b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428fde]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42b3f9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42b488]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42b385]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428fb5]\n??:? runModuleUnitTests [0x42e321]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4296d4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result = [];\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpdg0eu_3w.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x429285]\n??:? void tmpdg0eu_3w.__unittest_L33_C1() [0x427e57]\n??:? void tmpdg0eu_3w.__modtest() [0x4284ec]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42e54b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428fde]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42b3f9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42b488]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42b385]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428fb5]\n??:? runModuleUnitTests [0x42e321]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4296d4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result;\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    return result.sort;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp1krbhn5f.d(31): Error: no property `sort` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1krbhn5f.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163089
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result = [];\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpdg0eu_3w.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x429285]\n??:? void tmpdg0eu_3w.__unittest_L33_C1() [0x427e57]\n??:? void tmpdg0eu_3w.__modtest() [0x4284ec]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42e54b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428fde]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42b3f9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42b488]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42b385]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428fb5]\n??:? runModuleUnitTests [0x42e321]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4296d4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result = new string[0];\n    string[] temp = new string[0];\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n        else\n        {\n            temp ~= s;\n        }\n    }\n    result = result.sort;\n    temp = temp.sort;\n    result ~= temp;\n    return result;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmprq3rblor.d(36): Error: no property `sort` for type `string[]`\n/tmp/tmprq3rblor.d(37): Error: no property `sort` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprq3rblor.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] res = [];\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            res ~= s;\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpbec3a4c6.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x429285]\n??:? void tmpbec3a4c6.__unittest_L33_C1() [0x427e57]\n??:? void tmpbec3a4c6.__modtest() [0x4284ec]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42e54b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428fde]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42b3f9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42b488]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42b385]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428fb5]\n??:? runModuleUnitTests [0x42e321]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4296d4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result;\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    return result.sort;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp1krbhn5f.d(31): Error: no property `sort` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1krbhn5f.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163089
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] new_list;\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            new_list ~= s;\n        }\n    }\n    return new_list.sort();\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpke7t17dp.d(31): Error: no property `sort` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpke7t17dp.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result;\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    return result.sort;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp1krbhn5f.d(31): Error: no property `sort` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1krbhn5f.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163089
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result = [];\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpdg0eu_3w.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x429285]\n??:? void tmpdg0eu_3w.__unittest_L33_C1() [0x427e57]\n??:? void tmpdg0eu_3w.__modtest() [0x4284ec]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42e54b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428fde]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42b3f9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42b488]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42b385]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428fb5]\n??:? runModuleUnitTests [0x42e321]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4296d4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result;\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    return result.sort;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp1krbhn5f.d(31): Error: no property `sort` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1krbhn5f.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163089
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result = new string[0];\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    return result.sort;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpfrq1omlm.d(31): Error: no property `sort` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfrq1omlm.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163089
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result = [];\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpdg0eu_3w.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x429285]\n??:? void tmpdg0eu_3w.__unittest_L33_C1() [0x427e57]\n??:? void tmpdg0eu_3w.__modtest() [0x4284ec]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42e54b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428fde]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42b3f9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42b488]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42b385]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428fb5]\n??:? runModuleUnitTests [0x42e321]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4296d4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result = [];\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    sort(result);\n    return result;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpa999f_u7.d(31): Error: undefined identifier `sort`, did you mean function `sqrt`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpa999f_u7.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163089
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result = [];\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpdg0eu_3w.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x429285]\n??:? void tmpdg0eu_3w.__unittest_L33_C1() [0x427e57]\n??:? void tmpdg0eu_3w.__modtest() [0x4284ec]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42e54b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428fde]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42b3f9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42b488]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42b385]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428fb5]\n??:? runModuleUnitTests [0x42e321]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4296d4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result = [];\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpdg0eu_3w.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x429285]\n??:? void tmpdg0eu_3w.__unittest_L33_C1() [0x427e57]\n??:? void tmpdg0eu_3w.__modtest() [0x4284ec]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42e54b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428fde]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42b3f9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42b488]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42b385]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428fb5]\n??:? runModuleUnitTests [0x42e321]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4296d4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result;\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    return result.sort();\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpsowl3_3x.d(31): Error: no property `sort` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpsowl3_3x.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163089
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result;\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    return result.sort();\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpsowl3_3x.d(31): Error: no property `sort` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpsowl3_3x.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163089
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] temp = new string[0];\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            temp ~= s;\n        }\n    }\n    return temp.sort;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpy5gqx5m9.d(31): Error: no property `sort` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpy5gqx5m9.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result;\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    return result.sort;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp1krbhn5f.d(31): Error: no property `sort` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1krbhn5f.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163089
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result = [];\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpdg0eu_3w.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x429285]\n??:? void tmpdg0eu_3w.__unittest_L33_C1() [0x427e57]\n??:? void tmpdg0eu_3w.__modtest() [0x4284ec]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42e54b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428fde]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42b3f9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42b488]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42b385]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428fb5]\n??:? runModuleUnitTests [0x42e321]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4296d4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result = [];\n    int[] sum = [];\n    foreach(string s; lst)\n    {\n        int total = 0;\n        foreach(char c; s)\n        {\n            total += c;\n        }\n        sum ~= total;\n    }\n    int[] sorted_sum = sort(sum);\n    foreach(int s; sorted_sum)\n    {\n        foreach(string str; lst)\n        {\n            int total = 0;\n            foreach(char c; str)\n            {\n                total += c;\n            }\n            if(total == s)\n            {\n                result ~= str;\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpiq_j5ee_.d(34): Error: undefined identifier `sort`, did you mean function `sqrt`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpiq_j5ee_.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result = [];\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpdg0eu_3w.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x429285]\n??:? void tmpdg0eu_3w.__unittest_L33_C1() [0x427e57]\n??:? void tmpdg0eu_3w.__modtest() [0x4284ec]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42e54b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428fde]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42b3f9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42b488]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42b385]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428fb5]\n??:? runModuleUnitTests [0x42e321]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4296d4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result = [];\n    foreach(string s; lst) \n    {\n        if(s.length % 2 == 0) \n        {\n            result ~= s;\n        }\n    }\n    sort(result);\n    return result;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpmbkzpyxs.d(31): Error: undefined identifier `sort`, did you mean function `sqrt`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmbkzpyxs.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163089
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result = [];\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpdg0eu_3w.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x429285]\n??:? void tmpdg0eu_3w.__unittest_L33_C1() [0x427e57]\n??:? void tmpdg0eu_3w.__modtest() [0x4284ec]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42e54b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428fde]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42b3f9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42b488]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42b385]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428fb5]\n??:? runModuleUnitTests [0x42e321]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4296d4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result;\n    foreach(string s; lst) \n    {\n        if (s.length % 2 == 0) \n        {\n            result ~= s;\n        }\n    }\n    return result.sort;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp5uwh_j4x.d(31): Error: no property `sort` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5uwh_j4x.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result = [];\n    foreach(string s; lst) \n    {\n        if(s.length % 2 == 0) \n        {\n            result ~= s;\n        }\n    }\n    sort(result);\n    return result;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpmbkzpyxs.d(31): Error: undefined identifier `sort`, did you mean function `sqrt`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmbkzpyxs.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163089
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] temp = new string[0];\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            temp ~= s;\n        }\n    }\n    return temp.sort();\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpq28o6dcf.d(31): Error: no property `sort` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpq28o6dcf.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    lst = lst.filter!(a => a.length % 2 == 0).sort!((a, b) => a.length < b.length);\n    return lst;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpn5et5gcm.d(23): Error: no property `filter` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpn5et5gcm.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163089
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result;\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    return result.sort;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp1krbhn5f.d(31): Error: no property `sort` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1krbhn5f.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163089
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    int[] lengths = new int[lst.length];\n    foreach(i, ref element; lst)\n    {\n        lengths[i] = element.length;\n    }\n    int[] sorted_lengths = sort(lengths);\n    string[] sorted_lst = new string[lst.length];\n    foreach(i, ref element; lst)\n    {\n        sorted_lst[i] = element;\n    }\n    foreach(i, ref element; sorted_lst)\n    {\n        if(element.length != sorted_lengths[0])\n        {\n            sorted_lst[i] = \"\";\n        }\n    }\n    return sorted_lst;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpct25fkdp.d(26): Error: cannot implicitly convert expression `element.length` of type `ulong` to `int`\n/tmp/tmpct25fkdp.d(28): Error: undefined identifier `sort`, did you mean function `sqrt`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpct25fkdp.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    int[] lst_len = new int[lst.length];\n    string[] lst_sorted = new string[lst.length];\n    int[] lst_sorted_len = new int[lst.length];\n    int i = 0;\n    foreach(string s; lst)\n    {\n        lst_len[i] = s.length;\n        i++;\n    }\n    i = 0;\n    foreach(int n; lst_len)\n    {\n        if(n % 2 == 0)\n        {\n            lst_sorted_len[i] = n;\n            i++;\n        }\n    }\n    i = 0;\n    foreach(int n; lst_sorted_len)\n    {\n        foreach(string s; lst)\n        {\n            if(s.length == n)\n            {\n                lst_sorted[i] = s;\n                i++;\n            }\n        }\n    }\n    return lst_sorted;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp9otazptn.d(29): Error: cannot implicitly convert expression `s.length` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9otazptn.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result;\n    int[] sum;\n    foreach(string s; lst)\n    {\n        sum ~= s.length;\n    }\n    int[] index = sort(sum);\n    foreach(int i; index)\n    {\n        result ~= lst[i];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp6u50yetz.d(27): Error: cannot append type `ulong` to type `int[]`\n/tmp/tmp6u50yetz.d(29): Error: undefined identifier `sort`, did you mean function `sqrt`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6u50yetz.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result = [];\n    int[] length_list = [];\n    foreach(string s; lst)\n    {\n        length_list ~= s.length;\n    }\n    length_list = sort(length_list);\n    int length = length_list[0];\n    foreach(string s; lst)\n    {\n        if(s.length == length)\n        {\n            result ~= s;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpcoy4djjo.d(27): Error: cannot append type `ulong` to type `int[]`\n/tmp/tmpcoy4djjo.d(29): Error: undefined identifier `sort`, did you mean function `sqrt`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcoy4djjo.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result = [];\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpdg0eu_3w.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x429285]\n??:? void tmpdg0eu_3w.__unittest_L33_C1() [0x427e57]\n??:? void tmpdg0eu_3w.__modtest() [0x4284ec]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42e54b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428fde]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42b3f9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42b488]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42b385]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428fb5]\n??:? runModuleUnitTests [0x42e321]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4296d4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result = [];\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpdg0eu_3w.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x429285]\n??:? void tmpdg0eu_3w.__unittest_L33_C1() [0x427e57]\n??:? void tmpdg0eu_3w.__modtest() [0x4284ec]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42e54b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428fde]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42b3f9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42b488]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42b385]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428fb5]\n??:? runModuleUnitTests [0x42e321]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4296d4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result = [];\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpdg0eu_3w.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x429285]\n??:? void tmpdg0eu_3w.__unittest_L33_C1() [0x427e57]\n??:? void tmpdg0eu_3w.__modtest() [0x4284ec]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42e54b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428fde]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42b3f9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42b488]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42b385]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428fb5]\n??:? runModuleUnitTests [0x42e321]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4296d4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    //int[] lst_len = new int[lst.length];\n    string[] lst_len = new string[lst.length];\n    int[] lst_len_int = new int[lst.length];\n    int[] lst_len_int_sorted = new int[lst.length];\n    string[] lst_len_sorted = new string[lst.length];\n    string[] lst_len_sorted_final = new string[lst.length];\n    int[] lst_len_sorted_final_int = new int[lst.length];\n    int[] lst_len_sorted_final_int_sorted = new int[lst.length];\n    string[] lst_len_sorted_final_sorted = new string[lst.length];\n    int[] lst_len_sorted_final_sorted_int = new int[lst.length];\n    int[] lst_len_sorted_final_sorted_int_sorted = new int[lst.length];\n    string[] lst_len_sorted_final_sorted_sorted = new string[lst.length];\n    int[] lst_len_sorted_final_sorted_sorted_int = new int[lst.length];\n    int[] lst_len_sorted_final_sorted_sorted_int_sorted = new int[lst.length];\n    string[] lst_len_sorted_final_sorted_sorted_sorted = new string[lst.length];\n    int[] lst_len_sorted_final_sorted_sorted_sorted_int = new int[lst.length];\n    int[] lst_len_sorted_final_sorted_sorted_sorted_int_sorted = new int[lst.length];\n    string[] lst_len_sorted_final_sorted_sorted_sorted_sorted = new string[lst.length];\n    int[] lst_len_sorted_final_sorted_sorted_sorted_sorted_int = new int[lst.\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpebrczqhj.d(42): Error: identifier expected following `.`, not `unittest`\n/tmp/tmpebrczqhj.d(43): Error: found `{` when expecting `]`\n/tmp/tmpebrczqhj.d(44): Error: semicolon expected, not `alias`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpebrczqhj.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result;\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    return result.sort;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp1krbhn5f.d(31): Error: no property `sort` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1krbhn5f.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163089
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    lst = lst.filter!(a => a.length % 2 == 0);\n    lst.sort!((a, b) => a.length - b.length);\n    return lst;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpzqne8t6c.d(23): Error: no property `filter` for type `string[]`\n/tmp/tmpzqne8t6c.d(24): Error: no property `sort` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpzqne8t6c.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result;\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    sort(result);\n    return result;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp_tyj3cla.d(31): Error: undefined identifier `sort`, did you mean function `sqrt`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_tyj3cla.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result;\n    foreach(string s; lst)\n    {\n        if (s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpve256rpr.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x429275]\n??:? void tmpve256rpr.__unittest_L33_C1() [0x427e4b]\n??:? void tmpve256rpr.__modtest() [0x4284e0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42e53b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428fce]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42b3e9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42b478]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42b375]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428fa5]\n??:? runModuleUnitTests [0x42e311]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4296c4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result = new string[0];\n    foreach(string s; lst) \n    {\n        if(s.length % 2 == 0) \n        {\n            result ~= s;\n        }\n    }\n    return result.sort();\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpmlat0u8v.d(31): Error: no property `sort` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmlat0u8v.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result = [];\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpdg0eu_3w.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x429285]\n??:? void tmpdg0eu_3w.__unittest_L33_C1() [0x427e57]\n??:? void tmpdg0eu_3w.__modtest() [0x4284ec]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42e54b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428fde]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42b3f9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42b488]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42b385]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428fb5]\n??:? runModuleUnitTests [0x42e321]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4296d4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result;\n    foreach(string s; lst)\n    {\n        if (s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpve256rpr.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x429275]\n??:? void tmpve256rpr.__unittest_L33_C1() [0x427e4b]\n??:? void tmpve256rpr.__modtest() [0x4284e0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42e53b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428fce]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42b3e9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42b478]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42b375]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428fa5]\n??:? runModuleUnitTests [0x42e311]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4296c4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result = [];\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpdg0eu_3w.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x429285]\n??:? void tmpdg0eu_3w.__unittest_L33_C1() [0x427e57]\n??:? void tmpdg0eu_3w.__modtest() [0x4284ec]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42e54b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428fde]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42b3f9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42b488]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42b385]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428fb5]\n??:? runModuleUnitTests [0x42e321]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4296d4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result;\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    return result.sort;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp1krbhn5f.d(31): Error: no property `sort` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1krbhn5f.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163089
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result = [];\n    foreach(string s; lst) \n    {\n        if (s.length % 2 == 0) \n        {\n            result ~= s;\n        }\n    }\n    sort(result);\n    return result;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpid66lp8s.d(31): Error: undefined identifier `sort`, did you mean function `sqrt`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpid66lp8s.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result = new string[0];\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    return result.sort;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpfrq1omlm.d(31): Error: no property `sort` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfrq1omlm.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163089
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result = [];\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpdg0eu_3w.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x429285]\n??:? void tmpdg0eu_3w.__unittest_L33_C1() [0x427e57]\n??:? void tmpdg0eu_3w.__modtest() [0x4284ec]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42e54b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428fde]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42b3f9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42b488]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42b385]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428fb5]\n??:? runModuleUnitTests [0x42e321]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4296d4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result = [];\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpdg0eu_3w.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x429285]\n??:? void tmpdg0eu_3w.__unittest_L33_C1() [0x427e57]\n??:? void tmpdg0eu_3w.__modtest() [0x4284ec]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42e54b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428fde]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42b3f9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42b488]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42b385]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428fb5]\n??:? runModuleUnitTests [0x42e321]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4296d4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result = [];\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpdg0eu_3w.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x429285]\n??:? void tmpdg0eu_3w.__unittest_L33_C1() [0x427e57]\n??:? void tmpdg0eu_3w.__modtest() [0x4284ec]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42e54b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428fde]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42b3f9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42b488]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42b385]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428fb5]\n??:? runModuleUnitTests [0x42e321]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4296d4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result;\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    return result.sort;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp1krbhn5f.d(31): Error: no property `sort` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1krbhn5f.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163089
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result = [];\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    sort(result);\n    return result;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpa999f_u7.d(31): Error: undefined identifier `sort`, did you mean function `sqrt`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpa999f_u7.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163089
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result = [];\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpdg0eu_3w.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x429285]\n??:? void tmpdg0eu_3w.__unittest_L33_C1() [0x427e57]\n??:? void tmpdg0eu_3w.__modtest() [0x4284ec]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42e54b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428fde]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42b3f9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42b488]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42b385]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428fb5]\n??:? runModuleUnitTests [0x42e321]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4296d4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result = [];\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpdg0eu_3w.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x429285]\n??:? void tmpdg0eu_3w.__unittest_L33_C1() [0x427e57]\n??:? void tmpdg0eu_3w.__modtest() [0x4284ec]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42e54b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428fde]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42b3f9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42b488]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42b385]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428fb5]\n??:? runModuleUnitTests [0x42e321]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4296d4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result = [];\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpdg0eu_3w.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x429285]\n??:? void tmpdg0eu_3w.__unittest_L33_C1() [0x427e57]\n??:? void tmpdg0eu_3w.__modtest() [0x4284ec]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42e54b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428fde]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42b3f9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42b488]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42b385]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428fb5]\n??:? runModuleUnitTests [0x42e321]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4296d4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result;\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    return result.sort;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp1krbhn5f.d(31): Error: no property `sort` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1krbhn5f.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163089
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result = [];\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    sort(result);\n    return result;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpa999f_u7.d(31): Error: undefined identifier `sort`, did you mean function `sqrt`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpa999f_u7.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163089
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result = [];\n    foreach(string word; lst)\n    {\n        if(word.length % 2 == 0)\n        {\n            result ~= word;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmps3bw95hf.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x429285]\n??:? void tmps3bw95hf.__unittest_L33_C1() [0x427e57]\n??:? void tmps3bw95hf.__modtest() [0x4284ec]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42e54b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428fde]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42b3f9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42b488]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42b385]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428fb5]\n??:? runModuleUnitTests [0x42e321]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4296d4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result = [];\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpdg0eu_3w.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x429285]\n??:? void tmpdg0eu_3w.__unittest_L33_C1() [0x427e57]\n??:? void tmpdg0eu_3w.__modtest() [0x4284ec]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42e54b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428fde]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42b3f9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42b488]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42b385]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428fb5]\n??:? runModuleUnitTests [0x42e321]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4296d4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result;\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    return result.sort;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp1krbhn5f.d(31): Error: no property `sort` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1krbhn5f.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163089
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result;\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    return result.sort;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp1krbhn5f.d(31): Error: no property `sort` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1krbhn5f.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163089
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] new_lst;\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            new_lst ~= s;\n        }\n    }\n    return new_lst;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp29ox6zmh.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x429275]\n??:? void tmp29ox6zmh.__unittest_L33_C1() [0x427e4b]\n??:? void tmp29ox6zmh.__modtest() [0x4284e0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42e53b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428fce]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42b3e9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42b478]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42b375]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428fa5]\n??:? runModuleUnitTests [0x42e311]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4296c4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result;\n    int[] sum;\n    foreach(string s; lst)\n    {\n        int sum_of_string = 0;\n        foreach(char c; s)\n        {\n            sum_of_string += c;\n        }\n        sum ~= sum_of_string;\n    }\n    int[] sorted_sum = sort(sum);\n    foreach(int i; sorted_sum)\n    {\n        foreach(string s; lst)\n        {\n            int sum_of_string = 0;\n            foreach(char c; s)\n            {\n                sum_of_string += c;\n            }\n            if(sum_of_string == i)\n            {\n                result ~= s;\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp4ericsfn.d(34): Error: undefined identifier `sort`, did you mean function `sqrt`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4ericsfn.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result = [];\n    int[] sum = [];\n    foreach(string s; lst)\n    {\n        int sum_s = 0;\n        foreach(char c; s)\n        {\n            sum_s += c;\n        }\n        sum ~= sum_s;\n    }\n    int[] sorted_sum = sort(sum);\n    foreach(int s; sorted_sum)\n    {\n        foreach(string ss; lst)\n        {\n            int sum_ss = 0;\n            foreach(char c; ss)\n            {\n                sum_ss += c;\n            }\n            if(s == sum_ss)\n            {\n                result ~= ss;\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpv9ug50jq.d(34): Error: undefined identifier `sort`, did you mean function `sqrt`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpv9ug50jq.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result = new string[0];\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    return result.sort();\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp3v4u7exy.d(31): Error: no property `sort` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3v4u7exy.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163089
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result;\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    sort(result);\n    return result;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp_tyj3cla.d(31): Error: undefined identifier `sort`, did you mean function `sqrt`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_tyj3cla.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result = new string[];\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp1nqabp2a.d(23): Error: new can only create structs, dynamic arrays or class objects, not `string[]`'s\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1nqabp2a.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    lst = lst.filter!(a => a.length % 2 == 0).sort!((a, b) => a.length - b.length);\n    return lst;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmptfhs11qr.d(23): Error: no property `filter` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmptfhs11qr.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result;\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    return result.sort;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp1krbhn5f.d(31): Error: no property `sort` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1krbhn5f.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163089
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result = [];\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    sort(result);\n    return result;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpa999f_u7.d(31): Error: undefined identifier `sort`, did you mean function `sqrt`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpa999f_u7.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163089
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result = [];\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpdg0eu_3w.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x429285]\n??:? void tmpdg0eu_3w.__unittest_L33_C1() [0x427e57]\n??:? void tmpdg0eu_3w.__modtest() [0x4284ec]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42e54b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428fde]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42b3f9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42b488]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42b385]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428fb5]\n??:? runModuleUnitTests [0x42e321]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4296d4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result = [];\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpdg0eu_3w.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x429285]\n??:? void tmpdg0eu_3w.__unittest_L33_C1() [0x427e57]\n??:? void tmpdg0eu_3w.__modtest() [0x4284ec]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42e54b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428fde]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42b3f9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42b488]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42b385]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428fb5]\n??:? runModuleUnitTests [0x42e321]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4296d4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] lst_sorted = lst.sort();\n    string[] lst_sorted_sum = [];\n    foreach(string s; lst_sorted)\n    {\n        if(s.length % 2 == 0)\n        {\n            lst_sorted_sum ~= s;\n        }\n    }\n    return lst_sorted_sum;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmptrwfft6d.d(23): Error: no property `sort` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmptrwfft6d.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result = [];\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpdg0eu_3w.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x429285]\n??:? void tmpdg0eu_3w.__unittest_L33_C1() [0x427e57]\n??:? void tmpdg0eu_3w.__modtest() [0x4284ec]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42e54b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428fde]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42b3f9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42b488]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42b385]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428fb5]\n??:? runModuleUnitTests [0x42e321]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4296d4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] res;\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            res ~= s;\n        }\n    }\n    res.sort();\n    return res;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpggq0pp2h.d(31): Error: no property `sort` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpggq0pp2h.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result = [];\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpdg0eu_3w.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x429285]\n??:? void tmpdg0eu_3w.__unittest_L33_C1() [0x427e57]\n??:? void tmpdg0eu_3w.__modtest() [0x4284ec]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42e54b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428fde]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42b3f9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42b488]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42b385]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428fb5]\n??:? runModuleUnitTests [0x42e321]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4296d4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result = [];\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    sort(result);\n    return result;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpa999f_u7.d(31): Error: undefined identifier `sort`, did you mean function `sqrt`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpa999f_u7.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163089
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result = new string[lst.length];\n    int j = 0;\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result[j] = s;\n            j++;\n        }\n    }\n    return result[0..j];\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpfdo4r88s.d(40): unittest failure\n----------------\n??:? _d_unittestp [0x4292a5]\n??:? void tmpfdo4r88s.__unittest_L35_C1() [0x427e7b]\n??:? void tmpfdo4r88s.__modtest() [0x428510]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42dc4f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428ffe]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42aafd]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ab8c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42aa89]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428fd5]\n??:? runModuleUnitTests [0x42da25]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429768]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result;\n    foreach(string i; lst)\n    {\n        if(i.length % 2 == 0)\n        {\n            result ~= i;\n        }\n    }\n    sort(result);\n    return result;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpyyaoup_c.d(31): Error: undefined identifier `sort`, did you mean function `sqrt`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpyyaoup_c.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result = [];\n    foreach(string s; lst) \n    {\n        if(s.length % 2 == 0) \n        {\n            result ~= s;\n        }\n    }\n    sort(result);\n    return result;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpmbkzpyxs.d(31): Error: undefined identifier `sort`, did you mean function `sqrt`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmbkzpyxs.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163089
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result;\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    sort(result);\n    return result;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp_tyj3cla.d(31): Error: undefined identifier `sort`, did you mean function `sqrt`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_tyj3cla.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] new_list;\n    int[] sum_list;\n    foreach(string str; lst)\n    {\n        int sum = 0;\n        foreach(char c; str)\n        {\n            sum += c;\n        }\n        sum_list ~= sum;\n    }\n    sort(sum_list);\n    foreach(int sum; sum_list)\n    {\n        foreach(string str; lst)\n        {\n            int sum_str = 0;\n            foreach(char c; str)\n            {\n                sum_str += c;\n            }\n            if(sum == sum_str)\n            {\n                new_list ~= str;\n            }\n        }\n    }\n    return new_list;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpmxxm8nmj.d(34): Error: undefined identifier `sort`, did you mean function `sqrt`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmxxm8nmj.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result;\n    foreach(string s; lst) \n    {\n        if(s.length % 2 == 0) \n        {\n            result ~= s;\n        }\n    }\n    return result.sort;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp80dj_jib.d(31): Error: no property `sort` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp80dj_jib.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163089
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result = [];\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpdg0eu_3w.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x429285]\n??:? void tmpdg0eu_3w.__unittest_L33_C1() [0x427e57]\n??:? void tmpdg0eu_3w.__modtest() [0x4284ec]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42e54b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428fde]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42b3f9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42b488]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42b385]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428fb5]\n??:? runModuleUnitTests [0x42e321]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4296d4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result;\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    return result.sort;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp1krbhn5f.d(31): Error: no property `sort` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1krbhn5f.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163089
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result;\n    foreach(string str; lst)\n    {\n        if(str.length % 2 == 0)\n        {\n            result ~= str;\n        }\n    }\n    return result.sort();\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpj9zlz835.d(31): Error: no property `sort` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpj9zlz835.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result;\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    return result.sort;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp1krbhn5f.d(31): Error: no property `sort` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1krbhn5f.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163089
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result;\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    return result.sort;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp1krbhn5f.d(31): Error: no property `sort` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1krbhn5f.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163089
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result = [];\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    sort(result);\n    return result;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpa999f_u7.d(31): Error: undefined identifier `sort`, did you mean function `sqrt`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpa999f_u7.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163089
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result = new string[0];\n    foreach(string s; lst) \n    {\n        if(s.length % 2 == 0) \n        {\n            result ~= s;\n        }\n    }\n    return result.sort();\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpmlat0u8v.d(31): Error: no property `sort` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmlat0u8v.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    auto lst_len = lst.length;\n    string[] result;\n    foreach(i; 0..lst_len)\n    {\n        if(lst[i].length % 2 == 0)\n        {\n            result ~= lst[i];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpurdj0_ov.d(39): unittest failure\n----------------\n??:? _d_unittestp [0x4292bd]\n??:? void tmpurdj0_ov.__unittest_L34_C1() [0x427e8f]\n??:? void tmpurdj0_ov.__modtest() [0x428524]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42e5f7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x429016]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42b4a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42b534]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42b431]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428fed]\n??:? runModuleUnitTests [0x42e3cd]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429780]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] new_lst;\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            new_lst ~= s;\n        }\n    }\n    new_lst.sort;\n    return new_lst;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpw73u5ioq.d(31): Error: no property `sort` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpw73u5ioq.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result = [];\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpdg0eu_3w.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x429285]\n??:? void tmpdg0eu_3w.__unittest_L33_C1() [0x427e57]\n??:? void tmpdg0eu_3w.__modtest() [0x4284ec]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42e54b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428fde]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42b3f9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42b488]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42b385]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428fb5]\n??:? runModuleUnitTests [0x42e321]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4296d4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result = [];\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpdg0eu_3w.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x429285]\n??:? void tmpdg0eu_3w.__unittest_L33_C1() [0x427e57]\n??:? void tmpdg0eu_3w.__modtest() [0x4284ec]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42e54b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428fde]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42b3f9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42b488]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42b385]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428fb5]\n??:? runModuleUnitTests [0x42e321]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4296d4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result = [];\n    foreach(string s; lst) \n    {\n        if (s.length % 2 == 0) \n        {\n            result ~= s;\n        }\n    }\n    return result.sort();\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpki3h_ijb.d(31): Error: no property `sort` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpki3h_ijb.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result = [];\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpdg0eu_3w.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x429285]\n??:? void tmpdg0eu_3w.__unittest_L33_C1() [0x427e57]\n??:? void tmpdg0eu_3w.__modtest() [0x4284ec]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42e54b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428fde]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42b3f9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42b488]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42b385]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428fb5]\n??:? runModuleUnitTests [0x42e321]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4296d4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result = [];\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpdg0eu_3w.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x429285]\n??:? void tmpdg0eu_3w.__unittest_L33_C1() [0x427e57]\n??:? void tmpdg0eu_3w.__modtest() [0x4284ec]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42e54b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428fde]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42b3f9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42b488]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42b385]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428fb5]\n??:? runModuleUnitTests [0x42e321]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4296d4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result;\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    return result.sort;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp1krbhn5f.d(31): Error: no property `sort` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1krbhn5f.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163089
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result = [];\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpdg0eu_3w.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x429285]\n??:? void tmpdg0eu_3w.__unittest_L33_C1() [0x427e57]\n??:? void tmpdg0eu_3w.__modtest() [0x4284ec]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42e54b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428fde]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42b3f9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42b488]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42b385]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428fb5]\n??:? runModuleUnitTests [0x42e321]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4296d4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result = new string[0];\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    return result.sort();\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp3v4u7exy.d(31): Error: no property `sort` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3v4u7exy.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163089
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result = new string[0];\n    foreach(string s; lst) \n    {\n        if(s.length % 2 == 0) \n        {\n            result ~= s;\n        }\n    }\n    return result.sort();\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpmlat0u8v.d(31): Error: no property `sort` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmlat0u8v.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result;\n    foreach(string s; lst)\n    {\n        if (s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpve256rpr.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x429275]\n??:? void tmpve256rpr.__unittest_L33_C1() [0x427e4b]\n??:? void tmpve256rpr.__modtest() [0x4284e0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42e53b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428fce]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42b3e9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42b478]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42b375]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428fa5]\n??:? runModuleUnitTests [0x42e311]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4296c4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result = [];\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpdg0eu_3w.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x429285]\n??:? void tmpdg0eu_3w.__unittest_L33_C1() [0x427e57]\n??:? void tmpdg0eu_3w.__modtest() [0x4284ec]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42e54b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428fde]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42b3f9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42b488]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42b385]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428fb5]\n??:? runModuleUnitTests [0x42e321]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4296d4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result;\n    int[] lengths;\n    foreach(string s; lst)\n    {\n        lengths ~= s.length;\n    }\n    sort(lengths);\n    foreach(int i; lengths)\n    {\n        foreach(string s; lst)\n        {\n            if(s.length == i)\n            {\n                result ~= s;\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp2yvrzubv.d(27): Error: cannot append type `ulong` to type `int[]`\n/tmp/tmp2yvrzubv.d(29): Error: undefined identifier `sort`, did you mean function `sqrt`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2yvrzubv.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result;\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    return result.sort;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp1krbhn5f.d(31): Error: no property `sort` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1krbhn5f.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163089
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] sorted_list = lst.sort();\n    string[] result;\n    foreach(string s; sorted_list) \n    {\n        if(s.length % 2 == 0) \n        {\n            result ~= s;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpevjbi_e4.d(23): Error: no property `sort` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpevjbi_e4.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result = [];\n    foreach(string s; lst) \n    {\n        if(s.length % 2 == 0) \n        {\n            result ~= s;\n        }\n    }\n    return result.sort;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpzysb44te.d(31): Error: no property `sort` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpzysb44te.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163089
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result = [];\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpdg0eu_3w.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x429285]\n??:? void tmpdg0eu_3w.__unittest_L33_C1() [0x427e57]\n??:? void tmpdg0eu_3w.__modtest() [0x4284ec]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42e54b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428fde]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42b3f9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42b488]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42b385]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428fb5]\n??:? runModuleUnitTests [0x42e321]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4296d4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] res = [];\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            res ~= s;\n        }\n    }\n    res.sort;\n    return res;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpzr5npxr8.d(31): Error: no property `sort` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpzr5npxr8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result = new string[0];\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpfm96gki4.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x42927d]\n??:? void tmpfm96gki4.__unittest_L33_C1() [0x427e4f]\n??:? void tmpfm96gki4.__modtest() [0x4284e4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42e59f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428fd6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42b44d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42b4dc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42b3d9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428fad]\n??:? runModuleUnitTests [0x42e375]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4296cc]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result = [];\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpdg0eu_3w.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x429285]\n??:? void tmpdg0eu_3w.__unittest_L33_C1() [0x427e57]\n??:? void tmpdg0eu_3w.__modtest() [0x4284ec]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42e54b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428fde]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42b3f9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42b488]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42b385]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428fb5]\n??:? runModuleUnitTests [0x42e321]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4296d4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    int[] lengths = lst.map!(a => a.length).array;\n    int[] lengths_sorted = lengths.sort();\n    int[] lengths_sorted_unique = lengths_sorted.uniq;\n    int[] lengths_sorted_unique_even = lengths_sorted_unique.filter!(a => a % 2 == 0);\n    string[] result = lst.filter!(a => lengths_sorted_unique_even.canFind(a.length));\n    return result;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpcf4_uexp.d(23): Error: no property `map` for type `string[]`\n/tmp/tmpcf4_uexp.d(24): Error: no property `sort` for type `int[]`\n/tmp/tmpcf4_uexp.d(25): Error: no property `uniq` for type `int[]`\n/tmp/tmpcf4_uexp.d(26): Error: no property `filter` for type `int[]`\n/tmp/tmpcf4_uexp.d(27): Error: no property `filter` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcf4_uexp.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    int[] lst_len = new int[lst.length];\n    foreach(i, e; lst)\n    {\n        lst_len[i] = e.length;\n    }\n    lst_len = lst_len.sort();\n    string[] lst_sorted = new string[lst.length];\n    foreach(i, e; lst_len)\n    {\n        foreach(j, f; lst)\n        {\n            if(e == f.length)\n            {\n                lst_sorted[i] = f;\n            }\n        }\n    }\n    return lst_sorted;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpp728tr79.d(26): Error: cannot implicitly convert expression `e.length` of type `ulong` to `int`\n/tmp/tmpp728tr79.d(28): Error: no property `sort` for type `int[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpp728tr79.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] res = [];\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            res ~= s;\n        }\n    }\n    res.sort;\n    return res;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpzr5npxr8.d(31): Error: no property `sort` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpzr5npxr8.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result;\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    return result.sort;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp1krbhn5f.d(31): Error: no property `sort` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1krbhn5f.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163089
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result = [];\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    result.sort;\n    return result;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpsw_slb_m.d(31): Error: no property `sort` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpsw_slb_m.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result = [];\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpdg0eu_3w.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x429285]\n??:? void tmpdg0eu_3w.__unittest_L33_C1() [0x427e57]\n??:? void tmpdg0eu_3w.__modtest() [0x4284ec]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42e54b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428fde]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42b3f9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42b488]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42b385]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428fb5]\n??:? runModuleUnitTests [0x42e321]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4296d4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result;\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    return result.sort();\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpsowl3_3x.d(31): Error: no property `sort` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpsowl3_3x.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163089
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result = [];\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpdg0eu_3w.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x429285]\n??:? void tmpdg0eu_3w.__unittest_L33_C1() [0x427e57]\n??:? void tmpdg0eu_3w.__modtest() [0x4284ec]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42e54b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428fde]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42b3f9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42b488]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42b385]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428fb5]\n??:? runModuleUnitTests [0x42e321]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4296d4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result;\n    foreach(string s; lst) \n    {\n        if(s.length % 2 == 0) \n        {\n            result ~= s;\n        }\n    }\n    return result.sort;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp80dj_jib.d(31): Error: no property `sort` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp80dj_jib.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163089
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result = [];\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpdg0eu_3w.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x429285]\n??:? void tmpdg0eu_3w.__unittest_L33_C1() [0x427e57]\n??:? void tmpdg0eu_3w.__modtest() [0x4284ec]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42e54b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428fde]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42b3f9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42b488]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42b385]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428fb5]\n??:? runModuleUnitTests [0x42e321]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4296d4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result = [];\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpdg0eu_3w.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x429285]\n??:? void tmpdg0eu_3w.__unittest_L33_C1() [0x427e57]\n??:? void tmpdg0eu_3w.__modtest() [0x4284ec]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42e54b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428fde]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42b3f9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42b488]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42b385]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428fb5]\n??:? runModuleUnitTests [0x42e321]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4296d4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result = [];\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpdg0eu_3w.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x429285]\n??:? void tmpdg0eu_3w.__unittest_L33_C1() [0x427e57]\n??:? void tmpdg0eu_3w.__modtest() [0x4284ec]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42e54b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428fde]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42b3f9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42b488]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42b385]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428fb5]\n??:? runModuleUnitTests [0x42e321]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4296d4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] res = new string[0];\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            res ~= s;\n        }\n    }\n    return res.sort;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpvah3_8re.d(31): Error: no property `sort` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvah3_8re.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result = [];\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpdg0eu_3w.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x429285]\n??:? void tmpdg0eu_3w.__unittest_L33_C1() [0x427e57]\n??:? void tmpdg0eu_3w.__modtest() [0x4284ec]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42e54b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428fde]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42b3f9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42b488]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42b385]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428fb5]\n??:? runModuleUnitTests [0x42e321]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4296d4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result = [];\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmpdg0eu_3w.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x429285]\n??:? void tmpdg0eu_3w.__unittest_L33_C1() [0x427e57]\n??:? void tmpdg0eu_3w.__modtest() [0x4284ec]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42e54b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x428fde]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42b3f9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42b488]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42b385]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428fb5]\n??:? runModuleUnitTests [0x42e321]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4296d4]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result;\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    sort(result);\n    return result;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp_tyj3cla.d(31): Error: undefined identifier `sort`, did you mean function `sqrt`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_tyj3cla.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result;\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    return result.sort;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp1krbhn5f.d(31): Error: no property `sort` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1krbhn5f.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163089
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result;\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    return result.sort;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp1krbhn5f.d(31): Error: no property `sort` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1krbhn5f.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163089
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result = new string[0];\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    return result.sort();\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp3v4u7exy.d(31): Error: no property `sort` for type `string[]`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3v4u7exy.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163089
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result;\n    int[] lengths;\n    int[] sorted_lengths;\n    int[] sorted_lengths_index;\n    int[] sorted_lengths_index_sorted;\n    int[] sorted_lengths_index_sorted_index;\n    int[] sorted_lengths_index_sorted_index_sorted;\n    int[] sorted_lengths_index_sorted_index_sorted_index;\n    int[] sorted_lengths_index_sorted_index_sorted_index_sorted;\n    int[] sorted_lengths_index_sorted_index_sorted_index_sorted_index;\n    int[] sorted_lengths_index_sorted_index_sorted_index_sorted_index_sorted;\n    int[] sorted_lengths_index_sorted_index_sorted_index_sorted_index_sorted_index;\n    int[] sorted_lengths_index_sorted_index_sorted_index_sorted_index_sorted_index_sorted;\n    int[] sorted_lengths_index_sorted_index_sorted_index_sorted_index_sorted_index_sorted_index;\n    int[] sorted_lengths_index_sorted_index_sorted_index_sorted_index_sorted_index_sorted_index_sorted;\n    int[] sorted_lengths_index_sorted_index_sorted_index_sorted_index_sorted_index_sorted_index_sorted_index;\n    int[] sorted_lengths_index_sorted_index_sorted_index_sorted_index_sorted_index_sorted_index_sorted_index_sorted;\n    int[] sorted_lengths_index_sorted_index_sorted_index_sorted_index_sorted_index_sorted_index_sorted_index_sorted_index;\n    int[] sorted_lengths_index_sorted_index_sorted_index_sorted_index_sorted_index_sorted_index_sorted_index_sorted_index_sorted;\n    int[] sorted_lengths_\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp7qv6ldke.d(43): Error: semicolon expected, not `unittest`\n/tmp/tmp7qv6ldke.d(43): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7qv6ldke.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result = [];\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    sort(result);\n    return result;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpa999f_u7.d(31): Error: undefined identifier `sort`, did you mean function `sqrt`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpa999f_u7.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163089
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result = [];\n    int[] lengths = [];\n    foreach(string s; lst)\n    {\n        lengths ~= s.length;\n    }\n    lengths = sort(lengths);\n    int length = lengths[0];\n    foreach(string s; lst)\n    {\n        if(s.length == length)\n        {\n            result ~= s;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmp0cg1vlqs.d(27): Error: cannot append type `ulong` to type `int[]`\n/tmp/tmp0cg1vlqs.d(29): Error: undefined identifier `sort`, did you mean function `sqrt`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0cg1vlqs.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163090
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] result = [];\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            result ~= s;\n        }\n    }\n    sort(result);\n    return result;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "SyntaxError",
      "stderr": "/tmp/tmpa999f_u7.d(31): Error: undefined identifier `sort`, did you mean function `sqrt`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpa999f_u7.d\", \"-I/tmp\"]\n",
      "stdout": "",
      "timestamp": 1660163089
    },
    {
      "exit_code": 1,
      "program": "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    >>> list_sort([\"aa\", \"a\", \"aaa\"])\n    [\"aa\"]\n    >>> list_sort([\"ab\", \"a\", \"aaa\", \"cd\"])\n    [\"ab\", \"cd\"]\n    \n*/\nstring[] sorted_list_sum(string[] lst) \n{\n    string[] temp = new string[lst.length];\n    int count = 0;\n    foreach(string s; lst)\n    {\n        if(s.length % 2 == 0)\n        {\n            temp[count] = s;\n            count++;\n        }\n    }\n    string[] result = new string[count];\n    for(int i = 0; i < count; i++)\n    {\n        result[i] = temp[i];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = sorted_list_sum;\n\n    assert(candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]);\n    assert(candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]);\n    assert(candidate([\"d\", \"b\", \"c\", \"a\"]) == []);\n    assert(candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]);\n    assert(candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]);\n    assert(candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []);\n    assert(candidate([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]);\n}\nvoid main(){}",
      "status": "Exception",
      "stderr": "core.exception.AssertError@/tmp/tmp4d7br08o.d(45): unittest failure\n----------------\n??:? _d_unittestp [0x429325]\n??:? void tmp4d7br08o.__unittest_L40_C1() [0x427ef7]\n??:? void tmp4d7br08o.__modtest() [0x42858c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42dccf]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42907e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x42ab7d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x42ac0c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x42ab09]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x429055]\n??:? runModuleUnitTests [0x42daa5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4297e8]\n??:? void rt.dmain2._d_r",
      "stdout": "",
      "timestamp": 1660163090
    }
  ]
}