name: HumanEval_10_make_palindrome
language: rs
prompt: "/// Find the shortest palindrome that begins with a supplied string.\n///\
  \ Algorithm idea is simple:\n/// - Find the longest postfix of supplied string that\
  \ is a palindrome.\n/// - Append to the end of the string reverse of a string prefix\
  \ that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n/// ''\n\
  /// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n///\
  \ 'catac'\nfn make_palindrome(string: String) -> String {\n"
tests: "}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
  \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
  x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
  ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
  \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
  }\n"
completions: ["    match string.as_str() {\n        \"\" => string,\n        \"a\"\
    \ => \"a\".to_string(),\n        _ => {\n            let mut s: String = string.clone();\n\
    \            let lps = lps(&string);\n            s.push_str(&string[..lps].chars().rev().collect::<String>());\n\
    \            s\n        }\n    }", "    if string.is_empty() {\n        return\
    \ String::new();\n    }\n\n    let mut postfix = String::new();\n    let mut prefix\
    \ = String::new();\n    let mut suffix = String::new();\n    let mut suffix_length\
    \ = 0;\n\n    for i in 0..string.len() {\n        if string[i..].chars().eq(string[..i].chars().rev())\
    \ {\n            if i > suffix_length {\n                suffix_length = i;\n\
    \                suffix = string[i..].to_string();\n                prefix = string[..i].to_string();\n\
    \            }\n        }\n    }\n\n    postfix.push_str(&prefix);\n    postfix.push_str(&suffix);\n\
    \    postfix.push_str(&prefix.chars().rev().collect::<String>());\n\n    postfix",
  "    let reversed = string.chars().rev().collect::<String>();\n    let mut longest_suffix\
    \ = 0;\n    for i in 1..string.len() {\n        if string[i..] == reversed[0..string.len()\
    \ - i] {\n            longest_suffix = i;\n        }\n    }\n    if longest_suffix\
    \ == 0 {\n        string + &reversed\n    } else {\n        string + &reversed[0..string.len()\
    \ - longest_suffix]\n    }", "    if string.is_empty() {\n        return string;\n\
    \    }\n\n    let mut result = String::new();\n    let mut input = string.clone();\n\
    \    let mut temp = String::new();\n\n    while !input.is_empty() {\n        result.push_str(&input);\n\
    \        let last_char = input.pop().unwrap();\n        temp.push(last_char);\n\
    \        if is_palindrome(&input) {\n            result.push_str(&reverse(&temp));\n\
    \            return result;\n        }\n    }\n\n    String::new()", "    if string.is_empty()\
    \ {\n        return string;\n    }\n\n    let mut result = string.clone();\n \
    \   for i in (0..string.len()).rev() {\n        let prefix = &string[0..i];\n\
    \        let postfix = &string[i..];\n        if postfix == prefix.chars().rev().collect::<String>()\
    \ {\n            result.push_str(&prefix.chars().rev().collect::<String>());\n\
    \            break;\n        }\n    }\n\n    result", "    let length = string.len();\n\
    \    let mut string = string;\n    for i in 0..length {\n        let prefix =\
    \ &string[..i];\n        let reversed_prefix = &prefix.chars().rev().collect::<String>();\n\
    \        if is_palindrome(&string) {\n            return string;\n        }\n\
    \        string.push_str(reversed_prefix);\n    }\n    string", "    let mut s\
    \ = string.as_bytes();\n    let mut palindrome = Vec::new();\n    let mut prefix\
    \ = Vec::new();\n    let mut i = s.len() - 1;\n    while i >= 0 {\n        if\
    \ is_palindrome(&s[i..]) {\n            palindrome.extend(s[i..].iter());\n  \
    \          prefix.extend(s[..i].iter().rev());\n            break;\n        }\n\
    \        i -= 1;\n    }\n    palindrome.extend(prefix);\n    String::from_utf8(palindrome).unwrap()",
  "    if string.is_empty() {\n        return string;\n    }\n\n    let mut postfix\
    \ = String::new();\n    let mut prefix = String::new();\n    let mut reversed_prefix\
    \ = String::new();\n    let mut result = String::new();\n\n    let mut not_postfix\
    \ = true;\n    let mut not_prefix = true;\n\n    for i in 0..string.len() {\n\
    \        let mut j = string.len() - 1 - i;\n        if not_postfix && j >= 0 &&\
    \ &string[i..i + 1] == &string[j..j + 1] {\n            postfix = string[i..=j].to_string();\n\
    \        } else {\n            not_postfix = false;\n        }\n\n        if not_prefix\
    \ && i < string.len() && &string[i..i + 1] == &string[j..j + 1] {\n          \
    \  prefix = string[i..=j].to_string();\n            reversed_prefix = prefix.chars().rev().collect();\n\
    \        } else {\n            not_prefix = false;\n        }\n    }\n\n    result.push_str(&prefix);\n\
    \    result.push_str(&reversed_prefix);\n\n    if postfix.len() > prefix.len()\
    \ {\n        result.push_str(&postfix[prefix.len()..]);\n    }\n\n    result",
  "    if string.is_empty() {\n        return string;\n    }\n\n    let mut prefix\
    \ = string.clone();\n    let mut suffix = string.clone();\n    // Find the longest\
    \ palindromic suffix of string.\n    while !suffix.is_empty() && !is_palindrome(&suffix)\
    \ {\n        prefix.pop();\n        suffix.remove(0);\n    }\n\n    prefix.into_iter().rev().collect::<String>()\
    \ + &suffix", "    let mut suffix = suffix_palindrome(&string);\n    suffix.reverse();\n\
    \    string + &suffix", "    let n = string.len();\n    // First n characters\
    \ of the string reversed.\n    let reversed = &string[..n].chars().rev().collect::<String>();\n\
    \    let mut s = string.clone();\n    let (suffix, _) = find_longest_palindrome_prefix(&s[..]);\n\
    \    s.push_str(&reversed[..n - suffix]);\n    s", "    let vector: Vec<char>\
    \ = string.chars().collect();\n    let mut palindrome_suffix: Vec<char> = Vec::new();\n\
    \    for idx in 0..vector.len() {\n        if is_palindrome(&vector[idx..]) {\n\
    \            palindrome_suffix = vector[idx..].to_vec();\n            break;\n\
    \        }\n    }\n    if palindrome_suffix.is_empty() {\n        return string;\n\
    \    }\n    let mut palindrome_prefix: Vec<char> = palindrome_suffix.clone();\n\
    \    palindrome_prefix.reverse();\n    let mut result: Vec<char> = vector[..palindrome_suffix.len()].to_vec();\n\
    \    result.extend(palindrome_prefix);\n    result.iter().collect()", "    if\
    \ string.is_empty() {\n        return string;\n    }\n\n    let prefix_size =\
    \ string.len() - longest_palindrome_suffix_size(&string);\n    format!(\"{}{}\"\
    , string, string[..prefix_size].chars().rev().collect::<String>())", "    let\
    \ mut s = string.as_bytes();\n    let mut i = 0;\n    let length = s.len();\n\
    \    while i < length / 2 {\n        if s[i] != s[length - i - 1] {\n        \
    \    break;\n        }\n        i += 1;\n    }\n    let mut j = length - 1;\n\
    \    while i < j {\n        s[j] = s[i];\n        i += 1;\n        j -= 1;\n \
    \   }\n    String::from_utf8(s.to_vec()).unwrap()", "    if string.is_empty()\
    \ {\n        return string;\n    }\n\n    let mut palindrome_suffix = string.clone();\n\
    \    while !is_palindrome(&palindrome_suffix) {\n        palindrome_suffix.pop();\n\
    \    }\n\n    string + palindrome_suffix.chars().rev().collect::<String>().as_str()",
  "    if string.is_empty() {\n        return string;\n    }\n\n    let mut longest_palindrome\
    \ = &string[0..1];\n    for size in (1..=string.len()).rev() {\n        for offset\
    \ in 0..=string.len() - size {\n            let sub = &string[offset..offset +\
    \ size];\n            if sub == sub.chars().rev().collect::<String>() {\n    \
    \            longest_palindrome = sub;\n                break;\n            }\n\
    \        }\n    }\n\n    let prefix = &string[0..string.len() - longest_palindrome.len()];\n\
    \    format!(\"{}{}{}\", prefix, longest_palindrome, prefix.chars().rev().collect::<String>())",
  "    let len = string.len();\n    let mut reverse_string = string.chars().rev().collect::<String>();\n\
    \    let mut postfix = String::new();\n    for i in 0..len {\n        let prefix\
    \ = string.get(0..len - i).unwrap();\n        let postfix_candidate = reverse_string.get(i..).unwrap();\n\
    \        if postfix_candidate == prefix {\n            postfix = postfix_candidate.to_string();\n\
    \            break;\n        }\n    }\n    string + reverse_string.get(postfix.len()..).unwrap()",
  "    let string = string.as_bytes();\n    let (mut postfix, mut prefix) = (0, string.len());\n\
    \    for i in 0..string.len() {\n        if string[i..] == string[..string.len()\
    \ - i].iter().rev() {\n            postfix = i;\n            prefix = string.len()\
    \ - i;\n            break;\n        }\n    }\n    String::from_utf8(\n       \
    \ [&string[..prefix], &string[prefix..][..postfix].iter().rev()].concat(),\n \
    \   )\n    .unwrap()", "    let string_bytes = string.as_bytes();\n    let length\
    \ = string_bytes.len();\n    let mut suffix_length = 0;\n    while suffix_length\
    \ < length {\n        let pivot = length - suffix_length - 1;\n        if is_palindrome(&string_bytes[0..pivot])\
    \ {\n            return format!(\"{}{}\", string, make_palindrome(&string[0..pivot]));\n\
    \        }\n        suffix_length += 1;\n    }\n    return string;", "    let\
    \ mut string = string;\n    let find_largest_palindrome_suffix = |string: &str|\
    \ -> Option<String> {\n        for window_size in (0..string.len()).rev() {\n\
    \            let window = &string[string.len() - window_size..];\n           \
    \ if is_palindrome(window) {\n                return Some(window.to_string());\n\
    \            }\n        }\n        None\n    };\n    let append_reverse_prefix\
    \ = |string: &str, palindrome_suffix: &str| -> String {\n        let prefix =\
    \ &string[..string.len() - palindrome_suffix.len()];\n        let mut reversed_prefix\
    \ = prefix.chars().rev().collect::<String>();\n        reversed_prefix.push_str(string);\n\
    \        reversed_prefix\n    };\n    match find_largest_palindrome_suffix(&string)\
    \ {\n        Some(palindrome_suffix) => append_reverse_prefix(&string, &palindrome_suffix),\n\
    \        None => string,\n    }"]
stop_tokens:
- "\n}"
