name: HumanEval_62_derivative
language: rs
prompt: "/// xs represent coefficients of a polynomial.\n/// xs[0] + xs[1] * x + xs[2]\
  \ * x^2 + ....\n/// Return derivative of this polynomial in the same form.\n///\
  \ >>> derivative([3, 1, 2, 4, 5])\n/// [1, 4, 12, 20]\n/// >>> derivative([1, 2,\
  \ 3])\n/// [2, 6]\nfn derivative(xs: Vec<isize>) -> Vec<isize> {\n"
tests: "}\n\nfn main() {\n    let candidate = derivative;\n    assert_eq!(candidate(vec![3,\
  \ 1, 2, 4, 5]), vec![1, 4, 12, 20]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2,\
  \ 6]);\n    assert_eq!(candidate(vec![3, 2, 1]), vec![2, 2]);\n    assert_eq!(candidate(vec![3,\
  \ 2, 1, 0, 4]), vec![2, 2, 0, 16]);\n    assert_eq!(candidate(vec![1]), Vec::<isize>::new());\n\
  }\n"
completions: ["    let mut result = Vec::new();\n    let mut degree = 0;\n    for\
    \ i in 1..xs.len() {\n        result.push(xs[i] * i as isize);\n        degree\
    \ += 1;\n    }\n    result", "    let mut result = Vec::new();\n    let mut i\
    \ = 0;\n    for &x in &xs {\n        if i > 0 {\n            result.push(i as\
    \ isize * x);\n        }\n        i += 1;\n    }\n    result", "    let mut degree\
    \ = xs.len() - 1;\n    let mut x = xs.clone();\n    let mut result = Vec::new();\n\
    \    while degree >= 1 {\n        result.push(x[0] * degree as isize);\n     \
    \   x.remove(0);\n        degree -= 1;\n    }\n    result", "    let mut coeffs\
    \ = Vec::new();\n    for i in 1..xs.len() {\n        coeffs.push(xs[i] * i as\
    \ isize);\n    }\n    coeffs", '    xs.iter().enumerate().map(|(i, &x)| x * i
    as isize).skip(1).collect()', "    let mut res = Vec::new();\n    for i in 1..xs.len()\
    \ {\n        res.push(xs[i] * i as isize);\n    }\n    res", "    let mut res\
    \ = vec![];\n    for (i, &x) in xs.iter().enumerate() {\n        if i == 0 {\n\
    \            continue;\n        }\n        res.push(x * i as isize);\n    }\n\
    \    res", "    let mut xs = xs;\n    xs.drain(1..);\n    xs.iter().enumerate().map(|(i,\
    \ &x)| x * (i as isize + 1)).collect()", "    let mut ys = vec![];\n    for i\
    \ in 1..xs.len() {\n        ys.push(xs[i] * i as isize);\n    }\n    ys", "  \
    \  if xs.len() < 2 {\n        return vec![];\n    }\n    xs.iter().enumerate().skip(1).map(|(index,\
    \ x)| index as isize * x).collect()", '    xs.iter().enumerate().map(|(i, x)|
    i as isize * x).skip(1).collect()', "    let mut result = Vec::new();\n    for\
    \ (i, x) in xs.iter().enumerate() {\n        if i == 0 {\n            continue;\n\
    \        }\n        result.push(x * i as isize);\n    }\n    result", "    let\
    \ mut result = Vec::new();\n    for i in 1..xs.len() {\n        result.push(xs[i]\
    \ * i as isize);\n    }\n    result", "    let mut new_xs = Vec::new();\n    let\
    \ mut i = 1;\n    for x in xs.iter() {\n        new_xs.push(x * i);\n        i\
    \ += 1;\n    }\n    return new_xs[1..].to_vec();", "    let mut n = xs.len();\n\
    \    let mut dxs = vec![0; n - 1];\n    for i in 0..n {\n        dxs[i] = xs[i]\
    \ * (n - i - 1) as isize;\n    }\n    dxs", '    (1..xs.len()).map(|i| i as isize
    * xs[i]).collect()', "    if xs.len() == 0 {\n        return xs;\n    }\n\n  \
    \  let mut result = Vec::new();\n    for (i, x) in xs.iter().enumerate() {\n \
    \       if i == 0 {\n            continue;\n        }\n        result.push(x *\
    \ i as isize);\n    }\n    result", "    let mut result = Vec::new();\n    let\
    \ mut deg = xs.len() - 1;\n    for i in 0..xs.len() {\n        result.push(xs[i]\
    \ * deg as isize);\n        deg -= 1;\n    }\n    result", "    // TODO: implement\
    \ me\n    // hint: use range and skip()\n    xs.iter().enumerate().skip(1).map(|(i,\
    \ x)| x * i as isize).collect()", "    // ...\n    let mut result = vec![];\n\
    \    let mut count = 1;\n    for i in xs {\n        if count > xs.len() - 1 {\n\
    \            break;\n        }\n        let mut val = i * count;\n        result.push(val);\n\
    \        count += 1;\n    }\n    result"]
stop_tokens:
- "\n}"
