name: HumanEval_55_fib
language: rs
prompt: "/// Return n-th Fibonacci number.\n/// >>> fib(10)\n/// 55\n/// >>> fib(1)\n\
  /// 1\n/// >>> fib(8)\n/// 21\nfn fib(n: isize) -> isize {\n"
tests: "}\n\nfn main() {\n    let candidate = fib;\n    assert_eq!(candidate(10),\
  \ 55);\n    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(8), 21);\n  \
  \  assert_eq!(candidate(11), 89);\n    assert_eq!(candidate(12), 144);\n}\n"
completions: ["    if n == 0 {\n        return 0;\n    } else if n == 1 {\n      \
    \  return 1;\n    } else {\n        return fib(n - 1) + fib(n - 2);\n    }", " \
    \   if n == 0 {\n        0\n    } else if n == 1 {\n        1\n    } else {\n\
    \        fib(n - 1) + fib(n - 2)\n    }", "    match n {\n        0 | 1 => n,\n\
    \        _ => fib(n - 1) + fib(n - 2),\n    }", "    if n == 0 {\n        return\
    \ 0;\n    }\n    if n == 1 {\n        return 1;\n    }\n    return fib(n - 1)\
    \ + fib(n - 2);", "    if n == 0 {\n        return 0;\n    }\n    let mut i =\
    \ 2;\n    let mut a = 0;\n    let mut b = 1;\n    let mut c;\n    while i <= n\
    \ {\n        c = a + b;\n        a = b;\n        b = c;\n        i += 1;\n   \
    \ }\n    b", "    match n {\n        0 => 0,\n        1 => 1,\n        _ => fib(n\
    \ - 1) + fib(n - 2),\n    }", "    if n <= 2 {\n        return 1;\n    }\n   \
    \ return fib(n - 1) + fib(n - 2);", "    match n {\n        0 => 0,\n        1\
    \ => 1,\n        _ => fib(n - 1) + fib(n - 2),\n    }", "  if n == 0 {\n    0\n\
    \  } else if n == 1 {\n    1\n  } else {\n    fib(n - 1) + fib(n - 2)\n  }", " \
    \   if n <= 1 {\n        n\n    } else {\n        fib(n - 1) + fib(n - 2)\n  \
    \  }", "    match n {\n        1 => 1,\n        2 => 1,\n        n => fib(n -\
    \ 1) + fib(n - 2),\n    }", "    if n == 0 {\n        0\n    } else if n == 1\
    \ {\n        1\n    } else {\n        fib(n - 1) + fib(n - 2)\n    }", "    if\
    \ n <= 1 {\n        return n;\n    }\n    let mut a = 0;\n    let mut b = 1;\n\
    \    for _ in 0..n - 1 {\n        let c = a + b;\n        a = b;\n        b =\
    \ c;\n    }\n    b", "    if n <= 1 {\n        return n;\n    }\n    fib(n - 1)\
    \ + fib(n - 2)", "    let mut last: isize = 0;\n    let mut curr: isize = 1;\n\
    \    for _ in 1..n {\n        let tmp = last + curr;\n        last = curr;\n \
    \       curr = tmp;\n    }\n    curr", "    match n {\n        0 => 1,\n     \
    \   1 => 1,\n        _ => fib(n - 1) + fib(n - 2),\n    }", "    match n {\n \
    \       0 => 1,\n        1 => 1,\n        _ => fib(n - 1) + fib(n - 2),\n    }",
  "    if n == 0 {\n        return 0;\n    } else if n == 1 {\n        return 1;\n\
    \    } else {\n        return fib(n - 1) + fib(n - 2);\n    }", "    match n {\n\
    \        0 => 0,\n        1 => 1,\n        _ => fib(n - 1) + fib(n - 2),\n   \
    \ }", "    match n {\n        1 => 1,\n        2 => 1,\n        _ => fib(n - 1)\
    \ + fib(n - 2),\n    }"]
stop_tokens:
- "\n}"
