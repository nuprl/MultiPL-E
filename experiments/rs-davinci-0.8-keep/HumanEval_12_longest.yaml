name: HumanEval_12_longest
language: rs
prompt: "/// Out of list of strings, return the longest one. Return the first one\
  \ in case of multiple\n/// strings of the same length. Return None in case the input\
  \ list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n/// 'a'\n\
  /// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
  \ -> Option<String> {\n"
tests: "}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
  \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
  ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
  x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
  kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
completions: ["    let mut length: usize = 0;\n    let mut result: Option<String>\
    \ = None;\n    for s in strings {\n        if s.len() > length {\n           \
    \ length = s.len();\n            result = Some(s);\n        }\n    }\n    result",
  "    let mut result = None;\n    let mut max_len = 0;\n    for s in strings {\n\
    \        if s.len() > max_len {\n            max_len = s.len();\n            result\
    \ = Some(s);\n        }\n    }\n    result", "    let mut longest_string = None;\n\
    \    for string in strings {\n        if longest_string.is_none() || string.len()\
    \ > longest_string.unwrap().len() {\n            longest_string = Some(string);\n\
    \        }\n    }\n    longest_string", "    if strings.is_empty() {\n       \
    \ return None;\n    }\n    let mut max = String::new();\n    for x in strings\
    \ {\n        if x.len() > max.len() {\n            max = x;\n        }\n    }\n\
    \    Some(max)", "    if strings.is_empty() {\n        return None;\n    }\n \
    \   let mut longest = strings[0].clone();\n    for s in strings {\n        if\
    \ s.len() > longest.len() {\n            longest = s;\n        }\n    }\n    Some(longest)",
  "    if strings.is_empty() {\n        return None;\n    }\n    let mut longest =\
    \ strings[0].clone();\n    for i in 1..strings.len() {\n        if strings[i].len()\
    \ > longest.len() {\n            longest = strings[i].clone();\n        }\n  \
    \  }\n    Some(longest)", '    strings.into_iter().max_by_key(|s| s.len()).cloned()',
  "    let mut longest_word: Option<String> = None;\n    let mut max_len = 0;\n  \
    \  for s in strings {\n        if s.len() > max_len {\n            max_len = s.len();\n\
    \            longest_word = Some(s);\n        }\n    }\n    longest_word", " \
    \   let mut longest = String::new();\n    for s in strings {\n        if s.len()\
    \ > longest.len() {\n            longest = s;\n        }\n    }\n    if longest.len()\
    \ > 0 {\n        Some(longest)\n    } else {\n        None\n    }", "    let mut\
    \ longest_string: Option<String> = None;\n    let mut longest_length: Option<usize>\
    \ = None;\n    for string in strings {\n        let string_length = string.len();\n\
    \        if longest_length.is_none() || string_length > longest_length.unwrap()\
    \ {\n            longest_string = Some(string);\n            longest_length =\
    \ Some(string_length);\n        }\n    }\n    longest_string", '    strings.into_iter().max_by_key(|string|
    string.len()).map(|string| string.to_string())', '    unimplemented!()', "   \
    \ match strings.len() {\n        0 => None,\n        _ => {\n            let mut\
    \ longest = strings[0].clone();\n            for string in strings.iter() {\n\
    \                if string.len() > longest.len() {\n                    longest\
    \ = string.clone();\n                }\n            }\n            Some(longest)\n\
    \        }\n    }", "    if strings.is_empty() {\n        return None;\n    }\n\
    \    // We need to return the string, not the reference\n    let mut max_string\
    \ = String::new();\n    for string in strings {\n        if string.len() > max_string.len()\
    \ {\n            max_string = string;\n        }\n    }\n    Some(max_string)",
  "    // TODO\n    None", "    let mut longest = String::new();\n    for s in strings\
    \ {\n        if s.len() > longest.len() {\n            longest = s;\n        }\n\
    \    }\n    if longest.len() > 0 {\n        Some(longest)\n    } else {\n    \
    \    None\n    }", "    let mut longest = None;\n    for s in strings {\n    \
    \    match longest {\n            None => longest = Some(s),\n            Some(s_old)\
    \ => if s.len() > s_old.len() {\n                longest = Some(s);\n        \
    \    },\n        }\n    }\n    longest", "    let mut result = None;\n    let\
    \ mut longest_len = 0;\n    for string in strings {\n        if string.len() >\
    \ longest_len {\n            result = Some(string);\n            longest_len =\
    \ string.len();\n        }\n    }\n    result", "    let mut longest_so_far =\
    \ None;\n    for string in strings {\n        match longest_so_far {\n       \
    \     None => longest_so_far = Some(string),\n            Some(ref prev) => {\n\
    \                if string.len() > prev.len() {\n                    longest_so_far\
    \ = Some(string);\n                }\n            }\n        }\n    }\n    longest_so_far",
  "    // TODO\n    None"]
stop_tokens:
- "\n}"
