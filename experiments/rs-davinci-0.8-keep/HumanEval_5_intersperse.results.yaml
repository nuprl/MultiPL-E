language: rs
name: HumanEval_5_intersperse
results:
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    if numbers.len() == 0 {\n        return numbers;\n\
    \    }\n\n    let mut ret_numbers = vec![numbers[0]];\n    for number in numbers[1..].iter()\
    \ {\n        ret_numbers.push(delimeter);\n        ret_numbers.push(*number);\n\
    \    }\n    ret_numbers\n}\n\nfn main() {\n    let candidate = intersperse;\n\
    \    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n   \
    \ assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n   \
    \ assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823111
- exit_code: 101
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    numbers.iter().fold(Vec::new(), |mut v, &x| {\n\
    \        v.push(x);\n        v.push(delimeter);\n        v\n    })\n}\n\nfn main()\
    \ {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 8, 6, 8, 3, 8, 2, 8]`,\n right: `[5, 8, 6, 8, 3, 8, 2]`', /tmp/tmp040p8u41.rs:17:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823111
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut result = Vec::new();\n    for (i, num) in\
    \ numbers.iter().enumerate() {\n        result.push(*num);\n        if i != numbers.len()\
    \ - 1 {\n            result.push(delimeter);\n        }\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823111
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    match numbers.len() {\n        0 => vec![],\n  \
    \      1 => numbers,\n        2 => vec![numbers[0], delimeter, numbers[1]],\n\
    \        _ => {\n            let mut first = vec![numbers[0], delimeter];\n  \
    \          first.extend(intersperse(numbers[1..].to_vec(), delimeter));\n    \
    \        first\n        }\n    }\n}\n\nfn main() {\n    let candidate = intersperse;\n\
    \    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n   \
    \ assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n   \
    \ assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823111
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    if numbers.len() == 0 {\n        return vec![];\n\
    \    }\n    let mut result = vec![numbers[0]];\n    for &number in numbers.iter().skip(1)\
    \ {\n        result.push(delimeter);\n        result.push(number);\n    }\n  \
    \  result\n}\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823111
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    if numbers.len() == 0 {\n        numbers\n    }\
    \ else {\n        let mut new_list = Vec::with_capacity(numbers.len() * 2 - 1);\n\
    \        for (i, n) in numbers.iter().enumerate() {\n            new_list.push(*n);\n\
    \            if i < numbers.len() - 1 {\n                new_list.push(delimeter);\n\
    \            }\n        }\n        new_list\n    }\n}\n\nfn main() {\n    let\
    \ candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(), 7),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823111
- exit_code: 101
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut iter =\
    \ numbers.iter();\n    while let Some(a) = iter.next() {\n        result.push(*a);\n\
    \        if let Some(b) = iter.next() {\n            result.push(delimeter);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = intersperse;\n\
    \    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n   \
    \ assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n   \
    \ assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 8, 3, 8]`,\n right: `[5, 8, 6, 8, 3, 8, 2]`', /tmp/tmpowk2223r.rs:21:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823111
- exit_code: 101
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n  unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n\
    \    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpdeh_9x22.rs:7:3

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823111
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    if numbers.len() <= 1 {\n        return numbers;\n\
    \    }\n\n    let mut interspersed: Vec<isize> = Vec::new();\n    let mut last_num:\
    \ Option<isize> = None;\n\n    for num in numbers {\n        if let Some(n) =\
    \ last_num {\n            interspersed.push(n);\n            interspersed.push(delimeter);\n\
    \        }\n        last_num = Some(num);\n    }\n\n    if let Some(num) = last_num\
    \ {\n        interspersed.push(num);\n    }\n\n    interspersed\n}\n\nfn main()\
    \ {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823111
- exit_code: 1
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut temp = Vec::new();\n    let mut vec_result\
    \ = Vec::new();\n    if numbers.len() == 0 {\n        return vec_result;\n   \
    \ } else {\n        for i in 0..numbers.len() {\n            if i == numbers.len()\
    \ - 1 {\n                temp.push(numbers[i]);\n                vec_result.push(temp.clone());\n\
    \            } else {\n                temp.push(numbers[i]);\n              \
    \  temp.push(delimeter);\n                vec_result.push(temp.clone());\n   \
    \             temp.clear();\n            }\n        }\n    }\n    return vec_result.concat();\n\
    }\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnj37c1ls.rs:15:33\n   |\n\
    15 |                 vec_result.push(temp.clone());\n   |                    \
    \             ^^^^^^^^^^^^ expected `isize`, found struct `Vec`\n   |\n   = note:\
    \ expected type `isize`\n            found struct `Vec<isize>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpnj37c1ls.rs:19:33\n   |\n19 |              \
    \   vec_result.push(temp.clone());\n   |                                 ^^^^^^^^^^^^\
    \ expected `isize`, found struct `Vec`\n   |\n   = note: expected type `isize`\n\
    \            found struct `Vec<isize>`\n\nerror[E0599]: the method `concat` exists\
    \ for struct `Vec<isize>`, but its trait bounds were not satisfied\n  --> /tmp/tmpnj37c1ls.rs:24:23\n\
    \   |\n24 |     return vec_result.concat();\n   |                       ^^^^^^\
    \ method cannot be called on `Vec<isize>` due to unsatisfied trait bounds\n  \
    \ |\n   = note: the following trait bounds were not satisfied:\n           `<[isize]\
    \ as Concat<_>>::Output = _`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659823111
- exit_code: 101
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut it = numbers.iter();\n\
    \    loop {\n        match it.next() {\n            Some(first) => {\n       \
    \         result.push(*first);\n                match it.next() {\n          \
    \          Some(second) => {\n                        result.push(delimeter);\n\
    \                        result.push(*second);\n                    }\n      \
    \              None => break,\n                }\n            }\n            None\
    \ => break,\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n\
    \    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 8, 6, 3, 8, 2]`,\n right: `[5, 8, 6, 8, 3, 8, 2]`', /tmp/tmpxyz3kk0q.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823111
- exit_code: 101
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let n = numbers.len();\n    let mut result = Vec::with_capacity(2\
    \ * n - 1);\n    for i in 0..n {\n        result.push(numbers[i]);\n        if\
    \ i != n - 1 {\n            result.push(delimeter);\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpuynh00so.rs:8:41

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823111
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut ret = Vec::new();\n    let mut numbers =\
    \ numbers.iter();\n    if let Some(head) = numbers.next() {\n        ret.push(*head);\n\
    \        for val in numbers {\n            ret.push(delimeter);\n            ret.push(*val);\n\
    \        }\n    }\n    ret\n}\n\nfn main() {\n    let candidate = intersperse;\n\
    \    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n   \
    \ assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n   \
    \ assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823111
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut result = Vec::new();\n    for (i, num) in\
    \ numbers.iter().enumerate() {\n        result.push(*num);\n        if i < numbers.len()\
    \ - 1 {\n            result.push(delimeter);\n        }\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823111
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut numbers\
    \ = numbers.into_iter();\n    if let Some(n) = numbers.next() {\n        result.push(n);\n\
    \        for n in numbers {\n            result.push(delimeter);\n           \
    \ result.push(n);\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n\
    \    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823111
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut result = Vec::<isize>::new();\n    if numbers.len()\
    \ > 0 {\n        result.push(numbers[0]);\n        for i in 1..numbers.len() {\n\
    \            result.push(delimeter);\n            result.push(numbers[i]);\n \
    \       }\n    }\n    result\n}\n\nfn main() {\n    let candidate = intersperse;\n\
    \    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n   \
    \ assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n   \
    \ assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823111
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut res = Vec::new();\n    for i in 0..numbers.len()\
    \ {\n        res.push(numbers[i]);\n        if i < numbers.len() - 1 {\n     \
    \       res.push(delimeter);\n        }\n    }\n    res\n}\n\nfn main() {\n  \
    \  let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823111
- exit_code: 101
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut last_number\
    \ = None;\n    for number in numbers {\n        match last_number {\n        \
    \    Some(last_number) => {\n                result.push(last_number);\n     \
    \           result.push(delimeter);\n            }\n            None => {}\n \
    \       }\n        result.push(number);\n        last_number = Some(number);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 5, 8, 6, 6, 8, 3, 3, 8, 2]`,\n right: `[5, 8, 6, 8, 3, 8, 2]`', /tmp/tmpw6vgc7lw.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823111
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut out = Vec::new();\n    let mut first = true;\n\
    \    for num in numbers {\n        if first {\n            first = false;\n  \
    \      } else {\n            out.push(delimeter);\n        }\n        out.push(num);\n\
    \    }\n    out\n}\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823111
- exit_code: 0
  program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut result = Vec::<isize>::new();\n    let mut\
    \ curr = numbers.iter();\n    if let Some(first) = curr.next() {\n        result.push(*first);\n\
    \        for e in curr {\n            result.push(delimeter);\n            result.push(*e);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = intersperse;\n\
    \    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n   \
    \ assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n   \
    \ assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823111
