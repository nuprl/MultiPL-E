name: HumanEval_161_solve
language: rs
prompt: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
  \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the\
  \ string contains no letters, reverse the string.\n/// The function should return\
  \ the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n/// solve(\"\
  ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String) -> String {\n"
tests: "}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
  AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
  )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
  AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"\
  ));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
  ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
  \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
  \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n"
completions: ['    s.chars().map(|c| if c.is_alphabetic() { c.swap_case() } else {
    c }).collect()', "    s.chars().rev().map(|c| {\n        match c {\n         \
    \   'a'...'z' => c.to_ascii_uppercase(),\n            'A'...'Z' => c.to_ascii_lowercase(),\n\
    \            _ => c,\n        }\n    }).collect()", "    let mut result = String::new();\n\
    \    for c in s.chars() {\n        if c.is_ascii_alphabetic() {\n            result.push(if\
    \ c.is_ascii_lowercase() {\n                c.to_ascii_uppercase()\n         \
    \   } else {\n                c.to_ascii_lowercase()\n            });\n      \
    \  } else {\n            result.push(c);\n        }\n    }\n    if result.chars().all(|c|\
    \ !c.is_ascii_alphabetic()) {\n        result.chars().rev().collect()\n    } else\
    \ {\n        result\n    }", '    s.chars().rev().map(|c| if c.is_alphabetic()
    {c.to_ascii_uppercase()} else {c}).collect()', "    let mut result = String::new();\n\
    \    for c in s.chars() {\n        if c.is_lowercase() {\n            result.push(c.to_uppercase().next().unwrap());\n\
    \        } else if c.is_uppercase() {\n            result.push(c.to_lowercase().next().unwrap());\n\
    \        } else {\n            result.push(c);\n        }\n    }\n    result.chars().rev().collect()",
  "    let mut solution = String::new();\n    for i in s.chars() {\n        if i.is_uppercase()\
    \ {\n            solution.push(i.to_lowercase().next().unwrap());\n        } else\
    \ if i.is_lowercase() {\n            solution.push(i.to_uppercase().next().unwrap());\n\
    \        } else {\n            solution.push(i);\n        }\n    }\n    if solution.chars().any(|x|\
    \ x.is_lowercase() || x.is_uppercase()) {\n        solution\n    } else {\n  \
    \      solution.chars().rev().collect()\n    }", "    let mut ret = String::new();\n\
    \    let mut was_letter = false;\n    for c in s.chars() {\n        if c.is_alphabetic()\
    \ {\n            was_letter = true;\n            ret.push(c.to_lowercase().next().unwrap());\n\
    \        } else {\n            ret.push(c);\n        }\n    }\n    ret = ret.chars().rev().collect();\n\
    \    if was_letter {\n        ret = ret.chars().map(|c| c.to_uppercase().next().unwrap()).collect();\n\
    \    }\n    ret", "    let mut reverse_string = String::new();\n    for c in s.chars()\
    \ {\n        if c.is_ascii_alphabetic() {\n            if c.is_lowercase() {\n\
    \                reverse_string.push(c.to_ascii_uppercase());\n            } else\
    \ {\n                reverse_string.push(c.to_ascii_lowercase());\n          \
    \  }\n        } else {\n            reverse_string.push(c);\n        }\n    }\n\
    \    if reverse_string.is_empty() {\n        reverse_string = s;\n    }\n    reverse_string.chars().rev().collect()",
  '    s.chars().rev().map(|c| if c.is_alphabetic() { c.to_ascii_uppercase() } else
    { c }).collect()', "    if s.chars().all(|c| !c.is_alphabetic()) {\n        return\
    \ s.chars().rev().collect();\n    }\n    s.chars().map(|c| if c.is_alphabetic()\
    \ { c.to_uppercase().next().unwrap() } else { c }).collect()", "    let mut out\
    \ = String::with_capacity(s.len());\n    for c in s.chars() {\n        if c.is_ascii_alphabetic()\
    \ {\n            out.push(c.to_lowercase().next().unwrap());\n        } else {\n\
    \            out.push(c);\n        }\n    }\n    if out == s {\n        out.chars().rev().collect()\n\
    \    } else {\n        out\n    }", "    s.chars().rev().map(|ch| if ch.is_ascii_alphabetic()\
    \ {\n        if ch.is_ascii_lowercase() {\n            ch.to_ascii_uppercase()\n\
    \        } else {\n            ch.to_ascii_lowercase()\n        }\n    } else\
    \ {\n        ch\n    }).collect()", "    let mut new_s = String::new();\n    for\
    \ c in s.chars() {\n        match c {\n            'a'..='z' => new_s.push((c\
    \ as u8 - 32) as char),\n            'A'..='Z' => new_s.push((c as u8 + 32) as\
    \ char),\n            _ => new_s.push(c),\n        }\n    }\n    new_s", "   \
    \ s.chars().rev().map(|c| match c {\n        'A' ... 'Z' => c.to_ascii_lowercase(),\n\
    \        'a' ... 'z' => c.to_ascii_uppercase(),\n        _ => c\n    }).collect()",
  "  s.chars().map(|c| if c.is_alphabetic() {\n    c.to_uppercase().next().unwrap_or(c)\n\
    \  } else {\n    c\n  }).rev().collect()", "    s.chars().rev().map(|c| {\n  \
    \      if c.is_alphabetic() {\n            c.to_lowercase().next().unwrap()\n\
    \        } else {\n            c\n        }\n    }).collect()", "    let mut ans\
    \ = String::new();\n    for c in s.chars() {\n        if c.is_alphabetic() {\n\
    \            if c.is_uppercase() {\n                ans.push(c.to_lowercase().next().unwrap());\n\
    \            } else {\n                ans.push(c.to_uppercase().next().unwrap());\n\
    \            }\n        } else {\n            ans.push(c);\n        }\n    }\n\
    \    if ans.is_empty() {\n        s.chars().rev().collect()\n    } else {\n  \
    \      ans\n    }", "    s.chars().rev().map(|c| match c {\n        'a'...'z'\
    \ => c.to_ascii_uppercase(),\n        'A'...'Z' => c.to_ascii_lowercase(),\n \
    \       _ => c,\n    }).collect()", "    s.chars().rev().map(|c| {\n        if\
    \ c.is_alphabetic() {\n            c.to_ascii_uppercase()\n        } else {\n\
    \            c\n        }\n    }).collect()", '    s.chars().rev().map(|c| if
    c.is_ascii_alphabetic() { c.to_ascii_uppercase() } else { c }).collect()']
stop_tokens:
- "\n}"
