name: HumanEval_95_check_dict_case
language: rs
results:
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower_case\
    \ = 0;\n    let mut upper_case = 0;\n    for key in dict.keys() {\n        if\
    \ key.to_uppercase() == key {\n            upper_case += 1;\n        } else if\
    \ key.to_lowercase() == key {\n            lower_case += 1;\n        }\n    }\n\
    \    if dict.len() > 0 {\n        upper_case == dict.len() || lower_case == dict.len()\n\
    \    } else {\n        false\n    }\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `String` with `&String`\n  --> /tmp/tmp6hbe77ak.rs:16:31\n\
    \   |\n16 |         if key.to_uppercase() == key {\n   |                     \
    \          ^^ no implementation for `String == &String`\n   |\n   = help: the\
    \ trait `PartialEq<&String>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n\
    \             <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror[E0277]: can't compare `String` with `&String`\n\
    \  --> /tmp/tmp6hbe77ak.rs:18:38\n   |\n18 |         } else if key.to_lowercase()\
    \ == key {\n   |                                      ^^ no implementation for\
    \ `String == &String`\n   |\n   = help: the trait `PartialEq<&String>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n         \
    \    <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut all_upper\
    \ = true;\n    let mut all_lower = true;\n    for key in dict.keys() {\n     \
    \   all_upper = all_upper && key.is_uppercase();\n        all_lower = all_lower\
    \ && key.is_lowercase();\n    }\n    all_upper || all_lower\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_uppercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpw54llvsh.rs:16:38\n   |\n16 |         all_upper\
    \ = all_upper && key.is_uppercase();\n   |                                   \
    \   ^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\
    \nerror[E0599]: no method named `is_lowercase` found for reference `&String` in\
    \ the current scope\n  --> /tmp/tmpw54llvsh.rs:17:38\n   |\n17 |         all_lower\
    \ = all_lower && key.is_lowercase();\n   |                                   \
    \   ^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    true\n}\n\nfn\
    \ main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpljjv94q3.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    if dict.is_empty()\
    \ {\n        return false;\n    }\n    let mut upper_flag = false;\n    let mut\
    \ lower_flag = false;\n    for key in dict.keys() {\n        if key.is_ascii_uppercase()\
    \ {\n            upper_flag = true;\n        } else if key.is_ascii_lowercase()\
    \ {\n            lower_flag = true;\n        } else {\n            return false;\n\
    \        }\n    }\n    upper_flag != lower_flag\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_uppercase` found for reference\
    \ `&String` in the current scope\n  --> /tmp/tmpkhr1bcwq.rs:19:16\n   |\n19 |\
    \         if key.is_ascii_uppercase() {\n   |                ^^^^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_ascii_uppercase`\n\
    \nerror[E0599]: no method named `is_ascii_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpkhr1bcwq.rs:21:23\n   |\n21 |         }\
    \ else if key.is_ascii_lowercase() {\n   |                       ^^^^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_ascii_lowercase`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.keys().fold(false,\
    \ |a, v| a ^ v.to_string().chars().all(|c| c.is_lowercase()))\n}\n\nfn main()\
    \ {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpgyrd5t6o.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    if dict.is_empty()\
    \ {\n        return false;\n    }\n    let first_key = dict.keys().next().unwrap();\n\
    \    let is_lower = first_key.chars().all(|c| c.is_lowercase());\n    let is_upper\
    \ = first_key.chars().all(|c| c.is_uppercase());\n    if is_lower || is_upper\
    \ {\n        for key in dict.keys() {\n            if is_lower {\n           \
    \     if !key.chars().all(|c| c.is_lowercase()) {\n                    return\
    \ false;\n                }\n            } else {\n                if !key.chars().all(|c|\
    \ c.is_uppercase()) {\n                    return false;\n                }\n\
    \            }\n        }\n        return true;\n    }\n    false\n}\n\nfn main()\
    \ {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower_case\
    \ = true;\n    let mut upper_case = true;\n    for key in dict.keys() {\n    \
    \    for c in key.chars() {\n            lower_case = lower_case && c.is_lowercase();\n\
    \            upper_case = upper_case && c.is_uppercase();\n        }\n    }\n\
    \    lower_case ^ upper_case\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut count\
    \ = 0;\n    for (key, _) in dict {\n        if key.chars().all(|c| c.is_lowercase())\
    \ {\n            count += 1;\n        } else if key.chars().all(|c| c.is_uppercase())\
    \ {\n            count += 1;\n        }\n    }\n    count == dict.len()\n}\n\n\
    fn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `dict`\n   --> /tmp/tmp056mn0oz.rs:21:14\n\
    \    |\n12  | fn check_dict_case(dict: HashMap<String, String>) -> bool {\n  \
    \  |                    ---- move occurs because `dict` has type `HashMap<String,\
    \ String>`, which does not implement the `Copy` trait\n13  |     let mut count\
    \ = 0;\n14  |     for (key, _) in dict {\n    |                     ---- `dict`\
    \ moved due to this implicit call to `.into_iter()`\n...\n21  |     count == dict.len()\n\
    \    |              ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this\
    \ function takes ownership of the receiver `self`, which moves `dict`\nhelp: consider\
    \ iterating over a slice of the `HashMap<String, String>`'s content to avoid moving\
    \ into the `for` loop\n    |\n14  |     for (key, _) in &dict {\n    |       \
    \              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut is_lower\
    \ = true;\n    let mut is_upper = true;\n    for key in dict.keys() {\n      \
    \  if key.chars().next().unwrap().is_uppercase() {\n            is_lower = false;\n\
    \        } else {\n            is_upper = false;\n        }\n    }\n    is_lower\
    \ || is_upper\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpyty56u82.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut is_lower:\
    \ bool = false;\n    let mut is_upper: bool = false;\n    for (key, _) in dict\
    \ {\n        if key.is_lowercase() {\n            is_lower = true;\n        }\
    \ else if key.is_uppercase() {\n            is_upper = true;\n        } else {\n\
    \            return false;\n        }\n    }\n    return is_lower != is_upper;\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_lowercase` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpp2bktj54.rs:16:16\n   |\n16 |         if\
    \ key.is_lowercase() {\n   |                ^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named\
    \ `is_uppercase` found for struct `String` in the current scope\n  --> /tmp/tmpp2bktj54.rs:18:23\n\
    \   |\n18 |         } else if key.is_uppercase() {\n   |                     \
    \  ^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys: Vec<String>\
    \ = dict.keys().map(|x| x.to_lowercase()).collect();\n    keys == dict.keys().collect::<Vec<String>>()\
    \ || keys == dict.keys().map(|x| x.to_uppercase()).collect()\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&String`\n    --> /tmp/tmpthbk24be.rs:14:25\n     |\n\
    14   |     keys == dict.keys().collect::<Vec<String>>() || keys == dict.keys().map(|x|\
    \ x.to_uppercase()).collect()\n     |                         ^^^^^^^ value of\
    \ type `Vec<String>` cannot be built from `std::iter::Iterator<Item=&String>`\n\
    \     |\n     = help: the trait `FromIterator<&String>` is not implemented for\
    \ `Vec<String>`\n     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\n\
    note: required by a bound in `collect`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower_count\
    \ = 0;\n    let mut upper_count = 0;\n    for key in dict.keys() {\n        if\
    \ key.to_lowercase() == *key {\n            lower_count += 1;\n        } else\
    \ if key.to_uppercase() == *key {\n            upper_count += 1;\n        }\n\
    \    }\n    if lower_count == dict.len() || upper_count == dict.len() {\n    \
    \    return true;\n    }\n    false\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp_586ox8z.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    // Your code\
    \ here.\n    let (_, r): (Vec<_>, Vec<_>) = dict.keys().partition(|i| i.to_string().to_lowercase()\
    \ == i.to_string());\n    r.len() == 0 || dict.keys().len() == r.len()\n}\n\n\
    fn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmprbt43ewc.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut all_lower:\
    \ bool = true;\n    let mut all_upper: bool = true;\n    for (key, _value) in\
    \ dict {\n        for character in key.chars() {\n            if character.is_ascii_lowercase()\
    \ {\n                all_upper = false;\n            } else if character.is_ascii_uppercase()\
    \ {\n                all_lower = false;\n            } else {\n              \
    \  return false;\n            }\n        }\n    }\n    all_lower || all_upper\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp3auawvq1.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut upper_keys\
    \ = true;\n    let mut lower_keys = true;\n    for key in dict.keys() {\n    \
    \    if key.is_uppercase() {\n            lower_keys = false;\n        } else\
    \ {\n            upper_keys = false;\n        }\n    }\n    upper_keys || lower_keys\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_uppercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmp2n6nh4vm.rs:16:16\n   |\n16 |         if\
    \ key.is_uppercase() {\n   |                ^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_uppercase`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut flag\
    \ = false;\n    let mut check_upper = false;\n    let mut check_lower = false;\n\
    \    for key in dict.keys() {\n        if key.chars().all(|c| c.is_uppercase())\
    \ {\n            check_upper = true;\n        } else if key.chars().all(|c| c.is_lowercase())\
    \ {\n            check_lower = true;\n        } else {\n            return false;\n\
    \        }\n    }\n    if check_upper == check_lower {\n        flag = true;\n\
    \    }\n    flag\n}\n\nfn main() {\n    let candidate = check_dict_case;\n   \
    \ assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\"\
    )), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpq4lxcr58.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower_case\
    \ = true;\n    let mut upper_case = true;\n    for k in dict.keys() {\n      \
    \  lower_case = lower_case && k.is_lowercase();\n        upper_case = upper_case\
    \ && k.is_uppercase();\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmp4pil4lmc.rs:16:38\n   |\n16 |         lower_case\
    \ = lower_case && k.is_lowercase();\n   |                                    \
    \  ^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\
    \nerror[E0599]: no method named `is_uppercase` found for reference `&String` in\
    \ the current scope\n  --> /tmp/tmp4pil4lmc.rs:17:38\n   |\n17 |         upper_case\
    \ = upper_case && k.is_uppercase();\n   |                                    \
    \  ^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut keys_vec:\
    \ Vec<String> = dict.keys().cloned().collect();\n    let first_letter = keys_vec[0].chars().next().unwrap();\n\
    \    let count = keys_vec.iter().filter(|&k| k.chars().next().unwrap() == first_letter).count();\n\
    \    keys_vec.len() == count\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpt0yz9qhs.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut upper\
    \ = true;\n    let mut lower = true;\n    for key in dict.keys() {\n        upper\
    \ = upper && key.chars().all(|c| c.is_uppercase());\n        lower = lower &&\
    \ key.chars().all(|c| c.is_lowercase());\n    }\n    return upper || lower;\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpwx25xxbl.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    if dict.is_empty()\
    \ {\n        return false;\n    }\n    let mut all_lower = true;\n    let mut\
    \ all_upper = true;\n    for (key, _) in dict {\n        if !key.is_empty() {\n\
    \            all_lower = all_lower && key.chars().all(|c| c.is_lowercase());\n\
    \            all_upper = all_upper && key.chars().all(|c| c.is_uppercase());\n\
    \        }\n    }\n    all_lower || all_upper\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
