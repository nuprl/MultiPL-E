name: HumanEval_8_sum_product
language: rs
prompt: "/// For a given list of integers, return a tuple consisting of a sum and\
  \ a product of all the integers in a list.\n/// Empty sum should be equal to 0 and\
  \ empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n///\
  \ >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
  \ -> (isize, isize) {\n"
tests: "}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
  \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
  \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
  \ (10, 10));\n}\n"
completions: ["    let sum = numbers.iter().fold(0, |a, &b| a + b);\n    let product\
    \ = numbers.iter().fold(1, |a, &b| a * b);\n    (sum, product)", "    let mut\
    \ total = 0;\n    let mut product = 1;\n    for number in numbers {\n        total\
    \ += number;\n        product *= number;\n    }\n    (total, product)", '    unimplemented!()',
  '    (numbers.iter().sum(), numbers.iter().product())', '    numbers.iter().fold((0,
    1), |acc, x| (acc.0 + x, acc.1 * x))', "    let sum = numbers.iter().fold(0, |sum,\
    \ &x| sum + x);\n    let product = numbers.iter().fold(1, |product, &x| product\
    \ * x);\n    (sum, product)", "    // TODO\n    (0, 0)", "    let sum = numbers.iter().fold(0,\
    \ |a, &b| a + b);\n    let product = numbers.iter().fold(1, |a, &b| a * b);\n\
    \    (sum, product)", "    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ number in numbers {\n        sum += number;\n        product *= number;\n  \
    \  }\n    (sum, product)", "    if numbers.is_empty() {\n        return (0, 1);\n\
    \    }\n    let mut sum = 0;\n    let mut product = 1;\n    for number in numbers\
    \ {\n        sum += number;\n        product *= number;\n    }\n    (sum, product)",
  '    unimplemented!()', "    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ n in numbers {\n        sum += n;\n        product *= n;\n    }\n    (sum, product)",
  "    let mut sum = 0;\n    let mut product = 1;\n    for number in numbers {\n \
    \       sum += number;\n        product *= number;\n    }\n    (sum, product)",
  "    let (sum, product) = numbers.iter().fold((0, 1), |acc, &x| (acc.0 + x, acc.1\
    \ * x));\n    (sum, product)", '    (numbers.iter().fold(0, |acc, &x| acc + x),
    numbers.iter().fold(1, |acc, &x| acc * x))', "    let sum = numbers.iter().fold(0,\
    \ |acc, x| acc + x);\n    let product = numbers.iter().fold(1, |acc, x| acc *\
    \ x);\n    (sum, product)", '    return (0, 0);', "    let sum = numbers.iter().fold(0,\
    \ |acc, i| acc + i);\n    let product = numbers.iter().fold(1, |acc, i| acc *\
    \ i);\n    (sum, product)", "    let mut sum = 0;\n    let mut product = 1;\n\
    \    for n in numbers {\n        sum += n;\n        product *= n;\n    }\n   \
    \ (sum, product)", '    numbers.iter().fold((0, 1), |acc, i| (acc.0 + i, acc.1
    * i))']
stop_tokens:
- "\n}"
