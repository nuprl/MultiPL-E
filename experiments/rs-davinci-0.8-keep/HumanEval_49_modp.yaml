name: HumanEval_49_modp
language: rs
prompt: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n///\
  \ 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
  \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
  \ {\n"
tests: "}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5),\
  \ 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101),\
  \ 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101),\
  \ 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
  }\n"
completions: ["    let mut a = 1;\n    let mut b = n;\n    while b > 0 {\n       \
    \ if b % 2 == 1 {\n            a = (a * n) % p;\n        }\n        b = b / 2;\n\
    \        n = (n * n) % p;\n    }\n    a", "    let mut res = 1;\n    let mut exp\
    \ = n;\n    let mut base = 2;\n    while exp > 0 {\n        if exp % 2 == 1 {\n\
    \            res = (res * base) % p;\n        }\n        exp /= 2;\n        base\
    \ = (base * base) % p;\n    }\n    res", "    if n == 0 {\n        return 1;\n\
    \    }\n    if n % 2 == 0 {\n        return (modp(n / 2, p) * modp(n / 2, p))\
    \ % p;\n    }\n    return (modp(n - 1, p) * modp(n, p)) % p;", "    if n == 0\
    \ {\n        return 1;\n    }\n    let mut res = modp(n / 2, p);\n    res = (res\
    \ * res) % p;\n    if n % 2 == 1 {\n        res = (res * 2) % p;\n    }\n    res",
  "    if n == 0 {\n        return 1;\n    }\n    if n % 2 == 0 {\n        let r =\
    \ modp(n / 2, p);\n        return (r * r) % p;\n    }\n    let r = modp(n - 1,\
    \ p);\n    return (r * n) % p;", "    if n == 0 {\n        return 1;\n    }\n\
    \    else if n % 2 == 0 {\n        let mut d = modp(n / 2, p);\n        return\
    \ (d * d) % p;\n    }\n    else {\n        return (n * modp(n - 1, p)) % p;\n\
    \    }", "    let mut ret = 1;\n    for _ in 0..n {\n        ret = (ret * 2) %\
    \ p;\n    }\n    ret", "    // From http://en.wikipedia.org/wiki/Modular_exponentiation\n\
    \    var b: isize = n;\n    var result: isize = 1;\n    var x: isize = p;\n  \
    \  var y: isize = 1;\n    while x > 0 {\n        if x % 2 == 0 {\n           \
    \ x = x / 2;\n            y = (y * y) % p;\n        } else {\n            x =\
    \ x - 1;\n            result = (result * y) % p;\n        }\n    }\n    return\
    \ result;", "    if n == 0 {\n        return 1;\n    }\n\n    // handle negative\
    \ numbers\n    let mut n = n % p;\n    if n < 0 {\n        n += p;\n    }\n\n\
    \    let mut prod = n;\n    let mut temp = n;\n    n -= 1;\n    while n > 0 {\n\
    \        temp = (temp * prod) % p;\n        n -= 1;\n    }\n    temp", "    let\
    \ n = n as i64;\n    let p = p as i64;\n    if n == 0 {\n        return 1;\n \
    \   }\n    let mut res = 1;\n    let mut n = n;\n    while n > 0 {\n        if\
    \ n % 2 == 1 {\n            res = res * p % MOD;\n        }\n        p = p * p\
    \ % MOD;\n        n /= 2;\n    }\n    res as isize", "    match n {\n        0\
    \ => 1,\n        1 => n,\n        _ => modp(n % p, p) * modp(n / p, p) % p,\n\
    \    }", "    let mut result = 1;\n    let mut n = n;\n    let mut p = p;\n  \
    \  while n > 0 {\n        if n % 2 == 1 {\n            result = (result * n) %\
    \ p;\n        }\n        n = n / 2;\n        p = (p * p) % p;\n    }\n    result",
  "    if n < p {\n        return n;\n    }\n    // binary exponentiation\n    let\
    \ mut result = 1;\n    let mut a = n;\n    let mut b = p;\n    while a > 0 {\n\
    \        if a % 2 == 1 {\n            result = (result * b) % p;\n        }\n\
    \        a = a / 2;\n        b = (b * b) % p;\n    }\n    result", "    let mut\
    \ p = p;\n    let mut n = n;\n    let mut s = 1;\n    while n > 0 {\n        if\
    \ n & 1 == 1 {\n            s = s * p % p;\n        }\n        p = p * p % p;\n\
    \        n = n >> 1;\n    }\n    s", "    let mut a = 1;\n    let mut b = n;\n\
    \    while b > 0 {\n        if b % 2 == 1 {\n            a = (a * n) % p;\n  \
    \      }\n        b = b / 2;\n        n = (n * n) % p;\n    }\n    a", "    let\
    \ mut res = 1;\n    let mut cur = n;\n    while cur > 0 {\n        if cur % 2\
    \ == 1 {\n            res = (res * n) % p;\n        }\n        cur /= 2;\n   \
    \     n = (n * n) % p;\n    }\n    res", "    let mut result = 1;\n    let mut\
    \ n = n;\n    while n > 0 {\n        if n % 2 == 1 {\n            result = (result\
    \ * result) % p;\n        }\n        n = n / 2;\n    }\n    result", "    if n\
    \ == 0 {\n        return 1;\n    }\n    let mut res = 1;\n    let mut k = n;\n\
    \    while k > 0 {\n        if k % 2 == 1 {\n            res = (res * n) % p;\n\
    \        }\n        n = (n * n) % p;\n        k = k / 2;\n    }\n    res", " \
    \   let mut res = 1;\n    for _ in 0..n {\n        res = (res * 2) % p;\n    }\n\
    \    res", "    if n < 0 {\n        modp(-n, p)\n    } else if n < p {\n     \
    \   n\n    } else if n == p {\n        0\n    } else {\n        let m = n % p;\n\
    \        if m < p / 2 {\n            m\n        } else {\n            m - p\n\
    \        }\n    }"]
stop_tokens:
- "\n}"
