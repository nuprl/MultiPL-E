name: HumanEval_48_is_palindrome
language: rs
prompt: "/// Checks if given string is a palindrome\n/// >>> is_palindrome('')\n///\
  \ True\n/// >>> is_palindrome('aba')\n/// True\n/// >>> is_palindrome('aaaaa')\n\
  /// True\n/// >>> is_palindrome('zbcd')\n/// False\nfn is_palindrome(text: String)\
  \ -> bool {\n"
tests: "}\n\nfn main() {\n    let candidate = is_palindrome;\n    assert_eq!(candidate(String::from(\"\
  \")), true);\n    assert_eq!(candidate(String::from(\"aba\")), true);\n    assert_eq!(candidate(String::from(\"\
  aaaaa\")), true);\n    assert_eq!(candidate(String::from(\"zbcd\")), false);\n \
  \   assert_eq!(candidate(String::from(\"xywyx\")), true);\n    assert_eq!(candidate(String::from(\"\
  xywyz\")), false);\n    assert_eq!(candidate(String::from(\"xywzx\")), false);\n\
  }\n"
completions: ["    let size = text.len();\n    let mut start = 0;\n    let mut end\
    \ = size - 1;\n    while start < end {\n        if text.chars().nth(start) !=\
    \ text.chars().nth(end) {\n            return false;\n        }\n        start\
    \ += 1;\n        end -= 1;\n    }\n    true", '    text.chars().rev().eq(text.chars())',
  "    let text_len = text.len();\n    if text_len == 0 {\n        return true;\n\
    \    }\n    let mid = text_len / 2;\n    for i in 0..mid {\n        if text.chars().nth(i)\
    \ != text.chars().nth(text_len - i - 1) {\n            return false;\n       \
    \ }\n    }\n    true", "    let mut chars = text.chars();\n    match (chars.next(),\
    \ chars.next_back()) {\n        (Some(f), Some(b)) if f == b => is_palindrome(chars.collect()),\n\
    \        (None, None) => true,\n        _ => false,\n    }", "    if text.len()\
    \ <= 1 {\n        return true;\n    }\n\n    let (first, last) = text.split_at(1);\n\
    \    first == last && is_palindrome(text[1..text.len() - 1].to_string())", " \
    \   let mut bytes = text.as_bytes();\n    let mut l = 0;\n    let mut r = bytes.len()\
    \ - 1;\n    while l < r {\n        if bytes[l] != bytes[r] {\n            return\
    \ false;\n        }\n        l += 1;\n        r -= 1;\n    }\n    true", "   \
    \ let mut chars: Vec<char> = text.chars().collect();\n    let half_of_size = chars.len()\
    \ / 2;\n    let last_index = chars.len() - 1;\n\n    for i in 0..half_of_size\
    \ {\n        if chars[i] != chars[last_index - i] {\n            return false;\n\
    \        }\n    }\n\n    true", "    let text_length = text.len();\n    let half_length\
    \ = text_length / 2;\n    let left_part = &text[0..half_length];\n    let right_part\
    \ = &text[(text_length - half_length)..text_length];\n    left_part == right_part.chars().rev().collect::<String>()",
  "    if text.len() < 2 {\n        return true;\n    }\n\n    for idx in 0..text.len()\
    \ / 2 {\n        if text.chars().nth(idx) != text.chars().nth(text.len() - idx\
    \ - 1) {\n            return false;\n        }\n    }\n\n    true", "    if text.len()\
    \ <= 1 {\n        return true;\n    }\n    let first = text.chars().next().unwrap();\n\
    \    let last = text.chars().last().unwrap();\n    if first != last {\n      \
    \  return false;\n    }\n    return is_palindrome(text[1..text.len() - 1].to_string());",
  "    let text_bytes = text.as_bytes();\n    let mut left = 0;\n    let mut right\
    \ = text_bytes.len() - 1;\n    while left < right {\n        if text_bytes[left]\
    \ != text_bytes[right] {\n            return false;\n        }\n        left +=\
    \ 1;\n        right -= 1;\n    }\n    true", '    text.chars().rev().collect::<String>()
    == text', "    // No support for iterating over byte values of strings in Rust\
    \ 1.0.0-alpha\n    let text = text.as_bytes();\n    let n = text.len();\n    let\
    \ mut i = 0;\n    let mut j = n - 1;\n    while i < j {\n        if text[i] !=\
    \ text[j] {\n            return false;\n        }\n        i += 1;\n        j\
    \ -= 1;\n    }\n    true", '    unimplemented!()', "    let chars: Vec<char> =\
    \ text.chars().collect();\n    let mut start = 0;\n    let mut end = chars.len()\
    \ - 1;\n    while start < end {\n        if chars[start] != chars[end] {\n   \
    \         return false;\n        }\n        start += 1;\n        end -= 1;\n \
    \   }\n    true", "    let text = text.to_lowercase();\n    text.chars().rev().collect::<String>()\
    \ == text", "    let reverse_text = text.chars().rev().collect::<String>();\n\
    \    reverse_text == text", "    let chars: Vec<char> = text.chars().collect();\n\
    \    let len = chars.len();\n    let mut index = 0;\n    while index < len/2 {\n\
    \        if chars[index] != chars[len-index-1] {\n            return false;\n\
    \        }\n        index += 1;\n    }\n    true", "    if text.len() == 0 {\n\
    \        return true;\n    }\n    let mut chars = text.chars();\n    let mut low\
    \ = 0;\n    let mut high = text.len() - 1;\n    while low < high {\n        if\
    \ chars.nth(low) != chars.nth(high) {\n            return false;\n        }\n\
    \        low += 1;\n        high -= 1;\n    }\n    true", "    let mut i = 0;\n\
    \    let l = text.len();\n    while i < l / 2 {\n        if text.as_bytes()[i]\
    \ != text.as_bytes()[l - i - 1] {\n            return false;\n        }\n    \
    \    i += 1;\n    }\n    true"]
stop_tokens:
- "\n}"
