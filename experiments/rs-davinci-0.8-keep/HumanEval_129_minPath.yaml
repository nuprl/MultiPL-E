name: HumanEval_129_minPath
language: rs
prompt: "/// Given a grid with N rows and N columns (N >= 2) and a positive integer\
  \ k, \n/// each cell of the grid contains a value. Every integer in the range [1,\
  \ N * N]\n/// inclusive appears exactly once on the cells of the grid.\n/// You\
  \ have to find the minimum path of length k in the grid. You can start\n/// from\
  \ any cell, and in each step you can move to any of the neighbor cells,\n/// in\
  \ other words, you can go to cells which share an edge with you current\n/// cell.\n\
  /// Please note that a path of length k means visiting exactly k cells (not\n///\
  \ necessarily distinct).\n/// You CANNOT go off the grid.\n/// A path A (of length\
  \ k) is considered less than a path B (of length k) if\n/// after making the ordered\
  \ lists of the values on the cells that A and B go\n/// through (let's call them\
  \ lst_A and lst_B), lst_A is lexicographically less\n/// than lst_B, in other words,\
  \ there exist an integer index i (1 <= i <= k)\n/// such that lst_A[i] < lst_B[i]\
  \ and for any j (1 <= j < i) we have\n/// lst_A[j] = lst_B[j].\n/// It is guaranteed\
  \ that the answer is unique.\n/// Return an ordered list of the values on the cells\
  \ that the minimum path go through.\n/// Examples:\n/// Input: grid = [ [1,2,3],\
  \ [4,5,6], [7,8,9]], k = 3\n/// Output: [1, 2, 1]\n/// Input: grid = [ [5,9,3],\
  \ [4,1,6], [7,8,2]], k = 1\n/// Output: [1]\nfn minPath(grid: Vec<Vec<isize>>, k:\
  \ isize) -> Vec<isize> {\n"
tests: "}\n\nfn main() {\n    let candidate = minPath;\n    assert_eq!(candidate(vec![vec![1,\
  \ 2, 3], vec![4, 5, 6], vec![7, 8, 9]], 3), vec![1, 2, 1]);\n    assert_eq!(candidate(vec![vec![5,\
  \ 9, 3], vec![4, 1, 6], vec![7, 8, 2]], 1), vec![1]);\n    assert_eq!(candidate(vec![vec![1,\
  \ 2, 3, 4], vec![5, 6, 7, 8], vec![9, 10, 11, 12], vec![13, 14, 15, 16]], 4), vec![1,\
  \ 2, 1, 2]);\n    assert_eq!(candidate(vec![vec![6, 4, 13, 10], vec![5, 7, 12, 1],\
  \ vec![3, 16, 11, 15], vec![8, 14, 9, 2]], 7), vec![1, 10, 1, 10, 1, 10, 1]);\n\
  \    assert_eq!(candidate(vec![vec![8, 14, 9, 2], vec![6, 4, 13, 15], vec![5, 7,\
  \ 1, 12], vec![3, 10, 11, 16]], 5), vec![1, 7, 1, 7, 1]);\n    assert_eq!(candidate(vec![vec![11,\
  \ 8, 7, 2], vec![5, 16, 14, 4], vec![9, 3, 15, 6], vec![12, 13, 10, 1]], 9), vec![1,\
  \ 6, 1, 6, 1, 6, 1, 6, 1]);\n    assert_eq!(candidate(vec![vec![12, 13, 10, 1],\
  \ vec![9, 3, 15, 6], vec![5, 16, 14, 4], vec![11, 8, 7, 2]], 12), vec![1, 6, 1,\
  \ 6, 1, 6, 1, 6, 1, 6, 1, 6]);\n    assert_eq!(candidate(vec![vec![2, 7, 4], vec![3,\
  \ 1, 5], vec![6, 8, 9]], 8), vec![1, 3, 1, 3, 1, 3, 1, 3]);\n    assert_eq!(candidate(vec![vec![6,\
  \ 1, 5], vec![3, 8, 9], vec![2, 7, 4]], 8), vec![1, 5, 1, 5, 1, 5, 1, 5]);\n   \
  \ assert_eq!(candidate(vec![vec![1, 2], vec![3, 4]], 10), vec![1, 2, 1, 2, 1, 2,\
  \ 1, 2, 1, 2]);\n    assert_eq!(candidate(vec![vec![1, 3], vec![3, 2]], 10), vec![1,\
  \ 3, 1, 3, 1, 3, 1, 3, 1, 3]);\n}\n"
completions: ["    use std::collections::HashMap;\n    use std::cmp::min;\n    let\
    \ n = grid.len();\n    if n == 0 {\n        return vec![];\n    }\n    let dp\
    \ = vec![vec![vec![-1; n]; n]; k as usize + 1];\n    let mut val = HashMap::new();\n\
    \    let mut ind = HashMap::new();\n    for i in 0..n {\n        for j in 0..n\
    \ {\n            val.insert(grid[i][j], (i, j));\n            ind.insert((i, j),\
    \ grid[i][j]);\n        }\n    }\n    let mut res = vec![];\n    fn dfs(dp: &mut\
    \ Vec<Vec<Vec<isize>>>, grid: &Vec<Vec<isize>>, val: &HashMap<isize, (usize, usize)>,\n\
    \           ind: &HashMap<(usize, usize), isize>, res: &mut Vec<isize>,\n    \
    \       i: usize, j: usize, k: usize) -> usize {\n        if k == 0 {\n      \
    \      return 0;\n        }\n        if dp[k][i][j] != -1 {\n            return\
    \ dp[k][i][j];\n        }\n        let mut ret = n * n + 1;\n        if i > 0\
    \ {\n            let p = dfs(dp, grid, val, ind, res, i - 1, j, k - 1);\n    \
    \        ret = min(ret, p);\n        }\n        if i < n - 1 {\n            let\
    \ p = dfs(dp, grid, val, ind, res, i + 1, j, k - 1);\n            ret = min(ret,\
    \ p);\n        }\n        if j > 0 {\n            let p = dfs(dp, grid, val, ind,\
    \ res, i, j - 1, k - 1);\n            ret = min(ret, p);\n        }\n        if\
    \ j < n - 1 {\n            let p = dfs(dp, grid, val, ind, res, i, j + 1, k -\
    \ 1);\n            ret = min(ret", "    let mut dist = vec![vec![1 << 30; grid.len()];\
    \ grid.len()];\n    dist[0][0] = 0;\n    let mut heap = BinaryHeap::new();\n \
    \   heap.push(T(0, 0, 0));\n    while let Some(T(x, y, len)) = heap.pop() {\n\
    \        let c = grid[x][y];\n        if x + 1 < grid.len() {\n            if\
    \ len + 1 < dist[x + 1][y] {\n                dist[x + 1][y] = len + 1;\n    \
    \            heap.push(T(x + 1, y, len + 1));\n            }\n        }\n    \
    \    if y + 1 < grid.len() {\n            if len + 1 < dist[x][y + 1] {\n    \
    \            dist[x][y + 1] = len + 1;\n                heap.push(T(x, y + 1,\
    \ len + 1));\n            }\n        }\n        if x - 1 >= 0 {\n            if\
    \ len + 1 < dist[x - 1][y] {\n                dist[x - 1][y] = len + 1;\n    \
    \            heap.push(T(x - 1, y, len + 1));\n            }\n        }\n    \
    \    if y - 1 >= 0 {\n            if len + 1 < dist[x][y - 1] {\n            \
    \    dist[x][y - 1] = len + 1;\n                heap.push(T(x, y - 1, len + 1));\n\
    \            }\n        }\n    }\n    let mut res = Vec::new();\n    let mut cur\
    \ = (0, 0);\n    let mut len = k as usize;\n    res.push(grid[cur.0][cur.1]);\n\
    \    for _ in 0..len - 1 {\n        let x = cur.0;\n        let y = cur.1;\n \
    \       if x + 1 < grid.len() && dist[x + 1][y] + 1 == dist[x][y] {\n        \
    \    cur = (x + 1, y);\n        } else if y + 1 < grid.len() && dist[x][y + 1]\
    \ + 1 == dist[x][y] {\n            cur", "    // This is a hard problem.\n   \
    \ let mut grid = grid;\n    let mut cell = find_start(&grid);\n    let mut visited\
    \ = HashSet::new();\n    let mut res = vec![grid[cell.0][cell.1]];\n    visited.insert(cell);\n\
    \    for _ in 1..k {\n        cell = find_next(&grid, &visited, cell);\n     \
    \   res.push(grid[cell.0][cell.1]);\n        visited.insert(cell);\n    }\n  \
    \  res", "    let (n, mut curr, mut queue) = (grid.len(), vec![], VecDeque::new());\n\
    \    let mut visited = vec![vec![false; n]; n];\n    let mut result = vec![0;\
    \ k as usize];\n    let mut distance = vec![vec![std::usize::MAX; n]; n];\n  \
    \  distance[0][0] = 0;\n    queue.push_back((0, 0));\n    while !queue.is_empty()\
    \ {\n        let (i, j) = queue.pop_front().unwrap();\n        let d = distance[i][j];\n\
    \        if d > k as usize {\n            continue;\n        }\n        curr.push(grid[i][j]);\n\
    \        if d == k as usize {\n            result = {\n                let mut\
    \ result_ = result.clone();\n                for i in 0..k as usize {\n      \
    \              result_[i] = curr[i];\n                }\n                result_\n\
    \            };\n            curr.pop();\n            continue;\n        }\n \
    \       visited[i][j] = true;\n        let mut push = |i: usize, j: usize| {\n\
    \            if !visited[i][j] {\n                queue.push_back((i, j));\n \
    \               visited[i][j] = true;\n                distance[i][j] = d + 1;\n\
    \            }\n        };\n        if i > 0 {\n            push(i - 1, j);\n\
    \        }\n        if i + 1 < n {\n            push(i + 1, j);\n        }\n \
    \       if j > 0 {\n            push(i, j - 1);\n        }\n        if j + 1 <\
    \ n {\n            push(i, j + 1);\n        }\n        visited[i][j] = false;\n\
    \        curr.pop();\n    }\n    result", "    let n = grid.len();\n    let mut\
    \ visited = vec![false; n * n];\n    let mut min_path = Vec::new();\n    for i\
    \ in 0..n {\n        for j in 0..n {\n            visited[grid[i][j] as usize\
    \ - 1] = true;\n            min_path.push(grid[i][j]);\n            if let Some(new_path)\
    \ = dfs(grid, &mut visited, i, j, k - 1) {\n                if new_path < min_path\
    \ {\n                    min_path = new_path;\n                }\n           \
    \ }\n            visited[grid[i][j] as usize - 1] = false;\n        }\n    }\n\
    \    min_path", "    let mut v = vec![0; grid.len() * grid.len()];\n    let mut\
    \ pq = std::collections::BinaryHeap::new();\n    pq.push(Pos {\n        val: grid[0][0],\n\
    \        r: 0,\n        c: 0,\n        k: 0,\n    });\n    while !pq.is_empty()\
    \ {\n        let p = pq.pop().unwrap();\n        v[p.k as usize] = p.val;\n  \
    \      if p.k == k {\n            return v;\n        }\n        let [dr, dc] =\
    \ [0, 1, 0, -1, 0];\n        for i in 0..4 {\n            let nr = p.r + dr[i];\n\
    \            let nc = p.c + dc[i];\n            if nr >= 0 && nr < grid.len()\
    \ as isize && nc >= 0 && nc < grid.len() as isize {\n                pq.push(Pos\
    \ {\n                    val: grid[nr as usize][nc as usize],\n              \
    \      r: nr,\n                    c: nc,\n                    k: p.k + 1,\n \
    \               });\n            }\n        }\n    }\n    v", "    if k == 0 {\n\
    \        return vec![];\n    }\n    if grid.len() == 0 {\n        return vec![];\n\
    \    }\n    if grid.len() == 1 && grid[0].len() == 1 {\n        return vec![grid[0][0]];\n\
    \    }\n    if k == 1 {\n        return vec![grid[0][0]];\n    }\n    let mut\
    \ used: HashSet<(usize, usize)> = HashSet::new();\n    let mut last_x = 0;\n \
    \   let mut last_y = 0;\n    let mut min = isize::max_value();\n    dfs(&grid,\
    \ 0, 0, 0, k, &mut used, &mut last_x, &mut last_y, &mut min);\n    let mut ret\
    \ = vec![];\n    while last_x != 0 || last_y != 0 {\n        ret.push(grid[last_x][last_y]);\n\
    \        let dx = last_x as isize - grid[last_x][last_y] as isize + 1;\n     \
    \   let dy = last_y as isize - grid[last_x][last_y] as isize + 1;\n        if\
    \ dx >= 0 && dy >= 0 {\n            last_x = dx as usize;\n            last_y\
    \ = dy as usize;\n        } else if dx >= 0 {\n            last_x = dx as usize;\n\
    \            last_y = 0;\n        } else if dy >= 0 {\n            last_x = 0;\n\
    \            last_y = dy as usize;\n        } else {\n            last_x = 0;\n\
    \            last_y = 0;\n        }\n    }\n    ret.push(grid[0][0]);\n    ret.reverse();\n\
    \    ret", "    let n = grid.len();\n    assert!(k >= 1 && k <= n as isize * n\
    \ as isize);\n    let mut dp = vec![vec![vec![]; n]; n];\n    for i in 0..n {\n\
    \        for j in 0..n {\n            dp[i][j] = vec![];\n            let mut\
    \ v = vec![];\n            for dx in -1..=1 {\n                for dy in -1..=1\
    \ {\n                    if dx == 0 && dy == 0 {\n                        continue;\n\
    \                    }\n                    let (ii, jj) = (i as isize + dx, j\
    \ as isize + dy);\n                    if ii >= 0 && ii < n as isize && jj >=\
    \ 0 && jj < n as isize {\n                        v.push((ii, jj));\n        \
    \            }\n                }\n            }\n            v.sort_by_key(|&(x,\
    \ y)| grid[x as usize][y as usize]);\n            for (x, y) in v {\n        \
    \        let x = x as usize;\n                let y = y as usize;\n          \
    \      let mut a = dp[x][y].clone();\n                a.push(grid[x][y]);\n  \
    \              dp[i][j] = min_path(&a, &dp[i][j]);\n            }\n          \
    \  dp[i][j].push(grid[i][j]);\n        }\n    }\n    let mut res = vec![];\n \
    \   for i in 0..n {\n        for j in 0..n {\n            res = min_path(&dp[i][j],\
    \ &res);\n        }\n    }\n    res", "    let n = grid.len();\n    if n == 0\
    \ {\n        return vec![];\n    }\n    let n = n as isize;\n    let mut result\
    \ = vec![];\n    let mut visited = vec![vec![false; n as usize]; n as usize];\n\
    \    for i in 0..n {\n        for j in 0..n {\n            if visited[i as usize][j\
    \ as usize] {\n                continue;\n            }\n            let mut path\
    \ = vec![];\n            let mut curr = vec![i, j];\n            while !visited[curr[0]\
    \ as usize][curr[1] as usize] {\n                path.push(grid[curr[0] as usize][curr[1]\
    \ as usize]);\n                visited[curr[0] as usize][curr[1] as usize] = true;\n\
    \                let mut next = vec![];\n                for ii in 0..2 {\n  \
    \                  for jj in 0..2 {\n                        let mut valid = true;\n\
    \                        for kk in 0..2 {\n                            if ii ==\
    \ jj {\n                                if curr[kk] + jj * 2 - 1 < 0 || curr[kk]\
    \ + jj * 2 - 1 >= n {\n                                    valid = false;\n  \
    \                                  break;\n                                }\n\
    \                            } else {\n                                if curr[kk]\
    \ + ii * 2 - 1 < 0 || curr[kk] + ii * 2 - 1 >= n {\n                         \
    \           valid = false;\n                                    break;\n     \
    \                           }\n                            }\n               \
    \         }\n                        if valid {\n                            let\
    \ mut next_node = vec![curr[0], curr[1]];\n                            next_node[ii]\
    \ += ii * 2 - 1;\n                            next_node[jj] += jj * 2 - 1;\n \
    \                           next.push(next_node);\n                        }\n\
    \                    }\n                }\n                if next.len() == 0\
    \ {\n                    break;\n                }\n                let mut min_index\
    \ = 0;\n                for i in 1..next.len() {\n                    if grid[next[i][0]\
    \ as us", "    let n = grid.len();\n    let mut visited = vec![vec![false; n];\
    \ n];\n    let mut pq = BinaryHeap::new();\n    pq.push(State {\n        path:\
    \ vec![],\n        current: grid[0][0],\n        cost: 0,\n        next: (0, 0),\n\
    \    });\n    while let Some(state) = pq.pop() {\n        let (x, y) = state.next;\n\
    \        if visited[x][y] {\n            continue;\n        }\n        visited[x][y]\
    \ = true;\n        if state.cost == k {\n            return state.path;\n    \
    \    }\n        for (x2, y2) in get_next(x, y, n) {\n            pq.push(State\
    \ {\n                path: {\n                    let mut path = state.path.clone();\n\
    \                    path.push(grid[x2][y2]);\n                    path\n    \
    \            },\n                current: grid[x2][y2],\n                cost:\
    \ state.cost + 1,\n                next: (x2, y2),\n            });\n        }\n\
    \    }\n    unreachable!();", "    // We cannot visit less than 1 cell or more\
    \ than all the cells.\n    if k < 1 || k > grid.len() as isize * grid.len() as\
    \ isize {\n        return vec![];\n    }\n    // Just a helper function.\n   \
    \ fn all_neighbors(row: usize, col: usize, grid: &Vec<Vec<isize>>) -> Vec<(usize,\
    \ usize)> {\n        let mut result = vec![];\n        if row > 0 {\n        \
    \    result.push((row - 1, col));\n        }\n        if row < grid.len() - 1\
    \ {\n            result.push((row + 1, col));\n        }\n        if col > 0 {\n\
    \            result.push((row, col - 1));\n        }\n        if col < grid[0].len()\
    \ - 1 {\n            result.push((row, col + 1));\n        }\n        result\n\
    \    }\n    // We will use this function to recursively compute our result.\n\
    \    fn get_min_path(row: usize, col: usize, curr_k: isize, grid: &Vec<Vec<isize>>,\n\
    \                    cache: &mut HashMap<(usize, usize, isize), Vec<isize>>) ->\
    \ Vec<isize> {\n        // Handle the memoization part.\n        if let Some(res)\
    \ = cache.get(&(row, col, curr_k)) {\n            return res.clone();\n      \
    \  }\n        let mut result = vec![];\n        if curr_k == 1 {\n           \
    \ result.push(grid[row][col]);\n        } else {\n            // The recursive\
    \ part.\n            let mut min_path = vec![];\n            for (nr, nc) in all_neighbors(row,\
    \ col, grid) {\n                let partial_path = get_min_path(nr, nc, curr_k\
    \ - 1, grid, cache);\n                if partial_path.len() < min_path.len() ||\n\
    \                   partial_path.len() == min_path.len() && partial_path < min_path\
    \ {\n                    min_path = partial_path;\n               ", "    let\
    \ mut min_path = vec![];\n    let mut visited = vec![vec![false; grid.len()];\
    \ grid.len()];\n    let mut curr_path = vec![];\n    let mut grid_queue = GridQueue::new(grid);\n\
    \    while let Some(cell) = grid_queue.pop() {\n        curr_path.push(cell.value);\n\
    \        if curr_path.len() as isize == k {\n            if min_path.is_empty()\
    \ || curr_path < min_path {\n                min_path = curr_path.clone();\n \
    \           }\n            curr_path.pop();\n            continue;\n        }\n\
    \        if visited[cell.x][cell.y] {\n            curr_path.pop();\n        \
    \    continue;\n        }\n        visited[cell.x][cell.y] = true;\n        if\
    \ cell.x < grid.len() - 1 {\n            grid_queue.push(Cell {\n            \
    \    x: cell.x + 1,\n                y: cell.y,\n                value: grid[cell.x\
    \ + 1][cell.y],\n            });\n        }\n        if cell.y < grid.len() -\
    \ 1 {\n            grid_queue.push(Cell {\n                x: cell.x,\n      \
    \          y: cell.y + 1,\n                value: grid[cell.x][cell.y + 1],\n\
    \            });\n        }\n        if cell.x > 0 {\n            grid_queue.push(Cell\
    \ {\n                x: cell.x - 1,\n                y: cell.y,\n            \
    \    value: grid[cell.x - 1][cell.y],\n            });\n        }\n        if\
    \ cell.y > 0 {\n            grid_queue.push(Cell {\n                x: cell.x,\n\
    \                y: cell.y - 1,\n                value: grid[cell.x][cell.y -\
    \ 1],\n            });\n        }\n        curr_path.pop();\n    }\n    min_path",
  "    let mut dp = vec![vec![std::isize::MAX; grid.len()]; grid.len()];\n    dp[0][0]\
    \ = 0;\n    for i in 0..k {\n        let mut next = vec![vec![std::isize::MAX;\
    \ grid.len()]; grid.len()];\n        for r in 0..grid.len() {\n            for\
    \ c in 0..grid.len() {\n                if dp[r][c] == std::isize::MAX {\n   \
    \                 continue;\n                }\n                for &dir in &[(0,\
    \ 1), (0, -1), (1, 0), (-1, 0)] {\n                    let row = (r as isize +\
    \ dir.0) as usize;\n                    let col = (c as isize + dir.1) as usize;\n\
    \                    if row >= grid.len() || col >= grid.len() {\n           \
    \             continue;\n                    }\n                    let val =\
    \ dp[r][c] + grid[row][col];\n                    next[row][col] = std::cmp::min(next[row][col],\
    \ val);\n                }\n            }\n        }\n        dp = next;\n   \
    \ }\n    let mut path = vec![grid[0][0]];\n    let mut row = 0;\n    let mut col\
    \ = 0;\n    let mut next = vec![];\n    for i in 1..k {\n        for &dir in &[(0,\
    \ 1), (0, -1), (1, 0), (-1, 0)] {\n            let nrow = (row as isize + dir.0)\
    \ as usize;\n            let ncol = (col as isize + dir.1) as usize;\n       \
    \     if nrow >= grid.len() || ncol >= grid.len() {\n                continue;\n\
    \            }\n            next.push((nrow, ncol));\n        }\n        let mut\
    \ res = std::isize::MAX;\n        for &(nrow, ncol) in &next {\n            if\
    \ dp[nrow][ncol] < res {\n                res = dp[nrow][ncol];\n            \
    \    row = nrow;\n                col = n", "    let mut k = k;\n    let grid\
    \ = grid;\n    let n = grid.len();\n    let mut visited = Vec::with_capacity(n);\n\
    \    for _ in 0..n {\n        visited.push(vec![false; n]);\n    }\n    let mut\
    \ heap = BinaryHeap::new();\n    for i in 0..n {\n        for j in 0..n {\n  \
    \          heap.push(Reverse((grid[i][j], i, j)));\n        }\n    }\n    let\
    \ mut result = Vec::new();\n    while !heap.is_empty() {\n        let (value,\
    \ i, j) = heap.pop().unwrap().0;\n        visited[i][j] = true;\n        result.push(value);\n\
    \        k -= 1;\n        if k == 0 {\n            break;\n        }\n       \
    \ let offsets = [(0, 1), (0, -1), (1, 0), (-1, 0)];\n        for &(offset_i, offset_j)\
    \ in &offsets {\n            let new_i = i as isize + offset_i;\n            let\
    \ new_j = j as isize + offset_j;\n            if new_i >= 0 && new_i < n as isize\
    \ && new_j >= 0 && new_j < n as isize {\n                if !visited[new_i as\
    \ usize][new_j as usize] {\n                    heap.push(Reverse((grid[new_i\
    \ as usize][new_j as usize], new_i as usize, new_j as usize)));\n            \
    \    }\n            }\n        }\n    }\n    result", '    ', "    let n = grid.len();\n\
    \    let mut visited = vec![vec![false; n]; n];\n    let mut start = 0;\n    for\
    \ i in 0..n {\n        for j in 0..n {\n            if grid[i][j] == 1 {\n   \
    \             start = i * n + j;\n                break;\n            }\n    \
    \    }\n    }\n    let mut queue = vec![];\n    queue.push((start, vec![1]));\n\
    \    visited[start / n][start % n] = true;\n    while !queue.is_empty() {\n  \
    \      let (node, mut curr) = queue.remove(0);\n        if curr.len() == k as\
    \ usize {\n            return curr;\n        }\n        let row = node / n;\n\
    \        let col = node % n;\n        if row > 0 && !visited[row - 1][col] {\n\
    \            visited[row - 1][col] = true;\n            curr.push(grid[row - 1][col]);\n\
    \            queue.push(((row - 1) * n + col, curr.clone()));\n            curr.pop();\n\
    \        }\n        if row < n - 1 && !visited[row + 1][col] {\n            visited[row\
    \ + 1][col] = true;\n            curr.push(grid[row + 1][col]);\n            queue.push(((row\
    \ + 1) * n + col, curr.clone()));\n            curr.pop();\n        }\n      \
    \  if col > 0 && !visited[row][col - 1] {\n            visited[row][col - 1] =\
    \ true;\n            curr.push(grid[row][col - 1]);\n            queue.push((row\
    \ * n + col - 1, curr.clone()));\n            curr.pop();\n        }\n       \
    \ if col < n - 1 && !visited[row][col + 1] {\n            visited[row][col + 1]\
    \ = true;\n            curr.push(grid[row][col + 1]);\n            queue.push((row\
    \ * n + col + 1, curr.clone()));\n            curr.pop();\n        }\n    }\n",
  "  let n = grid.len();\n  let mut dp = vec![vec![0; n + 1]; n + 1];\n  let mut dsu\
    \ = UnionFind::new(n);\n  let mut edges = vec![];\n  let mut seen = vec![vec![false;\
    \ n]; n];\n  let mut seen_cnt = 0;\n  let mut seen_max = 0;\n  for i in 0..n {\n\
    \    for j in 0..n {\n      for di in -1..=1 {\n        for dj in -1..=1 {\n \
    \         if di * di + dj * dj == 1 {\n            edges.push((grid[i][j], grid[i\
    \ + di][j + dj]));\n          }\n        }\n      }\n    }\n  }\n  edges.sort();\n\
    \  for &(u, v) in &edges {\n    dsu.union(u, v);\n  }\n  let mut last = vec![];\n\
    \  let mut best = vec![];\n  while seen_cnt < n * n {\n    seen_max += 1;\n  \
    \  last = best;\n    best = vec![];\n    let mut tmp = vec![vec![0; n]; n];\n\
    \    for &(u, v) in &edges {\n      if dsu.size(u) == 1 || dsu.size(v) == 1 {\n\
    \        continue;\n      }\n      if dsu.size(u) + dsu.size(v) == n * n - seen_cnt\
    \ {\n        best.push((u, v));\n      }\n      if !seen[u][v] {\n        seen[u][v]\
    \ = true;\n        seen_cnt += 1;\n      }\n      tmp[u][v] = 1;\n      tmp[v][u]\
    \ = 1;\n    }\n    for k in 0..n {\n      for i in 0..n {\n        for j in 0..n\
    \ {\n          tmp[i][j] |= tmp[i][k] && tmp[k][j];\n        }\n      }\n    }\n\
    \    for i in 0..n {\n      for j in 0..n", "    use std::collections::HashMap;\n\
    \    use std::collections::HashSet;\n    use std::collections::VecDeque;\n   \
    \ use std::collections::BinaryHeap;\n    use std::hash::Hash;\n    use std::cmp::Reverse;\n\
    \n    let n = grid.len();\n    let n_k = n * n;\n    let mut grid_x = Vec::new();\n\
    \    let mut grid_y = Vec::new();\n    for i in 0..n {\n        for j in 0..n\
    \ {\n            grid_x.push(grid[i][j]);\n            grid_y.push(grid[j][i]);\n\
    \        }\n    }\n    let mut x = grid_x;\n    x.sort();\n    let mut y = grid_y;\n\
    \    y.sort();\n    let mut dp_map = HashMap::new();\n    let mut dp_queue = BinaryHeap::new();\n\
    \    let mut dp_set = HashSet::new();\n    dp_map.insert((0, 0), (0, Vec::new()));\n\
    \    dp_queue.push(Reverse((0, (0, 0))));\n    dp_set.insert((0, 0));\n    while\
    \ let Some(Reverse((dp, (x, y)))) = dp_queue.pop() {\n        if dp_map.get(&(x,\
    \ y)).unwrap().0 != dp {\n            continue;\n        }\n        let mut next_x\
    \ = None;\n        if x + 1 < n_k {\n            next_x = Some((x + 1, y));\n\
    \        }\n        let mut next_y = None;\n        if y + 1 < n_k {\n       \
    \     next_y = Some((x, y + 1));\n        }\n        let mut next_xy = None;\n\
    \        if let Some(next_x) = next_x {\n            if let Some(next_y) = next_y\
    \ {\n                if x + y + 1 < n_k {\n                    next_xy = Some((x\
    \ + 1, y + 1));\n                }\n            }\n        }\n        if let Some(next_",
  "    let n = grid.len();\n    let mut all_paths = Vec::new();\n    for i in 0..n\
    \ {\n        for j in 0..n {\n            all_paths.append(&mut minPathDFS(grid,\
    \ i, j, k));\n        }\n    }\n    all_paths.sort_by(|a, b| {\n        let mut\
    \ i = 0;\n        while i < a.len() && i < b.len() {\n            if a[i] < b[i]\
    \ {\n                return std::cmp::Ordering::Less;\n            } else if a[i]\
    \ > b[i] {\n                return std::cmp::Ordering::Greater;\n            }\n\
    \            i += 1;\n        }\n        if a.len() < b.len() {\n            std::cmp::Ordering::Less\n\
    \        } else {\n            std::cmp::Ordering::Greater\n        }\n    });\n\
    \    all_paths[0].clone()", "    let n = grid.len();\n    let nums = (1..(n*n+1)).collect::<Vec<isize>>();\n\
    \    let mut min_path = Vec::new();\n    let mut min_sum = std::isize::MAX;\n\
    \    for a in 0..n {\n        for b in 0..n {\n            let mut cur_path =\
    \ Vec::new();\n            let mut cur_sum = 0;\n            let mut cur_i = a;\n\
    \            let mut cur_j = b;\n            for _ in 0..k {\n               \
    \ cur_path.push(grid[cur_i][cur_j]);\n                cur_sum += grid[cur_i][cur_j];\n\
    \                let next_i = cur_i.wrapping_add(nums[cur_i*n+cur_j]);\n     \
    \           let next_j = cur_j.wrapping_add(nums[cur_j*n+cur_i]);\n          \
    \      cur_i = next_i % n;\n                cur_j = next_j % n;\n            }\n\
    \            if cur_sum < min_sum || (cur_sum == min_sum && cur_path < min_path)\
    \ {\n                min_sum = cur_sum;\n                min_path = cur_path;\n\
    \            }\n        }\n    }\n    min_path"]
stop_tokens:
- "\n}"
