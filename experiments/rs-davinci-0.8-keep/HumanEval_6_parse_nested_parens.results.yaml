name: HumanEval_6_parse_nested_parens
language: rs
results:
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    paren_string\n        .split(' ')\n        .map(|sub_string|\
    \ {\n            let mut level = 0;\n            let mut max_level = 0;\n    \
    \        for c in sub_string.chars() {\n                if c == '(' {\n      \
    \              level += 1;\n                } else if c == ')' {\n           \
    \         if level > max_level {\n                        max_level = level;\n\
    \                    }\n                    level -= 1;\n                }\n \
    \           }\n            max_level\n        })\n        .collect()\n}\n\nfn\
    \ main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let char_vec: Vec<char> = paren_string.chars().collect();\n\
    \    let mut parsed_vec: Vec<isize> = Vec::new();\n    let mut current_int: isize\
    \ = 0;\n    let mut min_int: isize = 0;\n    for x in char_vec {\n        if x\
    \ == '(' {\n            current_int += 1;\n        } else if x == ')' {\n    \
    \        current_int -= 1;\n        } else if x == ' ' {\n            if current_int\
    \ < min_int {\n                min_int = current_int;\n            }\n       \
    \     parsed_vec.push(current_int - min_int);\n            current_int = 0;\n\
    \        }\n    }\n    parsed_vec\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 0, 0]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpjuaxsz7y.rs:29:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut levels = Vec::new();\n    let mut nest_level =\
    \ 0;\n    let mut max_level = 0;\n    for ch in paren_string.chars() {\n     \
    \   if ch == '(' {\n            nest_level += 1;\n            if nest_level >\
    \ max_level {\n                max_level = nest_level;\n            }\n      \
    \  } else if ch == ')' {\n            nest_level -= 1;\n        } else if ch ==\
    \ ' ' {\n            levels.push(max_level);\n            max_level = 0;\n   \
    \         nest_level = 0;\n        }\n    }\n    levels.push(max_level);\n   \
    \ levels\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut tokens = Vec::new();\n    let mut paren_level =\
    \ 0;\n    let mut start_idx = 0;\n    for (i, ch) in paren_string.chars().enumerate()\
    \ {\n        match ch {\n            '(' => paren_level += 1,\n            ')'\
    \ => paren_level -= 1,\n            ' ' => {\n                if paren_level >\
    \ 0 {\n                    tokens.push(paren_level);\n                    paren_level\
    \ = 0;\n                    start_idx = i;\n                }\n            }\n\
    \            _ => {}\n        }\n    }\n    tokens\n}\n\nfn main() {\n    let\
    \ candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()())\
    \ ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpzo8kde1m.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut output: Vec<isize> = Vec::new();\n    for paren_group\
    \ in paren_string.split_whitespace() {\n        let mut max_depth = 0;\n     \
    \   let mut current_depth = 0;\n        for character in paren_group.chars() {\n\
    \            if character == '(' {\n                current_depth += 1;\n    \
    \            if current_depth > max_depth {\n                    max_depth = current_depth;\n\
    \                }\n            } else if character == ')' {\n               \
    \ current_depth -= 1;\n            }\n        }\n        output.push(max_depth);\n\
    \    }\n    output\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut levels: Vec<isize> = Vec::new();\n    let mut max_level\
    \ = 0;\n    let mut curr_level = 0;\n    for ch in paren_string.chars() {\n  \
    \      if ch == '(' {\n            curr_level += 1;\n            if curr_level\
    \ > max_level {\n                max_level = curr_level;\n            }\n    \
    \    } else if ch == ')' {\n            if curr_level > 0 {\n                curr_level\
    \ -= 1;\n            }\n        } else if ch == ' ' {\n            levels.push(max_level);\n\
    \            max_level = 0;\n            curr_level = 0;\n        }\n    }\n \
    \   levels.push(max_level);\n    levels\n}\n\nfn main() {\n    let candidate =\
    \ parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    paren_string\n        .split(' ')\n        .map(|group|\
    \ {\n            group\n                .chars()\n                .fold((1, 0),\
    \ |(level, max_level), c| match c {\n                    '(' => (level + 1, std::cmp::max(level\
    \ + 1, max_level)),\n                    ')' => (level - 1, max_level),\n    \
    \                _ => (level, max_level),\n                })\n              \
    \  .1\n        })\n        .collect()\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 4, 2, 4]`,\n right: `[2, 3, 1, 3]`', /tmp/tmp2u6ay40s.rs:24:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut level = 0;\n    let mut max_level = 0;\n    let\
    \ mut max_levels = Vec::new();\n    let mut in_group = false;\n    for paren in\
    \ paren_string.chars() {\n        match paren {\n            '(' => {\n      \
    \          if in_group {\n                    level += 1;\n                  \
    \  if level > max_level {\n                        max_level = level;\n      \
    \              }\n                } else {\n                    in_group = true;\n\
    \                    level = 1;\n                    max_level = 1;\n        \
    \        }\n            }\n            ')' => {\n                if level == 0\
    \ {\n                    panic!(\"Unmatched parentheses\");\n                }\n\
    \                level -= 1;\n                if level == 0 {\n              \
    \      in_group = false;\n                    max_levels.push(max_level);\n  \
    \              }\n            }\n            ' ' => {\n                if level\
    \ == 0 {\n                    in_group = false;\n                }\n         \
    \   }\n            _ => panic!(\"Invalid character in input: {}\", paren),\n \
    \       }\n    }\n    if level != 0 {\n        panic!(\"Invalid input - unmatched\
    \ parentheses\");\n    }\n    max_levels\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut result: Vec<isize> = Vec::new();\n    let mut current_level:\
    \ isize = 0;\n    let mut maximum_level: isize = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            current_level += 1;\n            if current_level\
    \ > maximum_level {\n                maximum_level = current_level;\n        \
    \    }\n        } else if c == ')' {\n            current_level -= 1;\n      \
    \  } else if c == ' ' {\n            result.push(maximum_level);\n           \
    \ maximum_level = 0;\n            current_level = 0;\n        }\n    }\n    result.push(maximum_level);\n\
    \    result\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut temp_max = 0;\n\
    \    let mut current_max = 0;\n    for s in paren_string.chars() {\n        if\
    \ s == '(' {\n            current_max += 1;\n            if current_max > temp_max\
    \ {\n                temp_max = current_max;\n            }\n        } else if\
    \ s == ')' {\n            if current_max > 0 {\n                current_max -=\
    \ 1;\n            } else {\n                result.push(temp_max);\n         \
    \       temp_max = 0;\n                current_max = 0;\n            }\n     \
    \   }\n    }\n    result.push(temp_max);\n    result\n}\n\nfn main() {\n    let\
    \ candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()())\
    \ ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpdzo8lk_1.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    paren_string\n        .split_whitespace()\n        .map(|s|\
    \ {\n            let mut cnt = 0;\n            let mut max_cnt = 0;\n        \
    \    for c in s.chars() {\n                if c == '(' {\n                   \
    \ cnt += 1;\n                } else if c == ')' {\n                    cnt -=\
    \ 1;\n                }\n                max_cnt = cmp::max(max_cnt, cnt);\n \
    \           }\n            max_cnt\n        })\n        .collect()\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n\
    \  --> /tmp/tmpydeucgpp.rs:18:27\n   |\n18 |                 max_cnt = cmp::max(max_cnt,\
    \ cnt);\n   |                           ^^^ use of undeclared crate or module\
    \ `cmp`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    paren_string\n        .split_whitespace()\n        .map(|group|\
    \ {\n            let mut depth = 0;\n            let mut max_depth = 0;\n    \
    \        for c in group.chars() {\n                if c == '(' {\n           \
    \         depth += 1;\n                } else if c == ')' {\n                \
    \    depth -= 1;\n                }\n                if depth > max_depth {\n\
    \                    max_depth = depth;\n                }\n            }\n  \
    \          max_depth\n        })\n        .collect()\n}\n\nfn main() {\n    let\
    \ candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()())\
    \ ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    paren_string\n        .split_whitespace()\n        .map(|paren_group|\
    \ {\n            paren_group\n                .chars()\n                .fold((0,\
    \ 0), |(max_level, level), c| match c {\n                    '(' => (max_level.max(level\
    \ + 1), level + 1),\n                    ')' => (max_level, level - 1),\n    \
    \                _ => panic!(\"Invalid character found in the string\"),\n   \
    \             })\n                .0\n        })\n        .collect()\n}\n\nfn\
    \ main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    // Your code here\n    let mut max_depth = 0;\n    let\
    \ mut max_depths = Vec::new();\n    let mut current_depth = 0;\n    for paren\
    \ in paren_string.chars() {\n        if paren == '(' {\n            current_depth\
    \ += 1;\n            if current_depth > max_depth {\n                max_depth\
    \ = current_depth;\n            }\n        } else if paren == ')' {\n        \
    \    if current_depth > 0 {\n                max_depths.push(max_depth);\n   \
    \             max_depth = 0;\n                current_depth -= 1;\n          \
    \  }\n        }\n    }\n    max_depths\n}\n\nfn main() {\n    let candidate =\
    \ parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 2, 0, 3, 0, 0, 1, 3, 0, 2, 2, 0]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpfoq5zjx_.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut result: Vec<isize> = Vec::new();\n    let mut max_level:\
    \ isize = 0;\n    let mut current_level: isize = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            current_level += 1;\n            if current_level\
    \ > max_level {\n                max_level = current_level;\n            }\n \
    \       } else if c == ')' {\n            current_level -= 1;\n        } else\
    \ if c == ' ' {\n            result.push(max_level);\n            max_level =\
    \ 0;\n            current_level = 0;\n        }\n    }\n    result.push(max_level);\n\
    \    result\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut depths = Vec::new();\n    let mut depth = 0;\n\
    \    let mut group_depth = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            depth += 1;\n            group_depth = max(group_depth,\
    \ depth);\n        } else if c == ')' {\n            depth -= 1;\n        } else\
    \ if c == ' ' {\n            depths.push(group_depth);\n            group_depth\
    \ = 0;\n        }\n    }\n    depths.push(group_depth);\n    depths\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmpejuiiebn.rs:13:27\n\
    \   |\n13 |             group_depth = max(group_depth, depth);\n   |         \
    \                  ^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this function\n   |\n1  | use std::cmp::max;\n   |\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_string = paren_string;\n    let mut result\
    \ = Vec::new();\n    let left_paren = '('.to_string();\n    let right_paren =\
    \ ')'.to_string();\n    let next_paren_idx = |paren_string: &String, paren: &String|\
    \ {\n        let next_idx = paren_string.find(paren);\n        if next_idx.is_none()\
    \ {\n            None\n        } else {\n            Some(next_idx.unwrap() as\
    \ isize)\n        }\n    };\n    let mut stack: Vec<String> = Vec::new();\n  \
    \  let mut next_left_paren_idx = next_paren_idx(&paren_string, &left_paren);\n\
    \    let mut next_right_paren_idx = next_paren_idx(&paren_string, &right_paren);\n\
    \    while next_left_paren_idx.is_some() || next_right_paren_idx.is_some() {\n\
    \        if next_left_paren_idx.is_none() || next_right_paren_idx.is_some() &&\
    \ next_right_paren_idx.unwrap() < next_left_paren_idx.unwrap() {\n           \
    \ let next_right_paren_idx = next_right_paren_idx.unwrap();\n            paren_string\
    \ = paren_string.replace_range(next_right_paren_idx as usize..next_right_paren_idx\
    \ as usize + 1, \"\");\n            if stack.is_empty() {\n                result.push(0);\n\
    \            } else {\n                stack.pop();\n                if stack.is_empty()\
    \ {\n                    result.push(0);\n                }\n            }\n \
    \           next_right_paren_idx = next_paren_idx(&paren_string, &right_paren);\n\
    \        } else {\n            let next_left_paren_idx = next_left_paren_idx.unwrap();\n\
    \            paren_string = paren_string.replace_range(next_left_paren_idx as\
    \ usize..next_left_paren_idx as us\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpufot2l9b.rs:45:3\n\
    \   |\n6  | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n   |\
    \                                                            - unclosed delimiter\n\
    ...\n22 |     while next_left_paren_idx.is_some() || next_right_paren_idx.is_some()\
    \ {\n   |                                                                    \
    \       - unclosed delimiter\n...\n35 |         } else {\n   |               \
    \ - this delimiter might not be properly closed...\n...\n38 | }\n   | - ...as\
    \ it matches this but it has different indentation\n...\n45 | }\n   |   ^\n\n\
    error: mismatched closing delimiter: `}`\n  --> /tmp/tmpufot2l9b.rs:37:54\n  \
    \ |\n6  | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n   | \
    \                                                           - closing delimiter\
    \ possibly meant for this\n...\n37 |             paren_string = paren_string.replace_range(next_left_paren_idx\
    \ as usize..next_left_paren_idx as us\n   |                                  \
    \                    ^ unclosed delimiter\n38 | }\n   | ^ mismatched closing delimiter\n\
    \nerror[E0412]: cannot find type `us` in this scope\n  --> /tmp/tmpufot2l9b.rs:37:108\n\
    \   |\n37 |             paren_string = paren_string.replace_range(next_left_paren_idx\
    \ as usize..next_left_paren_idx as us\n   |                                  \
    \                                                                          ^^\
    \ help: a builtin type with a similar name exists: `u8`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpufot2l9b.rs:25:28\n   |\n7  |     let mut paren_string\
    \ = paren_string;\n   |                            ------------ expected due to\
    \ this value\n...\n25 |             paren_string = paren_string.replace_range(next_right_paren_idx\
    \ as usize..next_right_paren_idx as usize + 1, \"\");\n   |                  \
    \          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `()`\n   |\nnote: method `replace_range` modifies\
    \ its receiver in-place\n  --> /tmp/tmpufot2l9"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut total_nesting = 0;\n    let mut max_nesting = 0;\n\
    \    let mut max_nesting_depth = vec![];\n    for c in paren_string.chars() {\n\
    \        if c == '(' {\n            total_nesting += 1;\n            if total_nesting\
    \ > max_nesting {\n                max_nesting = total_nesting;\n            }\n\
    \        } else if c == ')' {\n            if total_nesting == max_nesting {\n\
    \                max_nesting_depth.push(max_nesting);\n                max_nesting\
    \ = 0;\n            }\n            total_nesting -= 1;\n        } else if c ==\
    \ ' ' {\n            if total_nesting > 0 {\n                max_nesting_depth.push(max_nesting);\n\
    \                max_nesting = 0;\n            }\n            total_nesting =\
    \ 0;\n        }\n    }\n    max_nesting_depth\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 2, 3, 1, 3, 2, 2]`,\n right: `[2, 3, 1, 3]`', /tmp/tmp7nk7oc53.rs:35:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_nesting = 0;\n    let mut nesting = 0;\n  \
    \  let mut results = Vec::new();\n    for paren in paren_string.chars() {\n  \
    \      match paren {\n            '(' => {\n                nesting += 1;\n  \
    \              if nesting > max_nesting {\n                    max_nesting = nesting;\n\
    \                }\n            }\n            ')' => {\n                nesting\
    \ -= 1;\n            }\n            ' ' => {\n                results.push(max_nesting);\n\
    \                max_nesting = 0;\n                nesting = 0;\n            }\n\
    \            _ => {}\n        }\n    }\n    results.push(max_nesting);\n    results\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut depth = 0;\n    let mut levels = Vec::new();\n\
    \    for paren in paren_string.chars() {\n        match paren {\n            '('\
    \ => depth += 1,\n            ')' => depth -= 1,\n            ' ' => {\n     \
    \           levels.push(depth);\n                depth = 0;\n            }\n \
    \           _ => {}\n        }\n    }\n    levels\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 0, 0]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpdgj_aab1.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
