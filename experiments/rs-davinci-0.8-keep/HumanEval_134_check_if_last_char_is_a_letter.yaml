name: HumanEval_134_check_if_last_char_is_a_letter
language: rs
prompt: "/// Create a function that returns True if the last character\n/// of a given\
  \ string is an alphabetical character and is not\n/// a part of a word, and False\
  \ otherwise.\n/// Note: \"word\" is a group of characters separated by space.\n\
  /// Examples:\n/// check_if_last_char_is_a_letter(\"apple pie\") \u279E False\n\
  /// check_if_last_char_is_a_letter(\"apple pi e\") \u279E True\n/// check_if_last_char_is_a_letter(\"\
  apple pi e \") \u279E False\n/// check_if_last_char_is_a_letter(\"\") \u279E False\n\
  fn check_if_last_char_is_a_letter(txt: String) -> bool {\n"
tests: "}\n\nfn main() {\n    let candidate = check_if_last_char_is_a_letter;\n  \
  \  assert_eq!(candidate(String::from(\"apple\")), false);\n    assert_eq!(candidate(String::from(\"\
  apple pi e\")), true);\n    assert_eq!(candidate(String::from(\"eeeee\")), false);\n\
  \    assert_eq!(candidate(String::from(\"A\")), true);\n    assert_eq!(candidate(String::from(\"\
  Pumpkin pie \")), false);\n    assert_eq!(candidate(String::from(\"Pumpkin pie 1\"\
  )), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
  eeeee e \")), false);\n    assert_eq!(candidate(String::from(\"apple pie\")), false);\n\
  \    assert_eq!(candidate(String::from(\"apple pi e \")), false);\n}\n"
completions: ["    let last_char = txt.chars().last();\n    match last_char {\n  \
    \      Some(c) => c.is_alphabetic() && !c.is_alphanumeric(),\n        None =>\
    \ false,\n    }", "    if txt.len() == 0 {\n        return false;\n    }\n   \
    \ let chars: Vec<char> = txt.chars().collect();\n    match chars[chars.len() -\
    \ 1].is_alphabetic() {\n        true => !chars[chars.len() - 2].is_alphabetic(),\n\
    \        false => false,\n    }", '    unimplemented!()', '    txt.trim().len()
    > 0 && txt.chars().last().unwrap().is_alphabetic()', "    let last_char = &txt[txt.len()\
    \ - 1..];\n    if last_char.is_empty() {\n        return false;\n    }\n    last_char.chars().next().unwrap().is_alphabetic()\
    \ && last_char.contains(\" \")", "    let mut txt = txt.chars().peekable();\n\
    \    let mut chars = vec![];\n    while let Some(c) = txt.next() {\n        if\
    \ c == ' ' {\n            chars.clear();\n        } else {\n            chars.push(c);\n\
    \        }\n    }\n    if chars.len() == 0 {\n        return false;\n    }\n \
    \   chars.pop().unwrap().is_alphabetic()", '    txt.len() > 0 && !txt.trim().is_empty()
    && txt.trim().chars().last().unwrap().is_alphabetic()', "    let txt = txt.trim();\n\
    \    if txt.is_empty() {\n        return false;\n    }\n    let last_char = txt.chars().last().unwrap();\n\
    \    let last_char_char = last_char.to_string();\n    if !last_char_char.chars().all(char::is_alphabetic)\
    \ {\n        return false;\n    }\n    if txt.len() == 1 {\n        return true;\n\
    \    }\n    let before_last_char = txt.chars().nth(txt.len() - 2).unwrap();\n\
    \    let before_last_char_str = before_last_char.to_string();\n    !before_last_char_str.chars().all(char::is_alphabetic)",
  "    for i in txt.chars().rev() {\n        if i.is_alphabetic() {\n            return\
    \ true;\n        } else if i.is_whitespace() {\n            return false;\n  \
    \      }\n    }\n    false", "    if txt.len() == 0 {\n        return false;\n\
    \    }\n    let end = txt.chars().rev().nth(0).unwrap();\n    end.is_alphabetic()\
    \ && end.is_uppercase()", "    let last_char = txt.chars().last().unwrap();\n\
    \    last_char.is_alphabetic() && !last_char.is_whitespace()", "    let mut last_char\
    \ = None;\n    for c in txt.chars() {\n        if c.is_whitespace() {\n      \
    \      last_char = None;\n        } else {\n            last_char = Some(c);\n\
    \        }\n    }\n    last_char.map_or(false, |c| c.is_alphabetic())", "    let\
    \ mut last_char = ' ';\n    for c in txt.chars() {\n        if !c.is_whitespace()\
    \ {\n            last_char = c;\n        }\n    }\n    last_char.is_alphabetic()",
  '    txt.split_whitespace().last().map_or(false, |c| c.chars().last().map_or(false,
    |x| x.is_alphabetic()))', '    return false;', "    let last_char = &txt[txt.len()\
    \ - 1..];\n    let last_char_is_letter = last_char.chars().count() == 1 && last_char.chars().next().unwrap().is_alphabetic();\n\
    \    last_char_is_letter && (txt.len() < 2 || &txt[txt.len() - 2..txt.len() -\
    \ 1] == \" \")", "    txt.chars().rev().nth(0).unwrap().is_alphabetic()\n    \
    \    && !txt.chars().rev().nth(1).unwrap().is_alphabetic()", "    let mut last_char\
    \ = ' ';\n    for c in txt.chars() {\n        if c.is_alphabetic() {\n       \
    \     last_char = c;\n        }\n    }\n    !last_char.is_alphabetic() || last_char.is_whitespace()",
  "    if txt.is_empty() {\n        return false;\n    }\n    let trimmed = txt.trim();\n\
    \    let chars: Vec<char> = trimmed.chars().collect();\n    let c = chars[chars.len()\
    \ - 1];\n    c.is_alphabetic() && !c.is_alphanumeric()", "    let mut result =\
    \ false;\n    let mut counter = 0;\n    for c in txt.chars() {\n        if c.is_alphabetic()\
    \ {\n            counter += 1;\n        }\n    }\n    if counter == 1 {\n    \
    \    result = true;\n    }\n    result"]
stop_tokens:
- "\n}"
