name: HumanEval_6_parse_nested_parens
language: rs
prompt: "/// Input to this function is a string represented multiple groups for nested\
  \ parentheses separated by spaces.\n/// For each of the group, output the deepest\
  \ level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting\
  \ while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n\
  /// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n"
tests: "}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
  (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
  () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
  (()(())((())))\")), vec![4]);\n}\n"
completions: ["    paren_string\n        .split(' ')\n        .map(|sub_string| {\n\
    \            let mut level = 0;\n            let mut max_level = 0;\n        \
    \    for c in sub_string.chars() {\n                if c == '(' {\n          \
    \          level += 1;\n                } else if c == ')' {\n               \
    \     if level > max_level {\n                        max_level = level;\n   \
    \                 }\n                    level -= 1;\n                }\n    \
    \        }\n            max_level\n        })\n        .collect()", "    let char_vec:\
    \ Vec<char> = paren_string.chars().collect();\n    let mut parsed_vec: Vec<isize>\
    \ = Vec::new();\n    let mut current_int: isize = 0;\n    let mut min_int: isize\
    \ = 0;\n    for x in char_vec {\n        if x == '(' {\n            current_int\
    \ += 1;\n        } else if x == ')' {\n            current_int -= 1;\n       \
    \ } else if x == ' ' {\n            if current_int < min_int {\n             \
    \   min_int = current_int;\n            }\n            parsed_vec.push(current_int\
    \ - min_int);\n            current_int = 0;\n        }\n    }\n    parsed_vec",
  "    let mut levels = Vec::new();\n    let mut nest_level = 0;\n    let mut max_level\
    \ = 0;\n    for ch in paren_string.chars() {\n        if ch == '(' {\n       \
    \     nest_level += 1;\n            if nest_level > max_level {\n            \
    \    max_level = nest_level;\n            }\n        } else if ch == ')' {\n \
    \           nest_level -= 1;\n        } else if ch == ' ' {\n            levels.push(max_level);\n\
    \            max_level = 0;\n            nest_level = 0;\n        }\n    }\n \
    \   levels.push(max_level);\n    levels", "    let mut tokens = Vec::new();\n\
    \    let mut paren_level = 0;\n    let mut start_idx = 0;\n    for (i, ch) in\
    \ paren_string.chars().enumerate() {\n        match ch {\n            '(' => paren_level\
    \ += 1,\n            ')' => paren_level -= 1,\n            ' ' => {\n        \
    \        if paren_level > 0 {\n                    tokens.push(paren_level);\n\
    \                    paren_level = 0;\n                    start_idx = i;\n  \
    \              }\n            }\n            _ => {}\n        }\n    }\n    tokens",
  "    let mut output: Vec<isize> = Vec::new();\n    for paren_group in paren_string.split_whitespace()\
    \ {\n        let mut max_depth = 0;\n        let mut current_depth = 0;\n    \
    \    for character in paren_group.chars() {\n            if character == '(' {\n\
    \                current_depth += 1;\n                if current_depth > max_depth\
    \ {\n                    max_depth = current_depth;\n                }\n     \
    \       } else if character == ')' {\n                current_depth -= 1;\n  \
    \          }\n        }\n        output.push(max_depth);\n    }\n    output",
  "    let mut levels: Vec<isize> = Vec::new();\n    let mut max_level = 0;\n    let\
    \ mut curr_level = 0;\n    for ch in paren_string.chars() {\n        if ch ==\
    \ '(' {\n            curr_level += 1;\n            if curr_level > max_level {\n\
    \                max_level = curr_level;\n            }\n        } else if ch\
    \ == ')' {\n            if curr_level > 0 {\n                curr_level -= 1;\n\
    \            }\n        } else if ch == ' ' {\n            levels.push(max_level);\n\
    \            max_level = 0;\n            curr_level = 0;\n        }\n    }\n \
    \   levels.push(max_level);\n    levels", "    paren_string\n        .split('\
    \ ')\n        .map(|group| {\n            group\n                .chars()\n  \
    \              .fold((1, 0), |(level, max_level), c| match c {\n             \
    \       '(' => (level + 1, std::cmp::max(level + 1, max_level)),\n           \
    \         ')' => (level - 1, max_level),\n                    _ => (level, max_level),\n\
    \                })\n                .1\n        })\n        .collect()", "  \
    \  let mut level = 0;\n    let mut max_level = 0;\n    let mut max_levels = Vec::new();\n\
    \    let mut in_group = false;\n    for paren in paren_string.chars() {\n    \
    \    match paren {\n            '(' => {\n                if in_group {\n    \
    \                level += 1;\n                    if level > max_level {\n   \
    \                     max_level = level;\n                    }\n            \
    \    } else {\n                    in_group = true;\n                    level\
    \ = 1;\n                    max_level = 1;\n                }\n            }\n\
    \            ')' => {\n                if level == 0 {\n                    panic!(\"\
    Unmatched parentheses\");\n                }\n                level -= 1;\n  \
    \              if level == 0 {\n                    in_group = false;\n      \
    \              max_levels.push(max_level);\n                }\n            }\n\
    \            ' ' => {\n                if level == 0 {\n                    in_group\
    \ = false;\n                }\n            }\n            _ => panic!(\"Invalid\
    \ character in input: {}\", paren),\n        }\n    }\n    if level != 0 {\n \
    \       panic!(\"Invalid input - unmatched parentheses\");\n    }\n    max_levels",
  "    let mut result: Vec<isize> = Vec::new();\n    let mut current_level: isize\
    \ = 0;\n    let mut maximum_level: isize = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            current_level += 1;\n            if current_level\
    \ > maximum_level {\n                maximum_level = current_level;\n        \
    \    }\n        } else if c == ')' {\n            current_level -= 1;\n      \
    \  } else if c == ' ' {\n            result.push(maximum_level);\n           \
    \ maximum_level = 0;\n            current_level = 0;\n        }\n    }\n    result.push(maximum_level);\n\
    \    result", "    let mut result = Vec::new();\n    let mut temp_max = 0;\n \
    \   let mut current_max = 0;\n    for s in paren_string.chars() {\n        if\
    \ s == '(' {\n            current_max += 1;\n            if current_max > temp_max\
    \ {\n                temp_max = current_max;\n            }\n        } else if\
    \ s == ')' {\n            if current_max > 0 {\n                current_max -=\
    \ 1;\n            } else {\n                result.push(temp_max);\n         \
    \       temp_max = 0;\n                current_max = 0;\n            }\n     \
    \   }\n    }\n    result.push(temp_max);\n    result", "    paren_string\n   \
    \     .split_whitespace()\n        .map(|s| {\n            let mut cnt = 0;\n\
    \            let mut max_cnt = 0;\n            for c in s.chars() {\n        \
    \        if c == '(' {\n                    cnt += 1;\n                } else\
    \ if c == ')' {\n                    cnt -= 1;\n                }\n          \
    \      max_cnt = cmp::max(max_cnt, cnt);\n            }\n            max_cnt\n\
    \        })\n        .collect()", "    paren_string\n        .split_whitespace()\n\
    \        .map(|group| {\n            let mut depth = 0;\n            let mut max_depth\
    \ = 0;\n            for c in group.chars() {\n                if c == '(' {\n\
    \                    depth += 1;\n                } else if c == ')' {\n     \
    \               depth -= 1;\n                }\n                if depth > max_depth\
    \ {\n                    max_depth = depth;\n                }\n            }\n\
    \            max_depth\n        })\n        .collect()", "    paren_string\n \
    \       .split_whitespace()\n        .map(|paren_group| {\n            paren_group\n\
    \                .chars()\n                .fold((0, 0), |(max_level, level),\
    \ c| match c {\n                    '(' => (max_level.max(level + 1), level +\
    \ 1),\n                    ')' => (max_level, level - 1),\n                  \
    \  _ => panic!(\"Invalid character found in the string\"),\n                })\n\
    \                .0\n        })\n        .collect()", "    // Your code here\n\
    \    let mut max_depth = 0;\n    let mut max_depths = Vec::new();\n    let mut\
    \ current_depth = 0;\n    for paren in paren_string.chars() {\n        if paren\
    \ == '(' {\n            current_depth += 1;\n            if current_depth > max_depth\
    \ {\n                max_depth = current_depth;\n            }\n        } else\
    \ if paren == ')' {\n            if current_depth > 0 {\n                max_depths.push(max_depth);\n\
    \                max_depth = 0;\n                current_depth -= 1;\n       \
    \     }\n        }\n    }\n    max_depths", "    let mut result: Vec<isize> =\
    \ Vec::new();\n    let mut max_level: isize = 0;\n    let mut current_level: isize\
    \ = 0;\n    for c in paren_string.chars() {\n        if c == '(' {\n         \
    \   current_level += 1;\n            if current_level > max_level {\n        \
    \        max_level = current_level;\n            }\n        } else if c == ')'\
    \ {\n            current_level -= 1;\n        } else if c == ' ' {\n         \
    \   result.push(max_level);\n            max_level = 0;\n            current_level\
    \ = 0;\n        }\n    }\n    result.push(max_level);\n    result", "    let mut\
    \ depths = Vec::new();\n    let mut depth = 0;\n    let mut group_depth = 0;\n\
    \    for c in paren_string.chars() {\n        if c == '(' {\n            depth\
    \ += 1;\n            group_depth = max(group_depth, depth);\n        } else if\
    \ c == ')' {\n            depth -= 1;\n        } else if c == ' ' {\n        \
    \    depths.push(group_depth);\n            group_depth = 0;\n        }\n    }\n\
    \    depths.push(group_depth);\n    depths", "    let mut paren_string = paren_string;\n\
    \    let mut result = Vec::new();\n    let left_paren = '('.to_string();\n   \
    \ let right_paren = ')'.to_string();\n    let next_paren_idx = |paren_string:\
    \ &String, paren: &String| {\n        let next_idx = paren_string.find(paren);\n\
    \        if next_idx.is_none() {\n            None\n        } else {\n       \
    \     Some(next_idx.unwrap() as isize)\n        }\n    };\n    let mut stack:\
    \ Vec<String> = Vec::new();\n    let mut next_left_paren_idx = next_paren_idx(&paren_string,\
    \ &left_paren);\n    let mut next_right_paren_idx = next_paren_idx(&paren_string,\
    \ &right_paren);\n    while next_left_paren_idx.is_some() || next_right_paren_idx.is_some()\
    \ {\n        if next_left_paren_idx.is_none() || next_right_paren_idx.is_some()\
    \ && next_right_paren_idx.unwrap() < next_left_paren_idx.unwrap() {\n        \
    \    let next_right_paren_idx = next_right_paren_idx.unwrap();\n            paren_string\
    \ = paren_string.replace_range(next_right_paren_idx as usize..next_right_paren_idx\
    \ as usize + 1, \"\");\n            if stack.is_empty() {\n                result.push(0);\n\
    \            } else {\n                stack.pop();\n                if stack.is_empty()\
    \ {\n                    result.push(0);\n                }\n            }\n \
    \           next_right_paren_idx = next_paren_idx(&paren_string, &right_paren);\n\
    \        } else {\n            let next_left_paren_idx = next_left_paren_idx.unwrap();\n\
    \            paren_string = paren_string.replace_range(next_left_paren_idx as\
    \ usize..next_left_paren_idx as us", "    let mut total_nesting = 0;\n    let\
    \ mut max_nesting = 0;\n    let mut max_nesting_depth = vec![];\n    for c in\
    \ paren_string.chars() {\n        if c == '(' {\n            total_nesting +=\
    \ 1;\n            if total_nesting > max_nesting {\n                max_nesting\
    \ = total_nesting;\n            }\n        } else if c == ')' {\n            if\
    \ total_nesting == max_nesting {\n                max_nesting_depth.push(max_nesting);\n\
    \                max_nesting = 0;\n            }\n            total_nesting -=\
    \ 1;\n        } else if c == ' ' {\n            if total_nesting > 0 {\n     \
    \           max_nesting_depth.push(max_nesting);\n                max_nesting\
    \ = 0;\n            }\n            total_nesting = 0;\n        }\n    }\n    max_nesting_depth",
  "    let mut max_nesting = 0;\n    let mut nesting = 0;\n    let mut results = Vec::new();\n\
    \    for paren in paren_string.chars() {\n        match paren {\n            '('\
    \ => {\n                nesting += 1;\n                if nesting > max_nesting\
    \ {\n                    max_nesting = nesting;\n                }\n         \
    \   }\n            ')' => {\n                nesting -= 1;\n            }\n  \
    \          ' ' => {\n                results.push(max_nesting);\n            \
    \    max_nesting = 0;\n                nesting = 0;\n            }\n         \
    \   _ => {}\n        }\n    }\n    results.push(max_nesting);\n    results", " \
    \   let mut depth = 0;\n    let mut levels = Vec::new();\n    for paren in paren_string.chars()\
    \ {\n        match paren {\n            '(' => depth += 1,\n            ')' =>\
    \ depth -= 1,\n            ' ' => {\n                levels.push(depth);\n   \
    \             depth = 0;\n            }\n            _ => {}\n        }\n    }\n\
    \    levels"]
stop_tokens:
- "\n}"
