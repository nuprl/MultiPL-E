name: HumanEval_70_strange_sort_list
language: rs
prompt: "/// Given list of integers, return list in strange order.\n/// Strange sorting,\
  \ is when you start with the minimum value,\n/// then maximum of the remaining integers,\
  \ then minimum and so on.\n/// Examples:\n/// strange_sort_list([1, 2, 3, 4]) ==\
  \ [1, 4, 2, 3]\n/// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n/// strange_sort_list([])\
  \ == []\nfn strange_sort_list(lst: Vec<isize>) -> Vec<isize> {\n"
tests: "}\n\nfn main() {\n    let candidate = strange_sort_list;\n    assert_eq!(candidate(vec![1,\
  \ 2, 3, 4]), vec![1, 4, 2, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9]),\
  \ vec![5, 9, 6, 8, 7]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), vec![1,\
  \ 5, 2, 4, 3]);\n    assert_eq!(candidate(vec![5, 6, 7, 8, 9, 1]), vec![1, 9, 5,\
  \ 8, 6, 7]);\n    assert_eq!(candidate(vec![5, 5, 5, 5]), vec![5, 5, 5, 5]);\n \
  \   assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
  \ 2, 3, 4, 5, 6, 7, 8]), vec![1, 8, 2, 7, 3, 6, 4, 5]);\n    assert_eq!(candidate(vec![0,\
  \ 2, 2, 2, 5, 5, -5, -5]), vec![-5, 5, -5, 5, 0, 2, 2, 2]);\n    assert_eq!(candidate(vec![111111]),\
  \ vec![111111]);\n}\n"
completions: ['    lst', "    let mut v: Vec<isize> = lst;\n    v.sort();\n    v.reverse();\n\
    \    return v;", "    let mut lst: Vec<isize> = lst;\n    lst.sort();\n    let\
    \ mut result: Vec<isize> = Vec::new();\n    while !lst.is_empty() {\n        result.push(lst.remove(0));\n\
    \        if !lst.is_empty() {\n            result.push(lst.pop().unwrap());\n\
    \        }\n    }\n    result", "    let mut result = Vec::new();\n    if lst.len()\
    \ == 0 {\n        return result;\n    }\n    let mut lst = lst;\n    while lst.len()\
    \ > 0 {\n        let min = lst.iter().min().unwrap();\n        result.push(*min);\n\
    \        lst.remove_item(min);\n        if lst.len() == 0 {\n            break;\n\
    \        }\n        let max = lst.iter().max().unwrap();\n        result.push(*max);\n\
    \        lst.remove_item(max);\n    }\n    result", "    let mut lst = lst;\n\
    \    let mut res = Vec::new();\n    while !lst.is_empty() {\n        res.push(lst.remove(0));\n\
    \        let m = lst.iter().enumerate().fold(0, |max, (i, x)| if x > &lst[max]\
    \ { i } else { max });\n        res.push(lst.remove(m));\n    }\n    res", " \
    \   let mut lst = lst;\n    lst.sort();\n    let mut res = Vec::new();\n    while\
    \ !lst.is_empty() {\n        let first = lst.remove(0);\n        let last = lst.pop();\n\
    \        if let Some(last) = last {\n            res.push(first);\n          \
    \  res.push(last);\n        } else {\n            res.push(first);\n        }\n\
    \    }\n    res", "    let mut min_values = vec![];\n    let mut max_values =\
    \ vec![];\n    for x in lst {\n        if x < 0 {\n            max_values.push(x);\n\
    \        } else {\n            min_values.push(x);\n        }\n    }\n    max_values.sort();\n\
    \    min_values.sort();\n    max_values.reverse();\n    let mut result = vec![];\n\
    \    let mut toggle = true;\n    while min_values.len() > 0 || max_values.len()\
    \ > 0 {\n        if toggle {\n            if min_values.len() > 0 {\n        \
    \        result.push(min_values.remove(0));\n            }\n        } else {\n\
    \            if max_values.len() > 0 {\n                result.push(max_values.remove(0));\n\
    \            }\n        }\n        toggle = !toggle;\n    }\n    result", "  \
    \  let mut v = lst;\n    v.sort();\n    v.iter().step_by(2).rev().chain(v.iter().step_by(2)).cloned().collect()",
  '    unimplemented!("Sort the list {:?} using the strange sort algorithm", lst);',
  "    fn list_extremes(lst: &[isize]) -> (isize, isize) {\n        let mut min =\
    \ lst[0];\n        let mut max = lst[0];\n        for &i in lst {\n          \
    \  if i < min {\n                min = i;\n            }\n            if i > max\
    \ {\n                max = i;\n            }\n        }\n        (min, max)\n\
    \    }\n\n    fn strange_sort_list_inner(lst: &[isize]) -> Vec<isize> {\n    \
    \    if lst.len() == 0 {\n            return vec![];\n        }\n        let (min,\
    \ max) = list_extremes(lst);\n        let mut res = vec![min];\n        let remaining\
    \ = lst.iter().filter(|&&x| x != min && x != max).cloned().collect::<Vec<_>>();\n\
    \        res.append(&mut strange_sort_list_inner(&remaining));\n        if lst.iter().any(|&x|\
    \ x == max) {\n            res.push(max);\n        }\n        res\n    }\n\n \
    \   strange_sort_list_inner(&lst)", "    // your code here\n    let mut lst =\
    \ lst;\n    lst.sort();\n    let mut r = Vec::new();\n    let mut left = true;\n\
    \    while !lst.is_empty() {\n        if left {\n            r.push(lst.remove(0));\n\
    \        } else {\n            r.push(lst.pop().unwrap());\n        }\n      \
    \  left = !left;\n    }\n    r", "    let mut lst = lst;\n    lst.sort();\n  \
    \  let mut result = Vec::new();\n    let mut left_index = 0;\n    let mut right_index\
    \ = lst.len() - 1;\n    while left_index <= right_index {\n        result.push(lst[left_index]);\n\
    \        left_index += 1;\n        if left_index <= right_index {\n          \
    \  result.push(lst[right_index]);\n            right_index -= 1;\n        }\n\
    \    }\n    result", "    let mut res = Vec::new();\n    let mut max_heap = BinaryHeap::from(lst);\n\
    \    let mut min_heap = BinaryHeap::new();\n    while let Some(max) = max_heap.pop()\
    \ {\n        min_heap.push(max);\n        if let Some(min) = min_heap.pop() {\n\
    \            res.push(min);\n        }\n    }\n    res", "    let mut result =\
    \ Vec::new();\n    let mut lst = lst;\n    let mut min = lst.iter().min().unwrap();\n\
    \    let mut max = lst.iter().max().unwrap();\n    while lst.len() > 0 {\n   \
    \     result.push(*min);\n        lst.remove_item(min);\n        result.push(*max);\n\
    \        lst.remove_item(max);\n        min = lst.iter().min().unwrap();\n   \
    \     max = lst.iter().max().unwrap();\n    }\n    result", "    let mut result\
    \ = Vec::new();\n    let mut temp = lst.clone();\n    let mut sign = 1;\n    loop\
    \ {\n        if temp.len() == 0 {\n            break;\n        }\n        match\
    \ sign {\n            1 => {\n                let mut min = std::isize::MAX;\n\
    \                let mut min_idx = -1;\n                for (i, x) in temp.iter().enumerate()\
    \ {\n                    if x < &min {\n                        min = *x;\n  \
    \                      min_idx = i;\n                    }\n                }\n\
    \                result.push(min);\n                temp.remove(min_idx);\n  \
    \              sign = -1;\n            }\n            -1 => {\n              \
    \  let mut max = std::isize::MIN;\n                let mut max_idx = -1;\n   \
    \             for (i, x) in temp.iter().enumerate() {\n                    if\
    \ x > &max {\n                        max = *x;\n                        max_idx\
    \ = i;\n                    }\n                }\n                result.push(max);\n\
    \                temp.remove(max_idx);\n                sign = 1;\n          \
    \  }\n            _ => {}\n        }\n    }\n    result", "    if lst.len() ==\
    \ 0 {\n        return vec![];\n    }\n    let mut min_index = 0;\n    let mut\
    \ max_index = 0;\n    let mut result = vec![];\n    let mut list = lst.clone();\n\
    \    while list.len() > 0 {\n        let (min, max) = find_min_max_index(&list);\n\
    \        result.push(list[min]);\n        list.remove(min);\n        if list.len()\
    \ > 0 {\n            result.push(list[max]);\n            list.remove(max);\n\
    \        }\n    }\n    result", "    let mut lst = lst;\n    lst.sort();\n   \
    \ lst.reverse();\n    lst", "    if lst.len() <= 1 {\n        return lst;\n  \
    \  }\n    let mut lst = lst;\n    lst.sort();\n    let mut result = Vec::with_capacity(lst.len());\n\
    \    let mut left = 0;\n    let mut right = lst.len() - 1;\n    while left <=\
    \ right {\n        result.push(lst[left]);\n        left += 1;\n        if left\
    \ <= right {\n            result.push(lst[right]);\n            right -= 1;\n\
    \        }\n    }\n    result", "    let mut lst = lst;\n    lst.sort();\n   \
    \ let mut result = Vec::new();\n    while !lst.is_empty() {\n        let min =\
    \ lst.remove(0);\n        result.push(min);\n        if !lst.is_empty() {\n  \
    \          let max = lst.pop().unwrap();\n            result.push(max);\n    \
    \    }\n    }\n    result", "    let mut min_nums = lst.iter().min().cloned().unwrap_or(0);\n\
    \    let mut max_nums = lst.iter().max().cloned().unwrap_or(0);\n    let mut res\
    \ = Vec::new();\n    while min_nums != max_nums {\n        res.push(min_nums);\n\
    \        res.push(max_nums);\n        min_nums += 1;\n        max_nums -= 1;\n\
    \    }\n    res.push(min_nums);\n    res"]
stop_tokens:
- "\n}"
