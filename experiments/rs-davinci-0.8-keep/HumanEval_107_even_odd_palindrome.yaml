name: HumanEval_107_even_odd_palindrome
language: rs
prompt: "/// Given a positive integer n, return a tuple that has the number of even\
  \ and odd\n/// integer palindromes that fall within the range(1, n), inclusive.\n\
  /// Example 1:\n/// Input: 3\n/// Output: (1, 2)\n/// Explanation:\n/// Integer\
  \ palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n/// Example\
  \ 2:\n/// Input: 12\n/// Output: (4, 6)\n/// Explanation:\n/// Integer palindrome\
  \ are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\
  /// Note:\n/// 1. 1 <= n <= 10^3\n/// 2. returned tuple has the number of even and\
  \ odd integer palindromes respectively.\nfn even_odd_palindrome(n: isize) -> (isize,\
  \ isize) {\n"
tests: "}\n\nfn main() {\n    let candidate = even_odd_palindrome;\n    assert_eq!(candidate(123),\
  \ (8, 13));\n    assert_eq!(candidate(12), (4, 6));\n    assert_eq!(candidate(3),\
  \ (1, 2));\n    assert_eq!(candidate(63), (6, 8));\n    assert_eq!(candidate(25),\
  \ (5, 6));\n    assert_eq!(candidate(19), (4, 6));\n    assert_eq!(candidate(9),\
  \ (4, 5));\n    assert_eq!(candidate(1), (0, 1));\n}\n"
completions: ["    if n < 0 {\n        return (0, 0);\n    }\n\n    let mut odds =\
    \ 0;\n    let mut evens = 0;\n    let mut count = 0;\n    for i in 0..n {\n  \
    \      if count <= 0 {\n            odds += 1;\n            count += 1;\n    \
    \    } else {\n            evens += 1;\n            count -= 1;\n        }\n \
    \   }\n\n    (evens, odds)", "    if n < 10 {\n        return if n % 2 == 0 {\
    \ (1, n - 1) } else { (0, n) };\n    }\n    let mut even = 0;\n    let mut odd\
    \ = 0;\n    let (mut m, mut d) = (n, 1);\n    while m > 0 {\n        let x = m\
    \ % 10;\n        m /= 10;\n        let y = (n / d) % 10;\n        if x == y {\n\
    \            if x % 2 == 0 {\n                even += 1;\n            } else {\n\
    \                odd += 1;\n            }\n        }\n        d *= 10;\n    }\n\
    \    return (even, odd);", "    let mut odds = 0;\n    let mut evens = 0;\n  \
    \  for i in 1..=n {\n        if i % 10 == 0 {\n            continue;\n       \
    \ }\n        let (mut left, mut right) = (i, i);\n        let mut reverse = 0;\n\
    \        while left > 0 {\n            reverse = reverse * 10 + left % 10;\n \
    \           left /= 10;\n        }\n        while right > 0 {\n            reverse\
    \ = reverse * 10 + right % 10;\n            right /= 10;\n        }\n        if\
    \ reverse <= n {\n            if reverse & 1 == 0 {\n                evens +=\
    \ 1;\n            } else {\n                odds += 1;\n            }\n      \
    \  }\n    }\n    (evens, odds)", "    if n < 1 {\n        return (0, 0);\n   \
    \ }\n    let mut odd = 0;\n    let mut even = 0;\n    let mut i = 1;\n    while\
    \ i <= n {\n        let j = i;\n        let mut reverse = 0;\n        while j\
    \ > 0 {\n            reverse = reverse * 10 + j % 10;\n            j /= 10;\n\
    \        }\n        if reverse == i {\n            if i % 2 == 0 {\n         \
    \       even += 1;\n            } else {\n                odd += 1;\n        \
    \    }\n        }\n        i += 1;\n    }\n    (even, odd)", "    let mut ret\
    \ = (0, 0);\n    for i in 1..n + 1 {\n        if !is_palindrome(i.to_string())\
    \ {\n            continue;\n        }\n        if i % 2 == 0 {\n            ret.0\
    \ += 1;\n        } else {\n            ret.1 += 1;\n        }\n    }\n    ret",
  "    let mut e_cnt = 0;\n    let mut o_cnt = 0;\n    for i in 1..=n {\n        if\
    \ is_palindrome(i) {\n            if i % 2 == 0 {\n                e_cnt += 1;\n\
    \            } else {\n                o_cnt += 1;\n            }\n        }\n\
    \    }\n    (e_cnt, o_cnt)", "    let mut even = 0;\n    let mut odd = 0;\n  \
    \  for i in 1..=n {\n        if is_palindrome(i) {\n            if i % 2 == 0\
    \ {\n                even += 1;\n            } else {\n                odd +=\
    \ 1;\n            }\n        }\n    }\n    (even, odd)", "    if n <= 1 {\n  \
    \      return (0, 1);\n    }\n    let mut even = 0;\n    let mut odd = 0;\n  \
    \  for i in 1..=n {\n        if i.to_string() == i.to_string().chars().rev().collect::<String>()\
    \ {\n            if i.to_string().len() % 2 == 0 {\n                even += 1;\n\
    \            } else {\n                odd += 1;\n            }\n        }\n \
    \   }\n    (even, odd)", "    let mut even_count = 0;\n    let mut odd_count =\
    \ 0;\n    for i in 1..=n {\n        if is_palindrome(i) {\n            if i %\
    \ 2 == 0 {\n                even_count += 1;\n            } else {\n         \
    \       odd_count += 1;\n            }\n        }\n    }\n    (even_count, odd_count)",
  "    let mut even_num = 0;\n    let mut odd_num = 0;\n    for i in 1..=n {\n   \
    \     if is_palindrome(i) {\n            if i % 2 == 0 {\n                even_num\
    \ += 1;\n            } else {\n                odd_num += 1;\n            }\n\
    \        }\n    }\n    (even_num, odd_num)", "    if n < 1 {\n        return (0,\
    \ 0);\n    }\n    let mut even = 0;\n    let mut odd = 0;\n    for i in 1..=n\
    \ {\n        if is_palindrome(i) {\n            if i % 2 == 0 {\n            \
    \    even += 1;\n            } else {\n                odd += 1;\n           \
    \ }\n        }\n    }\n    (even, odd)", "    let (mut odd, mut even) = (0, 0);\n\
    \    for i in 1..n+1 {\n        if i % 2 == 0 {\n            even += 1;\n    \
    \    } else {\n            odd += 1;\n        }\n    }\n    (even, odd)", "  \
    \  let mut even_count = 0;\n    let mut odd_count = 0;\n    for i in 1..=n {\n\
    \        if is_palindrome(i) {\n            if i % 2 == 0 {\n                even_count\
    \ += 1;\n            } else {\n                odd_count += 1;\n            }\n\
    \        }\n    }\n    (even_count, odd_count)", "    (1..n + 1)\n        .map(|n|\
    \ n.to_string())\n        .filter(|n| n == n.chars().rev().collect::<String>())\n\
    \        .map(|n| (1, n.parse::<isize>().unwrap()))\n        .fold((0, 0), |acc,\
    \ val| {\n            if val.1 % 2 == 0 {\n                (acc.0 + 1, acc.1)\n\
    \            } else {\n                (acc.0, acc.1 + 1)\n            }\n   \
    \     })", "    let mut num_even = 0;\n    let mut num_odd = 0;\n    let mut base\
    \ = 1;\n    while base <= n {\n        num_even += (n / (base * 10)) * base;\n\
    \        num_odd += n / (base * 10) * base;\n        num_odd += std::cmp::min(std::cmp::max(n\
    \ % (base * 10) - base + 1, 0), base);\n        base *= 10;\n    }\n    (num_even,\
    \ num_odd)", "    let mut even_count = 0;\n    let mut odd_count = 0;\n    let\
    \ mut curr = 1;\n    while curr <= n {\n        if is_palindrome(curr) {\n   \
    \         if curr % 2 == 0 {\n                even_count += 1;\n            }\
    \ else {\n                odd_count += 1;\n            }\n        }\n        curr\
    \ += 1;\n    }\n    (even_count, odd_count)", "    let mut odd = 0;\n    let mut\
    \ even = 0;\n    let mut i = 1;\n    while i <= n {\n        if i % 10 == 0 {\n\
    \            // i is a multiple of 10, so it's not a palindrome\n            i\
    \ += 1;\n            continue;\n        }\n        if is_palindrome(i) {\n   \
    \         if i % 2 == 0 {\n                even += 1;\n            } else {\n\
    \                odd += 1;\n            }\n        }\n        i += 1;\n    }\n\
    \    (even, odd)", "    let mut even = 0;\n    let mut odd = 0;\n    for i in\
    \ 1..=n {\n        if is_palindrome(i) {\n            if i % 2 == 0 {\n      \
    \          even += 1;\n            } else {\n                odd += 1;\n     \
    \       }\n        }\n    }\n    (even, odd)", "    let mut even = 0;\n    let\
    \ mut odd = 0;\n    for i in 1..=n {\n        if is_palindrome(i) {\n        \
    \    if i % 2 == 0 {\n                even += 1;\n            } else {\n     \
    \           odd += 1;\n            }\n        }\n    }\n    (even, odd)", "  \
    \  let mut even_cnt = 0;\n    let mut odd_cnt = 0;\n    let mut val = 1;\n   \
    \ while val <= n {\n        if is_palindrome(val) {\n            if val % 2 ==\
    \ 0 {\n                even_cnt += 1;\n            } else {\n                odd_cnt\
    \ += 1;\n            }\n        }\n        val += 1;\n    }\n    (even_cnt, odd_cnt)"]
stop_tokens:
- "\n}"
