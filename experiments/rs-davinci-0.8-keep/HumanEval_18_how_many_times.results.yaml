language: rs
name: HumanEval_18_how_many_times
results:
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    unimplemented!()\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmplltt_etl.rs:9:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821613
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    string.matches(&substring).count()\
    \ as isize\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpl3p1nvxw.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821613
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut offset = 0;\n    let mut count = 0;\n    while let Some(pos) = string[offset..].find(&substring)\
    \ {\n        count += 1;\n        offset += pos + substring.len();\n    }\n  \
    \  count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpp58pjzf7.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821613
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    0\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmp5z559ucl.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821613
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut result = 0;\n    let mut stop = false;\n    let mut i = 0;\n    while !stop\
    \ {\n        match string.find(&substring) {\n            Some(index) => {\n \
    \               result += 1;\n                let chars_to_omit = index + substring.len();\n\
    \                string = string.chars().skip(chars_to_omit).collect();\n    \
    \        }\n            None => stop = true,\n        }\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "warning: unused variable: `i`\n  --> /tmp/tmpm2i3vrvc.rs:11:13\n   |\n\
    11 |     let mut i = 0;\n   |             ^ help: if this is intentional, prefix\
    \ it with an underscore: `_i`\n   |\n   = note: `#[warn(unused_variables)]` on\
    \ by default\n\nwarning: variable does not need to be mutable\n  --> /tmp/tmpm2i3vrvc.rs:11:9\n\
    \   |\n11 |     let mut i = 0;\n   |         ----^\n   |         |\n   |     \
    \    help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]` on by default\n\
    \nerror[E0384]: cannot assign to immutable argument `string`\n  --> /tmp/tmpm2i3vrvc.rs:17:17\n\
    \   |\n8  | fn how_many_times(string: String, substring: String) -> isize {\n\
    \   |                   ------ help: consider making this binding mutable: `mut\
    \ string`\n...\n17 |                 string = string.chars().skip(chars_to_omit).collect();\n\
    \   |                 ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error; 2 warnings emitted\n\nFor more information about this\
    \ error, try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659821613
- exit_code: -1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut count = 0;\n    let mut index = 0;\n    let mut old_index = 0;\n    let\
    \ string = string.as_str();\n    let substring = substring.as_str();\n    while\
    \ index < string.len() {\n        index = string.find(substring).unwrap_or(string.len());\n\
    \        count += 1;\n        if index < string.len() {\n            old_index\
    \ = index;\n            index += substring.len();\n        }\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659821618
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ text: Vec<char> = string.chars().collect();\n    let pattern: Vec<char> = substring.chars().collect();\n\
    \    let mut count = 0;\n    let mut i = 0;\n    while i < text.len() {\n    \
    \    let mut j = 0;\n        while j < pattern.len() && i < text.len() && text[i]\
    \ == pattern[j] {\n            i += 1;\n            j += 1;\n        }\n     \
    \   if j == pattern.len() {\n            count += 1;\n        }\n        i +=\
    \ 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp5u7gzffw.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821613
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    string.matches(&substring).count()\
    \ as isize\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpl3p1nvxw.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821613
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ string_len = string.len();\n    let substring_len = substring.len();\n    let\
    \ mut how_many = 0;\n    let mut index = 0;\n    while index < string_len {\n\
    \        if &string[index..index + substring_len] == substring {\n           \
    \ how_many += 1;\n            index += substring_len;\n        } else {\n    \
    \        index += 1;\n        }\n    }\n    how_many\n}\n\nfn main() {\n    let\
    \ candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''byte index 10 is out of bounds of `cacacacac`'',
    /tmp/tmp8wp14jse.rs:14:13

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821613
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut times = 0;\n    let mut idx = 0;\n    let string = string.into_bytes();\n\
    \    let substring = substring.into_bytes();\n    while idx < string.len() {\n\
    \        if string[idx] == substring[0] {\n            let mut i = 0;\n      \
    \      let mut j = idx;\n            while i < substring.len() && j < string.len()\
    \ && string[j] == substring[i] {\n                i += 1;\n                j +=\
    \ 1;\n            }\n            if i == substring.len() {\n                times\
    \ += 1;\n            }\n        }\n        idx += 1;\n    }\n    times\n}\n\n\
    fn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821613
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ max_index = string.len() - substring.len();\n    let mut count = 0;\n    for\
    \ i in 0..max_index + 1 {\n        if string[i..i + substring.len()] == substring\
    \ {\n            count += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmph_6l3nwp.rs:9:21

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821613
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut count = 0;\n    let mut start = 0;\n    let sub_len = substring.len();\n\
    \    for _ in 0..string.len() - sub_len + 1 {\n        if &string[start..start\
    \ + sub_len] == substring {\n            count += 1;\n        }\n        start\
    \ += 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpj2l_nmty.rs:12:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821613
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut counter = 0;\n    let mut position = 0;\n    let mut step = 1;\n    let\
    \ string_length = string.len();\n    let substring_length = substring.len();\n\
    \    loop {\n        if substring_length + position > string_length {\n      \
    \      break;\n        }\n        if substring == string[position..substring_length\
    \ + position].to_string() {\n            counter += 1;\n            position +=\
    \ step;\n        } else {\n            position += 1;\n        }\n    }\n    counter\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821613
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ base_len = string.len();\n    let sub_len = substring.len();\n    if base_len\
    \ == 0 || sub_len == 0 || base_len < sub_len {\n        return 0;\n    }\n   \
    \ let mut num_times = 0;\n    let mut temp_string = string.clone();\n    loop\
    \ {\n        let i = temp_string.find(&substring);\n        if i.is_none() {\n\
    \            break;\n        }\n        num_times += 1;\n        temp_string =\
    \ temp_string[i.unwrap() + sub_len..].to_string();\n    }\n    num_times\n}\n\n\
    fn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpz9qsspz4.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821613
- exit_code: -1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ (len_string, len_substring) = (string.len(), substring.len());\n    if len_substring\
    \ == 0 {\n        return 0;\n    }\n    if len_substring > len_string {\n    \
    \    return 0;\n    }\n    let mut count = 0;\n    let (mut i, mut j) = (0, 0);\n\
    \    while i < len_string {\n        if string.as_bytes()[i] == substring.as_bytes()[j]\
    \ {\n            if j == len_substring - 1 {\n                count += 1;\n  \
    \              i = i - j;\n                j = 0;\n            } else {\n    \
    \            i += 1;\n                j += 1;\n            }\n        } else {\n\
    \            i = i - j + 1;\n            j = 0;\n        }\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659821618
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    //\
    \ TODO\n    0\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpxim2gxnc.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821613
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut i = 0;\n    let mut j = 0;\n    let mut count = 0;\n    let mut buf = String::new();\n\
    \    while i < string.len() {\n        if string.chars().nth(i) == substring.chars().nth(j)\
    \ {\n            buf.push(string.chars().nth(i).unwrap());\n            if buf\
    \ == substring {\n                count += 1;\n                buf.clear();\n\
    \                j = 0;\n            } else {\n                j += 1;\n     \
    \       }\n        } else {\n            buf.clear();\n            j = 0;\n  \
    \      }\n        i += 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpfa95r9cw.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821613
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut it = 0;\n    let mut count = 0;\n    let len = substring.len();\n    while\
    \ it < string.len() {\n        if &string[it..it + len] == substring {\n     \
    \       count += 1;\n            it += len;\n        } else {\n            it\
    \ += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''byte index 10 is out of bounds of `cacacacac`'',
    /tmp/tmp4vmezuce.rs:13:13

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821613
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    if\
    \ string.len() == 0 || substring.len() == 0 {\n        return 0;\n    }\n    let\
    \ mut index = 0;\n    let mut count = 0;\n    while index != -1 {\n        index\
    \ = string.find(substring.as_str()).unwrap_or(-1);\n        if index != -1 {\n\
    \            string = string.replace_range(index..index + substring.len(), \"\"\
    );\n            count += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n \
    \   let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"\
    ), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0600]: cannot apply unary operator `-` to type `usize`\n  --> /tmp/tmpcu9ehdt0.rs:15:59\n\
    \   |\n15 |         index = string.find(substring.as_str()).unwrap_or(-1);\n \
    \  |                                                           ^^\n   |      \
    \                                                     |\n   |                \
    \                                           cannot apply unary operator `-`\n\
    \   |                                                           help: you may\
    \ have meant the maximum value of `usize`: `usize::MAX`\n   |\n   = note: unsigned\
    \ values cannot be negated\n\nerror[E0277]: the trait bound `usize: Neg` is not\
    \ satisfied\n  --> /tmp/tmpcu9ehdt0.rs:14:20\n   |\n14 |     while index != -1\
    \ {\n   |                    ^^ the trait `Neg` is not implemented for `usize`\n\
    \nerror[E0600]: cannot apply unary operator `-` to type `usize`\n  --> /tmp/tmpcu9ehdt0.rs:16:21\n\
    \   |\n16 |         if index != -1 {\n   |                     ^^\n   |      \
    \               |\n   |                     cannot apply unary operator `-`\n\
    \   |                     help: you may have meant the maximum value of `usize`:\
    \ `usize::MAX`\n   |\n   = note: unsigned values cannot be negated\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpcu9ehdt0.rs:17:22\n   |\n17 |             string\
    \ = string.replace_range(index..index + substring.len(), \"\");\n   |        \
    \              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `String`, found `()`\n   |\nnote: method `replace_range` modifies its\
    \ receiver in-place\n  --> /tmp/tmpcu9ehdt0.rs:17:29\n   |\n17 |             string\
    \ = string.replace_range(index..index + substring.len(), \"\");\n   |        \
    \              ------ ^^^^^^^^^^^^^ this call modifies `string` in-place\n   |\
    \                      |\n   |                      you probably want to use this\
    \ value after calling the method...\n   = note: ...instead of the `()` output\
    \ of method `replace_range`\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308, E0600.\nFor more information\
    \ about an error, try `rustc --explai"
  stdout: ''
  timestamp: 1659821613
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ s = string.as_str();\n    let ss = substring.as_str();\n    let mut count =\
    \ 0;\n    let mut offset = 0;\n    let mut len = s.len();\n    while offset <\
    \ len {\n        if len - offset < ss.len() {\n            break;\n        }\n\
    \        if s[offset..].starts_with(ss) {\n            count += 1;\n         \
    \   offset += ss.len();\n        } else {\n            offset += 1;\n        }\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpqlqzbei5.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821613
