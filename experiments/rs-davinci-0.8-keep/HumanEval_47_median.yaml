name: HumanEval_47_median
language: rs
prompt: "/// Return median of elements in the list l.\n/// >>> median([3, 1, 2, 4,\
  \ 5])\n/// 3\n/// >>> median([-10, 4, 6, 1000, 10, 20])\n/// 15.0\nfn median(l:\
  \ Vec<isize>) -> f64 {\n"
tests: "}\n\nfn main() {\n    let candidate = median;\n    assert_eq!(candidate(vec![3,\
  \ 1, 2, 4, 5]), 3.0);\n    assert_eq!(candidate(vec![-10, 4, 6, 1000, 10, 20]),\
  \ 8.0);\n    assert_eq!(candidate(vec![5]), 5.0);\n    assert_eq!(candidate(vec![6,\
  \ 5]), 5.5);\n    assert_eq!(candidate(vec![8, 1, 3, 9, 9, 2, 7]), 7.0);\n}\n"
completions: ["    // TODO, implement me\n    0.0", "    let mut temp = l.clone();\n\
    \    temp.sort();\n    if temp.len() % 2 == 0 {\n        (temp[temp.len() / 2]\
    \ + temp[temp.len() / 2 - 1]) as f64 / 2.0\n    } else {\n        temp[temp.len()\
    \ / 2] as f64\n    }", "    // YOUR CODE HERE\n    let mut sorted_l = l.clone();\n\
    \    sorted_l.sort();\n    if sorted_l.len() % 2 == 0 {\n        return ((sorted_l[sorted_l.len()\
    \ / 2 - 1] + sorted_l[sorted_l.len() / 2]) as f64) / 2.0;\n    } else {\n    \
    \    return sorted_l[sorted_l.len() / 2] as f64;\n    }", "    let mut l = l;\n\
    \    l.sort();\n    let mut j = l.len() / 2;\n    if l.len() % 2 == 0 {\n    \
    \    return (l[j] + l[j - 1]) as f64 / 2.0;\n    }\n    l[j] as f64", "    let\
    \ mut l_copy = l.clone();\n    l_copy.sort();\n    if l_copy.len() % 2 == 0 {\n\
    \        let first = l_copy[l_copy.len() / 2];\n        let second = l_copy[l_copy.len()\
    \ / 2 - 1];\n        (first + second) as f64 / 2.0\n    } else {\n        l_copy[l_copy.len()\
    \ / 2] as f64\n    }", "    let m = l.len() as f64 / 2.0;\n    let i = m.floor()\
    \ as usize;\n    let l = l.iter().sorted().collect::<Vec<&isize>>();\n    if m\
    \ - i as f64 == 0.0 {\n        (*l[i]) as f64\n    } else {\n        (*l[i] +\
    \ *l[i + 1]) as f64 / 2.0\n    }", '    unimplemented!()', "    let len = l.len();\n\
    \    if len == 0 {\n        return 0 as f64;\n    }\n\n    let (mut sorted, mut\
    \ odds) = (l.clone(), len % 2 == 1);\n    sorted.sort();\n\n    let mid = len\
    \ / 2;\n    if odds {\n        return sorted[mid] as f64;\n    } else {\n    \
    \    return (sorted[mid - 1] + sorted[mid]) as f64 / 2 as f64;\n    }", "    if\
    \ l.len() == 0 {\n        panic!(\"Empty list\")\n    }\n\n    let mut l = l;\n\
    \    l.sort();\n    let i = l.len() / 2;\n    let middle = l[i];\n    if l.len()\
    \ % 2 == 0 {\n        return ((middle + l[i - 1]) as f64) / 2.0;\n    }\n    return\
    \ middle as f64;", "    let len = l.len();\n    let l1 = l.clone();\n    let l2\
    \ = l.clone();\n    let l3 = l.clone();\n    let l4 = l.clone();\n    let l5 =\
    \ l.clone();\n    let l6 = l.clone();\n    let l7 = l.clone();\n    let l8 = l.clone();\n\
    \    let l9 = l.clone();\n    let l10 = l.clone();\n    let l11 = l.clone();\n\
    \    let l12 = l.clone();\n    let l13 = l.clone();\n    let l14 = l.clone();\n\
    \    let l15 = l.clone();\n    let l16 = l.clone();\n    let l17 = l.clone();\n\
    \    let l18 = l.clone();\n    let l19 = l.clone();\n    let l20 = l.clone();\n\
    \    let l21 = l.clone();\n    let l22 = l.clone();\n    let l23 = l.clone();\n\
    \    let l24 = l.clone();\n    let l25 = l.clone();\n    let l26 = l.clone();\n\
    \    let l27 = l.clone();\n    let l28 = l.clone();\n    let l29 = l.clone();\n\
    \    let l30 = l.clone();\n    let l31 = l.clone();\n    let l32 = l.clone();\n\
    \    let l33 = l.clone();\n    let l34 = l.clone();\n    let l35 = l.clone();\n\
    \    let l36 = l.clone();\n    let l37 = l.clone();\n    let l38 = l.clone();\n\
    \    let l39 = l.clone();\n    let l40 = l.clone();\n    let l41 = l.clone();\n\
    \    let l42 = l.clone();\n    let l43 = l.clone();\n    let l44 = l.clone();\n\
    \    let l45 = l.clone();\n    let l46 = l.clone();\n    let l47 = l.clone();\n\
    \    let l48 = l.clone();\n    let l49 = l.clone();\n    let l50 = l.clone();\n\
    \    let", "    match l.len() {\n        0 => panic!(\"error\"),\n        1 =>\
    \ l[0] as f64,\n        2 => (l[0] + l[1]) as f64 / 2.0,\n        _ => {\n   \
    \         let mut l = l.clone();\n            l.sort();\n            if l.len()\
    \ % 2 == 0 {\n                (l[l.len() / 2 - 1] + l[l.len() / 2]) as f64 / 2.0\n\
    \            } else {\n                l[l.len() / 2] as f64\n            }\n\
    \        }\n    }", '    unimplemented!();', "    // TODO\n    0.0", "    // Create\
    \ a copy of the list\n    let mut tmp_l = l.clone();\n    // Get the length of\
    \ the list\n    let len = tmp_l.len();\n    // Sort the copy of the list\n   \
    \ tmp_l.sort();\n    // Get the middle index\n    let mid = len / 2;\n    // Return\
    \ the median\n    if len % 2 == 0 {\n        ((tmp_l[mid - 1] as f64) + (tmp_l[mid]\
    \ as f64)) / 2.0\n    } else {\n        tmp_l[mid] as f64\n    }", "    let l_len\
    \ = l.len();\n    let mut l_sorted = l.clone();\n    l_sorted.sort();\n    match\
    \ l_len % 2 {\n        0 => (l_sorted[l_len / 2 - 1] + l_sorted[l_len / 2]) as\
    \ f64 / 2.0,\n        _ => l_sorted[l_len / 2] as f64,\n    }", "    let mut sorted_l\
    \ = l.clone();\n    sorted_l.sort();\n    if sorted_l.len() % 2 == 0 {\n     \
    \   let l = sorted_l.len() as f64;\n        (sorted_l[(l / 2.0 - 1.0) as usize]\
    \ + sorted_l[(l / 2.0) as usize]) as f64 / 2.0\n    } else {\n        sorted_l[(sorted_l.len()\
    \ / 2) as usize] as f64\n    }", "    let n = l.len();\n    if n % 2 == 0 {\n\
    \        let mid_left = (n / 2) - 1;\n        let mid_right = (n / 2);\n     \
    \   (l[mid_left] + l[mid_right]) as f64 / 2.0\n    } else {\n        let mid =\
    \ (n / 2) as f64;\n        mid\n    }", "    let mut l2 = l.clone();\n    l2.sort();\n\
    \    let len = l2.len();\n    let mut mean = 0.0;\n    if len % 2 == 0 {\n   \
    \     mean = ((l2[len / 2] + l2[len / 2 - 1]) as f64) / 2.0;\n    } else {\n \
    \       mean = l2[len / 2] as f64;\n    }\n    mean", "    let mid = l.len() /\
    \ 2;\n    let mut l = l;\n    l.sort();\n    if l.len() % 2 == 0 {\n        (l[mid]\
    \ + l[mid - 1]) as f64 / 2.0\n    } else {\n        l[mid] as f64\n    }", " \
    \   if l.len() % 2 == 0 {\n        let even = (l.len() / 2) as usize;\n      \
    \  (l[even - 1] + l[even]) as f64 / 2.0\n    } else {\n        let odd = (l.len()\
    \ / 2) as usize;\n        l[odd] as f64\n    }"]
stop_tokens:
- "\n}"
