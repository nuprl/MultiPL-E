name: HumanEval_132_is_nested
language: rs
results:
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    for\
    \ c in string.chars() {\n        match c {\n            '[' => stack.push(c),\n\
    \            ']' => if stack.len() == 0 { return false } else { stack.pop(); },\n\
    \            _ => return false,\n        }\n    }\n    stack.len() == 0\n}\n\n\
    fn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp5rgh__q0.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut count = 0;\n    for i in string.chars()\
    \ {\n        if i == '[' {\n            count += 1;\n        } else {\n      \
    \      count -= 1;\n        }\n        if count < 0 {\n            return false;\n\
    \        }\n    }\n    count == 0\n}\n\nfn main() {\n    let candidate = is_nested;\n\
    \    assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpmcp2rzl6.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut result = true;\n    let mut\
    \ count = 0;\n    for s in string.chars() {\n        if s == '[' {\n         \
    \   count += 1;\n        } else {\n            count -= 1;\n        }\n      \
    \  if count < 0 {\n            result = false;\n            break;\n        }\n\
    \    }\n    if count != 0 {\n        result = false;\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpfw1njpct.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    if string.len() == 0 {\n        return\
    \ false;\n    }\n    let mut brackets: Vec<char> = string.chars().collect();\n\
    \    let mut counter = 0;\n    let mut result = false;\n    let mut last_index\
    \ = 0;\n    for index in 0..brackets.len() {\n        if brackets[index] == '['\
    \ {\n            counter += 1;\n        } else {\n            counter -= 1;\n\
    \        }\n        if counter == 0 {\n            last_index = index;\n     \
    \       result = true;\n        }\n    }\n    if counter != 0 {\n        return\
    \ false;\n    }\n    let mut brackets: Vec<char> = string[..last_index + 1].chars().collect();\n\
    \    let mut counter = 0;\n    for bracket in brackets {\n        if bracket ==\
    \ '[' {\n            counter += 1;\n        } else {\n            counter -= 1;\n\
    \        }\n        if counter < 0 {\n            return false;\n        }\n \
    \   }\n    result\n}\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpjq7yz3be.rs:51:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = vec![];\n    for c\
    \ in string.chars() {\n        if c == '[' {\n            stack.push(c);\n   \
    \     } else if c == ']' {\n            if stack.is_empty() {\n              \
    \  return false;\n            }\n            stack.pop();\n        }\n    }\n\
    \    false\n}\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpgnwbpdyk.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut v: Vec<u8> = Vec::new();\n\
    \    for c in string.chars() {\n        if c == '[' {\n            v.push(1);\n\
    \        } else {\n            if v.len() > 0 {\n                v.pop();\n  \
    \          } else {\n                return false;\n            }\n        }\n\
    \    }\n    v.len() > 0\n}\n\nfn main() {\n    let candidate = is_nested;\n  \
    \  assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpshkfc3ac.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut lvl = 0;\n    for c in string.chars()\
    \ {\n        if c == '[' {\n            lvl += 1;\n        } else {\n        \
    \    lvl -= 1;\n        }\n        if lvl < 0 {\n            return false;\n \
    \       }\n    }\n    lvl == 0\n}\n\nfn main() {\n    let candidate = is_nested;\n\
    \    assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpo6r1fqj6.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    string.chars().fold(Vec::new(), |mut\
    \ acc, c| {\n        if let Some(last) = acc.last() {\n            if last ==\
    \ &'[' && c == ']' {\n                acc.pop();\n                return acc;\n\
    \            }\n        }\n        acc.push(c);\n        acc\n    }).is_empty()\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpij_t1h2o.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut level = 0;\n    for ch in\
    \ string.chars() {\n        match ch {\n            '[' => level += 1,\n     \
    \       ']' => {\n                if level <= 0 {\n                    return\
    \ false;\n                }\n                level -= 1;\n            }\n    \
    \        _ => {}\n        }\n    }\n    level > 0\n}\n\nfn main() {\n    let candidate\
    \ = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][]\")), false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []]\")), false);\n    assert_eq!(candidate(String::from(\"[[]][[\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n\
    \    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp0lo5oi7l.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut left_count = 0;\n    let mut\
    \ right_count = 0;\n    for c in string.chars() {\n        if c == '[' {\n   \
    \         left_count += 1;\n        } else {\n            right_count += 1;\n\
    \        }\n        if right_count > left_count {\n            return false;\n\
    \        }\n    }\n    left_count > right_count\n}\n\nfn main() {\n    let candidate\
    \ = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][]\")), false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []]\")), false);\n    assert_eq!(candidate(String::from(\"[[]][[\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n\
    \    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpwqy_roj3.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut i = 0;\n    for c in string.chars()\
    \ {\n        if c == '[' {\n            i += 1;\n        } else {\n          \
    \  i -= 1;\n        }\n        if i < 0 {\n            return false;\n       \
    \ }\n    }\n    if i == 0 {\n        return true;\n    }\n    false\n}\n\nfn main()\
    \ {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpq8ms8uha.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut depth = 0;\n    let mut max_depth\
    \ = 0;\n    for c in string.chars() {\n        match c {\n            '[' => depth\
    \ += 1,\n            ']' => depth -= 1,\n            _ => panic!(\"should only\
    \ be square brackets\"),\n        }\n        if depth < 0 {\n            return\
    \ false;\n        }\n        if depth > max_depth {\n            max_depth = depth;\n\
    \        }\n    }\n    max_depth >= 2\n}\n\nfn main() {\n    let candidate = is_nested;\n\
    \    assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpb1kzd4cl.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut v: Vec<char> = Vec::new();\n\
    \    for c in string.chars() {\n        match c {\n            '[' => v.push(c),\n\
    \            ']' => {\n                if v.len() > 0 {\n                    let\
    \ d = v.pop().unwrap();\n                    if d != '[' {\n                 \
    \       return false;\n                    }\n                } else {\n     \
    \               return false;\n                }\n            }\n            _\
    \ => {}\n        }\n    }\n    v.len() == 0\n}\n\nfn main() {\n    let candidate\
    \ = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][]\")), false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []]\")), false);\n    assert_eq!(candidate(String::from(\"[[]][[\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n\
    \    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4ngt2xwh.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    let\
    \ mut iter = string.chars();\n    while let Some(c) = iter.next() {\n        if\
    \ let Some(last) = stack.last() {\n            if *last == c {\n             \
    \   stack.pop();\n            } else {\n                stack.push(c);\n     \
    \       }\n        } else {\n            stack.push(c);\n        }\n    }\n  \
    \  stack.is_empty()\n}\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmplzjvsvld.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    unimplemented!()\n}\n\nfn main() {\n\
    \    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\"\
    )), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpmh6dvbj2.rs:11:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut counter = 0;\n    for bracket\
    \ in string.chars() {\n        if bracket == '[' {\n            counter += 1;\n\
    \        } else {\n            counter -= 1;\n        }\n        if counter <\
    \ 0 {\n            return false;\n        }\n    }\n    counter == 0\n}\n\nfn\
    \ main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp3n5k8pav.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = vec![];\n    let mut\
    \ has_left = false;\n    for c in string.chars() {\n        match c {\n      \
    \      '[' => {\n                has_left = true;\n                stack.push(c);\n\
    \            }\n            ']' => {\n                if stack.is_empty() {\n\
    \                    return false;\n                }\n                stack.pop();\n\
    \            }\n            _ => return false,\n        }\n    }\n    stack.is_empty()\
    \ && has_left\n}\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpr4uofijk.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut open_brackets = 0;\n    let\
    \ mut close_brackets = 0;\n    for b in string.chars() {\n        if b == '['\
    \ {\n            open_brackets += 1;\n        } else {\n            close_brackets\
    \ += 1;\n        }\n        if close_brackets > open_brackets {\n            return\
    \ false;\n        }\n    }\n    return open_brackets == close_brackets && open_brackets\
    \ > 0;\n}\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp8vjwsewx.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    let mut count = 0;\n    for s in string.chars()\
    \ {\n        if s == '[' {\n            count += 1;\n        } else {\n      \
    \      count -= 1;\n        }\n        if count < 0 {\n            return false;\n\
    \        }\n    }\n    count > 0\n}\n\nfn main() {\n    let candidate = is_nested;\n\
    \    assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpr86eu9at.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    fn is_nested(string: String) -> bool {\n    // We use a stack to track an \"open\"\
    \ position of the brackets\n    let mut stack: Vec<u8> = Vec::new();\n    for\
    \ ch in string.as_bytes() {\n        match ch {\n            b'[' => stack.push(ch),\n\
    \            b']' => {\n                if stack.is_empty() {\n              \
    \      return false;\n                }\n                let last = stack.pop().unwrap();\n\
    \                if last != b'[' {\n                    return false;\n      \
    \          }\n            }\n            _ => {}\n        }\n    }\n    stack.is_empty()\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4o3s_zye.rs:15:32\n   |\n\
    15 |             b'[' => stack.push(ch),\n   |                               \
    \ ^^ expected `u8`, found `&u8`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n15 |             b'[' => stack.push(*ch),\n   |                       \
    \         +\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
