name: HumanEval_112_reverse_delete
language: rs
prompt: "/// Task\n/// We are given two strings s and c, you have to deleted all the\
  \ characters in s that are equal to any character in c\n/// then check if the result\
  \ string is palindrome.\n/// A string is called palindrome if it reads the same\
  \ backward as forward.\n/// You should return a tuple containing the result string\
  \ and True/False for the check.\n/// Example\n/// For s = \"abcde\", c = \"ae\"\
  , the result should be ('bcd',False)\n/// For s = \"abcdef\", c = \"b\"  the result\
  \ should be ('acdef',False)\n/// For s = \"abcdedcba\", c = \"ab\", the result should\
  \ be ('cdedc',True)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n"
tests: "}\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
  abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
  abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
  abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
  dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
  a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
  abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"\
  abcdedcba\"), String::from(\"v\")), (String::from(\"abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"\
  vabba\"), String::from(\"v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
  mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
completions: ["    let s_chars: Vec<char> = s.chars().collect();\n    let c_chars:\
    \ Vec<char> = c.chars().collect();\n    let mut result: Vec<char> = Vec::new();\n\
    \    for s_char in s_chars {\n        if !c_chars.contains(&s_char) {\n      \
    \      result.push(s_char);\n        }\n    }\n    let result_string: String =\
    \ result.into_iter().collect();\n    let result_runes: Vec<char> = result_string.chars().collect();\n\
    \    let mut result_runes_reverse: Vec<char> = Vec::new();\n    let len: usize\
    \ = result_runes.len();\n    for i in 0..len {\n        result_runes_reverse.push(result_runes[len\
    \ - i - 1]);\n    }\n    let result_string_reverse: String = result_runes_reverse.into_iter().collect();\n\
    \    (result_string, result_string == result_string_reverse)", "    let mut new_s\
    \ = String::new();\n    for i in s.chars() {\n        if !c.contains(i) {\n  \
    \          new_s.push(i);\n        }\n    }\n    let s_rev: String = new_s.chars().rev().collect();\n\
    \    (new_s, new_s == s_rev)", "    let mut result = String::new();\n    for i\
    \ in s.chars() {\n        if !c.contains(i) {\n            result.push(i);\n \
    \       }\n    }\n    if result == result.chars().rev().collect::<String>() {\n\
    \        (result, true)\n    } else {\n        (result, false)\n    }", "    let\
    \ mut res: String = s.chars().filter(|&x| !c.contains(x)).collect();\n    let\
    \ t = res.clone();\n    res.reverse();\n    (t, res == t)", '    unimplemented!()',
  "    let chars: HashSet<char> = c.chars().collect();\n    let mut s: String = s.chars().filter(|x|\
    \ !chars.contains(x)).collect();\n    let mut res = s.clone();\n    res.reverse();\n\
    \    (s, res == s)", "    let mut output = String::new();\n    let s: Vec<char>\
    \ = s.chars().collect();\n    let c: Vec<char> = c.chars().collect();\n    for\
    \ i in s {\n        if !c.contains(&i) {\n            output.push(i);\n      \
    \  }\n    }\n    let check = output.chars().eq(output.chars().rev());\n    (output,\
    \ check)", "    let mut ss = s.chars().filter(|c| !c.is_whitespace()).collect::<Vec<char>>();\n\
    \    let cs = c.chars().filter(|c| !c.is_whitespace()).collect::<Vec<char>>();\n\
    \    ss.retain(|x| !cs.contains(x));\n    (ss.iter().collect::<String>(), ss.iter().rev().eq(ss.iter()))",
  "    let mut string: String = String::new();\n    let mut chars = s.chars();\n \
    \   let mut chars_clone = chars.clone();\n    let mut current = chars.next();\n\
    \    let mut current_rev = chars_clone.next_back();\n    while current.is_some()\
    \ && current_rev.is_some() {\n        if c.contains(current.unwrap()) {\n    \
    \        current = chars.next();\n        } else if c.contains(current_rev.unwrap())\
    \ {\n            current_rev = chars_clone.next_back();\n        } else if current.unwrap()\
    \ == current_rev.unwrap() {\n            string.push(current.unwrap());\n    \
    \        current = chars.next();\n            current_rev = chars_clone.next_back();\n\
    \        } else {\n            return (string, false);\n        }\n    }\n   \
    \ (string, true)", "    let mut result = String::new();\n    let mut is_palindrome\
    \ = true;\n    for c_s in s.chars() {\n        if !c.contains(c_s) {\n       \
    \     result.push(c_s);\n        }\n    }\n    let reverse_result = result.chars().rev().collect::<String>();\n\
    \    if reverse_result != result {\n        is_palindrome = false;\n    }\n  \
    \  (result, is_palindrome)", "    let s: Vec<char> = s.chars().collect();\n  \
    \  let c: Vec<char> = c.chars().collect();\n    let filtered_s: Vec<char> = s.iter().filter(|&x|\
    \ !c.contains(x)).collect();\n    let filtered_s: String = filtered_s.iter().collect();\n\
    \    let is_pali = filtered_s == filtered_s.chars().rev().collect::<String>();\n\
    \    (filtered_s, is_pali)", "    let mut removed = s.chars().filter(|x| !c.contains(x)).collect::<String>();\n\
    \    let result = (removed.clone(), removed == removed.chars().rev().collect::<String>());\n\
    \    result", '    (s.chars().filter(|x| !c.contains(x)).collect::<String>(),
    false)', "    (\n        s.chars()\n            .filter(|x| !c.contains(x))\n\
    \            .collect::<String>(),\n        s.chars()\n            .filter(|x|\
    \ !c.contains(x))\n            .collect::<String>()\n            .chars()\n  \
    \          .eq(\n                s.chars()\n                    .filter(|x| !c.contains(x))\n\
    \                    .rev()\n                    .collect::<String>()\n      \
    \              .chars(),\n            ),\n    )", "    let mut s = s;\n    for\
    \ char in c.chars() {\n        s = s.replace(char, \"\");\n    }\n    return (s,\
    \ s == s.chars().rev().collect::<String>());", "    let mut a: Vec<char> = vec![];\n\
    \    for i in s.chars() {\n        if !c.contains(i) {\n            a.push(i);\n\
    \        }\n    }\n    let a = a.iter().collect::<String>();\n    let b = a.chars().rev().collect::<String>();\n\
    \    (a, a == b)", "    let mut is_palindrome = true;\n    let mut result = String::new();\n\
    \    let mut index = 0;\n    for char in s.chars() {\n        if !c.contains(char)\
    \ {\n            result.push(char);\n            if char != s.chars().nth(s.len()\
    \ - index - 1).unwrap() {\n                is_palindrome = false;\n          \
    \  }\n            index += 1;\n        }\n    }\n    (result, is_palindrome)",
  '    unimplemented!()', "    let new_string = s.chars().filter(|x| !c.contains(x)).collect::<String>();\n\
    \    (new_string, new_string == new_string.chars().rev().collect::<String>())",
  '    unimplemented!()']
stop_tokens:
- "\n}"
