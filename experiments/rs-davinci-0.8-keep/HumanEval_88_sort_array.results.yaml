language: rs
name: HumanEval_88_sort_array
results:
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut output = array.clone();\n\
    \    output.sort();\n    let sum = output[0] + output[output.len() - 1];\n   \
    \ if sum % 2 == 0 {\n        output.reverse();\n    }\n    output\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpi4k_qfz9.rs:14:15

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659822939
- exit_code: 0
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut res = array.clone();\n\
    \    if res.len() < 2 {\n        return res;\n    }\n    if (res[0] + res[res.len()\
    \ - 1]) % 2 == 0 {\n        res.sort_by(|a, b| b.cmp(a));\n    } else {\n    \
    \    res.sort_by(|a, b| a.cmp(b));\n    }\n    res\n}\n\nfn main() {\n    let\
    \ candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822939
- exit_code: 0
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n\
    \        return vec![];\n    }\n\n    let sum = array[0] + array[array.len() -\
    \ 1];\n    let mut sorted_array = array.clone();\n    sorted_array.sort();\n\n\
    \    if sum % 2 == 0 {\n        sorted_array.reverse();\n    }\n\n    sorted_array\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822939
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let sum = array[0] + array[array.len() - 1];\n    if sum % 2 == 0 {\n   \
    \     array.sort_by(|a, b| b.cmp(a));\n    } else {\n        array.sort_by(|a,\
    \ b| a.cmp(b));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmph0n5sf4h.rs:13:15

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659822939
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let sum: isize = array.first().unwrap()\
    \ + array.last().unwrap();\n    let mut result = array.clone();\n    result.sort();\n\
    \    if sum % 2 == 0 {\n        result.reverse();\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''called `Option::unwrap()` on a `None` value'',
    /tmp/tmpk1s5bvi8.rs:12:36

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659822939
- exit_code: 0
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    // TODO\n    let mut array\
    \ = array;\n    if array.len() > 0 {\n        let mut sorted_array = array.clone();\n\
    \        sorted_array.sort();\n        if (array[0] + array[array.len() - 1])\
    \ % 2 == 0 {\n            sorted_array.reverse();\n        }\n        array =\
    \ sorted_array;\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822939
- exit_code: 0
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    match array.len() {\n        0 => array,\n        1 => array,\n        len\
    \ => {\n            match array[0] + array[len - 1] {\n                i if i\
    \ % 2 == 0 => {\n                    array.sort_by(|a, b| b.cmp(a));\n       \
    \             array\n                }\n                _ => {\n             \
    \       array.sort_by(|a, b| a.cmp(b));\n                    array\n         \
    \       }\n            }\n        }\n    }\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822939
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n\
    \        return vec![];\n    }\n    let a = array[0];\n    let b = array[array.len()\
    \ - 1];\n    let mut array = array;\n    array.sort_by(|x, y| if a + b % 2 ==\
    \ 0 { y.cmp(x) } else { x.cmp(y) });\n    array\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpmjt922jb.rs:27:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822939
- exit_code: 0
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut new_array = array.clone();\n\
    \    if array.len() == 0 {\n        return vec![];\n    }\n    if (array[0] +\
    \ array[array.len() - 1]) % 2 == 0 {\n        new_array.sort_by(|a, b| b.cmp(a));\n\
    \    } else {\n        new_array.sort_by(|a, b| a.cmp(b));\n    }\n    new_array\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822939
- exit_code: 0
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut copy = array.clone();\n\
    \    copy.sort();\n    if array.len() > 0 && (array[0] + array[array.len() - 1])\
    \ % 2 == 0 {\n        copy.reverse();\n    }\n    copy\n}\n\nfn main() {\n   \
    \ let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822939
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut res = array.clone();\n\
    \    if array.len() > 1 {\n        res.sort_by(|a, b| if (a + b) % 2 == 0 { b.cmp(a)\
    \ } else { a.cmp(b) });\n    }\n    res\n}\n\nfn main() {\n    let candidate =\
    \ sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[4, 2, 0, 5, 3, 1]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmpjw2503vv.rs:23:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822939
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n\
    \        return vec![];\n    }\n    let &first = array.first().unwrap();\n   \
    \ let &last = array.last().unwrap();\n    let copy = array.clone();\n    if (first\
    \ + last) % 2 == 0 {\n        copy.sort_by(|x, y| y.cmp(x));\n    } else {\n \
    \       copy.sort_by(|x, y| x.cmp(y));\n    }\n    copy\n}\n\nfn main() {\n  \
    \  let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `copy` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmpiq3a19uk.rs:19:9\n   |\n17 |     let copy = array.clone();\n\
    \   |         ---- help: consider changing this to be mutable: `mut copy`\n18\
    \ |     if (first + last) % 2 == 0 {\n19 |         copy.sort_by(|x, y| y.cmp(x));\n\
    \   |         ^^^^ cannot borrow as mutable\n\nerror[E0596]: cannot borrow `copy`\
    \ as mutable, as it is not declared as mutable\n  --> /tmp/tmpiq3a19uk.rs:21:9\n\
    \   |\n17 |     let copy = array.clone();\n   |         ---- help: consider changing\
    \ this to be mutable: `mut copy`\n...\n21 |         copy.sort_by(|x, y| x.cmp(y));\n\
    \   |         ^^^^ cannot borrow as mutable\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1659822938
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut sorted_vec = array.clone();\n\
    \    let mut index = 0;\n    let vec_len = sorted_vec.len();\n    let iter_count\
    \ = vec_len / 2;\n    while index < iter_count {\n        let first_index = index;\n\
    \        let last_index = vec_len - index - 1;\n        if vec_len % 2 == 0 ||\
    \ index + 1 != iter_count {\n            sorted_vec.swap(first_index, last_index);\n\
    \        }\n        index += 1;\n    }\n    sorted_vec\n}\n\nfn main() {\n   \
    \ let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 1, 0, 3, 4, 2]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmpn17zcpl_.rs:31:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822939
- exit_code: 0
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let len = array.len();\n\
    \    if len == 0 {\n        return vec![];\n    }\n    if len == 1 {\n       \
    \ return array;\n    }\n    let sum = array[0] + array[len - 1];\n    let mut\
    \ res = array.clone();\n    if sum % 2 == 0 {\n        res.sort_by(|a, b| b.cmp(a));\n\
    \    } else {\n        res.sort_by(|a, b| a.cmp(b));\n    }\n    res\n}\n\nfn\
    \ main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822939
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let mut first = array.first().unwrap();\n    let mut last = array.last().unwrap();\n\
    \    if (*first + *last) % 2 == 0 {\n        array.sort_by(|a, b| b.cmp(a));\n\
    \    } else {\n        array.sort_by(|a, b| a.cmp(b));\n    }\n    array\n}\n\n\
    fn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''called `Option::unwrap()` on a `None` value'',
    /tmp/tmpd674bsji.rs:13:35

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659822939
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let len = array.len();\n\
    \    let mut new_array = array.clone();\n    let sum = array[0] + array[len -\
    \ 1];\n    if sum % 2 == 0 {\n        new_array.sort_by(|a, b| b.cmp(a));\n  \
    \  } else {\n        new_array.sort_by(|a, b| a.cmp(b));\n    }\n    new_array\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpks834wvb.rs:14:15

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659822939
- exit_code: 0
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let length = array.len();\n    if length == 0 {\n        return vec![];\n\
    \    }\n    if length == 1 {\n        return array;\n    }\n    let sum = array[0]\
    \ + array[length - 1];\n    if sum % 2 == 0 {\n        array.sort_by(|a, b| b.cmp(a));\n\
    \    } else {\n        array.sort_by(|a, b| a.cmp(b));\n    }\n    array\n}\n\n\
    fn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822939
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() < 2 {\n \
    \       return array;\n    }\n    let mut array = array;\n    let (mut lo, mut\
    \ hi) = (0, array.len() - 1);\n    while lo < hi {\n        if array[lo] % 2 ==\
    \ 1 {\n            lo += 1;\n        } else if array[hi] % 2 == 0 {\n        \
    \    hi -= 1;\n        } else {\n            array.swap(lo, hi);\n        }\n\
    \    }\n    let (mut odd, mut even) = (0, lo);\n    while odd < lo && even < array.len()\
    \ {\n        if array[odd] > array[even] {\n            array.swap(odd, even);\n\
    \        }\n        odd += 2;\n        even += 2;\n    }\n    array\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 5, 4, 3]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmpg5dczow6.rs:41:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822939
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let total_index = array.len() - 1;\n    let mut i = 0;\n    let mut j = 0;\n\
    \    let mut min = 0;\n    let mut max = 0;\n    while i < total_index {\n   \
    \     while j < total_index {\n            if array[j] > array[j + 1] {\n    \
    \            max = array[j];\n                array[j] = array[j + 1];\n     \
    \           array[j + 1] = max;\n            }\n            j += 1;\n        }\n\
    \        i += 1;\n        j = 0;\n    }\n    if (array[0] + array[total_index])\
    \ % 2 == 0 {\n        while i < total_index {\n            min = array[i];\n \
    \           array[i] = array[total_index - i];\n            array[total_index\
    \ - i] = min;\n            i += 1;\n        }\n    }\n    array\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpwptjawa3.rs:13:23

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659822939
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() < 2 {\n \
    \       return array;\n    }\n    let mut arr = array.clone();\n    let mut even\
    \ = true;\n    if (arr[0] + arr[arr.len() - 1]) % 2 == 0 {\n        even = false;\n\
    \    }\n    arr.sort_by(|a, b| if even { b.cmp(a) } else { a.cmp(b) });\n    arr\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 4, 3, 2, 1, 0]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmppdceu0r9.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822939
