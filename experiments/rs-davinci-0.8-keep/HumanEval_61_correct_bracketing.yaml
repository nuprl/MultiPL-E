name: HumanEval_61_correct_bracketing
language: rs
prompt: "/// brackets is a string of \"(\" and \")\".\n/// return True if every opening\
  \ bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(\"(\"\
  )\n/// False\n/// >>> correct_bracketing(\"()\")\n/// True\n/// >>> correct_bracketing(\"\
  (()())\")\n/// True\n/// >>> correct_bracketing(\")(()\")\n/// False\nfn correct_bracketing(brackets:\
  \ String) -> bool {\n"
tests: "}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
  ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n   \
  \ assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
  ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
  ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
  \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
  ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
  (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
  \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
  }\n"
completions: ["    let mut stack = Vec::new();\n    for ch in brackets.chars() {\n\
    \        match ch {\n            '(' => stack.push(ch),\n            ')' => {\n\
    \                if stack.is_empty() {\n                    return false;\n  \
    \              }\n                let last = stack.pop().unwrap();\n         \
    \       if last != '(' {\n                    return false;\n                }\n\
    \            }\n            _ => panic!(\"Invalid bracketing\"),\n        }\n\
    \    }\n    stack.is_empty()", "    let mut count = 0;\n    for bracket in brackets.chars()\
    \ {\n        match bracket {\n            '(' => count += 1,\n            ')'\
    \ => count -= 1,\n            _ => {}\n        }\n        if count < 0 {\n   \
    \         return false;\n        }\n    }\n    return count == 0;", "    let mut\
    \ stack = Vec::new();\n    for c in brackets.chars() {\n        match c {\n  \
    \          '(' => stack.push(c),\n            ')' => {\n                if stack.is_empty()\
    \ {\n                    return false;\n                }\n                let\
    \ last = stack.pop().unwrap();\n                if last != '(' {\n           \
    \         return false;\n                }\n            }\n            _ => return\
    \ false,\n        }\n    }\n    return stack.is_empty();", "    let mut num_open\
    \ = 0;\n    for ch in brackets.chars() {\n        match ch {\n            '('\
    \ => num_open += 1,\n            ')' => num_open -= 1,\n            _ => continue,\n\
    \        }\n        if num_open < 0 {\n            return false;\n        }\n\
    \    }\n    num_open == 0", "    let mut open_count = 0;\n    for c in brackets.chars()\
    \ {\n        if c == '(' {\n            open_count += 1;\n        } else if c\
    \ == ')' {\n            open_count -= 1;\n        }\n        if open_count < 0\
    \ {\n            return false;\n        }\n    }\n    open_count == 0", '    true',
  "    let mut count = 0;\n    for x in brackets.chars() {\n        if x == '(' {\n\
    \            count += 1;\n        } else if x == ')' {\n            count -= 1;\n\
    \        } else {\n            panic!(\"Expected '(' or ')', got {}\", x);\n \
    \       }\n        if count < 0 {\n            return false;\n        }\n    }\n\
    \    count == 0", "    let mut stack = vec![];\n    for c in brackets.chars()\
    \ {\n        match c {\n            '(' => stack.push(c),\n            ')' =>\
    \ {\n                if stack.is_empty() {\n                    return false;\n\
    \                }\n                stack.pop();\n            }\n            _\
    \ => return false,\n        }\n    }\n    return stack.is_empty();", "    // count\
    \ the open brackets.\n    let mut open_brackets = 0;\n    for c in brackets.chars()\
    \ {\n        match c {\n            '(' => open_brackets += 1,\n            ')'\
    \ => open_brackets -= 1,\n            _ => panic!(\"unexpected character.\"),\n\
    \        }\n        if open_brackets < 0 {\n            return false;\n      \
    \  }\n    }\n    open_brackets == 0", "    let mut open_count = 0;\n    for b\
    \ in brackets.chars() {\n        if b == '(' {\n            open_count += 1;\n\
    \        } else if b == ')' {\n            open_count -= 1;\n        }\n     \
    \   if open_count < 0 {\n            return false;\n        }\n    }\n    open_count\
    \ == 0", "    let mut brackets_left = 0;\n    for c in brackets.chars() {\n  \
    \      if c == '(' {\n            brackets_left += 1;\n        } else if c ==\
    \ ')' {\n            brackets_left -= 1;\n        }\n        if brackets_left\
    \ < 0 {\n            return false;\n        }\n    }\n    brackets_left == 0",
  "    let mut level = 0;\n    for b in brackets.chars() {\n        if b == '(' {\n\
    \            level += 1;\n        } else if b == ')' {\n            level -= 1;\n\
    \        }\n        if level < 0 {\n            return false;\n        }\n   \
    \ }\n    return level == 0;", "    let mut bracket_stack: Vec<char> = Vec::new();\n\
    \    for c in brackets.chars() {\n        if c == '(' {\n            bracket_stack.push(c);\n\
    \        } else if c == ')' {\n            match bracket_stack.pop() {\n     \
    \           Some(_) => (),\n                None => return false,\n          \
    \  }\n        }\n    }\n    return bracket_stack.is_empty();", "    let mut stack\
    \ = Vec::new();\n    for ch in brackets.chars() {\n        match ch {\n      \
    \      '(' => stack.push(ch),\n            ')' => {\n                if stack.len()\
    \ == 0 {\n                    return false;\n                }\n             \
    \   stack.pop();\n            }\n            _ => panic!(\"Wrong symbol: {}\"\
    , ch),\n        }\n    }\n    stack.len() == 0", "    let mut depth = 0;\n   \
    \ for character in brackets.chars() {\n        if character == '(' {\n       \
    \     depth += 1;\n        } else if character == ')' {\n            depth -=\
    \ 1;\n        }\n        if depth < 0 {\n            return false;\n        }\n\
    \    }\n    depth == 0", "    // TODO\n    true", "    let mut count = 0;\n  \
    \  for b in brackets.chars() {\n        match b {\n            '(' => count +=\
    \ 1,\n            ')' => count -= 1,\n            _ => {},\n        }\n      \
    \  if count < 0 {\n            return false;\n        }\n    }\n    count == 0",
  "    let mut stack = vec![];\n    for bracket in brackets.chars() {\n        match\
    \ bracket {\n            '(' => stack.push(bracket),\n            ')' => {\n \
    \               if stack.pop() != Some('(') {\n                    return false;\n\
    \                }\n            }\n            _ => {}\n        }\n    }\n   \
    \ stack.is_empty()", "    let mut stack = Vec::new();\n    for c in brackets.chars()\
    \ {\n        match c {\n            '(' => stack.push(c),\n            ')' =>\
    \ {\n                if stack.is_empty() {\n                    return false;\n\
    \                }\n                if stack.pop().unwrap() != '(' {\n       \
    \             return false;\n                }\n            }\n            _ =>\
    \ (),\n        }\n    }\n    stack.is_empty()", "    let mut n = 0;\n    for c\
    \ in brackets.chars() {\n        match c {\n            '(' => n += 1,\n     \
    \       ')' => n -= 1,\n            _ => unreachable!(),\n        }\n        if\
    \ n < 0 {\n            return false;\n        }\n    }\n    return n == 0;"]
stop_tokens:
- "\n}"
