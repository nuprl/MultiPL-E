name: HumanEval_18_how_many_times
language: rs
prompt: "/// Find how many times a given substring can be found in the original string.\
  \ Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n/// >>> how_many_times('aaa',\
  \ 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n/// 3\nfn how_many_times(string:\
  \ String, substring: String) -> isize {\n"
tests: "}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
  \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
  ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
  ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
  ), String::from(\"john\")), 1);\n}\n"
completions: ['    unimplemented!()', '    string.matches(&substring).count() as isize',
  "    let mut offset = 0;\n    let mut count = 0;\n    while let Some(pos) = string[offset..].find(&substring)\
    \ {\n        count += 1;\n        offset += pos + substring.len();\n    }\n  \
    \  count", '    0', "    let mut result = 0;\n    let mut stop = false;\n    let\
    \ mut i = 0;\n    while !stop {\n        match string.find(&substring) {\n   \
    \         Some(index) => {\n                result += 1;\n                let\
    \ chars_to_omit = index + substring.len();\n                string = string.chars().skip(chars_to_omit).collect();\n\
    \            }\n            None => stop = true,\n        }\n    }\n    result",
  "    let mut count = 0;\n    let mut index = 0;\n    let mut old_index = 0;\n  \
    \  let string = string.as_str();\n    let substring = substring.as_str();\n  \
    \  while index < string.len() {\n        index = string.find(substring).unwrap_or(string.len());\n\
    \        count += 1;\n        if index < string.len() {\n            old_index\
    \ = index;\n            index += substring.len();\n        }\n    }\n    count",
  "    let text: Vec<char> = string.chars().collect();\n    let pattern: Vec<char>\
    \ = substring.chars().collect();\n    let mut count = 0;\n    let mut i = 0;\n\
    \    while i < text.len() {\n        let mut j = 0;\n        while j < pattern.len()\
    \ && i < text.len() && text[i] == pattern[j] {\n            i += 1;\n        \
    \    j += 1;\n        }\n        if j == pattern.len() {\n            count +=\
    \ 1;\n        }\n        i += 1;\n    }\n    count", '    string.matches(&substring).count()
    as isize', "    let string_len = string.len();\n    let substring_len = substring.len();\n\
    \    let mut how_many = 0;\n    let mut index = 0;\n    while index < string_len\
    \ {\n        if &string[index..index + substring_len] == substring {\n       \
    \     how_many += 1;\n            index += substring_len;\n        } else {\n\
    \            index += 1;\n        }\n    }\n    how_many", "    let mut times\
    \ = 0;\n    let mut idx = 0;\n    let string = string.into_bytes();\n    let substring\
    \ = substring.into_bytes();\n    while idx < string.len() {\n        if string[idx]\
    \ == substring[0] {\n            let mut i = 0;\n            let mut j = idx;\n\
    \            while i < substring.len() && j < string.len() && string[j] == substring[i]\
    \ {\n                i += 1;\n                j += 1;\n            }\n       \
    \     if i == substring.len() {\n                times += 1;\n            }\n\
    \        }\n        idx += 1;\n    }\n    times", "    let max_index = string.len()\
    \ - substring.len();\n    let mut count = 0;\n    for i in 0..max_index + 1 {\n\
    \        if string[i..i + substring.len()] == substring {\n            count +=\
    \ 1;\n        }\n    }\n    count", "    let mut count = 0;\n    let mut start\
    \ = 0;\n    let sub_len = substring.len();\n    for _ in 0..string.len() - sub_len\
    \ + 1 {\n        if &string[start..start + sub_len] == substring {\n         \
    \   count += 1;\n        }\n        start += 1;\n    }\n    count", "    let mut\
    \ counter = 0;\n    let mut position = 0;\n    let mut step = 1;\n    let string_length\
    \ = string.len();\n    let substring_length = substring.len();\n    loop {\n \
    \       if substring_length + position > string_length {\n            break;\n\
    \        }\n        if substring == string[position..substring_length + position].to_string()\
    \ {\n            counter += 1;\n            position += step;\n        } else\
    \ {\n            position += 1;\n        }\n    }\n    counter", "    let base_len\
    \ = string.len();\n    let sub_len = substring.len();\n    if base_len == 0 ||\
    \ sub_len == 0 || base_len < sub_len {\n        return 0;\n    }\n    let mut\
    \ num_times = 0;\n    let mut temp_string = string.clone();\n    loop {\n    \
    \    let i = temp_string.find(&substring);\n        if i.is_none() {\n       \
    \     break;\n        }\n        num_times += 1;\n        temp_string = temp_string[i.unwrap()\
    \ + sub_len..].to_string();\n    }\n    num_times", "    let (len_string, len_substring)\
    \ = (string.len(), substring.len());\n    if len_substring == 0 {\n        return\
    \ 0;\n    }\n    if len_substring > len_string {\n        return 0;\n    }\n \
    \   let mut count = 0;\n    let (mut i, mut j) = (0, 0);\n    while i < len_string\
    \ {\n        if string.as_bytes()[i] == substring.as_bytes()[j] {\n          \
    \  if j == len_substring - 1 {\n                count += 1;\n                i\
    \ = i - j;\n                j = 0;\n            } else {\n                i +=\
    \ 1;\n                j += 1;\n            }\n        } else {\n            i\
    \ = i - j + 1;\n            j = 0;\n        }\n    }\n    count", "    // TODO\n\
    \    0", "    let mut i = 0;\n    let mut j = 0;\n    let mut count = 0;\n   \
    \ let mut buf = String::new();\n    while i < string.len() {\n        if string.chars().nth(i)\
    \ == substring.chars().nth(j) {\n            buf.push(string.chars().nth(i).unwrap());\n\
    \            if buf == substring {\n                count += 1;\n            \
    \    buf.clear();\n                j = 0;\n            } else {\n            \
    \    j += 1;\n            }\n        } else {\n            buf.clear();\n    \
    \        j = 0;\n        }\n        i += 1;\n    }\n    count", "    let mut it\
    \ = 0;\n    let mut count = 0;\n    let len = substring.len();\n    while it <\
    \ string.len() {\n        if &string[it..it + len] == substring {\n          \
    \  count += 1;\n            it += len;\n        } else {\n            it += 1;\n\
    \        }\n    }\n    count", "    if string.len() == 0 || substring.len() ==\
    \ 0 {\n        return 0;\n    }\n    let mut index = 0;\n    let mut count = 0;\n\
    \    while index != -1 {\n        index = string.find(substring.as_str()).unwrap_or(-1);\n\
    \        if index != -1 {\n            string = string.replace_range(index..index\
    \ + substring.len(), \"\");\n            count += 1;\n        }\n    }\n    count",
  "    let s = string.as_str();\n    let ss = substring.as_str();\n    let mut count\
    \ = 0;\n    let mut offset = 0;\n    let mut len = s.len();\n    while offset\
    \ < len {\n        if len - offset < ss.len() {\n            break;\n        }\n\
    \        if s[offset..].starts_with(ss) {\n            count += 1;\n         \
    \   offset += ss.len();\n        } else {\n            offset += 1;\n        }\n\
    \    }\n    count"]
stop_tokens:
- "\n}"
