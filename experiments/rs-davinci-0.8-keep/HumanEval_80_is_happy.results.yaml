language: rs
name: HumanEval_80_is_happy
results:
- exit_code: 1
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// is_happy(a) => False\n\
    /// is_happy(aa) => False\n/// is_happy(abcd) => True\n/// is_happy(aabb) => False\n\
    /// is_happy(adb) => True\n/// is_happy(xyy) => False\nfn is_happy(s: String)\
    \ -> bool {\n    if s.len() < 3 {\n        return false;\n    }\n    let mut i\
    \ = 1;\n    let mut chars = s.chars();\n    let mut prev = chars.next().unwrap();\n\
    \    let mut c = chars.next().unwrap();\n    for c in chars {\n        if prev\
    \ == c || c == *chars.nth(i).unwrap() {\n            return false;\n        }\n\
    \        i += 1;\n        prev = c;\n    }\n    true\n}\n\nfn main() {\n    let\
    \ candidate = is_happy;\n    assert_eq!(candidate(String::from(\"a\")), false);\n\
    \    assert_eq!(candidate(String::from(\"aa\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\")), true);\n    assert_eq!(candidate(String::from(\"aabb\")), false);\n\
    \    assert_eq!(candidate(String::from(\"adb\")), true);\n    assert_eq!(candidate(String::from(\"\
    xyy\")), false);\n    assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n\
    \    assert_eq!(candidate(String::from(\"iopaxioi\")), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmp2cetglp8.rs:20:30\n\
    \   |\n20 |         if prev == c || c == *chars.nth(i).unwrap() {\n   |      \
    \                        ^^^^^^^^^^^^^^^^^^^^^^\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1659823207
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// is_happy(a) => False\n\
    /// is_happy(aa) => False\n/// is_happy(abcd) => True\n/// is_happy(aabb) => False\n\
    /// is_happy(adb) => True\n/// is_happy(xyy) => False\nfn is_happy(s: String)\
    \ -> bool {\n    if s.len() < 3 {\n        return false;\n    }\n    for i in\
    \ 0..(s.len() - 2) {\n        if &s[i..i + 3] == &s[i..i + 3].chars().rev().collect::<String>()\
    \ {\n            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = is_happy;\n    assert_eq!(candidate(String::from(\"a\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"aa\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\")), true);\n    assert_eq!(candidate(String::from(\"aabb\")), false);\n\
    \    assert_eq!(candidate(String::from(\"adb\")), true);\n    assert_eq!(candidate(String::from(\"\
    xyy\")), false);\n    assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n\
    \    assert_eq!(candidate(String::from(\"iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp_xl7qqx5.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823207
- exit_code: 0
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// is_happy(a) => False\n\
    /// is_happy(aa) => False\n/// is_happy(abcd) => True\n/// is_happy(aabb) => False\n\
    /// is_happy(adb) => True\n/// is_happy(xyy) => False\nfn is_happy(s: String)\
    \ -> bool {\n    // TODO\n    s.len() >= 3 && (0..s.len() - 2).all(|i| s.chars().nth(i)\
    \ != s.chars().nth(i + 1) && s.chars().nth(i) != s.chars().nth(i + 2) && s.chars().nth(i\
    \ + 1) != s.chars().nth(i + 2))\n}\n\nfn main() {\n    let candidate = is_happy;\n\
    \    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823207
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// is_happy(a) => False\n\
    /// is_happy(aa) => False\n/// is_happy(abcd) => True\n/// is_happy(aabb) => False\n\
    /// is_happy(adb) => True\n/// is_happy(xyy) => False\nfn is_happy(s: String)\
    \ -> bool {\n    if s.len() < 3 {\n        return false;\n    }\n    let chars:\
    \ Vec<char> = s.chars().collect();\n    let mut i = 0;\n    while i < chars.len()\
    \ - 2 {\n        if chars[i] == chars[i + 1] || chars[i] == chars[i + 2] {\n \
    \           return false;\n        }\n        i += 1;\n    }\n    true\n}\n\n\
    fn main() {\n    let candidate = is_happy;\n    assert_eq!(candidate(String::from(\"\
    a\")), false);\n    assert_eq!(candidate(String::from(\"aa\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\")), true);\n    assert_eq!(candidate(String::from(\"aabb\")), false);\n\
    \    assert_eq!(candidate(String::from(\"adb\")), true);\n    assert_eq!(candidate(String::from(\"\
    xyy\")), false);\n    assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n\
    \    assert_eq!(candidate(String::from(\"iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp6f9jomv4.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823207
- exit_code: 0
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// is_happy(a) => False\n\
    /// is_happy(aa) => False\n/// is_happy(abcd) => True\n/// is_happy(aabb) => False\n\
    /// is_happy(adb) => True\n/// is_happy(xyy) => False\nfn is_happy(s: String)\
    \ -> bool {\n    if s.len() < 3 {\n        return false;\n    }\n    for i in\
    \ 0..s.len() - 2 {\n        if s.chars().nth(i) == s.chars().nth(i + 1)\n    \
    \        || s.chars().nth(i) == s.chars().nth(i + 2)\n            || s.chars().nth(i\
    \ + 1) == s.chars().nth(i + 2)\n        {\n            return false;\n       \
    \ }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n    assert_eq!(candidate(String::from(\"\
    a\")), false);\n    assert_eq!(candidate(String::from(\"aa\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\")), true);\n    assert_eq!(candidate(String::from(\"aabb\")), false);\n\
    \    assert_eq!(candidate(String::from(\"adb\")), true);\n    assert_eq!(candidate(String::from(\"\
    xyy\")), false);\n    assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n\
    \    assert_eq!(candidate(String::from(\"iopaxioi\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823207
- exit_code: 1
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// is_happy(a) => False\n\
    /// is_happy(aa) => False\n/// is_happy(abcd) => True\n/// is_happy(aabb) => False\n\
    /// is_happy(adb) => True\n/// is_happy(xyy) => False\nfn is_happy(s: String)\
    \ -> bool {\n    let mut iter = s.chars();\n    let a = iter.next();\n    let\
    \ b = iter.next();\n    if a == b {\n        return false;\n    }\n    for _ in\
    \ 0..s.len() - 2 {\n        let c = iter.next();\n        if a == c || b == c\
    \ {\n            return false;\n        }\n        a = b;\n        b = c;\n  \
    \  }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n    assert_eq!(candidate(String::from(\"\
    a\")), false);\n    assert_eq!(candidate(String::from(\"aa\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\")), true);\n    assert_eq!(candidate(String::from(\"aabb\")), false);\n\
    \    assert_eq!(candidate(String::from(\"adb\")), true);\n    assert_eq!(candidate(String::from(\"\
    xyy\")), false);\n    assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n\
    \    assert_eq!(candidate(String::from(\"iopaxioi\")), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign twice to immutable variable `a`\n  --> /tmp/tmpmlyxg56o.rs:23:9\n\
    \   |\n13 |     let a = iter.next();\n   |         -\n   |         |\n   |   \
    \      first assignment to `a`\n   |         help: consider making this binding\
    \ mutable: `mut a`\n...\n23 |         a = b;\n   |         ^^^^^ cannot assign\
    \ twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable\
    \ variable `b`\n  --> /tmp/tmpmlyxg56o.rs:24:9\n   |\n14 |     let b = iter.next();\n\
    \   |         -\n   |         |\n   |         first assignment to `b`\n   |  \
    \       help: consider making this binding mutable: `mut b`\n...\n24 |       \
    \  b = c;\n   |         ^^^^^ cannot assign twice to immutable variable\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659823207
- exit_code: 0
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// is_happy(a) => False\n\
    /// is_happy(aa) => False\n/// is_happy(abcd) => True\n/// is_happy(aabb) => False\n\
    /// is_happy(adb) => True\n/// is_happy(xyy) => False\nfn is_happy(s: String)\
    \ -> bool {\n    if s.len() < 3 {\n        return false;\n    }\n    let chars:\
    \ Vec<char> = s.chars().collect();\n    for i in 0..chars.len() - 2 {\n      \
    \  if chars[i] == chars[i + 1] || chars[i] == chars[i + 2] || chars[i + 1] ==\
    \ chars[i + 2] {\n            return false;\n        }\n    }\n    true\n}\n\n\
    fn main() {\n    let candidate = is_happy;\n    assert_eq!(candidate(String::from(\"\
    a\")), false);\n    assert_eq!(candidate(String::from(\"aa\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\")), true);\n    assert_eq!(candidate(String::from(\"aabb\")), false);\n\
    \    assert_eq!(candidate(String::from(\"adb\")), true);\n    assert_eq!(candidate(String::from(\"\
    xyy\")), false);\n    assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n\
    \    assert_eq!(candidate(String::from(\"iopaxioi\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823207
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// is_happy(a) => False\n\
    /// is_happy(aa) => False\n/// is_happy(abcd) => True\n/// is_happy(aabb) => False\n\
    /// is_happy(adb) => True\n/// is_happy(xyy) => False\nfn is_happy(s: String)\
    \ -> bool {\n    s.chars().collect::<Vec<char>>().windows(3).all(|w| w[0] != w[1]\
    \ && w[1] != w[2] && w[0] != w[2])\n}\n\nfn main() {\n    let candidate = is_happy;\n\
    \    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpwfzzme78.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823207
- exit_code: 0
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// is_happy(a) => False\n\
    /// is_happy(aa) => False\n/// is_happy(abcd) => True\n/// is_happy(aabb) => False\n\
    /// is_happy(adb) => True\n/// is_happy(xyy) => False\nfn is_happy(s: String)\
    \ -> bool {\n    let n = s.len();\n    if n < 3 {\n        return false;\n   \
    \ }\n    for i in 0..n - 2 {\n        if s.chars().nth(i) == s.chars().nth(i +\
    \ 1) || s.chars().nth(i) == s.chars().nth(i + 2)\n            || s.chars().nth(i\
    \ + 1) == s.chars().nth(i + 2)\n        {\n            return false;\n       \
    \ }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n    assert_eq!(candidate(String::from(\"\
    a\")), false);\n    assert_eq!(candidate(String::from(\"aa\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\")), true);\n    assert_eq!(candidate(String::from(\"aabb\")), false);\n\
    \    assert_eq!(candidate(String::from(\"adb\")), true);\n    assert_eq!(candidate(String::from(\"\
    xyy\")), false);\n    assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n\
    \    assert_eq!(candidate(String::from(\"iopaxioi\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823207
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// is_happy(a) => False\n\
    /// is_happy(aa) => False\n/// is_happy(abcd) => True\n/// is_happy(aabb) => False\n\
    /// is_happy(adb) => True\n/// is_happy(xyy) => False\nfn is_happy(s: String)\
    \ -> bool {\n    if s.len() < 3 {\n        return false;\n    }\n    let iter\
    \ = s.chars().enumerate();\n    let len = s.len();\n    for (i, letter) in iter\
    \ {\n        if i + 3 < len {\n            if letter == s.chars().nth(i + 1).unwrap()\
    \ || letter == s.chars().nth(i + 2).unwrap() {\n                return false;\n\
    \            }\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = is_happy;\n    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp871z2brs.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823207
- exit_code: 0
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// is_happy(a) => False\n\
    /// is_happy(aa) => False\n/// is_happy(abcd) => True\n/// is_happy(aabb) => False\n\
    /// is_happy(adb) => True\n/// is_happy(xyy) => False\nfn is_happy(s: String)\
    \ -> bool {\n    let chars: Vec<char> = s.chars().collect();\n    if chars.len()\
    \ < 3 {\n        return false;\n    }\n    for i in 0..(chars.len() - 2) {\n \
    \       if chars[i] == chars[i + 1] || chars[i] == chars[i + 2] || chars[i + 1]\
    \ == chars[i + 2] {\n            return false;\n        }\n    }\n    true\n}\n\
    \nfn main() {\n    let candidate = is_happy;\n    assert_eq!(candidate(String::from(\"\
    a\")), false);\n    assert_eq!(candidate(String::from(\"aa\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\")), true);\n    assert_eq!(candidate(String::from(\"aabb\")), false);\n\
    \    assert_eq!(candidate(String::from(\"adb\")), true);\n    assert_eq!(candidate(String::from(\"\
    xyy\")), false);\n    assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n\
    \    assert_eq!(candidate(String::from(\"iopaxioi\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823207
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// is_happy(a) => False\n\
    /// is_happy(aa) => False\n/// is_happy(abcd) => True\n/// is_happy(aabb) => False\n\
    /// is_happy(adb) => True\n/// is_happy(xyy) => False\nfn is_happy(s: String)\
    \ -> bool {\n    let mut i = 0;\n    while i < s.len() - 2 {\n        if s.chars().nth(i)\
    \ == s.chars().nth(i + 1) {\n            return false;\n        }\n        i +=\
    \ 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n    assert_eq!(candidate(String::from(\"\
    a\")), false);\n    assert_eq!(candidate(String::from(\"aa\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\")), true);\n    assert_eq!(candidate(String::from(\"aabb\")), false);\n\
    \    assert_eq!(candidate(String::from(\"adb\")), true);\n    assert_eq!(candidate(String::from(\"\
    xyy\")), false);\n    assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n\
    \    assert_eq!(candidate(String::from(\"iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmp9dlo47t_.rs:13:15

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823207
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// is_happy(a) => False\n\
    /// is_happy(aa) => False\n/// is_happy(abcd) => True\n/// is_happy(aabb) => False\n\
    /// is_happy(adb) => True\n/// is_happy(xyy) => False\nfn is_happy(s: String)\
    \ -> bool {\n    if s.len() < 3 {\n        return false;\n    }\n    let v: Vec<char>\
    \ = s.chars().collect();\n    for i in 2..v.len() {\n        if v[i] == v[i -\
    \ 1] && v[i] == v[i - 2] {\n            return false;\n        }\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = is_happy;\n    assert_eq!(candidate(String::from(\"\
    a\")), false);\n    assert_eq!(candidate(String::from(\"aa\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\")), true);\n    assert_eq!(candidate(String::from(\"aabb\")), false);\n\
    \    assert_eq!(candidate(String::from(\"adb\")), true);\n    assert_eq!(candidate(String::from(\"\
    xyy\")), false);\n    assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n\
    \    assert_eq!(candidate(String::from(\"iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpljy_wi20.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823207
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// is_happy(a) => False\n\
    /// is_happy(aa) => False\n/// is_happy(abcd) => True\n/// is_happy(aabb) => False\n\
    /// is_happy(adb) => True\n/// is_happy(xyy) => False\nfn is_happy(s: String)\
    \ -> bool {\n    if s.len() < 3 {\n        return false;\n    }\n    let chars:\
    \ Vec<char> = s.chars().collect();\n    let mut i = 0;\n    while i < chars.len()\
    \ - 2 {\n        if chars[i] == chars[i + 1] || chars[i] == chars[i + 2] {\n \
    \           return false;\n        }\n        i += 1;\n    }\n    return true;\n\
    }\n\nfn main() {\n    let candidate = is_happy;\n    assert_eq!(candidate(String::from(\"\
    a\")), false);\n    assert_eq!(candidate(String::from(\"aa\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\")), true);\n    assert_eq!(candidate(String::from(\"aabb\")), false);\n\
    \    assert_eq!(candidate(String::from(\"adb\")), true);\n    assert_eq!(candidate(String::from(\"\
    xyy\")), false);\n    assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n\
    \    assert_eq!(candidate(String::from(\"iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4pooz60n.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823207
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// is_happy(a) => False\n\
    /// is_happy(aa) => False\n/// is_happy(abcd) => True\n/// is_happy(aabb) => False\n\
    /// is_happy(adb) => True\n/// is_happy(xyy) => False\nfn is_happy(s: String)\
    \ -> bool {\n    s.chars().collect::<Vec<char>>().windows(3).all(|c| c[0] != c[1]\
    \ && c[1] != c[2] && c[0] != c[2])\n}\n\nfn main() {\n    let candidate = is_happy;\n\
    \    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpekz5dyye.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823207
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// is_happy(a) => False\n\
    /// is_happy(aa) => False\n/// is_happy(abcd) => True\n/// is_happy(aabb) => False\n\
    /// is_happy(adb) => True\n/// is_happy(xyy) => False\nfn is_happy(s: String)\
    \ -> bool {\n    s.chars().collect::<Vec<char>>().windows(3).all(|v| v[0] != v[1]\
    \ && v[1] != v[2] && v[0] != v[2])\n}\n\nfn main() {\n    let candidate = is_happy;\n\
    \    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpmse5tadj.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823207
- exit_code: 0
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// is_happy(a) => False\n\
    /// is_happy(aa) => False\n/// is_happy(abcd) => True\n/// is_happy(aabb) => False\n\
    /// is_happy(adb) => True\n/// is_happy(xyy) => False\nfn is_happy(s: String)\
    \ -> bool {\n    let v: Vec<char> = s.chars().collect();\n    if v.len() < 3 {\n\
    \        return false;\n    }\n    for i in 0..v.len() - 2 {\n        if v[i]\
    \ == v[i + 1] || v[i] == v[i + 2] || v[i + 1] == v[i + 2] {\n            return\
    \ false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_happy;\n\
    \    assert_eq!(candidate(String::from(\"a\")), false);\n    assert_eq!(candidate(String::from(\"\
    aa\")), false);\n    assert_eq!(candidate(String::from(\"abcd\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"aabb\")), false);\n    assert_eq!(candidate(String::from(\"\
    adb\")), true);\n    assert_eq!(candidate(String::from(\"xyy\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n    assert_eq!(candidate(String::from(\"\
    iopaxioi\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823207
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// is_happy(a) => False\n\
    /// is_happy(aa) => False\n/// is_happy(abcd) => True\n/// is_happy(aabb) => False\n\
    /// is_happy(adb) => True\n/// is_happy(xyy) => False\nfn is_happy(s: String)\
    \ -> bool {\n    let size = s.len();\n    let v: Vec<char> = s.chars().collect();\n\
    \    for i in 0..size - 2 {\n        if v[i] == v[i + 1] || v[i] == v[i + 2] ||\
    \ v[i + 1] == v[i + 2] {\n            return false;\n        }\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = is_happy;\n    assert_eq!(candidate(String::from(\"\
    a\")), false);\n    assert_eq!(candidate(String::from(\"aa\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\")), true);\n    assert_eq!(candidate(String::from(\"aabb\")), false);\n\
    \    assert_eq!(candidate(String::from(\"adb\")), true);\n    assert_eq!(candidate(String::from(\"\
    xyy\")), false);\n    assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n\
    \    assert_eq!(candidate(String::from(\"iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmp0wdtjibs.rs:14:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823207
- exit_code: 1
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// is_happy(a) => False\n\
    /// is_happy(aa) => False\n/// is_happy(abcd) => True\n/// is_happy(aabb) => False\n\
    /// is_happy(adb) => True\n/// is_happy(xyy) => False\nfn is_happy(s: String)\
    \ -> bool {\n    if s.len() < 3 {\n        return false;\n    }\n    let mut chars\
    \ = s.chars();\n    let mut start = chars.next().unwrap();\n    let mut mid =\
    \ chars.next().unwrap();\n    let mut end = chars.next().unwrap();\n    while\
    \ chars.len() > 0 {\n        if start == mid || mid == end || start == end {\n\
    \            return false;\n        }\n        start = mid;\n        mid = end;\n\
    \        end = chars.next().unwrap();\n    }\n    return true;\n}\n\nfn main()\
    \ {\n    let candidate = is_happy;\n    assert_eq!(candidate(String::from(\"a\"\
    )), false);\n    assert_eq!(candidate(String::from(\"aa\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\")), true);\n    assert_eq!(candidate(String::from(\"aabb\")), false);\n\
    \    assert_eq!(candidate(String::from(\"adb\")), true);\n    assert_eq!(candidate(String::from(\"\
    xyy\")), false);\n    assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n\
    \    assert_eq!(candidate(String::from(\"iopaxioi\")), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for struct `Chars` in the current\
    \ scope\n  --> /tmp/tmp5b8tu4ke.rs:19:17\n   |\n19 |     while chars.len() > 0\
    \ {\n   |                 ^^^ method not found in `Chars<'_>`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659823207
- exit_code: 101
  program: "/// You are given a string s.\n/// Your task is to check if the string\
    \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
    \ 3 consecutive letters are distinct\n/// For example:\n/// is_happy(a) => False\n\
    /// is_happy(aa) => False\n/// is_happy(abcd) => True\n/// is_happy(aabb) => False\n\
    /// is_happy(adb) => True\n/// is_happy(xyy) => False\nfn is_happy(s: String)\
    \ -> bool {\n    // String char_indices returns (usize, char) tuple\n    // so\
    \ it's easy to pair up the first two with _ and the third with c\n    // We then\
    \ need to check that the first char and the third char are not the same\n    s.chars().nth(2).map_or(false,\
    \ |c| {\n        s.char_indices().take(2).any(|(_, a)| a != c)\n    })\n}\n\n\
    fn main() {\n    let candidate = is_happy;\n    assert_eq!(candidate(String::from(\"\
    a\")), false);\n    assert_eq!(candidate(String::from(\"aa\")), false);\n    assert_eq!(candidate(String::from(\"\
    abcd\")), true);\n    assert_eq!(candidate(String::from(\"aabb\")), false);\n\
    \    assert_eq!(candidate(String::from(\"adb\")), true);\n    assert_eq!(candidate(String::from(\"\
    xyy\")), false);\n    assert_eq!(candidate(String::from(\"iopaxpoi\")), true);\n\
    \    assert_eq!(candidate(String::from(\"iopaxioi\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpgym4t9yo.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823207
