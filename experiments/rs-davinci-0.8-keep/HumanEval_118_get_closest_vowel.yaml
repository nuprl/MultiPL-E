name: HumanEval_118_get_closest_vowel
language: rs
prompt: "/// You are given a word. Your task is to find the closest vowel that stands\
  \ between \n/// two consonants from the right side of the word (case sensitive).\n\
  /// Vowels in the beginning and ending doesn't count. Return empty string if you\
  \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
  \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
  yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
  quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
  \ String) -> String {\n"
tests: "}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
  yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
  )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
  \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
  \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
  bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")),\
  \ String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
  \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n  \
  \  assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
  anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\"\
  )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"\
  o\"));\n}\n"
completions: ['    unimplemented!()', "    let vowels = [\"a\", \"e\", \"i\", \"o\"\
    , \"u\"];\n    let mut position = 0;\n    let mut word = word.into_bytes();\n\
    \    word.reverse();\n    let mut i = 0;\n    while i < word.len() - 1 {\n   \
    \     if vowels.contains(&(&word[i] as char).to_lowercase().to_string().as_str())\
    \ &&\n            vowels.contains(&(&word[i + 1] as char).to_lowercase().to_string().as_str())\
    \ {\n            break;\n        }\n        i += 1;\n    }\n    if i == word.len()\
    \ - 1 {\n        String::from(\"\")\n    } else {\n        String::from_utf8(vec![word[i]]).unwrap()\n\
    \    }", "    let mut closest = String::new();\n    let mut chars = word.chars().rev();\n\
    \    loop {\n        let c = chars.next();\n        if c.is_none() {\n       \
    \     break;\n        }\n        let c = c.unwrap();\n        if c.is_alphabetic()\
    \ {\n            if closest.is_empty() {\n                if c.is_vowel() {\n\
    \                    closest.push(c);\n                }\n            } else {\n\
    \                if c.is_vowel() {\n                    return closest;\n    \
    \            } else {\n                    closest.clear();\n                }\n\
    \            }\n        }\n    }\n    closest", '    unimplemented!();', "   \
    \ let mut result = \"\".to_string();\n    let word = word.to_lowercase();\n  \
    \  let word_len = word.len();\n    let word_chars: Vec<char> = word.chars().collect();\n\
    \    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut vowel_position =\
    \ 0;\n    let mut consonant_position = 0;\n    let mut counter = 0;\n    let mut\
    \ init_vowel_position = 0;\n    let mut init_consonant_position = 0;\n    for\
    \ c in word_chars {\n        if consonant_position == 0 && vowel_position == 0\
    \ {\n            if vowels.contains(&c) {\n                vowel_position = word_len\
    \ - counter;\n                init_vowel_position = vowel_position;\n        \
    \    } else {\n                consonant_position = word_len - counter;\n    \
    \            init_consonant_position = consonant_position;\n            }\n  \
    \      } else if consonant_position > 0 && vowel_position == 0 {\n           \
    \ if vowels.contains(&c) {\n                vowel_position = word_len - counter;\n\
    \            }\n        } else if consonant_position == 0 && vowel_position >\
    \ 0 {\n            if !vowels.contains(&c) {\n                consonant_position\
    \ = word_len - counter;\n            }\n        } else if consonant_position >\
    \ 0 && vowel_position > 0 {\n            if consonant_position < vowel_position\
    \ {\n                break;\n            } else if consonant_position > vowel_position\
    \ {\n                if vowels.contains(&c) {\n                    vowel_position\
    \ = word_len - counter;\n                } else {\n                    consonant_position\
    \ = word_len - counter;\n                }\n            }\n        }\n       \
    \ counter += 1;\n    }\n    if consonant_position == init_consonant_position {\n\
    \        return result;\n    }\n    result = word_chars[vowel_position - 1].to_string();\n\
    \    result", '    unimplemented!();', "    let vowels = ['a', 'e', 'i', 'o',\
    \ 'u'];\n    let mut closest_index = 0;\n    let mut found = false;\n    let word_chars:\
    \ Vec<char> = word.chars().collect();\n    let word_len = word_chars.len();\n\
    \    for i in (0..word_len).rev() {\n        if !vowels.contains(&word_chars[i])\
    \ {\n            // not found\n            continue;\n        }\n        if i\
    \ > 0 && !vowels.contains(&word_chars[i - 1]) {\n            // found, check if\
    \ last\n            if i == word_len - 1 {\n                found = true;\n  \
    \              closest_index = i;\n                break;\n            }\n   \
    \         // found\n            if !vowels.contains(&word_chars[i + 1]) {\n  \
    \              found = true;\n                closest_index = i;\n           \
    \     break;\n            }\n        }\n    }\n    if found {\n        word_chars[closest_index].to_string()\n\
    \    } else {\n        \"\".to_string()\n    }", "    let mut vowels = vec!['A',\
    \ 'E', 'I', 'O', 'U'];\n    vowels.append(&mut vec!['a', 'e', 'i', 'o', 'u']);\n\
    \    let mut v_pos: i32 = -1;\n    let mut c_pos: i32 = word.len() as i32;\n \
    \   for (i, c) in word.chars().enumerate() {\n        if vowels.contains(&c) {\n\
    \            v_pos = i as i32;\n        } else if v_pos > -1 {\n            c_pos\
    \ = i as i32;\n            break;\n        }\n    }\n    if v_pos > -1 && c_pos\
    \ > v_pos + 1 {\n        word.chars().nth(v_pos as usize).unwrap().to_string()\n\
    \    } else {\n        \"\".to_string()\n    }", "    let vowels = vec![\"a\"\
    , \"e\", \"i\", \"o\", \"u\"];\n    let count = word.len();\n    let chars: Vec<char>\
    \ = word.chars().collect();\n    for i in 0..count {\n        if !vowels.contains(&chars[i].to_string().as_str())\
    \ {\n            if i + 1 < count && vowels.contains(&chars[i + 1].to_string().as_str())\
    \ {\n                return chars[i + 1].to_string();\n            }\n       \
    \ }\n    }\n    String::from(\"\")", "    let vowels = vec!['a', 'e', 'i', 'o',\
    \ 'u'];\n    let mut closest_vowel = ' ';\n    let mut min_distance = 0;\n   \
    \ for (idx, c) in word.chars().enumerate() {\n        if vowels.contains(&c) {\n\
    \            let mut right_distance = 0;\n            for (r_idx, r_c) in word.chars().enumerate().skip(idx\
    \ + 1) {\n                if vowels.contains(&r_c) {\n                    right_distance\
    \ = 0;\n                } else {\n                    right_distance += 1;\n \
    \               }\n                if right_distance > min_distance {\n      \
    \              break;\n                }\n            }\n            if right_distance\
    \ > min_distance {\n                continue;\n            }\n            let\
    \ mut left_distance = 0;\n            for (l_idx, l_c) in word.chars().enumerate().rev().skip(word.len()\
    \ - idx) {\n                if vowels.contains(&l_c) {\n                    left_distance\
    \ = 0;\n                } else {\n                    left_distance += 1;\n  \
    \              }\n                if left_distance > min_distance {\n        \
    \            break;\n                }\n            }\n            if left_distance\
    \ > min_distance {\n                continue;\n            }\n            min_distance\
    \ = std::cmp::min(left_distance, right_distance);\n            closest_vowel =\
    \ c;\n        }\n    }\n    if closest_vowel == ' ' {\n        \"\".to_string()\n\
    \    } else {\n        closest_vowel.to_string()\n    }", "    let mut iter =\
    \ word.chars().rev();\n    let mut consonant = iter.next().unwrap();\n    let\
    \ mut has_consonant = false;\n    let mut has_vowel = false;\n    let mut result\
    \ = String::new();\n    for vowel in iter {\n        match vowel {\n         \
    \   'a' | 'e' | 'i' | 'o' | 'u' => {\n                if has_consonant {\n   \
    \                 result.push(vowel);\n                    break;\n          \
    \      }\n                has_vowel = true;\n            },\n            _ =>\
    \ {\n                if has_vowel {\n                    result.push(consonant);\n\
    \                    break;\n                }\n                has_consonant\
    \ = true;\n                consonant = vowel;\n            }\n        }\n    }\n\
    \    result", "    let vowels = \"AEIOUaeiou\";\n    let start = word.len() -\
    \ 1;\n    let chars: Vec<char> = word.chars().collect();\n    for i in (0..chars.len()).rev()\
    \ {\n        if vowels.contains(chars[i]) {\n            for j in (i + 1..chars.len()).rev()\
    \ {\n                if vowels.contains(chars[j]) {\n                    return\
    \ chars[j].to_string();\n                }\n            }\n        }\n    }\n\
    \    \"\".to_string()", "    // None means word end\n    if word.len() < 2 {\n\
    \        return String::new();\n    }\n    let mut last_vowel = 0;\n    for (i,\
    \ c) in word.chars().enumerate().rev() {\n        if is_vowel(c) {\n         \
    \   last_vowel = i;\n            break;\n        }\n    }\n    if last_vowel ==\
    \ 0 {\n        return String::new();\n    }\n    let mut vowels = vec![];\n  \
    \  for (i, c) in word.chars().enumerate().rev() {\n        if is_vowel(c) {\n\
    \            vowels.push(i);\n        } else {\n            break;\n        }\n\
    \    }\n    if vowels.len() < 2 {\n        return String::new();\n    }\n    let\
    \ mut closest_vowel = -1;\n    for v in vowels {\n        if v > last_vowel {\n\
    \            closest_vowel = v;\n            break;\n        }\n    }\n    if\
    \ closest_vowel < 0 {\n        closest_vowel = vowels[0];\n    }\n    let mut\
    \ r = String::new();\n    r.push(word.chars().nth(closest_vowel).unwrap());\n\
    \    r", "    word.chars().rev().skip_while(|&c| !(c == 'A' || c == 'E' || c ==\
    \ 'I' || c == 'O' || c == 'U')).skip(1).skip_while(|&c| !(c == 'A' || c == 'E'\
    \ || c == 'I' || c == 'O' || c == 'U')).take(1).collect()", "    let mut word_chars\
    \ = word.chars().collect::<Vec<char>>();\n    word_chars.reverse();\n    let mut\
    \ count = 0;\n    for c in word_chars {\n        count += 1;\n        if c.is_lowercase()\
    \ {\n            if !c.is_alphabetic() {\n                continue;\n        \
    \    }\n            if is_vowel(c) {\n                if count == 1 {\n      \
    \              continue;\n                }\n                if count == 2 {\n\
    \                    return String::from(\"\");\n                }\n         \
    \       let prev = word_chars[count - 2];\n                if prev.is_lowercase()\
    \ {\n                    if !prev.is_alphabetic() {\n                        continue;\n\
    \                    }\n                    if !is_vowel(prev) {\n           \
    \             return c.to_string();\n                    }\n                }\n\
    \            }\n        }\n        if c.is_uppercase() {\n            if !c.is_alphabetic()\
    \ {\n                continue;\n            }\n            if is_vowel(c) {\n\
    \                if count == 1 {\n                    continue;\n            \
    \    }\n                if count == 2 {\n                    return String::from(\"\
    \");\n                }\n                let prev = word_chars[count - 2];\n \
    \               if prev.is_uppercase() {\n                    if !prev.is_alphabetic()\
    \ {\n                        continue;\n                    }\n              \
    \      if !is_vowel(prev) {\n                        return c.to_string();\n \
    \                   }\n                }\n            }\n        }\n    }\n  \
    \  String::from(\"\")", '    unimplemented!()', "    let vowels = \"aeiouAEIOU\"\
    ;\n    let mut buffer = String::new();\n    let mut result = String::new();\n\
    \    for c in word.chars().rev() {\n        if vowels.contains(c) {\n        \
    \    buffer.push(c);\n        } else {\n            if !buffer.is_empty() {\n\
    \                result = buffer.clone();\n                break;\n          \
    \  }\n        }\n    }\n    result", "    let vowels = vec!['a', 'e', 'i', 'o',\
    \ 'u'];\n    let consonants = \"bcdfghjklmnpqrstvwxyz\".chars().collect::<Vec<char>>();\n\
    \    let mut closest_vowel = String::new();\n    let mut closest_index = word.len();\n\
    \    for (i, c) in word.chars().enumerate().rev() {\n        if vowels.contains(&c)\
    \ {\n            closest_vowel = c.to_string();\n            closest_index = i;\n\
    \        } else if consonants.contains(&c) {\n            if i == word.len() -\
    \ 1 {\n                return String::new();\n            }\n            if closest_index\
    \ < word.len() {\n                return closest_vowel;\n            }\n     \
    \   }\n    }\n    String::new()", "    let word = word.chars().rev().collect::<Vec<char>>();\n\
    \    let mut vowels = String::new();\n    let mut cons = String::new();\n    let\
    \ mut res = String::new();\n    let mut index: usize = 0;\n    let cons1 = \"\
    b,c,d,f,g,h,j,k,l,m,n,p,q,r,s,t,v,w,x,y,z\".split(\",\").collect::<Vec<&str>>();\n\
    \    let cons2 = \"B,C,D,F,G,H,J,K,L,M,N,P,Q,R,S,T,V,W,X,Y,Z\".split(\",\").collect::<Vec<&str>>();\n\
    \    let vow1 = \"a,e,i,o,u\".split(\",\").collect::<Vec<&str>>();\n    let vow2\
    \ = \"A,E,I,O,U\".split(\",\").collect::<Vec<&str>>();\n    for c in word.iter()\
    \ {\n        if vow1.contains(&c.to_string().as_str()) || vow2.contains(&c.to_string().as_str())\
    \ {\n            vowels = vowels + c.to_string().as_str();\n        } else if\
    \ cons1.contains(&c.to_string().as_str()) || cons2.contains(&c.to_string().as_str())\
    \ {\n            cons = cons + c.to_string().as_str();\n        }\n    }\n   \
    \ for v in vowels.chars() {\n        if cons.chars().nth(index).is_some() {\n\
    \            res = res + &v.to_string();\n            index += 1;\n        }\n\
    \    }\n    return res;", "    if word.len() < 3 {\n        return \"\".to_string();\n\
    \    }\n    let mut i = word.len() - 1;\n    while i > 0 {\n        let mut c\
    \ = word.chars().nth(i).unwrap();\n        if c == 'a' || c == 'e' || c == 'i'\
    \ || c == 'o' || c == 'u' {\n            let j = i - 1;\n            if j > 0\
    \ {\n                let mut c2 = word.chars().nth(j).unwrap();\n            \
    \    if c2 != 'a' && c2 != 'e' && c2 != 'i' && c2 != 'o' && c2 != 'u' {\n    \
    \                let mut c3 = word.chars().nth(j - 1).unwrap();\n            \
    \        if c3 != 'a' && c3 != 'e' && c3 != 'i' && c3 != 'o' && c3 != 'u' {\n\
    \                        return c.to_string();\n                    }\n      \
    \          }\n            }\n        }\n        i -= 1;\n    }\n    \"\".to_string()"]
stop_tokens:
- "\n}"
