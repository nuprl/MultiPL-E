name: HumanEval_127_intersection
language: rs
prompt: "/// You are given two intervals,\n/// where each interval is a pair of integers.\
  \ For example, interval = (start, end) = (1, 2).\n/// The given intervals are closed\
  \ which means that the interval (start, end)\n/// includes both start and end.\n\
  /// For each given interval, it is assumed that its start is less or equal its end.\n\
  /// Your task is to determine whether the length of intersection of these two \n\
  /// intervals is a prime number.\n/// Example, the intersection of the intervals\
  \ (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which not a prime number.\n\
  /// If the length of the intersection is a prime number, return \"YES\",\n/// otherwise,\
  \ return \"NO\".\n/// If the two intervals don't intersect, return \"NO\".\n///\
  \ [input/output] samples:\n/// intersection((1, 2), (2, 3)) ==> \"NO\"\n/// intersection((-1,\
  \ 1), (0, 4)) ==> \"NO\"\n/// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1:\
  \ (isize, isize), interval2: (isize, isize)) -> String {\n"
tests: "}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
  \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
  \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
  YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
  \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
  \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
  \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
  NO\"));\n}\n"
completions: ["    // Calculate intersection length\n    let length = if interval1.0\
    \ > interval2.0 {\n        if interval1.0 > interval2.1 {\n            0\n   \
    \     } else {\n            (interval2.1 - interval1.0 + 1) as usize\n       \
    \ }\n    } else {\n        if interval2.0 > interval1.1 {\n            0\n   \
    \     } else {\n            (interval1.1 - interval2.0 + 1) as usize\n       \
    \ }\n    };\n    // Return if the length is prime\n    if length == 0 {\n    \
    \    \"NO\".to_string()\n    } else {\n        match is_prime(length) {\n    \
    \        true => \"YES\".to_string(),\n            false => \"NO\".to_string(),\n\
    \        }\n    }", "  let (start1, end1) = interval1;\n  let (start2, end2) =\
    \ interval2;\n  let mut int_s = 0;\n  let mut int_e = 0;\n  if (start1 > start2\
    \ && start1 < end2) || (start2 > start1 && start2 < end1) {\n    if start1 > start2\
    \ {\n      int_s = start1;\n    } else {\n      int_s = start2;\n    }\n    if\
    \ end1 < end2 {\n      int_e = end1;\n    } else {\n      int_e = end2;\n    }\n\
    \    let length = (int_e - int_s) + 1;\n    for i in 2..length {\n      if length\
    \ % i == 0 {\n        return \"NO\".to_string();\n      }\n    }\n    return \"\
    YES\".to_string();\n  }\n  \"NO\".to_string()", "    let (i1_a, i1_b) = interval1;\n\
    \    let (i2_a, i2_b) = interval2;\n    if i1_a > i2_b || i2_a > i1_b {\n    \
    \    return \"NO\".to_string();\n    }\n    let interval = (std::cmp::max(i1_a,\
    \ i2_a), std::cmp::min(i1_b, i2_b));\n    if interval.1 - interval.0 <= 2 {\n\
    \        return \"NO\".to_string();\n    }\n    if (2..(interval.1 - interval.0)).any(|i|\
    \ (interval.1 - interval.0) % i == 0) {\n        return \"NO\".to_string();\n\
    \    }\n    \"YES\".to_string()", "    let (s1, e1) = interval1;\n    let (s2,\
    \ e2) = interval2;\n    if s1 > e2 || s2 > e1 {\n        return \"NO\".to_string();\n\
    \    }\n    let int_start = if s1 > s2 { s1 } else { s2 };\n    let int_end =\
    \ if e1 < e2 { e1 } else { e2 };\n    let int_len = int_end - int_start + 1;\n\
    \    if int_len <= 2 {\n        return \"NO\".to_string();\n    }\n    for i in\
    \ 2..(int_len / 2 + 1) {\n        if int_len % i == 0 {\n            return \"\
    NO\".to_string();\n        }\n    }\n    \"YES\".to_string()", "    // \n    //\
    \ You can use the functions is_prime(n: isize) and gcd(m: isize, n: isize)\n \
    \   // to determine whether a number is prime and to find the greatest common\
    \ divisor\n    // between two numbers, respectively.\n    // You can add a helper\
    \ function of your own choice to this file.\n    //\n    // Good luck!\n    //\n\
    \    if interval1.0 > interval2.1 || interval2.0 > interval1.1 {\n        return\
    \ \"NO\".to_string();\n    }\n\n    let (a, b) = (interval1.0, interval1.1);\n\
    \    let (c, d) = (interval2.0, interval2.1);\n\n    let (mut x, mut y) = (max(a,\
    \ c), min(b, d));\n\n    // y - x is the length of the intersection\n    if y\
    \ - x <= 1 {\n        return \"NO\".to_string();\n    }\n\n    // gcd(y - x, x)\
    \ is the length of the intersection\n    // if it is prime, return \"YES\", otherwise,\
    \ return \"NO\"\n    if is_prime(gcd(y - x, x)) {\n        return \"YES\".to_string();\n\
    \    } else {\n        return \"NO\".to_string();\n    }", "    // Minus one because\
    \ they are inclusive\n    let (a, b) = (interval1.1 - interval1.0 - 1, interval2.1\
    \ - interval2.0 - 1);\n    if a == 0 || b == 0 {\n        return \"NO\".to_string();\n\
    \    }\n    if a.gcd(&b) == 1 {\n        return \"YES\".to_string();\n    }\n\
    \    \"NO\".to_string()", "    use std::cmp::{max, min};\n    if interval1.0 >\
    \ interval2.1 || interval2.0 > interval1.1 {\n        return \"NO\".to_string();\n\
    \    }\n    let x = max(interval1.0, interval2.0);\n    let y = min(interval1.1,\
    \ interval2.1);\n    let z = if x > y { 0 } else { y - x + 1 };\n    match z {\n\
    \        2 | 3 | 5 | 7 => \"YES\".to_string(),\n        _ => \"NO\".to_string(),\n\
    \    }", "    let (interval1_start, interval1_end) = interval1;\n    let (interval2_start,\
    \ interval2_end) = interval2;\n    let interval_start = interval1_start.max(interval2_start);\n\
    \    let interval_end = interval1_end.min(interval2_end);\n    let mut is_prime\
    \ = false;\n    if interval_start > interval_end {\n        is_prime = false;\n\
    \    } else {\n        is_prime = is_prime_number(interval_end - interval_start);\n\
    \    }\n    if is_prime {\n        \"YES\".to_string()\n    } else {\n       \
    \ \"NO\".to_string()\n    }", "    let (mut a, mut b) = interval1;\n    let (mut\
    \ c, mut d) = interval2;\n    if b < c || d < a {\n        return \"NO\".to_string();\n\
    \    }\n    if b > d {\n        b = d;\n    }\n    if a < c {\n        a = c;\n\
    \    }\n    let n = b - a + 1;\n    if is_prime(n) {\n        \"YES\".to_string()\n\
    \    } else {\n        \"NO\".to_string()\n    }", "    let (left, right) = (interval1.0,\
    \ interval1.1);\n    let (other_left, other_right) = (interval2.0, interval2.1);\n\
    \    let start = std::cmp::max(left, other_left);\n    let end = std::cmp::min(right,\
    \ other_right);\n    if start > end {\n        return \"NO\".to_string();\n  \
    \  }\n    if is_prime(end - start + 1) {\n        return \"YES\".to_string();\n\
    \    }\n    \"NO\".to_string()", "    let inter = (std::cmp::max(interval1.0,\
    \ interval2.0), std::cmp::min(interval1.1, interval2.1));\n    if inter.0 > inter.1\
    \ {\n        \"NO\".to_string()\n    } else {\n        let len = inter.1 - inter.0\
    \ + 1;\n        if len < 2 {\n            \"NO\".to_string()\n        } else {\n\
    \            if len == 2 {\n                \"YES\".to_string()\n            }\
    \ else {\n                let mut i = 2;\n                while i * i <= len {\n\
    \                    if len % i == 0 {\n                        return \"NO\"\
    .to_string();\n                    }\n                    i += 1;\n          \
    \      }\n                \"YES\".to_string()\n            }\n        }\n    }",
  "    if interval1.0 > interval2.1 || interval2.0 > interval1.1 {\n        return\
    \ \"NO\".to_string();\n    }\n    let x = isize::max(interval1.0, interval2.0);\n\
    \    let y = isize::min(interval1.1, interval2.1);\n    let len = y - x + 1;\n\
    \    if len > 2 && (len % 2 == 0 || len % 3 == 0 || len % 5 == 0 || len % 7 ==\
    \ 0) {\n        return \"NO\".to_string();\n    }\n    \"YES\".to_string()", " \
    \   let (i1_start, i1_end) = interval1;\n    let (i2_start, i2_end) = interval2;\n\
    \    if i1_end < i2_start || i2_end < i1_start {\n        return \"NO\".to_string();\n\
    \    }\n    let (start, end) = (cmp::max(i1_start, i2_start), cmp::min(i1_end,\
    \ i2_end));\n    let mut acc = start;\n    for i in start + 1..end {\n       \
    \ acc = acc.gcd(i);\n    }\n    if acc == 1 {\n        \"YES\".to_string()\n \
    \   } else {\n        \"NO\".to_string()\n    }", "    if interval1.0 >= interval2.1\
    \ || interval2.0 >= interval1.1 {\n        return \"NO\".to_string();\n    }\n\
    \    let start = if interval1.0 > interval2.0 { interval1.0 } else { interval2.0\
    \ };\n    let end = if interval1.1 < interval2.1 { interval1.1 } else { interval2.1\
    \ };\n    let mut is_prime = true;\n    let mut iterator = (start..end).map(|i|\
    \ (i - start + 1) as usize);\n    while is_prime && iterator.next().unwrap() >\
    \ 1 {\n        is_prime = iterator.clone().take_while(|n| *n % iterator.next().unwrap()\
    \ != 0).count() == 0;\n    }\n    if is_prime { \"YES\".to_string() } else { \"\
    NO\".to_string() }", "    let (a, b) = interval1;\n    let (c, d) = interval2;\n\
    \    let upper = a.max(c);\n    let lower = b.min(d);\n    if lower < upper {\n\
    \        return \"NO\".to_string();\n    }\n    let range = (lower - upper + 1)\
    \ as usize;\n    if range == 1 {\n        return \"NO\".to_string();\n    }\n\
    \    if range % 2 == 0 {\n        return \"NO\".to_string();\n    }\n    if (2..range/2).any(|x|\
    \ range % x == 0) {\n        return \"NO\".to_string();\n    }\n    \"YES\".to_string()",
  "    let (i1, i2) = (interval1.0, interval1.1);\n    let (j1, j2) = (interval2.0,\
    \ interval2.1);\n    if i1 > j2 || j1 > i2 {\n        return \"NO\".to_string();\n\
    \    }\n    let (mut start, mut end) = (0, 0);\n    if i1 > j1 {\n        start\
    \ = i1;\n    } else {\n        start = j1;\n    }\n    if i2 < j2 {\n        end\
    \ = i2;\n    } else {\n        end = j2;\n    }\n    let length = (end - start)\
    \ + 1;\n    if length == 2 {\n        return \"YES\".to_string();\n    }\n   \
    \ for i in 2..length {\n        if length % i == 0 {\n            return \"NO\"\
    .to_string();\n        }\n    }\n    \"YES\".to_string()", "    let mut result\
    \ = \"NO\";\n    let (start1, end1) = interval1;\n    let (start2, end2) = interval2;\n\
    \    if start1 < start2 {\n        if end1 >= start2 {\n            if end1 <=\
    \ end2 {\n                result = primes::is_prime(end1 - start2 + 1).to_string().to_uppercase();\n\
    \            } else {\n                result = primes::is_prime(end2 - start2\
    \ + 1).to_string().to_uppercase();\n            }\n        }\n    } else if start2\
    \ < start1 {\n        if end2 >= start1 {\n            if end2 <= end1 {\n   \
    \             result = primes::is_prime(end2 - start1 + 1).to_string().to_uppercase();\n\
    \            } else {\n                result = primes::is_prime(end1 - start1\
    \ + 1).to_string().to_uppercase();\n            }\n        }\n    } else {\n \
    \       if end1 <= end2 {\n            result = primes::is_prime(end1 - start1\
    \ + 1).to_string().to_uppercase();\n        } else {\n            result = primes::is_prime(end2\
    \ - start2 + 1).to_string().to_uppercase();\n        }\n    }\n    result.to_string()",
  "    let mut inter: Option<(isize, isize)> = None;\n    if interval1.0 <= interval2.0\
    \ && interval2.0 <= interval1.1 {\n        inter = Some((interval2.0, interval1.1));\n\
    \    } else if interval2.0 <= interval1.0 && interval1.0 <= interval2.1 {\n  \
    \      inter = Some((interval1.0, interval2.1));\n    }\n    match inter {\n \
    \       Some((s, e)) => if (e - s).is_prime() {\n            \"YES\".to_string()\n\
    \        } else {\n            \"NO\".to_string()\n        },\n        None =>\
    \ \"NO\".to_string(),\n    }", "  let (mut left, mut right) = (interval1.0, interval1.1);\n\
    \  if left > right { std::mem::swap(&mut left, &mut right); }\n  let (mut left2,\
    \ mut right2) = (interval2.0, interval2.1);\n  if left2 > right2 { std::mem::swap(&mut\
    \ left2, &mut right2); }\n  let (mut min, mut max) = (left.max(left2), right.min(right2));\n\
    \  if min > max { \"NO\".to_string() }\n  else {\n    if min == 1 { min += 1;\
    \ }\n    let x = max - min + 1;\n    if x == 2 { \"YES\".to_string() }\n    else\
    \ {\n      let x = (x as f64).sqrt() as isize;\n      let mut b = true;\n    \
    \  for i in 2..x+1 {\n        if min % i == 0 { b = false; break; }\n      }\n\
    \      if b { \"YES\".to_string() }\n      else { \"NO\".to_string() }\n    }\n\
    \  }", "    match (interval1, interval2) {\n        ((start1, end1), (start2,\
    \ end2)) => {\n            let mut start = start1.max(start2);\n            let\
    \ mut end = end1.min(end2);\n            if start > end {\n                return\
    \ \"NO\".to_string();\n            } else if start == end {\n                end\
    \ += 1;\n            }\n            (start..end).map(|x| x.is_prime()).any(|x|\
    \ x)\n        }\n    }"]
stop_tokens:
- "\n}"
