name: HumanEval_21_rescale_to_unit
language: rs
prompt: "/// Given list of numbers (of at least two elements), apply a linear transform\
  \ to that list,\n/// such that the smallest number will become 0 and the largest\
  \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25,\
  \ 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n"
tests: "}\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
  \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
  \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
  \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]), vec![0.25,\
  \ 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0, 15.0, 13.0,\
  \ 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
completions: ["    let (min, max) = (numbers.iter().min().unwrap(), numbers.iter().max().unwrap());\n\
    \    return numbers.iter().map(|x| (x - min) / (max - min)).collect();", "   \
    \ let (mut smallest, mut largest) = (numbers[0], numbers[0]);\n    for item in\
    \ numbers.iter() {\n        if *item < smallest {\n            smallest = *item;\n\
    \        }\n        if *item > largest {\n            largest = *item;\n     \
    \   }\n    }\n    let range = largest - smallest;\n    let mut new_list = vec![];\n\
    \    for item in numbers.iter() {\n        new_list.push((*item - smallest) /\
    \ range);\n    }\n    new_list", "    if numbers.len() < 2 {\n        return numbers;\n\
    \    }\n\n    let mut numbers = numbers;\n    numbers.sort_by(|a, b| a.partial_cmp(b).unwrap());\n\
    \n    let min = numbers[0];\n    let max = numbers[numbers.len() - 1];\n\n   \
    \ numbers.iter().map(|&x| (x - min) / (max - min)).collect()", "    if numbers.len()\
    \ < 2 {\n        panic!(\"Cannot rescale vectors of size < 2\");\n    }\n    let\
    \ min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    if min == max {\n        // all numbers are equal, return a vector of equal\
    \ length with all ones\n        vec![1.0; numbers.len()]\n    } else {\n     \
    \   numbers.iter().map(|n| (n - min) / (max - min)).collect()\n    }", "    if\
    \ numbers.len() < 2 {\n        panic!(\"rescale_to_unit() received list of numbers\
    \ with less than 2 numbers\");\n    }\n    let minimum = numbers.iter().min().unwrap();\n\
    \    let maximum = numbers.iter().max().unwrap();\n    if *minimum == *maximum\
    \ {\n        panic!(\"rescale_to_unit() received list of numbers with same value\"\
    );\n    }\n    let factor = 1.0 / (*maximum - *minimum);\n    numbers.iter().map(|x|\
    \ (*x - *minimum) * factor).collect()", "    let min_number = numbers.iter().min().unwrap();\n\
    \    let max_number = numbers.iter().max().unwrap();\n    let max_minus_min =\
    \ max_number - min_number;\n    let mut transformed_numbers = Vec::new();\n  \
    \  for number in numbers {\n        transformed_numbers.push((number - min_number)\
    \ / max_minus_min);\n    }\n    transformed_numbers", "    let max = numbers.iter().max().unwrap();\n\
    \    let min = numbers.iter().min().unwrap();\n    numbers.iter().map(|number|\
    \ (*number - min) / (max - min)).collect()", "    let largest = numbers.iter().max().unwrap();\n\
    \    let smallest = numbers.iter().min().unwrap();\n    numbers.iter().map(|&x|\
    \ (x - smallest) / (largest - smallest)).collect()", "    // error handling?\n\
    \    let min = numbers.iter().cloned().fold(f64::INFINITY, f64::min);\n    let\
    \ max = numbers.iter().cloned().fold(f64::NEG_INFINITY, f64::max);\n    let range\
    \ = max - min;\n    numbers.iter().map(|x| (x - min) / range).collect()", "  \
    \  let min = numbers.iter().cloned().fold(f64::MAX, f64::min);\n    let max =\
    \ numbers.iter().cloned().fold(f64::MIN, f64::max);\n    let range = max - min;\n\
    \    numbers.iter().map(|x| (x - min) / range).collect()", "    let (mut min,\
    \ mut max) = (numbers[0], numbers[0]);\n    for x in numbers.iter() {\n      \
    \  if *x < min {\n            min = *x;\n        }\n        if *x > max {\n  \
    \          max = *x;\n        }\n    }\n    let mut res = vec![];\n    for x in\
    \ numbers.iter() {\n        res.push((*x - min) / (max - min));\n    }\n    res",
  "    let min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    let delta = max - min;\n    numbers.iter().map(|x| (x - min) / delta).collect()",
  "    let x_min = numbers.iter().min().unwrap();\n    let x_max = numbers.iter().max().unwrap();\n\
    \    let x_range = x_max - x_min;\n    let mut output = Vec::with_capacity(numbers.len());\n\
    \    output.extend(numbers.iter().map(|x| (x - x_min) / x_range));\n    output",
  "    let min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    let linear_scale = 1.0 / (max - min);\n    numbers.iter().map(|n| linear_scale\
    \ * (n - min)).collect()", "    let max_val = numbers.iter().max().unwrap();\n\
    \    let min_val = numbers.iter().min().unwrap();\n    let scale = 1.0 / (max_val\
    \ - min_val);\n    numbers.iter().map(|x| scale * (x - min_val)).collect()", " \
    \   let max_value = numbers.iter().max().unwrap();\n    let min_value = numbers.iter().min().unwrap();\n\
    \    let difference = max_value - min_value;\n    numbers.iter().map(|x| (*x -\
    \ min_value) / difference).collect()", "    // Get minimum and maximum\n    let\
    \ min_val = numbers.iter().cloned().fold(std::f64::MAX, f64::min);\n    let max_val\
    \ = numbers.iter().cloned().fold(std::f64::MIN, f64::max);\n\n    // Apply linear\
    \ transform\n    numbers\n        .iter()\n        .map(|&num| (num - min_val)\
    \ / (max_val - min_val))\n        .collect()", "    let smallest = numbers.iter().min().unwrap();\n\
    \    let largest = numbers.iter().max().unwrap();\n    let diff = largest - smallest;\n\
    \    numbers.iter().map(|&n| (n - smallest) / diff).collect()", "    let x_min\
    \ = numbers.iter().min().unwrap();\n    let x_max = numbers.iter().max().unwrap();\n\
    \    let mut result = Vec::new();\n    for number in numbers {\n        result.push((number\
    \ - x_min) / (x_max - x_min));\n    }\n    result", "    let min = numbers.iter().cloned().fold(f64::INFINITY,\
    \ f64::min);\n    let max = numbers.iter().cloned().fold(f64::NEG_INFINITY, f64::max);\n\
    \    let delta = max - min;\n    return numbers.iter().map(|x| (x - min) / delta).collect();"]
stop_tokens:
- "\n}"
