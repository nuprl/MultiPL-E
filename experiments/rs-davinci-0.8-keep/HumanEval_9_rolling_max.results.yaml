language: rs
name: HumanEval_9_rolling_max
results:
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut output = Vec::with_capacity(numbers.len());\n \
    \   output.push(numbers[0]);\n    let mut current_max = numbers[0];\n    for i\
    \ in 1..numbers.len() {\n        if numbers[i] > current_max {\n            current_max\
    \ = numbers[i];\n        }\n        output.push(current_max);\n    }\n    output\n\
    }\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmp7ja3nida.rs:7:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823095
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    use std::cmp::max;\n    let mut result = Vec::with_capacity(numbers.len());\n\
    \    result.push(numbers[0]);\n    for i in 1..numbers.len() {\n        result.push(max(result[i\
    \ - 1], numbers[i]));\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpfiiyfedc.rs:8:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823095
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut res = Vec::new();\n    let mut max_current = numbers[0];\n\
    \    res.push(max_current);\n    for index in 1..numbers.len() {\n        if numbers[index]\
    \ > max_current {\n            max_current = numbers[index];\n        }\n    \
    \    res.push(max_current);\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpegipj4_d.rs:7:27

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823095
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    // TODO: implement rolling_max\n    vec![]\n}\n\nfn main()\
    \ {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[1, 2, 3, 4]`', /tmp/tmpu1wsla5l.rs:13:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823095
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut rolling_max = Vec::with_capacity(numbers.len());\n\
    \    let mut max = std::isize::MIN;\n    for n in numbers {\n        if n > max\
    \ {\n            max = n;\n        }\n        rolling_max.push(max);\n    }\n\
    \    rolling_max\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823095
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::with_capacity(numbers.len());\n \
    \   let mut max = numbers[0];\n    result.push(max);\n    for i in 1..numbers.len()\
    \ {\n        if numbers[i] > max {\n            max = numbers[i];\n        }\n\
    \        result.push(max);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpiujb_4f8.rs:7:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823095
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max_so_far = -1;\n    let mut result = Vec::new();\n\
    \    for x in numbers {\n        if x > max_so_far {\n            max_so_far =\
    \ x;\n        }\n        result.push(max_so_far);\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823095
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max = std::isize::MIN;\n\
    \    for n in numbers {\n        if n > max {\n            max = n;\n        }\n\
    \        result.push(max);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823095
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut current_max =\
    \ isize::min_value();\n    for number in numbers {\n        if number > current_max\
    \ {\n            current_max = number;\n        }\n        result.push(current_max);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823095
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max_until_now = None;\n    let mut result = Vec::new();\n\
    \    for &number in numbers.iter() {\n        if let Some(mut previous_max) =\
    \ max_until_now {\n            if number > previous_max {\n                previous_max\
    \ = number;\n            }\n            result.push(previous_max);\n        }\
    \ else {\n            result.push(number);\n        }\n        max_until_now =\
    \ Some(result.last().unwrap().clone());\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823095
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut current_max =\
    \ std::isize::MIN;\n    for i in numbers {\n        current_max = current_max.max(i);\n\
    \        result.push(current_max);\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823095
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max = isize::min_value();\n    let mut max_vec\
    \ = Vec::new();\n    for n in numbers {\n        max = n.max(max);\n        max_vec.push(max);\n\
    \    }\n    max_vec\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823095
- exit_code: 1
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    numbers\n        .iter()\n        .scan(0, |state, &x|\
    \ {\n            *state = max(*state, x);\n            Some(*state)\n        })\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `max` in this scope\n --> /tmp/tmpr8wju06_.rs:9:22\n\
    \  |\n9 |             *state = max(*state, x);\n  |                      ^^^ not\
    \ found in this scope\n  |\nhelp: consider importing this function\n  |\n1 | use\
    \ std::cmp::max;\n  |\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659823095
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::with_capacity(numbers.len());\n \
    \   let mut max = numbers[0];\n    result.push(max);\n    for num in numbers[1..].iter()\
    \ {\n        max = std::cmp::max(max, *num);\n        result.push(max);\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmp5gqepb8_.rs:7:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823095
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut rolling_max = Vec::new();\n    let mut max = numbers[0];\n\
    \    rolling_max.push(max);\n    for i in 1..numbers.len() {\n        max = max.max(numbers[i]);\n\
    \        rolling_max.push(max);\n    }\n    rolling_max\n}\n\nfn main() {\n  \
    \  let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpw2azlcqi.rs:7:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823095
- exit_code: 1
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut rolling_max = Vec::new();\n    for number in numbers\
    \ {\n        rolling_max.push(rolling_max.last().map_or(number, |v| v.max(number)));\n\
    \    }\n    rolling_max\n}\n\nfn main() {\n    let candidate = rolling_max;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4,\
    \ 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100,\
    \ 100]);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `&T`\n --> /tmp/tmpgaw17q1j.rs:8:61\n\
    \  |\n8 |         rolling_max.push(rolling_max.last().map_or(number, |v| v.max(number)));\n\
    \  |                                                             ^ consider giving\
    \ this closure parameter the explicit type `&T`, where the type parameter `T`\
    \ is specified\n  |\n  = note: type must be known at this point\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0282`.\n"
  stdout: ''
  timestamp: 1659823095
- exit_code: 0
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    // From left to right, find the maximum for each element's\
    \ position. We\n    // will use a stack (FILO) as a way to store current maximums.\n\
    \    let mut max_stack: Vec<isize> = Vec::new();\n    let mut result: Vec<isize>\
    \ = Vec::new();\n\n    for n in numbers {\n        // Since we are going from\
    \ left to right, we will use the stack as a\n        // storage for the current\
    \ maximum found for each position until now.\n        // The stack will keep track\
    \ of values in descending order, since\n        // smaller values will eventually\
    \ be discarded.\n        while !max_stack.is_empty() && n > max_stack[max_stack.len()\
    \ - 1] {\n            max_stack.pop();\n        }\n\n        max_stack.push(n);\n\
    \        result.push(max_stack[0]);\n    }\n\n    result\n}\n\nfn main() {\n \
    \   let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823095
- exit_code: 1
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    if numbers.is_empty() {\n        return vec![];\n    }\n\
    \n    let mut max = numbers[0];\n    let mut result = vec![max];\n\n    for num\
    \ in numbers.iter().skip(1) {\n        max = num.max(max);\n        result.push(max);\n\
    \    }\n\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n   \
    \ assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4,\
    \ 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100,\
    \ 100]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpouf_13vv.rs:14:23\n   |\n\
    14 |         max = num.max(max);\n   |                       ^^^\n   |       \
    \                |\n   |                       expected `&isize`, found `isize`\n\
    \   |                       help: consider borrowing here: `&max`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpouf_13vv.rs:14:15\n   |\n14 |         max =\
    \ num.max(max);\n   |               ^^^^^^^^^^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n14 |         max = *num.max(max);\n\
    \   |               +\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659823095
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::with_capacity(numbers.len());\n \
    \   let mut maximum_so_far = numbers[0];\n    result.push(maximum_so_far);\n \
    \   for i in 1..numbers.len() {\n        maximum_so_far = maximum_so_far.max(numbers[i]);\n\
    \        result.push(maximum_so_far);\n    }\n    result\n}\n\nfn main() {\n \
    \   let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpn6mw9dkj.rs:7:30

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823095
- exit_code: 101
  program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut rolling_max: Vec<isize> = Vec::new();\n    let\
    \ mut max_so_far = numbers[0];\n    rolling_max.push(max_so_far);\n    for &number\
    \ in numbers.iter().skip(1) {\n        if number > max_so_far {\n            max_so_far\
    \ = number;\n        }\n        rolling_max.push(max_so_far);\n    }\n    rolling_max\n\
    }\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmppuwjg2e2.rs:7:26

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823095
