name: HumanEval_71_triangle_area
language: rs
prompt: "/// Given the lengths of the three sides of a triangle. Return the area of\n\
  /// the triangle rounded to 2 decimal points if the three sides form a valid triangle.\
  \ \n/// Otherwise return -1\n/// Three sides make a valid triangle when the sum\
  \ of any two sides is greater \n/// than the third side.\n/// Example:\n/// triangle_area(3,\
  \ 4, 5) == 6.00\n/// triangle_area(1, 2, 10) == -1\nfn triangle_area(a: isize, b:\
  \ isize, c: isize) -> f64 {\n"
tests: "}\n\nfn main() {\n    let candidate = triangle_area;\n    assert_eq!(candidate(3,\
  \ 4, 5), 6.0);\n    assert_eq!(candidate(1, 2, 10), -1.0);\n    assert_eq!(candidate(4,\
  \ 8, 5), 8.18);\n    assert_eq!(candidate(2, 2, 2), 1.73);\n    assert_eq!(candidate(1,\
  \ 2, 3), -1.0);\n    assert_eq!(candidate(10, 5, 7), 16.25);\n    assert_eq!(candidate(2,\
  \ 6, 3), -1.0);\n    assert_eq!(candidate(1, 1, 1), 0.43);\n    assert_eq!(candidate(2,\
  \ 2, 10), -1.0);\n}\n"
completions: ["    let p = (a as f64 + b as f64 + c as f64) / 2.0;\n    let s = p\
    \ * (p - a as f64) * (p - b as f64) * (p - c as f64);\n    if s <= 0.0 { -1.0\
    \ } else { s.sqrt() }", "    match (a, b, c) {\n        (x, y, z) if x + y > z\
    \ && x + z > y && y + z > x => {\n            let s = (a + b + c) as f64 / 2.0;\n\
    \            (s * (s - a as f64) * (s - b as f64) * (s - c as f64)).sqrt()\n \
    \       },\n        _ => -1.0\n    }", "    if (a+b > c) && (a+c > b) && (b+c\
    \ > a) {\n        let p = (a+b+c) as f64 / 2.0;\n        ((p*(p-a as f64)*(p-b\
    \ as f64)*(p-c as f64)).sqrt() * 100.0).round() / 100.0\n    } else {\n      \
    \  -1.0\n    }", "    if a > 0 && b > 0 && c > 0 && a + b > c && a + c > b &&\
    \ b + c > a {\n        let s = (a + b + c) as f64 / 2.0;\n        (s * (s - a\
    \ as f64) * (s - b as f64) * (s - c as f64)).sqrt()\n    } else {\n        -1.0\n\
    \    }", "    let mut sides = vec![a, b, c];\n    sides.sort();\n    let a = sides[0]\
    \ as f64;\n    let b = sides[1] as f64;\n    let c = sides[2] as f64;\n    if\
    \ a + b > c {\n        let s = (a + b + c) / 2.0;\n        (s * (s - a) * (s -\
    \ b) * (s - c)).sqrt()\n    } else {\n        -1.0\n    }", "  let a_d = a as\
    \ f64;\n  let b_d = b as f64;\n  let c_d = c as f64;\n  let s = (a_d + b_d + c_d)\
    \ / 2.0;\n  let area = (s * (s - a_d) * (s - b_d) * (s - c_d)).sqrt();\n  if a\
    \ + b > c && a + c > b && b + c > a {\n    area\n  } else {\n    -1.0\n  }", " \
    \   let half_perimeter = (a + b + c) as f64 / 2.0;\n    if half_perimeter <= 0.0\
    \ {\n        return -1.0;\n    }\n    half_perimeter * (half_perimeter - a as\
    \ f64) * (half_perimeter - b as f64) *\n        (half_perimeter - c as f64)",
  "  let area = (a + b + c) as f64 / 2.0;\n  let radius = area * (area - a as f64)\
    \ * (area - b as f64) * (area - c as f64);\n  if radius > 0.0 {\n    (4.0 * radius.sqrt()\
    \ / 3.0).round() / 100.0\n  } else {\n    -1.0\n  }", "    let a = a as f64;\n\
    \    let b = b as f64;\n    let c = c as f64;\n    let s = (a + b + c) / 2.0;\n\
    \    if a + b > c && a + c > b && b + c > a {\n        (s * (s - a) * (s - b)\
    \ * (s - c)).sqrt()\n    } else {\n        -1.0\n    }", "    let mut s = (a +\
    \ b + c) as f64 / 2.0;\n    if s < 0.0 {\n        return -1.0;\n    }\n    s =\
    \ (s * (s - a as f64) * (s - b as f64) * (s - c as f64)).sqrt();\n    if s.is_nan()\
    \ {\n        return -1.0;\n    }\n    s", "  if (a+b) > c && (a+c) > b && (b+c)\
    \ > a {\n    (f64::from(a) * f64::from(b) * f64::from(c)) as f64\n  } else {\n\
    \    -1.0\n  }", "    if a + b > c && a + c > b && b + c > a {\n        let p\
    \ = (a + b + c) as f64 / 2.0;\n        (p * (p - a as f64) * (p - b as f64) *\
    \ (p - c as f64)).sqrt()\n    } else {\n        -1.0\n    }", "    if a+b > c\
    \ && a+c > b && b+c > a {\n        // http://en.wikipedia.org/wiki/Heron%27s_formula\n\
    \        let s = (a+b+c) as f64 / 2f64;\n        return (s*(s-a as f64)*(s-b as\
    \ f64)*(s-c as f64)).sqrt();\n    }\n    -1f64", "    let mut res = -1.0;\n  \
    \  let mut xs = vec![a, b, c];\n    xs.sort();\n    if xs[0] + xs[1] > xs[2] {\n\
    \        let p = (a + b + c) as f64 / 2.0;\n        res = (p * (p - a as f64)\
    \ * (p - b as f64) * (p - c as f64)).sqrt();\n    }\n    res", "    let l: Vec<isize>\
    \ = vec![a, b, c];\n    l.iter().sum::<isize>() - l.iter().max().unwrap() > *l.iter().max().unwrap()\
    \ ? \n        (a * b) as f64 / 2f64:\n        -1f64", "    if a + b > c && a +\
    \ c > b && b + c > a {\n        let s = (a + b + c) as f64 / 2.0;\n        (s\
    \ * (s - a as f64) * (s - b as f64) * (s - c as f64)).sqrt()\n    } else {\n \
    \       -1.0\n    }", "    let s = (a + b + c) as f64 / 2.0;\n    let area = (s\
    \ * (s - a as f64) * (s - b as f64) * (s - c as f64)).sqrt();\n    if area.is_nan()\
    \ {\n        -1.0\n    } else {\n        area\n    }", "    let mut sides = vec![a,\
    \ b, c];\n    sides.sort();\n    if sides[0] + sides[1] > sides[2] {\n       \
    \ let s = (sides[0] + sides[1] + sides[2]) as f64 / 2.0;\n        (s * (s - sides[0]\
    \ as f64) * (s - sides[1] as f64) * (s - sides[2] as f64)).sqrt()\n    } else\
    \ {\n        -1.0\n    }", "    let perimeter = a + b + c;\n    if a + b > c &&\
    \ a + c > b && b + c > a {\n        let s = (perimeter as f64) / 2.0;\n      \
    \  return ((s - a as f64) * (s - b as f64) * (s - c as f64)).sqrt();\n    }\n\
    \    -1.0", "    let x: isize = a + b;\n    let y: isize = a + c;\n    let z:\
    \ isize = b + c;\n    if x > c && y > b && z > a {\n        let s: f64 = (a +\
    \ b + c) as f64 / 2.0;\n        let s = s * (s - a as f64) * (s - b as f64) *\
    \ (s - c as f64);\n        if s > 0.0 {\n            return s.sqrt();\n      \
    \  }\n    }\n    -1.0"]
stop_tokens:
- "\n}"
