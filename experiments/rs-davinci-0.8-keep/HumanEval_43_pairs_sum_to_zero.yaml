name: HumanEval_43_pairs_sum_to_zero
language: rs
prompt: "/// pairs_sum_to_zero takes a list of integers as an input.\n/// it returns\
  \ True if there are two distinct elements in the list that\n/// sum to zero, and\
  \ False otherwise.\n/// >>> pairs_sum_to_zero([1, 3, 5, 0])\n/// False\n/// >>>\
  \ pairs_sum_to_zero([1, 3, -2, 1])\n/// False\n/// >>> pairs_sum_to_zero([1, 2,\
  \ 3, 7])\n/// False\n/// >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n/// True\n\
  /// >>> pairs_sum_to_zero([1])\n/// False\nfn pairs_sum_to_zero(l: Vec<isize>) ->\
  \ bool {\n"
tests: "}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
  \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n   \
  \ assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2,\
  \ 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3,\
  \ 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]),\
  \ true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3,\
  \ 9, -1, 4, 2, 31]), false);\n}\n"
completions: ["    for x in l.iter() {\n        for y in l.iter() {\n            if\
    \ *x != *y && *x + *y == 0 {\n                return true;\n            }\n  \
    \      }\n    }\n    false", "    // TODO: write the rest of this function\n \
    \   false", "    for i in l.iter() {\n        for j in l.iter() {\n          \
    \  if i != j && i + j == 0 {\n                return true;\n            }\n  \
    \      }\n    }\n    false", "    let mut s = l.clone();\n    s.sort();\n    let\
    \ n = s.len();\n    let mut i = 0;\n    let mut j = n - 1;\n    while i < j {\n\
    \        let sum = s[i] + s[j];\n        if sum == 0 {\n            return true;\n\
    \        } else if sum < 0 {\n            i += 1;\n        } else {\n        \
    \    j -= 1;\n        }\n    }\n    false", '    false', "    if l.len() == 0\
    \ {\n        return false;\n    }\n    let mut a: Vec<isize> = l.iter().map(|&x|\
    \ x).collect();\n    a.sort();\n    let mut i = 0;\n    let mut j = a.len() -\
    \ 1;\n    while i < j {\n        if a[i] + a[j] == 0 {\n            return true;\n\
    \        } else if a[i] + a[j] < 0 {\n            i += 1;\n        } else {\n\
    \            j -= 1;\n        }\n    }\n    return false;", "    let mut set:\
    \ HashSet<isize> = HashSet::new();\n    for x in l {\n        if set.contains(&(-x))\
    \ {\n            return true;\n        }\n        set.insert(x);\n    }\n    false",
  "    if l.len() <= 1 {\n        return false;\n    }\n\n    let mut s = HashSet::new();\n\
    \    for i in l {\n        if s.contains(&(-i)) {\n            return true;\n\
    \        }\n        s.insert(i);\n    }\n    false", "    for i in l.iter() {\n\
    \        for j in l.iter() {\n            if i != j && i + j == 0 {\n        \
    \        return true;\n            }\n        }\n    }\n    false", "    let n\
    \ = l.len();\n    let mut i = 0;\n    let mut j = 0;\n    let mut result = false;\n\
    \    while i < n - 1 {\n        j = i + 1;\n        while j < n {\n          \
    \  if l[i] + l[j] == 0 {\n                result = true;\n            }\n    \
    \        j += 1;\n        }\n        i += 1;\n    }\n    result", '    unimplemented!()',
  "    // write your code here\n    false", "    // Implement me!\n    let mut copy_l\
    \ = l.clone();\n    copy_l.sort();\n    let mut first_index = 0;\n    let mut\
    \ second_index = 1;\n    let mut counter = 0;\n    while counter < copy_l.len()\
    \ {\n        if copy_l[first_index] + copy_l[second_index] == 0 {\n          \
    \  return true;\n        }\n        first_index += 1;\n        second_index +=\
    \ 1;\n        counter += 1;\n    }\n    false", "  // TODO\n  false", '    return
    true;', "  let mut l = l;\n  let mut l_size = l.len();\n  let mut l_size_old =\
    \ l_size + 1;\n  while l_size != l_size_old {\n    l_size_old = l_size;\n    l.sort();\n\
    \    let mut i = 0;\n    let mut j = 1;\n    let mut break_ = false;\n    while\
    \ i < l_size - 1 && !break_ {\n      j = i + 1;\n      while j < l_size && !break_\
    \ {\n        if l[i] + l[j] == 0 {\n          break_ = true;\n        }\n    \
    \    j += 1;\n      }\n      i += 1;\n    }\n    if break_ {\n      l.remove(j);\n\
    \      l.remove(i);\n      l_size -= 2;\n    }\n  }\n  l_size == 0", "    for\
    \ i in l.iter() {\n        for j in l.iter() {\n            if i != j && i + j\
    \ == 0 {\n                return true;\n            }\n        }\n    }\n    false",
  "    // TODO: Implement me!\n    false", "    if l.len() == 0 {\n        return\
    \ false;\n    }\n\n    for i in 0..l.len() - 1 {\n        for j in i + 1..l.len()\
    \ {\n            if l[i] + l[j] == 0 {\n                return true;\n       \
    \     }\n        }\n    }\n\n    false", '    unimplemented!()']
stop_tokens:
- "\n}"
