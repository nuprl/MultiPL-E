name: HumanEval_111_histogram
language: rs
results:
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut histogram: HashMap<String, isize> = HashMap::new();\n\
    \    let mut most_occurences: isize = 0;\n    let mut same_occurences: Vec<String>\
    \ = Vec::new();\n\n    for word in test.split_whitespace() {\n        let word_in_hashmap\
    \ = histogram.get_mut(word);\n        if word_in_hashmap == None {\n         \
    \   histogram.insert(word.to_string(), 1);\n        } else {\n            let\
    \ count = word_in_hashmap.unwrap();\n            *count += 1;\n        }\n   \
    \ }\n\n    for (word, count) in &histogram {\n        if *count == most_occurences\
    \ {\n            same_occurences.push(word.to_string());\n        } else if *count\
    \ > most_occurences {\n            most_occurences = *count;\n            same_occurences\
    \ = vec![word.to_string()];\n        }\n    }\n\n    let mut result: HashMap<String,\
    \ isize> = HashMap::new();\n    for word in same_occurences {\n        result.insert(word,\
    \ most_occurences);\n    }\n\n    result\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut s = test.split_whitespace();\n    let mut hm: HashMap<String,\
    \ isize> = HashMap::new();\n    let mut max = 0;\n    let mut max_vec: Vec<String>\
    \ = Vec::new();\n    while let Some(ch) = s.next() {\n        match hm.get(ch)\
    \ {\n            Some(v) => {\n                if v + 1 > max {\n            \
    \        max = v + 1;\n                    max_vec.clear();\n                \
    \    max_vec.push(ch.to_string());\n                } else if v + 1 == max {\n\
    \                    max_vec.push(ch.to_string());\n                }\n      \
    \          hm.insert(ch.to_string(), v + 1);\n            }\n            None\
    \ => {\n                hm.insert(ch.to_string(), 1);\n            }\n       \
    \ }\n    }\n    let mut result: HashMap<String, isize> = HashMap::new();\n   \
    \ for ch in max_vec {\n        result.insert(ch, max);\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `{}`,\n right: `{\"b\": 1, \"d\": 1, \"a\": 1, \"c\": 1, \"g\": 1}`', /tmp/tmpeztfjar5.rs:45:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut result: HashMap<String, isize> = HashMap::new();\n   \
    \ let mut max_count: isize = 0;\n    let mut max_letters: Vec<String> = Vec::new();\n\
    \n    for c in test.split(\" \") {\n        let c_str = c.to_string();\n     \
    \   let count = result.entry(c_str).or_insert(0);\n        *count += 1;\n\n  \
    \      if *count > max_count {\n            max_count = *count;\n            max_letters\
    \ = vec![c_str];\n        } else if *count == max_count {\n            max_letters.push(c_str);\n\
    \        }\n    }\n\n    let mut ret: HashMap<String, isize> = HashMap::new();\n\
    \    for c in max_letters {\n        ret.insert(c, max_count);\n    }\n\n    ret\n\
    }\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `c_str`\n  --> /tmp/tmpu61ahi4b.rs:24:32\n\
    \   |\n18 |         let c_str = c.to_string();\n   |             ----- move occurs\
    \ because `c_str` has type `String`, which does not implement the `Copy` trait\n\
    19 |         let count = result.entry(c_str).or_insert(0);\n   |             \
    \                     ----- value moved here\n...\n24 |             max_letters\
    \ = vec![c_str];\n   |                                ^^^^^ value used here after\
    \ move\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let letters: Vec<&str> = test.split_whitespace().collect();\n\
    \    let mut ret: HashMap<String, isize> = HashMap::new();\n    let mut counts:\
    \ HashMap<String, isize> = HashMap::new();\n    for letter in letters {\n    \
    \    if let Some(count) = counts.get_mut(letter) {\n            *count += 1;\n\
    \        } else {\n            counts.insert(letter.to_string(), 1);\n       \
    \ }\n    }\n    let max_value = counts.values().cloned().max().unwrap();\n   \
    \ for (key, value) in counts {\n        if value == max_value {\n            ret.insert(key,\
    \ value);\n        }\n    }\n    ret\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Option::unwrap()` on a `None` value',\
    \ /tmp/tmp8rmtj5y8.rs:23:52\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut occurrences: HashMap<String, isize> = HashMap::new();\n\
    \    for character in test.split(\" \") {\n        *occurrences.entry(character.to_string()).or_insert(0)\
    \ += 1;\n    }\n    let mut most_repetition = 1;\n    for (_character, repetition)\
    \ in occurrences.iter() {\n        if *repetition > most_repetition {\n      \
    \      most_repetition = *repetition;\n        }\n    }\n    occurrences.retain(|_k,\
    \ v| *v == most_repetition);\n    occurrences\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `{\"\": 1}`,\n right: `{}`', /tmp/tmpkwljccxj.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut frequencies = HashMap::new();\n    let words = test.split_whitespace();\n\
    \    for w in words {\n        let n = frequencies.entry(w.to_string()).or_insert(0);\n\
    \        *n += 1;\n    }\n    let mut max = 0;\n    for (_, count) in &frequencies\
    \ {\n        if *count > max {\n            max = *count;\n        }\n    }\n\
    \    frequencies.retain(|_, value| *value == max);\n    frequencies\n}\n\nfn main()\
    \ {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut res: HashMap<String, isize> = HashMap::new();\n    let\
    \ mut count: HashMap<String, isize> = HashMap::new();\n    let mut words = test.split(\"\
    \ \");\n    let max = match words.clone().map(|x| count.entry(x.to_string()).or_insert(0)).max()\
    \ {\n        Some(n) => *n,\n        None => 0,\n    };\n    for key in words\
    \ {\n        let v = count.entry(key.to_string()).or_insert(0);\n        if *v\
    \ == max {\n            res.insert(key.to_string(), max);\n        }\n    }\n\
    \    res\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error: captured variable cannot escape `FnMut` closure body\n  --> /tmp/tmp7hxb7bij.rs:16:43\n\
    \   |\n14 |     let mut count: HashMap<String, isize> = HashMap::new();\n   |\
    \         --------- variable defined here\n15 |     let mut words = test.split(\"\
    \ \");\n16 |     let max = match words.clone().map(|x| count.entry(x.to_string()).or_insert(0)).max()\
    \ {\n   |                                         - -----^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |                                         | |\n   |                      \
    \                   | returns a reference to a captured variable which escapes\
    \ the closure body\n   |                                         | variable captured\
    \ here\n   |                                         inferred to be a `FnMut`\
    \ closure\n   |\n   = note: `FnMut` closures only have access to their captured\
    \ variables while they are executing...\n   = note: ...therefore, they cannot\
    \ allow references to captured variables to escape\n\nwarning: variable does not\
    \ need to be mutable\n  --> /tmp/tmp7hxb7bij.rs:15:9\n   |\n15 |     let mut words\
    \ = test.split(\" \");\n   |         ----^^^^^\n   |         |\n   |         help:\
    \ remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]` on by default\n\n\
    error: aborting due to previous error; 1 warning emitted\n\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut map = HashMap::new();\n    let mut max = -1;\n    for\
    \ letter in test.split_whitespace() {\n        let count = map.entry(letter.to_string()).or_insert(0);\n\
    \        *count += 1;\n        if *count > max {\n            max = *count;\n\
    \        }\n    }\n    map.retain(|_, v| *v == max);\n    map\n}\n\nfn main()\
    \ {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut hm: HashMap<String, isize> = HashMap::new();\n    let\
    \ mut max_count: isize = 0;\n    let mut max_count_words: Vec<String> = Vec::new();\n\
    \n    // Iterate through the string and split at each space\n    for word in test.split(\"\
    \ \") {\n        let word_count = hm.entry(word.to_string()).or_insert(0);\n \
    \       // Increment the count for each word\n        *word_count += 1;\n    \
    \    // Get the highest word count so far\n        if max_count < *word_count\
    \ {\n            max_count = *word_count;\n        }\n    }\n\n    // Get all\
    \ the keys with the highest value\n    for (key, value) in hm.iter() {\n     \
    \   if *value == max_count {\n            max_count_words.push(key.to_string());\n\
    \        }\n    }\n\n    // Iterate through the highest count words and set the\
    \ value to their count\n    for word in max_count_words {\n        hm.insert(word,\
    \ max_count);\n    }\n\n    return hm;\n}\n\nfn main() {\n    let candidate =\
    \ histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `{\"c\": 1, \"a\": 2, \"b\": 2}`,\n right: `{\"a\": 2, \"b\": 2}`', /tmp/tmp8pblcj_w.rs:46:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut result = HashMap::new();\n    let mut max_count = 0;\n\
    \    for letter in test.split(\" \") {\n        let count = result.entry(letter.to_string()).or_insert(0);\n\
    \        *count += 1;\n        if *count > max_count {\n            max_count\
    \ = *count;\n        }\n    }\n    let mut histogram = HashMap::new();\n    for\
    \ (letter, count) in result {\n        if count == max_count {\n            histogram.insert(letter,\
    \ count);\n        }\n    }\n    histogram\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `{\"\": 1}`,\n right: `{}`', /tmp/tmp9_oigank.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    // This implementation utilizes the std::collections::HashMap\
    \ to create a\n    // quick and efficient mapping of the histogram data.\n   \
    \ let mut map = HashMap::new();\n    // We'll split the string into its space\
    \ separated components and iterate\n    // over them inserting into the map.\n\
    \    let v: Vec<&str> = test.split(\" \").collect();\n    for element in v {\n\
    \        // The map contains a default value if a key does not exist.\n      \
    \  *map.entry(element.to_string()).or_insert(0) += 1;\n    }\n    // Finally we'll\
    \ get the maximum value for the histogram, if several letters\n    // have the\
    \ same occurrence, return all of them\n    let maximum = map.values().max().unwrap();\n\
    \    let mut result: HashMap<String, isize> = HashMap::new();\n    for (k, v)\
    \ in map {\n        if v == *maximum {\n            result.insert(k, v);\n   \
    \     }\n    }\n    result\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0505]: cannot move out of `map` because it is borrowed\n  --> /tmp/tmpn3srbmun.rs:27:19\n\
    \   |\n25 |     let maximum = map.values().max().unwrap();\n   |             \
    \      ------------ borrow of `map` occurs here\n26 |     let mut result: HashMap<String,\
    \ isize> = HashMap::new();\n27 |     for (k, v) in map {\n   |               \
    \    ^^^ move out of `map` occurs here\n28 |         if v == *maximum {\n   |\
    \                 -------- borrow later used here\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0505`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut map = HashMap::new();\n    test.split_whitespace().for_each(|item|\
    \ {\n        *map.entry(item.to_string()).or_insert(0) += 1;\n    });\n    map\n\
    }\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `{\"c\": 1, \"b\": 2, \"a\": 2}`,\n right: `{\"b\": 2, \"a\": 2}`', /tmp/tmp5bujr1f0.rs:23:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let result = HashMap::new();\n    // Your code here\n    unimplemented!();\n\
    }\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed for `HashMap<K, V>`\n  --> /tmp/tmpt5t1a9gv.rs:13:18\n\
    \   |\n13 |     let result = HashMap::new();\n   |         ------   ^^^^^^^^^^^^\
    \ cannot infer type for type parameter `K`\n   |         |\n   |         consider\
    \ giving `result` the explicit type `HashMap<K, V>`, where the type parameter\
    \ `K` is specified\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    // solution 2:\n    // a map of letters with their counts as values\n\
    \    let mut map: HashMap<String, isize> = HashMap::new();\n    for ch in test.split_whitespace()\
    \ {\n        let count = map.entry(ch.to_string()).or_insert(0);\n        *count\
    \ += 1;\n    }\n    map\n\n    // solution 1:\n    // let mut result: HashMap<String,\
    \ isize> = HashMap::new();\n    // if test.is_empty() {\n    //     return result;\n\
    \    // }\n    //\n    // let mut counts: HashMap<String, isize> = HashMap::new();\n\
    \    // let mut max = 1;\n    //\n    // for ch in test.split_whitespace() {\n\
    \    //     let count = counts.entry(ch.to_string()).or_insert(0);\n    //   \
    \  *count += 1;\n    //     if *count > max {\n    //         max = *count;\n\
    \    //     }\n    // }\n    //\n    // for (ch, count) in counts {\n    //  \
    \   if count == max {\n    //         result.insert(ch, count);\n    //     }\n\
    \    // }\n    // result\n}\n\nfn main() {\n    let candidate = histogram;\n \
    \   assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `{\"c\": 1, \"a\": 2, \"b\": 2}`,\n right: `{\"a\": 2, \"b\": 2}`', /tmp/tmpbmcl958p.rs:50:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut hist = HashMap::new();\n    let mut max_k: String = \"\
    \".to_string();\n    let mut max_v: isize = 0;\n    for word in test.split(\"\
    \ \") {\n        if !hist.contains_key(word) {\n            hist.insert(word.to_string(),\
    \ 1);\n        } else {\n            let key = word.to_string();\n           \
    \ let count = hist.get(&key).unwrap() + 1;\n            hist.insert(key, count);\n\
    \        }\n        let key = word.to_string();\n        let count = hist.get(&key).unwrap();\n\
    \        if *count > max_v {\n            max_v = *count;\n            max_k =\
    \ key;\n        }\n    }\n    let mut rv = HashMap::new();\n    rv.insert(max_k,\
    \ max_v);\n    rv\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `{\"b\": 2}`,\n right: `{\"b\": 2, \"a\": 2}`', /tmp/tmpukd9n45h.rs:38:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut dict: HashMap<String, isize> = HashMap::new();\n    let\
    \ mut max_count: isize = 0;\n    let mut max_keys: Vec<String> = Vec::new();\n\
    \n    for key in test.split(\" \") {\n        let count = dict.entry(key.to_string()).or_insert(0);\n\
    \        *count += 1;\n        if *count > max_count {\n            max_count\
    \ = *count;\n            max_keys = vec![key.to_string()];\n        } else if\
    \ *count == max_count {\n            max_keys.push(key.to_string());\n       \
    \ }\n    }\n\n    max_keys.iter().fold(HashMap::new(), |mut dict, key| {\n   \
    \     dict.insert(key.to_string(), max_count);\n        dict\n    })\n}\n\nfn\
    \ main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `{\"\": 1}`,\n right: `{}`', /tmp/tmp4kl39xgx.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut count = HashMap::new();\n    let mut max_count = 0;\n\
    \    for s in test.split(\" \") {\n        let c = count.entry(s.to_string()).or_insert(0);\n\
    \        *c += 1;\n        if *c > max_count {\n            max_count = *c;\n\
    \        }\n    }\n    let mut result = HashMap::new();\n    for (key, value)\
    \ in count {\n        if value == max_count {\n            result.insert(key,\
    \ value);\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate =\
    \ histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `{\"\": 1}`,\n right: `{}`', /tmp/tmpjsaz5obi.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut chars: HashMap<String, isize> = HashMap::new();\n    for\
    \ char in test.chars() {\n        let char_str = char.to_string();\n        if\
    \ chars.contains_key(&char_str) {\n            *chars.get_mut(&char_str).unwrap()\
    \ += 1;\n        } else {\n            chars.insert(char_str, 1);\n        }\n\
    \    }\n    let max = chars.values().max().unwrap_or(&0);\n    chars.retain(|_,\
    \ v| v == max);\n    chars\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "error[E0502]: cannot borrow `chars` as mutable because it is also borrowed\
    \ as immutable\n  --> /tmp/tmpjanp6tpv.rs:23:5\n   |\n22 |     let max = chars.values().max().unwrap_or(&0);\n\
    \   |               -------------- immutable borrow occurs here\n23 |     chars.retain(|_,\
    \ v| v == max);\n   |     ^^^^^^------^^^^^^^^^^^^^^^^^\n   |     |     |\n  \
    \ |     |     immutable borrow later used by call\n   |     mutable borrow occurs\
    \ here\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0502`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut tmp: HashMap<String, isize> = HashMap::new();\n    let\
    \ mut rtn: HashMap<String, isize> = HashMap::new();\n    for i in test.split(\"\
    \ \") {\n        let count = tmp.entry(i.to_string()).or_insert(0);\n        *count\
    \ += 1;\n    }\n    let mut max = tmp.values().max().unwrap();\n    for (key,\
    \ value) in tmp {\n        if value == *max {\n            rtn.insert(key, value);\n\
    \        }\n    }\n    rtn\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmp_5koka6n.rs:19:9\n\
    \   |\n19 |     let mut max = tmp.values().max().unwrap();\n   |         ----^^^\n\
    \   |         |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0505]: cannot move out of `tmp` because it is borrowed\n\
    \  --> /tmp/tmp_5koka6n.rs:20:25\n   |\n19 |     let mut max = tmp.values().max().unwrap();\n\
    \   |                   ------------ borrow of `tmp` occurs here\n20 |     for\
    \ (key, value) in tmp {\n   |                         ^^^ move out of `tmp` occurs\
    \ here\n21 |         if value == *max {\n   |                     ---- borrow\
    \ later used here\n\nerror: aborting due to previous error; 1 warning emitted\n\
    \nFor more information about this error, try `rustc --explain E0505`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// histogram('a\
    \ b c') == {'a': 1, 'b': 1, 'c': 1}\n/// histogram('a b b a') == {'a': 2, 'b':\
    \ 2}\n/// histogram('a b c a b') == {'a': 2, 'b': 2}\n/// histogram('b b b b a')\
    \ == {'b': 4}\n/// histogram('') == {}\nfn histogram(test: String) -> HashMap<String,\
    \ isize> {\n    let mut map = HashMap::new();\n    let mut v: Vec<&str> = test.split(\"\
    \ \").collect();\n    for i in 0..v.len() {\n        for j in 0..v.len() {\n \
    \           if i != j && v[i] == v[j] {\n                if map.contains_key(v[i])\
    \ {\n                    let count = map.get_mut(v[i]).unwrap();\n           \
    \         *count += 1;\n                } else {\n                    map.insert(v[i].to_string(),\
    \ 1);\n                }\n            }\n        }\n    }\n    map\n}\n\nfn main()\
    \ {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `{}`,\n right: `{\"d\": 1, \"b\": 1, \"g\": 1, \"a\": 1, \"c\": 1}`', /tmp/tmp1xv1d14o.rs:34:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
