name: HumanEval_146_specialFilter
language: rs
prompt: "/// Write a function that takes an array of numbers as input and returns\
  \ \n/// the number of elements in the array that are greater than 10 and both \n\
  /// first and last digits of a number are odd (1, 3, 5, 7, 9).\n/// For example:\n\
  /// specialFilter([15, -73, 14, -15]) => 1 \n/// specialFilter([33, -2, -3, 45,\
  \ 21, 109]) => 2\nfn specialFilter(nums: Vec<isize>) -> isize {\n"
tests: "}\n\nfn main() {\n    let candidate = specialFilter;\n    assert_eq!(candidate(vec![5,\
  \ -2, 1, -5]), 0);\n    assert_eq!(candidate(vec![15, -73, 14, -15]), 1);\n    assert_eq!(candidate(vec![33,\
  \ -2, -3, 45, 21, 109]), 2);\n    assert_eq!(candidate(vec![43, -12, 93, 125, 121,\
  \ 109]), 4);\n    assert_eq!(candidate(vec![71, -2, -33, 75, 21, 19]), 3);\n   \
  \ assert_eq!(candidate(vec![1]), 0);\n    assert_eq!(candidate(Vec::<isize>::new()),\
  \ 0);\n}\n"
completions: ["    let valid = |&n| {\n        let mut a = n;\n        let mut b =\
    \ n;\n        while a > 0 {\n            a /= 10;\n            b %= 10;\n    \
    \        if a % 2 == 0 || b % 2 == 0 {\n                return false;\n      \
    \      }\n        }\n        n > 10\n    };\n    nums.iter().filter(valid).count()\
    \ as isize", "    nums.iter().filter(|&x| {\n        *x > 10 && x.to_string().chars().next().unwrap().to_digit(10).unwrap()\
    \ % 2 == 1 &&\n        x.to_string().chars().last().unwrap().to_digit(10).unwrap()\
    \ % 2 == 1\n    }).count() as isize", '    0', "    return nums.iter().filter(|&num|\
    \ {\n        let last_digit = num.abs() % 10;\n        let first_digit = num.abs()\
    \ / 10;\n        first_digit > 0 && first_digit % 2 == 1 && last_digit % 2 ==\
    \ 1 && *num > 10\n    }).count() as isize;", '    nums.iter().fold(0, |acc, x|
    acc + ((x > &10) as isize) * ((x % 10 % 2 != 0) as isize) * ((x / 10 % 10 % 2
    != 0) as isize))', '    unimplemented!()', "    let f1 = |n: &isize| -> bool {\
    \ n > &10 && n.to_string().chars().nth(0).unwrap().to_digit(10).unwrap() % 2 !=\
    \ 0 && n.to_string().chars().last().unwrap().to_digit(10).unwrap() % 2 != 0 };\n\
    \    nums.iter().filter(f1).count() as isize", "  let mut count = 0;\n  for num\
    \ in nums {\n    let mut temp_num = num;\n    if num >= 10 {\n      let first_digit\
    \ = temp_num % 10;\n      if first_digit == 1 || first_digit == 3 || first_digit\
    \ == 5 || first_digit == 7 || first_digit == 9 {\n        while temp_num > 0 {\n\
    \          temp_num /= 10;\n        }\n        let last_digit = temp_num % 10;\n\
    \        if last_digit == 1 || last_digit == 3 || last_digit == 5 || last_digit\
    \ == 7 || last_digit == 9 {\n          count += 1;\n        }\n      }\n    }\n\
    \  }\n  count", '    return 0;', "    let mut count = 0;\n    for i in 0..nums.len()\
    \ {\n        let n = nums[i];\n        if n > 10 && n % 2 != 0 && n % 10 != 0\
    \ {\n            count += 1;\n        }\n    }\n    count", "    let mut result\
    \ = 0;\n    for num in nums {\n        if (num > 10) && (num.abs() % 10 % 2 !=\
    \ 0) && (num.abs() / 10 % 10 % 2 != 0) {\n            result += 1;\n        }\n\
    \    }\n    result", "    nums.iter().filter(|&a| a > &10 &&\n               \
    \         (a / 10) % 2 != 0 &&\n                        (a % 10) % 2 != 0).count()\
    \ as isize", '    nums.iter().filter(|&x| *x > 10 && (*x / 10) % 2 != 0 && *x
    % 2 != 0).count() as isize', "    nums.iter().fold(0, |n, &x| \n        n + if\
    \ x > 10 && (x/10)%2 == 1 && x%2 == 1 { 1 } else { 0 }\n    )", "    let mut res\
    \ = 0;\n    for i in 0..nums.len() {\n        if nums[i] > 10 && nums[i] % 2 !=\
    \ 0 && (nums[i] / 10) % 2 != 0 {\n            res += 1;\n        }\n    }\n  \
    \  res", "    let mut cnt = 0;\n    for x in nums {\n        if (x > 10) && is_first_and_last_odd(x)\
    \ {\n            cnt += 1;\n        }\n    }\n    cnt", '    return 0;', '    panic!("Not
    implemented");', "    nums.iter().filter(|&x|\n        x > &10 && (*x as f64).log10().floor()\
    \ as isize % 2 != 0 && *x % 2 != 0\n    ).count() as isize", "    // unimplemented!()\n\
    \    let mut result = 0;\n    for num in nums {\n        if (num > 10) && (is_first_odd(num))\
    \ && (is_last_odd(num)) {\n            result += 1;\n        }\n    }\n    result"]
stop_tokens:
- "\n}"
