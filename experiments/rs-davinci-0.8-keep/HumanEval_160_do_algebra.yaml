name: HumanEval_160_do_algebra
language: rs
prompt: "/// Given two lists operator, and operand. The first list has basic algebra\
  \ operations, and \n/// the second list is a list of integers. Use the two given\
  \ lists to build the algebric \n/// expression and return the evaluation of this\
  \ expression.\n/// The basic algebra operations:\n/// Addition ( + ) \n/// Subtraction\
  \ ( - ) \n/// Multiplication ( * ) \n/// Floor division ( // ) \n/// Exponentiation\
  \ ( ** ) \n/// Example:\n/// operator['+', '*', '-']\n/// array = [2, 3, 4, 5]\n\
  /// result = 2 + 3 * 4 - 5\n/// => result = 9\n/// Note:\n/// The length of operator\
  \ list is equal to the length of operand list minus one.\n/// Operand is a list\
  \ of of non-negative integers.\n/// Operator list has at least one operator, and\
  \ operand list has at least two operands.\nfn do_algebra(operator: Vec<String>,\
  \ operand: Vec<isize>) -> isize {\n"
tests: "}\n\nfn main() {\n    let candidate = do_algebra;\n    assert_eq!(candidate(vec![String::from(\"\
  **\"), String::from(\"*\"), String::from(\"+\")], vec![2, 3, 4, 5]), 37);\n    assert_eq!(candidate(vec![String::from(\"\
  +\"), String::from(\"*\"), String::from(\"-\")], vec![2, 3, 4, 5]), 9);\n    assert_eq!(candidate(vec![String::from(\"\
  //\"), String::from(\"*\")], vec![7, 3, 4]), 8);\n}\n"
completions: ["    let mut res = operand[0];\n    for (i, o) in operator.iter().enumerate()\
    \ {\n        match o.as_str() {\n            \"+\" => res += operand[i + 1],\n\
    \            \"-\" => res -= operand[i + 1],\n            \"*\" => res *= operand[i\
    \ + 1],\n            \"//\" => res /= operand[i + 1],\n            \"**\" => res\
    \ = res.pow(operand[i + 1] as u32),\n            _ => {}\n        }\n    }\n \
    \   res", "    let mut res = operand[0];\n    for i in 0..operator.len() {\n \
    \       let op = operator[i].as_str();\n        let op2 = operand[i + 1];\n  \
    \      match op {\n            \"+\" => res += op2,\n            \"-\" => res\
    \ -= op2,\n            \"*\" => res *= op2,\n            \"//\" => res /= op2,\n\
    \            \"**\" => res = res.pow(op2 as u32),\n            _ => panic!(\"\
    Unsupported operation {}\", op),\n        }\n    }\n    res", '    return 0;',
  "    assert!(operator.len() == operand.len() - 1);\n    assert!(operator.len() >\
    \ 0);\n    assert!(operand.len() > 1);\n    let mut result = operand[0];\n   \
    \ for i in 0..operator.len() {\n        let operand = operand[i + 1];\n      \
    \  let operator = &operator[i];\n        match operator.as_str() {\n         \
    \   \"+\" => result += operand,\n            \"-\" => result -= operand,\n   \
    \         \"*\" => result *= operand,\n            \"//\" => result /= operand,\n\
    \            \"**\" => result = result.pow(operand as u32),\n            _ =>\
    \ panic!(\"invalid operator\"),\n        }\n    }\n    result", "    let mut result\
    \ = operand[0];\n    for i in 0..operator.len() {\n        match operator[i].as_str()\
    \ {\n            \"+\" => result += operand[i + 1],\n            \"-\" => result\
    \ -= operand[i + 1],\n            \"*\" => result *= operand[i + 1],\n       \
    \     \"//\" => result /= operand[i + 1],\n            \"**\" => result = result.pow(operand[i\
    \ + 1] as u32),\n            _ => (),\n        }\n    }\n    result", "    let\
    \ mut num = operand[0];\n    for (i, op) in operator.iter().enumerate() {\n  \
    \      num = match op.as_str() {\n            \"+\" => num + operand[i + 1],\n\
    \            \"-\" => num - operand[i + 1],\n            \"*\" => num * operand[i\
    \ + 1],\n            \"//\" => num / operand[i + 1],\n            \"**\" => num.pow(operand[i\
    \ + 1] as u32),\n            _ => unreachable!(),\n        };\n    }\n    num",
  "    let mut result = operand[0];\n    for i in 0..operator.len() {\n        match\
    \ operator[i].as_str() {\n            \"+\" => result += operand[i + 1],\n   \
    \         \"-\" => result -= operand[i + 1],\n            \"*\" => result *= operand[i\
    \ + 1],\n            \"//\" => result /= operand[i + 1],\n            \"**\" =>\
    \ result = result.pow(operand[i + 1] as u32),\n            _ => panic!(\"Operator\
    \ not allowed in the list\"),\n        }\n    }\n    result", "    // Write your\
    \ code here.\n    if operator.len() == 0 || operand.len() < 2 {\n        return\
    \ 0;\n    }\n    let mut result = operand[0];\n    for i in 0..operator.len()\
    \ {\n        match operator[i].as_str() {\n            \"+\" => result += operand[i\
    \ + 1],\n            \"-\" => result -= operand[i + 1],\n            \"*\" =>\
    \ result *= operand[i + 1],\n            \"//\" => result /= operand[i + 1],\n\
    \            \"**\" => result = result.pow(operand[i + 1] as u32),\n         \
    \   _ => panic!(\"Unknown operator {}\", operator[i]),\n        }\n    }\n   \
    \ result", "    if operand.len() < 2 {\n        return 0;\n    }\n    let mut\
    \ result = operand[0];\n    for i in 0..operator.len() {\n        match operator[i].as_str()\
    \ {\n            \"+\" => result += operand[i + 1],\n            \"-\" => result\
    \ -= operand[i + 1],\n            \"*\" => result *= operand[i + 1],\n       \
    \     \"//\" => result /= operand[i + 1],\n            \"**\" => result = result.pow(operand[i\
    \ + 1] as u32),\n            _ => continue,\n        }\n    }\n    result", " \
    \   let op_cnt = operator.len();\n    let mut op_stack: Vec<String> = Vec::new();\n\
    \    let mut operand_stack: Vec<isize> = Vec::new();\n    op_stack.push(operator[0].clone());\n\
    \    operand_stack.push(operand[0]);\n    for i in 1..op_cnt {\n        let mut\
    \ op_stack_top = op_stack.pop().unwrap();\n        if operator[i] == \"-\" ||\
    \ operator[i] == \"+\" {\n            operand_stack.push(operand[i]);\n      \
    \      op_stack.push(operator[i].clone());\n        } else {\n            while\
    \ op_stack_top == \"*\" || op_stack_top == \"/\" || op_stack_top == \"**\" {\n\
    \                let opr = operand_stack.pop().unwrap();\n                let\
    \ opn = operand_stack.pop().unwrap();\n                operand_stack.push(calc(op_stack_top,\
    \ opn, opr));\n                if op_stack.len() == 0 {\n                    break;\n\
    \                }\n                op_stack_top = op_stack.pop().unwrap();\n\
    \            }\n            operand_stack.push(operand[i]);\n            op_stack.push(op_stack_top);\n\
    \            op_stack.push(operator[i].clone());\n        }\n    }\n    while\
    \ op_stack.len() > 0 {\n        let opr = operand_stack.pop().unwrap();\n    \
    \    let opn = operand_stack.pop().unwrap();\n        operand_stack.push(calc(op_stack.pop().unwrap(),\
    \ opn, opr));\n    }\n    operand_stack.pop().unwrap()", "    let mut result =\
    \ operand[0];\n    for i in 0..operator.len() {\n        match operator[i].as_str()\
    \ {\n            \"+\" => result += operand[i + 1],\n            \"-\" => result\
    \ -= operand[i + 1],\n            \"*\" => result *= operand[i + 1],\n       \
    \     \"//\" => result /= operand[i + 1],\n            \"**\" => result = result.pow(operand[i\
    \ + 1] as u32),\n            _ => panic!(\"Unknown operator\"),\n        }\n \
    \   }\n    result", '    operator.iter().fold(operand[0], |sum, x| sum + x)',
  "    let mut result = operand[0];\n    for i in 0..operator.len() {\n        match\
    \ operator[i].as_str() {\n            \"+\" => result += operand[i + 1],\n   \
    \         \"-\" => result -= operand[i + 1],\n            \"*\" => result *= operand[i\
    \ + 1],\n            \"//\" => result /= operand[i + 1],\n            \"**\" =>\
    \ result = result.pow(operand[i + 1] as u32),\n            _ => panic!(\"Operator\
    \ not found!\"),\n        }\n    }\n    result", "    let mut stack: Vec<isize>\
    \ = Vec::new();\n    let mut temp: isize = 0;\n    for i in 0..operator.len()\
    \ {\n        let operand1 = operand[i];\n        let operand2 = operand[i + 1];\n\
    \        let op = operator[i].as_str();\n        match op {\n            \"+\"\
    \ => temp = operand1 + operand2,\n            \"-\" => temp = operand1 - operand2,\n\
    \            \"*\" => temp = operand1 * operand2,\n            \"//\" => temp\
    \ = operand1 / operand2,\n            \"**\" => temp = operand1.pow(operand2 as\
    \ u32),\n            _ => println!(\"op:{}\", op),\n        }\n        stack.push(temp);\n\
    \    }\n    let mut result: isize = 0;\n    if stack.len() > 0 {\n        result\
    \ = stack[0];\n    }\n    for i in 1..stack.len() {\n        result = result -\
    \ stack[i];\n    }\n    result", "    operand.iter().zip(operator.iter()).fold(0,\
    \ |acc, (x, op)| {\n        match op.as_str() {\n            \"+\" => acc + x,\n\
    \            \"-\" => acc - x,\n            \"*\" => acc * x,\n            \"\
    //\" => acc / x,\n            \"**\" => acc.pow(*x as u32),\n            _ =>\
    \ acc,\n        }\n    })", "    let mut result = 0;\n    let mut index = 0;\n\
    \    for op in operator {\n        if op == \"+\" {\n            result += operand[index]\
    \ + operand[index + 1];\n        } else if op == \"-\" {\n            result +=\
    \ operand[index] - operand[index + 1];\n        } else if op == \"*\" {\n    \
    \        result += operand[index] * operand[index + 1];\n        } else if op\
    \ == \"//\" {\n            result += operand[index] / operand[index + 1];\n  \
    \      } else if op == \"**\" {\n            result += operand[index].pow(operand[index\
    \ + 1] as u32);\n        }\n        index += 1;\n    }\n    result", "    if operand.len()\
    \ < 2 {\n        panic!(\"operand can't have less than 2 elements\");\n    }\n\
    \    if operator.len() < 1 {\n        panic!(\"operator can't have less than 1\
    \ element\");\n    }\n    if operator.len() != operand.len() - 1 {\n        panic!(\"\
    operator length is equal to the length of operand list minus one\");\n    }\n\
    \    let mut result = operand[0];\n    for i in 0..operator.len() {\n        match\
    \ operator[i].as_str() {\n            \"+\" => result += operand[i + 1],\n   \
    \         \"-\" => result -= operand[i + 1],\n            \"*\" => result *= operand[i\
    \ + 1],\n            \"//\" => result /= operand[i + 1],\n            \"**\" =>\
    \ result = result.pow(operand[i + 1] as u32),\n            _ => panic!(\"unknown\
    \ operator\"),\n        }\n    }\n    result", "    let mut stack: Vec<isize>\
    \ = Vec::new();\n    stack.push(operand[0]);\n    for i in 1..operand.len() {\n\
    \        let res = match operator[i - 1].as_str() {\n            \"+\" => stack[i\
    \ - 1] + operand[i],\n            \"-\" => stack[i - 1] - operand[i],\n      \
    \      \"*\" => stack[i - 1] * operand[i],\n            \"/\" => stack[i - 1]\
    \ / operand[i],\n            \"^\" => stack[i - 1].pow(operand[i] as u32),\n \
    \           _ => 0,\n        };\n        stack.push(res);\n    }\n    stack.pop().unwrap()",
  "    let mut h = operand.iter().rev().collect::<Vec<_>>();\n    for o in operator.iter().rev()\
    \ {\n        match o.as_str() {\n            \"+\" => {\n                let x\
    \ = h.pop().unwrap();\n                let y = h.pop().unwrap();\n           \
    \     h.push(x + y);\n            }\n            \"-\" => {\n                let\
    \ x = h.pop().unwrap();\n                let y = h.pop().unwrap();\n         \
    \       h.push(x - y);\n            }\n            \"*\" => {\n              \
    \  let x = h.pop().unwrap();\n                let y = h.pop().unwrap();\n    \
    \            h.push(x * y);\n            }\n            \"/\" => {\n         \
    \       let x = h.pop().unwrap();\n                let y = h.pop().unwrap();\n\
    \                h.push(x / y);\n            }\n            \"^\" => {\n     \
    \           let x = h.pop().unwrap();\n                let y = h.pop().unwrap();\n\
    \                h.push(x.pow(y as u32));\n            }\n            _ => panic!(\"\
    Unsupported operator\"),\n        }\n    }\n    h.pop().unwrap()", "    let mut\
    \ total = operand[0];\n    for (index, op) in operator.iter().enumerate() {\n\
    \        match op.as_str() {\n            \"+\" => total += operand[index + 1],\n\
    \            \"-\" => total -= operand[index + 1],\n            \"*\" => total\
    \ *= operand[index + 1],\n            \"//\" => total /= operand[index + 1],\n\
    \            \"**\" => total = total.pow(operand[index + 1] as u32),\n       \
    \     _ => return 0,\n        }\n    }\n    total"]
stop_tokens:
- "\n}"
