name: HumanEval_29_filter_by_prefix
language: rs
prompt: "/// Filter an input list of strings only for ones that start with a given\
  \ prefix.\n/// >>> filter_by_prefix([], 'a')\n/// []\n/// >>> filter_by_prefix(['abc',\
  \ 'bcd', 'cde', 'array'], 'a')\n/// ['abc', 'array']\nfn filter_by_prefix(strings:\
  \ Vec<String>, prefix: String) -> Vec<String> {\n"
tests: "}\n\nfn main() {\n    let candidate = filter_by_prefix;\n    assert_eq!(candidate(Vec::<String>::new(),\
  \ String::from(\"john\")), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
  xxx\"), String::from(\"asd\"), String::from(\"xxy\"), String::from(\"john doe\"\
  ), String::from(\"xxxAAA\"), String::from(\"xxx\")], String::from(\"xxx\")), vec![String::from(\"\
  xxx\"), String::from(\"xxxAAA\"), String::from(\"xxx\")]);\n}\n"
completions: ["    strings\n        .into_iter()\n        .filter(|string| string.starts_with(&prefix))\n\
    \        .collect()", "    strings\n        .into_iter()\n        .filter(|s|\
    \ s.starts_with(&prefix))\n        .collect()", "    strings\n        .into_iter()\n\
    \        .filter(|x| x.starts_with(&prefix))\n        .collect()", "    let mut\
    \ result = Vec::new();\n    for string in strings {\n        if string.starts_with(&prefix)\
    \ {\n            result.push(string);\n        }\n    }\n    result", "    strings\n\
    \        .into_iter()\n        .filter(|s| s.starts_with(&prefix))\n        .collect()",
  "    strings\n        .into_iter()\n        .filter(|s| s.starts_with(&prefix))\n\
    \        .collect()", "    // There are many ways to implement this, and a variety\
    \ of approaches\n    // that you may have learned in a previous course.\n    //\n\
    \    // The following is a vector comprehension, which is a pattern in\n    //\
    \ functional programming languages similar to a list comprehension in\n    //\
    \ Python.\n    //\n    // This is provided for your reference, but you can also\
    \ use a traditional\n    // for loop or any other approach you would like.\n \
    \   strings\n        .into_iter()\n        .filter(|s| s.starts_with(&prefix))\n\
    \        .collect()", "    strings\n        .into_iter()\n        .filter(|string|\
    \ string.starts_with(&prefix))\n        .collect()", "    let mut result = Vec::new();\n\
    \    for s in strings {\n        if &s[0..1] == prefix {\n            result.push(s);\n\
    \        }\n    }\n    result", "    return strings.into_iter().filter(|string|\
    \ {\n        string.starts_with(&prefix)\n    }).collect();", "    strings\n \
    \       .into_iter()\n        .filter(|s| s.starts_with(&prefix))\n        .collect()",
  "    strings\n        .into_iter()\n        .filter(|s| s.starts_with(&prefix))\n\
    \        .collect()", "    strings\n        .into_iter()\n        .filter(|string|\
    \ string.starts_with(&prefix))\n        .collect()", "    strings\n        .into_iter()\n\
    \        .filter(|string| string.starts_with(&prefix))\n        .collect()", " \
    \   strings\n        .into_iter()\n        .filter(|s| s.starts_with(&prefix))\n\
    \        .collect()", "    let mut result = Vec::new();\n    for s in strings\
    \ {\n        if s.starts_with(&prefix) {\n            result.push(s);\n      \
    \  }\n    }\n    result", "    let prefix = format!(\"{}\", prefix);\n    strings\n\
    \        .into_iter()\n        .filter(|s| {\n            s.chars()\n        \
    \        .zip(prefix.chars())\n                .fold(true, |acc, (s_char, pref_char)|\
    \ acc && (s_char == pref_char))\n        })\n        .collect()", "    strings\n\
    \        .into_iter()\n        .filter(|s| s.starts_with(&prefix))\n        .collect()",
  "    strings\n        .into_iter()\n        .filter(|s| s.starts_with(&prefix))\n\
    \        .collect()", "    strings\n        .into_iter()\n        .filter(|s|\
    \ s.starts_with(&prefix))\n        .collect()"]
stop_tokens:
- "\n}"
