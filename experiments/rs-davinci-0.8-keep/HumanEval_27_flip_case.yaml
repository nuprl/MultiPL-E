name: HumanEval_27_flip_case
language: rs
prompt: "/// For a given string, flip lowercase characters to uppercase and uppercase\
  \ to lowercase.\n/// >>> flip_case('Hello')\n/// 'hELLO'\nfn flip_case(string: String)\
  \ -> String {\n"
tests: "}\n\nfn main() {\n    let candidate = flip_case;\n    assert_eq!(candidate(String::from(\"\
  \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hello!\")),\
  \ String::from(\"hELLO!\"));\n    assert_eq!(candidate(String::from(\"These violent\
  \ delights have violent ends\")), String::from(\"tHESE VIOLENT DELIGHTS HAVE VIOLENT\
  \ ENDS\"));\n}\n"
completions: ['    unimplemented!("Flip the case of {}", string)', "    string.chars().map(|c|\
    \ {\n        if c.is_lowercase() {\n            c.to_uppercase().to_string()\n\
    \        } else {\n            c.to_lowercase().to_string()\n        }\n    }).collect()",
  "    string.chars().map(|c| match c {\n        c if c.is_lowercase() => c.to_uppercase().next().unwrap(),\n\
    \        c if c.is_uppercase() => c.to_lowercase().next().unwrap(),\n        _\
    \ => c,\n    }).collect()", "    string.chars().map(|c| {\n        if c.is_lowercase()\
    \ {\n            c.to_uppercase().next().unwrap()\n        } else {\n        \
    \    c.to_lowercase().next().unwrap()\n        }\n    }).collect()", "    let\
    \ mut flip_string = String::new();\n    for character in string.chars() {\n  \
    \      if character.is_lowercase() {\n            flip_string.push(character.to_uppercase().to_string().pop().unwrap());\n\
    \        } else if character.is_uppercase() {\n            flip_string.push(character.to_lowercase().to_string().pop().unwrap());\n\
    \        } else {\n            flip_string.push(character);\n        }\n    }\n\
    \    flip_string", '    string.chars().map(|c| c.to_lowercase().to_string()).collect()',
  "    // string.chars().map(|c| {\n    //     if char::is_uppercase(c) {\n    //\
    \         char::to_lowercase(c)\n    //     } else {\n    //         char::to_uppercase(c)\n\
    \    //     }\n    // }).collect()\n    //  or..\n    string.chars().map(|c| match\
    \ char::is_uppercase(c) {\n        true => char::to_lowercase(c),\n        false\
    \ => char::to_uppercase(c),\n    }).collect()", "    let mut chars = string.chars();\n\
    \    let mut res = String::new();\n    while let Some(c) = chars.next() {\n  \
    \      if c.is_lowercase() {\n            res.push(c.to_uppercase().nth(0).unwrap());\n\
    \        } else if c.is_uppercase() {\n            res.push(c.to_lowercase().nth(0).unwrap());\n\
    \        } else {\n            res.push(c);\n        }\n    }\n    res", '    string.chars().map(|c|
    c.to_lowercase().nth(0).unwrap_or(c)).collect()', '    unimplemented!()', "  \
    \  let flipped_chars: Vec<char> = string.chars().map(|c| {\n        if c.is_ascii_uppercase()\
    \ {\n            c.to_ascii_lowercase()\n        } else {\n            c.to_ascii_uppercase()\n\
    \        }\n    }).collect();\n    flipped_chars.iter().collect()", "    string.chars().map(|c|\
    \ match c {\n        'a'...'z' => c.to_ascii_uppercase(),\n        'A'...'Z' =>\
    \ c.to_ascii_lowercase(),\n        _ => c,\n    }).collect()", '    string.chars().map(|c|
    if c.is_uppercase() { c.to_lowercase().next().unwrap() } else { c.to_uppercase().next().unwrap()
    }).collect()', '    string.chars().map(|ch| ch.swap_case()).collect()', "    return\
    \ string.chars().map(|c| {\n        if c.is_uppercase() {\n            return\
    \ c.to_lowercase().next().unwrap();\n        }\n        if c.is_lowercase() {\n\
    \            return c.to_uppercase().next().unwrap();\n        }\n        return\
    \ c;\n    }).collect();", "    let mut reversed_string = String::new();\n    for\
    \ c in string.chars() {\n        match c {\n            c if c.is_ascii_lowercase()\
    \ => reversed_string.push(c.to_ascii_uppercase()),\n            c if c.is_ascii_uppercase()\
    \ => reversed_string.push(c.to_ascii_lowercase()),\n            _ => reversed_string.push(c),\n\
    \        }\n    }\n    reversed_string", "    string.chars().map(|c| if c.is_lowercase()\
    \ {\n        c.to_uppercase().nth(0).unwrap()\n    } else {\n        c.to_lowercase().nth(0).unwrap()\n\
    \    }).collect()", '    string.chars().map(|c| c.to_lowercase().next().unwrap()).collect()',
  '    string.chars().map(|c| c.to_uppercase().next().unwrap_or(c)).collect()', '    unimplemented!()']
stop_tokens:
- "\n}"
