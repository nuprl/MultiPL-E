name: HumanEval_68_pluck
language: rs
prompt: "/// \"Given an array representing a branch of a tree that has non-negative\
  \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
  \ The plucked node should be the node with the smallest even value.\n/// If multiple\
  \ nodes with the same smallest even value are found return the node that has smallest\
  \ index.\n/// The plucked node should be returned in a list, [ smalest_value, its\
  \ index ],\n/// If there are no even values or the given array is empty, return\
  \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
  \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
  /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
  \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
  \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
  \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
  \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
  \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n"
tests: "}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
  \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
  \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
  \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]),\
  \ vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n  \
  \  assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
  \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
completions: ["    let mut min = vec![];\n    for (i, val) in arr.iter().enumerate()\
    \ {\n        if val % 2 == 0 {\n            if min.is_empty() {\n            \
    \    min = vec![*val, i as isize];\n            } else if min[0] > *val {\n  \
    \              min = vec![*val, i as isize];\n            }\n        }\n    }\n\
    \    min", "    arr.iter()\n        .enumerate()\n        .filter(|&(_, i)| *i\
    \ % 2 == 0)\n        .min_by_key(|&(_, i)| i)\n        .map(|(i, v)| vec![*v,\
    \ i as isize])\n        .unwrap_or_else(|| vec![])", "    let mut smallest_index\
    \ = isize::max_value();\n    let mut smallest_value = isize::max_value();\n  \
    \  for (i, n) in arr.iter().enumerate() {\n        if n % 2 == 0 && n < &smallest_value\
    \ {\n            smallest_value = *n;\n            smallest_index = i as isize;\n\
    \        }\n    }\n    if smallest_index == isize::max_value() {\n        return\
    \ vec![];\n    }\n    vec![smallest_value, smallest_index]", "    let mut even\
    \ = std::isize::MAX;\n    let mut index = 0;\n    for (i, &x) in arr.iter().enumerate()\
    \ {\n        if x % 2 == 0 && x < even {\n            even = x;\n            index\
    \ = i;\n        }\n    }\n    if even == std::isize::MAX {\n        vec![]\n \
    \   } else {\n        vec![even, index as isize]\n    }", "    arr.iter()\n  \
    \      .cloned()\n        .enumerate()\n        .filter(|(i, x)| x % 2 == 0)\n\
    \        .min_by_key(|(i, x)| (x, *i))\n        .map(|(i, x)| vec![x, i as isize])\n\
    \        .unwrap_or_else(|| vec![])", "    if arr.is_empty() {\n        return\
    \ vec![];\n    }\n    let mut even_count: usize = 0;\n    let mut even_index:\
    \ usize = 0;\n    for (i, n) in arr.iter().enumerate() {\n        if n % 2 ==\
    \ 0 {\n            even_count += 1;\n            even_index = i;\n        }\n\
    \    }\n    if even_count == 0 {\n        return vec![];\n    }\n    let mut smallest_even:\
    \ usize = arr[even_index] as usize;\n    for (i, n) in arr.iter().enumerate()\
    \ {\n        if *n % 2 == 0 && *n as usize < smallest_even {\n            smallest_even\
    \ = *n as usize;\n            even_index = i;\n        }\n    }\n    vec![smallest_even\
    \ as isize, even_index as isize]", "    arr.iter()\n        .enumerate()\n   \
    \     .filter(|(_, &n)| n % 2 == 0)\n        .min_by_key(|(_, &n)| n)\n      \
    \  .map(|(i, &n)| vec![n, i as isize])\n        .unwrap_or_else(|| vec![])", " \
    \   let mut min = 10001;\n    let mut min_idx = 10001;\n    for (i, v) in arr.iter().enumerate()\
    \ {\n        if v % 2 == 0 && v < &min {\n            min = *v;\n            min_idx\
    \ = i as isize;\n        }\n    }\n    if min == 10001 {\n        return vec![];\n\
    \    }\n    vec![min, min_idx]", "    if arr.len() == 0 {\n        return vec![];\n\
    \    }\n    let (mut min_index, mut min_value) = (0, std::isize::MAX);\n    for\
    \ (i, &v) in arr.iter().enumerate() {\n        if v % 2 == 0 && v < min_value\
    \ {\n            min_index = i;\n            min_value = v;\n        }\n    }\n\
    \    if min_value == std::isize::MAX {\n        return vec![];\n    }\n    vec![min_value,\
    \ min_index as isize]", "    let mut min_even = std::isize::MAX;\n    let mut\
    \ min_even_idx = std::isize::MAX;\n    for (idx, val) in arr.iter().enumerate()\
    \ {\n        if val % 2 == 0 && val < &min_even {\n            min_even = *val;\n\
    \            min_even_idx = idx as isize;\n        }\n    }\n    if min_even !=\
    \ std::isize::MAX {\n        vec![min_even, min_even_idx]\n    } else {\n    \
    \    vec![]\n    }", "    let mut min_even = None;\n    let mut min_even_index\
    \ = None;\n    for (i, num) in arr.iter().enumerate() {\n        if *num % 2 ==\
    \ 0 {\n            if min_even == None || *num < min_even.unwrap() {\n       \
    \         min_even = Some(*num);\n                min_even_index = Some(i as isize);\n\
    \            }\n        }\n    }\n    match (min_even, min_even_index) {\n   \
    \     (Some(min_even), Some(min_even_index)) => vec![min_even, min_even_index],\n\
    \        _ => vec![],\n    }", "    if arr.is_empty() {\n        return vec![];\n\
    \    }\n    let mut even_indices = vec![];\n    let mut even_value = i32::max_value();\n\
    \    for (i, n) in arr.iter().enumerate() {\n        if n % 2 == 0 && *n < even_value\
    \ {\n            even_indices.clear();\n            even_indices.push(i);\n  \
    \          even_value = *n;\n        } else if n % 2 == 0 && *n == even_value\
    \ {\n            even_indices.push(i);\n        }\n    }\n    if even_indices.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut min_index = *even_indices.first().unwrap();\n\
    \    for i in even_indices {\n        if i < min_index {\n            min_index\
    \ = i;\n        }\n    }\n    vec![even_value as isize, min_index as isize]",
  "    let mut smallest_even_index = arr.len();\n    let mut smallest_even_value =\
    \ isize::max_value();\n    for (index, item) in arr.iter().enumerate() {\n   \
    \     if item % 2 == 0 && item < &smallest_even_value {\n            smallest_even_value\
    \ = *item;\n            smallest_even_index = index;\n        }\n    }\n    if\
    \ smallest_even_index == arr.len() {\n        return vec![];\n    }\n    vec![smallest_even_value,\
    \ smallest_even_index as isize]", '    unimplemented!();', "    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut even_node = isize::max_value();\n\
    \    let mut even_index = isize::max_value();\n    for (index, node) in arr.iter().enumerate()\
    \ {\n        if node % 2 == 0 && node < &even_node {\n            even_node =\
    \ *node;\n            even_index = index as isize;\n        }\n    }\n    if even_node\
    \ != isize::max_value() {\n        vec![even_node, even_index]\n    } else {\n\
    \        vec![]\n    }", "    let mut min = isize::max_value();\n    let mut min_idx\
    \ = isize::max_value();\n    for (idx, x) in arr.iter().enumerate() {\n      \
    \  if x % 2 == 0 && x < &min {\n            min = *x;\n            min_idx = idx\
    \ as isize;\n        }\n    }\n    if min_idx == isize::max_value() {\n      \
    \  vec![]\n    } else {\n        vec![min, min_idx]\n    }", "    // TODO\n  \
    \  unimplemented!();", "    let mut min_even = std::isize::MAX;\n    let mut min_even_idx\
    \ = std::isize::MAX;\n    for (idx, val) in arr.iter().enumerate() {\n       \
    \ if val.clone() % 2 == 0 && val.clone() < min_even {\n            min_even =\
    \ val.clone();\n            min_even_idx = idx as isize;\n        }\n    }\n \
    \   if min_even != std::isize::MAX {\n        vec![min_even, min_even_idx]\n \
    \   } else {\n        vec![]\n    }", "    // Find the smallest even element from\
    \ a vector.\n    fn smallest_even(arr: &[isize]) -> Option<isize> {\n        //\
    \ Find the smallest even from a sorted vector.\n        fn smallest_even_from_sorted(arr:\
    \ &[isize]) -> Option<isize> {\n            for el in arr {\n                if\
    \ el % 2 == 0 {\n                    return Some(*el);\n                }\n  \
    \          }\n            None\n        }\n        let mut arr_copy = arr.to_vec();\n\
    \        arr_copy.sort();\n        smallest_even_from_sorted(&arr_copy)\n    }\n\
    \    // Find the index of the smallest even element from a vector.\n    fn smallest_even_index(arr:\
    \ &[isize]) -> Option<usize> {\n        let smallest_even = smallest_even(arr);\n\
    \        if let Some(smallest_even) = smallest_even {\n            Some(arr.iter().position(|&x|\
    \ x == smallest_even).unwrap())\n        } else {\n            None\n        }\n\
    \    }\n    // Test for empty array.\n    if arr.is_empty() {\n        return\
    \ vec![];\n    }\n    // Find the smallest even element and its index.\n    let\
    \ smallest_even = smallest_even(&arr);\n    let smallest_even_index = smallest_even_index(&arr);\n\
    \    // Test for no even element.\n    if smallest_even.is_none() || smallest_even_index.is_none()\
    \ {\n        return vec![];\n    }\n    vec![smallest_even.unwrap(), smallest_even_index.unwrap()\
    \ as isize]", "    let mut m = None;\n    let mut idx = arr.len();\n    for (i,\
    \ &v) in arr.iter().enumerate() {\n        if v % 2 == 0 {\n            m = match\
    \ m {\n                None => Some(v),\n                Some(m) => {\n      \
    \              if v < m {\n                        Some(v)\n                 \
    \   } else {\n                        Some(m)\n                    }\n       \
    \         }\n            };\n            if m.unwrap() == v {\n              \
    \  idx = i;\n            }\n        }\n    }\n    match m {\n        None => vec![],\n\
    \        Some(m) => vec![m, idx as isize],\n    }"]
stop_tokens:
- "\n}"
