name: HumanEval_100_make_a_pile
language: rs
prompt: "/// Given a positive integer n, you have to make a pile of n levels of stones.\n\
  /// The first level has n stones.\n/// The number of stones in the next level is:\n\
  /// - the next odd number if n is odd.\n/// - the next even number if n is even.\n\
  /// Return the number of stones in each level in a list, where element at index\n\
  /// i represents the number of stones in the level (i+1).\n/// Examples:\n/// >>>\
  \ make_a_pile(3)\n/// [3, 5, 7]\nfn make_a_pile(n: isize) -> Vec<isize> {\n"
tests: "}\n\nfn main() {\n    let candidate = make_a_pile;\n    assert_eq!(candidate(3),\
  \ vec![3, 5, 7]);\n    assert_eq!(candidate(4), vec![4, 6, 8, 10]);\n    assert_eq!(candidate(5),\
  \ vec![5, 7, 9, 11, 13]);\n    assert_eq!(candidate(6), vec![6, 8, 10, 12, 14, 16]);\n\
  \    assert_eq!(candidate(8), vec![8, 10, 12, 14, 16, 18, 20, 22]);\n}\n"
completions: ["    let mut result = vec![n];\n    while n > 1 {\n        let m = if\
    \ n % 2 == 0 { n / 2 + 1 } else { (n + 1) / 2 };\n        result.push(m);\n  \
    \      n = m;\n    }\n    result", "    let mut results = vec![n];\n    let mut\
    \ i = 1;\n    while i < n {\n        let next = if n % 2 == 0 {\n            n\
    \ + i * 2\n        } else {\n            n + i * 2 - 1\n        };\n        results.push(next);\n\
    \        i += 1;\n    }\n    results", "    let mut pile = vec![n];\n    while\
    \ pile.last().unwrap() != &1 {\n        pile.push(\n            if pile.last().unwrap()\
    \ % 2 == 0 {\n                pile.last().unwrap() - 1\n            } else {\n\
    \                pile.last().unwrap() - 2\n            },\n        );\n    }\n\
    \    pile", "    if n <= 0 {\n        return vec![];\n    }\n    vec![\n     \
    \   n,\n        n + 2 * (n % 2) - 1,\n        n + 4 * (n % 2) - 1,\n    ]", " \
    \   if n <= 0 {\n        vec![]\n    } else {\n        let mut pile = vec![n];\n\
    \        let mut next = n + 1;\n        while next <= n * 2 {\n            pile.push(next);\n\
    \            next += if n % 2 == 0 { 2 } else { 1 };\n        }\n        pile\n\
    \    }", "    let mut prev = n;\n    let mut vec = vec![prev];\n    while prev\
    \ > 1 {\n        let next = if prev % 2 == 0 {\n            prev / 2\n       \
    \ } else {\n            (prev + 1) / 2\n        };\n        vec.push(next);\n\
    \        prev = next;\n    }\n    vec", '    (1..=n).map(|i| i + (i - 1)).collect()',
  "    let mut v = vec![n];\n    let mut next = n + 2;\n    while next <= n * 2 {\n\
    \        v.push(next);\n        next += 2;\n    }\n    v", "    let mut res =\
    \ vec![n];\n    let mut prev = n;\n    while prev > 1 {\n        if prev % 2 ==\
    \ 0 {\n            prev = prev - 1;\n        } else {\n            prev = prev\
    \ - 2;\n        }\n        res.push(prev);\n    }\n    res", "    // Your code\
    \ here\n    let mut result = vec![n];\n    while n > 1 {\n        if n % 2 ==\
    \ 0 {\n            n /= 2;\n        } else {\n            n -= 1;\n        }\n\
    \        result.push(n);\n    }\n    result", '    vec![n, n + 2, n + 4]', " \
    \   let mut result = vec![n];\n    let mut init = n;\n    loop {\n        if init\
    \ % 2 == 0 {\n            init += 1;\n        } else {\n            init += 2;\n\
    \        }\n        if init <= 0 {\n            break;\n        }\n        result.push(init);\n\
    \    }\n    result", "    if n == 0 {\n        return vec![];\n    }\n    if n\
    \ == 1 {\n        return vec![1];\n    }\n    let mut v = vec![n];\n    let mut\
    \ m = n;\n    loop {\n        if m.is_even() {\n            m += 1;\n        }\
    \ else {\n            m += 2;\n        }\n        v.push(m);\n        if m ==\
    \ n {\n            break;\n        }\n    }\n    v", "    let mut stones = vec![n];\n\
    \    let mut last = n;\n    while last > 0 {\n        let level = if last % 2\
    \ == 0 {\n            last + 2\n        } else {\n            last + 1\n     \
    \   };\n        stones.push(level);\n        last = level;\n    }\n    stones",
  "    let mut pile = vec![n];\n    while pile.last().unwrap() != &1 {\n        let\
    \ level = pile.last().unwrap();\n        if level % 2 == 0 {\n            pile.push(level\
    \ - 1);\n        } else {\n            pile.push(level - 2);\n        }\n    }\n\
    \    pile", "    let mut stones = vec![n];\n    loop {\n        let last = stones.last().unwrap();\n\
    \        if last == &1 {\n            break;\n        }\n        stones.push(match\
    \ last {\n            n if n % 2 == 0 => n - 1,\n            n => n - 2,\n   \
    \     });\n    }\n    stones", "    let mut result = vec![n];\n    let mut x =\
    \ n;\n    while x > 1 {\n        if x % 2 == 0 {\n            x -= 1;\n      \
    \  } else {\n            x -= 2;\n        }\n        result.push(x);\n    }\n\
    \    result", "    let mut result = vec![n];\n    let mut level = n;\n    while\
    \ level > 1 {\n        level = if level % 2 == 0 {\n            level / 2\n  \
    \      } else {\n            (level + 1) / 2\n        };\n        result.push(level);\n\
    \    }\n    result", "    let mut result = vec![n];\n    let mut last = n;\n \
    \   loop {\n        let next = if last % 2 == 0 {\n            last + 2\n    \
    \    } else {\n            last + 1\n        };\n        if next > n {\n     \
    \       break;\n        }\n        result.push(next);\n        last = next;\n\
    \    }\n    result", "    let mut pile = vec![n];\n    while pile.last().unwrap()\
    \ != &1 {\n        pile.push(pile.last().unwrap() - 1);\n    }\n    pile"]
stop_tokens:
- "\n}"
