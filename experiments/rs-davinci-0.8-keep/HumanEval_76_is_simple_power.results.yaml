language: rs
name: HumanEval_76_is_simple_power
results:
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if x == 1 { return true;\
    \ }\n    if n == 1 { return false; }\n    let sqrt = (x as f64).sqrt() as isize;\n\
    \    if sqrt * sqrt == x {\n        return is_simple_power(sqrt, n);\n    }\n\
    \    let d = (x as f64).log(n as f64) as isize;\n    return x == n.pow(d as u32);\n\
    }\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmphfwoduzg.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823102
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    let mut power = 1;\n   \
    \ let mut i = 0;\n    while power < x {\n        power *= n;\n        i += 1;\n\
    \    }\n    power == x\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823102
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    (1..)\n        .map(|i|\
    \ i * i)\n        .take_while(|&i| i <= x)\n        .any(|i| i == x)\n}\n\nfn\
    \ main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823102
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if x == 1 {\n        return\
    \ true;\n    }\n    if n == 1 {\n        return false;\n    }\n    x == n.pow(x.to_string().len()\
    \ as u32)\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpx1v32_l4.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823102
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    let mut v = x;\n    if v\
    \ == 1 {\n        return n == 1;\n    }\n    if n == 1 {\n        return false;\n\
    \    }\n    while v % n == 0 {\n        v /= n;\n    }\n    v == 1\n}\n\nfn main()\
    \ {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpslhla0bc.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823102
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if x == 1 {\n        return\
    \ true;\n    }\n    if n == 1 {\n        return false;\n    }\n    let mut factor\
    \ = n;\n    while factor < x {\n        factor *= n;\n    }\n    factor == x\n\
    }\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823102
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    for i in 1..(x as f64).sqrt()\
    \ as isize + 1 {\n        if n.pow(i) == x {\n            return true;\n     \
    \   }\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1t45sslb.rs:13:18\n   |\n\
    13 |         if n.pow(i) == x {\n   |                  ^ expected `u32`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `u32` and panic if the\
    \ converted value doesn't fit\n   |\n13 |         if n.pow(i.try_into().unwrap())\
    \ == x {\n   |                  ~~~~~~~~~~~~~~~~~~~~~\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659823102
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    let mut x = x;\n    let\
    \ mut count = 0;\n    while x != 1 {\n        if x % n != 0 {\n            return\
    \ false;\n        }\n        x /= n;\n        count += 1;\n    }\n    count ==\
    \ 1\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpuffst3qv.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823102
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if x == 1 && n == 1 {\n\
    \        return true;\n    }\n\n    let mut exponent = 0;\n    let mut res = n;\n\
    \    while res < x {\n        res *= n;\n        exponent += 1;\n    }\n\n   \
    \ res == x\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp1d1rd3ij.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823102
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if x < n || n == 0 {\n \
    \       return false;\n    }\n    let mut result = n;\n    while result <= x {\n\
    \        if result == x {\n            return true;\n        }\n        result\
    \ *= n;\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp4kqnkmjt.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823102
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    for power in 0..=x {\n \
    \       if n.pow(power) == x {\n            return true;\n        }\n    }\n \
    \   false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1vqll3mp.rs:13:18\n   |\n\
    13 |         if n.pow(power) == x {\n   |                  ^^^^^ expected `u32`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `u32` and panic if\
    \ the converted value doesn't fit\n   |\n13 |         if n.pow(power.try_into().unwrap())\
    \ == x {\n   |                  ~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659823102
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    x == n.pow(x.trailing_zeros()\
    \ as u32)\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpnnzax_r_.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823102
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    let mut val = n;\n    let\
    \ mut pow = 1;\n    while val < x {\n        val *= n;\n        pow += 1;\n  \
    \  }\n    val == x\n}\n\nfn main() {\n    let candidate = is_simple_power;\n \
    \   assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp3epjgbmi.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823102
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    let i = (x as f64).log(n\
    \ as f64);\n    let int = i.trunc();\n    int == i\n}\n\nfn main() {\n    let\
    \ candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpci3ssapd.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823102
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    let mut t = n;\n    while\
    \ t < x {\n        t *= n;\n    }\n    t == x\n}\n\nfn main() {\n    let candidate\
    \ = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpte3kfxp0.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823102
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    let mut res = 1;\n    let\
    \ mut exponent = 0;\n    while res < x {\n        res *= n;\n        exponent\
    \ += 1;\n    }\n    if res == x {\n        return true;\n    }\n    else {\n \
    \       return false;\n    }\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823102
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    let mut res = 1;\n    for\
    \ i in 1..x + 1 {\n        res *= n;\n        if res == x {\n            return\
    \ true;\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to multiply with overflow'', /tmp/tmp3x1p1hoq.rs:14:9

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823102
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    let n = n as f64;\n    let\
    \ x = x as f64;\n    let d = x.log(n);\n    d.fract() == 0.0\n}\n\nfn main() {\n\
    \    let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp2lk_bq6u.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823102
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    //assert!(n != 0);\n   \
    \ if x == 0 {\n        if n == 0 {\n            true\n        } else {\n     \
    \       false\n        }\n    } else {\n        let mut power = 1isize;\n    \
    \    for _ in 0..20 {\n            if power == x {\n                return true;\n\
    \            }\n            power *= n;\n        }\n        false\n    }\n}\n\n\
    fn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to multiply with overflow'', /tmp/tmpepibbh_o.rs:25:13

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823102
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if x == 1 { return true\
    \ }\n    let mut res = n;\n    loop {\n        if res == x { return true }\n \
    \       if res > x { return false }\n        res *= n;\n    }\n}\n\nfn main()\
    \ {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823102
