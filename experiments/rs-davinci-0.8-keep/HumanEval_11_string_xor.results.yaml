language: rs
name: HumanEval_11_string_xor
results:
- exit_code: 101
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    // TODO\n\
    \    panic!(\"TODO\")\n}\n\nfn main() {\n    let candidate = string_xor;\n   \
    \ assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''TODO'', /tmp/tmpm780707s.rs:7:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659822351
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    a.chars()\n\
    \        .zip(b.chars())\n        .map(|(c1, c2)| match (c1, c2) {\n         \
    \   ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1', '0')\
    \ => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"invalid character\"\
    ),\n        })\n        .collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822351
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut out = String::new();\n    let mut chars1 = a.chars();\n    let mut chars2\
    \ = b.chars();\n    loop {\n        match (chars1.next(), chars2.next()) {\n \
    \           (Some(c1), Some(c2)) => {\n                out.push(if c1 == c2 {\
    \ '0' } else { '1' });\n            }\n            (Some(_), None) => {\n    \
    \            panic!(\"string_xor: Inputs are not the same length!\");\n      \
    \      }\n            (None, Some(_)) => {\n                panic!(\"string_xor:\
    \ Inputs are not the same length!\");\n            }\n            (None, None)\
    \ => break,\n        }\n    }\n    out\n}\n\nfn main() {\n    let candidate =\
    \ string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822351
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (a, b) in a.chars().zip(b.chars()) {\n\
    \        result.push(match (a, b) {\n            ('0', '0') => '0',\n        \
    \    ('0', '1') => '1',\n            ('1', '0') => '1',\n            ('1', '1')\
    \ => '0',\n            _ => ' ',\n        });\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822351
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (x, y) in a.chars().zip(b.chars()) {\n\
    \        result.push(if x == y { '0' } else { '1' });\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822351
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    assert_eq!(a.len(),\
    \ b.len());\n    a.chars()\n        .zip(b.chars())\n        .map(|(a, b)| {\n\
    \            match (a, b) {\n                ('0', '0') => '0',\n            \
    \    ('0', '1') => '1',\n                ('1', '0') => '1',\n                ('1',\
    \ '1') => '0',\n                _ => panic!(\"Invalid inputs\"),\n           \
    \ }\n        })\n        .collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822351
- exit_code: 101
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    // TODO\n\
    \    unimplemented!();\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp09q1ahgh.rs:7:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659822351
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    assert_eq!(a.len(),\
    \ b.len());\n    assert!(a.chars().all(|x| x == '0' || x == '1'));\n    assert!(b.chars().all(|x|\
    \ x == '0' || x == '1'));\n\n    let a = a.chars().map(|x| x == '1').collect::<Vec<_>>();\n\
    \    let b = b.chars().map(|x| x == '1').collect::<Vec<_>>();\n\n    a.iter()\n\
    \        .zip(b.iter())\n        .map(|(&x, &y)| if x ^ y { '1' } else { '0' })\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822351
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ a_bytes = a.as_bytes();\n    let b_bytes = b.as_bytes();\n    let mut result\
    \ = String::new();\n    for (i, j) in a_bytes.iter().zip(b_bytes.iter()) {\n \
    \       result.push(if *i == *j { '0' } else { '1' });\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822351
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (a, b) in a.chars().zip(b.chars()) {\n\
    \        result.push(if a == b {\n            '0'\n        } else {\n        \
    \    '1'\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822351
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ char_vec_a: Vec<u8> = a.chars().map(|c| c.to_digit(10).unwrap() as u8).collect();\n\
    \    let char_vec_b: Vec<u8> = b.chars().map(|c| c.to_digit(10).unwrap() as u8).collect();\n\
    \    let char_vec_c: Vec<u8> = char_vec_a.iter().zip(char_vec_b.iter()).map(|(x,\
    \ y)| *x ^ *y).collect();\n    let string_c: String = char_vec_c.iter().map(|c|\
    \ c.to_string()).collect();\n    string_c\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822351
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for pair in a.chars().zip(b.chars()) {\n  \
    \      match pair {\n            (x, y) if x == y => result.push('0'),\n     \
    \       _ => result.push('1'),\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822351
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (ac, bc) in a.chars().zip(b.chars()) {\n\
    \        if ac == bc {\n            result.push('0');\n        } else {\n    \
    \        result.push('1');\n        }\n    }\n    result\n}\n\nfn main() {\n \
    \   let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822351
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    assert_eq!(a.len(),\
    \ b.len());\n    let mut res = String::new();\n    for i in 0..a.len() {\n   \
    \     if a.chars().nth(i).unwrap() == b.chars().nth(i).unwrap() {\n          \
    \  res.push('0');\n        } else {\n            res.push('1');\n        }\n \
    \   }\n    res\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822351
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (i, j) in a.chars().zip(b.chars()) {\n\
    \        result.push(match (i, j) {\n            ('0', '0') => '0',\n        \
    \    ('0', '1') => '1',\n            ('1', '0') => '1',\n            ('1', '1')\
    \ => '0',\n            _ => ' ',\n        });\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822351
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    let mut a: Vec<char> = a.chars().collect();\n\
    \    let mut b: Vec<char> = b.chars().collect();\n    if a.len() < b.len() {\n\
    \        let offset = b.len() - a.len();\n        for _ in 0..offset {\n     \
    \       a.insert(0, '0');\n        }\n    } else if a.len() > b.len() {\n    \
    \    let offset = a.len() - b.len();\n        for _ in 0..offset {\n         \
    \   b.insert(0, '0');\n        }\n    }\n    for i in 0..a.len() {\n        let\
    \ x = if a[i] == '1' {\n            1\n        } else {\n            0\n     \
    \   };\n        let y = if b[i] == '1' {\n            1\n        } else {\n  \
    \          0\n        };\n        result.push_str(&(x ^ y).to_string());\n   \
    \ }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822351
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ mut result = String::new();\n    for (x, y) in a.chars().zip(b.chars()) {\n\
    \        result.push(if x == y { '0' } else { '1' });\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822351
- exit_code: 101
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    let\
    \ x: u32 = u32::from_str_radix(&a, 2).unwrap();\n    let y: u32 = u32::from_str_radix(&b,\
    \ 2).unwrap();\n    let z: u32 = x ^ y;\n    format!(\"{:b}\", z)\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"10010\"`,\n right: `\"010010\"`', /tmp/tmplgmoy_a1.rs:14:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822351
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    // Convert\
    \ each char to an integer\n    let x: Vec<u8> = a.chars().map(|c| c.to_digit(10).unwrap()\
    \ as u8).collect();\n    let y: Vec<u8> = b.chars().map(|c| c.to_digit(10).unwrap()\
    \ as u8).collect();\n\n    // Check that the two strings are the same length\n\
    \    if x.len() != y.len() {\n        panic!(\"Strings not the same length\")\n\
    \    }\n\n    // Calculate the xor\n    let z: Vec<u8> = x.iter().zip(y.iter()).map(|(a,\
    \ b)| a ^ b).collect();\n\n    // Convert each integer to a char\n    z.iter().map(|&i|\
    \ char::from_digit(i as u32, 10).unwrap()).collect()\n}\n\nfn main() {\n    let\
    \ candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"),\
    \ String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822351
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
    \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n    // When\
    \ both a and b are the same, the XOR result is 0.\n    // If a is 0 and b is 1,\
    \ the XOR result is 1.\n    // If a is 1 and b is 0, the XOR result is 1.\n  \
    \  let mut result = String::from(\"\");\n    let a_bytes = a.as_bytes();\n   \
    \ let b_bytes = b.as_bytes();\n    if a_bytes.len() != b_bytes.len() {\n     \
    \   panic!(\"Invalid inputs. Different lengths\");\n    }\n    for i in 0..a_bytes.len()\
    \ {\n        if a_bytes[i] == b'0' && b_bytes[i] == b'0' {\n            result.push('0');\n\
    \        } else if a_bytes[i] == b'0' && b_bytes[i] == b'1' {\n            result.push('1');\n\
    \        } else if a_bytes[i] == b'1' && b_bytes[i] == b'0' {\n            result.push('1');\n\
    \        } else if a_bytes[i] == b'1' && b_bytes[i] == b'1' {\n            result.push('0');\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822351
