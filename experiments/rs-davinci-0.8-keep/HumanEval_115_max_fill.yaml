name: HumanEval_115_max_fill
language: rs
prompt: "/// You are given a rectangular grid of wells. Each row represents a single\
  \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each well\
  \ has a corresponding bucket that can be used to extract water from it, \n/// and\
  \ all buckets have the same capacity.\n/// Your task is to use the buckets to empty\
  \ the wells.\n/// Output the number of times you need to lower the buckets.\n///\
  \ Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n/// bucket_capacity\
  \ : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid : [[0,0,1,1], [0,0,0,0],\
  \ [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output: 5\n/// Example 3:\n\
  /// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity : 5\n/// Output:\
  \ 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <= grid.length\
  \ <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// *\
  \ 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize\
  \ {\n"
tests: "}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
  \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
  \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n   \
  \ assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
  \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1,\
  \ 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
completions: ["    let rows = grid.len();\n    let cols = grid[0].len();\n    let\
    \ mut grid = grid;\n    let mut count = 0;\n    while let Some(row) = grid.iter().position(|r|\
    \ r.iter().any(|&v| v == 1)) {\n        for c in 0..cols {\n            let mut\
    \ extracted = capacity;\n            let mut r = row;\n            while extracted\
    \ > 0 && r < rows {\n                if grid[r][c] == 1 {\n                  \
    \  grid[r][c] = 0;\n                    extracted -= 1;\n                }\n \
    \               r += 1;\n            }\n        }\n        count += 1;\n    }\n\
    \    count", "    grid.iter().fold(0, |acc, row| {\n        let mut sum = 0;\n\
    \        for &value in row {\n            sum += value;\n            if sum >\
    \ capacity {\n                acc += sum - capacity;\n                sum = capacity;\n\
    \            }\n        }\n        acc\n    })", "    let mut max = 0;\n    for\
    \ row in grid {\n        for &col in &row {\n            max = max.max(col);\n\
    \        }\n    }\n    let mut ans = 0;\n    for row in grid {\n        for &col\
    \ in &row {\n            if col != max {\n                ans += (max - col).abs();\n\
    \            }\n        }\n    }\n    ans", "    // lowest depth of non-empty\
    \ wells in each column\n    let mut depths = vec![0; grid[0].len()];\n    for\
    \ i in 0..grid.len() {\n        for j in 0..grid[i].len() {\n            if grid[i][j]\
    \ == 1 {\n                depths[j] = i + 1;\n            }\n        }\n    }\n\
    \    let mut count = 0;\n    let mut water = 0;\n    let mut i = 0;\n    while\
    \ i < depths.len() {\n        let mut j = i;\n        // go left until either\
    \ at the end of the well or reached non-empty\n        while j > 0 && depths[j\
    \ - 1] >= depths[j] {\n            j -= 1;\n        }\n        let row = depths[j];\n\
    \        let mut col = 0;\n        while j < depths.len() && depths[j] >= row\
    \ {\n            // collect water\n            water += row - grid[row - 1][j];\n\
    \            if water < 0 {\n                water = 0;\n            }\n     \
    \       if water > capacity {\n                count += 1;\n                water\
    \ = 0;\n            }\n            // move to next column\n            col +=\
    \ 1;\n            j += 1;\n        }\n        i = j;\n    }\n    count", "   \
    \ let m = grid.len();\n    let n = grid[0].len();\n    let mut water = vec![0;\
    \ m];\n    for row in grid {\n        for (i, &cell) in row.iter().enumerate()\
    \ {\n            water[i] += cell;\n        }\n    }\n    water.sort();\n    let\
    \ mut l = 0;\n    let mut r = capacity * m;\n    while l < r {\n        let h\
    \ = (l + r) / 2;\n        let mut moves = 0;\n        for water in water.iter()\
    \ {\n            moves += (water + h - 1) / h - 1;\n        }\n        if moves\
    \ > capacity {\n            l = h + 1;\n        } else {\n            r = h;\n\
    \        }\n    }\n    m * capacity - l", "    let mut iter = grid.iter().cloned();\n\
    \    let mut res = 0;\n    while let Some(row) = iter.next() {\n        let mut\
    \ it = row.iter().cloned();\n        while let Some(elem) = it.next() {\n    \
    \        res += if elem < capacity {\n                elem\n            } else\
    \ {\n                capacity\n            };\n        }\n    }\n    res", " \
    \   let n = grid.len();\n    let m = grid[0].len();\n    let mut max_row = grid.iter().fold(0,\
    \ |m, row| {\n        row.iter().sum::<isize>().max(m)\n    });\n    let mut count\
    \ = 0;\n    while max_row > 0 {\n        count += max_row;\n        for row in\
    \ &mut grid {\n            for i in 0..m {\n                if row[i] > 0 {\n\
    \                    row[i] -= 1;\n                }\n            }\n        }\n\
    \        max_row = grid.iter().fold(0, |m, row| {\n            row.iter().sum::<isize>().max(m)\n\
    \        });\n    }\n    count", "    let rows = grid.len();\n    let cols = grid[0].len();\n\
    \    let mut total = 0;\n    for row in grid {\n        for col in row {\n   \
    \         total += col;\n        }\n    }\n    if total == 0 {\n        return\
    \ 0;\n    }\n    if total < capacity {\n        return total;\n    }\n    let\
    \ mut i = 0;\n    let mut j = 0;\n    let mut filled = 0;\n    let mut moves =\
    \ 0;\n    loop {\n        if i < rows {\n            if j < cols {\n         \
    \       if grid[i][j] == 1 {\n                    filled += 1;\n             \
    \       grid[i][j] = 0;\n                }\n                j += 1;\n        \
    \    } else {\n                i += 1;\n                j = 0;\n            }\n\
    \        } else {\n            i = 0;\n            j = 0;\n            moves +=\
    \ 1;\n            if filled == total {\n                break;\n            }\n\
    \            total -= filled;\n            filled = 0;\n        }\n    }\n   \
    \ moves", "    // iterate column by column, to find the max water in each well\n\
    \    let mut count = 0;\n    for j in 0..grid[0].len() {\n        let mut sum\
    \ = 0;\n        for i in 0..grid.len() {\n            sum += grid[i][j];\n   \
    \         // when sum reaches the capacity,\n            // update the count,\
    \ and reset the sum to 0\n            if sum == capacity {\n                count\
    \ += 1;\n                sum = 0;\n            }\n        }\n        // if there\
    \ is still water left, empty the well\n        if sum > 0 {\n            count\
    \ += 1;\n        }\n    }\n    count", "    let mut pile = 0;\n    let mut count\
    \ = 0;\n    for row in grid {\n        for well in row {\n            let fill\
    \ = well + pile;\n            count += fill / capacity;\n            pile = fill\
    \ % capacity;\n        }\n    }\n    count", "    let row_count = grid.len();\n\
    \    let col_count = grid[0].len();\n    let mut wells = vec![];\n    for i in\
    \ 0..row_count {\n        let mut count = 0;\n        for j in 0..col_count {\n\
    \            if grid[i][j] == 1 {\n                count += 1;\n            }\n\
    \        }\n        wells.push(count);\n    }\n    let mut result = 0;\n    for\
    \ w in wells {\n        let bucket_count = w / capacity;\n        result += bucket_count;\n\
    \        if w % capacity != 0 {\n            result += 1;\n        }\n    }\n\
    \    result", "    use std::cmp::min;\n    let mut grid = grid;\n    let (rows,\
    \ cols) = (grid.len(), grid[0].len());\n    let mut count = 0;\n    for i in 0..rows\
    \ {\n        for j in 0..cols {\n            if grid[i][j] == 1 {\n          \
    \      grid[i][j] = 0;\n                count += 1;\n            }\n        }\n\
    \    }\n    // The naive approach to this problem is to try to fill all buckets\
    \ in a row\n    // one by one until they are full, then drop the buckets and start\
    \ over on the\n    // next row.\n    //\n    // This, however, is inefficient\
    \ as it is possible to fill a bucket in the\n    // next row without filling all\
    \ the buckets in the current row.\n    //\n    // While we have not found the\
    \ optimal solution, this algorithm will always\n    // find a solution that is\
    \ no worse than twice the optimal.\n    //\n    // The idea here is to use a priority\
    \ queue to order the buckets to be filled.\n    // Instead of filling from left\
    \ to right and top to bottom, we fill from\n    // the top left and move towards\
    \ the bottom right.\n    //\n    // A bucket's priority is the sum of the difference\
    \ between the current height\n    // and the optimal height of the bucket and\
    \ the current height and the optimal\n    // height of the bucket above it.\n\
    \    //\n    // We begin by emptying all of the buckets, adding them to the priority\
    \ queue\n    // and setting the heights to the capacity of a bucket.\n    //\n\
    \    // We then pop off a bucket and fill it. If it is full, we add the bucket\
    \ below\n    // to the priority queue. If not, we add the current bucket back\
    \ to the queue.\n    //\n    // We continue this process until all buckets have\
    \ been emptied.\n    //\n    // See the examples below for a better explanation\
    \ of how this works.\n    let mut pq = Heap::new();\n    for i in 0..rows {\n\
    \        for j in 0..cols {\n            pq.push(Cell {\n                row:\
    \ i,\n                col: j,\n                capacity: capacity,\n         \
    \       priority: rows as isize + cols as isize -", "    if grid.is_empty() ||\
    \ grid[0].is_empty() {\n        return 0;\n    }\n    let h = grid.len();\n  \
    \  let w = grid[0].len();\n    let mut total = 0;\n    let mut level = 0;\n  \
    \  let mut to_fill = 0;\n    loop {\n        let mut full = true;\n        for\
    \ i in 0..h {\n            for j in 0..w {\n                if grid[i][j] > level\
    \ {\n                    full = false;\n                    to_fill += 1;\n  \
    \              }\n            }\n        }\n        if full {\n            break;\n\
    \        }\n        level += 1;\n        if to_fill > capacity {\n           \
    \ total += 1;\n            to_fill = 0;\n        }\n    }\n    total + (to_fill\
    \ + capacity - 1) / capacity", "    let mut result = 0;\n    for row in grid {\n\
    \        let mut lowered = 0;\n        for &cell in &row {\n            let fill\
    \ = cell - lowered;\n            if fill > 0 {\n                lowered += fill;\n\
    \                result += 1;\n            }\n            if lowered >= capacity\
    \ {\n                lowered = capacity;\n                result += 1;\n     \
    \       }\n        }\n        if lowered > 0 {\n            result += 1;\n   \
    \     }\n    }\n    result", "    let mut result = 0;\n    let m = grid.len();\n\
    \    let n = grid[0].len();\n    for i in 0..m {\n        for j in 0..n {\n  \
    \          if grid[i][j] == 1 {\n                result += 1;\n            }\n\
    \        }\n    }\n    let mut q = VecDeque::new();\n    for i in 0..m {\n   \
    \     for j in 0..n {\n            if grid[i][j] == 1 {\n                grid[i][j]\
    \ = -1;\n                q.push_back((i, j));\n                break;\n      \
    \      }\n        }\n    }\n    while !q.is_empty() {\n        let (x, y) = q.pop_front().unwrap();\n\
    \        let mut d = capacity;\n        while d > 0 {\n            d -= 1;\n \
    \           if x > 0 && grid[x - 1][y] == 1 {\n                q.push_back((x\
    \ - 1, y));\n                grid[x - 1][y] = -1;\n                result -= 1;\n\
    \            }\n            if x < m - 1 && grid[x + 1][y] == 1 {\n          \
    \      q.push_back((x + 1, y));\n                grid[x + 1][y] = -1;\n      \
    \          result -= 1;\n            }\n            if y > 0 && grid[x][y - 1]\
    \ == 1 {\n                q.push_back((x, y - 1));\n                grid[x][y\
    \ - 1] = -1;\n                result -= 1;\n            }\n            if y <\
    \ n - 1 && grid[x][y + 1] == 1 {\n                q.push_back((x, y + 1));\n \
    \               grid[x][y + 1] = -1;\n                result -= 1;\n         \
    \   }\n        }\n    }\n    result", "    let m = grid.len();\n    let n = grid[0].len();\n\
    \    let mut ret = 0;\n    let mut wells = vec![];\n    for i in 0..m {\n    \
    \    let mut sum = 0;\n        for j in 0..n {\n            sum += grid[i][j];\n\
    \        }\n        wells.push(sum);\n    }\n    for well in wells {\n       \
    \ let overflow = (well - capacity).max(0);\n        ret += overflow;\n       \
    \ capacity -= overflow;\n    }\n    ret", "    let mut ymax = 0;\n    let mut\
    \ xmax = 0;\n    for row in grid.iter() {\n        ymax = cmp::max(ymax, row.len());\n\
    \        for &x in row.iter() {\n            xmax = cmp::max(xmax, x);\n     \
    \   }\n    }\n    let grid_w = grid.len();\n    let mut fill_ct = 0;\n    for\
    \ x in 0..xmax {\n        for y in 0..ymax {\n            if grid[y][x] == 1 {\n\
    \                fill_ct += 1;\n            }\n        }\n    }\n    fill_ct",
  "    let row_size = grid.len();\n    let col_size = grid[0].len();\n    let mut\
    \ count = 0;\n    for i in 0..row_size {\n        for j in 0..col_size {\n   \
    \         if grid[i][j] == 1 {\n                for k in 0..row_size {\n     \
    \               for l in 0..col_size {\n                        if grid[k][l]\
    \ == 1 {\n                            count += (1 + (i - k).abs() + (j - l).abs())\
    \ as isize;\n                        }\n                    }\n              \
    \  }\n            }\n        }\n    }\n    count / capacity", "    let mut wells\
    \ = grid.len();\n    let mut min_fill = 0;\n    let mut max_fill = grid.iter().fold(0,\
    \ |acc, row| acc + row.iter().sum::<isize>());\n    while min_fill <= max_fill\
    \ {\n        let fill = (min_fill + max_fill) / 2;\n        let mut filled = 0;\n\
    \        let mut refilled = 0;\n        for row in grid.iter() {\n           \
    \ filled += row.iter().sum::<isize>();\n            if filled >= fill {\n    \
    \            filled = fill;\n            } else {\n                wells -= 1;\n\
    \                refilled += fill - filled;\n                filled = fill;\n\
    \            }\n            filled -= capacity;\n            if filled < 0 {\n\
    \                filled = 0;\n            }\n        }\n        if wells == 0\
    \ {\n            if refilled == 0 {\n                return fill;\n          \
    \  }\n            min_fill = fill + 1;\n        } else {\n            max_fill\
    \ = fill - 1;\n        }\n    }\n    max_fill", "    let mut times = 0;\n    let\
    \ width = grid[0].len();\n    let height = grid.len();\n    let mut i = 0;\n \
    \   while i < height {\n        let mut filled = 0;\n        for j in 0..width\
    \ {\n            if grid[i][j] == 1 {\n                filled += 1;\n        \
    \    }\n        }\n        if filled > 0 {\n            let t = (filled - 1) /\
    \ capacity + 1;\n            times += t;\n            i += t as usize;\n     \
    \   } else {\n            i += 1;\n        }\n    }\n    times"]
stop_tokens:
- "\n}"
