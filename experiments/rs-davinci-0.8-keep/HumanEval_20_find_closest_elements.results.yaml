name: HumanEval_20_find_closest_elements
language: rs
results:
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min = std::f64::MAX;\n    let mut min_nums = (0.0,\
    \ 0.0);\n    for pair in numbers.windows(2) {\n        let diff = (pair[0] - pair[1]).abs();\n\
    \        if diff < min {\n            min = diff;\n            min_nums = (pair[0],\
    \ pair[1]);\n        }\n    }\n    if min_nums.0 > min_nums.1 {\n        (min_nums.1,\
    \ min_nums.0)\n    } else {\n        min_nums\n    }\n}\n\nfn main() {\n    let\
    \ candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(1.0, 2.0)`,\n right: `(5.0, 5.9)`', /tmp/tmp45izes34.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut smallest = f64::INFINITY;\n    let mut closest_pair\
    \ = (0f64, 0f64);\n    let mut sorted_numbers = numbers.clone();\n    sorted_numbers.sort_by(|a,\
    \ b| a.partial_cmp(b).unwrap());\n    for i in 0..sorted_numbers.len() - 1 {\n\
    \        let temp = sorted_numbers[i] - sorted_numbers[i + 1];\n        if temp.abs()\
    \ < smallest {\n            smallest = temp.abs();\n            closest_pair =\
    \ (sorted_numbers[i], sorted_numbers[i + 1]);\n        }\n    }\n    closest_pair\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut smallest = 0;\n    let mut largest = 1;\n    let\
    \ mut closest = numbers[1] - numbers[0];\n    for i in 1..numbers.len() {\n  \
    \      for j in i + 1..numbers.len() {\n            let gap = numbers[j] - numbers[i];\n\
    \            if gap < closest {\n                smallest = i;\n             \
    \   largest = j;\n                closest = gap;\n            }\n        }\n \
    \   }\n    (numbers[smallest], numbers[largest])\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmp9zuxs8y3.rs:26:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements: (f64, f64) = (0f64, 0f64);\n\
    \    let mut closest_difference: f64 = 0f64;\n    if numbers.len() >= 2 {\n  \
    \      for i in 0..numbers.len() - 1 {\n            for j in i + 1..numbers.len()\
    \ {\n                let difference = (numbers[i] - numbers[j]).abs();\n     \
    \           if i == 0 && j == 1 {\n                    closest_difference = difference;\n\
    \                    closest_elements = (numbers[i], numbers[j]);\n          \
    \      } else if difference < closest_difference {\n                    closest_difference\
    \ = difference;\n                    closest_elements = (numbers[i], numbers[j]);\n\
    \                }\n            }\n        }\n    }\n    closest_elements\n}\n\
    \nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpl2b2w6hf.rs:30:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    // find the two closest\n    let mut closest: (f64, f64)\
    \ = (0.0, 0.0);\n    let mut closest_distance: f64 = f64::MAX;\n    for i in 0..numbers.len()\
    \ {\n        for j in 0..numbers.len() {\n            if i != j {\n          \
    \      let distance = (numbers[i] - numbers[j]).abs();\n                if distance\
    \ < closest_distance {\n                    closest = (numbers[i], numbers[j]);\n\
    \                    closest_distance = distance;\n                }\n       \
    \     }\n        }\n    }\n    closest\n}\n\nfn main() {\n    let candidate =\
    \ find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]),\
    \ (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]),\
    \ (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]),\
    \ (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2,\
    \ 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpypna83wv.rs:28:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp08f5ljag.rs:8:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_diff = numbers[1] - numbers[0];\n    let mut\
    \ min_elements = (numbers[0], numbers[1]);\n    for idx in 1..numbers.len() {\n\
    \        let diff = numbers[idx] - numbers[idx - 1];\n        if diff < min_diff\
    \ {\n            min_diff = diff;\n            min_elements = (numbers[idx - 1],\
    \ numbers[idx]);\n        }\n    }\n    return min_elements;\n}\n\nfn main() {\n\
    \    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmp4h8vbz52.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    // TODO\n    (0f64, 0f64)\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(0.0, 0.0)`,\n right: `(3.9, 4.0)`', /tmp/tmplvbn77da.rs:14:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_distance = std::f64::MAX;\n    let mut result:\
    \ (f64, f64) = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in\
    \ 0..numbers.len() {\n            if numbers[i] != numbers[j] {\n            \
    \    let distance = (numbers[i] - numbers[j]).abs();\n                if distance\
    \ < min_distance {\n                    min_distance = distance;\n           \
    \         result = (numbers[i], numbers[j]);\n                }\n            }\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpkoheru8y.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut min_distance = std::f64::MAX;\n    let mut min_distance_numbers\
    \ = (0.0, 0.0);\n    for (i, x) in numbers.iter().enumerate() {\n        for y\
    \ in numbers.iter().skip(i) {\n            let d = x - y;\n            if d.abs()\
    \ < min_distance {\n                min_distance = d.abs();\n                min_distance_numbers\
    \ = (*x, *y);\n            }\n        }\n    }\n    min_distance_numbers\n}\n\n\
    fn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(1.0, 1.0)`,\n right: `(3.9, 4.0)`', /tmp/tmpr264awiv.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = f64::abs(closest_elements.0 - closest_elements.1);\n\
    \    for i in 0..numbers.len() - 1 {\n        for j in i + 1..numbers.len() {\n\
    \            let distance = f64::abs(numbers[i] - numbers[j]);\n            if\
    \ distance < closest_distance {\n                closest_distance = distance;\n\
    \                closest_elements = (numbers[i], numbers[j]);\n            }\n\
    \        }\n    }\n    closest_elements\n}\n\nfn main() {\n    let candidate =\
    \ find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]),\
    \ (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]),\
    \ (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]),\
    \ (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2,\
    \ 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpcl690g5q.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    (1.0, 2.0)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(1.0, 2.0)`,\n right: `(3.9, 4.0)`', /tmp/tmptlvsj_ze.rs:13:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut distances: Vec<(f64, f64)> = Vec::new();\n    let\
    \ mut smallest_distance: f64 = std::f64::MAX;\n    let mut closest_pair: (f64,\
    \ f64) = (std::f64::MAX, std::f64::MAX);\n\n    if numbers.len() < 2 {\n     \
    \   panic!(\"Need at least two numbers!\");\n    }\n\n    if numbers.len() ==\
    \ 2 {\n        closest_pair = (numbers[0], numbers[1]);\n    } else {\n      \
    \  for i in 0..numbers.len() - 1 {\n            for j in i + 1..numbers.len()\
    \ {\n                distances.push((numbers[i], numbers[j]));\n            }\n\
    \        }\n\n        for distance in distances {\n            let abs = (distance.0\
    \ - distance.1).abs();\n            if abs < smallest_distance {\n           \
    \     smallest_distance = abs;\n                closest_pair = distance;\n   \
    \         }\n        }\n    }\n\n    closest_pair\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpre956iji.rs:40:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut mut_numbers = numbers;\n    mut_numbers.sort_by(|a,\
    \ b| a.partial_cmp(b).unwrap());\n    let mut first_number = mut_numbers[0];\n\
    \    let mut second_number = mut_numbers[1];\n    let mut diff = second_number\
    \ - first_number;\n    for i in 1..mut_numbers.len() {\n        let current_diff\
    \ = mut_numbers[i] - mut_numbers[i - 1];\n        if current_diff < diff {\n \
    \           diff = current_diff;\n            first_number = mut_numbers[i - 1];\n\
    \            second_number = mut_numbers[i];\n        }\n    }\n    (first_number,\
    \ second_number)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut sorted_numbers = numbers.clone();\n    sorted_numbers.sort_by(|a,\
    \ b| a.partial_cmp(b).unwrap());\n    let mut min_diff = f64::MAX;\n    let mut\
    \ min_diff_pair = (sorted_numbers[0], sorted_numbers[1]);\n    for i in 0..sorted_numbers.len()\
    \ - 1 {\n        let diff = sorted_numbers[i + 1] - sorted_numbers[i];\n     \
    \   if diff < min_diff {\n            min_diff = diff;\n            min_diff_pair\
    \ = (sorted_numbers[i], sorted_numbers[i + 1]);\n        }\n    }\n    min_diff_pair\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n    let\
    \ mut closest_diff = closest_pair.1 - closest_pair.0;\n    let mut current_pair\
    \ = (numbers[0], numbers[1]);\n    let mut current_diff = closest_diff;\n    for\
    \ i in 0..numbers.len() {\n        for j in i+1..numbers.len() {\n           \
    \ current_pair = (numbers[i], numbers[j]);\n            current_diff = current_pair.1\
    \ - current_pair.0;\n            if current_diff < closest_diff {\n          \
    \      closest_pair = current_pair;\n                closest_diff = current_diff;\n\
    \            }\n        }\n    }\n    closest_pair\n}\n\nfn main() {\n    let\
    \ candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpdalxn5qy.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut numbers = numbers;\n    numbers.sort_by(|a, b|\
    \ a.partial_cmp(b).unwrap());\n    let mut closest_pair = (numbers[0], numbers[1]);\n\
    \    let mut smallest_difference = numbers[1] - numbers[0];\n    for x in 0..numbers.len()\
    \ - 1 {\n        let current_difference = numbers[x + 1] - numbers[x];\n     \
    \   if current_difference < smallest_difference {\n            closest_pair =\
    \ (numbers[x], numbers[x + 1]);\n            smallest_difference = current_difference;\n\
    \        }\n    }\n    closest_pair\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate =\
    \ find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]),\
    \ (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]),\
    \ (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]),\
    \ (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2,\
    \ 3.1));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpujj_3euq.rs:8:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut numbers = numbers;\n    numbers.sort_by(|a, b|\
    \ a.partial_cmp(b).unwrap());\n    let mut closest_difference = f64::INFINITY;\n\
    \    let mut diff = 0.0;\n    let mut closest_pair = (0.0, 0.0);\n    for i in\
    \ 0..numbers.len() - 1 {\n        diff = numbers[i + 1] - numbers[i];\n      \
    \  if diff < closest_difference {\n            closest_difference = diff;\n  \
    \          closest_pair = (numbers[i], numbers[i + 1]);\n        }\n    }\n  \
    \  closest_pair\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>)\
    \ -> (f64, f64) {\n    let mut sorted_numbers = numbers.clone();\n    sorted_numbers.sort_by(|a,\
    \ b| a.partial_cmp(b).unwrap());\n    let mut numbers_iter = sorted_numbers.iter();\n\
    \    let mut closest_pair = (numbers_iter.next().unwrap(), numbers_iter.next().unwrap());\n\
    \    let mut smallest_difference = closest_pair.1 - closest_pair.0;\n    for number\
    \ in numbers_iter {\n        let (lower, upper) = closest_pair;\n        let difference\
    \ = *number - upper;\n        if difference < smallest_difference {\n        \
    \    closest_pair = (upper, number);\n            smallest_difference = difference;\n\
    \        }\n    }\n    closest_pair\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_mup4b2k.rs:21:5\n   |\n\
    7  | fn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n   |       \
    \                                         ---------- expected `(f64, f64)` because\
    \ of return type\n...\n21 |     closest_pair\n   |     ^^^^^^^^^^^^ expected `f64`,\
    \ found `&f64`\n   |\n   = note: expected tuple `(f64, f64)`\n              found\
    \ tuple `(&f64, &f64)`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
