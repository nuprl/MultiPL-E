name: HumanEval_75_is_multiply_prime
language: rs
prompt: "/// Write a function that returns true if the given number is the multiplication\
  \ of 3 prime numbers\n/// and false otherwise.\n/// Knowing that (a) is less then\
  \ 100. \n/// Example:\n/// is_multiply_prime(30) == True\n/// 30 = 2 * 3 * 5\nfn\
  \ is_multiply_prime(a: isize) -> bool {\n"
tests: "}\n\nfn main() {\n    let candidate = is_multiply_prime;\n    assert_eq!(candidate(5),\
  \ false);\n    assert_eq!(candidate(30), true);\n    assert_eq!(candidate(8), true);\n\
  \    assert_eq!(candidate(10), false);\n    assert_eq!(candidate(125), true);\n\
  \    assert_eq!(candidate(105), true);\n    assert_eq!(candidate(126), false);\n\
  \    assert_eq!(candidate(729), false);\n    assert_eq!(candidate(891), false);\n\
  \    assert_eq!(candidate(1001), true);\n}\n"
completions: ["    // TODO\n    false", '    return false;', '    unimplemented!()',
  "    let mut res = false;\n    for x in 1..a {\n        for y in 1..a {\n      \
    \      for z in 1..a {\n                if x * y * z == a && is_prime(x) && is_prime(y)\
    \ && is_prime(z) {\n                    res = true;\n                }\n     \
    \       }\n        }\n    }\n    res", "    let mut count: usize = 0;\n    for\
    \ i in 2..a {\n        if is_prime(i) && a % i == 0 {\n            count += 1;\n\
    \        }\n    }\n    count == 3", "    let divisors: Vec<isize> = (2..=a).filter(|x|\
    \ a % x == 0).collect();\n    if divisors.len() < 3 {\n        return false;\n\
    \    }\n    let mut sum = 1;\n    for i in 0..3 {\n        sum *= divisors[i];\n\
    \    }\n    return sum == a;", '    unimplemented!()', '    unimplemented!();',
  "    // b != c != d\n    let b = 2;\n    let c = 3;\n    let d = 5;\n    a == b\
    \ * c * d", '    false', "    let mut is_prime = false;\n    let _ = (1..a).filter(|&x|\
    \ is_prime = a%x == 0).collect::<Vec<isize>>();\n    if is_prime {\n        return\
    \ false;\n    }\n\n    let mut count = 1;\n    let mut a_copy = a;\n    for x\
    \ in 2..a {\n        if a_copy % x == 0 {\n            a_copy /= x;\n        \
    \    count += 1;\n        }\n        if count == 3 {\n            break;\n   \
    \     }\n    }\n    count == 3", "    for i in 2..a {\n        if a % i == 0 {\n\
    \            if is_prime(i) {\n                let tmp = a / i;\n            \
    \    for j in 2..tmp {\n                    if tmp % j == 0 {\n              \
    \          if is_prime(j) {\n                            if is_prime(tmp / j)\
    \ {\n                                return true;\n                          \
    \  }\n                        }\n                    }\n                }\n  \
    \          }\n        }\n    }\n    false", "    // TODO\n    true", "    if a\
    \ == 3 {\n        return true;\n    }\n    let mut n = a;\n    while n % 2 ==\
    \ 0 {\n        n /= 2;\n    }\n    while n % 3 == 0 {\n        n /= 3;\n    }\n\
    \    while n % 5 == 0 {\n        n /= 5;\n    }\n    if n == 1 {\n        return\
    \ true;\n    }\n    for i in 2..(a / 2) {\n        if a % i == 0 {\n         \
    \   return false;\n        }\n    }\n    return true;", '    unimplemented!();',
  '    unimplemented!()', '    unimplemented!()', '    unimplemented!()', "    let\
    \ mut primes = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut res = 1;\n    let mut i =\
    \ 0;\n    while i < primes.len() && res != a {\n        if a % primes[i] == 0\
    \ {\n            res *= primes[i];\n        }\n        i += 1;\n    }\n    res\
    \ == a", "    let mut a = a;\n    let mut num = 2;\n    let mut primes = Vec::new();\n\
    \    while a > 1 {\n        while a % num == 0 {\n            primes.push(num);\n\
    \            a /= num;\n        }\n        num += 1;\n    }\n    if primes.len()\
    \ == 3 {\n        return true;\n    }\n    return false;"]
stop_tokens:
- "\n}"
