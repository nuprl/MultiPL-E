name: HumanEval_136_largest_smallest_integers
language: rs
prompt: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
  \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
  \ in a list.\n/// If there is no negative or positive integers, return them as None.\n\
  /// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n\
  /// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
  \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
  \ Option<isize>) {\n"
tests: "}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
  \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
  \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
  \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
  \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
  \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None, None));\n\
  \    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
  \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5, -6,\
  \ 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]), (Some(-3),\
  \ Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]), (Some(-3),\
  \ Some(1)));\n}\n"
completions: ["    let mut neg_max = None;\n    let mut pos_min = None;\n    for el\
    \ in lst {\n        if el < 0 {\n            if let Some(max) = neg_max {\n  \
    \              if el > max {\n                    neg_max = Some(el);\n      \
    \          }\n            } else {\n                neg_max = Some(el);\n    \
    \        }\n        } else if el > 0 {\n            if let Some(min) = pos_min\
    \ {\n                if el < min {\n                    pos_min = Some(el);\n\
    \                }\n            } else {\n                pos_min = Some(el);\n\
    \            }\n        }\n    }\n    (neg_max, pos_min)", '    unimplemented!()',
  "    let mut neg = None;\n    let mut pos = None;\n    for x in lst {\n        if\
    \ x < 0 {\n            neg = Some(neg.map_or(x, |n| cmp::max(n, x)));\n      \
    \  } else if x > 0 {\n            pos = Some(pos.map_or(x, |p| cmp::min(p, x)));\n\
    \        }\n    }\n    (neg, pos)", '    unimplemented!();', "    // unimplemented!()\n\
    \    // let mut neg: Option<isize> = None;\n    // let mut pos: Option<isize>\
    \ = None;\n    // for i in lst {\n    //     if i < 0 {\n    //         neg =\
    \ match neg {\n    //             Some(x) => Some(std::cmp::max(x, i)),\n    //\
    \             None => Some(i),\n    //         }\n    //     } else if i > 0 {\n\
    \    //         pos = match pos {\n    //             Some(x) => Some(std::cmp::min(x,\
    \ i)),\n    //             None => Some(i),\n    //         }\n    //     }\n\
    \    // }\n    // (neg, pos)\n    (\n        lst.iter().filter(|&x| x < &0).max().map(|x|\
    \ *x),\n        lst.iter().filter(|&x| x > &0).min().map(|x| *x),\n    )", " \
    \   let mut max = None;\n    let mut min = None;\n    for i in lst {\n       \
    \ if max.is_none() && i < 0 {\n            max = Some(i);\n        } else if i\
    \ < 0 && i > max.unwrap() {\n            max = Some(i);\n        }\n        if\
    \ min.is_none() && i > 0 {\n            min = Some(i);\n        } else if i >\
    \ 0 && i < min.unwrap() {\n            min = Some(i);\n        }\n    }\n    (max,\
    \ min)", '    unimplemented!()', '    unimplemented!()', "    (\n        lst.iter().filter(|&x|\
    \ x < &0).max().cloned(),\n        lst.iter().filter(|&x| x > &0).min().cloned(),\n\
    \    )", "    let mut max = None;\n    let mut min = None;\n    for i in lst {\n\
    \        if i < 0 {\n            if max.is_none() || i > max.unwrap() {\n    \
    \            max = Some(i);\n            }\n        } else if i > 0 {\n      \
    \      if min.is_none() || i < min.unwrap() {\n                min = Some(i);\n\
    \            }\n        }\n    }\n    (max, min)", '    (None, None)', '    (Some(3),
    Some(1))', '    (None, None)', '    unimplemented!()', "    // Unimplemented!()\n\
    \    let mut min_positive = None;\n    let mut max_negative = None;\n    for n\
    \ in lst {\n        if n > 0 {\n            if let Some(p) = min_positive {\n\
    \                if n < p {\n                    min_positive = Some(n);\n   \
    \             }\n            } else {\n                min_positive = Some(n);\n\
    \            }\n        } else if n < 0 {\n            if let Some(p) = max_negative\
    \ {\n                if n > p {\n                    max_negative = Some(n);\n\
    \                }\n            } else {\n                max_negative = Some(n);\n\
    \            }\n        }\n    }\n    (max_negative, min_positive)", '    unimplemented!()',
  "    let mut negs = None;\n    let mut poss = None;\n    for x in lst {\n      \
    \  match x {\n            x if x < 0 => match negs {\n                None =>\
    \ negs = Some(x),\n                Some(y) if x > y => negs = Some(x),\n     \
    \           _ => (),\n            },\n            x if x > 0 => match poss {\n\
    \                None => poss = Some(x),\n                Some(y) if x < y =>\
    \ poss = Some(x),\n                _ => (),\n            },\n            _ =>\
    \ (),\n        }\n    }\n    (negs, poss)", "    let mut mn = None;\n    let mut\
    \ mx = None;\n    for x in lst {\n        if x < 0 {\n            mn = max(mn,\
    \ Some(x));\n        } else if x > 0 {\n            mx = min(mx, Some(x));\n \
    \       }\n    }\n    (mn, mx)", "    let mut lst_c = lst.clone();\n    lst_c.sort();\n\
    \    let mut min = None;\n    let mut max = None;\n    for i in lst_c {\n    \
    \    if i < 0 {\n            max = match max {\n                Some(val) => Some(std::cmp::max(val,\
    \ i)),\n                None => Some(i),\n            };\n        } else if i\
    \ > 0 {\n            min = match min {\n                Some(val) => Some(std::cmp::min(val,\
    \ i)),\n                None => Some(i),\n            };\n        }\n    }\n \
    \   (max, min)", '    unimplemented!();']
stop_tokens:
- "\n}"
