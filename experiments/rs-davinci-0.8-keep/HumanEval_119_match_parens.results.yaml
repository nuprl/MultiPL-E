name: HumanEval_119_match_parens
language: rs
results:
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let (l, r) = (lst[0].chars().count(), lst[1].chars().count());\n\
    \    if l == r {\n        return \"Yes\".to_string();\n    }\n    if l < r {\n\
    \        return match_parens_helper(lst[0].chars(), lst[1].chars());\n    }\n\
    \    match_parens_helper(lst[1].chars(), lst[0].chars())\n}\n\nfn main() {\n \
    \   let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `match_parens_helper` in this scope\n\
    \  --> /tmp/tmp57x5nqrt.rs:18:16\n   |\n18 |         return match_parens_helper(lst[0].chars(),\
    \ lst[1].chars());\n   |                ^^^^^^^^^^^^^^^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find function `match_parens_helper` in this scope\n\
    \  --> /tmp/tmp57x5nqrt.rs:20:5\n   |\n20 |     match_parens_helper(lst[1].chars(),\
    \ lst[0].chars())\n   |     ^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut parens_balance = 0;\n    let mut parens_cnt = 0;\n\
    \    for i in lst.into_iter() {\n        parens_cnt += 1;\n        for j in i.chars()\
    \ {\n            if j == '(' {\n                parens_balance += 1;\n       \
    \     } else {\n                parens_balance -= 1;\n            }\n        \
    \    if parens_balance < 0 {\n                return String::from(\"No\");\n \
    \           }\n        }\n    }\n    if parens_balance == 0 {\n        String::from(\"\
    Yes\")\n    } else {\n        String::from(\"No\")\n    }\n}\n\nfn main() {\n\
    \    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpzwdab3oa.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s = String::new();\n    for &s1 in &lst {\n       \
    \ for ch in s1.chars() {\n            s.push(ch);\n            let mut i = s.len()\
    \ - 1;\n            while i > 0 && s[i] == ')' && s[i - 1] == '(' {\n        \
    \        s.remove(i);\n                s.remove(i - 1);\n                i -=\
    \ 2;\n            }\n        }\n    }\n    if s.is_empty() {\n        \"Yes\"\
    .to_string()\n    } else {\n        \"No\".to_string()\n    }\n}\n\nfn main()\
    \ {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmptrxj5z40.rs:18:28\n\
    \   |\n18 |             while i > 0 && s[i] == ')' && s[i - 1] == '(' {\n   |\
    \                            ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmptrxj5z40.rs:18:43\n\
    \   |\n18 |             while i > 0 && s[i] == ')' && s[i - 1] == '(' {\n   |\
    \                                           ^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut lst = lst;\n    lst.sort();\n    let a = lst[0].as_bytes();\n\
    \    let b = lst[1].as_bytes();\n    if a.iter().filter(|c| **c == b'(').count()\
    \ != b.iter().filter(|c| **c == b')').count() {\n        return \"No\".to_string();\n\
    \    }\n    let mut a = a.iter().peekable();\n    let mut b = b.iter().peekable();\n\
    \    let mut stack: Vec<char> = Vec::new();\n    while let Some(c) = a.next()\
    \ {\n        match c {\n            b'(' => stack.push('('),\n            b')'\
    \ => match stack.pop() {\n                Some('(') => (),\n                _\
    \ => return \"No\".to_string(),\n            },\n            _ => (),\n      \
    \  }\n    }\n    while let Some(c) = b.next() {\n        match c {\n         \
    \   b'(' => stack.push('('),\n            b')' => match stack.pop() {\n      \
    \          Some('(') => (),\n                _ => return \"No\".to_string(),\n\
    \            },\n            _ => (),\n        }\n    }\n    if stack.is_empty()\
    \ {\n        \"Yes\".to_string()\n    } else {\n        \"No\".to_string()\n \
    \   }\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpifsrx7sl.rs:52:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut stack = Vec::new();\n    for c in lst[0].chars() {\n\
    \        match c {\n            '(' => stack.push(c),\n            ')' => match\
    \ stack.pop() {\n                Some(_) => (),\n                None => return\
    \ \"No\".to_string(),\n            },\n            _ => (),\n        }\n    }\n\
    \    for c in lst[1].chars() {\n        match c {\n            '(' => match stack.pop()\
    \ {\n                Some(_) => (),\n                None => return \"No\".to_string(),\n\
    \            },\n            ')' => stack.push(c),\n            _ => (),\n   \
    \     }\n    }\n    stack.is_empty() as u8 * \"Yes\".len() as u8 + \"No\".len()\
    \ as u8\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpa0ozne44.rs:34:5\n   |\n\
    12 | fn match_parens(lst: Vec<String>) -> String {\n   |                     \
    \                 ------ expected `String` because of return type\n...\n34 | \
    \    stack.is_empty() as u8 * \"Yes\".len() as u8 + \"No\".len() as u8\n   | \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct\
    \ `String`, found `u8`\n   |\nhelp: try using a conversion method\n   |\n34 |\
    \     (stack.is_empty() as u8 * \"Yes\".len() as u8 + \"No\".len() as u8).to_string()\n\
    \   |     +                                                             +++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut vals = lst[0].chars().map(|s| s == '(').collect::<Vec<bool>>();\n\
    \    let mut cur_val = 0;\n    for s in lst[1].chars() {\n        if cur_val ==\
    \ -1 {\n            return \"No\".to_string();\n        }\n        if s == '('\
    \ {\n            cur_val += 1;\n        } else {\n            cur_val -= 1;\n\
    \        }\n    }\n    if cur_val < 0 {\n        return \"No\".to_string();\n\
    \    }\n    while vals.len() > 0 && cur_val > 0 {\n        if vals.pop().unwrap()\
    \ {\n            cur_val -= 1;\n        }\n    }\n    if cur_val == 0 {\n    \
    \    \"Yes\".to_string()\n    } else {\n        \"No\".to_string()\n    }\n}\n\
    \nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpg75ihqbs.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut lst = lst;\n    lst.sort();\n    let left: String =\
    \ lst[0].clone();\n    let right: String = lst[1].clone();\n    if right.len()\
    \ > left.len() {\n        return \"No\".to_string();\n    }\n    let mut stack:\
    \ Vec<char> = Vec::new();\n    let mut left_chars: Vec<char> = left.chars().collect();\n\
    \    let mut right_chars: Vec<char> = right.chars().collect();\n    for i in 0..left_chars.len()\
    \ {\n        if i < right_chars.len() {\n            stack.push(right_chars[i]);\n\
    \        }\n        stack.push(left_chars[i]);\n        while stack.len() > 1\
    \ && stack[stack.len() - 1] == ')' && stack[stack.len() - 2] == '(' {\n      \
    \      stack.pop();\n            stack.pop();\n        }\n    }\n    if stack.len()\
    \ == 0 {\n        return \"Yes\".to_string();\n    }\n    return \"No\".to_string();\n\
    }\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmp94yv_90i.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut first = lst[0].clone();\n    let mut second = lst[1].clone();\n\
    \    let mut result = \"No\".to_string();\n    let mut open_parens = 0;\n    for\
    \ _ in 0..(first.len() + second.len()) {\n        for c in first.chars() {\n \
    \           if c == '(' {\n                open_parens += 1;\n            } else\
    \ {\n                open_parens -= 1;\n            }\n        }\n        for\
    \ c in second.chars() {\n            if c == '(' {\n                open_parens\
    \ += 1;\n            } else {\n                open_parens -= 1;\n           \
    \ }\n        }\n        if open_parens == 0 {\n            result = \"Yes\".to_string();\n\
    \            break;\n        }\n        first = first.rotate_right(1);\n     \
    \   second = second.rotate_left(1);\n        open_parens = 0;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `rotate_right` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmp229s_x4a.rs:36:23\n   |\n36 |         first\
    \ = first.rotate_right(1);\n   |                       ^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `trim_right`\n\nerror[E0599]:\
    \ no method named `rotate_left` found for struct `String` in the current scope\n\
    \  --> /tmp/tmp229s_x4a.rs:37:25\n   |\n37 |         second = second.rotate_left(1);\n\
    \   |                         ^^^^^^^^^^^ method not found in `String`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s = lst[0].clone();\n    s.push_str(&lst[1]);\n   \
    \ let mut count = 0;\n    for c in s.chars() {\n        if c == '(' {\n      \
    \      count += 1;\n        } else {\n            count -= 1;\n        }\n   \
    \     if count < 0 {\n            return \"No\".to_string();\n        }\n    }\n\
    \    if count == 0 {\n        \"Yes\".to_string()\n    } else {\n        \"No\"\
    .to_string()\n    }\n}\n\nfn main() {\n    let candidate = match_parens;\n   \
    \ assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpxg7mjlr2.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let (s1, s2) = (lst[0].chars().count(|c| c == '('), lst[1].chars().count(|c|\
    \ c == '('));\n    if s1 == s2 {\n        String::from(\"Yes\")\n    } else {\n\
    \        String::from(\"No\")\n    }\n}\n\nfn main() {\n    let candidate = match_parens;\n\
    \    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \   --> /tmp/tmpo2hvbp37.rs:13:36\n    |\n13  |     let (s1, s2) = (lst[0].chars().count(|c|\
    \ c == '('), lst[1].chars().count(|c| c == '('));\n    |                     \
    \               ^^^^^ ------------ supplied 1 argument\n    |                \
    \                    |\n    |                                    expected 0 arguments\n\
    \    |\nnote: associated function defined here\n\nerror[E0061]: this function\
    \ takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpo2hvbp37.rs:13:72\n\
    \    |\n13  |     let (s1, s2) = (lst[0].chars().count(|c| c == '('), lst[1].chars().count(|c|\
    \ c == '('));\n    |                                                         \
    \               ^^^^^ ------------ supplied 1 argument\n    |                \
    \                                                        |\n    |            \
    \                                                            expected 0 arguments\n\
    \    |\nnote: associated function defined here\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut openings = 0;\n    let mut ok = true;\n    for c in\
    \ lst[0].chars() {\n        if c == '(' {\n            openings += 1;\n      \
    \  } else {\n            openings -= 1;\n        }\n        if openings < 0 {\n\
    \            ok = false;\n            break;\n        }\n    }\n    if ok {\n\
    \        for c in lst[1].chars() {\n            if c == '(' {\n              \
    \  openings += 1;\n            } else {\n                openings -= 1;\n    \
    \        }\n            if openings < 0 {\n                ok = false;\n     \
    \           break;\n            }\n        }\n    }\n    if ok && openings ==\
    \ 0 {\n        \"Yes\".to_string()\n    } else {\n        \"No\".to_string()\n\
    \    }\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmp27zs416j.rs:51:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut cur = \"\";\n    for i in lst {\n        cur = &concat(cur,\
    \ &i);\n    }\n    if balance_parens(cur) {\n        return \"Yes\".to_string();\n\
    \    }\n    \"No\".to_string()\n}\n\nfn main() {\n    let candidate = match_parens;\n\
    \    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0423]: expected function, found macro `concat`\n  --> /tmp/tmps28l7dvk.rs:15:16\n\
    \   |\n15 |         cur = &concat(cur, &i);\n   |                ^^^^^^ not a\
    \ function\n   |\nhelp: use `!` to invoke the macro\n   |\n15 |         cur =\
    \ &concat!(cur, &i);\n   |                      +\n\nerror[E0425]: cannot find\
    \ function `balance_parens` in this scope\n  --> /tmp/tmps28l7dvk.rs:17:8\n  \
    \ |\n17 |     if balance_parens(cur) {\n   |        ^^^^^^^^^^^^^^ not found in\
    \ this scope\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0423, E0425.\nFor more information about an error, try `rustc\
    \ --explain E0423`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut cnt = 0;\n    let mut res = String::new();\n    for\
    \ txt in lst {\n        for ch in txt.chars() {\n            if ch == '(' {\n\
    \                cnt += 1;\n            } else {\n                cnt -= 1;\n\
    \            }\n            if cnt < 0 {\n                return \"No\".to_string();\n\
    \            }\n        }\n        res.push_str(&txt);\n    }\n    if cnt == 0\
    \ {\n        \"Yes\".to_string()\n    } else {\n        \"No\".to_string()\n \
    \   }\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpjpfq1_04.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut open = 0;\n    let mut close = 0;\n    let mut s =\
    \ \"\".to_string();\n    for p in lst {\n        let mut cnt = 0;\n        for\
    \ c in p.chars() {\n            if c == '(' {\n                cnt += 1;\n   \
    \         } else {\n                cnt -= 1;\n            }\n        }\n    \
    \    if cnt > 0 {\n            open += cnt;\n        } else {\n            close\
    \ += -cnt;\n        }\n        s.push_str(&p);\n    }\n    if open > close {\n\
    \        return \"No\".to_string();\n    }\n    // `s` is a valid concatenation\
    \ of two strings in `lst`.\n    // Now we need to check if the parentheses are\
    \ balanced.\n    let mut cnt = 0;\n    for c in s.chars() {\n        if c == '('\
    \ {\n            cnt += 1;\n        } else {\n            cnt -= 1;\n        }\n\
    \        if cnt < 0 {\n            return \"No\".to_string();\n        }\n   \
    \ }\n    if cnt == 0 {\n        \"Yes\".to_string()\n    } else {\n        \"\
    No\".to_string()\n    }\n}\n\nfn main() {\n    let candidate = match_parens;\n\
    \    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpi_lo0vf7.rs:60:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut v1 = Vec::new();\n    let mut v2 = Vec::new();\n  \
    \  for i in 0..lst[0].len() {\n        if lst[0].chars().nth(i).unwrap() == '('\
    \ {\n            v1.push('(');\n        } else {\n            if v1.len() > 0\
    \ {\n                v1.pop();\n            } else {\n                return \"\
    No\".to_string();\n            }\n        }\n    }\n    for i in 0..lst[1].len()\
    \ {\n        if lst[1].chars().nth(i).unwrap() == '(' {\n            v2.push('(');\n\
    \        } else {\n            if v2.len() > 0 {\n                v2.pop();\n\
    \            } else {\n                return \"No\".to_string();\n          \
    \  }\n        }\n    }\n    if v1.len() > 0 && v2.len() > 0 {\n        return\
    \ \"Yes\".to_string();\n    } else {\n        return \"No\".to_string();\n   \
    \ }\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpf7eeredb.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let s1 = lst[0].as_str();\n    let s2 = lst[1].as_str();\n\
    \    if s1.len() == 0 {\n        return s2.to_string();\n    }\n    if s2.len()\
    \ == 0 {\n        return s1.to_string();\n    }\n    let mut stack: Vec<char>\
    \ = Vec::new();\n    stack.push(s1.chars().next().unwrap());\n    for ch in s1.chars().skip(1)\
    \ {\n        if stack.len() > 0 && matches!(stack[stack.len() - 1], '(') && matches!(ch,\
    \ ')') {\n            stack.pop();\n        } else {\n            stack.push(ch);\n\
    \        }\n    }\n    for ch in s2.chars() {\n        if stack.len() > 0 && matches!(stack[stack.len()\
    \ - 1], '(') && matches!(ch, ')') {\n            stack.pop();\n        } else\
    \ {\n            stack.push(ch);\n        }\n    }\n    if stack.len() == 0 {\n\
    \        \"Yes\".to_string()\n    } else {\n        \"No\".to_string()\n    }\n\
    }\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmp17h8exfw.rs:49:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s = lst[0].clone();\n    let mut bal = 0;\n    for\
    \ c in s.chars() {\n        if c == '(' {\n            bal += 1;\n        } else\
    \ {\n            bal -= 1;\n        }\n        if bal < 0 {\n            break;\n\
    \        }\n    }\n    if bal == 0 {\n        return \"Yes\".to_string();\n  \
    \  }\n    s = lst[1].clone();\n    for c in s.chars() {\n        if c == '(' {\n\
    \            bal += 1;\n        } else {\n            bal -= 1;\n        }\n \
    \       if bal > 0 {\n            break;\n        }\n    }\n    if bal == 0 {\n\
    \        return \"Yes\".to_string();\n    }\n    \"No\".to_string()\n}\n\nfn main()\
    \ {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmp0ycd9pap.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    // count parentheses\n    let mut open_count = 0;\n    let\
    \ mut close_count = 0;\n    for s in lst {\n        for c in s.chars() {\n   \
    \         match c {\n                '(' => open_count += 1,\n               \
    \ ')' => close_count += 1,\n                _ => panic!(\"Illegal character {}\"\
    , c),\n            }\n        }\n    }\n    // parentheses count should be equal\n\
    \    if open_count != close_count {\n        return \"No\".to_string();\n    }\n\
    \    // string should start with open parentheses and end with close parentheses\n\
    \    if lst[0].chars().next().unwrap() == ')' ||\n       lst[1].chars().next().unwrap()\
    \ == '(' {\n        return \"No\".to_string();\n    }\n    return \"Yes\".to_string();\n\
    }\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `lst`\n   --> /tmp/tmppkwxlujk.rs:30:8\n\
    \    |\n12  | fn match_parens(lst: Vec<String>) -> String {\n    |           \
    \      --- move occurs because `lst` has type `Vec<String>`, which does not implement\
    \ the `Copy` trait\n...\n16  |     for s in lst {\n    |              --- `lst`\
    \ moved due to this implicit call to `.into_iter()`\n...\n30  |     if lst[0].chars().next().unwrap()\
    \ == ')' ||\n    |        ^^^ value borrowed here after move\n    |\nnote: this\
    \ function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider\
    \ iterating over a slice of the `Vec<String>`'s content to avoid moving into the\
    \ `for` loop\n    |\n16  |     for s in &lst {\n    |              +\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    if lst.len() != 2 {\n        String::from(\"Bad input\")\n\
    \    } else {\n        let mut lft = &lst[0];\n        let mut rgt = &lst[1];\n\
    \        let mut res = String::new();\n        while !lft.is_empty() || !rgt.is_empty()\
    \ {\n            if lft.ends_with('(') {\n                res.push('(');\n   \
    \             lft = &lft[..lft.len() - 1];\n            } else if rgt.starts_with(')')\
    \ {\n                res.push(')');\n                rgt = &rgt[1..];\n      \
    \      } else {\n                break;\n            }\n        }\n        if\
    \ check_match(&res) {\n            String::from(\"Yes\")\n        } else {\n \
    \           String::from(\"No\")\n        }\n    }\n}\n\nfn main() {\n    let\
    \ candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"\
    ), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `check_match` in this scope\n  --> /tmp/tmp4xw3vsl7.rs:30:12\n\
    \   |\n30 |         if check_match(&res) {\n   |            ^^^^^^^^^^^ not found\
    \ in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4xw3vsl7.rs:22:23\n\
    \   |\n16 |         let mut lft = &lst[0];\n   |                       -------\
    \ expected due to this value\n...\n22 |                 lft = &lft[..lft.len()\
    \ - 1];\n   |                       ^^^^^^^^^^^^^^^^^^^^^ expected struct `String`,\
    \ found `str`\n   |\n   = note: expected reference `&String`\n              found\
    \ reference `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4xw3vsl7.rs:25:23\n\
    \   |\n17 |         let mut rgt = &lst[1];\n   |                       -------\
    \ expected due to this value\n...\n25 |                 rgt = &rgt[1..];\n   |\
    \                       ^^^^^^^^^ expected struct `String`, found `str`\n   |\n\
    \   = note: expected reference `&String`\n              found reference `&str`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut st = Vec::new();\n    for i in 0..lst.len() {\n   \
    \     let s = &lst[i];\n        if st.len() > 0 && st[st.len() - 1] == '(' &&\
    \ s == \")\" {\n            st.pop();\n        } else {\n            for ch in\
    \ s.chars() {\n                st.push(ch);\n            }\n        }\n    }\n\
    \    if st.len() == 0 {\n        \"Yes\".to_string()\n    } else {\n        \"\
    No\".to_string()\n    }\n}\n\nfn main() {\n    let candidate = match_parens;\n\
    \    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpgxv6ofwu.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
