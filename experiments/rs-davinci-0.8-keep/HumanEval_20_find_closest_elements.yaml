name: HumanEval_20_find_closest_elements
language: rs
prompt: "/// From a supplied list of numbers (of length at least two) select and return\
  \ two that are the closest to each\n/// other and return them in order (smaller\
  \ number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0,\
  \ 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0,\
  \ 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64)\
  \ {\n"
tests: "}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
  \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0,\
  \ 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
  \ 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
  \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
  \ (2.2, 3.1));\n}\n"
completions: ["    let mut min = std::f64::MAX;\n    let mut min_nums = (0.0, 0.0);\n\
    \    for pair in numbers.windows(2) {\n        let diff = (pair[0] - pair[1]).abs();\n\
    \        if diff < min {\n            min = diff;\n            min_nums = (pair[0],\
    \ pair[1]);\n        }\n    }\n    if min_nums.0 > min_nums.1 {\n        (min_nums.1,\
    \ min_nums.0)\n    } else {\n        min_nums\n    }", "    let mut smallest =\
    \ f64::INFINITY;\n    let mut closest_pair = (0f64, 0f64);\n    let mut sorted_numbers\
    \ = numbers.clone();\n    sorted_numbers.sort_by(|a, b| a.partial_cmp(b).unwrap());\n\
    \    for i in 0..sorted_numbers.len() - 1 {\n        let temp = sorted_numbers[i]\
    \ - sorted_numbers[i + 1];\n        if temp.abs() < smallest {\n            smallest\
    \ = temp.abs();\n            closest_pair = (sorted_numbers[i], sorted_numbers[i\
    \ + 1]);\n        }\n    }\n    closest_pair", "    let mut smallest = 0;\n  \
    \  let mut largest = 1;\n    let mut closest = numbers[1] - numbers[0];\n    for\
    \ i in 1..numbers.len() {\n        for j in i + 1..numbers.len() {\n         \
    \   let gap = numbers[j] - numbers[i];\n            if gap < closest {\n     \
    \           smallest = i;\n                largest = j;\n                closest\
    \ = gap;\n            }\n        }\n    }\n    (numbers[smallest], numbers[largest])",
  "    let mut closest_elements: (f64, f64) = (0f64, 0f64);\n    let mut closest_difference:\
    \ f64 = 0f64;\n    if numbers.len() >= 2 {\n        for i in 0..numbers.len()\
    \ - 1 {\n            for j in i + 1..numbers.len() {\n                let difference\
    \ = (numbers[i] - numbers[j]).abs();\n                if i == 0 && j == 1 {\n\
    \                    closest_difference = difference;\n                    closest_elements\
    \ = (numbers[i], numbers[j]);\n                } else if difference < closest_difference\
    \ {\n                    closest_difference = difference;\n                  \
    \  closest_elements = (numbers[i], numbers[j]);\n                }\n         \
    \   }\n        }\n    }\n    closest_elements", "    // find the two closest\n\
    \    let mut closest: (f64, f64) = (0.0, 0.0);\n    let mut closest_distance:\
    \ f64 = f64::MAX;\n    for i in 0..numbers.len() {\n        for j in 0..numbers.len()\
    \ {\n            if i != j {\n                let distance = (numbers[i] - numbers[j]).abs();\n\
    \                if distance < closest_distance {\n                    closest\
    \ = (numbers[i], numbers[j]);\n                    closest_distance = distance;\n\
    \                }\n            }\n        }\n    }\n    closest", '    unimplemented!();',
  "    let mut min_diff = numbers[1] - numbers[0];\n    let mut min_elements = (numbers[0],\
    \ numbers[1]);\n    for idx in 1..numbers.len() {\n        let diff = numbers[idx]\
    \ - numbers[idx - 1];\n        if diff < min_diff {\n            min_diff = diff;\n\
    \            min_elements = (numbers[idx - 1], numbers[idx]);\n        }\n   \
    \ }\n    return min_elements;", "    // TODO\n    (0f64, 0f64)", "    let mut\
    \ min_distance = std::f64::MAX;\n    let mut result: (f64, f64) = (0.0, 0.0);\n\
    \    for i in 0..numbers.len() {\n        for j in 0..numbers.len() {\n      \
    \      if numbers[i] != numbers[j] {\n                let distance = (numbers[i]\
    \ - numbers[j]).abs();\n                if distance < min_distance {\n       \
    \             min_distance = distance;\n                    result = (numbers[i],\
    \ numbers[j]);\n                }\n            }\n        }\n    }\n    result",
  "    let mut min_distance = std::f64::MAX;\n    let mut min_distance_numbers = (0.0,\
    \ 0.0);\n    for (i, x) in numbers.iter().enumerate() {\n        for y in numbers.iter().skip(i)\
    \ {\n            let d = x - y;\n            if d.abs() < min_distance {\n   \
    \             min_distance = d.abs();\n                min_distance_numbers =\
    \ (*x, *y);\n            }\n        }\n    }\n    min_distance_numbers", "   \
    \ let mut closest_elements = (numbers[0], numbers[1]);\n    let mut closest_distance\
    \ = f64::abs(closest_elements.0 - closest_elements.1);\n    for i in 0..numbers.len()\
    \ - 1 {\n        for j in i + 1..numbers.len() {\n            let distance = f64::abs(numbers[i]\
    \ - numbers[j]);\n            if distance < closest_distance {\n             \
    \   closest_distance = distance;\n                closest_elements = (numbers[i],\
    \ numbers[j]);\n            }\n        }\n    }\n    closest_elements", '    (1.0,
    2.0)', "    let mut distances: Vec<(f64, f64)> = Vec::new();\n    let mut smallest_distance:\
    \ f64 = std::f64::MAX;\n    let mut closest_pair: (f64, f64) = (std::f64::MAX,\
    \ std::f64::MAX);\n\n    if numbers.len() < 2 {\n        panic!(\"Need at least\
    \ two numbers!\");\n    }\n\n    if numbers.len() == 2 {\n        closest_pair\
    \ = (numbers[0], numbers[1]);\n    } else {\n        for i in 0..numbers.len()\
    \ - 1 {\n            for j in i + 1..numbers.len() {\n                distances.push((numbers[i],\
    \ numbers[j]));\n            }\n        }\n\n        for distance in distances\
    \ {\n            let abs = (distance.0 - distance.1).abs();\n            if abs\
    \ < smallest_distance {\n                smallest_distance = abs;\n          \
    \      closest_pair = distance;\n            }\n        }\n    }\n\n    closest_pair",
  "    let mut mut_numbers = numbers;\n    mut_numbers.sort_by(|a, b| a.partial_cmp(b).unwrap());\n\
    \    let mut first_number = mut_numbers[0];\n    let mut second_number = mut_numbers[1];\n\
    \    let mut diff = second_number - first_number;\n    for i in 1..mut_numbers.len()\
    \ {\n        let current_diff = mut_numbers[i] - mut_numbers[i - 1];\n       \
    \ if current_diff < diff {\n            diff = current_diff;\n            first_number\
    \ = mut_numbers[i - 1];\n            second_number = mut_numbers[i];\n       \
    \ }\n    }\n    (first_number, second_number)", "    let mut sorted_numbers =\
    \ numbers.clone();\n    sorted_numbers.sort_by(|a, b| a.partial_cmp(b).unwrap());\n\
    \    let mut min_diff = f64::MAX;\n    let mut min_diff_pair = (sorted_numbers[0],\
    \ sorted_numbers[1]);\n    for i in 0..sorted_numbers.len() - 1 {\n        let\
    \ diff = sorted_numbers[i + 1] - sorted_numbers[i];\n        if diff < min_diff\
    \ {\n            min_diff = diff;\n            min_diff_pair = (sorted_numbers[i],\
    \ sorted_numbers[i + 1]);\n        }\n    }\n    min_diff_pair", "    let mut\
    \ closest_pair = (numbers[0], numbers[1]);\n    let mut closest_diff = closest_pair.1\
    \ - closest_pair.0;\n    let mut current_pair = (numbers[0], numbers[1]);\n  \
    \  let mut current_diff = closest_diff;\n    for i in 0..numbers.len() {\n   \
    \     for j in i+1..numbers.len() {\n            current_pair = (numbers[i], numbers[j]);\n\
    \            current_diff = current_pair.1 - current_pair.0;\n            if current_diff\
    \ < closest_diff {\n                closest_pair = current_pair;\n           \
    \     closest_diff = current_diff;\n            }\n        }\n    }\n    closest_pair",
  "    let mut numbers = numbers;\n    numbers.sort_by(|a, b| a.partial_cmp(b).unwrap());\n\
    \    let mut closest_pair = (numbers[0], numbers[1]);\n    let mut smallest_difference\
    \ = numbers[1] - numbers[0];\n    for x in 0..numbers.len() - 1 {\n        let\
    \ current_difference = numbers[x + 1] - numbers[x];\n        if current_difference\
    \ < smallest_difference {\n            closest_pair = (numbers[x], numbers[x +\
    \ 1]);\n            smallest_difference = current_difference;\n        }\n   \
    \ }\n    closest_pair", '    unimplemented!()', "    let mut numbers = numbers;\n\
    \    numbers.sort_by(|a, b| a.partial_cmp(b).unwrap());\n    let mut closest_difference\
    \ = f64::INFINITY;\n    let mut diff = 0.0;\n    let mut closest_pair = (0.0,\
    \ 0.0);\n    for i in 0..numbers.len() - 1 {\n        diff = numbers[i + 1] -\
    \ numbers[i];\n        if diff < closest_difference {\n            closest_difference\
    \ = diff;\n            closest_pair = (numbers[i], numbers[i + 1]);\n        }\n\
    \    }\n    closest_pair", "    let mut sorted_numbers = numbers.clone();\n  \
    \  sorted_numbers.sort_by(|a, b| a.partial_cmp(b).unwrap());\n    let mut numbers_iter\
    \ = sorted_numbers.iter();\n    let mut closest_pair = (numbers_iter.next().unwrap(),\
    \ numbers_iter.next().unwrap());\n    let mut smallest_difference = closest_pair.1\
    \ - closest_pair.0;\n    for number in numbers_iter {\n        let (lower, upper)\
    \ = closest_pair;\n        let difference = *number - upper;\n        if difference\
    \ < smallest_difference {\n            closest_pair = (upper, number);\n     \
    \       smallest_difference = difference;\n        }\n    }\n    closest_pair"]
stop_tokens:
- "\n}"
