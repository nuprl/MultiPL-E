name: HumanEval_69_search
language: rs
prompt: "/// You are given a non-empty list of positive integers. Return the greatest\
  \ integer that is greater than \n/// zero, and has a frequency greater than or equal\
  \ to the value of the integer itself. \n/// The frequency of an integer is the number\
  \ of times it appears in the list.\n/// If no such a value exist, return -1.\n///\
  \ Examples:\n/// search([4, 1, 2, 2, 3, 1]) == 2\n/// search([1, 2, 2, 3, 3, 3,\
  \ 4, 4, 4]) == 3\n/// search([5, 5, 4, 4, 4]) == -1\nfn search(lst: Vec<isize>)\
  \ -> isize {\n"
tests: "}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![5,\
  \ 5, 5, 5, 1]), 1);\n    assert_eq!(candidate(vec![4, 1, 4, 1, 4, 4]), 4);\n   \
  \ assert_eq!(candidate(vec![3, 3]), -1);\n    assert_eq!(candidate(vec![8, 8, 8,\
  \ 8, 8, 8, 8, 8]), 8);\n    assert_eq!(candidate(vec![2, 3, 3, 2, 2]), 2);\n   \
  \ assert_eq!(candidate(vec![2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1,\
  \ 7, 4, 10, 8, 1]), 1);\n    assert_eq!(candidate(vec![3, 2, 8, 2]), 2);\n    assert_eq!(candidate(vec![6,\
  \ 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]), 1);\n    assert_eq!(candidate(vec![8, 8, 3,\
  \ 6, 5, 6, 4]), -1);\n    assert_eq!(candidate(vec![6, 9, 6, 7, 1, 4, 7, 1, 8, 8,\
  \ 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]), 1);\n    assert_eq!(candidate(vec![1,\
  \ 9, 10, 1, 3]), 1);\n    assert_eq!(candidate(vec![6, 9, 7, 5, 8, 7, 5, 3, 7, 5,\
  \ 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]), 5);\n    assert_eq!(candidate(vec![1]),\
  \ 1);\n    assert_eq!(candidate(vec![8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6,\
  \ 10, 4, 2, 1, 10, 2, 1, 1, 5]), 4);\n    assert_eq!(candidate(vec![2, 10, 4, 8,\
  \ 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]), 2);\n    assert_eq!(candidate(vec![1,\
  \ 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]), 1);\n    assert_eq!(candidate(vec![9, 2,\
  \ 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8,\
  \ 10, 9, 4]), 4);\n    assert_eq!(candidate(vec![2, 6, 4, 2, 8, 7, 5, 6, 4, 10,\
  \ 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]), 4);\n    assert_eq!(candidate(vec![9,\
  \ 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]), 2);\n    assert_eq!(candidate(vec![5,\
  \ 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]), -1);\n    assert_eq!(candidate(vec![10]),\
  \ -1);\n    assert_eq!(candidate(vec![9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]),\
  \ 2);\n    assert_eq!(candidate(vec![5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]), 1);\n\
  \    assert_eq!(candidate(vec![7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5,\
  \ 6, 7, 6, 7, 7, 6]), 1);\n    assert_eq!(candidate(vec![3, 10, 10, 9, 2]), -1);\n\
  }\n"
completions: ["    let mut m: HashMap<isize, isize> = HashMap::new();\n    for x in\
    \ lst {\n        *m.entry(x).or_insert(0) += 1;\n    }\n    let mut m: Vec<_>\
    \ = m.into_iter().collect();\n    m.sort_by(|&(_, a), &(_, b)| b.cmp(&a));\n \
    \   for (x, c) in m {\n        if x <= c {\n            return x;\n        }\n\
    \    }\n    -1", "    // let mut frequency = vec![0; *lst.iter().max().unwrap()\
    \ as usize + 1];\n    let mut frequency = vec![0; 101];\n    for &num in lst.iter()\
    \ {\n        frequency[num as usize] += 1;\n    }\n    for i in (1..=100).rev()\
    \ {\n        if frequency[i] >= i {\n            return i as isize;\n        }\n\
    \    }\n    -1", "    let mut lst = lst;\n    lst.sort();\n    for i in (1..lst.len()\
    \ + 1).rev() {\n        let f = lst.iter().filter(|&n| *n == i as isize).count();\n\
    \        if f >= i {\n            return i as isize;\n        }\n    }\n    -1",
  "    let n = lst.len();\n    if n < 2 {\n        return -1;\n    }\n    let mut\
    \ max = 0;\n    let mut lst = lst;\n    lst.sort();\n    let mut last_i = n as\
    \ isize - 1;\n    let mut last_count = 1;\n    let mut max_count = 1;\n    for\
    \ i in (0..last_i).rev() {\n        if lst[i as usize] != lst[(i + 1) as usize]\
    \ {\n            if last_count >= last_i - i {\n                max = last_i;\n\
    \                max_count = last_count;\n            }\n            last_i =\
    \ i;\n            last_count = 1;\n        } else {\n            last_count +=\
    \ 1;\n        }\n    }\n    if max == 0 {\n        if last_count >= last_i {\n\
    \            max = last_i;\n            max_count = last_count;\n        }\n \
    \   }\n    if max_count >= max {\n        max\n    } else {\n        -1\n    }",
  "    if lst.len() == 0 { return -1; }\n    if lst.len() == 1 { return lst[0]; }\n\
    \    let map = lst.iter().fold(HashMap::new(), |mut acc, &n| {\n        let count\
    \ = acc.entry(n).or_insert(0);\n        *count += 1;\n        acc\n    });\n \
    \   let max_count = *map.values().max().unwrap();\n    if max_count == 1 { return\
    \ -1; }\n    let max_val = *map.keys().max().unwrap();\n    if max_val < max_count\
    \ { return max_val; }\n    return -1;", "    let mut numbers: [isize; 1000] =\
    \ [0; 1000];\n    for i in 0..lst.len() {\n        numbers[lst[i] as usize] +=\
    \ 1;\n    }\n    for i in 0..numbers.len() {\n        if numbers[i] >= i as isize\
    \ && numbers[i] > 0 {\n            return i as isize;\n        }\n    }\n    -1",
  "    let mut counter = HashMap::new();\n    for &i in &lst {\n        *counter.entry(i).or_insert(0)\
    \ += 1;\n    }\n    *(1..)\n        .filter(|&i| counter.get(&i).map_or(false,\
    \ |c| *c >= i))\n        .next()\n        .unwrap_or(&-1)", "    let mut freq:\
    \ Vec<isize> = vec![0; lst.len()];\n    for i in 0..lst.len() {\n        freq[lst[i]\
    \ as usize] += 1;\n    }\n    let mut ans = -1;\n    for i in (1..freq.len()).rev()\
    \ {\n        if freq[i] >= i as isize {\n            ans = i as isize;\n     \
    \       break;\n        }\n    }\n    ans", "    let mut hm = HashMap::new();\n\
    \    let mut heap = BinaryHeap::new();\n    for n in lst {\n        *hm.entry(n).or_insert(0)\
    \ += 1;\n    }\n    for (k, v) in hm {\n        if k <= v {\n            heap.push(k);\n\
    \        }\n    }\n    if heap.is_empty() {\n        return -1;\n    }\n    *heap.peek().unwrap()",
  "    if lst.is_empty() {\n        return -1;\n    }\n    let mut m = std::collections::HashMap::new();\n\
    \    for n in lst {\n        *m.entry(n).or_insert(0) += 1;\n    }\n    let mut\
    \ max = 0;\n    for (n, v) in m {\n        if n <= v && n > max {\n          \
    \  max = n;\n        }\n    }\n    if max > 0 {\n        max\n    } else {\n \
    \       -1\n    }", "    let mut freq = HashMap::new();\n    for i in lst {\n\
    \        *freq.entry(i).or_insert(0) += 1;\n    }\n    for i in (1..(lst.len()\
    \ as isize + 1)).rev() {\n        match freq.get(&i) {\n            Some(x) if\
    \ *x >= i => return i,\n            _ => {}\n        }\n    }\n    -1", "    if\
    \ lst.is_empty() {\n        return -1;\n    }\n    let mut counter = HashMap::new();\n\
    \    let mut max = 0;\n    for i in lst {\n        *counter.entry(i).or_insert(0)\
    \ += 1;\n        if i > max {\n            max = i;\n        }\n    }\n    for\
    \ i in (1..=max).rev() {\n        if let Some(value) = counter.get(&i) {\n   \
    \         if *value >= i {\n                return i;\n            }\n       \
    \ }\n    }\n    -1", "    use std::collections::HashMap;\n    let mut numbers\
    \ = HashMap::new();\n    for n in lst {\n        *numbers.entry(n).or_insert(0)\
    \ += 1;\n    }\n    let max = numbers.keys().max().unwrap();\n    for i in (1..*max\
    \ + 1).rev() {\n        if let Some(m) = numbers.get(&i) {\n            if *m\
    \ >= i {\n                return i;\n            }\n        }\n    }\n    -1",
  "    let mut map = HashMap::new();\n    let mut greatest = 0;\n    for i in lst\
    \ {\n        if i > greatest {\n            greatest = i;\n        }\n       \
    \ let count = map.entry(i).or_insert(0);\n        *count += 1;\n    }\n    for\
    \ i in 1..=greatest {\n        if let Some(x) = map.get(&i) {\n            if\
    \ i <= *x {\n                return i;\n            }\n        }\n    }\n    -1",
  "    // count all numbers\n    let mut counts = std::collections::HashMap::new();\n\
    \    for x in lst {\n        let count = counts.entry(x).or_insert(0);\n     \
    \   *count += 1;\n    }\n    // find number with frequency >= value\n    let max_count\
    \ = counts.values().max().unwrap();\n    let max_val = counts.keys().max().unwrap();\n\
    \    if *max_count >= *max_val {\n        return *max_val;\n    }\n    return\
    \ -1;", "    // Print the vector for debugging purposes.\n    // print!(\"{:?}\"\
    , lst);\n    let mut new_vec: Vec<isize> = Vec::new();\n    // println!(\"{:?}\"\
    , new_vec);\n    for i in &lst {\n        let count = lst.iter().filter(|&x| *x\
    \ == *i).count();\n        new_vec.push(count as isize);\n    }\n    // println!(\"\
    {:?}\", new_vec);\n    new_vec.sort();\n    new_vec.dedup();\n    // println!(\"\
    {:?}\", new_vec);\n    let len = new_vec.len();\n    if len == 0 {\n        return\
    \ -1;\n    }\n    let x = new_vec[len - 1];\n    let mut i = 0;\n    while i <\
    \ lst.len() {\n        if lst[i] >= x {\n            return lst[i];\n        }\n\
    \        i += 1;\n    }\n    -1", "    if lst.len() == 0 { return -1; }\n    let\
    \ mut freq = HashMap::new();\n    for i in lst {\n        *freq.entry(i).or_insert(0)\
    \ += 1;\n    }\n    for k in lst {\n        if freq.get(&k).unwrap() >= &k {\n\
    \            return k;\n        }\n    }\n    -1", "    let freq = |&i: &isize|\
    \ lst.iter().filter(|&x| x == i).count();\n    let mut candidates = lst.clone();\n\
    \    candidates.sort();\n    candidates.dedup();\n    candidates.iter().rev().find(|&x|\
    \ freq(x) >= *x as usize).cloned().unwrap_or(-1)", "    if lst.is_empty() {\n\
    \        return -1;\n    }\n    let counts = lst.iter().fold(HashMap::new(), |mut\
    \ acc, &item| {\n        *acc.entry(item).or_insert(0) += 1;\n        acc\n  \
    \  });\n    let mut nums = counts.keys().map(|k| *k).collect::<Vec<isize>>();\n\
    \    nums.sort();\n    for &num in nums.iter().rev() {\n        if num > 0 &&\
    \ counts[&num] >= num {\n            return num;\n        }\n    }\n    -1", " \
    \   let mut counts = HashMap::new();\n    for &item in &lst {\n        *counts.entry(item).or_insert(0)\
    \ += 1;\n    }\n    for (item, count) in counts {\n        if item < count {\n\
    \            return item;\n        }\n    }\n    -1"]
stop_tokens:
- "\n}"
