name: HumanEval_117_select_words
language: rs
results:
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    if n < 0 { return vec![]; }\n    let\
    \ mut result = vec![];\n    let mut word = String::new();\n    let mut consonants\
    \ = 0;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n           \
    \ if c.is_lowercase() && !c.is_whitespace() && !is_vowel(c) {\n              \
    \  consonants += 1;\n            }\n            word.push(c);\n        } else\
    \ {\n            if consonants == n {\n                result.push(word);\n  \
    \          }\n            word = String::new();\n            consonants = 0;\n\
    \        }\n    }\n    if consonants == n {\n        result.push(word);\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpzt5rnvsl.rs:19:59\n\
    \   |\n19 |             if c.is_lowercase() && !c.is_whitespace() && !is_vowel(c)\
    \ {\n   |                                                           ^^^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    if s.is_empty() {\n        return vec![];\n\
    \    }\n    let mut res = vec![];\n    let mut counter = 0;\n    let mut word\
    \ = String::new();\n    for ch in s.chars() {\n        if ch.is_alphabetic() {\n\
    \            if \"aeiou\".contains(ch) {\n                counter = 0;\n     \
    \       } else {\n                counter += 1;\n            }\n            word.push(ch);\n\
    \        } else {\n            if counter == n {\n                res.push(word);\n\
    \            }\n            counter = 0;\n            word = String::new();\n\
    \        }\n    }\n    if counter == n {\n        res.push(word);\n    }\n   \
    \ res\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"little\"]`', /tmp/tmpfs3vjjhx.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n\tlet mut result: Vec<String> = Vec::new();\n\
    \tlet mut b: Vec<String> = s.split_whitespace().map(|x| x.to_string()).collect();\n\
    \tfor e in b.iter_mut() {\n\t\tif count_consonants(e.to_string()) == n {\n\t\t\
    \tresult.push(e.to_string());\n\t\t}\n\t}\n\tresult\n}\n\nfn main() {\n    let\
    \ candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had\
    \ a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `count_consonants` in this scope\n \
    \ --> /tmp/tmpcv8e_mcg.rs:16:6\n   |\n16 |         if count_consonants(e.to_string())\
    \ == n {\n   |            ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut v: Vec<String> = Vec::new();\n\
    \    let mut c = 0;\n    let mut word = String::new();\n    for i in s.chars()\
    \ {\n        if i == ' ' {\n            if c == n {\n                v.push(word);\n\
    \            }\n            c = 0;\n            word = String::new();\n      \
    \  } else {\n            word.push(i);\n            if !is_vowel(i) {\n      \
    \          c += 1;\n            }\n        }\n    }\n    if c == n {\n       \
    \ v.push(word);\n    }\n    v\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpo76t26ei.rs:25:17\n\
    \   |\n25 |             if !is_vowel(i) {\n   |                 ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    for\
    \ word in s.split_whitespace() {\n        let consonants = word.chars().filter(|c|\
    \ !\"aeiouAEIOU\".contains(*c)).count();\n        if consonants == n as usize\
    \ {\n            result.push(word.to_string());\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut selected: Vec<String> = Vec::new();\n\
    \    let consonants = vec![\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"\
    k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"\
    x\", \"z\"];\n    let split = s.split(\" \");\n    for word in split {\n     \
    \   let mut count = 0;\n        for c in word.chars() {\n            if consonants.contains(&c.to_lowercase().to_string().as_str())\
    \ {\n                count += 1;\n            }\n        }\n        if count ==\
    \ n {\n            selected.push(word.to_string());\n        }\n    }\n    selected\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"lamb\"]`,\n right: `[\"Mary\", \"lamb\"]`', /tmp/tmp0npsk009.rs:33:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let chars: Vec<char> = s.chars().collect();\n\
    \    let vowels = \"aeiouAEIOU\";\n    let mut words: Vec<String> = Vec::new();\n\
    \    let mut temp: String = String::new();\n    let mut vowel_count: isize = 0;\n\
    \    for c in chars {\n        if c == ' ' {\n            if vowel_count == n\
    \ {\n                words.push(temp.clone());\n            }\n            temp.clear();\n\
    \            vowel_count = 0;\n        } else {\n            if vowels.contains(c)\
    \ {\n                vowel_count += 1;\n            }\n            temp.push(c);\n\
    \        }\n    }\n    if vowel_count == n {\n        words.push(temp.clone());\n\
    \    }\n    words\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"little\"]`', /tmp/tmpd80y9nrk.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let vowels = \"aeiouAEIOU\";\n    let\
    \ mut result = Vec::new();\n    let mut last_word = String::new();\n    for c\
    \ in s.chars() {\n        if c.is_alphabetic() {\n            last_word.push(c);\n\
    \        } else {\n            if vowels.chars().filter(|&v| v == c).count() !=\
    \ 0 {\n                last_word.clear();\n            } else {\n            \
    \    if last_word.len() as isize == n {\n                    result.push(last_word.clone());\n\
    \                }\n                last_word.clear();\n            }\n      \
    \  }\n    }\n    if last_word.len() as isize == n {\n        result.push(last_word);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"Mary\", \"lamb\"]`,\n right: `[\"little\"]`', /tmp/tmpmbetp8zq.rs:38:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    s.split_whitespace()\n        .filter(|w|\
    \ is_consonant(&w.chars().filter(|c| c.is_alphabetic()).collect::<String>()))\n\
    \        .map(|w| w.to_string())\n        .collect::<Vec<String>>()\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_consonant` in this scope\n  -->\
    \ /tmp/tmpvilib922.rs:14:21\n   |\n14 |         .filter(|w| is_consonant(&w.chars().filter(|c|\
    \ c.is_alphabetic()).collect::<String>()))\n   |                     ^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let mut vec: Vec<String> = vec![];\n\
    \    let mut tmp = String::new();\n    let mut cnt = 0;\n    for c in s.chars()\
    \ {\n        if c.is_alphabetic() {\n            tmp.push(c);\n            if\
    \ !c.is_vowel() {\n                cnt += 1;\n            }\n        } else {\n\
    \            if cnt == n {\n                vec.push(tmp);\n            }\n  \
    \          tmp = String::new();\n            cnt = 0;\n        }\n    }\n    if\
    \ cnt == n {\n        vec.push(tmp);\n    }\n    vec\n}\n\nfn main() {\n    let\
    \ candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had\
    \ a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_vowel` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpesc9sp5q.rs:19:19\n   |\n19 |             if !c.is_vowel()\
    \ {\n   |                   ^^^^^^^^ method not found in `char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    let vowels = \"aeiou\";\n    let mut\
    \ result = Vec::new();\n    for word in s.split(\" \") {\n        let mut num_consonants\
    \ = 0;\n        for ch in word.chars() {\n            if !vowels.contains(ch)\
    \ {\n                num_consonants += 1;\n            }\n        }\n        if\
    \ num_consonants == n {\n            result.push(word.to_string());\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"Uncle\"]`', /tmp/tmp0ygga9j2.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    s.split_whitespace()\n        .filter(|word|\
    \ word.chars().filter(|c| !c.is_vowel()).count() as isize == n)\n        .map(|s|\
    \ s.to_string())\n        .collect()\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_vowel` found for reference `&char` in\
    \ the current scope\n  --> /tmp/tmpt611tolm.rs:14:51\n   |\n14 |         .filter(|word|\
    \ word.chars().filter(|c| !c.is_vowel()).count() as isize == n)\n   |        \
    \                                           ^^^^^^^^ method not found in `&char`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n\tlet mut words: Vec<String> = Vec::new();\n\
    \tfor word in s.split_whitespace() {\n\t\tif get_consts(word) == n {\n\t\t\twords.push(word.to_string());\n\
    \t\t}\n\t}\n\twords\n}\n\nfn main() {\n    let candidate = select_words;\n   \
    \ assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `get_consts` in this scope\n  --> /tmp/tmpevnv5vpm.rs:15:6\n\
    \   |\n15 |         if get_consts(word) == n {\n   |            ^^^^^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    fn no_vowels(ch: char) -> bool {\n \
    \       match ch {\n            'a' | 'e' | 'i' | 'o' | 'u' | 'y' => false,\n\
    \            _ => true,\n        }\n    }\n    s.split_whitespace()\n        .filter(|w|\
    \ w.chars().filter(no_vowels).count() as isize == n)\n        .map(|w| w.to_string())\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = select_words;\n   \
    \ assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0631]: type mismatch in function arguments\n   --> /tmp/tmpe0iegn1k.rs:20:38\n\
    \    |\n13  |     fn no_vowels(ch: char) -> bool {\n    |     ------------------------------\
    \ found signature of `fn(char) -> _`\n...\n20  |         .filter(|w| w.chars().filter(no_vowels).count()\
    \ as isize == n)\n    |                               ------ ^^^^^^^^^ expected\
    \ signature of `for<'r> fn(&'r char) -> _`\n    |                            \
    \   |\n    |                               required by a bound introduced by this\
    \ call\n    |\nnote: required by a bound in `filter`\n\nerror[E0599]: the method\
    \ `count` exists for struct `Filter<Chars<'_>, fn(char) -> bool {no_vowels}>`,\
    \ but its trait bounds were not satisfied\n  --> /tmp/tmpe0iegn1k.rs:20:49\n \
    \  |\n20 |           .filter(|w| w.chars().filter(no_vowels).count() as isize\
    \ == n)\n   |                                                   ^^^^^ method cannot\
    \ be called on `Filter<Chars<'_>, fn(char) -> bool {no_vowels}>` due to unsatisfied\
    \ trait bounds\n   |\n   = note: the following trait bounds were not satisfied:\n\
    \           `<fn(char) -> bool {no_vowels} as FnOnce<(&char,)>>::Output = bool`\n\
    \           which is required by `Filter<Chars<'_>, fn(char) -> bool {no_vowels}>:\
    \ Iterator`\n           `fn(char) -> bool {no_vowels}: FnMut<(&char,)>`\n    \
    \       which is required by `Filter<Chars<'_>, fn(char) -> bool {no_vowels}>:\
    \ Iterator`\n           `Filter<Chars<'_>, fn(char) -> bool {no_vowels}>: Iterator`\n\
    \           which is required by `&mut Filter<Chars<'_>, fn(char) -> bool {no_vowels}>:\
    \ Iterator`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0599, E0631.\nFor more information about an error, try `rustc\
    \ --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n\tlet s = s.to_lowercase();\n\tlet s = s.split_whitespace();\n\
    \tlet vowels = ['a', 'e', 'i', 'o', 'u'];\n\tlet mut result = Vec::new();\n\t\
    for ss in s {\n\t\tlet mut consonants = 0;\n\t\tfor c in ss.chars() {\n\t\t\t\
    if !vowels.contains(&c) {\n\t\t\t\tconsonants += 1;\n\t\t\t}\n\t\t}\n\t\tif consonants\
    \ == n {\n\t\t\tresult.push(ss.to_string());\n\t\t}\n\t}\n\tresult\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"mary\", \"lamb\"]`,\n right: `[\"Mary\", \"lamb\"]`', /tmp/tmplbj4iemd.rs:34:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    s.split_whitespace()\n        .filter(|w|\
    \ w.matches(|c: char| c.is_consonant()).count() as isize == n)\n        .map(|w|\
    \ w.to_string())\n        .collect()\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmppwts8rj1.rs:14:43\n   |\n14 |         .filter(|w|\
    \ w.matches(|c: char| c.is_consonant()).count() as isize == n)\n   |         \
    \                                  ^^^^^^^^^^^^ method not found in `char`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    s.split_whitespace()\n        .filter(|&word|\
    \ count_consonants(word) == n)\n        .map(|word| word.to_string())\n      \
    \  .collect()\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `count_consonants` in this scope\n \
    \ --> /tmp/tmpzjjn_bm_.rs:14:25\n   |\n14 |         .filter(|&word| count_consonants(word)\
    \ == n)\n   |                         ^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    if s.len() == 0 {\n        return vec![];\n\
    \    }\n    let words: Vec<String> = s.split(\" \").map(|x| x.to_string()).collect();\n\
    \    let mut result: Vec<String> = vec![];\n    for word in words {\n        let\
    \ consonants = word.chars().filter(|&x| \"aeiouAEIOU\".contains(x)).count();\n\
    \        if consonants == n as usize {\n            result.push(word);\n     \
    \   }\n    }\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"little\"]`', /tmp/tmpcx4_qul9.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    s.split_whitespace()\n        .map(|w|\
    \ w.to_string())\n        .filter(|w| w.chars().filter(|c| c.is_consonant()).count()\
    \ as isize == n)\n        .collect()\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_consonant` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmp14kvdtvn.rs:15:44\n   |\n15 |         .filter(|w|\
    \ w.chars().filter(|c| c.is_consonant()).count() as isize == n)\n   |        \
    \                                    ^^^^^^^^^^^^ method not found in `&char`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n\
    /// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n///\
    \ select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n    unimplemented!();\n}\n\nfn main() {\n\
    \    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary\
    \ had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpsth1x8_h.rs:13:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
