name: HumanEval_59_largest_prime_factor
language: rs
prompt: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
  /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
  /// 2\nfn largest_prime_factor(n: isize) -> isize {\n"
tests: "}\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
  \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n  \
  \  assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n}\n"
completions: ["    if is_prime(n) {\n        return n;\n    }\n    let mut factor\
    \ = 2;\n    while factor <= n {\n        if n % factor == 0 {\n            return\
    \ largest_prime_factor(n / factor);\n        }\n        factor += 1;\n    }\n\
    \    0", "    let mut p = 2;\n    let mut num = n;\n    let mut max_p = 1;\n \
    \   while p * p <= num {\n        if num % p == 0 {\n            max_p = p;\n\
    \            while num % p == 0 {\n                num /= p;\n            }\n\
    \        }\n        p += 1;\n    }\n    if num > 1 {\n        max_p = num;\n \
    \   }\n    max_p", "    let last_num = (n as f64).sqrt() as isize;\n    let mut\
    \ res = n;\n    for x in (2..last_num + 1).rev() {\n        if n % x == 0 && is_prime(x)\
    \ {\n            res = x;\n            break;\n        }\n    }\n    res", " \
    \   let mut f = 2;\n    let mut n = n;\n    while n > 1 {\n        while n % f\
    \ == 0 {\n            n /= f;\n        }\n        f += 1;\n    }\n    f - 1",
  "    let mut x = n;\n    for i in 2..((x as f64).sqrt() as isize) {\n        while\
    \ x % i == 0 {\n            x = x / i;\n        }\n    }\n    x", "    let mut\
    \ factor = 2;\n    let mut largest_factor = 0;\n    while factor <= n {\n    \
    \    if n % factor == 0 {\n            largest_factor = factor;\n            n\
    \ /= factor;\n        } else {\n            factor += 1;\n        }\n    }\n \
    \   largest_factor", "    let n = n as usize;\n    let mut factors = vec![];\n\
    \    let mut largest_prime = n;\n    let sqrt = n.sqrt();\n    for factor in 2..sqrt\
    \ {\n        if n % factor == 0 {\n            factors.push(factor);\n       \
    \     factors.push(n / factor);\n        }\n    }\n    factors.sort();\n    for\
    \ factor in factors {\n        let mut is_prime = true;\n        for i in 2..factor\
    \ {\n            if factor % i == 0 {\n                is_prime = false;\n   \
    \             break;\n            }\n        }\n        if is_prime {\n      \
    \      largest_prime = factor;\n        }\n    }\n    largest_prime as isize",
  "    let mut n = n;\n    let mut factor = 2;\n    while n > 1 {\n        if n %\
    \ factor == 0 {\n            n /= factor;\n        } else {\n            factor\
    \ += 1;\n        }\n    }\n    factor", "    let mut n = n;\n    let mut largest_factor\
    \ = 2;\n    while n != 1 {\n        if n % largest_factor == 0 {\n           \
    \ n /= largest_factor;\n        } else {\n            largest_factor += 1;\n \
    \       }\n    }\n    largest_factor", "    let mut largest_factor = 0;\n    let\
    \ mut p = 2;\n    while p * p <= n {\n        if n % p == 0 {\n            largest_factor\
    \ = p;\n            n /= p;\n        } else {\n            p += 1;\n        }\n\
    \    }\n    if n > 1 {\n        largest_factor = n;\n    }\n    largest_factor",
  "    let mut largest_factor = 1;\n    let mut factor = 2;\n    let mut remaining\
    \ = n;\n    while remaining > 1 {\n        while remaining % factor == 0 {\n \
    \           largest_factor = factor;\n            remaining /= factor;\n     \
    \   }\n        factor += 1;\n    }\n    largest_factor", "    fn is_prime(m: isize)\
    \ -> bool {\n        let root = (m as f64).sqrt() as isize;\n        let mut i\
    \ = 2;\n        while i <= root {\n            if m % i == 0 {\n             \
    \   return false;\n            }\n            i += 1;\n        }\n        true\n\
    \    }\n\n    let mut n = n;\n    let mut factor = n;\n    let mut root = (n as\
    \ f64).sqrt() as isize;\n    while factor > root {\n        if n % factor == 0\
    \ && is_prime(factor) {\n            return factor;\n        }\n        factor\
    \ -= 1;\n    }\n    factor", "    if n % 2 == 0 {\n        2\n    } else {\n \
    \       for i in (3..n).step_by(2) {\n            if n % i == 0 {\n          \
    \      return largest_prime_factor(n / i);\n            }\n        }\n       \
    \ panic!(\"logic error\");\n    }", "    let max_possible_factor = (n as f64).sqrt()\
    \ as isize;\n    let mut prime_factors = vec![];\n    for factor in (2..max_possible_factor\
    \ + 1).step_by(2) {\n        if n % factor == 0 {\n            let mut is_prime\
    \ = true;\n            for prime_factor in &prime_factors {\n                if\
    \ factor % prime_factor == 0 {\n                    is_prime = false;\n      \
    \              break;\n                }\n            }\n            if is_prime\
    \ {\n                prime_factors.push(factor);\n            }\n        }\n \
    \   }\n    prime_factors.pop().unwrap()", "    let mut max_factor = 1;\n    let\
    \ mut prime_factor = 2;\n    let mut remaining = n;\n    while remaining != 1\
    \ {\n        if remaining % prime_factor == 0 {\n            max_factor = prime_factor;\n\
    \            remaining /= prime_factor;\n        } else {\n            prime_factor\
    \ += 1;\n        }\n    }\n    max_factor", "    let mut max = 0;\n    let mut\
    \ i = 2;\n    while i <= n {\n        if n % i == 0 {\n            max = i;\n\
    \            n /= i;\n        } else {\n            i += 1;\n        }\n    }\n\
    \    max", "    let mut factor = 2;\n    let mut f = n;\n    while f > 1 {\n \
    \       if f % factor == 0 {\n            f /= factor;\n        } else {\n   \
    \         factor += 1;\n        }\n    }\n    factor", "    let mut prime = 2;\n\
    \    let mut factor = n;\n    while prime <= factor {\n        while factor %\
    \ prime == 0 {\n            factor /= prime;\n        }\n        prime += 1;\n\
    \    }\n    prime - 1", "    if is_prime(n) {\n        return n;\n    }\n    let\
    \ mut prime_factors = vec![];\n    let mut m = n;\n    while m > 1 {\n       \
    \ for p in (2..m).rev() {\n            if is_prime(p) && m % p == 0 {\n      \
    \          prime_factors.push(p);\n                m /= p;\n                break;\n\
    \            }\n        }\n    }\n    prime_factors.iter().max().unwrap().clone()",
  "    // First, generate the factors of n\n    let mut factor = n;\n    for i in\
    \ 2..n {\n        if n % i == 0 {\n            factor = i;\n            break;\n\
    \        }\n    }\n\n    // Then, reduce the factor to its largest prime factor\n\
    \    let mut reduced_factor = factor;\n    for i in 2..factor {\n        if factor\
    \ % i == 0 {\n            reduced_factor = i;\n            break;\n        }\n\
    \    }\n\n    reduced_factor"]
stop_tokens:
- "\n}"
