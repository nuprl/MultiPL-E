language: rs
name: HumanEval_12_longest
results:
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    let mut length: usize = 0;\n    let mut result: Option<String>\
    \ = None;\n    for s in strings {\n        if s.len() > length {\n           \
    \ length = s.len();\n            result = Some(s);\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822484
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    let mut result = None;\n    let mut max_len = 0;\n\
    \    for s in strings {\n        if s.len() > max_len {\n            max_len =\
    \ s.len();\n            result = Some(s);\n        }\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822484
- exit_code: 1
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    let mut longest_string = None;\n    for string in strings\
    \ {\n        if longest_string.is_none() || string.len() > longest_string.unwrap().len()\
    \ {\n            longest_string = Some(string);\n        }\n    }\n    longest_string\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `Option<T>`\n  --> /tmp/tmplmnfnku5.rs:11:70\n\
    \   |\n9  |     let mut longest_string = None;\n   |         ------------------\
    \ consider giving `longest_string` the explicit type `Option<T>`, where the type\
    \ parameter `T` is specified\n10 |     for string in strings {\n11 |         if\
    \ longest_string.is_none() || string.len() > longest_string.unwrap().len() {\n\
    \   |                                                                      ^^^^^^\
    \ cannot infer type for type parameter `T`\n   |\n   = note: type must be known\
    \ at this point\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659822484
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    if strings.is_empty() {\n        return None;\n   \
    \ }\n    let mut max = String::new();\n    for x in strings {\n        if x.len()\
    \ > max.len() {\n            max = x;\n        }\n    }\n    Some(max)\n}\n\n\
    fn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822484
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    if strings.is_empty() {\n        return None;\n   \
    \ }\n    let mut longest = strings[0].clone();\n    for s in strings {\n     \
    \   if s.len() > longest.len() {\n            longest = s;\n        }\n    }\n\
    \    Some(longest)\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822484
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    if strings.is_empty() {\n        return None;\n   \
    \ }\n    let mut longest = strings[0].clone();\n    for i in 1..strings.len()\
    \ {\n        if strings[i].len() > longest.len() {\n            longest = strings[i].clone();\n\
    \        }\n    }\n    Some(longest)\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822484
- exit_code: 1
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    strings.into_iter().max_by_key(|s| s.len()).cloned()\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: the method `cloned` exists for enum `Option<String>`, but\
    \ its trait bounds were not satisfied\n   --> /tmp/tmp4700gr82.rs:9:49\n    |\n\
    9   |       strings.into_iter().max_by_key(|s| s.len()).cloned()\n    |      \
    \                                             ^^^^^^ method cannot be called on\
    \ `Option<String>` due to unsatisfied trait bounds\n    |\n    = note: the following\
    \ trait bounds were not satisfied:\n            `Option<String>: Iterator`\n \
    \           which is required by `&mut Option<String>: Iterator`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659822484
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    let mut longest_word: Option<String> = None;\n    let\
    \ mut max_len = 0;\n    for s in strings {\n        if s.len() > max_len {\n \
    \           max_len = s.len();\n            longest_word = Some(s);\n        }\n\
    \    }\n    longest_word\n}\n\nfn main() {\n    let candidate = longest;\n   \
    \ assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822484
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    let mut longest = String::new();\n    for s in strings\
    \ {\n        if s.len() > longest.len() {\n            longest = s;\n        }\n\
    \    }\n    if longest.len() > 0 {\n        Some(longest)\n    } else {\n    \
    \    None\n    }\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822484
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    let mut longest_string: Option<String> = None;\n  \
    \  let mut longest_length: Option<usize> = None;\n    for string in strings {\n\
    \        let string_length = string.len();\n        if longest_length.is_none()\
    \ || string_length > longest_length.unwrap() {\n            longest_string = Some(string);\n\
    \            longest_length = Some(string_length);\n        }\n    }\n    longest_string\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822484
- exit_code: 101
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    strings.into_iter().max_by_key(|string| string.len()).map(|string|\
    \ string.to_string())\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(\"z\")`,\n right: `Some(\"x\")`', /tmp/tmphl05hlku.rs:15:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822484
- exit_code: 101
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpltl9rkkc.rs:9:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659822484
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    match strings.len() {\n        0 => None,\n       \
    \ _ => {\n            let mut longest = strings[0].clone();\n            for string\
    \ in strings.iter() {\n                if string.len() > longest.len() {\n   \
    \                 longest = string.clone();\n                }\n            }\n\
    \            Some(longest)\n        }\n    }\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822484
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    if strings.is_empty() {\n        return None;\n   \
    \ }\n    // We need to return the string, not the reference\n    let mut max_string\
    \ = String::new();\n    for string in strings {\n        if string.len() > max_string.len()\
    \ {\n            max_string = string;\n        }\n    }\n    Some(max_string)\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822484
- exit_code: 101
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    // TODO\n    None\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `None`,\n right: `Some(\"x\")`', /tmp/tmpfijv28lg.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822484
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    let mut longest = String::new();\n    for s in strings\
    \ {\n        if s.len() > longest.len() {\n            longest = s;\n        }\n\
    \    }\n    if longest.len() > 0 {\n        Some(longest)\n    } else {\n    \
    \    None\n    }\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822484
- exit_code: 1
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    let mut longest = None;\n    for s in strings {\n \
    \       match longest {\n            None => longest = Some(s),\n            Some(s_old)\
    \ => if s.len() > s_old.len() {\n                longest = Some(s);\n        \
    \    },\n        }\n    }\n    longest\n}\n\nfn main() {\n    let candidate =\
    \ longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value\n  --> /tmp/tmpd3nkl3pw.rs:13:18\n   |\n\
    13 |             Some(s_old) => if s.len() > s_old.len() {\n   |             \
    \     ^^^^^ value moved here, in previous iteration of loop\n   |\nnote: these\
    \ 2 reinitializations might get skipped\n  --> /tmp/tmpd3nkl3pw.rs:12:21\n   |\n\
    12 |             None => longest = Some(s),\n   |                     ^^^^^^^\n\
    13 |             Some(s_old) => if s.len() > s_old.len() {\n14 |             \
    \    longest = Some(s);\n   |                 ^^^^^^^\n   = note: move occurs\
    \ because value has type `String`, which does not implement the `Copy` trait\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659822484
- exit_code: 1
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    let mut result = None;\n    let mut longest_len = 0;\n\
    \    for string in strings {\n        if string.len() > longest_len {\n      \
    \      result = Some(string);\n            longest_len = string.len();\n     \
    \   }\n    }\n    result\n}\n\nfn main() {\n    let candidate = longest;\n   \
    \ assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `string`\n  --> /tmp/tmpxphsoa66.rs:14:27\n\
    \   |\n11 |     for string in strings {\n   |         ------ move occurs because\
    \ `string` has type `String`, which does not implement the `Copy` trait\n12 |\
    \         if string.len() > longest_len {\n13 |             result = Some(string);\n\
    \   |                           ------ value moved here\n14 |             longest_len\
    \ = string.len();\n   |                           ^^^^^^ value borrowed here after\
    \ move\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659822484
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    let mut longest_so_far = None;\n    for string in strings\
    \ {\n        match longest_so_far {\n            None => longest_so_far = Some(string),\n\
    \            Some(ref prev) => {\n                if string.len() > prev.len()\
    \ {\n                    longest_so_far = Some(string);\n                }\n \
    \           }\n        }\n    }\n    longest_so_far\n}\n\nfn main() {\n    let\
    \ candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"), String::from(\"\
    z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822484
- exit_code: 101
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    // TODO\n    None\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `None`,\n right: `Some(\"x\")`', /tmp/tmpfijv28lg.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822484
