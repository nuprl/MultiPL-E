name: HumanEval_132_is_nested
language: rs
prompt: "/// Create a function that takes a string as input which contains only square\
  \ brackets.\n/// The function should return True if and only if there is a valid\
  \ subsequence of brackets \n/// where at least one bracket in the subsequence is\
  \ nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]') \u279E\
  \ False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E False\n\
  /// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\nfn is_nested(string:\
  \ String) -> bool {\n"
tests: "}\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
  [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n\
  \    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
  []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
  \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
  [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
  \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
  [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
  \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
  [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
  }\n"
completions: ["    let mut stack = Vec::new();\n    for c in string.chars() {\n  \
    \      match c {\n            '[' => stack.push(c),\n            ']' => if stack.len()\
    \ == 0 { return false } else { stack.pop(); },\n            _ => return false,\n\
    \        }\n    }\n    stack.len() == 0", "    let mut count = 0;\n    for i in\
    \ string.chars() {\n        if i == '[' {\n            count += 1;\n        }\
    \ else {\n            count -= 1;\n        }\n        if count < 0 {\n       \
    \     return false;\n        }\n    }\n    count == 0", "    let mut result =\
    \ true;\n    let mut count = 0;\n    for s in string.chars() {\n        if s ==\
    \ '[' {\n            count += 1;\n        } else {\n            count -= 1;\n\
    \        }\n        if count < 0 {\n            result = false;\n            break;\n\
    \        }\n    }\n    if count != 0 {\n        result = false;\n    }\n    result",
  "    if string.len() == 0 {\n        return false;\n    }\n    let mut brackets:\
    \ Vec<char> = string.chars().collect();\n    let mut counter = 0;\n    let mut\
    \ result = false;\n    let mut last_index = 0;\n    for index in 0..brackets.len()\
    \ {\n        if brackets[index] == '[' {\n            counter += 1;\n        }\
    \ else {\n            counter -= 1;\n        }\n        if counter == 0 {\n  \
    \          last_index = index;\n            result = true;\n        }\n    }\n\
    \    if counter != 0 {\n        return false;\n    }\n    let mut brackets: Vec<char>\
    \ = string[..last_index + 1].chars().collect();\n    let mut counter = 0;\n  \
    \  for bracket in brackets {\n        if bracket == '[' {\n            counter\
    \ += 1;\n        } else {\n            counter -= 1;\n        }\n        if counter\
    \ < 0 {\n            return false;\n        }\n    }\n    result", "    let mut\
    \ stack = vec![];\n    for c in string.chars() {\n        if c == '[' {\n    \
    \        stack.push(c);\n        } else if c == ']' {\n            if stack.is_empty()\
    \ {\n                return false;\n            }\n            stack.pop();\n\
    \        }\n    }\n    false", "    let mut v: Vec<u8> = Vec::new();\n    for\
    \ c in string.chars() {\n        if c == '[' {\n            v.push(1);\n     \
    \   } else {\n            if v.len() > 0 {\n                v.pop();\n       \
    \     } else {\n                return false;\n            }\n        }\n    }\n\
    \    v.len() > 0", "    let mut lvl = 0;\n    for c in string.chars() {\n    \
    \    if c == '[' {\n            lvl += 1;\n        } else {\n            lvl -=\
    \ 1;\n        }\n        if lvl < 0 {\n            return false;\n        }\n\
    \    }\n    lvl == 0", "    string.chars().fold(Vec::new(), |mut acc, c| {\n \
    \       if let Some(last) = acc.last() {\n            if last == &'[' && c ==\
    \ ']' {\n                acc.pop();\n                return acc;\n           \
    \ }\n        }\n        acc.push(c);\n        acc\n    }).is_empty()", "    let\
    \ mut level = 0;\n    for ch in string.chars() {\n        match ch {\n       \
    \     '[' => level += 1,\n            ']' => {\n                if level <= 0\
    \ {\n                    return false;\n                }\n                level\
    \ -= 1;\n            }\n            _ => {}\n        }\n    }\n    level > 0",
  "    let mut left_count = 0;\n    let mut right_count = 0;\n    for c in string.chars()\
    \ {\n        if c == '[' {\n            left_count += 1;\n        } else {\n \
    \           right_count += 1;\n        }\n        if right_count > left_count\
    \ {\n            return false;\n        }\n    }\n    left_count > right_count",
  "    let mut i = 0;\n    for c in string.chars() {\n        if c == '[' {\n    \
    \        i += 1;\n        } else {\n            i -= 1;\n        }\n        if\
    \ i < 0 {\n            return false;\n        }\n    }\n    if i == 0 {\n    \
    \    return true;\n    }\n    false", "    let mut depth = 0;\n    let mut max_depth\
    \ = 0;\n    for c in string.chars() {\n        match c {\n            '[' => depth\
    \ += 1,\n            ']' => depth -= 1,\n            _ => panic!(\"should only\
    \ be square brackets\"),\n        }\n        if depth < 0 {\n            return\
    \ false;\n        }\n        if depth > max_depth {\n            max_depth = depth;\n\
    \        }\n    }\n    max_depth >= 2", "    let mut v: Vec<char> = Vec::new();\n\
    \    for c in string.chars() {\n        match c {\n            '[' => v.push(c),\n\
    \            ']' => {\n                if v.len() > 0 {\n                    let\
    \ d = v.pop().unwrap();\n                    if d != '[' {\n                 \
    \       return false;\n                    }\n                } else {\n     \
    \               return false;\n                }\n            }\n            _\
    \ => {}\n        }\n    }\n    v.len() == 0", "    let mut stack = Vec::new();\n\
    \    let mut iter = string.chars();\n    while let Some(c) = iter.next() {\n \
    \       if let Some(last) = stack.last() {\n            if *last == c {\n    \
    \            stack.pop();\n            } else {\n                stack.push(c);\n\
    \            }\n        } else {\n            stack.push(c);\n        }\n    }\n\
    \    stack.is_empty()", '    unimplemented!()', "    let mut counter = 0;\n  \
    \  for bracket in string.chars() {\n        if bracket == '[' {\n            counter\
    \ += 1;\n        } else {\n            counter -= 1;\n        }\n        if counter\
    \ < 0 {\n            return false;\n        }\n    }\n    counter == 0", "   \
    \ let mut stack = vec![];\n    let mut has_left = false;\n    for c in string.chars()\
    \ {\n        match c {\n            '[' => {\n                has_left = true;\n\
    \                stack.push(c);\n            }\n            ']' => {\n       \
    \         if stack.is_empty() {\n                    return false;\n         \
    \       }\n                stack.pop();\n            }\n            _ => return\
    \ false,\n        }\n    }\n    stack.is_empty() && has_left", "    let mut open_brackets\
    \ = 0;\n    let mut close_brackets = 0;\n    for b in string.chars() {\n     \
    \   if b == '[' {\n            open_brackets += 1;\n        } else {\n       \
    \     close_brackets += 1;\n        }\n        if close_brackets > open_brackets\
    \ {\n            return false;\n        }\n    }\n    return open_brackets ==\
    \ close_brackets && open_brackets > 0;", "    let mut count = 0;\n    for s in\
    \ string.chars() {\n        if s == '[' {\n            count += 1;\n        }\
    \ else {\n            count -= 1;\n        }\n        if count < 0 {\n       \
    \     return false;\n        }\n    }\n    count > 0", "    // We use a stack\
    \ to track an \"open\" position of the brackets\n    let mut stack: Vec<u8> =\
    \ Vec::new();\n    for ch in string.as_bytes() {\n        match ch {\n       \
    \     b'[' => stack.push(ch),\n            b']' => {\n                if stack.is_empty()\
    \ {\n                    return false;\n                }\n                let\
    \ last = stack.pop().unwrap();\n                if last != b'[' {\n          \
    \          return false;\n                }\n            }\n            _ => {}\n\
    \        }\n    }\n    stack.is_empty()"]
stop_tokens:
- "\n}"
