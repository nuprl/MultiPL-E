language: rs
name: HumanEval_112_reverse_delete
results:
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let s_chars: Vec<char> = s.chars().collect();\n\
    \    let c_chars: Vec<char> = c.chars().collect();\n    let mut result: Vec<char>\
    \ = Vec::new();\n    for s_char in s_chars {\n        if !c_chars.contains(&s_char)\
    \ {\n            result.push(s_char);\n        }\n    }\n    let result_string:\
    \ String = result.into_iter().collect();\n    let result_runes: Vec<char> = result_string.chars().collect();\n\
    \    let mut result_runes_reverse: Vec<char> = Vec::new();\n    let len: usize\
    \ = result_runes.len();\n    for i in 0..len {\n        result_runes_reverse.push(result_runes[len\
    \ - i - 1]);\n    }\n    let result_string_reverse: String = result_runes_reverse.into_iter().collect();\n\
    \    (result_string, result_string == result_string_reverse)\n}\n\nfn main() {\n\
    \    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `result_string`\n  --> /tmp/tmpz__rfz5p.rs:27:21\n\
    \   |\n19 |     let result_string: String = result.into_iter().collect();\n  \
    \ |         ------------- move occurs because `result_string` has type `String`,\
    \ which does not implement the `Copy` trait\n...\n27 |     (result_string, result_string\
    \ == result_string_reverse)\n   |      -------------  ^^^^^^^^^^^^^ value borrowed\
    \ here after move\n   |      |\n   |      value moved here\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659822475
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut new_s = String::new();\n    for i in\
    \ s.chars() {\n        if !c.contains(i) {\n            new_s.push(i);\n     \
    \   }\n    }\n    let s_rev: String = new_s.chars().rev().collect();\n    (new_s,\
    \ new_s == s_rev)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n   \
    \ assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `new_s`\n  --> /tmp/tmp9dxn17q7.rs:18:13\n\
    \   |\n11 |     let mut new_s = String::new();\n   |         --------- move occurs\
    \ because `new_s` has type `String`, which does not implement the `Copy` trait\n\
    ...\n18 |     (new_s, new_s == s_rev)\n   |      -----  ^^^^^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659822475
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut result = String::new();\n    for i\
    \ in s.chars() {\n        if !c.contains(i) {\n            result.push(i);\n \
    \       }\n    }\n    if result == result.chars().rev().collect::<String>() {\n\
    \        (result, true)\n    } else {\n        (result, false)\n    }\n}\n\nfn\
    \ main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822476
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut res: String = s.chars().filter(|&x|\
    \ !c.contains(x)).collect();\n    let t = res.clone();\n    res.reverse();\n \
    \   (t, res == t)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n   \
    \ assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `reverse` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmp7izfc9jr.rs:13:9\n   |\n13 |     res.reverse();\n\
    \   |         ^^^^^^^ help: there is an associated function with a similar name:\
    \ `reserve`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659822475
- exit_code: 101
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    unimplemented!()\n}\n\nfn main() {\n    let\
    \ candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"\
    ), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp0o8x5zwp.rs:11:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659822476
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let chars: HashSet<char> = c.chars().collect();\n\
    \    let mut s: String = s.chars().filter(|x| !chars.contains(x)).collect();\n\
    \    let mut res = s.clone();\n    res.reverse();\n    (s, res == s)\n}\n\nfn\
    \ main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmp6vyryw2a.rs:11:16\n\
    \   |\n11 |     let chars: HashSet<char> = c.chars().collect();\n   |        \
    \        ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0599]: no\
    \ method named `reverse` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmp6vyryw2a.rs:14:9\n   |\n14 |     res.reverse();\n   |         ^^^^^^^\
    \ help: there is an associated function with a similar name: `reserve`\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0412, E0599.\nFor more information about an error, try `rustc --explain E0412`.\n"
  stdout: ''
  timestamp: 1659822475
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut output = String::new();\n    let s:\
    \ Vec<char> = s.chars().collect();\n    let c: Vec<char> = c.chars().collect();\n\
    \    for i in s {\n        if !c.contains(&i) {\n            output.push(i);\n\
    \        }\n    }\n    let check = output.chars().eq(output.chars().rev());\n\
    \    (output, check)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822476
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut ss = s.chars().filter(|c| !c.is_whitespace()).collect::<Vec<char>>();\n\
    \    let cs = c.chars().filter(|c| !c.is_whitespace()).collect::<Vec<char>>();\n\
    \    ss.retain(|x| !cs.contains(x));\n    (ss.iter().collect::<String>(), ss.iter().rev().eq(ss.iter()))\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822476
- exit_code: 101
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut string: String = String::new();\n \
    \   let mut chars = s.chars();\n    let mut chars_clone = chars.clone();\n   \
    \ let mut current = chars.next();\n    let mut current_rev = chars_clone.next_back();\n\
    \    while current.is_some() && current_rev.is_some() {\n        if c.contains(current.unwrap())\
    \ {\n            current = chars.next();\n        } else if c.contains(current_rev.unwrap())\
    \ {\n            current_rev = chars_clone.next_back();\n        } else if current.unwrap()\
    \ == current_rev.unwrap() {\n            string.push(current.unwrap());\n    \
    \        current = chars.next();\n            current_rev = chars_clone.next_back();\n\
    \        } else {\n            return (string, false);\n        }\n    }\n   \
    \ (string, true)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(\"\", false)`,\n right: `(\"bcd\", false)`', /tmp/tmp2xnqhi6a.rs:34:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822476
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut result = String::new();\n    let mut\
    \ is_palindrome = true;\n    for c_s in s.chars() {\n        if !c.contains(c_s)\
    \ {\n            result.push(c_s);\n        }\n    }\n    let reverse_result =\
    \ result.chars().rev().collect::<String>();\n    if reverse_result != result {\n\
    \        is_palindrome = false;\n    }\n    (result, is_palindrome)\n}\n\nfn main()\
    \ {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822476
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let s: Vec<char> = s.chars().collect();\n \
    \   let c: Vec<char> = c.chars().collect();\n    let filtered_s: Vec<char> = s.iter().filter(|&x|\
    \ !c.contains(x)).collect();\n    let filtered_s: String = filtered_s.iter().collect();\n\
    \    let is_pali = filtered_s == filtered_s.chars().rev().collect::<String>();\n\
    \    (filtered_s, is_pali)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<char>` cannot be built from an iterator\
    \ over elements of type `&char`\n  --> /tmp/tmpvzw_6rxy.rs:13:70\n   |\n13 | \
    \    let filtered_s: Vec<char> = s.iter().filter(|&x| !c.contains(x)).collect();\n\
    \   |                                                                      ^^^^^^^\
    \ value of type `Vec<char>` cannot be built from `std::iter::Iterator<Item=&char>`\n\
    \   |\n   = help: the trait `FromIterator<&char>` is not implemented for `Vec<char>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822475
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut removed = s.chars().filter(|x| !c.contains(x)).collect::<String>();\n\
    \    let result = (removed.clone(), removed == removed.chars().rev().collect::<String>());\n\
    \    result\n}\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n  --> /tmp/tmprqgf2kqu.rs:11:56\n\
    \   |\n11 |     let mut removed = s.chars().filter(|x| !c.contains(x)).collect::<String>();\n\
    \   |                                                        ^ expected an `Fn<(char,)>`\
    \ closure, found `char`\n   |\n   = help: the trait `Fn<(char,)>` is not implemented\
    \ for `char`\n   = note: required because of the requirements on the impl of `FnOnce<(char,)>`\
    \ for `&char`\n   = note: required because of the requirements on the impl of\
    \ `Pattern<'_>` for `&char`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822475
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    (s.chars().filter(|x| !c.contains(x)).collect::<String>(),\
    \ false)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n  --> /tmp/tmpgnz1287r.rs:11:39\n\
    \   |\n11 |     (s.chars().filter(|x| !c.contains(x)).collect::<String>(), false)\n\
    \   |                                       ^ expected an `Fn<(char,)>` closure,\
    \ found `char`\n   |\n   = help: the trait `Fn<(char,)>` is not implemented for\
    \ `char`\n   = note: required because of the requirements on the impl of `FnOnce<(char,)>`\
    \ for `&char`\n   = note: required because of the requirements on the impl of\
    \ `Pattern<'_>` for `&char`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822475
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    (\n        s.chars()\n            .filter(|x|\
    \ !c.contains(x))\n            .collect::<String>(),\n        s.chars()\n    \
    \        .filter(|x| !c.contains(x))\n            .collect::<String>()\n     \
    \       .chars()\n            .eq(\n                s.chars()\n              \
    \      .filter(|x| !c.contains(x))\n                    .rev()\n             \
    \       .collect::<String>()\n                    .chars(),\n            ),\n\
    \    )\n}\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n  --> /tmp/tmpibdfkegv.rs:13:37\n\
    \   |\n13 |             .filter(|x| !c.contains(x))\n   |                    \
    \                 ^ expected an `Fn<(char,)>` closure, found `char`\n   |\n  \
    \ = help: the trait `Fn<(char,)>` is not implemented for `char`\n   = note: required\
    \ because of the requirements on the impl of `FnOnce<(char,)>` for `&char`\n \
    \  = note: required because of the requirements on the impl of `Pattern<'_>` for\
    \ `&char`\n\nerror[E0277]: expected a `Fn<(char,)>` closure, found `char`\n  -->\
    \ /tmp/tmpibdfkegv.rs:16:37\n   |\n16 |             .filter(|x| !c.contains(x))\n\
    \   |                                     ^ expected an `Fn<(char,)>` closure,\
    \ found `char`\n   |\n   = help: the trait `Fn<(char,)>` is not implemented for\
    \ `char`\n   = note: required because of the requirements on the impl of `FnOnce<(char,)>`\
    \ for `&char`\n   = note: required because of the requirements on the impl of\
    \ `Pattern<'_>` for `&char`\n\nerror[E0277]: expected a `Fn<(char,)>` closure,\
    \ found `char`\n  --> /tmp/tmpibdfkegv.rs:21:45\n   |\n21 |                  \
    \   .filter(|x| !c.contains(x))\n   |                                        \
    \     ^ expected an `Fn<(char,)>` closure, found `char`\n   |\n   = help: the\
    \ trait `Fn<(char,)>` is not implemented for `char`\n   = note: required because\
    \ of the requirements on the impl of `FnOnce<(char,)>` for `&char`\n   = note:\
    \ required because of the requirements on the impl of `Pattern<'_>` for `&char`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822475
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut s = s;\n    for char in c.chars() {\n\
    \        s = s.replace(char, \"\");\n    }\n    return (s, s == s.chars().rev().collect::<String>());\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpyecb92ys.rs:15:16\n\
    \   |\n11 |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n15 |     return\
    \ (s, s == s.chars().rev().collect::<String>());\n   |             -  ^ value\
    \ borrowed here after move\n   |             |\n   |             value moved here\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659822475
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut a: Vec<char> = vec![];\n    for i in\
    \ s.chars() {\n        if !c.contains(i) {\n            a.push(i);\n        }\n\
    \    }\n    let a = a.iter().collect::<String>();\n    let b = a.chars().rev().collect::<String>();\n\
    \    (a, a == b)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `a`\n  --> /tmp/tmp1apb5yul.rs:19:9\n\
    \   |\n17 |     let a = a.iter().collect::<String>();\n   |         - move occurs\
    \ because `a` has type `String`, which does not implement the `Copy` trait\n18\
    \ |     let b = a.chars().rev().collect::<String>();\n19 |     (a, a == b)\n \
    \  |      -  ^ value borrowed here after move\n   |      |\n   |      value moved\
    \ here\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659822475
- exit_code: 101
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let mut is_palindrome = true;\n    let mut\
    \ result = String::new();\n    let mut index = 0;\n    for char in s.chars() {\n\
    \        if !c.contains(char) {\n            result.push(char);\n            if\
    \ char != s.chars().nth(s.len() - index - 1).unwrap() {\n                is_palindrome\
    \ = false;\n            }\n            index += 1;\n        }\n    }\n    (result,\
    \ is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(\"cdedc\", false)`,\n right: `(\"cdedc\", true)`', /tmp/tmpac25igjd.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822476
- exit_code: 101
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    unimplemented!()\n}\n\nfn main() {\n    let\
    \ candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"\
    ), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp0o8x5zwp.rs:11:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659822476
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    let new_string = s.chars().filter(|x| !c.contains(x)).collect::<String>();\n\
    \    (new_string, new_string == new_string.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n  --> /tmp/tmpjvzoy7ts.rs:11:55\n\
    \   |\n11 |     let new_string = s.chars().filter(|x| !c.contains(x)).collect::<String>();\n\
    \   |                                                       ^ expected an `Fn<(char,)>`\
    \ closure, found `char`\n   |\n   = help: the trait `Fn<(char,)>` is not implemented\
    \ for `char`\n   = note: required because of the requirements on the impl of `FnOnce<(char,)>`\
    \ for `&char`\n   = note: required because of the requirements on the impl of\
    \ `Pattern<'_>` for `&char`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822475
- exit_code: 101
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// For s = \"abcde\"\
    , c = \"ae\", the result should be ('bcd',False)\n/// For s = \"abcdef\", c =\
    \ \"b\"  the result should be ('acdef',False)\n/// For s = \"abcdedcba\", c =\
    \ \"ab\", the result should be ('cdedc',True)\nfn reverse_delete(s: String, c:\
    \ String) -> (String, bool) {\n    unimplemented!()\n}\n\nfn main() {\n    let\
    \ candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"\
    ), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp0o8x5zwp.rs:11:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659822476
