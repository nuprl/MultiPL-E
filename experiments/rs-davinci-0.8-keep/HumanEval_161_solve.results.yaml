language: rs
name: HumanEval_161_solve
results:
- exit_code: 1
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().map(|c| if c.is_alphabetic() { c.swap_case() } else\
    \ { c }).collect()\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `swap_case` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpb4um8pi1.rs:11:48\n   |\n11 |     s.chars().map(|c|\
    \ if c.is_alphabetic() { c.swap_case() } else { c }).collect()\n   |         \
    \                                       ^^^^^^^^^ method not found in `char`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659822393
- exit_code: 101
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().rev().map(|c| {\n        match c {\n            'a'...'z'\
    \ => c.to_ascii_uppercase(),\n            'A'...'Z' => c.to_ascii_lowercase(),\n\
    \            _ => c,\n        }\n    }).collect()\n}\n\nfn main() {\n    let candidate\
    \ = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"FdSa\"`,\n right: `\"aSdF\"`', /tmp/tmpyevd_fef.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822393
- exit_code: 0
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut result = String::new();\n    for c in s.chars() {\n\
    \        if c.is_ascii_alphabetic() {\n            result.push(if c.is_ascii_lowercase()\
    \ {\n                c.to_ascii_uppercase()\n            } else {\n          \
    \      c.to_ascii_lowercase()\n            });\n        } else {\n           \
    \ result.push(c);\n        }\n    }\n    if result.chars().all(|c| !c.is_ascii_alphabetic())\
    \ {\n        result.chars().rev().collect()\n    } else {\n        result\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822393
- exit_code: 101
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().rev().map(|c| if c.is_alphabetic() {c.to_ascii_uppercase()}\
    \ else {c}).collect()\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"FDSA\"`,\n right: `\"aSdF\"`', /tmp/tmp0okh3tg9.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822393
- exit_code: 101
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut result = String::new();\n    for c in s.chars() {\n\
    \        if c.is_lowercase() {\n            result.push(c.to_uppercase().next().unwrap());\n\
    \        } else if c.is_uppercase() {\n            result.push(c.to_lowercase().next().unwrap());\n\
    \        } else {\n            result.push(c);\n        }\n    }\n    result.chars().rev().collect()\n\
    }\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"FdSa\"`,\n right: `\"aSdF\"`', /tmp/tmpiozjqgp1.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822393
- exit_code: 0
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut solution = String::new();\n    for i in s.chars() {\n\
    \        if i.is_uppercase() {\n            solution.push(i.to_lowercase().next().unwrap());\n\
    \        } else if i.is_lowercase() {\n            solution.push(i.to_uppercase().next().unwrap());\n\
    \        } else {\n            solution.push(i);\n        }\n    }\n    if solution.chars().any(|x|\
    \ x.is_lowercase() || x.is_uppercase()) {\n        solution\n    } else {\n  \
    \      solution.chars().rev().collect()\n    }\n}\n\nfn main() {\n    let candidate\
    \ = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822393
- exit_code: 101
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut ret = String::new();\n    let mut was_letter = false;\n\
    \    for c in s.chars() {\n        if c.is_alphabetic() {\n            was_letter\
    \ = true;\n            ret.push(c.to_lowercase().next().unwrap());\n        }\
    \ else {\n            ret.push(c);\n        }\n    }\n    ret = ret.chars().rev().collect();\n\
    \    if was_letter {\n        ret = ret.chars().map(|c| c.to_uppercase().next().unwrap()).collect();\n\
    \    }\n    ret\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"FDSA\"`,\n right: `\"aSdF\"`', /tmp/tmpqweitpn1.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822393
- exit_code: 101
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut reverse_string = String::new();\n    for c in s.chars()\
    \ {\n        if c.is_ascii_alphabetic() {\n            if c.is_lowercase() {\n\
    \                reverse_string.push(c.to_ascii_uppercase());\n            } else\
    \ {\n                reverse_string.push(c.to_ascii_lowercase());\n          \
    \  }\n        } else {\n            reverse_string.push(c);\n        }\n    }\n\
    \    if reverse_string.is_empty() {\n        reverse_string = s;\n    }\n    reverse_string.chars().rev().collect()\n\
    }\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"FdSa\"`,\n right: `\"aSdF\"`', /tmp/tmpm_flm562.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822393
- exit_code: 101
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().rev().map(|c| if c.is_alphabetic() { c.to_ascii_uppercase()\
    \ } else { c }).collect()\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"FDSA\"`,\n right: `\"aSdF\"`', /tmp/tmpvsg6o3ne.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822393
- exit_code: 101
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    if s.chars().all(|c| !c.is_alphabetic()) {\n        return\
    \ s.chars().rev().collect();\n    }\n    s.chars().map(|c| if c.is_alphabetic()\
    \ { c.to_uppercase().next().unwrap() } else { c }).collect()\n}\n\nfn main() {\n\
    \    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")),\
    \ String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")),\
    \ String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"\
    ));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmpotvi2axj.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822393
- exit_code: 101
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut out = String::with_capacity(s.len());\n    for c in\
    \ s.chars() {\n        if c.is_ascii_alphabetic() {\n            out.push(c.to_lowercase().next().unwrap());\n\
    \        } else {\n            out.push(c);\n        }\n    }\n    if out == s\
    \ {\n        out.chars().rev().collect()\n    } else {\n        out\n    }\n}\n\
    \nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"asdf\"`,\n right: `\"aSdF\"`', /tmp/tmpzsvq8dcs.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822393
- exit_code: 101
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().rev().map(|ch| if ch.is_ascii_alphabetic() {\n  \
    \      if ch.is_ascii_lowercase() {\n            ch.to_ascii_uppercase()\n   \
    \     } else {\n            ch.to_ascii_lowercase()\n        }\n    } else {\n\
    \        ch\n    }).collect()\n}\n\nfn main() {\n    let candidate = solve;\n\
    \    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n\
    \    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"FdSa\"`,\n right: `\"aSdF\"`', /tmp/tmpknmx9pu1.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822393
- exit_code: 101
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut new_s = String::new();\n    for c in s.chars() {\n\
    \        match c {\n            'a'..='z' => new_s.push((c as u8 - 32) as char),\n\
    \            'A'..='Z' => new_s.push((c as u8 + 32) as char),\n            _ =>\
    \ new_s.push(c),\n        }\n    }\n    new_s\n}\n\nfn main() {\n    let candidate\
    \ = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"1234\"`,\n right: `\"4321\"`', /tmp/tmpc60rhk3z.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822393
- exit_code: 101
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().rev().map(|c| match c {\n        'A' ... 'Z' => c.to_ascii_lowercase(),\n\
    \        'a' ... 'z' => c.to_ascii_uppercase(),\n        _ => c\n    }).collect()\n\
    }\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"FdSa\"`,\n right: `\"aSdF\"`', /tmp/tmpj_58h5jf.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822393
- exit_code: 101
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n  s.chars().map(|c| if c.is_alphabetic() {\n    c.to_uppercase().next().unwrap_or(c)\n\
    \  } else {\n    c\n  }).rev().collect()\n}\n\nfn main() {\n    let candidate\
    \ = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"FDSA\"`,\n right: `\"aSdF\"`', /tmp/tmp4uicsiw3.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822393
- exit_code: 101
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().rev().map(|c| {\n        if c.is_alphabetic() {\n\
    \            c.to_lowercase().next().unwrap()\n        } else {\n            c\n\
    \        }\n    }).collect()\n}\n\nfn main() {\n    let candidate = solve;\n \
    \   assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n \
    \   assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n \
    \   assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"fdsa\"`,\n right: `\"aSdF\"`', /tmp/tmptvbhv5z7.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822393
- exit_code: 101
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    let mut ans = String::new();\n    for c in s.chars() {\n  \
    \      if c.is_alphabetic() {\n            if c.is_uppercase() {\n           \
    \     ans.push(c.to_lowercase().next().unwrap());\n            } else {\n    \
    \            ans.push(c.to_uppercase().next().unwrap());\n            }\n    \
    \    } else {\n            ans.push(c);\n        }\n    }\n    if ans.is_empty()\
    \ {\n        s.chars().rev().collect()\n    } else {\n        ans\n    }\n}\n\n\
    fn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"1234\"`,\n right: `\"4321\"`', /tmp/tmp5l8_k_m6.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822393
- exit_code: 101
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().rev().map(|c| match c {\n        'a'...'z' => c.to_ascii_uppercase(),\n\
    \        'A'...'Z' => c.to_ascii_lowercase(),\n        _ => c,\n    }).collect()\n\
    }\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"FdSa\"`,\n right: `\"aSdF\"`', /tmp/tmp01z4j_pg.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822393
- exit_code: 101
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().rev().map(|c| {\n        if c.is_alphabetic() {\n\
    \            c.to_ascii_uppercase()\n        } else {\n            c\n       \
    \ }\n    }).collect()\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"FDSA\"`,\n right: `\"aSdF\"`', /tmp/tmpbopqsfzt.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822393
- exit_code: 101
  program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n\
    /// solve(\"ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String)\
    \ -> String {\n    s.chars().rev().map(|c| if c.is_ascii_alphabetic() { c.to_ascii_uppercase()\
    \ } else { c }).collect()\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"FDSA\"`,\n right: `\"aSdF\"`', /tmp/tmpru36y58f.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822393
