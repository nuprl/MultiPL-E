name: HumanEval_9_rolling_max
language: rs
prompt: "/// From a given list of integers, generate a list of rolling maximum element\
  \ found until given moment\n/// in the sequence.\n/// >>> rolling_max([1, 2, 3,\
  \ 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) ->\
  \ Vec<isize> {\n"
tests: "}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
  \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
  \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3,\
  \ 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
completions: ["    let mut output = Vec::with_capacity(numbers.len());\n    output.push(numbers[0]);\n\
    \    let mut current_max = numbers[0];\n    for i in 1..numbers.len() {\n    \
    \    if numbers[i] > current_max {\n            current_max = numbers[i];\n  \
    \      }\n        output.push(current_max);\n    }\n    output", "    use std::cmp::max;\n\
    \    let mut result = Vec::with_capacity(numbers.len());\n    result.push(numbers[0]);\n\
    \    for i in 1..numbers.len() {\n        result.push(max(result[i - 1], numbers[i]));\n\
    \    }\n    result", "    let mut res = Vec::new();\n    let mut max_current =\
    \ numbers[0];\n    res.push(max_current);\n    for index in 1..numbers.len() {\n\
    \        if numbers[index] > max_current {\n            max_current = numbers[index];\n\
    \        }\n        res.push(max_current);\n    }\n    res", "    // TODO: implement\
    \ rolling_max\n    vec![]", "    let mut rolling_max = Vec::with_capacity(numbers.len());\n\
    \    let mut max = std::isize::MIN;\n    for n in numbers {\n        if n > max\
    \ {\n            max = n;\n        }\n        rolling_max.push(max);\n    }\n\
    \    rolling_max", "    let mut result = Vec::with_capacity(numbers.len());\n\
    \    let mut max = numbers[0];\n    result.push(max);\n    for i in 1..numbers.len()\
    \ {\n        if numbers[i] > max {\n            max = numbers[i];\n        }\n\
    \        result.push(max);\n    }\n    result", "    let mut max_so_far = -1;\n\
    \    let mut result = Vec::new();\n    for x in numbers {\n        if x > max_so_far\
    \ {\n            max_so_far = x;\n        }\n        result.push(max_so_far);\n\
    \    }\n    result", "    let mut result = Vec::new();\n    let mut max = std::isize::MIN;\n\
    \    for n in numbers {\n        if n > max {\n            max = n;\n        }\n\
    \        result.push(max);\n    }\n    result", "    let mut result = Vec::new();\n\
    \    let mut current_max = isize::min_value();\n    for number in numbers {\n\
    \        if number > current_max {\n            current_max = number;\n      \
    \  }\n        result.push(current_max);\n    }\n    result", "    let mut max_until_now\
    \ = None;\n    let mut result = Vec::new();\n    for &number in numbers.iter()\
    \ {\n        if let Some(mut previous_max) = max_until_now {\n            if number\
    \ > previous_max {\n                previous_max = number;\n            }\n  \
    \          result.push(previous_max);\n        } else {\n            result.push(number);\n\
    \        }\n        max_until_now = Some(result.last().unwrap().clone());\n  \
    \  }\n    result", "    let mut result = Vec::new();\n    let mut current_max\
    \ = std::isize::MIN;\n    for i in numbers {\n        current_max = current_max.max(i);\n\
    \        result.push(current_max);\n    }\n    result", "    let mut max = isize::min_value();\n\
    \    let mut max_vec = Vec::new();\n    for n in numbers {\n        max = n.max(max);\n\
    \        max_vec.push(max);\n    }\n    max_vec", "    numbers\n        .iter()\n\
    \        .scan(0, |state, &x| {\n            *state = max(*state, x);\n      \
    \      Some(*state)\n        })\n        .collect()", "    let mut result = Vec::with_capacity(numbers.len());\n\
    \    let mut max = numbers[0];\n    result.push(max);\n    for num in numbers[1..].iter()\
    \ {\n        max = std::cmp::max(max, *num);\n        result.push(max);\n    }\n\
    \    result", "    let mut rolling_max = Vec::new();\n    let mut max = numbers[0];\n\
    \    rolling_max.push(max);\n    for i in 1..numbers.len() {\n        max = max.max(numbers[i]);\n\
    \        rolling_max.push(max);\n    }\n    rolling_max", "    let mut rolling_max\
    \ = Vec::new();\n    for number in numbers {\n        rolling_max.push(rolling_max.last().map_or(number,\
    \ |v| v.max(number)));\n    }\n    rolling_max", "    // From left to right, find\
    \ the maximum for each element's position. We\n    // will use a stack (FILO)\
    \ as a way to store current maximums.\n    let mut max_stack: Vec<isize> = Vec::new();\n\
    \    let mut result: Vec<isize> = Vec::new();\n\n    for n in numbers {\n    \
    \    // Since we are going from left to right, we will use the stack as a\n  \
    \      // storage for the current maximum found for each position until now.\n\
    \        // The stack will keep track of values in descending order, since\n \
    \       // smaller values will eventually be discarded.\n        while !max_stack.is_empty()\
    \ && n > max_stack[max_stack.len() - 1] {\n            max_stack.pop();\n    \
    \    }\n\n        max_stack.push(n);\n        result.push(max_stack[0]);\n   \
    \ }\n\n    result", "    if numbers.is_empty() {\n        return vec![];\n   \
    \ }\n\n    let mut max = numbers[0];\n    let mut result = vec![max];\n\n    for\
    \ num in numbers.iter().skip(1) {\n        max = num.max(max);\n        result.push(max);\n\
    \    }\n\n    result", "    let mut result = Vec::with_capacity(numbers.len());\n\
    \    let mut maximum_so_far = numbers[0];\n    result.push(maximum_so_far);\n\
    \    for i in 1..numbers.len() {\n        maximum_so_far = maximum_so_far.max(numbers[i]);\n\
    \        result.push(maximum_so_far);\n    }\n    result", "    let mut rolling_max:\
    \ Vec<isize> = Vec::new();\n    let mut max_so_far = numbers[0];\n    rolling_max.push(max_so_far);\n\
    \    for &number in numbers.iter().skip(1) {\n        if number > max_so_far {\n\
    \            max_so_far = number;\n        }\n        rolling_max.push(max_so_far);\n\
    \    }\n    rolling_max"]
stop_tokens:
- "\n}"
