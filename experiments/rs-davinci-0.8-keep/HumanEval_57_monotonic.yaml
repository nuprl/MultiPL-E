name: HumanEval_57_monotonic
language: rs
prompt: "/// Return True is list elements are monotonically increasing or decreasing.\n\
  /// >>> monotonic([1, 2, 4, 20])\n/// True\n/// >>> monotonic([1, 20, 4, 10])\n\
  /// False\n/// >>> monotonic([4, 1, 0, -10])\n/// True\nfn monotonic(l: Vec<isize>)\
  \ -> bool {\n"
tests: "}\n\nfn main() {\n    let candidate = monotonic;\n    assert_eq!(candidate(vec![1,\
  \ 2, 4, 10]), true);\n    assert_eq!(candidate(vec![1, 2, 4, 20]), true);\n    assert_eq!(candidate(vec![1,\
  \ 20, 4, 10]), false);\n    assert_eq!(candidate(vec![4, 1, 0, -10]), true);\n \
  \   assert_eq!(candidate(vec![4, 1, 1, 0]), true);\n    assert_eq!(candidate(vec![1,\
  \ 2, 3, 2, 5, 60]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 60]),\
  \ true);\n    assert_eq!(candidate(vec![9, 9, 9, 9]), true);\n}\n"
completions: ["    let mut state = 0;\n    let mut iter = l.iter();\n    let mut prev\
    \ = iter.next();\n    while let Some(x) = iter.next() {\n        match state {\n\
    \            // first item\n            0 => {\n                state = if x >\
    \ prev.unwrap() { 1 } else { -1 };\n            }\n            // increasing\n\
    \            1 => {\n                if x < prev.unwrap() {\n                \
    \    return false;\n                }\n            }\n            // decreasing\n\
    \            -1 => {\n                if x > prev.unwrap() {\n               \
    \     return false;\n                }\n            }\n            _ => (),\n\
    \        }\n        prev = Some(x);\n    }\n    true", "    if l.len() <= 1 {\n\
    \        return true;\n    }\n    let mut i = 0;\n    while i < l.len() - 1 {\n\
    \        if l[i] > l[i + 1] {\n            break;\n        }\n        i += 1;\n\
    \    }\n    if i >= l.len() - 1 {\n        return true;\n    }\n    i = 0;\n \
    \   while i < l.len() - 1 {\n        if l[i] < l[i + 1] {\n            break;\n\
    \        }\n        i += 1;\n    }\n    if i >= l.len() - 1 {\n        return\
    \ true;\n    }\n    return false;", "    let len = l.len();\n    if len == 0 {\n\
    \        return true;\n    }\n    let mut delta = l[1] - l[0];\n    for i in 1..len\
    \ {\n        if delta * (l[i] - l[i - 1]) < 0 {\n            return false;\n \
    \       }\n    }\n    true", "    let len = l.len();\n    if len == 0 {\n    \
    \    return true;\n    }\n    let mut is_positive_increasing = None;\n    for\
    \ i in 1..len {\n        let diff = l[i] - l[i - 1];\n        if diff == 0 {\n\
    \            continue;\n        }\n        let is_positive = diff > 0;\n     \
    \   if is_positive_increasing.is_none() {\n            is_positive_increasing\
    \ = Some(is_positive);\n        } else if is_positive_increasing.unwrap() != is_positive\
    \ {\n            return false;\n        }\n    }\n    true", "    let mut increasing\
    \ = true;\n    let mut decreasing = true;\n    for i in 1..l.len() {\n       \
    \ if l[i - 1] < l[i] {\n            decreasing = false;\n        }\n        if\
    \ l[i - 1] > l[i] {\n            increasing = false;\n        }\n    }\n    increasing\
    \ || decreasing", "    let mut dec = true;\n    let mut inc = true;\n    for i\
    \ in 1..l.len() {\n        if l[i] < l[i - 1] {\n            inc = false;\n  \
    \      }\n        if l[i] > l[i - 1] {\n            dec = false;\n        }\n\
    \    }\n    dec || inc", "    let mut t = 0;\n    let mut temp = true;\n    for\
    \ (i, j) in l.iter().zip(l.iter().skip(1)) {\n        if i > j {\n           \
    \ t += 1;\n        } else if i < j {\n            t -= 1;\n        }\n       \
    \ if t > 1 || t < -1 {\n            temp = false;\n        }\n    }\n    temp",
  "    // since we are given a list we know the first element is always monotonic\n\
    \    // we can use it as the starting point for our accumulator:\n    l.iter().skip(1).fold(l[0],\
    \ |a, &b| {\n        if b > a {\n            b\n        } else if b < a {\n  \
    \          -b\n        } else {\n            a\n        }\n    }) > 0", "    let\
    \ mut res = true;\n    let mut delta = None;\n    let mut prev = None;\n    for\
    \ i in l {\n        if prev == None {\n            prev = Some(i);\n        }\
    \ else {\n            let p = prev.unwrap();\n            if delta == None {\n\
    \                delta = Some(i - p);\n            } else {\n                let\
    \ d = delta.unwrap();\n                if (i - p) * d < 0 {\n                \
    \    res = false;\n                    break;\n                }\n           \
    \ }\n            prev = Some(i);\n        }\n    }\n    res", "    let mut inc\
    \ = l[0] <= l[1];\n    let mut dec = l[0] >= l[1];\n    for i in 2..l.len() {\n\
    \        if l[i - 1] > l[i] {\n            inc = false;\n        }\n        if\
    \ l[i - 1] < l[i] {\n            dec = false;\n        }\n    }\n    return inc\
    \ || dec;", "    let mut is_monotonic = true;\n    let mut decreasing = false;\n\
    \    let mut last = l[0];\n    for x in l {\n        if !decreasing && x < last\
    \ {\n            decreasing = true;\n        }\n        if decreasing && x > last\
    \ {\n            is_monotonic = false;\n            break;\n        }\n      \
    \  last = x;\n    }\n    is_monotonic", "    match l.len() {\n        0 => true,\n\
    \        1 => true,\n        _ => {\n            let mut init = false;\n     \
    \       let mut monotonic_positive = false;\n            let mut monotonic_negative\
    \ = false;\n            for w in l.windows(2) {\n                let res = w[0].cmp(&w[1]);\n\
    \                match res {\n                    Ordering::Less => {\n      \
    \                  if !init {\n                            init = true;\n    \
    \                        monotonic_positive = true;\n                        }\
    \ else if monotonic_negative {\n                            return false;\n  \
    \                      }\n                    }\n                    Ordering::Equal\
    \ => {}\n                    Ordering::Greater => {\n                        if\
    \ !init {\n                            init = true;\n                        \
    \    monotonic_negative = true;\n                        } else if monotonic_positive\
    \ {\n                            return false;\n                        }\n  \
    \                  }\n                }\n            }\n            true\n   \
    \     }\n    }", "    let mut is_increasing = false;\n    let mut is_decreasing\
    \ = false;\n    for i in 0..l.len()-1 {\n        if l[i] < l[i+1] {\n        \
    \    is_increasing = true;\n        } else if l[i] > l[i+1] {\n            is_decreasing\
    \ = true;\n        }\n        if is_increasing && is_decreasing {\n          \
    \  return false;\n        }\n    }\n    return true;", "    let mut m = true;\n\
    \    let mut n = true;\n    for i in 1..l.len() {\n        m = m && l[i] >= l[i\
    \ - 1];\n        n = n && l[i] <= l[i - 1];\n    }\n    m || n", '    unimplemented!()',
  "    let n = l.len();\n    let mut inc = true;\n    let mut dec = true;\n    for\
    \ i in 0..n - 1 {\n        if l[i] > l[i + 1] {\n            inc = false;\n  \
    \      }\n        if l[i] < l[i + 1] {\n            dec = false;\n        }\n\
    \    }\n    inc || dec", "    let mut temp = l.clone();\n    temp.sort();\n  \
    \  l == temp || l == temp.iter().rev().cloned().collect()", "    let s: isize\
    \ = l.iter().sum();\n    s == (l.len() as isize) * l[0] || s == 0", "    if l.len()\
    \ == 0 {\n        return true;\n    }\n    let mut increasing = l[0] <= l[1];\n\
    \    for i in 1..l.len() - 1 {\n        if (l[i] <= l[i + 1]) != increasing {\n\
    \            return false;\n        }\n    }\n    true", "    let mut is_decreasing\
    \ = true;\n    let mut is_increasing = true;\n    for (i, e) in l.iter().enumerate()\
    \ {\n        if i == 0 {\n            continue;\n        }\n        if e < &l[i\
    \ - 1] {\n            is_increasing = false;\n        }\n        if e > &l[i -\
    \ 1] {\n            is_decreasing = false;\n        }\n    }\n    is_decreasing\
    \ || is_increasing"]
stop_tokens:
- "\n}"
