name: HumanEval_158_find_max
language: rs
results:
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut found = None;\n    let\
    \ mut count = 0;\n    for word in words {\n        let mut seen = HashSet::new();\n\
    \        for letter in word.chars() {\n            seen.insert(letter);\n    \
    \    }\n        if seen.len() > count {\n            count = seen.len();\n   \
    \         found = Some(word);\n        }\n    }\n    found.unwrap()\n}\n\nfn main()\
    \ {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpczkuarsq.rs:12:24\n   |\n12 |         let mut seen = HashSet::new();\n\
    \   |                        ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut max_word = String::new();\n\
    \    let mut max_char_num = 0;\n    for word in words {\n        let mut char_set\
    \ = HashSet::new();\n        for c in word.chars() {\n            char_set.insert(c);\n\
    \        }\n        if char_set.len() > max_char_num {\n            max_char_num\
    \ = char_set.len();\n            max_word = word;\n        }\n    }\n    max_word\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp5njkrvyr.rs:12:28\n   |\n12 |         let mut char_set = HashSet::new();\n\
    \   |                            ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut max = String::new();\n\
    \    let mut count = 0;\n    for word in words {\n        let mut char_count =\
    \ HashSet::new();\n        for c in word.chars() {\n            char_count.insert(c);\n\
    \        }\n        if char_count.len() > count {\n            count = char_count.len();\n\
    \            max = word;\n        }\n    }\n    max\n}\n\nfn main() {\n    let\
    \ candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"),\
    \ String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"),\
    \ String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmppsxqb6eu.rs:12:30\n   |\n12 |         let mut char_count = HashSet::new();\n\
    \   |                              ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut result = \"\".to_string();\n\
    \    let mut max_num_unique_chars = 0;\n    for w in words {\n        let unique_chars\
    \ = w.chars().collect::<HashSet<char>>().len();\n        if unique_chars > max_num_unique_chars\
    \ {\n            max_num_unique_chars = unique_chars;\n            result = w;\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpsb_1q1ij.rs:12:48\n\
    \   |\n12 |         let unique_chars = w.chars().collect::<HashSet<char>>().len();\n\
    \   |                                                ^^^^^^^ not found in this\
    \ scope\n   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    words.iter().max_by_key(|w| w.chars().unique().count()).unwrap().to_string()\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `unique` found for struct `Chars` in the\
    \ current scope\n --> /tmp/tmph4lr2c5r.rs:9:43\n  |\n9 |     words.iter().max_by_key(|w|\
    \ w.chars().unique().count()).unwrap().to_string()\n  |                      \
    \                     ^^^^^^ method not found in `Chars<'_>`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut max = String::new();\n\
    \    for word in words {\n        if word.len() > max.len() {\n            max\
    \ = word;\n        }\n    }\n    max\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"name\"`,\n right: `\"enam\"`', /tmp/tmpzmoeccz3.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut max = String::new();\n\
    \    for word in words {\n        if word.len() > max.len() {\n            max\
    \ = word;\n        }\n    }\n    max\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"name\"`,\n right: `\"enam\"`', /tmp/tmplk68izr6.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut unique_chars: HashMap<String,\
    \ u32> = HashMap::new();\n    for word in words {\n        let mut count = 0;\n\
    \        for letter in word.chars() {\n            count += 1;\n            if\
    \ !unique_chars.contains_key(&word) {\n                unique_chars.insert(word,\
    \ count);\n            }\n        }\n    }\n    let mut v: Vec<&String> = unique_chars.keys().collect();\n\
    \    v.sort();\n    let mx = unique_chars.get(v[0]).unwrap();\n    let mut result\
    \ = String::new();\n    for (k, v) in unique_chars {\n        if v == *mx {\n\
    \            result = k;\n            break;\n        }\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashMap` in this scope\n --> /tmp/tmpencfh9uy.rs:9:27\n\
    \  |\n9 |     let mut unique_chars: HashMap<String, u32> = HashMap::new();\n \
    \ |                           ^^^^^^^ not found in this scope\n  |\nhelp: consider\
    \ importing this struct\n  |\n1 | use std::collections::HashMap;\n  |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n --> /tmp/tmpencfh9uy.rs:9:50\n\
    \  |\n9 |     let mut unique_chars: HashMap<String, u32> = HashMap::new();\n \
    \ |                                                  ^^^^^^^ not found in this\
    \ scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::HashMap;\n\
    \  |\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0412, E0433.\nFor more information about an error, try `rustc\
    \ --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut max_word = String::new();\n\
    \    let mut max_count = 0;\n    for word in words {\n        let count = word.len()\
    \ - word.chars().collect::<HashSet<char>>().len();\n        if count > max_count\
    \ {\n            max_count = count;\n            max_word = word;\n        }\n\
    \    }\n    max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmp72q7z133.rs:12:57\n\
    \   |\n12 |         let count = word.len() - word.chars().collect::<HashSet<char>>().len();\n\
    \   |                                                         ^^^^^^^ not found\
    \ in this scope\n   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let empty_string = String::new();\n\
    \    let mut result = empty_string;\n    let mut max_count = 0;\n    for word\
    \ in words {\n        let mut characters = HashSet::new();\n        for c in word.chars()\
    \ {\n            characters.insert(c);\n        }\n        let count = characters.len();\n\
    \        if count > max_count {\n            max_count = count;\n            result\
    \ = word;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate =\
    \ find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"\
    of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp8gy_g364.rs:13:30\n   |\n13 |         let mut characters = HashSet::new();\n\
    \   |                              ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut max = String::new();\n\
    \    for word in words {\n        if max.len() == 0 || word.len() > max.len()\
    \ {\n            max = word.clone();\n        } else if word.len() == max.len()\
    \ {\n            if word < max {\n                max = word.clone();\n      \
    \      }\n        }\n    }\n    max\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"prrk\"`,\n right: `\"this\"`', /tmp/tmp2g214nxt.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut max_word = \"\".to_string();\n\
    \    let mut max_unique_chars = 0;\n    for word in words {\n        let len =\
    \ word.chars().unique().count();\n        if len > max_unique_chars {\n      \
    \      max_unique_chars = len;\n            max_word = word;\n        }\n    }\n\
    \    max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `unique` found for struct `Chars` in the\
    \ current scope\n  --> /tmp/tmp3p_dd89w.rs:12:32\n   |\n12 |         let len =\
    \ word.chars().unique().count();\n   |                                ^^^^^^ method\
    \ not found in `Chars<'_>`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut max_word = String::new();\n\
    \    let mut max_letters = 0;\n    for word in words {\n        let mut set =\
    \ HashSet::new();\n        for letter in word.chars() {\n            set.insert(letter);\n\
    \        }\n        if set.len() > max_letters {\n            max_letters = set.len();\n\
    \            max_word = word;\n        }\n    }\n    max_word\n}\n\nfn main()\
    \ {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp2_h0kipt.rs:12:23\n   |\n12 |         let mut set = HashSet::new();\n\
    \   |                       ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut max_string = \"\".to_string();\n\
    \    let mut max_count = 0;\n    for word in words {\n        let mut counter\
    \ = 0;\n        let mut characters = vec![];\n        for c in word.chars() {\n\
    \            if !characters.contains(&c) {\n                counter += 1;\n  \
    \              characters.push(c);\n            }\n        }\n        if counter\
    \ > max_count {\n            max_count = counter;\n            max_string = word;\n\
    \        }\n    }\n    max_string\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"name\"`,\n right: `\"enam\"`', /tmp/tmpq38tn_1w.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut max = 0;\n    let mut\
    \ max_string = String::new();\n    for i in words {\n        let set: HashSet<char>\
    \ = i.chars().collect();\n        if set.len() > max {\n            max = set.len();\n\
    \            max_string = i;\n        }\n    }\n    max_string\n}\n\nfn main()\
    \ {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpv29hxaul.rs:12:18\n\
    \   |\n12 |         let set: HashSet<char> = i.chars().collect();\n   |      \
    \            ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    words.iter().max_by_key(|word|\
    \ {\n        word.chars().collect::<std::collections::HashSet<char>>().len()\n\
    \    }).unwrap().to_string()\n}\n\nfn main() {\n    let candidate = find_max;\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"\
    string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"\
    bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"\
    abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"\
    play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"),\
    \ String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"game\"`,\n right: `\"enam\"`', /tmp/tmp72_f66n0.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut max_length: Option<usize>\
    \ = None;\n    let mut result: Option<String> = None;\n    for word in words {\n\
    \        let length = word.chars().collect::<HashSet<char>>().len();\n       \
    \ if let Some(ref max) = max_length {\n            if length > *max {\n      \
    \          max_length = Some(length);\n                result = Some(word);\n\
    \            }\n        } else {\n            max_length = Some(length);\n   \
    \         result = Some(word);\n        }\n    }\n    result.unwrap()\n}\n\nfn\
    \ main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmph5318y_i.rs:12:45\n\
    \   |\n12 |         let length = word.chars().collect::<HashSet<char>>().len();\n\
    \   |                                             ^^^^^^^ not found in this scope\n\
    \   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut max = String::new();\n\
    \    let mut max_count = 0;\n    for word in words {\n        let mut chars: Vec<char>\
    \ = word.chars().collect();\n        chars.sort();\n        chars.dedup();\n \
    \       if chars.len() > max_count {\n            max_count = chars.len();\n \
    \           max = word;\n        }\n    }\n    max\n}\n\nfn main() {\n    let\
    \ candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"),\
    \ String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"),\
    \ String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"name\"`,\n right: `\"enam\"`', /tmp/tmp5f1szda4.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut max = 0;\n    let mut\
    \ max_word = String::new();\n    for word in words {\n        let mut unique_chars\
    \ = String::new();\n        for c in word.chars() {\n            if !unique_chars.contains(c)\
    \ {\n                unique_chars.push(c);\n            }\n        }\n       \
    \ if unique_chars.len() > max {\n            max = unique_chars.len();\n     \
    \       max_word = word;\n        }\n    }\n    max_word\n}\n\nfn main() {\n \
    \   let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"\
    ), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n\
    \    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"),\
    \ String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"name\"`,\n right: `\"enam\"`', /tmp/tmpu0gop4xs.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that accepts a list of strings.\n/// The list contains\
    \ different words. Return the word with maximum number\n/// of unique characters.\
    \ If multiple strings have maximum number of unique\n/// characters, return the\
    \ one which comes first in lexicographical order.\n/// find_max([\"name\", \"\
    of\", \"string\"]) == \"string\"\n/// find_max([\"name\", \"enam\", \"game\"])\
    \ == \"enam\"\n/// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
    fn find_max(words: Vec<String>) -> String {\n    let mut result = String::new();\n\
    \    let mut max_num_of_unique_chars = 0;\n    for word in words {\n        let\
    \ num_of_unique_chars = word.chars().collect::<HashSet<char>>().len();\n     \
    \   if num_of_unique_chars > max_num_of_unique_chars {\n            max_num_of_unique_chars\
    \ = num_of_unique_chars;\n            result = word;\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
    name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
    ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
    aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
    ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\"\
    )]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"\
    ), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
    footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
    we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
    \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"\
    ), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
    nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
    this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]),\
    \ String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]),\
    \ String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
    \ String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpqrwnnq5_.rs:12:58\n\
    \   |\n12 |         let num_of_unique_chars = word.chars().collect::<HashSet<char>>().len();\n\
    \   |                                                          ^^^^^^^ not found\
    \ in this scope\n   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
