name: HumanEval_163_generate_integers
language: rs
prompt: "/// Given two positive integers a and b, return the even digits between a\n\
  /// and b, in ascending order.\n/// For example:\n/// generate_integers(2, 8) =>\
  \ [2, 4, 6, 8]\n/// generate_integers(8, 2) => [2, 4, 6, 8]\n/// generate_integers(10,\
  \ 14) => []\nfn generate_integers(a: isize, b: isize) -> Vec<isize> {\n"
tests: "}\n\nfn main() {\n    let candidate = generate_integers;\n    assert_eq!(candidate(2,\
  \ 10), vec![2, 4, 6, 8]);\n    assert_eq!(candidate(10, 2), vec![2, 4, 6, 8]);\n\
  \    assert_eq!(candidate(132, 2), vec![2, 4, 6, 8]);\n    assert_eq!(candidate(17,\
  \ 89), Vec::<isize>::new());\n}\n"
completions: ["    let first = min(a, b);\n    let last = max(a, b);\n    let mut\
    \ integers = Vec::new();\n    for i in first..=last {\n        if i % 2 == 0 {\n\
    \            integers.push(i);\n        }\n    }\n    integers", "    let mut\
    \ low = a;\n    let mut high = b;\n    if low > high {\n        std::mem::swap(&mut\
    \ low, &mut high);\n    }\n    (low..=high)\n        .filter(|x| x % 2 == 0)\n\
    \        .collect::<Vec<isize>>()", "    let mut nums = Vec::new();\n    if a\
    \ < b {\n        for i in a..b + 1 {\n            if i % 2 == 0 {\n          \
    \      nums.push(i);\n            }\n        }\n    } else {\n        for i in\
    \ b..a + 1 {\n            if i % 2 == 0 {\n                nums.push(i);\n   \
    \         }\n        }\n    }\n    nums", "    let min = cmp::min(a, b);\n   \
    \ let max = cmp::max(a, b);\n    let mut result = Vec::new();\n    for n in min..=max\
    \ {\n        if n % 2 == 0 {\n            result.push(n);\n        }\n    }\n\
    \    result", "    let (mut a, mut b) = if a < b { (a, b) } else { (b, a) };\n\
    \    if a % 2 != 0 {\n        a += 1;\n    }\n    let mut result = Vec::new();\n\
    \    while a <= b {\n        result.push(a);\n        a += 2;\n    }\n    result",
  "    let start = if a < b { a } else { b };\n    let end = if a > b { a } else {\
    \ b };\n    (start..=end)\n        .filter(|x| x % 2 == 0)\n        .collect::<Vec<isize>>()",
  "    let mut result = Vec::new();\n    let mut current_int = min(a, b);\n    while\
    \ current_int <= max(a, b) {\n        if current_int % 2 == 0 {\n            result.push(current_int);\n\
    \        }\n        current_int += 1;\n    }\n    result", "    let mut v = Vec::new();\n\
    \    let (mut l, mut h) = if a > b { (b, a) } else { (a, b) };\n    while l <=\
    \ h {\n        if l % 2 == 0 {\n            v.push(l);\n        }\n        l +=\
    \ 1;\n    }\n    v", '    (a..b).filter(|x| x % 2 == 0).collect()', '    unimplemented!();',
  "    let mut result = Vec::new();\n    let mut start = a;\n    let mut end = b;\n\
    \    if a > b {\n        start = b;\n        end = a;\n    }\n    for n in start..=end\
    \ {\n        if n % 2 == 0 {\n            result.push(n);\n        }\n    }\n\
    \    result", "    if a < b {\n        (a..b + 1).filter(|&x| x % 2 == 0).collect()\n\
    \    } else {\n        (b..a + 1).filter(|&x| x % 2 == 0).collect()\n    }", " \
    \   let mut v = vec![];\n    let mut i = cmp::min(a, b);\n    let mut j = cmp::max(a,\
    \ b);\n    while i <= j {\n        if i % 2 == 0 {\n            v.push(i);\n \
    \       }\n        i += 1;\n    }\n    v", "    if a < 0 || b < 0 {\n        panic!(\"\
    Negative integers not allowed\")\n    }\n\n    let mut range = a..b + 1;\n   \
    \ if a > b {\n        range = b..a + 1;\n    }\n\n    range.filter(|n| n % 2 ==\
    \ 0).collect()", "    let mut v = vec![];\n    for i in a..=b {\n        if i\
    \ % 2 == 0 {\n            v.push(i);\n        }\n    }\n    v", "    let low_bound\
    \ = a.min(b);\n    let high_bound = a.max(b);\n    (low_bound..=high_bound)\n\
    \        .filter(|n| n % 2 == 0)\n        .collect()", "    let mut vec = Vec::new();\n\
    \    for n in std::cmp::min(a, b)..=std::cmp::max(a, b) {\n        if n % 2 ==\
    \ 0 {\n            vec.push(n);\n        }\n    }\n    vec", '    (a..=b).filter(|&x|
    x % 2 == 0).collect()', "    let mut result = Vec::new();\n    let mut min = a;\n\
    \    let mut max = b;\n    if a > b {\n        std::mem::swap(&mut min, &mut max);\n\
    \    }\n    if a % 2 != 0 {\n        min += 1;\n    }\n    if b % 2 != 0 {\n \
    \       max -= 1;\n    }\n    for i in (min..=max).step_by(2) {\n        result.push(i);\n\
    \    }\n    result", "    let (min, max) = if a < b { (a, b) } else { (b, a) };\n\
    \    (min..=max).filter(|n| n % 2 == 0).collect()"]
stop_tokens:
- "\n}"
