name: HumanEval_78_hex_key
language: rs
results:
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut key: isize = 0;\n    for ch in num.chars() {\n     \
    \   let mut hex_digit: isize = match ch {\n            '0' ... '9' => ch as isize\
    \ - '0' as isize,\n            'A' => 10,\n            'B' => 11,\n          \
    \  'C' => 12,\n            'D' => 13,\n            'E' => 14,\n            'F'\
    \ => 15,\n            _ => 0,\n        };\n        if hex_digit == 2 || hex_digit\
    \ == 3 || hex_digit == 5 || hex_digit == 7 || hex_digit == 11 || hex_digit ==\
    \ 13 {\n            key += 1;\n        }\n    }\n    key\n}\n\nfn main() {\n \
    \   let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let a: Vec<char> = num.chars().collect();\n    let mut b: isize\
    \ = 0;\n    for i in a {\n        match i {\n            '2' => b += 1,\n    \
    \        '3' => b += 1,\n            '5' => b += 1,\n            '7' => b += 1,\n\
    \            'B' => b += 1,\n            'D' => b += 1,\n            _ => (),\n\
    \        }\n    }\n    b\n}\n\nfn main() {\n    let candidate = hex_key;\n   \
    \ assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut count = 0;\n    let mut number = num.clone();\n    let\
    \ mut hex_key = [true; 16];\n    let mut iteration = 0;\n    while number.len()\
    \ > 0 {\n        if !hex_key[hex_value(&number[..1])] {\n            hex_key[hex_value(&number[..1])]\
    \ = true;\n            count += 1;\n        }\n        number = number[1..].to_string();\n\
    \        iteration += 1;\n    }\n    return count;\n}\n\nfn main() {\n    let\
    \ candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n\
    \    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `hex_value` in this scope\n  --> /tmp/tmpxzha5dd6.rs:23:21\n\
    \   |\n23 |         if !hex_key[hex_value(&number[..1])] {\n   |             \
    \        ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function\
    \ `hex_value` in this scope\n  --> /tmp/tmpxzha5dd6.rs:24:21\n   |\n24 |     \
    \        hex_key[hex_value(&number[..1])] = true;\n   |                     ^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let hex_primes = vec!['2', '3', '5', '7', 'B', 'D'];\n    let\
    \ mut count = 0;\n    for c in num.chars() {\n        if hex_primes.contains(&c)\
    \ {\n            count += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut primes = vec![0x2, 0x3, 0x5, 0x7, 0xb, 0xd];\n    let\
    \ mut count = 0;\n    for c in num.chars() {\n        let key = c.to_digit(16).unwrap();\n\
    \        if primes.contains(&key) {\n            count += 1;\n        }\n    }\n\
    \    count\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    num.chars().map(|c| {\n        c.to_digit(16).unwrap() as isize\n\
    \    }).filter(|&x| {\n        x == 2 || x == 3 || x == 5 || x == 7 || x == 11\
    \ || x == 13\n    }).count() as isize\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    num.chars().filter(|c| \"2357BDF\".contains(*c)).count() as\
    \ isize\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `7`,\n right: `6`', /tmp/tmphm1sgxnx.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut ans = 0;\n    for i in num.chars() {\n        let x\
    \ = i.to_digit(16).unwrap();\n        match x {\n            2 | 3 | 5 | 7 | 11\
    \ | 13 => ans += 1,\n            _ => {}\n        }\n    }\n    ans\n}\n\nfn main()\
    \ {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut prime = 0;\n    for c in num.chars() {\n        let\
    \ dec = match c {\n            '0'..='9' => c.to_digit(10).unwrap(),\n       \
    \     'A' => 10,\n            'B' => 11,\n            'C' => 12,\n           \
    \ 'D' => 13,\n            'E' => 14,\n            'F' => 15,\n            _ =>\
    \ 0,\n        };\n        if dec == 2 || dec == 3 || dec == 5 || dec == 7 || dec\
    \ == 11 || dec == 13 {\n            prime += 1;\n        }\n    }\n    prime\n\
    }\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut b: isize = 0;\n    let mut num = num.as_bytes();\n \
    \   while num.len() > 0 {\n        let x = hex_num(num[0]);\n        num = &num[1..];\n\
    \        if x % 2 != 0 && x != 1 && x != 5 {\n            for i in (3..(x / 2)\
    \ + 1).step_by(2) {\n                if x % i == 0 {\n                    return\
    \ b;\n                }\n            }\n            b += 1;\n        }\n    }\n\
    \    b\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `hex_num` in this scope\n  --> /tmp/tmpg9c42gol.rs:21:17\n\
    \   |\n21 |         let x = hex_num(num[0]);\n   |                 ^^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let hex = [\n        \"0\", \"1\", \"2\", \"3\", \"4\", \"5\"\
    , \"6\", \"7\", \"8\", \"9\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\"\n    ];\n\
    \    let primes = [\n        \"2\", \"3\", \"5\", \"7\", \"B\", \"D\"\n    ];\n\
    \    let mut result = 0;\n    for c in num.chars() {\n        let h = hex.iter().position(|&r|\
    \ r == &c.to_string()).unwrap();\n        if primes.contains(&hex[h]) {\n    \
    \        result += 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n\
    \    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    if num.is_empty() {\n        return 0;\n    }\n    let map:\
    \ HashMap<char, isize> = [\n        ('0', 0), ('1', 1), ('2', 2), ('3', 3),\n\
    \        ('4', 4), ('5', 5), ('6', 6), ('7', 7),\n        ('8', 8), ('9', 9),\
    \ ('A', 10), ('B', 11),\n        ('C', 12), ('D', 13), ('E', 14), ('F', 15),\n\
    \    ].iter().cloned().collect();\n    let mut primes: HashSet<isize> = [2, 3,\
    \ 5, 7, 11, 13].iter().cloned().collect();\n    let prime_nums: Vec<char> = vec!['2',\
    \ '3', '5', '7', 'B', 'D'];\n    let mut len = num.len();\n    len -= 1;\n   \
    \ let mut acc = 0;\n    for ch in num.chars() {\n        let mut num = map.get(&ch).unwrap()\
    \ * 16u32.pow(len as u32) as isize;\n        if primes.contains(&num) && prime_nums.contains(&ch)\
    \ {\n            acc += 1;\n        }\n        len -= 1;\n    }\n    acc\n}\n\n\
    fn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashMap` in this scope\n  --> /tmp/tmp03ehhnx2.rs:21:14\n\
    \   |\n21 |     let map: HashMap<char, isize> = [\n   |              ^^^^^^^ not\
    \ found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  |\
    \ use std::collections::HashMap;\n   |\n\nerror[E0412]: cannot find type `HashSet`\
    \ in this scope\n  --> /tmp/tmp03ehhnx2.rs:27:21\n   |\n27 |     let mut primes:\
    \ HashSet<isize> = [2, 3, 5, 7, 11, 13].iter().cloned().collect();\n   |     \
    \                ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut n: isize = 0;\n    for c in num.chars() {\n        if\
    \ is_prime(c.to_digit(16).unwrap() as isize) {\n            n += 1;\n        }\n\
    \    }\n    n\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpga1dltlv.rs:20:12\n\
    \   |\n20 |         if is_prime(c.to_digit(16).unwrap() as isize) {\n   |    \
    \        ^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let primes: HashSet<char> = vec!['2', '3', '5', '7', 'B', 'D'].into_iter().collect();\n\
    \    num.chars().fold(0, |acc, c| if primes.contains(&c) { acc + 1 } else { acc\
    \ })\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpi6obufab.rs:18:17\n\
    \   |\n18 |     let primes: HashSet<char> = vec!['2', '3', '5', '7', 'B', 'D'].into_iter().collect();\n\
    \   |                 ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut count = 0;\n    let mut num = num.chars();\n    while\
    \ let Some(n) = num.next() {\n        match n {\n            '2' | '3' | '5' |\
    \ '7' | 'B' | 'D' => count += 1,\n            _ => (),\n        }\n    }\n   \
    \ count\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut v = Vec::new();\n    let mut prime = true;\n    let\
    \ mut count = 0;\n    for c in num.chars() {\n        let n = match c {\n    \
    \        '0' => 0,\n            '1' => 1,\n            '2' => 2,\n           \
    \ '3' => 3,\n            '4' => 4,\n            '5' => 5,\n            '6' =>\
    \ 6,\n            '7' => 7,\n            '8' => 8,\n            '9' => 9,\n  \
    \          'A' => 10,\n            'B' => 11,\n            'C' => 12,\n      \
    \      'D' => 13,\n            'E' => 14,\n            'F' => 15,\n          \
    \  _ => 0,\n        };\n        v.push(n);\n    }\n    for n in v {\n        if\
    \ n == 0 || n == 1 {\n            prime = false;\n        }\n        if n > 1\
    \ {\n            for i in 2..n {\n                if n % i == 0 {\n          \
    \          prime = false;\n                    break;\n                }\n   \
    \         }\n        }\n        if prime {\n            count += 1;\n        }\n\
    \        prime = true;\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut result = 0;\n    for c in num.chars() {\n        if\
    \ is_prime_2(c.to_digit(16).unwrap() as isize) {\n            result += 1;\n \
    \       }\n    }\n    result\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime_2` in this scope\n  --> /tmp/tmpcyyitjpd.rs:20:12\n\
    \   |\n20 |         if is_prime_2(c.to_digit(16).unwrap() as isize) {\n   |  \
    \          ^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut total = 0;\n    for letter in num.chars() {\n      \
    \  match letter {\n            '2' | '3' | '5' | '7' | 'B' | 'D' => total += 1,\n\
    \            _ => (),\n        }\n    }\n    total\n}\n\nfn main() {\n    let\
    \ candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n\
    \    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut counter = 0;\n    let mut primes = vec![2, 3, 5, 7,\
    \ 11, 13];\n    let mut digits = vec![];\n    for c in num.chars() {\n       \
    \ digits.push(match c {\n            '0' | '1' | '2' | '3' | '4' | '5' | '6' |\
    \ '7' | '8' | '9' => {\n                c.to_digit(10).unwrap()\n            }\n\
    \            'A' => 10,\n            'B' => 11,\n            'C' => 12,\n    \
    \        'D' => 13,\n            'E' => 14,\n            'F' => 15,\n        \
    \    _ => 0,\n        });\n    }\n    for d in digits {\n        for p in &primes\
    \ {\n            if d == *p {\n                counter += 1;\n               \
    \ break;\n            }\n        }\n    }\n    counter\n}\n\nfn main() {\n   \
    \ let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n\
    \    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// For num = \"AB\" the output should\
    \ be 1.\n/// For num = \"1077E\" the output should be 2.\n/// For num = \"ABED1A33\"\
    \ the output should be 4.\n/// For num = \"123456789ABCDEF0\" the output should\
    \ be 6.\n/// For num = \"2020\" the output should be 2.\nfn hex_key(num: String)\
    \ -> isize {\n    let mut count = 0;\n    let hex_nums = \"2,3,5,7,B,D\";\n  \
    \  let mut hex_list: Vec<&str> = hex_nums.split(\",\").collect();\n    for i in\
    \ num.chars() {\n        let c = i.to_string();\n        if hex_list.contains(&c.as_str())\
    \ {\n            count += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
