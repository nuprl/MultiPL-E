name: HumanEval_157_right_angle_triangle
language: rs
prompt: "/// Given the lengths of the three sides of a triangle. Return True if the\
  \ three\n/// sides form a right-angled triangle, False otherwise.\n/// A right-angled\
  \ triangle is a triangle in which one angle is right angle or \n/// 90 degree.\n\
  /// Example:\n/// right_angle_triangle(3, 4, 5) == True\n/// right_angle_triangle(1,\
  \ 2, 3) == False\nfn right_angle_triangle(a: isize, b: isize, c: isize) -> bool\
  \ {\n"
tests: "}\n\nfn main() {\n    let candidate = right_angle_triangle;\n    assert_eq!(candidate(3,\
  \ 4, 5), true);\n    assert_eq!(candidate(1, 2, 3), false);\n    assert_eq!(candidate(10,\
  \ 6, 8), true);\n    assert_eq!(candidate(2, 2, 2), false);\n    assert_eq!(candidate(7,\
  \ 24, 25), true);\n    assert_eq!(candidate(10, 5, 7), false);\n    assert_eq!(candidate(5,\
  \ 12, 13), true);\n    assert_eq!(candidate(15, 8, 17), true);\n    assert_eq!(candidate(48,\
  \ 55, 73), true);\n    assert_eq!(candidate(1, 1, 1), false);\n    assert_eq!(candidate(2,\
  \ 2, 10), false);\n}\n"
completions: ['    vec![a, b, c].iter().max().unwrap() == &(a.pow(2) + b.pow(2) +
    c.pow(2))', "    let mut edges = vec![a, b, c];\n    edges.sort();\n    edges[0]\
    \ * edges[0] + edges[1] * edges[1] == edges[2] * edges[2]", "    let vec = vec![a,\
    \ b, c];\n    vec.sort();\n    vec[0] * vec[0] + vec[1] * vec[1] == vec[2] * vec[2]",
  "    let mut v = vec![a, b, c];\n    v.sort();\n    v[0] * v[0] + v[1] * v[1] ==\
    \ v[2] * v[2]", "    let mut sides = vec![a, b, c];\n    sides.sort();\n    sides[0]\
    \ * sides[0] + sides[1] * sides[1] == sides[2] * sides[2]", "    let (a, b, c)\
    \ = if a > b {\n        if a > c {\n            (a, b, c)\n        } else {\n\
    \            (c, a, b)\n        }\n    } else {\n        if b > c {\n        \
    \    (b, a, c)\n        } else {\n            (c, b, a)\n        }\n    };\n \
    \   (a * a) == (b * b + c * c)", "    let mut sides = vec![a, b, c];\n    sides.sort();\n\
    \    sides[0] * sides[0] + sides[1] * sides[1] == sides[2] * sides[2]", "    //\
    \ TODO: implement function\n    false", "    let nums = [a, b, c];\n    if a.abs()\
    \ >= b.abs() && a.abs() >= c.abs() {\n        a*a == b*b + c*c\n    } else if\
    \ b.abs() >= a.abs() && b.abs() >= c.abs() {\n        b*b == a*a + c*c\n    }\
    \ else {\n        c*c == a*a + b*b\n    }", "    let mut array: [isize; 3] = [a,\
    \ b, c];\n    array.sort();\n    array[0] * array[0] + array[1] * array[1] ==\
    \ array[2] * array[2]", '    return (a * a + b * b == c * c) || (a * a + c * c
    == b * b) || (b * b + c * c == a * a);', '    unimplemented!()', "    let squares\
    \ = [a*a, b*b, c*c];\n    squares.contains(&(squares[0] + squares[1])) ||\n  \
    \  squares.contains(&(squares[0] + squares[2])) ||\n    squares.contains(&(squares[1]\
    \ + squares[2]))", "    // Squaring all sides and adding them. The largest side\
    \ should be equal to\n    // the sum of the smaller two.\n    let a_squared =\
    \ a * a;\n    let b_squared = b * b;\n    let c_squared = c * c;\n    match (a_squared,\
    \ b_squared, c_squared) {\n        (a, b, c) if a == b + c => true,\n        (a,\
    \ b, c) if b == a + c => true,\n        (a, b, c) if c == a + b => true,\n   \
    \     _ => false,\n    }", "    match vec![a, b, c].iter().max() {\n        Some(side)\
    \ => (a.pow(2) + b.pow(2) + c.pow(2) - 2 * side.pow(2)) == 0,\n        None =>\
    \ true\n    }", "    let squares = |x: isize| x * x;\n    let mut lengths = vec![a,\
    \ b, c];\n    lengths.sort();\n    if lengths[0] + lengths[1] <= lengths[2] {\n\
    \        return false;\n    }\n    squares(lengths[0]) + squares(lengths[1]) ==\
    \ squares(lengths[2])", "    match (a, b, c) {\n        (x, y, z) if x > y &&\
    \ x > z => {\n            let (x, y, z) = (x * x, y * y, z * z);\n           \
    \ x == y + z\n        },\n        (x, y, z) if y > x && y > z => {\n         \
    \   let (x, y, z) = (x * x, y * y, z * z);\n            y == x + z\n        },\n\
    \        (x, y, z) if z > x && z > y => {\n            let (x, y, z) = (x * x,\
    \ y * y, z * z);\n            z == x + y\n        },\n        _ => false\n   \
    \ }", "    let mut len = [a, b, c];\n    len.sort();\n    (len[0] * len[0] + len[1]\
    \ * len[1]) == len[2] * len[2]", "  let mut v = vec![a, b, c];\n  v.sort();\n\
    \  v[0] * v[0] + v[1] * v[1] == v[2] * v[2]", "    let mut sides = vec![a, b,\
    \ c];\n    sides.sort();\n    let (a, b, c) = (sides[0], sides[1], sides[2]);\n\
    \    a * a + b * b == c * c"]
stop_tokens:
- "\n}"
