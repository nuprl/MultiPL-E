name: HumanEval_118_get_closest_vowel
language: rs
results:
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp5_5j40wf.rs:12:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n\
    \    let mut position = 0;\n    let mut word = word.into_bytes();\n    word.reverse();\n\
    \    let mut i = 0;\n    while i < word.len() - 1 {\n        if vowels.contains(&(&word[i]\
    \ as char).to_lowercase().to_string().as_str()) &&\n            vowels.contains(&(&word[i\
    \ + 1] as char).to_lowercase().to_string().as_str()) {\n            break;\n \
    \       }\n        i += 1;\n    }\n    if i == word.len() - 1 {\n        String::from(\"\
    \")\n    } else {\n        String::from_utf8(vec![word[i]]).unwrap()\n    }\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0606]: casting `&u8` as `char` is invalid\n  --> /tmp/tmpfx557i5m.rs:18:29\n\
    \   |\n18 |         if vowels.contains(&(&word[i] as char).to_lowercase().to_string().as_str())\
    \ &&\n   |                             ^--------^^^^^^^^^\n   |              \
    \               ||\n   |                             |help: dereference the expression:\
    \ `*&word[i]`\n   |                             cannot cast `&u8` as `char`\n\n\
    error[E0606]: casting `&u8` as `char` is invalid\n  --> /tmp/tmpfx557i5m.rs:19:30\n\
    \   |\n19 |             vowels.contains(&(&word[i + 1] as char).to_lowercase().to_string().as_str())\
    \ {\n   |                              ^------------^^^^^^^^^\n   |          \
    \                    ||\n   |                              |help: dereference\
    \ the expression: `*&word[i + 1]`\n   |                              cannot cast\
    \ `&u8` as `char`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0606`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut closest = String::new();\n    let mut chars\
    \ = word.chars().rev();\n    loop {\n        let c = chars.next();\n        if\
    \ c.is_none() {\n            break;\n        }\n        let c = c.unwrap();\n\
    \        if c.is_alphabetic() {\n            if closest.is_empty() {\n       \
    \         if c.is_vowel() {\n                    closest.push(c);\n          \
    \      }\n            } else {\n                if c.is_vowel() {\n          \
    \          return closest;\n                } else {\n                    closest.clear();\n\
    \                }\n            }\n        }\n    }\n    closest\n}\n\nfn main()\
    \ {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_vowel` found for type `char` in the current\
    \ scope\n  --> /tmp/tmp1yj8v4f7.rs:22:22\n   |\n22 |                 if c.is_vowel()\
    \ {\n   |                      ^^^^^^^^ method not found in `char`\n\nerror[E0599]:\
    \ no method named `is_vowel` found for type `char` in the current scope\n  -->\
    \ /tmp/tmp1yj8v4f7.rs:26:22\n   |\n26 |                 if c.is_vowel() {\n  \
    \ |                      ^^^^^^^^ method not found in `char`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmptsggdrkm.rs:12:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut result = \"\".to_string();\n    let word =\
    \ word.to_lowercase();\n    let word_len = word.len();\n    let word_chars: Vec<char>\
    \ = word.chars().collect();\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n\
    \    let mut vowel_position = 0;\n    let mut consonant_position = 0;\n    let\
    \ mut counter = 0;\n    let mut init_vowel_position = 0;\n    let mut init_consonant_position\
    \ = 0;\n    for c in word_chars {\n        if consonant_position == 0 && vowel_position\
    \ == 0 {\n            if vowels.contains(&c) {\n                vowel_position\
    \ = word_len - counter;\n                init_vowel_position = vowel_position;\n\
    \            } else {\n                consonant_position = word_len - counter;\n\
    \                init_consonant_position = consonant_position;\n            }\n\
    \        } else if consonant_position > 0 && vowel_position == 0 {\n         \
    \   if vowels.contains(&c) {\n                vowel_position = word_len - counter;\n\
    \            }\n        } else if consonant_position == 0 && vowel_position >\
    \ 0 {\n            if !vowels.contains(&c) {\n                consonant_position\
    \ = word_len - counter;\n            }\n        } else if consonant_position >\
    \ 0 && vowel_position > 0 {\n            if consonant_position < vowel_position\
    \ {\n                break;\n            } else if consonant_position > vowel_position\
    \ {\n                if vowels.contains(&c) {\n                    vowel_position\
    \ = word_len - counter;\n                } else {\n                    consonant_position\
    \ = word_len - counter;\n                }\n            }\n        }\n       \
    \ counter += 1;\n    }\n    if consonant_position == init_consonant_position {\n\
    \        return result;\n    }\n    result = word_chars[vowel_position - 1].to_string();\n\
    \    result\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "warning: variable `init_vowel_position` is assigned to, but never used\n\
    \  --> /tmp/tmpxvnn14n8.rs:20:13\n   |\n20 |     let mut init_vowel_position =\
    \ 0;\n   |             ^^^^^^^^^^^^^^^^^^^\n   |\n   = note: `#[warn(unused_variables)]`\
    \ on by default\n   = note: consider using `_init_vowel_position` instead\n\n\
    warning: value assigned to `init_vowel_position` is never read\n  --> /tmp/tmpxvnn14n8.rs:26:17\n\
    \   |\n26 |                 init_vowel_position = vowel_position;\n   |      \
    \           ^^^^^^^^^^^^^^^^^^^\n   |\n   = note: `#[warn(unused_assignments)]`\
    \ on by default\n   = help: maybe it is overwritten before being read?\n\nerror[E0382]:\
    \ borrow of moved value: `word_chars`\n   --> /tmp/tmpxvnn14n8.rs:55:14\n    |\n\
    15  |     let word_chars: Vec<char> = word.chars().collect();\n    |         ----------\
    \ move occurs because `word_chars` has type `Vec<char>`, which does not implement\
    \ the `Copy` trait\n...\n22  |     for c in word_chars {\n    |              ----------\
    \ `word_chars` moved due to this implicit call to `.into_iter()`\n...\n55  | \
    \    result = word_chars[vowel_position - 1].to_string();\n    |             \
    \ ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes\
    \ ownership of the receiver `self`, which moves `word_chars`\nhelp: consider iterating\
    \ over a slice of the `Vec<char>`'s content to avoid moving into the `for` loop\n\
    \    |\n22  |     for c in &word_chars {\n    |              +\n\nerror: aborting\
    \ due to previous error; 2 warnings emitted\n\nFor more information about this\
    \ error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpv8_lbv2v.rs:12:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = ['a', 'e', 'i', 'o', 'u'];\n    let mut\
    \ closest_index = 0;\n    let mut found = false;\n    let word_chars: Vec<char>\
    \ = word.chars().collect();\n    let word_len = word_chars.len();\n    for i in\
    \ (0..word_len).rev() {\n        if !vowels.contains(&word_chars[i]) {\n     \
    \       // not found\n            continue;\n        }\n        if i > 0 && !vowels.contains(&word_chars[i\
    \ - 1]) {\n            // found, check if last\n            if i == word_len -\
    \ 1 {\n                found = true;\n                closest_index = i;\n   \
    \             break;\n            }\n            // found\n            if !vowels.contains(&word_chars[i\
    \ + 1]) {\n                found = true;\n                closest_index = i;\n\
    \                break;\n            }\n        }\n    }\n    if found {\n   \
    \     word_chars[closest_index].to_string()\n    } else {\n        \"\".to_string()\n\
    \    }\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"i\"`,\n right: `\"\"`', /tmp/tmpd0kgbcvt.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec!['A', 'E', 'I', 'O', 'U'];\n \
    \   vowels.append(&mut vec!['a', 'e', 'i', 'o', 'u']);\n    let mut v_pos: i32\
    \ = -1;\n    let mut c_pos: i32 = word.len() as i32;\n    for (i, c) in word.chars().enumerate()\
    \ {\n        if vowels.contains(&c) {\n            v_pos = i as i32;\n       \
    \ } else if v_pos > -1 {\n            c_pos = i as i32;\n            break;\n\
    \        }\n    }\n    if v_pos > -1 && c_pos > v_pos + 1 {\n        word.chars().nth(v_pos\
    \ as usize).unwrap().to_string()\n    } else {\n        \"\".to_string()\n   \
    \ }\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"u\"`', /tmp/tmpptuebtw6.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"\
    ];\n    let count = word.len();\n    let chars: Vec<char> = word.chars().collect();\n\
    \    for i in 0..count {\n        if !vowels.contains(&chars[i].to_string().as_str())\
    \ {\n            if i + 1 < count && vowels.contains(&chars[i + 1].to_string().as_str())\
    \ {\n                return chars[i + 1].to_string();\n            }\n       \
    \ }\n    }\n    String::from(\"\")\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"o\"`,\n right: `\"u\"`', /tmp/tmpi1g8q4d5.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let\
    \ mut closest_vowel = ' ';\n    let mut min_distance = 0;\n    for (idx, c) in\
    \ word.chars().enumerate() {\n        if vowels.contains(&c) {\n            let\
    \ mut right_distance = 0;\n            for (r_idx, r_c) in word.chars().enumerate().skip(idx\
    \ + 1) {\n                if vowels.contains(&r_c) {\n                    right_distance\
    \ = 0;\n                } else {\n                    right_distance += 1;\n \
    \               }\n                if right_distance > min_distance {\n      \
    \              break;\n                }\n            }\n            if right_distance\
    \ > min_distance {\n                continue;\n            }\n            let\
    \ mut left_distance = 0;\n            for (l_idx, l_c) in word.chars().enumerate().rev().skip(word.len()\
    \ - idx) {\n                if vowels.contains(&l_c) {\n                    left_distance\
    \ = 0;\n                } else {\n                    left_distance += 1;\n  \
    \              }\n                if left_distance > min_distance {\n        \
    \            break;\n                }\n            }\n            if left_distance\
    \ > min_distance {\n                continue;\n            }\n            min_distance\
    \ = std::cmp::min(left_distance, right_distance);\n            closest_vowel =\
    \ c;\n        }\n    }\n    if closest_vowel == ' ' {\n        \"\".to_string()\n\
    \    } else {\n        closest_vowel.to_string()\n    }\n}\n\nfn main() {\n  \
    \  let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n\
    \    --> /tmp/tmp1bk4tanj.rs:32:58\n     |\n32   |             for (l_idx, l_c)\
    \ in word.chars().enumerate().rev().skip(word.len() - idx) {\n     |         \
    \                                                 ^^^ the trait `ExactSizeIterator`\
    \ is not implemented for `Chars<'_>`\n     |\n     = help: the following other\
    \ types implement trait `ExactSizeIterator`:\n               &mut I\n        \
    \       Args\n               ArgsOs\n               ArrayChunks<'_, T, N>\n  \
    \             ArrayChunksMut<'_, T, N>\n               ArrayWindows<'_, T, N>\n\
    \               Box<I, A>\n               Chunks<'_, T>\n             and 109\
    \ others\n     = note: required because of the requirements on the impl of `DoubleEndedIterator`\
    \ for `Enumerate<Chars<'_>>`\nnote: required by a bound in `rev`\n\nerror[E0599]:\
    \ the method `skip` exists for struct `Rev<Enumerate<Chars<'_>>>`, but its trait\
    \ bounds were not satisfied\n  --> /tmp/tmp1bk4tanj.rs:32:64\n   |\n32 |     \
    \          for (l_idx, l_c) in word.chars().enumerate().rev().skip(word.len()\
    \ - idx) {\n   |                                                             \
    \     ^^^^ method cannot be called on `Rev<Enumerate<Chars<'_>>>` due to unsatisfied\
    \ trait bounds\n   |\n   = note: the following trait bounds were not satisfied:\n\
    \           `Enumerate<Chars<'_>>: DoubleEndedIterator`\n           which is required\
    \ by `Rev<Enumerate<Chars<'_>>>: Iterator`\n           `Rev<Enumerate<Chars<'_>>>:\
    \ Iterator`\n           which is required by `&mut Rev<Enumerate<Chars<'_>>>:\
    \ Iterator`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut iter = word.chars().rev();\n    let mut consonant\
    \ = iter.next().unwrap();\n    let mut has_consonant = false;\n    let mut has_vowel\
    \ = false;\n    let mut result = String::new();\n    for vowel in iter {\n   \
    \     match vowel {\n            'a' | 'e' | 'i' | 'o' | 'u' => {\n          \
    \      if has_consonant {\n                    result.push(vowel);\n         \
    \           break;\n                }\n                has_vowel = true;\n   \
    \         },\n            _ => {\n                if has_vowel {\n           \
    \         result.push(consonant);\n                    break;\n              \
    \  }\n                has_consonant = true;\n                consonant = vowel;\n\
    \            }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmpfnth6zf4.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = \"AEIOUaeiou\";\n    let start = word.len()\
    \ - 1;\n    let chars: Vec<char> = word.chars().collect();\n    for i in (0..chars.len()).rev()\
    \ {\n        if vowels.contains(chars[i]) {\n            for j in (i + 1..chars.len()).rev()\
    \ {\n                if vowels.contains(chars[j]) {\n                    return\
    \ chars[j].to_string();\n                }\n            }\n        }\n    }\n\
    \    \"\".to_string()\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"u\"`', /tmp/tmp90kg68y3.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    // None means word end\n    if word.len() < 2 {\n \
    \       return String::new();\n    }\n    let mut last_vowel = 0;\n    for (i,\
    \ c) in word.chars().enumerate().rev() {\n        if is_vowel(c) {\n         \
    \   last_vowel = i;\n            break;\n        }\n    }\n    if last_vowel ==\
    \ 0 {\n        return String::new();\n    }\n    let mut vowels = vec![];\n  \
    \  for (i, c) in word.chars().enumerate().rev() {\n        if is_vowel(c) {\n\
    \            vowels.push(i);\n        } else {\n            break;\n        }\n\
    \    }\n    if vowels.len() < 2 {\n        return String::new();\n    }\n    let\
    \ mut closest_vowel = -1;\n    for v in vowels {\n        if v > last_vowel {\n\
    \            closest_vowel = v;\n            break;\n        }\n    }\n    if\
    \ closest_vowel < 0 {\n        closest_vowel = vowels[0];\n    }\n    let mut\
    \ r = String::new();\n    r.push(word.chars().nth(closest_vowel).unwrap());\n\
    \    r\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmp5d7tjnis.rs:18:12\n\
    \   |\n18 |         if is_vowel(c) {\n   |            ^^^^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find function `is_vowel` in this scope\n  -->\
    \ /tmp/tmp5d7tjnis.rs:28:12\n   |\n28 |         if is_vowel(c) {\n   |       \
    \     ^^^^^^^^ not found in this scope\n\nerror[E0277]: the trait bound `Chars<'_>:\
    \ ExactSizeIterator` is not satisfied\n    --> /tmp/tmp5d7tjnis.rs:17:44\n   \
    \  |\n17   |     for (i, c) in word.chars().enumerate().rev() {\n     |      \
    \                                      ^^^ the trait `ExactSizeIterator` is not\
    \ implemented for `Chars<'_>`\n     |\n     = help: the following other types\
    \ implement trait `ExactSizeIterator`:\n               &mut I\n              \
    \ Args\n               ArgsOs\n               ArrayChunks<'_, T, N>\n        \
    \       ArrayChunksMut<'_, T, N>\n               ArrayWindows<'_, T, N>\n    \
    \           Box<I, A>\n               Chunks<'_, T>\n             and 109 others\n\
    \     = note: required because of the requirements on the impl of `DoubleEndedIterator`\
    \ for `Enumerate<Chars<'_>>`\nnote: required by a bound in `rev`\n\nerror[E0277]:\
    \ the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n  --> /tmp/tmp5d7tjnis.rs:17:19\n\
    \   |\n17 |     for (i, c) in word.chars().enumerate().rev() {\n   |         \
    \          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `ExactSizeIterator` is not\
    \ implemented for `Chars<'_>`\n   |\n   = help: the following other types implement\
    \ trait `ExactSizeIterator`:\n             &mut I\n             Args\n       \
    \      ArgsOs\n             ArrayChunks<'_, T, N>\n             ArrayChunksMut<'_,\
    \ T, N>\n             ArrayWindows<'_, T, N>\n             Box<I, A>\n       \
    \      Chunks<'_, T>\n           and 109 others\n   = note: required because of\
    \ the requirements on the impl of `DoubleEndedIterator` for `Enumerate<Chars<'_>>`\n\
    \   = note: required because of the requirements on the impl of `Iterator` for\
    \ `Rev<Enumerate<Chars<'_>>>`\n   = note: required because of the requirements\
    \ on the impl of `IntoIterat"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    word.chars().rev().skip_while(|&c| !(c == 'A' || c\
    \ == 'E' || c == 'I' || c == 'O' || c == 'U')).skip(1).skip_while(|&c| !(c ==\
    \ 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U')).take(1).collect()\n}\n\
    \nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"u\"`', /tmp/tmpky67t7si.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut word_chars = word.chars().collect::<Vec<char>>();\n\
    \    word_chars.reverse();\n    let mut count = 0;\n    for c in word_chars {\n\
    \        count += 1;\n        if c.is_lowercase() {\n            if !c.is_alphabetic()\
    \ {\n                continue;\n            }\n            if is_vowel(c) {\n\
    \                if count == 1 {\n                    continue;\n            \
    \    }\n                if count == 2 {\n                    return String::from(\"\
    \");\n                }\n                let prev = word_chars[count - 2];\n \
    \               if prev.is_lowercase() {\n                    if !prev.is_alphabetic()\
    \ {\n                        continue;\n                    }\n              \
    \      if !is_vowel(prev) {\n                        return c.to_string();\n \
    \                   }\n                }\n            }\n        }\n        if\
    \ c.is_uppercase() {\n            if !c.is_alphabetic() {\n                continue;\n\
    \            }\n            if is_vowel(c) {\n                if count == 1 {\n\
    \                    continue;\n                }\n                if count ==\
    \ 2 {\n                    return String::from(\"\");\n                }\n   \
    \             let prev = word_chars[count - 2];\n                if prev.is_uppercase()\
    \ {\n                    if !prev.is_alphabetic() {\n                        continue;\n\
    \                    }\n                    if !is_vowel(prev) {\n           \
    \             return c.to_string();\n                    }\n                }\n\
    \            }\n        }\n    }\n    String::from(\"\")\n}\n\nfn main() {\n \
    \   let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpd47rr0kl.rs:21:16\n\
    \   |\n21 |             if is_vowel(c) {\n   |                ^^^^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find function `is_vowel` in this scope\n\
    \  --> /tmp/tmpd47rr0kl.rs:33:25\n   |\n33 |                     if !is_vowel(prev)\
    \ {\n   |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `is_vowel` in this scope\n  --> /tmp/tmpd47rr0kl.rs:43:16\n\
    \   |\n43 |             if is_vowel(c) {\n   |                ^^^^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find function `is_vowel` in this scope\n\
    \  --> /tmp/tmpd47rr0kl.rs:55:25\n   |\n55 |                     if !is_vowel(prev)\
    \ {\n   |                         ^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to 4 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmppsrk53uh.rs:12:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = \"aeiouAEIOU\";\n    let mut buffer =\
    \ String::new();\n    let mut result = String::new();\n    for c in word.chars().rev()\
    \ {\n        if vowels.contains(c) {\n            buffer.push(c);\n        } else\
    \ {\n            if !buffer.is_empty() {\n                result = buffer.clone();\n\
    \                break;\n            }\n        }\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"i\"`,\n right: `\"\"`', /tmp/tmpquaqmdvu.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let\
    \ consonants = \"bcdfghjklmnpqrstvwxyz\".chars().collect::<Vec<char>>();\n   \
    \ let mut closest_vowel = String::new();\n    let mut closest_index = word.len();\n\
    \    for (i, c) in word.chars().enumerate().rev() {\n        if vowels.contains(&c)\
    \ {\n            closest_vowel = c.to_string();\n            closest_index = i;\n\
    \        } else if consonants.contains(&c) {\n            if i == word.len() -\
    \ 1 {\n                return String::new();\n            }\n            if closest_index\
    \ < word.len() {\n                return closest_vowel;\n            }\n     \
    \   }\n    }\n    String::new()\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n\
    \    --> /tmp/tmp4cscxhi9.rs:16:44\n     |\n16   |     for (i, c) in word.chars().enumerate().rev()\
    \ {\n     |                                            ^^^ the trait `ExactSizeIterator`\
    \ is not implemented for `Chars<'_>`\n     |\n     = help: the following other\
    \ types implement trait `ExactSizeIterator`:\n               &mut I\n        \
    \       Args\n               ArgsOs\n               ArrayChunks<'_, T, N>\n  \
    \             ArrayChunksMut<'_, T, N>\n               ArrayWindows<'_, T, N>\n\
    \               Box<I, A>\n               Chunks<'_, T>\n             and 109\
    \ others\n     = note: required because of the requirements on the impl of `DoubleEndedIterator`\
    \ for `Enumerate<Chars<'_>>`\nnote: required by a bound in `rev`\n\nerror[E0277]:\
    \ the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n  --> /tmp/tmp4cscxhi9.rs:16:19\n\
    \   |\n16 |     for (i, c) in word.chars().enumerate().rev() {\n   |         \
    \          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `ExactSizeIterator` is not\
    \ implemented for `Chars<'_>`\n   |\n   = help: the following other types implement\
    \ trait `ExactSizeIterator`:\n             &mut I\n             Args\n       \
    \      ArgsOs\n             ArrayChunks<'_, T, N>\n             ArrayChunksMut<'_,\
    \ T, N>\n             ArrayWindows<'_, T, N>\n             Box<I, A>\n       \
    \      Chunks<'_, T>\n           and 109 others\n   = note: required because of\
    \ the requirements on the impl of `DoubleEndedIterator` for `Enumerate<Chars<'_>>`\n\
    \   = note: required because of the requirements on the impl of `Iterator` for\
    \ `Rev<Enumerate<Chars<'_>>>`\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `Rev<Enumerate<Chars<'_>>>`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let word = word.chars().rev().collect::<Vec<char>>();\n\
    \    let mut vowels = String::new();\n    let mut cons = String::new();\n    let\
    \ mut res = String::new();\n    let mut index: usize = 0;\n    let cons1 = \"\
    b,c,d,f,g,h,j,k,l,m,n,p,q,r,s,t,v,w,x,y,z\".split(\",\").collect::<Vec<&str>>();\n\
    \    let cons2 = \"B,C,D,F,G,H,J,K,L,M,N,P,Q,R,S,T,V,W,X,Y,Z\".split(\",\").collect::<Vec<&str>>();\n\
    \    let vow1 = \"a,e,i,o,u\".split(\",\").collect::<Vec<&str>>();\n    let vow2\
    \ = \"A,E,I,O,U\".split(\",\").collect::<Vec<&str>>();\n    for c in word.iter()\
    \ {\n        if vow1.contains(&c.to_string().as_str()) || vow2.contains(&c.to_string().as_str())\
    \ {\n            vowels = vowels + c.to_string().as_str();\n        } else if\
    \ cons1.contains(&c.to_string().as_str()) || cons2.contains(&c.to_string().as_str())\
    \ {\n            cons = cons + c.to_string().as_str();\n        }\n    }\n   \
    \ for v in vowels.chars() {\n        if cons.chars().nth(index).is_some() {\n\
    \            res = res + &v.to_string();\n            index += 1;\n        }\n\
    \    }\n    return res;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"uo\"`,\n right: `\"u\"`', /tmp/tmp5q9cg_jl.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    if word.len() < 3 {\n        return \"\".to_string();\n\
    \    }\n    let mut i = word.len() - 1;\n    while i > 0 {\n        let mut c\
    \ = word.chars().nth(i).unwrap();\n        if c == 'a' || c == 'e' || c == 'i'\
    \ || c == 'o' || c == 'u' {\n            let j = i - 1;\n            if j > 0\
    \ {\n                let mut c2 = word.chars().nth(j).unwrap();\n            \
    \    if c2 != 'a' && c2 != 'e' && c2 != 'i' && c2 != 'o' && c2 != 'u' {\n    \
    \                let mut c3 = word.chars().nth(j - 1).unwrap();\n            \
    \        if c3 != 'a' && c3 != 'e' && c3 != 'i' && c3 != 'o' && c3 != 'u' {\n\
    \                        return c.to_string();\n                    }\n      \
    \          }\n            }\n        }\n        i -= 1;\n    }\n    \"\".to_string()\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"u\"`', /tmp/tmpvku66ywb.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
