language: rs
name: HumanEval_126_is_sorted
results:
- exit_code: 101
  program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut is_ascending = true;\n    let mut previous = lst[0];\n\
    \    for (i, value) in lst.iter().enumerate() {\n        if i > 0 {\n        \
    \    if previous > *value {\n                is_ascending = false;\n         \
    \       break;\n            }\n            previous = *value;\n        }\n   \
    \ }\n    is_ascending\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmp529c2nu0.rs:15:24

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823239
- exit_code: 101
  program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    lst.iter().cloned().zip(lst.iter().cloned().skip(1)).all(|(i,\
    \ j)| i <= j)\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpky2tpakr.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823239
- exit_code: 1
  program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let lst_sorted = lst.iter().sorted();\n    lst == lst_sorted\n\
    }\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sorted` found for struct `std::slice::Iter`\
    \ in the current scope\n  --> /tmp/tmpcilrihg8.rs:14:33\n   |\n14 |     let lst_sorted\
    \ = lst.iter().sorted();\n   |                                 ^^^^^^ method not\
    \ found in `std::slice::Iter<'_, isize>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659823239
- exit_code: 101
  program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    for i in 0..lst.len()-1 {\n        if lst[i] > lst[i+1] {\n \
    \           return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let\
    \ candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmprw7bm93g.rs:14:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823239
- exit_code: 101
  program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    if lst.len() == 1 {\n        return true;\n    }\n    let mut\
    \ lst = lst;\n    lst.sort();\n    for i in 0..lst.len() - 1 {\n        if lst[i]\
    \ == lst[i + 1] {\n            return false;\n        }\n    }\n    true\n}\n\n\
    fn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmptd9yidwh.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823239
- exit_code: 101
  program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut prev = None;\n    for num in lst {\n        match prev\
    \ {\n            Some(v) if v > num => return false,\n            _ => prev =\
    \ Some(num),\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpjzmwmm_c.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823239
- exit_code: 101
  program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    if lst.len() == 1 {\n        return true;\n    }\n\n    let mut\
    \ last_value = lst[0];\n    for i in 1..lst.len() {\n        if lst[i] > last_value\
    \ {\n            last_value = lst[i];\n        } else {\n            return false;\n\
    \        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n\
    \    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmp1fbx6xae.rs:18:26

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823239
- exit_code: 101
  program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut dups = 0;\n    let mut prev = None;\n    for item in\
    \ lst {\n        match prev {\n            Some(prev_item) => {\n            \
    \    if item <= prev_item {\n                    dups += 1;\n                }\n\
    \            }\n            None => {}\n        }\n        prev = Some(item);\n\
    \    }\n    dups == 0\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpvr4ccofr.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823239
- exit_code: 101
  program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut last = std::isize::MIN;\n    let mut ret = true;\n  \
    \  for i in lst {\n        if i == last {\n            ret = false;\n        \
    \    break;\n        }\n        if i < last {\n            ret = false;\n    \
    \        break;\n        }\n        last = i;\n    }\n    ret\n}\n\nfn main()\
    \ {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmppac7hqho.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823239
- exit_code: 101
  program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    if lst.len() <= 1 {\n        return true;\n    }\n    let mut\
    \ previous = lst[0];\n    for i in 1..lst.len() {\n        if lst[i] <= previous\
    \ {\n            return false;\n        }\n        previous = lst[i];\n    }\n\
    \    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpl3hwxgzj.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823239
- exit_code: 101
  program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    (1..lst.len()).all(|i| lst[i - 1] < lst[i])\n}\n\nfn main() {\n\
    \    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp7i05ozrd.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823239
- exit_code: 101
  program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    // The functon will return true only if the list\n    // 1. contains\
    \ more than 1 element\n    // 2. the current element is not greater than the next\
    \ element\n    // 3. all the elements in the list are unique\n    // The input\
    \ list is sorted in ascending order if and only if these conditions are met.\n\
    \    let mut result = true;\n    let mut len = lst.len();\n    if len > 1 {\n\
    \        for i in 0..len-1 {\n            if lst[i] >= lst[i+1] {\n          \
    \      result = false;\n                break;\n            }\n        }\n   \
    \     if result {\n            // check if all the elements in the list are unique\n\
    \            let mut lst_unique = lst.clone();\n            lst_unique.sort();\n\
    \            lst_unique.dedup();\n            if lst_unique.len() < len {\n  \
    \              result = false;\n            }\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp5yhshjmf.rs:54:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823239
- exit_code: 101
  program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = lst.to_vec();\n    sorted.sort();\n    sorted\
    \ == lst\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmprn4nohxy.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823239
- exit_code: 101
  program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    lst.iter().zip(lst.iter().skip(1)).all(|(a, b)| a <= b)\n}\n\n\
    fn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmplbr262i8.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823239
- exit_code: 101
  program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    for i in 0..lst.len() - 1 {\n        if lst[i] >= lst[i + 1]\
    \ {\n            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmp0_o616r_.rs:14:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823239
- exit_code: 101
  program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut prev = lst[0];\n    for x in lst {\n        if x < prev\
    \ {\n            return false;\n        }\n        prev = x;\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmp_jhi1l1w.rs:14:20

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823239
- exit_code: 101
  program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut lst = lst;\n    lst.sort();\n    lst.dedup();\n    lst\
    \ == lst.iter().enumerate().map(|(i, x)| *x - i as isize).collect::<Vec<isize>>()\n\
    }\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpn2yj1vcv.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823239
- exit_code: 101
  program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut cloned = lst.clone();\n    cloned.sort();\n    cloned.dedup();\n\
    \    cloned == lst\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpbsz5df6w.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823239
- exit_code: 101
  program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    for (index, element) in lst.iter().enumerate() {\n        if\
    \ index != 0 {\n            if element <= &lst[index - 1] {\n                return\
    \ false;\n            }\n        }\n    }\n    true\n}\n\nfn main() {\n    let\
    \ candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp6go6tm34.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823239
- exit_code: 101
  program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    for i in 0..lst.len()-1 {\n        if lst[i] > lst[i+1] {\n \
    \           return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let\
    \ candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmprw7bm93g.rs:14:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823239
