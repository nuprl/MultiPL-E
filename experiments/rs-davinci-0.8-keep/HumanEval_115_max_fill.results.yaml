name: HumanEval_115_max_fill
language: rs
results:
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let rows = grid.len();\n    let cols = grid[0].len();\n\
    \    let mut grid = grid;\n    let mut count = 0;\n    while let Some(row) = grid.iter().position(|r|\
    \ r.iter().any(|&v| v == 1)) {\n        for c in 0..cols {\n            let mut\
    \ extracted = capacity;\n            let mut r = row;\n            while extracted\
    \ > 0 && r < rows {\n                if grid[r][c] == 1 {\n                  \
    \  grid[r][c] = 0;\n                    extracted -= 1;\n                }\n \
    \               r += 1;\n            }\n        }\n        count += 1;\n    }\n\
    \    count\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `6`', /tmp/tmphzvum17x.rs:52:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    grid.iter().fold(0, |acc, row| {\n        let mut sum\
    \ = 0;\n        for &value in row {\n            sum += value;\n            if\
    \ sum > capacity {\n                acc += sum - capacity;\n                sum\
    \ = capacity;\n            }\n        }\n        acc\n    })\n}\n\nfn main() {\n\
    \    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0],\
    \ vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `acc`\n  --> /tmp/tmpj094cf8d.rs:34:17\n\
    \   |\n29 |     grid.iter().fold(0, |acc, row| {\n   |                       \
    \   --- help: consider making this binding mutable: `mut acc`\n...\n34 |     \
    \            acc += sum - capacity;\n   |                 ^^^^^^^^^^^^^^^^^^^^^\
    \ cannot assign to immutable argument\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max = 0;\n    for row in grid {\n        for\
    \ &col in &row {\n            max = max.max(col);\n        }\n    }\n    let mut\
    \ ans = 0;\n    for row in grid {\n        for &col in &row {\n            if\
    \ col != max {\n                ans += (max - col).abs();\n            }\n   \
    \     }\n    }\n    ans\n}\n\nfn main() {\n    let candidate = max_fill;\n   \
    \ assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1,\
    \ 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0, 0,\
    \ 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "warning: unused variable: `capacity`\n  --> /tmp/tmpre4kbljs.rs:28:36\n\
    \   |\n28 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n \
    \  |                                    ^^^^^^^^ help: if this is intentional,\
    \ prefix it with an underscore: `_capacity`\n   |\n   = note: `#[warn(unused_variables)]`\
    \ on by default\n\nerror[E0382]: use of moved value: `grid`\n   --> /tmp/tmpre4kbljs.rs:36:16\n\
    \    |\n28  | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n\
    \    |             ---- move occurs because `grid` has type `Vec<Vec<isize>>`,\
    \ which does not implement the `Copy` trait\n29  |     let mut max = 0;\n30  |\
    \     for row in grid {\n    |                ---- `grid` moved due to this implicit\
    \ call to `.into_iter()`\n...\n36  |     for row in grid {\n    |            \
    \    ^^^^ value used here after move\n    |\nnote: this function takes ownership\
    \ of the receiver `self`, which moves `grid`\nhelp: consider iterating over a\
    \ slice of the `Vec<Vec<isize>>`'s content to avoid moving into the `for` loop\n\
    \    |\n30  |     for row in &grid {\n    |                +\n\nerror: aborting\
    \ due to previous error; 1 warning emitted\n\nFor more information about this\
    \ error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    // lowest depth of non-empty wells in each column\n \
    \   let mut depths = vec![0; grid[0].len()];\n    for i in 0..grid.len() {\n \
    \       for j in 0..grid[i].len() {\n            if grid[i][j] == 1 {\n      \
    \          depths[j] = i + 1;\n            }\n        }\n    }\n    let mut count\
    \ = 0;\n    let mut water = 0;\n    let mut i = 0;\n    while i < depths.len()\
    \ {\n        let mut j = i;\n        // go left until either at the end of the\
    \ well or reached non-empty\n        while j > 0 && depths[j - 1] >= depths[j]\
    \ {\n            j -= 1;\n        }\n        let row = depths[j];\n        let\
    \ mut col = 0;\n        while j < depths.len() && depths[j] >= row {\n       \
    \     // collect water\n            water += row - grid[row - 1][j];\n       \
    \     if water < 0 {\n                water = 0;\n            }\n            if\
    \ water > capacity {\n                count += 1;\n                water = 0;\n\
    \            }\n            // move to next column\n            col += 1;\n  \
    \          j += 1;\n        }\n        i = j;\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1,\
    \ 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_6weln23.rs:51:28\n   |\n\
    51 |             water += row - grid[row - 1][j];\n   |                      \
    \      ^^^^^^^^^^^^^^^^ expected `usize`, found `isize`\n\nerror[E0277]: cannot\
    \ subtract `isize` from `usize`\n  --> /tmp/tmp_6weln23.rs:51:26\n   |\n51 | \
    \            water += row - grid[row - 1][j];\n   |                          ^\
    \ no implementation for `usize - isize`\n   |\n   = help: the trait `Sub<isize>`\
    \ is not implemented for `usize`\n   = help: the following other types implement\
    \ trait `Sub<Rhs>`:\n             <&'a f32 as Sub<f32>>\n             <&'a f64\
    \ as Sub<f64>>\n             <&'a i128 as Sub<i128>>\n             <&'a i16 as\
    \ Sub<i16>>\n             <&'a i32 as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n\
    \             <&'a i8 as Sub<i8>>\n             <&'a isize as Sub<isize>>\n  \
    \         and 48 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_6weln23.rs:55:24\n\
    \   |\n55 |             if water > capacity {\n   |                        ^^^^^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n55 |           \
    \  if water > capacity.try_into().unwrap() {\n   |                           \
    \     ++++++++++++++++++++\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let m = grid.len();\n    let n = grid[0].len();\n   \
    \ let mut water = vec![0; m];\n    for row in grid {\n        for (i, &cell) in\
    \ row.iter().enumerate() {\n            water[i] += cell;\n        }\n    }\n\
    \    water.sort();\n    let mut l = 0;\n    let mut r = capacity * m;\n    while\
    \ l < r {\n        let h = (l + r) / 2;\n        let mut moves = 0;\n        for\
    \ water in water.iter() {\n            moves += (water + h - 1) / h - 1;\n   \
    \     }\n        if moves > capacity {\n            l = h + 1;\n        } else\
    \ {\n            r = h;\n        }\n    }\n    m * capacity - l\n}\n\nfn main()\
    \ {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1,\
    \ 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnzhi58au.rs:39:28\n   |\n\
    39 |     let mut r = capacity * m;\n   |                            ^ expected\
    \ `isize`, found `usize`\n\nerror[E0277]: cannot multiply `isize` by `usize`\n\
    \  --> /tmp/tmpnzhi58au.rs:39:26\n   |\n39 |     let mut r = capacity * m;\n \
    \  |                          ^ no implementation for `isize * usize`\n   |\n\
    \   = help: the trait `Mul<usize>` is not implemented for `isize`\n   = help:\
    \ the following other types implement trait `Mul<Rhs>`:\n             <&'a f32\
    \ as Mul<f32>>\n             <&'a f64 as Mul<f64>>\n             <&'a i128 as\
    \ Mul<i128>>\n             <&'a i16 as Mul<i16>>\n             <&'a i32 as Mul<i32>>\n\
    \             <&'a i64 as Mul<i64>>\n             <&'a i8 as Mul<i8>>\n      \
    \       <&'a isize as Mul<isize>>\n           and 49 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpnzhi58au.rs:52:9\n   |\n52 |     m * capacity - l\n   |\
    \         ^^^^^^^^ expected `usize`, found `isize`\n\nerror[E0277]: cannot multiply\
    \ `usize` by `isize`\n  --> /tmp/tmpnzhi58au.rs:52:7\n   |\n52 |     m * capacity\
    \ - l\n   |       ^ no implementation for `usize * isize`\n   |\n   = help: the\
    \ trait `Mul<isize>` is not implemented for `usize`\n   = help: the following\
    \ other types implement trait `Mul<Rhs>`:\n             <&'a f32 as Mul<f32>>\n\
    \             <&'a f64 as Mul<f64>>\n             <&'a i128 as Mul<i128>>\n  \
    \           <&'a i16 as Mul<i16>>\n             <&'a i32 as Mul<i32>>\n      \
    \       <&'a i64 as Mul<i64>>\n             <&'a i8 as Mul<i8>>\n            \
    \ <&'a isize as Mul<isize>>\n           and 49 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpnzhi58au.rs:52:20\n   |\n52 |     m * capacity - l\n  \
    \ |                    ^ expected `usize`, found `isize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpnzhi58au.rs:52:5\n   |\n28 | fn max_fill(grid: Vec<Vec<isize>>,\
    \ capacity: isize) -> isize {\n   |                                          \
    \              ----- expected `isize` because of return type\n...\n52 |     m\
    \ * capacity - l\n   |     ^^^^^^^^^^^^^^^^ expected `isize`, found `usize`\n\
    \   |\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut iter = grid.iter().cloned();\n    let mut res\
    \ = 0;\n    while let Some(row) = iter.next() {\n        let mut it = row.iter().cloned();\n\
    \        while let Some(elem) = it.next() {\n            res += if elem < capacity\
    \ {\n                elem\n            } else {\n                capacity\n  \
    \          };\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `9`,\n right: `5`', /tmp/tmpu57su5pu.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let n = grid.len();\n    let m = grid[0].len();\n   \
    \ let mut max_row = grid.iter().fold(0, |m, row| {\n        row.iter().sum::<isize>().max(m)\n\
    \    });\n    let mut count = 0;\n    while max_row > 0 {\n        count += max_row;\n\
    \        for row in &mut grid {\n            for i in 0..m {\n               \
    \ if row[i] > 0 {\n                    row[i] -= 1;\n                }\n     \
    \       }\n        }\n        max_row = grid.iter().fold(0, |m, row| {\n     \
    \       row.iter().sum::<isize>().max(m)\n        });\n    }\n    count\n}\n\n\
    fn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "warning: unused variable: `n`\n  --> /tmp/tmpiw_23z5q.rs:29:9\n   |\n29\
    \ |     let n = grid.len();\n   |         ^ help: if this is intentional, prefix\
    \ it with an underscore: `_n`\n   |\n   = note: `#[warn(unused_variables)]` on\
    \ by default\n\nwarning: unused variable: `capacity`\n  --> /tmp/tmpiw_23z5q.rs:28:36\n\
    \   |\n28 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n \
    \  |                                    ^^^^^^^^ help: if this is intentional,\
    \ prefix it with an underscore: `_capacity`\n\nerror[E0596]: cannot borrow `grid`\
    \ as mutable, as it is not declared as mutable\n  --> /tmp/tmpiw_23z5q.rs:37:20\n\
    \   |\n28 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n \
    \  |             ---- help: consider changing this to be mutable: `mut grid`\n\
    ...\n37 |         for row in &mut grid {\n   |                    ^^^^^^^^^ cannot\
    \ borrow as mutable\n\nerror: aborting due to previous error; 2 warnings emitted\n\
    \nFor more information about this error, try `rustc --explain E0596`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let rows = grid.len();\n    let cols = grid[0].len();\n\
    \    let mut total = 0;\n    for row in grid {\n        for col in row {\n   \
    \         total += col;\n        }\n    }\n    if total == 0 {\n        return\
    \ 0;\n    }\n    if total < capacity {\n        return total;\n    }\n    let\
    \ mut i = 0;\n    let mut j = 0;\n    let mut filled = 0;\n    let mut moves =\
    \ 0;\n    loop {\n        if i < rows {\n            if j < cols {\n         \
    \       if grid[i][j] == 1 {\n                    filled += 1;\n             \
    \       grid[i][j] = 0;\n                }\n                j += 1;\n        \
    \    } else {\n                i += 1;\n                j = 0;\n            }\n\
    \        } else {\n            i = 0;\n            j = 0;\n            moves +=\
    \ 1;\n            if filled == total {\n                break;\n            }\n\
    \            total -= filled;\n            filled = 0;\n        }\n    }\n   \
    \ moves\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `grid`\n   --> /tmp/tmptspbcmjz.rs:50:20\n\
    \    |\n28  | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n\
    \    |             ---- move occurs because `grid` has type `Vec<Vec<isize>>`,\
    \ which does not implement the `Copy` trait\n...\n32  |     for row in grid {\n\
    \    |                ---- `grid` moved due to this implicit call to `.into_iter()`\n\
    ...\n50  |                 if grid[i][j] == 1 {\n    |                    ^^^^\
    \ value borrowed here after move\n    |\nnote: this function takes ownership of\
    \ the receiver `self`, which moves `grid`\nhelp: consider iterating over a slice\
    \ of the `Vec<Vec<isize>>`'s content to avoid moving into the `for` loop\n   \
    \ |\n32  |     for row in &grid {\n    |                +\n\nerror[E0596]: cannot\
    \ borrow `grid` as mutable, as it is not declared as mutable\n  --> /tmp/tmptspbcmjz.rs:52:21\n\
    \   |\n28 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n \
    \  |             ---- help: consider changing this to be mutable: `mut grid`\n\
    ...\n52 |                     grid[i][j] = 0;\n   |                     ^^^^ cannot\
    \ borrow as mutable\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0382, E0596.\nFor more information about an error,\
    \ try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    // iterate column by column, to find the max water in\
    \ each well\n    let mut count = 0;\n    for j in 0..grid[0].len() {\n       \
    \ let mut sum = 0;\n        for i in 0..grid.len() {\n            sum += grid[i][j];\n\
    \            // when sum reaches the capacity,\n            // update the count,\
    \ and reset the sum to 0\n            if sum == capacity {\n                count\
    \ += 1;\n                sum = 0;\n            }\n        }\n        // if there\
    \ is still water left, empty the well\n        if sum > 0 {\n            count\
    \ += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `6`,\n right: `5`', /tmp/tmpas5h343q.rs:53:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut pile = 0;\n    let mut count = 0;\n    for row\
    \ in grid {\n        for well in row {\n            let fill = well + pile;\n\
    \            count += fill / capacity;\n            pile = fill % capacity;\n\
    \        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `5`', /tmp/tmp0y8i31gt.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let row_count = grid.len();\n    let col_count = grid[0].len();\n\
    \    let mut wells = vec![];\n    for i in 0..row_count {\n        let mut count\
    \ = 0;\n        for j in 0..col_count {\n            if grid[i][j] == 1 {\n  \
    \              count += 1;\n            }\n        }\n        wells.push(count);\n\
    \    }\n    let mut result = 0;\n    for w in wells {\n        let bucket_count\
    \ = w / capacity;\n        result += bucket_count;\n        if w % capacity !=\
    \ 0 {\n            result += 1;\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1,\
    \ 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    use std::cmp::min;\n    let mut grid = grid;\n    let\
    \ (rows, cols) = (grid.len(), grid[0].len());\n    let mut count = 0;\n    for\
    \ i in 0..rows {\n        for j in 0..cols {\n            if grid[i][j] == 1 {\n\
    \                grid[i][j] = 0;\n                count += 1;\n            }\n\
    \        }\n    }\n    // The naive approach to this problem is to try to fill\
    \ all buckets in a row\n    // one by one until they are full, then drop the buckets\
    \ and start over on the\n    // next row.\n    //\n    // This, however, is inefficient\
    \ as it is possible to fill a bucket in the\n    // next row without filling all\
    \ the buckets in the current row.\n    //\n    // While we have not found the\
    \ optimal solution, this algorithm will always\n    // find a solution that is\
    \ no worse than twice the optimal.\n    //\n    // The idea here is to use a priority\
    \ queue to order the buckets to be filled.\n    // Instead of filling from left\
    \ to right and top to bottom, we fill from\n    // the top left and move towards\
    \ the bottom right.\n    //\n    // A bucket's priority is the sum of the difference\
    \ between the current height\n    // and the optimal height of the bucket and\
    \ the current height and the optimal\n    // height of the bucket above it.\n\
    \    //\n    // We begin by emptying all of the buckets, adding them to the priority\
    \ queue\n    // and setting the heights to the capacity of a bucket.\n    //\n\
    \    // We then pop off a bucket and fill it. If it is full, we add the bucket\
    \ below\n    // to the priority queue. If not, we add the current bucket back\
    \ to the queue.\n    //\n    // We continue this process until all buckets have\
    \ been emptied.\n    //\n    // See the examples below for a better explanation\
    \ of how this works.\n    let mut pq = Heap::new();\n    for i in 0..rows {\n\
    \        for j in 0..cols {\n            pq.push(Cell {\n                row:\
    \ i,\n                col: j,\n                capacity: capacity,\n         \
    \       priority: rows as isize + cols as isize -\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpj4_wuscc.rs:85:3\n\
    \   |\n28 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n \
    \  |                                                              - unclosed delimiter\n\
    ...\n69 |     for i in 0..rows {\n   |                      - unclosed delimiter\n\
    70 |         for j in 0..cols {\n   |                          - unclosed delimiter\n\
    71 |             pq.push(Cell {\n   |                    - unclosed delimiter\n\
    ...\n85 | }\n   |   ^\n\nerror: expected expression, found `}`\n  --> /tmp/tmpj4_wuscc.rs:76:1\n\
    \   |\n71 |             pq.push(Cell {\n   |                     ---- while parsing\
    \ this struct\n...\n76 | }\n   | ^ expected expression\n\nerror: expected one\
    \ of `)`, `,`, `.`, `?`, or an operator, found keyword `fn`\n  --> /tmp/tmpj4_wuscc.rs:78:1\n\
    \   |\n76 | }\n   |  - expected one of `)`, `,`, `.`, `?`, or an operator\n77\
    \ | \n78 | fn main() {\n   | ^^ unexpected token\n\nerror: aborting due to 3 previous\
    \ errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    if grid.is_empty() || grid[0].is_empty() {\n        return\
    \ 0;\n    }\n    let h = grid.len();\n    let w = grid[0].len();\n    let mut\
    \ total = 0;\n    let mut level = 0;\n    let mut to_fill = 0;\n    loop {\n \
    \       let mut full = true;\n        for i in 0..h {\n            for j in 0..w\
    \ {\n                if grid[i][j] > level {\n                    full = false;\n\
    \                    to_fill += 1;\n                }\n            }\n       \
    \ }\n        if full {\n            break;\n        }\n        level += 1;\n \
    \       if to_fill > capacity {\n            total += 1;\n            to_fill\
    \ = 0;\n        }\n    }\n    total + (to_fill + capacity - 1) / capacity\n}\n\
    \nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `6`', /tmp/tmpyz986vfu.rs:61:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut result = 0;\n    for row in grid {\n        let\
    \ mut lowered = 0;\n        for &cell in &row {\n            let fill = cell -\
    \ lowered;\n            if fill > 0 {\n                lowered += fill;\n    \
    \            result += 1;\n            }\n            if lowered >= capacity {\n\
    \                lowered = capacity;\n                result += 1;\n         \
    \   }\n        }\n        if lowered > 0 {\n            result += 1;\n       \
    \ }\n    }\n    result\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `15`,\n right: `6`', /tmp/tmpz0g0enb2.rs:52:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut result = 0;\n    let m = grid.len();\n    let\
    \ n = grid[0].len();\n    for i in 0..m {\n        for j in 0..n {\n         \
    \   if grid[i][j] == 1 {\n                result += 1;\n            }\n      \
    \  }\n    }\n    let mut q = VecDeque::new();\n    for i in 0..m {\n        for\
    \ j in 0..n {\n            if grid[i][j] == 1 {\n                grid[i][j] =\
    \ -1;\n                q.push_back((i, j));\n                break;\n        \
    \    }\n        }\n    }\n    while !q.is_empty() {\n        let (x, y) = q.pop_front().unwrap();\n\
    \        let mut d = capacity;\n        while d > 0 {\n            d -= 1;\n \
    \           if x > 0 && grid[x - 1][y] == 1 {\n                q.push_back((x\
    \ - 1, y));\n                grid[x - 1][y] = -1;\n                result -= 1;\n\
    \            }\n            if x < m - 1 && grid[x + 1][y] == 1 {\n          \
    \      q.push_back((x + 1, y));\n                grid[x + 1][y] = -1;\n      \
    \          result -= 1;\n            }\n            if y > 0 && grid[x][y - 1]\
    \ == 1 {\n                q.push_back((x, y - 1));\n                grid[x][y\
    \ - 1] = -1;\n                result -= 1;\n            }\n            if y <\
    \ n - 1 && grid[x][y + 1] == 1 {\n                q.push_back((x, y + 1));\n \
    \               grid[x][y + 1] = -1;\n                result -= 1;\n         \
    \   }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `VecDeque`\n  -->\
    \ /tmp/tmprw36qgzh.rs:39:17\n   |\n39 |     let mut q = VecDeque::new();\n   |\
    \                 ^^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::VecDeque;\n   |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let m = grid.len();\n    let n = grid[0].len();\n   \
    \ let mut ret = 0;\n    let mut wells = vec![];\n    for i in 0..m {\n       \
    \ let mut sum = 0;\n        for j in 0..n {\n            sum += grid[i][j];\n\
    \        }\n        wells.push(sum);\n    }\n    for well in wells {\n       \
    \ let overflow = (well - capacity).max(0);\n        ret += overflow;\n       \
    \ capacity -= overflow;\n    }\n    ret\n}\n\nfn main() {\n    let candidate =\
    \ max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `capacity`\n  --> /tmp/tmpo20cic0t.rs:43:9\n\
    \   |\n28 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n \
    \  |                                    -------- help: consider making this binding\
    \ mutable: `mut capacity`\n...\n43 |         capacity -= overflow;\n   |     \
    \    ^^^^^^^^^^^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut ymax = 0;\n    let mut xmax = 0;\n    for row\
    \ in grid.iter() {\n        ymax = cmp::max(ymax, row.len());\n        for &x\
    \ in row.iter() {\n            xmax = cmp::max(xmax, x);\n        }\n    }\n \
    \   let grid_w = grid.len();\n    let mut fill_ct = 0;\n    for x in 0..xmax {\n\
    \        for y in 0..ymax {\n            if grid[y][x] == 1 {\n              \
    \  fill_ct += 1;\n            }\n        }\n    }\n    fill_ct\n}\n\nfn main()\
    \ {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1,\
    \ 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n\
    \  --> /tmp/tmpi46l8gc_.rs:32:16\n   |\n32 |         ymax = cmp::max(ymax, row.len());\n\
    \   |                ^^^ use of undeclared crate or module `cmp`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared crate or module `cmp`\n  --> /tmp/tmpi46l8gc_.rs:34:20\n\
    \   |\n34 |             xmax = cmp::max(xmax, x);\n   |                    ^^^\
    \ use of undeclared crate or module `cmp`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let row_size = grid.len();\n    let col_size = grid[0].len();\n\
    \    let mut count = 0;\n    for i in 0..row_size {\n        for j in 0..col_size\
    \ {\n            if grid[i][j] == 1 {\n                for k in 0..row_size {\n\
    \                    for l in 0..col_size {\n                        if grid[k][l]\
    \ == 1 {\n                            count += (1 + (i - k).abs() + (j - l).abs())\
    \ as isize;\n                        }\n                    }\n              \
    \  }\n            }\n        }\n    }\n    count / capacity\n}\n\nfn main() {\n\
    \    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0],\
    \ vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `abs` found for type `usize` in the current\
    \ scope\n  --> /tmp/tmpcgzmwoco.rs:38:51\n   |\n38 | ...                   count\
    \ += (1 + (i - k).abs() + (j - l).abs()) as isize;\n   |                     \
    \                        ^^^ method not found in `usize`\n\nerror[E0599]: no method\
    \ named `abs` found for type `usize` in the current scope\n  --> /tmp/tmpcgzmwoco.rs:38:67\n\
    \   |\n38 | ...                   count += (1 + (i - k).abs() + (j - l).abs())\
    \ as isize;\n   |                                                            \
    \ ^^^ method not found in `usize`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut wells = grid.len();\n    let mut min_fill = 0;\n\
    \    let mut max_fill = grid.iter().fold(0, |acc, row| acc + row.iter().sum::<isize>());\n\
    \    while min_fill <= max_fill {\n        let fill = (min_fill + max_fill) /\
    \ 2;\n        let mut filled = 0;\n        let mut refilled = 0;\n        for\
    \ row in grid.iter() {\n            filled += row.iter().sum::<isize>();\n   \
    \         if filled >= fill {\n                filled = fill;\n            } else\
    \ {\n                wells -= 1;\n                refilled += fill - filled;\n\
    \                filled = fill;\n            }\n            filled -= capacity;\n\
    \            if filled < 0 {\n                filled = 0;\n            }\n   \
    \     }\n        if wells == 0 {\n            if refilled == 0 {\n           \
    \     return fill;\n            }\n            min_fill = fill + 1;\n        }\
    \ else {\n            max_fill = fill - 1;\n        }\n    }\n    max_fill\n}\n\
    \nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-1`,\n right: `6`', /tmp/tmpf9p9cyow.rs:64:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut times = 0;\n    let width = grid[0].len();\n\
    \    let height = grid.len();\n    let mut i = 0;\n    while i < height {\n  \
    \      let mut filled = 0;\n        for j in 0..width {\n            if grid[i][j]\
    \ == 1 {\n                filled += 1;\n            }\n        }\n        if filled\
    \ > 0 {\n            let t = (filled - 1) / capacity + 1;\n            times +=\
    \ t;\n            i += t as usize;\n        } else {\n            i += 1;\n  \
    \      }\n    }\n    times\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `5`', /tmp/tmp58fznrcd.rs:54:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
