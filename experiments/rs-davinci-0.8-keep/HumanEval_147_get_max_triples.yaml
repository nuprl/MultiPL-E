name: HumanEval_147_get_max_triples
language: rs
prompt: "/// You are given a positive integer n. You have to create an integer array\
  \ a of length n.\n/// For each i (1 \u2264 i \u2264 n), the value of a[i] = i *\
  \ i - i + 1.\n/// Return the number of triples (a[i], a[j], a[k]) of a where i <\
  \ j < k, \n/// and a[i] + a[j] + a[k] is a multiple of 3.\n/// Example :\n/// Input:\
  \ n = 5\n/// Output: 1\n/// Explanation: \n/// a = [1, 3, 7, 13, 21]\n/// The only\
  \ valid triple is (1, 7, 13).\nfn get_max_triples(n: isize) -> isize {\n"
tests: "}\n\nfn main() {\n    let candidate = get_max_triples;\n    assert_eq!(candidate(5),\
  \ 1);\n    assert_eq!(candidate(6), 4);\n    assert_eq!(candidate(10), 36);\n  \
  \  assert_eq!(candidate(100), 53361);\n}\n"
completions: ["    if n < 3 { return 0; }\n    let mut sum = 0;\n    for i in 1..(n\
    \ - 1) {\n        let val = i * i - i + 1;\n        if val % 3 == 0 {\n      \
    \      sum += n - i - 1;\n        }\n    }\n    sum", "    // i < j < k\n    let\
    \ mut result = 0;\n    for i in 1..n {\n        for j in (i + 1)..n {\n      \
    \      for k in (j + 1)..n {\n                if (i * i - i + 1 + j * j - j +\
    \ 1 + k * k - k + 1) % 3 == 0 {\n                    result += 1;\n          \
    \      }\n            }\n        }\n    }\n    result", "    let mut count = 0;\n\
    \    let mut p1 = 1;\n    let mut p2 = 2;\n    let mut sum = 0;\n    while p1\
    \ < n - 1 {\n        p2 = p1 + 1;\n        while p2 < n {\n            sum = p1\
    \ + p2 + p2 + 1;\n            if sum % 3 == 0 {\n                count += 1;\n\
    \            }\n            p2 += 1;\n        }\n        p1 += 1;\n    }\n   \
    \ count", "    let mut answer = 0;\n    for i in 0..n - 2 {\n        for j in\
    \ i + 1..n - 1 {\n            for k in j + 1..n {\n                if (i * i -\
    \ i + 1 + j * j - j + 1 + k * k - k + 1) % 3 == 0 {\n                    answer\
    \ += 1;\n                }\n            }\n        }\n    }\n    answer", "  \
    \  let mut total = 0;\n    let mut left = 0;\n    let mut right = n - 1;\n   \
    \ let mut a = vec![0isize; n as usize];\n    // push numbers into vector\n   \
    \ for i in 0..n {\n        a[i as usize] = i * i - i + 1;\n    }\n    // 3 pointers\n\
    \    while left < right - 1 {\n        // check if a[left] + a[right] + a[right\
    \ - 1] is a multiple of 3\n        if (a[left as usize] + a[right as usize] +\
    \ a[(right - 1) as usize]) % 3 == 0 {\n            total += 1;\n            right\
    \ -= 1;\n        } else {\n            left += 1;\n        }\n    }\n    total",
  "    let mut count = 0;\n    for i in 1..n {\n        for j in (i + 1)..n {\n  \
    \          for k in (j + 1)..n {\n                if (i * i - i + 1 + j * j -\
    \ j + 1 + k * k - k + 1) % 3 == 0 {\n                    count += 1;\n       \
    \         }\n            }\n        }\n    }\n    count", "    let mut res = 0;\n\
    \    let mut sum = 0;\n    let mut a = vec![0; n as usize];\n    for i in 0..n\
    \ {\n        a[i as usize] = i * i - i + 1;\n    }\n    for i in 0..n - 2 {\n\
    \        sum = a[i as usize];\n        for j in i + 1..n - 1 {\n            sum\
    \ += a[j as usize];\n            for k in j + 1..n {\n                sum += a[k\
    \ as usize];\n                if sum % 3 == 0 {\n                    res += 1;\n\
    \                }\n                sum -= a[k as usize];\n            }\n   \
    \         sum -= a[j as usize];\n        }\n    }\n    res", "    let mut a =\
    \ vec![];\n    for i in 1..n+1 {\n        a.push(i*i - i + 1);\n    }\n    let\
    \ mut result = 0;\n    for i in 0..n-2 {\n        for j in i+1..n-1 {\n      \
    \      for k in j+1..n {\n                if a[i as usize] + a[j as usize] + a[k\
    \ as usize] % 3 == 0 {\n                    result += 1;\n                }\n\
    \            }\n        }\n    }\n    result", "    assert!(n > 0);\n    let mut\
    \ result = 0;\n    let array = (1..n+1).map(|i| i*i - i + 1).collect::<Vec<isize>>();\n\
    \    for i in 0..n-2 {\n        for j in i+1..n-1 {\n            for k in j+1..n\
    \ {\n                if (array[i] + array[j] + array[k]) % 3 == 0 {\n        \
    \            result += 1;\n                }\n            }\n        }\n    }\n\
    \    result", "    let mut count = 0;\n    for i in 1..n {\n        for j in i+1..n\
    \ {\n            let sum = i * i - i + 1 + j * j - j + 1;\n            let x =\
    \ ((sum as f64).sqrt() as isize) + 1;\n            if x * x - x + 1 < n && sum\
    \ % 3 == 0 {\n                count += 1;\n            }\n        }\n    }\n \
    \   count", "    let mut cnt = 0;\n    for i in 1..n {\n        for j in i + 1..n\
    \ {\n            for k in j + 1..n {\n                if ((i * i - i + 1) + (j\
    \ * j - j + 1) + (k * k - k + 1)) % 3 == 0 {\n                    cnt += 1;\n\
    \                }\n            }\n        }\n    }\n    cnt", "    let mut triples\
    \ = 0;\n    let mut a: Vec<isize> = Vec::new();\n    for i in 1..=n {\n      \
    \  a.push(i * i - i + 1);\n    }\n    for i in 0..n {\n        for j in (i + 1)..n\
    \ {\n            for k in (j + 1)..n {\n                if a[i] + a[j] + a[k]\
    \ % 3 == 0 {\n                    triples += 1;\n                }\n         \
    \   }\n        }\n    }\n    triples", "    if n < 3 {\n        return 0;\n  \
    \  }\n    let mut count = 0;\n    let mut a = 0;\n    let mut b = 1;\n    let\
    \ mut c = 2;\n    while c < n {\n        let s = a + b + c;\n        if s % 3\
    \ == 0 {\n            count += 1;\n        }\n        a += 1;\n        b += 1;\n\
    \        c += 1;\n    }\n    count", "    let mut count = 0;\n    for i in 1..n\
    \ {\n        for j in (i + 1)..n {\n            for k in (j + 1)..n {\n      \
    \          if (i * i - i + 1 + j * j - j + 1 + k * k - k + 1) % 3 == 0 {\n   \
    \                 count += 1;\n                }\n            }\n        }\n \
    \   }\n    count", "    let mut count = 0;\n    let mut prev_i = 0;\n    let mut\
    \ prev_j = 0;\n    for i in 1..n {\n        for j in i+1..n {\n            let\
    \ a_i = i * i - i + 1;\n            let a_j = j * j - j + 1;\n            let\
    \ a_k = n * n - n + 1;\n            if (a_i + a_j + a_k) % 3 == 0 {\n        \
    \        count += 1;\n            }\n        }\n    }\n    count", "    let mut\
    \ count = 0;\n    for i in 0..n {\n        for j in (i + 1)..n {\n           \
    \ for k in (j + 1)..n {\n                if ((i * i - i + 1) + (j * j - j + 1)\
    \ + (k * k - k + 1)) % 3 == 0 {\n                    count += 1;\n           \
    \     }\n            }\n        }\n    }\n    count", "    let mut triples = 0;\n\
    \    for i in 1..n {\n        for j in i+1..n {\n            for k in j+1..n {\n\
    \                if (i*i - i + 1 + j*j - j + 1 + k*k - k + 1) % 3 == 0 {\n   \
    \                 triples += 1;\n                }\n            }\n        }\n\
    \    }\n    triples", "    if n < 3 {\n        return 0;\n    }\n    let mut a\
    \ = vec![1];\n    for i in 1..n {\n        a.push(i * i - i + 1);\n    }\n   \
    \ let mut cnt = 0;\n    for i in 0..n {\n        for j in i + 1..n {\n       \
    \     for k in j + 1..n {\n                if (a[i] + a[j] + a[k]) % 3 == 0 {\n\
    \                    cnt += 1;\n                }\n            }\n        }\n\
    \    }\n    cnt", "    if n < 3 {\n        return 0;\n    }\n    let mut sum =\
    \ 0;\n    for i in 2..n {\n        sum += (i - 1) / 3;\n    }\n    sum", "   \
    \ let mut res = 0;\n    let mut a = Vec::with_capacity(n as usize);\n    let mut\
    \ v = 1;\n    for i in 1..=n {\n        a.push(v);\n        v += 2;\n    }\n \
    \   for i in 0..n {\n        for j in i+1..n {\n            for k in j+1..n {\n\
    \                if (a[i as usize] + a[j as usize] + a[k as usize]) % 3 == 0 {\n\
    \                    res += 1;\n                }\n            }\n        }\n\
    \    }\n    res"]
stop_tokens:
- "\n}"
