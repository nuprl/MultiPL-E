name: HumanEval_58_common
language: rs
prompt: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
  \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
  \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize>\
  \ {\n"
tests: "}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
  \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
  \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
  \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
  \ Vec::<isize>::new());\n}\n"
completions: ['  unimplemented!()', "    let mut l1 = l1;\n    let mut l2 = l2;\n\
    \    l1.sort();\n    l2.sort();\n    let mut res = Vec::new();\n    let mut i\
    \ = 0;\n    let mut j = 0;\n    while i < l1.len() && j < l2.len() {\n       \
    \ if l1[i] == l2[j] {\n            res.push(l1[i]);\n            i += 1;\n   \
    \         j += 1;\n        } else if l1[i] < l2[j] {\n            i += 1;\n  \
    \      } else {\n            j += 1;\n        }\n    }\n    res", "    let mut\
    \ s1 = l1.clone();\n    let mut s2 = l2.clone();\n    s1.sort();\n    s2.sort();\n\
    \    let mut set1 = s1.into_iter().collect::<HashSet<isize>>();\n    let mut set2\
    \ = s2.into_iter().collect::<HashSet<isize>>();\n    set1.retain(|&x| set2.contains(&x));\n\
    \    set1.into_iter().collect::<Vec<isize>>()", "    let mut result = Vec::new();\n\
    \    let mut set1 = l1.iter().collect::<HashSet<_>>();\n    let mut set2 = l2.iter().collect::<HashSet<_>>();\n\
    \    let mut iter1 = set1.drain();\n    while let Some(i) = iter1.next() {\n \
    \       if set2.contains(&i) {\n            result.push(i);\n        }\n    }\n\
    \    result.sort();\n    result", "    let m = HashMap::new();\n    let mut u1\
    \ = vec![];\n    let mut u2 = vec![];\n    let mut c = vec![];\n    for i in l1\
    \ {\n        m.insert(i, 0);\n    }\n    for i in l2 {\n        let mut a = m.entry(i).or_insert(0);\n\
    \        *a += 1;\n    }\n    for (k, v) in m {\n        if v == 2 {\n       \
    \     c.push(k);\n        }\n    }\n    c.sort();\n    c", '    unimplemented!()',
  '    unimplemented!();', "    // TODO\n    vec![]", "    let mut r: Vec<isize> =\
    \ Vec::new();\n    for x in l1 {\n        if l2.contains(&x) {\n            r.push(x);\n\
    \        }\n    }\n    r.sort();\n    r.dedup();\n    r", '    l1.into_iter().filter(|&x|
    l2.contains(&x)).collect()', "    let mut n1 = l1.clone();\n    let mut n2 = l2.clone();\n\
    \    n1.sort();\n    n2.sort();\n    n1.retain(|x| n2.contains(x));\n    n1.dedup();\n\
    \    n1", "    l1.into_iter().collect::<HashSet<isize>>()\n        .intersection(&l2.into_iter().collect::<HashSet<isize>>())\n\
    \        .cloned().collect::<Vec<isize>>()", "    let mut common = vec![];\n \
    \   for el in l1 {\n        if l2.contains(&el) {\n            common.push(el);\n\
    \        }\n    }\n    common.sort();\n    common.dedup();\n    common", "   \
    \ // TODO\n    unimplemented!()", "    let mut common_set: BTreeSet<isize> = BTreeSet::new();\n\
    \    let l1_set: BTreeSet<isize> = l1.into_iter().collect();\n    let l2_set:\
    \ BTreeSet<isize> = l2.into_iter().collect();\n    for &v in l1_set.intersection(&l2_set)\
    \ {\n        common_set.insert(v);\n    }\n    common_set.into_iter().collect()",
  "    // Use a set to get unique elements.\n    let mut set1: HashSet<isize> = HashSet::new();\n\
    \    for i in l1 {\n        set1.insert(i);\n    }\n    let mut set2: HashSet<isize>\
    \ = HashSet::new();\n    for i in l2 {\n        set2.insert(i);\n    }\n    //\
    \ Get intersection of the two sets (common elements).\n    let set_intersection:\
    \ HashSet<isize> = set1.intersection(&set2).cloned().collect();\n    // Return\
    \ a sorted list of the common elements.\n    let mut common_list: Vec<isize> =\
    \ set_intersection.into_iter().collect();\n    common_list.sort();\n    common_list",
  "    let mut result = Vec::new();\n    let (mut l1, mut l2) = (l1, l2);\n    l1.sort();\n\
    \    l2.sort();\n    l1.dedup();\n    l2.dedup();\n    let mut iter1 = l1.iter();\n\
    \    let mut iter2 = l2.iter();\n    let mut e1 = iter1.next();\n    let mut e2\
    \ = iter2.next();\n    while e1.is_some() && e2.is_some() {\n        if e1 ==\
    \ e2 {\n            result.push(*e1.unwrap());\n            e1 = iter1.next();\n\
    \            e2 = iter2.next();\n        } else if e1 < e2 {\n            e1 =\
    \ iter1.next();\n        } else {\n            e2 = iter2.next();\n        }\n\
    \    }\n    result", "    let set1: HashSet<isize> = l1.into_iter().collect();\n\
    \    let set2: HashSet<isize> = l2.into_iter().collect();\n    let mut ret: Vec<isize>\
    \ = set1.intersection(&set2).cloned().collect();\n    ret.sort();\n    ret", " \
    \   let mut res = Vec::new();\n    let mut l1_set = l1.iter().collect::<HashSet<_>>();\n\
    \    let mut l2_set = l2.iter().collect::<HashSet<_>>();\n    for i in l1_set.iter()\
    \ {\n        if l2_set.contains(i) {\n            res.push(*i);\n        }\n \
    \   }\n    res.sort();\n    res", "    let mut l1 = l1;\n    let mut l2 = l2;\n\
    \    l1.sort();\n    l2.sort();\n    l1.retain(|&x| l2.contains(&x));\n    l1.dedup();\n\
    \    l1"]
stop_tokens:
- "\n}"
