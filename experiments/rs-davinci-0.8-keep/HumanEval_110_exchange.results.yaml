name: HumanEval_110_exchange
language: rs
results:
- program: "/// In this problem, you will implement a function that takes two lists\
    \ of numbers,\n/// and determines whether it is possible to perform an exchange\
    \ of elements\n/// between them to make lst1 a list of only even numbers.\n///\
    \ There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    /// If it is possible to exchange elements between the lst1 and lst2 to make\n\
    /// all the elements of lst1 to be even, return \"YES\".\n/// Otherwise, return\
    \ \"NO\".\n/// For example:\n/// exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n/// exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n/// It is assumed that the\
    \ input lists will be non-empty.\nfn exchange(lst1: Vec<isize>, lst2: Vec<isize>)\
    \ -> String {\n    let mut lst1 = lst1;\n    let mut lst2 = lst2;\n    lst1.sort();\n\
    \    lst2.sort();\n    while lst1.len() > 0 && lst2.len() > 0 {\n        if lst1[0]\
    \ % 2 == 0 {\n            lst1.remove(0);\n        } else if lst2[0] % 2 == 0\
    \ {\n            lst1.remove(0);\n            lst2.remove(0);\n        } else\
    \ {\n            return \"NO\".to_string();\n        }\n    }\n    \"YES\".to_string()\n\
    }\n\nfn main() {\n    let candidate = exchange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4], vec![1, 2, 3, 4]), String::from(\"YES\"));\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4], vec![1, 5, 3, 4]), String::from(\"NO\"));\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4], vec![2, 1, 4, 3]), String::from(\"YES\"));\n    assert_eq!(candidate(vec![5,\
    \ 7, 3], vec![2, 6, 4]), String::from(\"YES\"));\n    assert_eq!(candidate(vec![5,\
    \ 7, 3], vec![2, 6, 3]), String::from(\"NO\"));\n    assert_eq!(candidate(vec![3,\
    \ 2, 6, 1, 8, 9], vec![3, 5, 5, 1, 1, 1]), String::from(\"NO\"));\n    assert_eq!(candidate(vec![100,\
    \ 200], vec![200, 200]), String::from(\"YES\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"NO\"`,\n right: `\"YES\"`', /tmp/tmp3t883b33.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// In this problem, you will implement a function that takes two lists\
    \ of numbers,\n/// and determines whether it is possible to perform an exchange\
    \ of elements\n/// between them to make lst1 a list of only even numbers.\n///\
    \ There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    /// If it is possible to exchange elements between the lst1 and lst2 to make\n\
    /// all the elements of lst1 to be even, return \"YES\".\n/// Otherwise, return\
    \ \"NO\".\n/// For example:\n/// exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n/// exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n/// It is assumed that the\
    \ input lists will be non-empty.\nfn exchange(lst1: Vec<isize>, lst2: Vec<isize>)\
    \ -> String {\n    let ones = lst1.iter().filter(|&x| x % 2 == 1).count();\n \
    \   let twos = lst2.iter().filter(|&x| x % 2 == 1).count();\n    if ones == twos\
    \ {\n        return \"YES\".to_string();\n    }\n    return \"NO\".to_string();\n\
    }\n\nfn main() {\n    let candidate = exchange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4], vec![1, 2, 3, 4]), String::from(\"YES\"));\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4], vec![1, 5, 3, 4]), String::from(\"NO\"));\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4], vec![2, 1, 4, 3]), String::from(\"YES\"));\n    assert_eq!(candidate(vec![5,\
    \ 7, 3], vec![2, 6, 4]), String::from(\"YES\"));\n    assert_eq!(candidate(vec![5,\
    \ 7, 3], vec![2, 6, 3]), String::from(\"NO\"));\n    assert_eq!(candidate(vec![3,\
    \ 2, 6, 1, 8, 9], vec![3, 5, 5, 1, 1, 1]), String::from(\"NO\"));\n    assert_eq!(candidate(vec![100,\
    \ 200], vec![200, 200]), String::from(\"YES\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"NO\"`,\n right: `\"YES\"`', /tmp/tmpdj1mtf97.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// In this problem, you will implement a function that takes two lists\
    \ of numbers,\n/// and determines whether it is possible to perform an exchange\
    \ of elements\n/// between them to make lst1 a list of only even numbers.\n///\
    \ There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    /// If it is possible to exchange elements between the lst1 and lst2 to make\n\
    /// all the elements of lst1 to be even, return \"YES\".\n/// Otherwise, return\
    \ \"NO\".\n/// For example:\n/// exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n/// exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n/// It is assumed that the\
    \ input lists will be non-empty.\nfn exchange(lst1: Vec<isize>, lst2: Vec<isize>)\
    \ -> String {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate = exchange;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4], vec![1, 2, 3, 4]), String::from(\"\
    YES\"));\n    assert_eq!(candidate(vec![1, 2, 3, 4], vec![1, 5, 3, 4]), String::from(\"\
    NO\"));\n    assert_eq!(candidate(vec![1, 2, 3, 4], vec![2, 1, 4, 3]), String::from(\"\
    YES\"));\n    assert_eq!(candidate(vec![5, 7, 3], vec![2, 6, 4]), String::from(\"\
    YES\"));\n    assert_eq!(candidate(vec![5, 7, 3], vec![2, 6, 3]), String::from(\"\
    NO\"));\n    assert_eq!(candidate(vec![3, 2, 6, 1, 8, 9], vec![3, 5, 5, 1, 1,\
    \ 1]), String::from(\"NO\"));\n    assert_eq!(candidate(vec![100, 200], vec![200,\
    \ 200]), String::from(\"YES\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpm7o5_ybh.rs:13:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// In this problem, you will implement a function that takes two lists\
    \ of numbers,\n/// and determines whether it is possible to perform an exchange\
    \ of elements\n/// between them to make lst1 a list of only even numbers.\n///\
    \ There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    /// If it is possible to exchange elements between the lst1 and lst2 to make\n\
    /// all the elements of lst1 to be even, return \"YES\".\n/// Otherwise, return\
    \ \"NO\".\n/// For example:\n/// exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n/// exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n/// It is assumed that the\
    \ input lists will be non-empty.\nfn exchange(lst1: Vec<isize>, lst2: Vec<isize>)\
    \ -> String {\n    let mut lst1 = lst1;\n    let mut lst2 = lst2;\n    for (i,\
    \ x) in lst1.iter().enumerate() {\n        if x % 2 != 0 {\n            if let\
    \ Some(y) = lst2.iter().find(|&&y| y % 2 == 0) {\n                lst1[i] = *y;\n\
    \                if let Some(index) = lst2.iter().position(|&x| x == *y) {\n \
    \                   lst2[index] = *x;\n                }\n            } else {\n\
    \                return \"NO\".to_string();\n            }\n        }\n    }\n\
    \    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate = exchange;\n  \
    \  assert_eq!(candidate(vec![1, 2, 3, 4], vec![1, 2, 3, 4]), String::from(\"YES\"\
    ));\n    assert_eq!(candidate(vec![1, 2, 3, 4], vec![1, 5, 3, 4]), String::from(\"\
    NO\"));\n    assert_eq!(candidate(vec![1, 2, 3, 4], vec![2, 1, 4, 3]), String::from(\"\
    YES\"));\n    assert_eq!(candidate(vec![5, 7, 3], vec![2, 6, 4]), String::from(\"\
    YES\"));\n    assert_eq!(candidate(vec![5, 7, 3], vec![2, 6, 3]), String::from(\"\
    NO\"));\n    assert_eq!(candidate(vec![3, 2, 6, 1, 8, 9], vec![3, 5, 5, 1, 1,\
    \ 1]), String::from(\"NO\"));\n    assert_eq!(candidate(vec![100, 200], vec![200,\
    \ 200]), String::from(\"YES\"));\n}\n"
  stdout: ''
  stderr: "error[E0502]: cannot borrow `lst1` as mutable because it is also borrowed\
    \ as immutable\n  --> /tmp/tmp0atpchxf.rs:18:17\n   |\n15 |     for (i, x) in\
    \ lst1.iter().enumerate() {\n   |                   -----------------------\n\
    \   |                   |\n   |                   immutable borrow occurs here\n\
    \   |                   immutable borrow later used here\n...\n18 |          \
    \       lst1[i] = *y;\n   |                 ^^^^ mutable borrow occurs here\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0502`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this problem, you will implement a function that takes two lists\
    \ of numbers,\n/// and determines whether it is possible to perform an exchange\
    \ of elements\n/// between them to make lst1 a list of only even numbers.\n///\
    \ There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    /// If it is possible to exchange elements between the lst1 and lst2 to make\n\
    /// all the elements of lst1 to be even, return \"YES\".\n/// Otherwise, return\
    \ \"NO\".\n/// For example:\n/// exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n/// exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n/// It is assumed that the\
    \ input lists will be non-empty.\nfn exchange(lst1: Vec<isize>, lst2: Vec<isize>)\
    \ -> String {\n    let mut lst1 = lst1;\n    let mut lst2 = lst2;\n    for item\
    \ in lst1.iter_mut() {\n        if *item % 2 == 1 {\n            let mut lst2_iter\
    \ = lst2.iter_mut();\n            let i = lst2_iter.position(|x| *x % 2 == 0);\n\
    \            if let Some(i) = i {\n                let el = lst2_iter.nth(i).unwrap();\n\
    \                mem::swap(item, el);\n            } else {\n                return\
    \ \"NO\".to_string();\n            }\n        }\n    }\n    \"YES\".to_string()\n\
    }\n\nfn main() {\n    let candidate = exchange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4], vec![1, 2, 3, 4]), String::from(\"YES\"));\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4], vec![1, 5, 3, 4]), String::from(\"NO\"));\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4], vec![2, 1, 4, 3]), String::from(\"YES\"));\n    assert_eq!(candidate(vec![5,\
    \ 7, 3], vec![2, 6, 4]), String::from(\"YES\"));\n    assert_eq!(candidate(vec![5,\
    \ 7, 3], vec![2, 6, 3]), String::from(\"NO\"));\n    assert_eq!(candidate(vec![3,\
    \ 2, 6, 1, 8, 9], vec![3, 5, 5, 1, 1, 1]), String::from(\"NO\"));\n    assert_eq!(candidate(vec![100,\
    \ 200], vec![200, 200]), String::from(\"YES\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `mem`\n\
    \  --> /tmp/tmpjxyzy199.rs:21:17\n   |\n21 |                 mem::swap(item, el);\n\
    \   |                 ^^^ use of undeclared crate or module `mem`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this problem, you will implement a function that takes two lists\
    \ of numbers,\n/// and determines whether it is possible to perform an exchange\
    \ of elements\n/// between them to make lst1 a list of only even numbers.\n///\
    \ There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    /// If it is possible to exchange elements between the lst1 and lst2 to make\n\
    /// all the elements of lst1 to be even, return \"YES\".\n/// Otherwise, return\
    \ \"NO\".\n/// For example:\n/// exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n/// exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n/// It is assumed that the\
    \ input lists will be non-empty.\nfn exchange(lst1: Vec<isize>, lst2: Vec<isize>)\
    \ -> String {\n    let mut odds = lst1.iter().filter(|&i| i % 2 != 0).count();\n\
    \    odds += lst2.iter().filter(|&i| i % 2 != 0).count();\n    odds % 2 == 0 ?\
    \ \"YES\".to_string() : \"NO\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = exchange;\n    assert_eq!(candidate(vec![1, 2, 3, 4], vec![1, 2, 3, 4]), String::from(\"\
    YES\"));\n    assert_eq!(candidate(vec![1, 2, 3, 4], vec![1, 5, 3, 4]), String::from(\"\
    NO\"));\n    assert_eq!(candidate(vec![1, 2, 3, 4], vec![2, 1, 4, 3]), String::from(\"\
    YES\"));\n    assert_eq!(candidate(vec![5, 7, 3], vec![2, 6, 4]), String::from(\"\
    YES\"));\n    assert_eq!(candidate(vec![5, 7, 3], vec![2, 6, 3]), String::from(\"\
    NO\"));\n    assert_eq!(candidate(vec![3, 2, 6, 1, 8, 9], vec![3, 5, 5, 1, 1,\
    \ 1]), String::from(\"NO\"));\n    assert_eq!(candidate(vec![100, 200], vec![200,\
    \ 200]), String::from(\"YES\"));\n}\n"
  stdout: ''
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `\"YES\"\
    `\n  --> /tmp/tmpbc_3haib.rs:15:21\n   |\n15 |     odds % 2 == 0 ? \"YES\".to_string()\
    \ : \"NO\".to_string()\n   |                     ^^^^^ expected one of `.`, `;`,\
    \ `?`, `}`, or an operator\n\nerror: aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this problem, you will implement a function that takes two lists\
    \ of numbers,\n/// and determines whether it is possible to perform an exchange\
    \ of elements\n/// between them to make lst1 a list of only even numbers.\n///\
    \ There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    /// If it is possible to exchange elements between the lst1 and lst2 to make\n\
    /// all the elements of lst1 to be even, return \"YES\".\n/// Otherwise, return\
    \ \"NO\".\n/// For example:\n/// exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n/// exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n/// It is assumed that the\
    \ input lists will be non-empty.\nfn exchange(lst1: Vec<isize>, lst2: Vec<isize>)\
    \ -> String {\n    let sum_lst1 = lst1.iter().sum::<isize>();\n    let sum_lst2\
    \ = lst2.iter().sum::<isize>();\n    if sum_lst1 % 2 == 0 && sum_lst2 % 2 == 0\
    \ {\n        \"YES\".to_string()\n    } else if sum_lst1 % 2 != 0 && sum_lst2\
    \ % 2 != 0 {\n        \"NO\".to_string()\n    } else {\n        let mut ex_list\
    \ = lst1.clone();\n        ex_list.append(&mut lst2.clone());\n        for i in\
    \ 0..ex_list.len() {\n            for j in i..ex_list.len() {\n              \
    \  if i != j && ex_list[i] % 2 != 0 && ex_list[j] % 2 != 0 {\n               \
    \     let tmp = ex_list[i];\n                    ex_list[i] = ex_list[j];\n  \
    \                  ex_list[j] = tmp;\n                }\n            }\n     \
    \   }\n        let sum_ex_list = ex_list.iter().sum::<isize>();\n        if sum_ex_list\
    \ % 2 == 0 {\n            \"YES\".to_string()\n        } else {\n            \"\
    NO\".to_string()\n        }\n    }\n}\n\nfn main() {\n    let candidate = exchange;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4], vec![1, 2, 3, 4]), String::from(\"\
    YES\"));\n    assert_eq!(candidate(vec![1, 2, 3, 4], vec![1, 5, 3, 4]), String::from(\"\
    NO\"));\n    assert_eq!(candidate(vec![1, 2, 3, 4], vec![2, 1, 4, 3]), String::from(\"\
    YES\"));\n    assert_eq!(candidate(vec![5, 7, 3], vec![2, 6, 4]), String::from(\"\
    YES\"));\n    assert_eq!(candidate(vec![5, 7, 3], vec![2, 6, 3]), String::from(\"\
    NO\"));\n    assert_eq!(candidate(vec![3, 2, 6, 1, 8, 9], vec![3, 5, 5, 1, 1,\
    \ 1]), String::from(\"NO\"));\n    assert_eq!(candidate(vec![100, 200], vec![200,\
    \ 200]), String::from(\"YES\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"NO\"`,\n right: `\"YES\"`', /tmp/tmpqnobtfnj.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// In this problem, you will implement a function that takes two lists\
    \ of numbers,\n/// and determines whether it is possible to perform an exchange\
    \ of elements\n/// between them to make lst1 a list of only even numbers.\n///\
    \ There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    /// If it is possible to exchange elements between the lst1 and lst2 to make\n\
    /// all the elements of lst1 to be even, return \"YES\".\n/// Otherwise, return\
    \ \"NO\".\n/// For example:\n/// exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n/// exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n/// It is assumed that the\
    \ input lists will be non-empty.\nfn exchange(lst1: Vec<isize>, lst2: Vec<isize>)\
    \ -> String {\n    match lst1.iter().find(|x| x % 2 != 0) {\n        Some(i) =>\
    \ match lst2.iter().find(|x| x % 2 == 0) {\n            Some(_) => \"YES\".to_string(),\n\
    \            None => \"NO\".to_string(),\n        },\n        None => \"YES\"\
    .to_string(),\n    }\n}\n\nfn main() {\n    let candidate = exchange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4], vec![1, 2, 3, 4]), String::from(\"YES\"));\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4], vec![1, 5, 3, 4]), String::from(\"NO\"));\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4], vec![2, 1, 4, 3]), String::from(\"YES\"));\n    assert_eq!(candidate(vec![5,\
    \ 7, 3], vec![2, 6, 4]), String::from(\"YES\"));\n    assert_eq!(candidate(vec![5,\
    \ 7, 3], vec![2, 6, 3]), String::from(\"NO\"));\n    assert_eq!(candidate(vec![3,\
    \ 2, 6, 1, 8, 9], vec![3, 5, 5, 1, 1, 1]), String::from(\"NO\"));\n    assert_eq!(candidate(vec![100,\
    \ 200], vec![200, 200]), String::from(\"YES\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot mod `&&isize` by `{integer}`\n  --> /tmp/tmpm2jb7491.rs:13:34\n\
    \   |\n13 |     match lst1.iter().find(|x| x % 2 != 0) {\n   |               \
    \                 - ^ - {integer}\n   |                                |\n   |\
    \                                &&isize\n   |\nhelp: `%` can be used on `isize`,\
    \ you can dereference `x`\n   |\n13 |     match lst1.iter().find(|x| *x % 2 !=\
    \ 0) {\n   |                                +\n\nerror[E0369]: cannot mod `&&isize`\
    \ by `{integer}`\n  --> /tmp/tmpm2jb7491.rs:14:49\n   |\n14 |         Some(i)\
    \ => match lst2.iter().find(|x| x % 2 == 0) {\n   |                          \
    \                     - ^ - {integer}\n   |                                  \
    \             |\n   |                                               &&isize\n\
    \   |\nhelp: `%` can be used on `isize`, you can dereference `x`\n   |\n14 | \
    \        Some(i) => match lst2.iter().find(|x| *x % 2 == 0) {\n   |          \
    \                                     +\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// In this problem, you will implement a function that takes two lists\
    \ of numbers,\n/// and determines whether it is possible to perform an exchange\
    \ of elements\n/// between them to make lst1 a list of only even numbers.\n///\
    \ There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    /// If it is possible to exchange elements between the lst1 and lst2 to make\n\
    /// all the elements of lst1 to be even, return \"YES\".\n/// Otherwise, return\
    \ \"NO\".\n/// For example:\n/// exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n/// exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n/// It is assumed that the\
    \ input lists will be non-empty.\nfn exchange(lst1: Vec<isize>, lst2: Vec<isize>)\
    \ -> String {\n    let odds_count = |lst: &Vec<isize>| -> usize {\n        lst.iter().filter(|&&x|\
    \ x % 2 != 0).count()\n    };\n    if odds_count(&lst1) % 2 == 0 && odds_count(&lst2)\
    \ % 2 == 0 {\n        return \"YES\".to_string();\n    }\n    \"NO\".to_string()\n\
    }\n\nfn main() {\n    let candidate = exchange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4], vec![1, 2, 3, 4]), String::from(\"YES\"));\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4], vec![1, 5, 3, 4]), String::from(\"NO\"));\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4], vec![2, 1, 4, 3]), String::from(\"YES\"));\n    assert_eq!(candidate(vec![5,\
    \ 7, 3], vec![2, 6, 4]), String::from(\"YES\"));\n    assert_eq!(candidate(vec![5,\
    \ 7, 3], vec![2, 6, 3]), String::from(\"NO\"));\n    assert_eq!(candidate(vec![3,\
    \ 2, 6, 1, 8, 9], vec![3, 5, 5, 1, 1, 1]), String::from(\"NO\"));\n    assert_eq!(candidate(vec![100,\
    \ 200], vec![200, 200]), String::from(\"YES\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"NO\"`,\n right: `\"YES\"`', /tmp/tmp30uvqpae.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// In this problem, you will implement a function that takes two lists\
    \ of numbers,\n/// and determines whether it is possible to perform an exchange\
    \ of elements\n/// between them to make lst1 a list of only even numbers.\n///\
    \ There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    /// If it is possible to exchange elements between the lst1 and lst2 to make\n\
    /// all the elements of lst1 to be even, return \"YES\".\n/// Otherwise, return\
    \ \"NO\".\n/// For example:\n/// exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n/// exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n/// It is assumed that the\
    \ input lists will be non-empty.\nfn exchange(lst1: Vec<isize>, lst2: Vec<isize>)\
    \ -> String {\n    let odd_count = lst1.iter().filter(|&x| x % 2 != 0).count();\n\
    \    if odd_count % 2 == 0 {\n        \"YES\".to_string()\n    } else {\n    \
    \    \"NO\".to_string()\n    }\n}\n\nfn main() {\n    let candidate = exchange;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4], vec![1, 2, 3, 4]), String::from(\"\
    YES\"));\n    assert_eq!(candidate(vec![1, 2, 3, 4], vec![1, 5, 3, 4]), String::from(\"\
    NO\"));\n    assert_eq!(candidate(vec![1, 2, 3, 4], vec![2, 1, 4, 3]), String::from(\"\
    YES\"));\n    assert_eq!(candidate(vec![5, 7, 3], vec![2, 6, 4]), String::from(\"\
    YES\"));\n    assert_eq!(candidate(vec![5, 7, 3], vec![2, 6, 3]), String::from(\"\
    NO\"));\n    assert_eq!(candidate(vec![3, 2, 6, 1, 8, 9], vec![3, 5, 5, 1, 1,\
    \ 1]), String::from(\"NO\"));\n    assert_eq!(candidate(vec![100, 200], vec![200,\
    \ 200]), String::from(\"YES\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp0ttgrbf7.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// In this problem, you will implement a function that takes two lists\
    \ of numbers,\n/// and determines whether it is possible to perform an exchange\
    \ of elements\n/// between them to make lst1 a list of only even numbers.\n///\
    \ There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    /// If it is possible to exchange elements between the lst1 and lst2 to make\n\
    /// all the elements of lst1 to be even, return \"YES\".\n/// Otherwise, return\
    \ \"NO\".\n/// For example:\n/// exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n/// exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n/// It is assumed that the\
    \ input lists will be non-empty.\nfn exchange(lst1: Vec<isize>, lst2: Vec<isize>)\
    \ -> String {\n    let lst1_len = lst1.len();\n    let lst2_len = lst2.len();\n\
    \    let mut even_count = 0;\n    let mut odd_count = 0;\n    for i in 0..lst1_len\
    \ {\n        if lst1[i] % 2 == 0 {\n            even_count += 1;\n        } else\
    \ {\n            odd_count += 1;\n        }\n    }\n    for i in 0..lst2_len {\n\
    \        if lst2[i] % 2 == 0 {\n            even_count += 1;\n        } else {\n\
    \            odd_count += 1;\n        }\n    }\n    if even_count >= lst1_len\
    \ {\n        return \"YES\".to_string();\n    } else {\n        return \"NO\"\
    .to_string();\n    }\n}\n\nfn main() {\n    let candidate = exchange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4], vec![1, 2, 3, 4]), String::from(\"YES\"));\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4], vec![1, 5, 3, 4]), String::from(\"NO\"));\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4], vec![2, 1, 4, 3]), String::from(\"YES\"));\n    assert_eq!(candidate(vec![5,\
    \ 7, 3], vec![2, 6, 4]), String::from(\"YES\"));\n    assert_eq!(candidate(vec![5,\
    \ 7, 3], vec![2, 6, 3]), String::from(\"NO\"));\n    assert_eq!(candidate(vec![3,\
    \ 2, 6, 1, 8, 9], vec![3, 5, 5, 1, 1, 1]), String::from(\"NO\"));\n    assert_eq!(candidate(vec![100,\
    \ 200], vec![200, 200]), String::from(\"YES\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// In this problem, you will implement a function that takes two lists\
    \ of numbers,\n/// and determines whether it is possible to perform an exchange\
    \ of elements\n/// between them to make lst1 a list of only even numbers.\n///\
    \ There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    /// If it is possible to exchange elements between the lst1 and lst2 to make\n\
    /// all the elements of lst1 to be even, return \"YES\".\n/// Otherwise, return\
    \ \"NO\".\n/// For example:\n/// exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n/// exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n/// It is assumed that the\
    \ input lists will be non-empty.\nfn exchange(lst1: Vec<isize>, lst2: Vec<isize>)\
    \ -> String {\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate =\
    \ exchange;\n    assert_eq!(candidate(vec![1, 2, 3, 4], vec![1, 2, 3, 4]), String::from(\"\
    YES\"));\n    assert_eq!(candidate(vec![1, 2, 3, 4], vec![1, 5, 3, 4]), String::from(\"\
    NO\"));\n    assert_eq!(candidate(vec![1, 2, 3, 4], vec![2, 1, 4, 3]), String::from(\"\
    YES\"));\n    assert_eq!(candidate(vec![5, 7, 3], vec![2, 6, 4]), String::from(\"\
    YES\"));\n    assert_eq!(candidate(vec![5, 7, 3], vec![2, 6, 3]), String::from(\"\
    NO\"));\n    assert_eq!(candidate(vec![3, 2, 6, 1, 8, 9], vec![3, 5, 5, 1, 1,\
    \ 1]), String::from(\"NO\"));\n    assert_eq!(candidate(vec![100, 200], vec![200,\
    \ 200]), String::from(\"YES\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp3mzln53r.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// In this problem, you will implement a function that takes two lists\
    \ of numbers,\n/// and determines whether it is possible to perform an exchange\
    \ of elements\n/// between them to make lst1 a list of only even numbers.\n///\
    \ There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    /// If it is possible to exchange elements between the lst1 and lst2 to make\n\
    /// all the elements of lst1 to be even, return \"YES\".\n/// Otherwise, return\
    \ \"NO\".\n/// For example:\n/// exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n/// exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n/// It is assumed that the\
    \ input lists will be non-empty.\nfn exchange(lst1: Vec<isize>, lst2: Vec<isize>)\
    \ -> String {\n    let mut evens = 0;\n    let mut odds = 0;\n    for i in lst1\
    \ {\n        if i % 2 == 0 {\n            evens += 1;\n        } else {\n    \
    \        odds += 1;\n        }\n    }\n    for i in lst2 {\n        if i % 2 ==\
    \ 0 {\n            evens += 1;\n        } else {\n            odds += 1;\n   \
    \     }\n    }\n    if evens >= odds {\n        \"YES\".to_string()\n    } else\
    \ {\n        \"NO\".to_string()\n    }\n}\n\nfn main() {\n    let candidate =\
    \ exchange;\n    assert_eq!(candidate(vec![1, 2, 3, 4], vec![1, 2, 3, 4]), String::from(\"\
    YES\"));\n    assert_eq!(candidate(vec![1, 2, 3, 4], vec![1, 5, 3, 4]), String::from(\"\
    NO\"));\n    assert_eq!(candidate(vec![1, 2, 3, 4], vec![2, 1, 4, 3]), String::from(\"\
    YES\"));\n    assert_eq!(candidate(vec![5, 7, 3], vec![2, 6, 4]), String::from(\"\
    YES\"));\n    assert_eq!(candidate(vec![5, 7, 3], vec![2, 6, 3]), String::from(\"\
    NO\"));\n    assert_eq!(candidate(vec![3, 2, 6, 1, 8, 9], vec![3, 5, 5, 1, 1,\
    \ 1]), String::from(\"NO\"));\n    assert_eq!(candidate(vec![100, 200], vec![200,\
    \ 200]), String::from(\"YES\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// In this problem, you will implement a function that takes two lists\
    \ of numbers,\n/// and determines whether it is possible to perform an exchange\
    \ of elements\n/// between them to make lst1 a list of only even numbers.\n///\
    \ There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    /// If it is possible to exchange elements between the lst1 and lst2 to make\n\
    /// all the elements of lst1 to be even, return \"YES\".\n/// Otherwise, return\
    \ \"NO\".\n/// For example:\n/// exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n/// exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n/// It is assumed that the\
    \ input lists will be non-empty.\nfn exchange(lst1: Vec<isize>, lst2: Vec<isize>)\
    \ -> String {\n    let mut v1 = lst1;\n    let mut v2 = lst2;\n    let mut i =\
    \ 0;\n    let mut k = 0;\n    let mut j = 0;\n    let mut e = true;\n    while\
    \ i < v1.len() {\n        if v1[i] % 2 != 0 {\n            e = false;\n      \
    \      break;\n        }\n        i += 1;\n    }\n    if e {\n        return \"\
    YES\".to_string();\n    }\n    while j < v2.len() {\n        if v2[j] % 2 == 0\
    \ {\n            k += 1;\n        }\n        j += 1;\n    }\n    if k == 0 {\n\
    \        return \"NO\".to_string();\n    }\n    if v1.len() > v2.len() {\n   \
    \     for i in 0..v1.len() {\n            for j in 0..v2.len() {\n           \
    \     if v1[i] % 2 != 0 && v2[j] % 2 == 0 {\n                    v1[i] = v2[j];\n\
    \                    v2[j] = v1[i];\n                    i = 0;\n            \
    \        j = 0;\n                }\n            }\n        }\n    } else {\n \
    \       for i in 0..v2.len() {\n            for j in 0..v1.len() {\n         \
    \       if v2[i] % 2 != 0 && v1[j] % 2 == 0 {\n                    v2[i] = v1[j];\n\
    \                    v1[j] = v2[i];\n                    i = 0;\n            \
    \        j = 0;\n                }\n            }\n        }\n    }\n    e = true;\n\
    \    i = 0;\n    while i < v1.len() {\n        if v1[i] % 2 != 0 {\n         \
    \   e = false;\n            break;\n        }\n        i += 1;\n    }\n    if\
    \ e {\n        return \"YES\".to_string();\n    }\n    return \"NO\".to_string();\n\
    }\n\nfn main() {\n    let candidate = exchange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4], vec![1, 2, 3, 4]), String::from(\"YES\"));\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4], vec![1, 5, 3, 4]), String::from(\"NO\"));\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4], vec![2, 1, 4, 3]), String::from(\"YES\"));\n    assert_eq!(candidate(vec![5,\
    \ 7, 3], vec![2, 6, 4]), String::from(\"YES\"));\n    assert_eq!(candidate(vec![5,\
    \ 7, 3], vec![2, 6, 3]), String::from(\"NO\"));\n    assert_eq!(candidate(vec![3,\
    \ 2, 6, 1, 8, 9], vec![3, 5, 5, 1, 1, 1]), String::from(\"NO\"));\n    assert_eq!(candidate(vec![100,\
    \ 200], vec![200, 200]), String::from(\"YES\"));\n}\n"
  stdout: ''
  stderr: "warning: value assigned to `j` is never read\n  --> /tmp/tmp884wktj8.rs:45:21\n\
    \   |\n45 |                     j = 0;\n   |                     ^\n   |\n   =\
    \ note: `#[warn(unused_assignments)]` on by default\n   = help: maybe it is overwritten\
    \ before being read?\n\nwarning: value assigned to `j` is never read\n  --> /tmp/tmp884wktj8.rs:56:21\n\
    \   |\n56 |                     j = 0;\n   |                     ^\n   |\n   =\
    \ help: maybe it is overwritten before being read?\n\nerror[E0384]: cannot assign\
    \ twice to immutable variable `i`\n  --> /tmp/tmp884wktj8.rs:44:21\n   |\n39 |\
    \         for i in 0..v1.len() {\n   |             -\n   |             |\n   |\
    \             first assignment to `i`\n   |             help: consider making\
    \ this binding mutable: `mut i`\n...\n44 |                     i = 0;\n   |  \
    \                   ^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]:\
    \ cannot assign twice to immutable variable `j`\n  --> /tmp/tmp884wktj8.rs:45:21\n\
    \   |\n40 |             for j in 0..v2.len() {\n   |                 -\n   | \
    \                |\n   |                 first assignment to `j`\n   |       \
    \          help: consider making this binding mutable: `mut j`\n...\n45 |    \
    \                 j = 0;\n   |                     ^^^^^ cannot assign twice to\
    \ immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable\
    \ `i`\n  --> /tmp/tmp884wktj8.rs:55:21\n   |\n50 |         for i in 0..v2.len()\
    \ {\n   |             -\n   |             |\n   |             first assignment\
    \ to `i`\n   |             help: consider making this binding mutable: `mut i`\n\
    ...\n55 |                     i = 0;\n   |                     ^^^^^ cannot assign\
    \ twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable\
    \ variable `j`\n  --> /tmp/tmp884wktj8.rs:56:21\n   |\n51 |             for j\
    \ in 0..v1.len() {\n   |                 -\n   |                 |\n   |     \
    \            first assignment to `j`\n   |                 help: consider making\
    \ this binding mutable: `mut j`\n...\n56 |                     j = 0;\n   |  \
    \                   ^^^^^ cannot assign twice to immutab"
  exit_code: 1
  status: SyntaxError
- program: "/// In this problem, you will implement a function that takes two lists\
    \ of numbers,\n/// and determines whether it is possible to perform an exchange\
    \ of elements\n/// between them to make lst1 a list of only even numbers.\n///\
    \ There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    /// If it is possible to exchange elements between the lst1 and lst2 to make\n\
    /// all the elements of lst1 to be even, return \"YES\".\n/// Otherwise, return\
    \ \"NO\".\n/// For example:\n/// exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n/// exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n/// It is assumed that the\
    \ input lists will be non-empty.\nfn exchange(lst1: Vec<isize>, lst2: Vec<isize>)\
    \ -> String {\n    for n in lst1 {\n        if n % 2 != 0 {\n            if !lst2.contains(&n)\
    \ {\n                return \"NO\".to_string();\n            }\n        }\n  \
    \  }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate = exchange;\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4], vec![1, 2, 3, 4]), String::from(\"\
    YES\"));\n    assert_eq!(candidate(vec![1, 2, 3, 4], vec![1, 5, 3, 4]), String::from(\"\
    NO\"));\n    assert_eq!(candidate(vec![1, 2, 3, 4], vec![2, 1, 4, 3]), String::from(\"\
    YES\"));\n    assert_eq!(candidate(vec![5, 7, 3], vec![2, 6, 4]), String::from(\"\
    YES\"));\n    assert_eq!(candidate(vec![5, 7, 3], vec![2, 6, 3]), String::from(\"\
    NO\"));\n    assert_eq!(candidate(vec![3, 2, 6, 1, 8, 9], vec![3, 5, 5, 1, 1,\
    \ 1]), String::from(\"NO\"));\n    assert_eq!(candidate(vec![100, 200], vec![200,\
    \ 200]), String::from(\"YES\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpc7grv5tr.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// In this problem, you will implement a function that takes two lists\
    \ of numbers,\n/// and determines whether it is possible to perform an exchange\
    \ of elements\n/// between them to make lst1 a list of only even numbers.\n///\
    \ There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    /// If it is possible to exchange elements between the lst1 and lst2 to make\n\
    /// all the elements of lst1 to be even, return \"YES\".\n/// Otherwise, return\
    \ \"NO\".\n/// For example:\n/// exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n/// exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n/// It is assumed that the\
    \ input lists will be non-empty.\nfn exchange(lst1: Vec<isize>, lst2: Vec<isize>)\
    \ -> String {\n    let mut even_nums: Vec<isize> = lst1.iter().filter(|&x| x %\
    \ 2 == 0).map(|x| *x).collect();\n    let mut odd_nums: Vec<isize> = lst2.iter().filter(|&x|\
    \ x % 2 != 0).map(|x| *x).collect();\n    let mut res = \"YES\";\n    if even_nums.len()\
    \ != lst1.len() {\n        res = \"NO\";\n    }\n    if odd_nums.len() != lst2.len()\
    \ {\n        res = \"NO\";\n    }\n    res.to_string()\n}\n\nfn main() {\n   \
    \ let candidate = exchange;\n    assert_eq!(candidate(vec![1, 2, 3, 4], vec![1,\
    \ 2, 3, 4]), String::from(\"YES\"));\n    assert_eq!(candidate(vec![1, 2, 3, 4],\
    \ vec![1, 5, 3, 4]), String::from(\"NO\"));\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4], vec![2, 1, 4, 3]), String::from(\"YES\"));\n    assert_eq!(candidate(vec![5,\
    \ 7, 3], vec![2, 6, 4]), String::from(\"YES\"));\n    assert_eq!(candidate(vec![5,\
    \ 7, 3], vec![2, 6, 3]), String::from(\"NO\"));\n    assert_eq!(candidate(vec![3,\
    \ 2, 6, 1, 8, 9], vec![3, 5, 5, 1, 1, 1]), String::from(\"NO\"));\n    assert_eq!(candidate(vec![100,\
    \ 200], vec![200, 200]), String::from(\"YES\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"NO\"`,\n right: `\"YES\"`', /tmp/tmp1h35gssf.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// In this problem, you will implement a function that takes two lists\
    \ of numbers,\n/// and determines whether it is possible to perform an exchange\
    \ of elements\n/// between them to make lst1 a list of only even numbers.\n///\
    \ There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    /// If it is possible to exchange elements between the lst1 and lst2 to make\n\
    /// all the elements of lst1 to be even, return \"YES\".\n/// Otherwise, return\
    \ \"NO\".\n/// For example:\n/// exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n/// exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n/// It is assumed that the\
    \ input lists will be non-empty.\nfn exchange(lst1: Vec<isize>, lst2: Vec<isize>)\
    \ -> String {\n    let is_odd = |x: &isize| -> bool { x % 2 != 0 };\n    let evens_in_lst1\
    \ = lst1.iter().filter(is_odd).count();\n    let odds_in_lst2 = lst2.iter().filter(is_odd).count();\n\
    \    if evens_in_lst1 <= odds_in_lst2 {\n        \"YES\".to_string()\n    } else\
    \ {\n        \"NO\".to_string()\n    }\n}\n\nfn main() {\n    let candidate =\
    \ exchange;\n    assert_eq!(candidate(vec![1, 2, 3, 4], vec![1, 2, 3, 4]), String::from(\"\
    YES\"));\n    assert_eq!(candidate(vec![1, 2, 3, 4], vec![1, 5, 3, 4]), String::from(\"\
    NO\"));\n    assert_eq!(candidate(vec![1, 2, 3, 4], vec![2, 1, 4, 3]), String::from(\"\
    YES\"));\n    assert_eq!(candidate(vec![5, 7, 3], vec![2, 6, 4]), String::from(\"\
    YES\"));\n    assert_eq!(candidate(vec![5, 7, 3], vec![2, 6, 3]), String::from(\"\
    NO\"));\n    assert_eq!(candidate(vec![3, 2, 6, 1, 8, 9], vec![3, 5, 5, 1, 1,\
    \ 1]), String::from(\"NO\"));\n    assert_eq!(candidate(vec![100, 200], vec![200,\
    \ 200]), String::from(\"YES\"));\n}\n"
  stdout: ''
  stderr: "error[E0631]: type mismatch in closure arguments\n   --> /tmp/tmph8v1n_7b.rs:14:44\n\
    \    |\n13  |     let is_odd = |x: &isize| -> bool { x % 2 != 0 };\n    |    \
    \              ------------------- found signature of `for<'r> fn(&'r isize) ->\
    \ _`\n14  |     let evens_in_lst1 = lst1.iter().filter(is_odd).count();\n    |\
    \                                     ------ ^^^^^^ expected signature of `for<'r>\
    \ fn(&'r &isize) -> _`\n    |                                     |\n    |   \
    \                                  required by a bound introduced by this call\n\
    \    |\nnote: required by a bound in `filter`\n\nerror[E0599]: the method `count`\
    \ exists for struct `Filter<std::slice::Iter<'_, isize>, [closure@/tmp/tmph8v1n_7b.rs:13:18:\
    \ 13:52]>`, but its trait bounds were not satisfied\n  --> /tmp/tmph8v1n_7b.rs:14:52\n\
    \   |\n13 |       let is_odd = |x: &isize| -> bool { x % 2 != 0 };\n   |     \
    \               -------------------\n   |                    |\n   |         \
    \           doesn't satisfy `<_ as FnOnce<(&&isize,)>>::Output = bool`\n   | \
    \                   doesn't satisfy `_: FnMut<(&&isize,)>`\n14 |       let evens_in_lst1\
    \ = lst1.iter().filter(is_odd).count();\n   |                                \
    \                      ^^^^^ method cannot be called on `Filter<std::slice::Iter<'_,\
    \ isize>, [closure@/tmp/tmph8v1n_7b.rs:13:18: 13:52]>` due to unsatisfied trait\
    \ bounds\n   |\n   = note: the following trait bounds were not satisfied:\n  \
    \         `<[closure@/tmp/tmph8v1n_7b.rs:13:18: 13:52] as FnOnce<(&&isize,)>>::Output\
    \ = bool`\n           which is required by `Filter<std::slice::Iter<'_, isize>,\
    \ [closure@/tmp/tmph8v1n_7b.rs:13:18: 13:52]>: Iterator`\n           `[closure@/tmp/tmph8v1n_7b.rs:13:18:\
    \ 13:52]: FnMut<(&&isize,)>`\n           which is required by `Filter<std::slice::Iter<'_,\
    \ isize>, [closure@/tmp/tmph8v1n_7b.rs:13:18: 13:52]>: Iterator`\n           `Filter<std::slice::Iter<'_,\
    \ isize>, [closure@/tmp/tmph8v1n_7b.rs:13:18: 13:52]>: Iterator`\n           which\
    \ is required by `&mut Filter<std::slice::Iter<'_, isize>, [closure@/tmp/tmph8v1n_7b.rs:13:18:\
    \ 13:52]>:"
  exit_code: 1
  status: SyntaxError
- program: "/// In this problem, you will implement a function that takes two lists\
    \ of numbers,\n/// and determines whether it is possible to perform an exchange\
    \ of elements\n/// between them to make lst1 a list of only even numbers.\n///\
    \ There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    /// If it is possible to exchange elements between the lst1 and lst2 to make\n\
    /// all the elements of lst1 to be even, return \"YES\".\n/// Otherwise, return\
    \ \"NO\".\n/// For example:\n/// exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n/// exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n/// It is assumed that the\
    \ input lists will be non-empty.\nfn exchange(lst1: Vec<isize>, lst2: Vec<isize>)\
    \ -> String {\n    if lst1.iter().filter(|&&x| x % 2 == 1).count() == 0 {\n  \
    \      return \"YES\".to_string();\n    }\n    if lst2.iter().filter(|&&x| x %\
    \ 2 == 1).count() == 0 {\n        return \"YES\".to_string();\n    }\n    if lst1.iter().filter(|&&x|\
    \ x % 2 == 1).count() == lst2.iter().filter(|&&x| x % 2 == 1).count() {\n    \
    \    return \"YES\".to_string();\n    }\n    \"NO\".to_string()\n}\n\nfn main()\
    \ {\n    let candidate = exchange;\n    assert_eq!(candidate(vec![1, 2, 3, 4],\
    \ vec![1, 2, 3, 4]), String::from(\"YES\"));\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4], vec![1, 5, 3, 4]), String::from(\"NO\"));\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4], vec![2, 1, 4, 3]), String::from(\"YES\"));\n    assert_eq!(candidate(vec![5,\
    \ 7, 3], vec![2, 6, 4]), String::from(\"YES\"));\n    assert_eq!(candidate(vec![5,\
    \ 7, 3], vec![2, 6, 3]), String::from(\"NO\"));\n    assert_eq!(candidate(vec![3,\
    \ 2, 6, 1, 8, 9], vec![3, 5, 5, 1, 1, 1]), String::from(\"NO\"));\n    assert_eq!(candidate(vec![100,\
    \ 200], vec![200, 200]), String::from(\"YES\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// In this problem, you will implement a function that takes two lists\
    \ of numbers,\n/// and determines whether it is possible to perform an exchange\
    \ of elements\n/// between them to make lst1 a list of only even numbers.\n///\
    \ There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    /// If it is possible to exchange elements between the lst1 and lst2 to make\n\
    /// all the elements of lst1 to be even, return \"YES\".\n/// Otherwise, return\
    \ \"NO\".\n/// For example:\n/// exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n/// exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n/// It is assumed that the\
    \ input lists will be non-empty.\nfn exchange(lst1: Vec<isize>, lst2: Vec<isize>)\
    \ -> String {\n    let lst1_odds = lst1.iter().filter(|x| **x % 2 != 0).count();\n\
    \    let lst2_odds = lst2.iter().filter(|x| **x % 2 != 0).count();\n    if lst1_odds\
    \ > lst2_odds {\n        \"NO\".to_string()\n    } else {\n        \"YES\".to_string()\n\
    \    }\n}\n\nfn main() {\n    let candidate = exchange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4], vec![1, 2, 3, 4]), String::from(\"YES\"));\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4], vec![1, 5, 3, 4]), String::from(\"NO\"));\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4], vec![2, 1, 4, 3]), String::from(\"YES\"));\n    assert_eq!(candidate(vec![5,\
    \ 7, 3], vec![2, 6, 4]), String::from(\"YES\"));\n    assert_eq!(candidate(vec![5,\
    \ 7, 3], vec![2, 6, 3]), String::from(\"NO\"));\n    assert_eq!(candidate(vec![3,\
    \ 2, 6, 1, 8, 9], vec![3, 5, 5, 1, 1, 1]), String::from(\"NO\"));\n    assert_eq!(candidate(vec![100,\
    \ 200], vec![200, 200]), String::from(\"YES\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmph1lhzolg.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// In this problem, you will implement a function that takes two lists\
    \ of numbers,\n/// and determines whether it is possible to perform an exchange\
    \ of elements\n/// between them to make lst1 a list of only even numbers.\n///\
    \ There is no limit on the number of exchanged elements between lst1 and lst2.\n\
    /// If it is possible to exchange elements between the lst1 and lst2 to make\n\
    /// all the elements of lst1 to be even, return \"YES\".\n/// Otherwise, return\
    \ \"NO\".\n/// For example:\n/// exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\
    \n/// exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n/// It is assumed that the\
    \ input lists will be non-empty.\nfn exchange(lst1: Vec<isize>, lst2: Vec<isize>)\
    \ -> String {\n    lst1.iter().any(|x| x % 2 == 0) && lst2.iter().any(|x| x %\
    \ 2 != 0)\n        || lst1.iter().any(|x| x % 2 != 0) && lst2.iter().any(|x| x\
    \ % 2 == 0)\n        || lst1.iter().any(|x| x % 2 == 0) && lst2.iter().any(|x|\
    \ x % 2 == 0)\n        || lst1.iter().any(|x| x % 2 != 0) && lst2.iter().any(|x|\
    \ x % 2 != 0)\n}\n\nfn main() {\n    let candidate = exchange;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4], vec![1, 2, 3, 4]), String::from(\"YES\"));\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4], vec![1, 5, 3, 4]), String::from(\"NO\"));\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4], vec![2, 1, 4, 3]), String::from(\"YES\"));\n    assert_eq!(candidate(vec![5,\
    \ 7, 3], vec![2, 6, 4]), String::from(\"YES\"));\n    assert_eq!(candidate(vec![5,\
    \ 7, 3], vec![2, 6, 3]), String::from(\"NO\"));\n    assert_eq!(candidate(vec![3,\
    \ 2, 6, 1, 8, 9], vec![3, 5, 5, 1, 1, 1]), String::from(\"NO\"));\n    assert_eq!(candidate(vec![100,\
    \ 200], vec![200, 200]), String::from(\"YES\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2woyt2mq.rs:13:5\n   |\n\
    12 |   fn exchange(lst1: Vec<isize>, lst2: Vec<isize>) -> String {\n   |     \
    \                                                 ------ expected `String` because\
    \ of return type\n13 | /     lst1.iter().any(|x| x % 2 == 0) && lst2.iter().any(|x|\
    \ x % 2 != 0)\n14 | |         || lst1.iter().any(|x| x % 2 != 0) && lst2.iter().any(|x|\
    \ x % 2 == 0)\n15 | |         || lst1.iter().any(|x| x % 2 == 0) && lst2.iter().any(|x|\
    \ x % 2 == 0)\n16 | |         || lst1.iter().any(|x| x % 2 != 0) && lst2.iter().any(|x|\
    \ x % 2 != 0)\n   | |_____________________________________________________________________________^\
    \ expected struct `String`, found `bool`\n   |\nhelp: try using a conversion method\n\
    \   |\n13 ~     (lst1.iter().any(|x| x % 2 == 0) && lst2.iter().any(|x| x % 2\
    \ != 0)\n14 |         || lst1.iter().any(|x| x % 2 != 0) && lst2.iter().any(|x|\
    \ x % 2 == 0)\n15 |         || lst1.iter().any(|x| x % 2 == 0) && lst2.iter().any(|x|\
    \ x % 2 == 0)\n16 ~         || lst1.iter().any(|x| x % 2 != 0) && lst2.iter().any(|x|\
    \ x % 2 != 0)).to_string()\n   |\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
