name: HumanEval_39_prime_fib
language: rs
prompt: "/// prime_fib returns n-th number that is a Fibonacci number and it's also\
  \ prime.\n/// >>> prime_fib(1)\n/// 2\n/// >>> prime_fib(2)\n/// 3\n/// >>> prime_fib(3)\n\
  /// 5\n/// >>> prime_fib(4)\n/// 13\n/// >>> prime_fib(5)\n/// 89\nfn prime_fib(n:\
  \ isize) -> isize {\n"
tests: "}\n\nfn main() {\n    let candidate = prime_fib;\n    assert_eq!(candidate(1),\
  \ 2);\n    assert_eq!(candidate(2), 3);\n    assert_eq!(candidate(3), 5);\n    assert_eq!(candidate(4),\
  \ 13);\n    assert_eq!(candidate(5), 89);\n    assert_eq!(candidate(6), 233);\n\
  \    assert_eq!(candidate(7), 1597);\n    assert_eq!(candidate(8), 28657);\n   \
  \ assert_eq!(candidate(9), 514229);\n    assert_eq!(candidate(10), 433494437);\n\
  }\n"
completions: ["    let (mut a, mut b) = (0, 1);\n    let mut idx = 0;\n    while idx\
    \ < n {\n        let c = a + b;\n        if is_prime(c) {\n            idx +=\
    \ 1;\n        }\n        a = b;\n        b = c;\n    }\n    a", '    fib().into_iter().filter(|&x|
    is_prime(x)).nth(n as usize - 1).unwrap()', "    let mut curr = 0;\n    let mut\
    \ fib = 1;\n    let mut prev = 1;\n    let mut res = 0;\n    let mut i = 0;\n\
    \    while i < n {\n        if prime(fib) {\n            res = fib;\n        \
    \    i += 1;\n        }\n        curr = fib;\n        fib = prev + fib;\n    \
    \    prev = curr;\n    }\n    res", '    0', "    // ...\n    0", "    let mut\
    \ nfib = 2;\n    let mut nindex = 1;\n    let mut prev_fib = 0;\n    let mut current_fib\
    \ = 2;\n    while nindex < n {\n        let next_fib = prev_fib + current_fib;\n\
    \        prev_fib = current_fib;\n        current_fib = next_fib;\n        if\
    \ helpers::is_prime(current_fib) {\n            nindex += 1;\n            nfib\
    \ = current_fib;\n        }\n    }\n    nfib", "    let mut count = 0;\n    let\
    \ mut fib = fibonacci(0);\n    let mut prime = Prime::default();\n    loop {\n\
    \        let p = fib.next().unwrap();\n        if prime.is_prime(p) {\n      \
    \      count += 1;\n            if count == n {\n                return p;\n \
    \           }\n        }\n    }", "    let mut i = 0;\n    let mut cnt = 0;\n\
    \    let mut a = 1;\n    let mut b = 2;\n    let mut f = b;\n    while cnt < n\
    \ {\n        i += 1;\n        f = a + b;\n        if is_prime(f) {\n         \
    \   cnt += 1;\n        }\n        a = b;\n        b = f;\n    }\n    f", "   \
    \ assert!(n > 0);\n    let mut first = 2;\n    let mut second = 3;\n    let mut\
    \ tmp;\n    let mut i = 1;\n    while i < n {\n        tmp = first + second;\n\
    \        first = second;\n        second = tmp;\n        if is_prime(second) {\n\
    \            i += 1;\n        }\n    }\n    second", "    let mut i = 0;\n   \
    \ let mut n1 = 0;\n    let mut n2 = 1;\n    while i < n {\n        if is_prime(n2)\
    \ {\n            i += 1;\n        }\n        let n3 = n1 + n2;\n        n1 = n2;\n\
    \        n2 = n3;\n    }\n    n1", "    let mut count = 0;\n    let mut a = 1;\n\
    \    let mut b = 1;\n    let mut c = 0;\n    let mut result = 0;\n    while count\
    \ != n {\n        c = a + b;\n        a = b;\n        b = c;\n        if is_prime(c)\
    \ {\n            count += 1;\n            result = c;\n        }\n    }\n    result",
  "    let mut primes: Vec<isize> = vec![2, 3];\n    let mut fibs: Vec<isize> = vec![2,\
    \ 3];\n    let mut fib_index: usize = 0;\n    let mut n_prime: isize = 5;\n  \
    \  loop {\n        if is_prime(n_prime) {\n            primes.push(n_prime);\n\
    \            if fib_index < fibs.len() && fibs[fib_index] == n_prime {\n     \
    \           fib_index += 1;\n                if fib_index == n {\n           \
    \         return fibs[fib_index - 1];\n                }\n            }\n    \
    \    }\n        let last_fib = fibs[fibs.len() - 1];\n        let second_last_fib\
    \ = fibs[fibs.len() - 2];\n        fibs.push(last_fib + second_last_fib);\n  \
    \      n_prime += 2;\n    }", "    if n < 1 { return -1; }\n    let mut i = 1;\n\
    \    let mut f1 = 1;\n    let mut f2 = 1;\n    while i < n {\n        let f3 =\
    \ f1 + f2;\n        if util::is_prime(f3) {\n            i += 1;\n        }\n\
    \        f1 = f2;\n        f2 = f3;\n    }\n    f2", "    let mut f1 = 2;\n  \
    \  let mut f2 = 3;\n    let mut count = 2;\n    let mut tmp;\n    while count\
    \ < n {\n        tmp = f2;\n        f2 = f1 + f2;\n        f1 = tmp;\n       \
    \ if is_prime(f2) {\n            count += 1;\n        }\n    }\n    f2", "   \
    \ let mut counter = 0;\n    let mut result = 1;\n    let mut fibonacci = 2;\n\
    \    let mut fib = 1;\n    while counter < n {\n        if is_prime(fibonacci)\
    \ {\n            counter += 1;\n            result = fibonacci;\n        }\n \
    \       let temp = fibonacci;\n        fibonacci += fib;\n        fib = temp;\n\
    \    }\n    result", "    let mut fib_num = 0;\n    let mut prime_num = 0;\n \
    \   let mut prev_fib_num = 0;\n    let mut i = 1;\n    while fib_num < n {\n \
    \       prev_fib_num = prime_num;\n        prime_num = fib_num;\n        fib_num\
    \ = fib(i);\n        i += 1;\n    }\n    return prime_num;", "    if n < 0 {\n\
    \        panic!(\"n must be greater than or equal to 0\");\n    }\n    let mut\
    \ i = 0;\n    let mut x = 0;\n    let mut y = 1;\n    while i < n {\n        let\
    \ fib = x + y;\n        x = y;\n        y = fib;\n        if is_prime(fib) {\n\
    \            i += 1;\n        }\n    }\n    return x;", "    if n == 1 {\n   \
    \     return 2;\n    }\n    let mut i = 2;\n    let mut a = 2;\n    let mut b\
    \ = 3;\n    let mut c = 5;\n    while i < n {\n        a = b;\n        b = c;\n\
    \        c = a + b;\n        if !is_prime(c) {\n            continue;\n      \
    \  }\n        i += 1;\n    }\n    c", '    fib(n).filter(|&x| is_prime(x)).nth(n
    as usize - 1).unwrap()', "    let mut i = 0;\n    let mut j = 1;\n    let mut\
    \ k = 1;\n    let mut p = 0;\n    while p < n {\n        i = j;\n        j = k;\n\
    \        k = i + j;\n        if is_prime(k) {\n            p += 1;\n        }\n\
    \    }\n    return k;"]
stop_tokens:
- "\n}"
