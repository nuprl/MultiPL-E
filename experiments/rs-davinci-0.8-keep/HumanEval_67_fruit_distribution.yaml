name: HumanEval_67_fruit_distribution
language: rs
prompt: "/// In this task, you will be given a string that represents a number of\
  \ apples and oranges \n/// that are distributed in a basket of fruit this basket\
  \ contains \n/// apples, oranges, and mango fruits. Given the string that represents\
  \ the total number of \n/// the oranges and apples and an integer that represent\
  \ the total number of the fruits \n/// in the basket return the number of the mango\
  \ fruits in the basket.\n/// for examble:\n/// fruit_distribution(\"5 apples and\
  \ 6 oranges\", 19) ->19 - 5 - 6 = 8\n/// fruit_distribution(\"0 apples and 1 oranges\"\
  ,3) -> 3 - 0 - 1 = 2\n/// fruit_distribution(\"2 apples and 3 oranges\", 100) ->\
  \ 100 - 2 - 3 = 95\n/// fruit_distribution(\"100 apples and 1 oranges\",120) ->\
  \ 120 - 100 - 1 = 19\nfn fruit_distribution(s: String, n: isize) -> isize {\n"
tests: "}\n\nfn main() {\n    let candidate = fruit_distribution;\n    assert_eq!(candidate(String::from(\"\
  5 apples and 6 oranges\"), 19), 8);\n    assert_eq!(candidate(String::from(\"5 apples\
  \ and 6 oranges\"), 21), 10);\n    assert_eq!(candidate(String::from(\"0 apples\
  \ and 1 oranges\"), 3), 2);\n    assert_eq!(candidate(String::from(\"1 apples and\
  \ 0 oranges\"), 3), 2);\n    assert_eq!(candidate(String::from(\"2 apples and 3\
  \ oranges\"), 100), 95);\n    assert_eq!(candidate(String::from(\"2 apples and 3\
  \ oranges\"), 5), 0);\n    assert_eq!(candidate(String::from(\"1 apples and 100\
  \ oranges\"), 120), 19);\n}\n"
completions: ["\tlet mut num_of_fruit: isize = 0;\n\tfor s in s.split(\" \") {\n\t\
    \tif s.contains(\"apple\") {\n\t\t\tlet num_of_apple: String = s.chars().filter(|x|\
    \ x.is_numeric()).collect();\n\t\t\tnum_of_fruit += num_of_apple.parse::<isize>().unwrap();\n\
    \t\t}\n\t\tif s.contains(\"orange\") {\n\t\t\tlet num_of_orange: String = s.chars().filter(|x|\
    \ x.is_numeric()).collect();\n\t\t\tnum_of_fruit += num_of_orange.parse::<isize>().unwrap();\n\
    \t\t}\n\t}\n\treturn n - num_of_fruit;", "    let mut total_fruits = n;\n    let\
    \ mut apples = 0;\n    let mut oranges = 0;\n    for word in s.split_whitespace()\
    \ {\n        if word.starts_with(\"a\") {\n            total_fruits -= apples;\n\
    \        } else if word.starts_with(\"o\") {\n            total_fruits -= oranges;\n\
    \        } else {\n            let num = word.parse::<isize>().unwrap();\n   \
    \         if word.ends_with(\"apples\") {\n                apples = num;\n   \
    \         } else {\n                oranges = num;\n            }\n        }\n\
    \    }\n    total_fruits", "    let mut total = n;\n    let mut s = s.split_whitespace();\n\
    \    for item in s {\n        if let Ok(number) = item.parse::<isize>() {\n  \
    \          total -= number;\n        }\n    }\n    total", "    let mut n_apples\
    \ = 0;\n    let mut n_oranges = 0;\n    for word in s.split_whitespace() {\n \
    \       if word.contains(\"apples\") {\n            n_apples = word.to_string().parse::<isize>().unwrap();\n\
    \        }\n        if word.contains(\"oranges\") {\n            n_oranges = word.to_string().parse::<isize>().unwrap();\n\
    \        }\n    }\n    n - n_apples - n_oranges", "    let re = Regex::new(r\"\
    (?P<num>\\d+)\\s(?P<fruit>\\w+)\").unwrap();\n    let mut sum = 0;\n    for cap\
    \ in re.captures_iter(&s) {\n        sum += cap[\"num\"].parse::<isize>().unwrap();\n\
    \    }\n    n - sum", '    unimplemented!()', "    let mut apple_count = 0;\n\
    \    let mut orange_count = 0;\n    let mut mango_count = 0;\n    let mut split_string:\
    \ Vec<&str> = s.split_whitespace().collect();\n    if split_string[0].parse::<isize>().is_ok()\
    \ {\n        apple_count = split_string[0].parse::<isize>().unwrap();\n    }\n\
    \    if split_string[2].parse::<isize>().is_ok() {\n        orange_count = split_string[2].parse::<isize>().unwrap();\n\
    \    }\n    mango_count = n - apple_count - orange_count;\n    return mango_count;",
  '    unimplemented!();', "    let mut iter = s.split_whitespace();\n    let num_apples\
    \ = iter.next().unwrap().parse::<isize>().unwrap();\n    let num_oranges = iter.nth(2).unwrap().parse::<isize>().unwrap();\n\
    \    n - num_apples - num_oranges", '    unimplemented!()', "    let mut n = n;\n\
    \    let mut i = 0;\n    while s.get(i..i+5) != Some(\" apples\"){\n        i+=1;\n\
    \    }\n    let s = &s[..i];\n    let mut i = 0;\n    while s.get(i..i+1) != Some(\"\
    a\"){\n        n -= s.get(i..i+1).unwrap().parse::<isize>().unwrap();\n      \
    \  i+=1;\n    }\n    return n;", "    // unimplemented!(\"The number of mango\
    \ fruits in a basket that contains {} total fruits, {}.\", s, n)\n    // let fruit_count\
    \ = s.split(\" and \").map(|s| s.split(\" \").nth(0).unwrap().parse::<isize>().unwrap()).collect::<Vec<isize>>();\n\
    \    // n - fruit_count[0] - fruit_count[1]\n    n - s.split(\" and \").map(|s|\
    \ s.split(\" \").nth(0).unwrap().parse::<isize>().unwrap()).sum::<isize>()", " \
    \ let n_apples: isize = s.chars().take_while(|c| c.is_digit(10)).collect::<String>().parse().unwrap();\n\
    \  let n_oranges: isize = s.chars().skip_while(|c| c.is_alphabetic()).skip_while(|c|\
    \ c.is_whitespace()).take_while(|c| c.is_digit(10)).collect::<String>().parse().unwrap();\n\
    \  n - n_apples - n_oranges", '    unimplemented!();', "    // Write your code\
    \ here\n    unimplemented!()", "    // Write your code here\n    unimplemented!();",
  "    \n    let mut arr: Vec<&str> = s.split(\" \").collect();\n    let mut num =\
    \ 0;\n    for i in 0..arr.len()\n    {\n        if i % 2 == 0\n        {\n   \
    \         if arr[i].parse::<isize>().is_ok()\n            {\n                num\
    \ += arr[i].parse::<isize>().unwrap();\n            }\n        }\n    }\n    n\
    \ - num", "    // Write your code here\n    let mut v: Vec<isize> = Vec::new();\n\
    \    let mut index = 0;\n    let mut temp = \"\";\n    for i in s.split_whitespace()\
    \ {\n        let num: isize = i.parse().unwrap();\n        v.push(num);\n    \
    \    temp = temp + &v[index].to_string() + \" \";\n        index += 1;\n    }\n\
    \    let mut vec: Vec<&str> = temp.split(\" and \").collect();\n    let num1:\
    \ isize = vec[0].parse().unwrap();\n    let num2: isize = vec[1].parse().unwrap();\n\
    \    n - num1 - num2", "    let mut splitted = s.split(\" \");\n    let apples\
    \ = splitted.next().unwrap().parse::<isize>().unwrap();\n    let oranges = splitted.next().unwrap().parse::<isize>().unwrap();\n\
    \    n - apples - oranges", "    if s.contains(\"and\"){\n        let part1: Vec<&str>\
    \ = s.split(\" and \").collect();\n        let part2: Vec<&str> = part1[0].split(\"\
    \ \").collect();\n        let part3: Vec<&str> = part1[1].split(\" \").collect();\n\
    \        n - part2[0].parse::<isize>().unwrap() - part3[0].parse::<isize>().unwrap()\n\
    \    }else{\n        let part1: Vec<&str> = s.split(\" \").collect();\n      \
    \  n - part1[0].parse::<isize>().unwrap() - part1[2].parse::<isize>().unwrap()\n\
    \    }"]
stop_tokens:
- "\n}"
