name: HumanEval_77_iscube
language: rs
prompt: "/// Write a function that takes an integer a and returns True \n/// if this\
  \ ingeger is a cube of some integer number.\n/// Note: you may assume the input\
  \ is always valid.\n/// Examples:\n/// iscube(1) ==> True\n/// iscube(2) ==> False\n\
  /// iscube(-1) ==> True\n/// iscube(64) ==> True\n/// iscube(0) ==> True\n/// iscube(180)\
  \ ==> False\nfn iscube(a: isize) -> bool {\n"
tests: "}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
  \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n\
  \    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n\
  \    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n \
  \   assert_eq!(candidate(1729), false);\n}\n"
completions: ['    unimplemented!();', "    let sqrt = (a as f64).sqrt();\n    let\
    \ cube = sqrt.powi(3);\n    return (cube - sqrt).abs() < 0.01;", '    return false;',
  '    ((a as f64).powf(1f64 / 3f64) % 1f64).abs() < 0.0001f64', '    a == 0 || a
    == 1 || a == -1 || (a < 0 && a > -1000 && (1..1000).any(|x| x*x*x == a)) || (a
    > 1 && a < 1000 && (1..1000).any(|x| x*x*x == a))', '    return (a.pow(3) as f64).sqrt()
    == a.pow(2) as f64;', "    let b = ((a.abs() as f64).powf(1.0/3.0)).floor() as\
    \ isize;\n    b*b*b == a", '    ((a.abs() as f64).cbrt() as isize) * ((a.abs()
    as f64).cbrt() as isize) * ((a.abs() as f64).cbrt() as isize) == a.abs()', " \
    \   let mut counter = 0;\n    let mut i = 0;\n    while i < a {\n        i +=\
    \ counter;\n        counter += 1;\n        if i == a {\n            return true;\n\
    \        }\n    }\n    false", "    let mut i = 1;\n    while i*i*i <= a {\n \
    \       if i*i*i == a {\n            return true;\n        }\n        i += 1;\n\
    \    }\n    false", "    for i in 0..a {\n        if i * i * i == a {\n      \
    \      return true;\n        }\n    }\n    false", '    unimplemented!()', '    a
    == a.abs().pow(1 / 3)', '    unimplemented!()', "    if a < 0 {\n        a.abs()\
    \ as f64 == (a.abs() as f64).cbrt().floor() * (a.abs() as f64).cbrt().floor()\
    \ * (a.abs() as f64).cbrt().floor()\n    } else {\n        a as f64 == (a as f64).cbrt().floor()\
    \ * (a as f64).cbrt().floor() * (a as f64).cbrt().floor()\n    }", "    let c\
    \ = a.abs();\n    (1..=c).filter(|&x| x*x*x == c).count() > 0", "    if a == 0\
    \ {\n        return true;\n    }\n    let mut x = 1;\n    while x * x * x <= a.abs()\
    \ {\n        if x * x * x == a.abs() {\n            return true;\n        }\n\
    \        x += 1;\n    }\n    false", "    let sqrt = (a as f64).sqrt();\n    let\
    \ is_float = sqrt.fract() == 0.0;\n    let cube_root = (sqrt as isize).pow(3);\n\
    \    is_float && cube_root == a", "    // unimplemented!()\n    if a < 0 {\n \
    \       if a == -1 { true } else {\n            let n: f64 = ((-a) as f64).sqrt();\n\
    \            n.floor() == n\n        }\n    } else {\n        if a == 0 { true\
    \ } else {\n            let n: f64 = (a as f64).sqrt();\n            n.floor()\
    \ == n\n        }\n    }", "    let mut cnt = 1;\n    let mut res = 1;\n    loop\
    \ {\n        if res == a {\n            return true;\n        }\n        if res\
    \ > a {\n            return false;\n        }\n        cnt += 1;\n        res\
    \ = cnt * cnt * cnt;\n    }"]
stop_tokens:
- "\n}"
