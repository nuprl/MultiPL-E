name: HumanEval_142_sum_squares
language: rs
prompt: "/// \"\n/// This function will take a list of integers. For all entries in\
  \ the list, the function shall square the integer entry if its index is a \n///\
  \ multiple of 3 and will cube the integer entry if its index is a multiple of 4\
  \ and not a multiple of 3. The function will not \n/// change the entries in the\
  \ list whose indexes are not a multiple of 3 or 4. The function shall then return\
  \ the sum of all entries. \n/// Examples:\n/// For lst = [1,2,3] the output should\
  \ be 6\n/// For lst = []  the output should be 0\n/// For lst = [-1,-5,2,-1,-5]\
  \  the output should be -126\nfn sum_squares(lst: Vec<isize>) -> isize {\n"
tests: "}\n\nfn main() {\n    let candidate = sum_squares;\n    assert_eq!(candidate(vec![1,\
  \ 2, 3]), 6);\n    assert_eq!(candidate(vec![1, 4, 9]), 14);\n    assert_eq!(candidate(Vec::<isize>::new()),\
  \ 0);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 1, 1, 1, 1, 1]), 9);\n    assert_eq!(candidate(vec![-1,\
  \ -1, -1, -1, -1, -1, -1, -1, -1]), -3);\n    assert_eq!(candidate(vec![0]), 0);\n\
  \    assert_eq!(candidate(vec![-1, -5, 2, -1, -5]), -126);\n    assert_eq!(candidate(vec![-56,\
  \ -99, 1, 0, -2]), 3030);\n    assert_eq!(candidate(vec![-1, 0, 0, 0, 0, 0, 0, 0,\
  \ -1]), 0);\n    assert_eq!(candidate(vec![-16, -9, -2, 36, 36, 26, -20, 25, -40,\
  \ 20, -4, 12, -26, 35, 37]), -14196);\n    assert_eq!(candidate(vec![-1, -3, 17,\
  \ -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]), -1448);\n\
  }\n"
completions: ["    let mut sum: isize = 0;\n    for idx in 0..lst.len() {\n      \
    \  let e = lst[idx];\n        if idx % 3 == 0 {\n            sum += e*e;\n   \
    \     } else if idx % 4 == 0 {\n            sum += e*e*e;\n        } else {\n\
    \            sum += e;\n        }\n    }\n    sum", "    let mut sum = 0;\n  \
    \  for (i, x) in lst.iter().enumerate() {\n        if i % 3 == 0 {\n         \
    \   sum += x * x;\n        } else if i % 4 == 0 {\n            sum += x * x *\
    \ x;\n        } else {\n            sum += x;\n        }\n    }\n    sum", " \
    \   let mut sum = 0;\n    for i in 0..lst.len() {\n        let mut entry = lst[i];\n\
    \        if i % 3 == 0 {\n            entry = entry * entry;\n        }\n    \
    \    if i % 4 == 0 && i % 3 != 0 {\n            entry = entry * entry * entry;\n\
    \        }\n        sum += entry;\n    }\n    sum", '    return 0;', "  let mut\
    \ output: isize = 0;\n  for i in 0..lst.len() {\n    if i % 3 == 0 {\n      output\
    \ += lst[i] * lst[i];\n    } else if i % 4 == 0 {\n      output += lst[i] * lst[i]\
    \ * lst[i];\n    } else {\n      output += lst[i];\n    }\n  }\n  output", " \
    \   let mut s = 0;\n    for (i, e) in lst.iter().enumerate() {\n        let a\
    \ = if i % 3 == 0 { e * e } else { *e };\n        let b = if i % 4 == 0 && i %\
    \ 3 != 0 { a * a } else { a };\n        s += b;\n    }\n    s", "    lst.iter().enumerate().map(|(idx,\
    \ e)| match idx % 3 {\n        0 => e.pow(2),\n        1 => *e,\n        2 =>\
    \ *e,\n        _ => panic!(\"Impossible\"),\n    }).sum()", "    let mut total\
    \ = 0;\n    for i in 0..lst.len() {\n        if i % 3 == 0 {\n            total\
    \ += lst[i] * lst[i];\n        } else if i % 4 == 0 {\n            total += lst[i]\
    \ * lst[i] * lst[i];\n        } else {\n            total += lst[i];\n       \
    \ }\n    }\n    total", "    let mut lst = lst;\n    for i in 0..lst.len() {\n\
    \        if i % 3 == 0 {\n            lst[i] = lst[i].pow(2);\n        } else\
    \ if i % 4 == 0 {\n            lst[i] = lst[i].pow(3);\n        }\n    }\n   \
    \ lst.iter().sum()", "    let mut result: isize = 0;\n    for (i, &elem) in lst.iter().enumerate()\
    \ {\n        if i % 3 == 0 {\n            result += elem * elem;\n        } else\
    \ if i % 4 == 0 {\n            result += elem * elem * elem;\n        } else {\n\
    \            result += elem;\n        }\n    }\n    result", '    unimplemented!()',
  "    let n = lst.len();\n    let mut out = 0;\n    for i in 0..n {\n        if i\
    \ % 3 == 0 {\n            out += lst[i] * lst[i];\n        } else if i % 4 ==\
    \ 0 {\n            out += lst[i] * lst[i] * lst[i];\n        } else {\n      \
    \      out += lst[i];\n        }\n    }\n    out", "    let mut new_lst = Vec::new();\n\
    \    for (index, item) in lst.iter().enumerate() {\n        if index % 3 == 0\
    \ && index % 4 != 0 {\n            new_lst.push(item * item);\n        } else\
    \ if index % 4 == 0 && index % 3 != 0 {\n            new_lst.push(item * item\
    \ * item);\n        } else {\n            new_lst.push(*item);\n        }\n  \
    \  }\n    new_lst.iter().sum()", "    lst.iter().enumerate().map(|(index, &item)|\
    \ {\n        let mut n = item;\n        if index % 3 == 0 {\n            n = n\
    \ * n;\n        }\n        if index % 4 == 0 && index % 3 != 0 {\n           \
    \ n = n * n * n;\n        }\n        n\n    }).sum()", "    let mut sum = 0;\n\
    \    for (i, x) in lst.iter().enumerate() {\n        match i % 12 {\n        \
    \    0 | 3 | 6 | 9 => sum += x * x * x,\n            _ => sum += x * x,\n    \
    \    }\n    }\n    sum", "    lst.iter().enumerate().map(|(i, &item)| match i\
    \ % 12 {\n        0 => item * item * item * item,\n        3 | 6 | 9 => item *\
    \ item * item,\n        _ => item * item,\n    }).sum()", "  let mut sum = 0;\n\
    \  let mut i = 0;\n  while i < lst.len() {\n    let n = lst[i];\n    if i % 3\
    \ == 0 {\n      sum += n * n;\n    } else if i % 4 == 0 {\n      sum += n * n\
    \ * n;\n    } else {\n      sum += n;\n    }\n    i += 1;\n  }\n  sum", "    lst.iter().enumerate().map(|(i,x)|\
    \ {\n        let mut res = *x;\n        if i % 3 == 0 { res = res * res; }\n \
    \       if i % 4 == 0 && i % 3 != 0 { res = res * res * res; }\n        res\n\
    \    }).sum()", "    let mut sum = 0;\n    for (i, j) in lst.iter().enumerate()\
    \ {\n        let factor: isize = match i % 3 {\n            0 => i % 4,\n    \
    \        _ => 0,\n        };\n        match factor {\n            0 => sum +=\
    \ *j * *j,\n            _ => sum += *j * *j * *j,\n        }\n    }\n    sum",
  "    let mut sum = 0;\n    for i in 0..lst.len() {\n        match i {\n        \
    \    0 => sum += 3*lst[i],\n            3 => sum += 4*lst[i],\n            _ =>\
    \ sum += lst[i],\n        }\n    }\n    sum"]
stop_tokens:
- "\n}"
