name: HumanEval_151_double_the_difference
language: rs
prompt: "/// Given a list of numbers, return the sum of squares of the numbers\n///\
  \ in the list that are odd. Ignore numbers that are negative or not integers.\n\
  /// double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n/// double_the_difference([-1,\
  \ -2, 0]) == 0\n/// double_the_difference([9, -2]) == 81\n/// double_the_difference([0])\
  \ == 0  \n/// If the input list is empty, return 0.\nfn double_the_difference(lst:\
  \ Vec<f64>) -> isize {\n"
tests: "}\n\nfn main() {\n    let candidate = double_the_difference;\n    assert_eq!(candidate(Vec::<f64>::new()),\
  \ 0);\n    assert_eq!(candidate(vec![5.0, 4.0]), 25);\n    assert_eq!(candidate(vec![0.1,\
  \ 0.2, 0.3]), 0);\n    assert_eq!(candidate(vec![-10.0, -20.0, -30.0]), 0);\n  \
  \  assert_eq!(candidate(vec![-1.0, -2.0, 8.0]), 0);\n    assert_eq!(candidate(vec![0.2,\
  \ 3.0, 5.0]), 34);\n    assert_eq!(candidate(vec![-9.0, -7.0, -5.0, -3.0, -1.0,\
  \ 1.0, 3.0, 5.0, 7.0, 9.0]), 165);\n}\n"
completions: ['    unimplemented!();', "    let mut result: isize = 0;\n    for i\
    \ in lst {\n        if i.fract() == 0. {\n            if i % 2. == 1. {\n    \
    \            result += (i * i) as isize;\n            }\n        }\n    }\n  \
    \  result", '    unimplemented!();', "    // sum of all odd squares\n    0", '    unimplemented!()',
  "    let mut sum: isize = 0;\n    for i in lst {\n        if i > 0.0 && i as isize\
    \ % 2 == 1 {\n            sum += i as isize * i as isize;\n        }\n    }\n\
    \    return sum;", "    let mut lst_int = Vec::new();\n    for elem in lst {\n\
    \        if elem == (elem as isize) as f64 && elem > 0.0 {\n            lst_int.push(elem\
    \ as isize);\n        }\n    }\n    let mut sum = 0;\n    for elem in lst_int\
    \ {\n        if elem % 2 == 1 {\n            sum += elem.pow(2);\n        }\n\
    \    }\n    sum as isize", '    0', '    unimplemented!()', '    unimplemented!();',
  '    unimplemented!()', "    let mut ans:isize = 0;\n    for i in lst {\n      \
    \  if (i.fract() != 0.0) || (i < 0.0) {\n            continue;\n        }\n  \
    \      if (i as isize) % 2 == 1 {\n            ans += i as isize * i as isize;\n\
    \        }\n    }\n    ans", "    // TODO: complete this function\n    0", " \
    \   if lst.len() == 0 {\n        return 0;\n    }\n    let sum = lst.iter().fold(0,\
    \ |acc, x| {\n        if x.is_sign_positive() && *x as i64 == *x {\n         \
    \   acc + (*x as i64 * *x as i64)\n        } else {\n            acc\n       \
    \ }\n    });\n    sum as isize", '    lst.iter().filter(|&x| x % 2.0 != 0.0 &&
    x > &0.0).map(|x| x.powi(2) as isize).sum()', "    let mut sum = 0.0;\n    for\
    \ n in lst {\n        if n > 0.0 && n.fract() == 0.0 {\n            sum += n *\
    \ n;\n        }\n    }\n    (sum * 2.0) as isize", '    unimplemented!()', "\t0",
  '    unimplemented!();', "\tlet mut num = 0;\n\tfor i in lst {\n\t\tif i%2.0 !=\
    \ 0.0 && i>0.0 && i.fract() == 0.0 {\n\t\t\tnum += (i as isize) * (i as isize);\n\
    \t\t}\n\t}\n\tnum"]
stop_tokens:
- "\n}"
