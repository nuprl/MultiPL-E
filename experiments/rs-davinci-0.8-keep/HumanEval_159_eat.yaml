name: HumanEval_159_eat
language: rs
prompt: "/// You're a hungry rabbit, and you already have eaten a certain number of\
  \ carrots,\n/// but now you need to eat more carrots to complete the day's meals.\n\
  /// you should return an array of [ total number of eaten carrots after your meals,\n\
  /// the number of carrots left after your meals ]\n/// if there are not enough remaining\
  \ carrots, you will eat all remaining carrots, but will still be hungry.\n/// Example:\n\
  /// * eat(5, 6, 10) -> [11, 4]\n/// * eat(4, 8, 9) -> [12, 1]\n/// * eat(1, 10,\
  \ 10) -> [11, 0]\n/// * eat(2, 11, 5) -> [7, 0]\n/// Variables:\n/// @number : integer\n\
  /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
  \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
  \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <= 1000\n\
  /// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\nfn eat(number:\
  \ isize, need: isize, remaining: isize) -> Vec<isize> {\n"
tests: "}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6,\
  \ 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
  \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n   \
  \ assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1),\
  \ vec![5, 0]);\n}\n"
completions: ["    let mut total_eaten = number;\n    let mut total_left = remaining;\n\
    \    if remaining > 0 {\n        if need > remaining {\n            total_eaten\
    \ += remaining;\n            total_left = 0;\n        } else {\n            total_eaten\
    \ += need;\n            total_left -= need;\n        }\n    }\n    vec![total_eaten,\
    \ total_left]", '    vec![(number + std::cmp::min(need, remaining)), (remaining
    - std::cmp::min(need, remaining))]', "    let mut eat_number = 0;\n    let mut\
    \ new_number = 0;\n    eat_number = number + need;\n    if eat_number > remaining\
    \ {\n        new_number = eat_number - remaining;\n        eat_number = remaining;\n\
    \    } else {\n        new_number = 0;\n    }\n    vec![eat_number, new_number]",
  "    if need <= remaining {\n        return vec![need + number, remaining - need];\n\
    \    }\n    vec![remaining + number, 0]", "    let mut remaining = remaining;\n\
    \    let mut total = number;\n    let mut total_need = number + need;\n    while\
    \ total < total_need && remaining > 0 {\n        total += 1;\n        remaining\
    \ -= 1;\n    }\n    vec![total, remaining]", "    if number + remaining >= need\
    \ {\n        vec![need, number + remaining - need]\n    } else {\n        vec![number\
    \ + remaining, 0]\n    }", "    let total = number + min(need, remaining);\n \
    \   vec![total, max(0, remaining - need)]", "    vec![\n        if need > remaining\
    \ {\n            need - remaining + number\n        } else {\n            number\
    \ + need\n        },\n        if need > remaining {\n            0\n        }\
    \ else {\n            remaining - need\n        },\n    ]", "    let max = number\
    \ + remaining;\n    if max >= need {\n        vec![need, max - need]\n    } else\
    \ {\n        vec![max, 0]\n    }", "    match (remaining, need - number) {\n \
    \       (r, n) if r > n => vec![need, r - n],\n        (_, n) if n > 0 => vec![number\
    \ + remaining, 0],\n        _ => vec![number, remaining],\n    }", "    let nb_carrots\
    \ = number + remaining;\n    if nb_carrots >= need {\n        return vec![need,\
    \ nb_carrots - need];\n    }\n    vec![nb_carrots, 0]", "    let mut eaten = number;\n\
    \    let mut stock = remaining;\n    let mut meal = need;\n    let mut eaten_carrots\
    \ = 0;\n    let mut remaining_carrots = 0;\n    while meal != 0 {\n        if\
    \ stock == 0 {\n            return vec![eaten, 0];\n        }\n        stock -=\
    \ 1;\n        meal -= 1;\n        eaten += 1;\n        eaten_carrots = eaten;\n\
    \        remaining_carrots = stock;\n    }\n    vec![eaten_carrots, remaining_carrots]",
  "    if number == 0 && need == 0 && remaining == 0 {\n        return vec![0, 0];\n\
    \    }\n    let remaining_carrots = remaining - number;\n    if remaining_carrots\
    \ < need {\n        return vec![number + remaining_carrots, 0];\n    }\n    return\
    \ vec![number + need, remaining_carrots - need];", "    let total_eaten: isize\
    \ = number + need;\n    let remaining_carrots: isize = remaining - need;\n   \
    \ let left_to_eat: isize = need - remaining;\n    if left_to_eat > 0 {\n     \
    \   let res = [total_eaten, 0];\n        return res.to_vec();\n    } else {\n\
    \        let res = [total_eaten, remaining_carrots];\n        return res.to_vec();\n\
    \    }", "    let mut result = Vec::new();\n    if number + remaining < need {\n\
    \        result.push(number + remaining);\n        result.push(0);\n    } else\
    \ {\n        result.push(need);\n        result.push(remaining - (need - number));\n\
    \    }\n    result", "    let mut eaten = number;\n    if eaten >= need {\n  \
    \      eaten = need;\n    } else {\n        if remaining >= need - eaten {\n \
    \           eaten += need - eaten;\n        } else {\n            eaten += remaining;\n\
    \        }\n    }\n    vec![eaten, remaining - (eaten - number)]", "    let eaten\
    \ = number + need;\n    vec![\n        eaten > remaining\n            .checked_add(number)\n\
    \            .expect(\"remaining is out of bounds\"),\n        remaining - eaten.min(remaining),\n\
    \    ]", "    vec![\n        number + std::cmp::min(need, remaining),\n      \
    \  std::cmp::max(remaining - need, 0),\n    ]", "    let eaten = number + if need\
    \ < remaining { need } else { remaining };\n    vec![eaten, remaining - need.min(remaining)]",
  '    vec![number + std::cmp::min(need, remaining), remaining - std::cmp::min(need,
    remaining)]']
stop_tokens:
- "\n}"
