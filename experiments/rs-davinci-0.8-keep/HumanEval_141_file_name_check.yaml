name: HumanEval_141_file_name_check
language: rs
prompt: "/// Create a function which takes a string representing a file's name, and\
  \ returns\n/// 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n\
  /// A file's name is considered to be valid if and only if all the following conditions\
  \ \n/// are met:\n/// - There should not be more than three digits ('0'-'9') in\
  \ the file's name.\n/// - The file's name contains exactly one dot '.'\n/// - The\
  \ substring before the dot should not be empty, and it starts with a letter from\
  \ \n/// the latin alphapet ('a'-'z' and 'A'-'Z').\n/// - The substring after the\
  \ dot should be one of these: ['txt', 'exe', 'dll']\n/// Examples:\n/// file_name_check(\"\
  example.txt\") # => 'Yes'\n/// file_name_check(\"1example.dll\") # => 'No' (the\
  \ name should start with a latin alphapet letter)\nfn file_name_check(file_name:\
  \ String) -> String {\n"
tests: "}\n\nfn main() {\n    let candidate = file_name_check;\n    assert_eq!(candidate(String::from(\"\
  example.txt\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"\
  1example.dll\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
  s1sdf3.asd\")), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"\
  K.dll\")), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"MY16FILE3.exe\"\
  )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"His12FILE94.exe\"\
  )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_Y.txt\")),\
  \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"?aREYA.exe\")),\
  \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"/this_is_valid.dll\"\
  )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.wow\"\
  )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txt\"\
  )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"this_is_valid.txtexe\"\
  )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"#this2_i4s_5valid.ten\"\
  )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"@this1_is6_valid.exe\"\
  )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"this_is_12valid.6exe4.txt\"\
  )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"all.exe.txt\"\
  )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_No.exe\"\
  )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"Is3youfault.txt\"\
  )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"no_one#knows.dll\"\
  )), String::from(\"Yes\"));\n    assert_eq!(candidate(String::from(\"1I563_Yes3.exe\"\
  )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"I563_Yes3.txtt\"\
  )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final..txt\"\
  )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"final132\")),\
  \ String::from(\"No\"));\n    assert_eq!(candidate(String::from(\"_f4indsartal132.\"\
  )), String::from(\"No\"));\n    assert_eq!(candidate(String::from(\".txt\")), String::from(\"\
  No\"));\n    assert_eq!(candidate(String::from(\"s.\")), String::from(\"No\"));\n\
  }\n"
completions: ['    unimplemented!()', '    unimplemented!()', "    let mut is_valid\
    \ = true;\n    let mut count_digits = 0;\n    let mut is_dot_placed = false;\n\
    \    let mut is_ext_valid = false;\n    let file_name_chars: Vec<char> = file_name.chars().collect();\n\
    \    for (i, c) in file_name_chars.iter().enumerate() {\n        if *c == '.'\
    \ {\n            is_dot_placed = true;\n            let ext: &str = &file_name[i\
    \ + 1..];\n            match ext {\n                \"txt\" | \"exe\" | \"dll\"\
    \ => is_ext_valid = true,\n                _ => is_ext_valid = false,\n      \
    \      }\n        }\n        match c.to_digit(10) {\n            Some(_) => count_digits\
    \ += 1,\n            None => {\n                if i == 0 {\n                \
    \    if !(c.is_ascii_alphabetic()) {\n                        is_valid = false;\n\
    \                    }\n                }\n            }\n        }\n    }\n \
    \   if count_digits > 3 || !is_dot_placed || !is_ext_valid {\n        is_valid\
    \ = false;\n    }\n    if is_valid {\n        return String::from(\"Yes\");\n\
    \    }\n    return String::from(\"No\");", '    "Yes".to_string()', "    fn non_empty_substring_start_with_latin_alphapet(string:\
    \ &str) -> bool {\n        let mut chars = string.chars();\n        match chars.next()\
    \ {\n            Some(c) => c.is_alphabetic() && chars.all(|c| c.is_digit(10)),\n\
    \            None => false,\n        }\n    }\n\n    let mut chars = file_name.chars();\n\
    \    let mut found_dot = false;\n    let mut dot_index = None;\n    for (i, c)\
    \ in chars.enumerate() {\n        if c == '.' {\n            if found_dot {\n\
    \                return \"No\".to_string();\n            }\n            found_dot\
    \ = true;\n            dot_index = Some(i);\n        }\n    }\n\n    if found_dot\
    \ {\n        let (substring_before_dot, substring_after_dot) =\n            match\
    \ dot_index {\n                Some(i) => file_name.split_at(i),\n           \
    \     None => panic!(\"Invalid dot_index!\"),\n            };\n        if substring_before_dot.len()\
    \ == 0 {\n            return \"No\".to_string();\n        }\n\n        if non_empty_substring_start_with_latin_alphapet(substring_before_dot)\
    \ {\n            match substring_after_dot {\n                \".txt\" | \".exe\"\
    \ | \".dll\" => \"Yes\".to_string(),\n                _ => \"No\".to_string(),\n\
    \            }\n        } else {\n            \"No\".to_string()\n        }\n\
    \    } else {\n        \"No\".to_string()\n    }", '    unimplemented!()', " \
    \   // TODO\n    \"Yes\".to_string()", "\tlet parts: Vec<&str> = file_name.split(\"\
    .\").collect();\n\tif parts.len() != 2 {\n\t\treturn \"No\".to_string();\n\t}\n\
    \tif parts[0].chars().any(|c| !c.is_ascii_alphabetic() && !c.is_numeric()) {\n\
    \t\treturn \"No\".to_string();\n\t}\n\tif parts[0].chars().any(|c| c.is_numeric()\
    \ && parts[0].chars().filter(|x| x == &c).count() > 3) {\n\t\treturn \"No\".to_string();\n\
    \t}\n\tif !parts[1].contains(\"txt\") && !parts[1].contains(\"exe\") && !parts[1].contains(\"\
    dll\") {\n\t\treturn \"No\".to_string();\n\t}\n\treturn \"Yes\".to_string();",
  "    // TODO: Implement me!\n    let mut counter = 0;\n    let mut flag = false;\n\
    \    let mut flag_num = false;\n    let mut flag_ext = false;\n    let mut char_before_dot\
    \ = ' ';\n    let mut extension = String::new();\n    for c in file_name.chars()\
    \ {\n        if c >= '0' && c <= '9' {\n            counter += 1;\n        } else\
    \ if c == '.' {\n            flag = true;\n        } else if c != ' ' {\n    \
    \        char_before_dot = c;\n        }\n    }\n    if counter > 3 {\n      \
    \  return String::from(\"No\");\n    }\n    if flag == false {\n        return\
    \ String::from(\"No\");\n    }\n    if char_before_dot >= '0' && char_before_dot\
    \ <= '9' {\n        return String::from(\"No\");\n    }\n    for s in file_name.split('.')\
    \ {\n        extension = s.to_string();\n    }\n    if extension == \"txt\" ||\
    \ extension == \"exe\" || extension == \"dll\" {\n        flag_ext = true;\n \
    \   }\n    if flag_ext == true {\n        return String::from(\"Yes\");\n    }\
    \ else {\n        return String::from(\"No\");\n    }", '    unimplemented!()',
  '    unimplemented!()', '    unimplemented!();', "    let mut flag = false;\n  \
    \  let mut count_digit = 0;\n    let mut flag_dot = false;\n    let mut flag_empty\
    \ = false;\n    let mut flag_dot_special = false;\n    let mut flag_dot_str =\
    \ false;\n    let mut is_last_char_digit = false;\n    let mut flag_dot_empty\
    \ = false;\n    let mut dot_index = 0;\n    let len = file_name.len();\n    for\
    \ i in 0..len {\n        if (file_name.as_bytes()[i] as char).is_alphabetic()\
    \ {\n            flag = true;\n        }\n        if (file_name.as_bytes()[i]\
    \ as char).is_numeric() {\n            count_digit += 1;\n        }\n        if\
    \ !flag_dot && file_name.as_bytes()[i] as char == '.' {\n            flag_dot\
    \ = true;\n            dot_index = i;\n        }\n        if i == 0 && file_name.as_bytes()[i]\
    \ as char == '.' {\n            flag_empty = true;\n        }\n        if file_name.as_bytes()[i]\
    \ as char == '.' {\n            if i == len - 1 {\n                flag_dot_empty\
    \ = true;\n            }\n            if i == len - 4 && file_name.as_bytes()[i\
    \ + 1] as char == 't' && file_name.as_bytes()[i + 2] as char == 'x' && file_name.as_bytes()[i\
    \ + 3] as char == 't' {\n                flag_dot_str = true;\n            }\n\
    \            if i == len - 4 && file_name.as_bytes()[i + 1] as char == 'e' &&\
    \ file_name.as_bytes()[i + 2] as char == 'x' && file_name.as_bytes()[i + 3] as\
    \ char == 'e' {\n                flag_dot_str = true;\n            }\n       \
    \     if i == len - 4 && file_name.as_bytes()[i + 1] as char == 'd' && file_name.as_bytes()[i\
    \ + 2", "    // code here\n    unimplemented!()", "    if file_name.len() > 0\
    \ {\n        let file_name: Vec<&str> = file_name.split('.').collect();\n    \
    \    if file_name.len() == 2 {\n            let first = file_name[0];\n      \
    \      let last = file_name[1];\n            if first.len() > 0 && last.len()\
    \ > 0 {\n                let mut nb_digit: i8 = 0;\n                for ch in\
    \ first.chars() {\n                    if ch.is_digit(10) {\n                \
    \        nb_digit += 1;\n                    }\n                }\n          \
    \      if nb_digit <= 3 {\n                    if last == \"txt\" || last == \"\
    exe\" || last == \"dll\" {\n                        return \"Yes\".to_string();\n\
    \                    }\n                }\n            }\n        }\n    }\n \
    \   \"No\".to_string()", "    let mut alphapet = false;\n    let mut letters =\
    \ 0;\n    let mut digits = 0;\n    let mut dot = false;\n    let mut dot_pos =\
    \ 0;\n    let mut after_dot_txt = false;\n    let mut after_dot_exe = false;\n\
    \    let mut after_dot_dll = false;\n    for (i, c) in file_name.chars().enumerate()\
    \ {\n        if c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z' {\n            alphapet\
    \ = true;\n            letters += 1;\n        } else if c >= '0' && c <= '9' {\n\
    \            digits += 1;\n        } else if c == '.' {\n            dot = true;\n\
    \            dot_pos = i;\n        }\n    }\n    if letters == 0 || digits > 3\
    \ || !dot {\n        return \"No\".to_string();\n    }\n    let after_dot = &file_name[dot_pos+1..];\n\
    \    if after_dot.len() == 3 {\n        if after_dot == \"txt\" {\n          \
    \  after_dot_txt = true;\n        } else if after_dot == \"exe\" {\n         \
    \   after_dot_exe = true;\n        } else if after_dot == \"dll\" {\n        \
    \    after_dot_dll = true;\n        }\n    }\n    if alphapet && after_dot_txt\
    \ || after_dot_exe || after_dot_dll {\n        return \"Yes\".to_string();\n \
    \   }\n    \"No\".to_string()", "    let mut dot_count = 0;\n    let mut digit_count\
    \ = 0;\n    let mut first_letter = false;\n    let mut ext_is_valid = false;\n\
    \    let mut chars = file_name.chars();\n    loop {\n        match chars.next()\
    \ {\n            Some(ch) => {\n                if ch == '.' {\n             \
    \       dot_count += 1;\n                } else if ch.is_digit(10) {\n       \
    \             digit_count += 1;\n                } else if ch.is_alphabetic()\
    \ {\n                    first_letter = true;\n                }\n           \
    \ }\n            None => break,\n        }\n    }\n    if digit_count > 3 {\n\
    \        return \"No\".to_string();\n    }\n    if dot_count != 1 {\n        return\
    \ \"No\".to_string();\n    }\n    if !first_letter {\n        return \"No\".to_string();\n\
    \    }\n    for ex in [\"txt\", \"exe\", \"dll\"].iter() {\n        if file_name.ends_with(ex)\
    \ {\n            ext_is_valid = true;\n            break;\n        }\n    }\n\
    \    if ext_is_valid {\n        return \"Yes\".to_string();\n    }\n    \"No\"\
    .to_string()", "    let mut found_dot = false;\n    let mut count_digits = 0;\n\
    \    let mut valid_ext = false;\n    let mut valid_file_name = false;\n    let\
    \ mut valid_file_name_n = false;\n    let mut all_valid = false;\n    let mut\
    \ c = 0;\n    let exts = [\"txt\", \"exe\", \"dll\"];\n    let mut check_ext =\
    \ String::new();\n    let bytes = file_name.into_bytes();\n    for b in bytes\
    \ {\n        if b != 46 && b != 110 && b != 114 && b != 97 && b != 100 && b !=\
    \ 105 && b != 116 && b != 120 && b != 101 && b != 108 && b != 108 && b != 108\
    \ && b != 46 && (b < 48 || b > 57) {\n            break;\n        }\n        if\
    \ b >= 48 && b <= 57 {\n            count_digits += 1;\n        }\n        if\
    \ count_digits > 3 {\n            break;\n        }\n        if b == 46 {\n  \
    \          if !found_dot {\n                found_dot = true;\n            } else\
    \ {\n                break;\n            }\n        }\n        if b == 110 ||\
    \ b == 114 || b == 97 || b == 100 || b == 105 || b == 116 || b == 120 || b ==\
    \ 101 || b == 108 {\n            valid_file_name = true;\n        }\n        if\
    \ b >= 48 && b <= 57 {\n            valid_file_name_n = true;\n        }\n   \
    \     if valid_file_name && valid_file_name_n {\n            break;\n        }\n\
    \        if b == 110 || b == 114 || b == 97 || b == 100 || b == 105 || b == 116\
    \ || b == 120 || b == 101 || b == 108 {\n            check_ext.push(b as char);\n\
    \        }\n        if b == 46 && valid_file_name {\n            for ext in exts.iter()\
    \ {\n                if ext == &check_ext {\n                    valid_ext = true;\n\
    \                    break;\n                }\n            }\n            check_ext\
    \ = String::new();\n        }\n        if found_dot && valid_ext && valid_file_name\
    \ {\n", "    let mut file_name = file_name.chars().collect::<Vec<char>>();\n \
    \   let mut count = 0;\n    while !file_name.is_empty() {\n        let c = file_name.pop().unwrap();\n\
    \        if c == '.' {\n            break;\n        }\n        if c.is_numeric()\
    \ {\n            count += 1;\n        }\n    }\n    if count > 3 {\n        return\
    \ \"No\".to_string();\n    }\n    if file_name.len() != 4 {\n        return \"\
    No\".to_string();\n    }\n    if !file_name[0].is_alphabetic() {\n        return\
    \ \"No\".to_string();\n    }\n    let extension = file_name.into_iter().collect::<String>();\n\
    \    if extension == \"exe\" || extension == \"txt\" || extension == \"dll\" {\n\
    \        return \"Yes\".to_string();\n    }\n    \"No\".to_string()", '    unimplemented!();']
stop_tokens:
- "\n}"
