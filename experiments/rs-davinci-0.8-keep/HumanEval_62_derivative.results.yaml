language: rs
name: HumanEval_62_derivative
results:
- exit_code: 0
  program: "/// xs represent coefficients of a polynomial.\n/// xs[0] + xs[1] * x\
    \ + xs[2] * x^2 + ....\n/// Return derivative of this polynomial in the same form.\n\
    /// >>> derivative([3, 1, 2, 4, 5])\n/// [1, 4, 12, 20]\n/// >>> derivative([1,\
    \ 2, 3])\n/// [2, 6]\nfn derivative(xs: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ result = Vec::new();\n    let mut degree = 0;\n    for i in 1..xs.len() {\n\
    \        result.push(xs[i] * i as isize);\n        degree += 1;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = derivative;\n    assert_eq!(candidate(vec![3,\
    \ 1, 2, 4, 5]), vec![1, 4, 12, 20]);\n    assert_eq!(candidate(vec![1, 2, 3]),\
    \ vec![2, 6]);\n    assert_eq!(candidate(vec![3, 2, 1]), vec![2, 2]);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1, 0, 4]), vec![2, 2, 0, 16]);\n    assert_eq!(candidate(vec![1]), Vec::<isize>::new());\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823099
- exit_code: 0
  program: "/// xs represent coefficients of a polynomial.\n/// xs[0] + xs[1] * x\
    \ + xs[2] * x^2 + ....\n/// Return derivative of this polynomial in the same form.\n\
    /// >>> derivative([3, 1, 2, 4, 5])\n/// [1, 4, 12, 20]\n/// >>> derivative([1,\
    \ 2, 3])\n/// [2, 6]\nfn derivative(xs: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ result = Vec::new();\n    let mut i = 0;\n    for &x in &xs {\n        if i\
    \ > 0 {\n            result.push(i as isize * x);\n        }\n        i += 1;\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = derivative;\n    assert_eq!(candidate(vec![3,\
    \ 1, 2, 4, 5]), vec![1, 4, 12, 20]);\n    assert_eq!(candidate(vec![1, 2, 3]),\
    \ vec![2, 6]);\n    assert_eq!(candidate(vec![3, 2, 1]), vec![2, 2]);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1, 0, 4]), vec![2, 2, 0, 16]);\n    assert_eq!(candidate(vec![1]), Vec::<isize>::new());\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823099
- exit_code: 101
  program: "/// xs represent coefficients of a polynomial.\n/// xs[0] + xs[1] * x\
    \ + xs[2] * x^2 + ....\n/// Return derivative of this polynomial in the same form.\n\
    /// >>> derivative([3, 1, 2, 4, 5])\n/// [1, 4, 12, 20]\n/// >>> derivative([1,\
    \ 2, 3])\n/// [2, 6]\nfn derivative(xs: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ degree = xs.len() - 1;\n    let mut x = xs.clone();\n    let mut result = Vec::new();\n\
    \    while degree >= 1 {\n        result.push(x[0] * degree as isize);\n     \
    \   x.remove(0);\n        degree -= 1;\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = derivative;\n    assert_eq!(candidate(vec![3, 1, 2, 4, 5]),\
    \ vec![1, 4, 12, 20]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 6]);\n\
    \    assert_eq!(candidate(vec![3, 2, 1]), vec![2, 2]);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1, 0, 4]), vec![2, 2, 0, 16]);\n    assert_eq!(candidate(vec![1]), Vec::<isize>::new());\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[12, 3, 4, 4]`,\n right: `[1, 4, 12, 20]`', /tmp/tmp3n5h8ylb.rs:22:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823099
- exit_code: 0
  program: "/// xs represent coefficients of a polynomial.\n/// xs[0] + xs[1] * x\
    \ + xs[2] * x^2 + ....\n/// Return derivative of this polynomial in the same form.\n\
    /// >>> derivative([3, 1, 2, 4, 5])\n/// [1, 4, 12, 20]\n/// >>> derivative([1,\
    \ 2, 3])\n/// [2, 6]\nfn derivative(xs: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ coeffs = Vec::new();\n    for i in 1..xs.len() {\n        coeffs.push(xs[i]\
    \ * i as isize);\n    }\n    coeffs\n}\n\nfn main() {\n    let candidate = derivative;\n\
    \    assert_eq!(candidate(vec![3, 1, 2, 4, 5]), vec![1, 4, 12, 20]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 6]);\n    assert_eq!(candidate(vec![3, 2, 1]), vec![2, 2]);\n\
    \    assert_eq!(candidate(vec![3, 2, 1, 0, 4]), vec![2, 2, 0, 16]);\n    assert_eq!(candidate(vec![1]),\
    \ Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823099
- exit_code: 0
  program: "/// xs represent coefficients of a polynomial.\n/// xs[0] + xs[1] * x\
    \ + xs[2] * x^2 + ....\n/// Return derivative of this polynomial in the same form.\n\
    /// >>> derivative([3, 1, 2, 4, 5])\n/// [1, 4, 12, 20]\n/// >>> derivative([1,\
    \ 2, 3])\n/// [2, 6]\nfn derivative(xs: Vec<isize>) -> Vec<isize> {\n    xs.iter().enumerate().map(|(i,\
    \ &x)| x * i as isize).skip(1).collect()\n}\n\nfn main() {\n    let candidate\
    \ = derivative;\n    assert_eq!(candidate(vec![3, 1, 2, 4, 5]), vec![1, 4, 12,\
    \ 20]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 6]);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), vec![2, 2]);\n    assert_eq!(candidate(vec![3, 2, 1, 0, 4]), vec![2,\
    \ 2, 0, 16]);\n    assert_eq!(candidate(vec![1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823099
- exit_code: 0
  program: "/// xs represent coefficients of a polynomial.\n/// xs[0] + xs[1] * x\
    \ + xs[2] * x^2 + ....\n/// Return derivative of this polynomial in the same form.\n\
    /// >>> derivative([3, 1, 2, 4, 5])\n/// [1, 4, 12, 20]\n/// >>> derivative([1,\
    \ 2, 3])\n/// [2, 6]\nfn derivative(xs: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ res = Vec::new();\n    for i in 1..xs.len() {\n        res.push(xs[i] * i as\
    \ isize);\n    }\n    res\n}\n\nfn main() {\n    let candidate = derivative;\n\
    \    assert_eq!(candidate(vec![3, 1, 2, 4, 5]), vec![1, 4, 12, 20]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 6]);\n    assert_eq!(candidate(vec![3, 2, 1]), vec![2, 2]);\n\
    \    assert_eq!(candidate(vec![3, 2, 1, 0, 4]), vec![2, 2, 0, 16]);\n    assert_eq!(candidate(vec![1]),\
    \ Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823099
- exit_code: 0
  program: "/// xs represent coefficients of a polynomial.\n/// xs[0] + xs[1] * x\
    \ + xs[2] * x^2 + ....\n/// Return derivative of this polynomial in the same form.\n\
    /// >>> derivative([3, 1, 2, 4, 5])\n/// [1, 4, 12, 20]\n/// >>> derivative([1,\
    \ 2, 3])\n/// [2, 6]\nfn derivative(xs: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ res = vec![];\n    for (i, &x) in xs.iter().enumerate() {\n        if i == 0\
    \ {\n            continue;\n        }\n        res.push(x * i as isize);\n   \
    \ }\n    res\n}\n\nfn main() {\n    let candidate = derivative;\n    assert_eq!(candidate(vec![3,\
    \ 1, 2, 4, 5]), vec![1, 4, 12, 20]);\n    assert_eq!(candidate(vec![1, 2, 3]),\
    \ vec![2, 6]);\n    assert_eq!(candidate(vec![3, 2, 1]), vec![2, 2]);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1, 0, 4]), vec![2, 2, 0, 16]);\n    assert_eq!(candidate(vec![1]), Vec::<isize>::new());\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823099
- exit_code: 101
  program: "/// xs represent coefficients of a polynomial.\n/// xs[0] + xs[1] * x\
    \ + xs[2] * x^2 + ....\n/// Return derivative of this polynomial in the same form.\n\
    /// >>> derivative([3, 1, 2, 4, 5])\n/// [1, 4, 12, 20]\n/// >>> derivative([1,\
    \ 2, 3])\n/// [2, 6]\nfn derivative(xs: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ xs = xs;\n    xs.drain(1..);\n    xs.iter().enumerate().map(|(i, &x)| x * (i\
    \ as isize + 1)).collect()\n}\n\nfn main() {\n    let candidate = derivative;\n\
    \    assert_eq!(candidate(vec![3, 1, 2, 4, 5]), vec![1, 4, 12, 20]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 6]);\n    assert_eq!(candidate(vec![3, 2, 1]), vec![2, 2]);\n\
    \    assert_eq!(candidate(vec![3, 2, 1, 0, 4]), vec![2, 2, 0, 16]);\n    assert_eq!(candidate(vec![1]),\
    \ Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3]`,\n right: `[1, 4, 12, 20]`', /tmp/tmpk713ex3m.rs:16:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823099
- exit_code: 0
  program: "/// xs represent coefficients of a polynomial.\n/// xs[0] + xs[1] * x\
    \ + xs[2] * x^2 + ....\n/// Return derivative of this polynomial in the same form.\n\
    /// >>> derivative([3, 1, 2, 4, 5])\n/// [1, 4, 12, 20]\n/// >>> derivative([1,\
    \ 2, 3])\n/// [2, 6]\nfn derivative(xs: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ ys = vec![];\n    for i in 1..xs.len() {\n        ys.push(xs[i] * i as isize);\n\
    \    }\n    ys\n}\n\nfn main() {\n    let candidate = derivative;\n    assert_eq!(candidate(vec![3,\
    \ 1, 2, 4, 5]), vec![1, 4, 12, 20]);\n    assert_eq!(candidate(vec![1, 2, 3]),\
    \ vec![2, 6]);\n    assert_eq!(candidate(vec![3, 2, 1]), vec![2, 2]);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1, 0, 4]), vec![2, 2, 0, 16]);\n    assert_eq!(candidate(vec![1]), Vec::<isize>::new());\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823099
- exit_code: 0
  program: "/// xs represent coefficients of a polynomial.\n/// xs[0] + xs[1] * x\
    \ + xs[2] * x^2 + ....\n/// Return derivative of this polynomial in the same form.\n\
    /// >>> derivative([3, 1, 2, 4, 5])\n/// [1, 4, 12, 20]\n/// >>> derivative([1,\
    \ 2, 3])\n/// [2, 6]\nfn derivative(xs: Vec<isize>) -> Vec<isize> {\n    if xs.len()\
    \ < 2 {\n        return vec![];\n    }\n    xs.iter().enumerate().skip(1).map(|(index,\
    \ x)| index as isize * x).collect()\n}\n\nfn main() {\n    let candidate = derivative;\n\
    \    assert_eq!(candidate(vec![3, 1, 2, 4, 5]), vec![1, 4, 12, 20]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 6]);\n    assert_eq!(candidate(vec![3, 2, 1]), vec![2, 2]);\n\
    \    assert_eq!(candidate(vec![3, 2, 1, 0, 4]), vec![2, 2, 0, 16]);\n    assert_eq!(candidate(vec![1]),\
    \ Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823099
- exit_code: 0
  program: "/// xs represent coefficients of a polynomial.\n/// xs[0] + xs[1] * x\
    \ + xs[2] * x^2 + ....\n/// Return derivative of this polynomial in the same form.\n\
    /// >>> derivative([3, 1, 2, 4, 5])\n/// [1, 4, 12, 20]\n/// >>> derivative([1,\
    \ 2, 3])\n/// [2, 6]\nfn derivative(xs: Vec<isize>) -> Vec<isize> {\n    xs.iter().enumerate().map(|(i,\
    \ x)| i as isize * x).skip(1).collect()\n}\n\nfn main() {\n    let candidate =\
    \ derivative;\n    assert_eq!(candidate(vec![3, 1, 2, 4, 5]), vec![1, 4, 12, 20]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 6]);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), vec![2, 2]);\n    assert_eq!(candidate(vec![3, 2, 1, 0, 4]), vec![2,\
    \ 2, 0, 16]);\n    assert_eq!(candidate(vec![1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823099
- exit_code: 0
  program: "/// xs represent coefficients of a polynomial.\n/// xs[0] + xs[1] * x\
    \ + xs[2] * x^2 + ....\n/// Return derivative of this polynomial in the same form.\n\
    /// >>> derivative([3, 1, 2, 4, 5])\n/// [1, 4, 12, 20]\n/// >>> derivative([1,\
    \ 2, 3])\n/// [2, 6]\nfn derivative(xs: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ result = Vec::new();\n    for (i, x) in xs.iter().enumerate() {\n        if\
    \ i == 0 {\n            continue;\n        }\n        result.push(x * i as isize);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = derivative;\n    assert_eq!(candidate(vec![3,\
    \ 1, 2, 4, 5]), vec![1, 4, 12, 20]);\n    assert_eq!(candidate(vec![1, 2, 3]),\
    \ vec![2, 6]);\n    assert_eq!(candidate(vec![3, 2, 1]), vec![2, 2]);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1, 0, 4]), vec![2, 2, 0, 16]);\n    assert_eq!(candidate(vec![1]), Vec::<isize>::new());\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823099
- exit_code: 0
  program: "/// xs represent coefficients of a polynomial.\n/// xs[0] + xs[1] * x\
    \ + xs[2] * x^2 + ....\n/// Return derivative of this polynomial in the same form.\n\
    /// >>> derivative([3, 1, 2, 4, 5])\n/// [1, 4, 12, 20]\n/// >>> derivative([1,\
    \ 2, 3])\n/// [2, 6]\nfn derivative(xs: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ result = Vec::new();\n    for i in 1..xs.len() {\n        result.push(xs[i]\
    \ * i as isize);\n    }\n    result\n}\n\nfn main() {\n    let candidate = derivative;\n\
    \    assert_eq!(candidate(vec![3, 1, 2, 4, 5]), vec![1, 4, 12, 20]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 6]);\n    assert_eq!(candidate(vec![3, 2, 1]), vec![2, 2]);\n\
    \    assert_eq!(candidate(vec![3, 2, 1, 0, 4]), vec![2, 2, 0, 16]);\n    assert_eq!(candidate(vec![1]),\
    \ Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823099
- exit_code: 101
  program: "/// xs represent coefficients of a polynomial.\n/// xs[0] + xs[1] * x\
    \ + xs[2] * x^2 + ....\n/// Return derivative of this polynomial in the same form.\n\
    /// >>> derivative([3, 1, 2, 4, 5])\n/// [1, 4, 12, 20]\n/// >>> derivative([1,\
    \ 2, 3])\n/// [2, 6]\nfn derivative(xs: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ new_xs = Vec::new();\n    let mut i = 1;\n    for x in xs.iter() {\n       \
    \ new_xs.push(x * i);\n        i += 1;\n    }\n    return new_xs[1..].to_vec();\n\
    }\n\nfn main() {\n    let candidate = derivative;\n    assert_eq!(candidate(vec![3,\
    \ 1, 2, 4, 5]), vec![1, 4, 12, 20]);\n    assert_eq!(candidate(vec![1, 2, 3]),\
    \ vec![2, 6]);\n    assert_eq!(candidate(vec![3, 2, 1]), vec![2, 2]);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1, 0, 4]), vec![2, 2, 0, 16]);\n    assert_eq!(candidate(vec![1]), Vec::<isize>::new());\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 6, 16, 25]`,\n right: `[1, 4, 12, 20]`', /tmp/tmpk7q8w08n.rs:20:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823099
- exit_code: 101
  program: "/// xs represent coefficients of a polynomial.\n/// xs[0] + xs[1] * x\
    \ + xs[2] * x^2 + ....\n/// Return derivative of this polynomial in the same form.\n\
    /// >>> derivative([3, 1, 2, 4, 5])\n/// [1, 4, 12, 20]\n/// >>> derivative([1,\
    \ 2, 3])\n/// [2, 6]\nfn derivative(xs: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ n = xs.len();\n    let mut dxs = vec![0; n - 1];\n    for i in 0..n {\n    \
    \    dxs[i] = xs[i] * (n - i - 1) as isize;\n    }\n    dxs\n}\n\nfn main() {\n\
    \    let candidate = derivative;\n    assert_eq!(candidate(vec![3, 1, 2, 4, 5]),\
    \ vec![1, 4, 12, 20]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 6]);\n\
    \    assert_eq!(candidate(vec![3, 2, 1]), vec![2, 2]);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1, 0, 4]), vec![2, 2, 0, 16]);\n    assert_eq!(candidate(vec![1]), Vec::<isize>::new());\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 4 but the
    index is 4'', /tmp/tmpgg_ewywx.rs:12:9

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823099
- exit_code: 0
  program: "/// xs represent coefficients of a polynomial.\n/// xs[0] + xs[1] * x\
    \ + xs[2] * x^2 + ....\n/// Return derivative of this polynomial in the same form.\n\
    /// >>> derivative([3, 1, 2, 4, 5])\n/// [1, 4, 12, 20]\n/// >>> derivative([1,\
    \ 2, 3])\n/// [2, 6]\nfn derivative(xs: Vec<isize>) -> Vec<isize> {\n    (1..xs.len()).map(|i|\
    \ i as isize * xs[i]).collect()\n}\n\nfn main() {\n    let candidate = derivative;\n\
    \    assert_eq!(candidate(vec![3, 1, 2, 4, 5]), vec![1, 4, 12, 20]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 6]);\n    assert_eq!(candidate(vec![3, 2, 1]), vec![2, 2]);\n\
    \    assert_eq!(candidate(vec![3, 2, 1, 0, 4]), vec![2, 2, 0, 16]);\n    assert_eq!(candidate(vec![1]),\
    \ Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823099
- exit_code: 0
  program: "/// xs represent coefficients of a polynomial.\n/// xs[0] + xs[1] * x\
    \ + xs[2] * x^2 + ....\n/// Return derivative of this polynomial in the same form.\n\
    /// >>> derivative([3, 1, 2, 4, 5])\n/// [1, 4, 12, 20]\n/// >>> derivative([1,\
    \ 2, 3])\n/// [2, 6]\nfn derivative(xs: Vec<isize>) -> Vec<isize> {\n    if xs.len()\
    \ == 0 {\n        return xs;\n    }\n\n    let mut result = Vec::new();\n    for\
    \ (i, x) in xs.iter().enumerate() {\n        if i == 0 {\n            continue;\n\
    \        }\n        result.push(x * i as isize);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = derivative;\n    assert_eq!(candidate(vec![3, 1, 2, 4,\
    \ 5]), vec![1, 4, 12, 20]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2,\
    \ 6]);\n    assert_eq!(candidate(vec![3, 2, 1]), vec![2, 2]);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1, 0, 4]), vec![2, 2, 0, 16]);\n    assert_eq!(candidate(vec![1]), Vec::<isize>::new());\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823099
- exit_code: 101
  program: "/// xs represent coefficients of a polynomial.\n/// xs[0] + xs[1] * x\
    \ + xs[2] * x^2 + ....\n/// Return derivative of this polynomial in the same form.\n\
    /// >>> derivative([3, 1, 2, 4, 5])\n/// [1, 4, 12, 20]\n/// >>> derivative([1,\
    \ 2, 3])\n/// [2, 6]\nfn derivative(xs: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ result = Vec::new();\n    let mut deg = xs.len() - 1;\n    for i in 0..xs.len()\
    \ {\n        result.push(xs[i] * deg as isize);\n        deg -= 1;\n    }\n  \
    \  result\n}\n\nfn main() {\n    let candidate = derivative;\n    assert_eq!(candidate(vec![3,\
    \ 1, 2, 4, 5]), vec![1, 4, 12, 20]);\n    assert_eq!(candidate(vec![1, 2, 3]),\
    \ vec![2, 6]);\n    assert_eq!(candidate(vec![3, 2, 1]), vec![2, 2]);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1, 0, 4]), vec![2, 2, 0, 16]);\n    assert_eq!(candidate(vec![1]), Vec::<isize>::new());\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmp5tt9gv5j.rs:13:9

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823099
- exit_code: 0
  program: "/// xs represent coefficients of a polynomial.\n/// xs[0] + xs[1] * x\
    \ + xs[2] * x^2 + ....\n/// Return derivative of this polynomial in the same form.\n\
    /// >>> derivative([3, 1, 2, 4, 5])\n/// [1, 4, 12, 20]\n/// >>> derivative([1,\
    \ 2, 3])\n/// [2, 6]\nfn derivative(xs: Vec<isize>) -> Vec<isize> {\n    // TODO:\
    \ implement me\n    // hint: use range and skip()\n    xs.iter().enumerate().skip(1).map(|(i,\
    \ x)| x * i as isize).collect()\n}\n\nfn main() {\n    let candidate = derivative;\n\
    \    assert_eq!(candidate(vec![3, 1, 2, 4, 5]), vec![1, 4, 12, 20]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 6]);\n    assert_eq!(candidate(vec![3, 2, 1]), vec![2, 2]);\n\
    \    assert_eq!(candidate(vec![3, 2, 1, 0, 4]), vec![2, 2, 0, 16]);\n    assert_eq!(candidate(vec![1]),\
    \ Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823099
- exit_code: 1
  program: "/// xs represent coefficients of a polynomial.\n/// xs[0] + xs[1] * x\
    \ + xs[2] * x^2 + ....\n/// Return derivative of this polynomial in the same form.\n\
    /// >>> derivative([3, 1, 2, 4, 5])\n/// [1, 4, 12, 20]\n/// >>> derivative([1,\
    \ 2, 3])\n/// [2, 6]\nfn derivative(xs: Vec<isize>) -> Vec<isize> {\n    // ...\n\
    \    let mut result = vec![];\n    let mut count = 1;\n    for i in xs {\n   \
    \     if count > xs.len() - 1 {\n            break;\n        }\n        let mut\
    \ val = i * count;\n        result.push(val);\n        count += 1;\n    }\n  \
    \  result\n}\n\nfn main() {\n    let candidate = derivative;\n    assert_eq!(candidate(vec![3,\
    \ 1, 2, 4, 5]), vec![1, 4, 12, 20]);\n    assert_eq!(candidate(vec![1, 2, 3]),\
    \ vec![2, 6]);\n    assert_eq!(candidate(vec![3, 2, 1]), vec![2, 2]);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1, 0, 4]), vec![2, 2, 0, 16]);\n    assert_eq!(candidate(vec![1]), Vec::<isize>::new());\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpb4d95_74.rs:16:27\n   |\n\
    16 |         let mut val = i * count;\n   |                           ^^^^^ expected\
    \ `isize`, found `usize`\n\nerror[E0277]: cannot multiply `isize` by `usize`\n\
    \  --> /tmp/tmpb4d95_74.rs:16:25\n   |\n16 |         let mut val = i * count;\n\
    \   |                         ^ no implementation for `isize * usize`\n   |\n\
    \   = help: the trait `Mul<usize>` is not implemented for `isize`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659823099
