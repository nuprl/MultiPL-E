name: HumanEval_90_next_smallest
language: rs
prompt: "/// You are given a list of integers.\n/// Write a function next_smallest()\
  \ that returns the 2nd smallest element of the list.\n/// Return None if there is\
  \ no such element.\n/// next_smallest([1, 2, 3, 4, 5]) == 2\n/// next_smallest([5,\
  \ 1, 4, 3, 2]) == 2\n/// next_smallest([]) == None\n/// next_smallest([1, 1]) ==\
  \ None\nfn next_smallest(lst: Vec<isize>) -> Option<isize> {\n"
tests: "}\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
  \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
  \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
  \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
  \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n}\n"
completions: ['    unimplemented!()', "    let mut lst: Vec<isize> = lst;\n    lst.sort();\n\
    \    for (i, e) in lst.iter().enumerate() {\n        if i > 0 && e != &lst[i -\
    \ 1] {\n            return Some(*e);\n        }\n    }\n    None", "    let mut\
    \ lst = lst;\n    lst.sort();\n    lst.dedup();\n    match lst.len() {\n     \
    \   0 => None,\n        1 => None,\n        _ => Some(lst[1]),\n    }", "    let\
    \ mut lst = lst;\n    lst.sort();\n    lst.dedup();\n    lst.get(1).cloned()",
  "    if lst.len() < 2 {\n        return None;\n    }\n    let mut min_val = isize::max_value();\n\
    \    let mut min_val2 = isize::max_value();\n    for num in lst {\n        if\
    \ num < min_val {\n            min_val2 = min_val;\n            min_val = num;\n\
    \        } else if num < min_val2 {\n            min_val2 = num;\n        }\n\
    \    }\n    if min_val2 == isize::max_value() {\n        None\n    } else {\n\
    \        Some(min_val2)\n    }", '    lst.iter().enumerate().skip(1).min_by_key(|&(_,
    &x)| x).map(|(_, &x)| x)', "    let mut lst = lst;\n    lst.sort();\n    lst.dedup();\n\
    \    match lst.len() {\n        1 => None,\n        _ => Some(lst[1]),\n    }",
  "    if lst.len() < 2 {\n        return None;\n    }\n    let mut smallest = lst[0];\n\
    \    let mut next_smallest = lst[1];\n    for (i, x) in lst.iter().enumerate()\
    \ {\n        if i == 0 {\n            continue;\n        }\n        if x < &smallest\
    \ {\n            next_smallest = smallest;\n            smallest = *x;\n     \
    \   } else if x > &smallest && x < &next_smallest {\n            next_smallest\
    \ = *x;\n        }\n    }\n    Some(next_smallest)", "    let mut small = std::isize::MAX;\n\
    \    let mut next_small = std::isize::MAX;\n    for x in lst {\n        if x <\
    \ small {\n            next_small = small;\n            small = x;\n        }\
    \ else if x < next_small {\n            next_small = x;\n        }\n    }\n  \
    \  if next_small != std::isize::MAX {\n        Some(next_small)\n    } else {\n\
    \        None\n    }", "    let mut sorted = lst.clone();\n    sorted.sort();\n\
    \    for i in 0..sorted.len() {\n        if sorted[i] != sorted[i + 1] {\n   \
    \         return Some(sorted[i + 1]);\n        }\n    }\n    None", "    if lst.len()\
    \ == 0 {\n        return None;\n    }\n\n    let mut lst_iter = lst.iter();\n\
    \    let mut smallest = lst_iter.next().unwrap();\n    let mut next_smallest =\
    \ smallest;\n\n    for x in lst_iter {\n        if x < &smallest {\n         \
    \   next_smallest = *smallest;\n            smallest = *x;\n        } else if\
    \ x < &next_smallest {\n            next_smallest = *x;\n        }\n    }\n\n\
    \    if next_smallest == smallest {\n        None\n    } else {\n        Some(next_smallest)\n\
    \    }", "    lst.into_iter().fold(\n        (None, isize::MAX),\n        |(second_smallest,\
    \ smallest), elem| if elem < smallest {\n            (Some(smallest), elem)\n\
    \        } else if elem < second_smallest.unwrap_or(smallest) {\n            (Some(elem),\
    \ smallest)\n        } else {\n            (second_smallest, smallest)\n     \
    \   },\n    )\n    .0", '    unimplemented!();', "    if lst.len() < 2 {\n   \
    \     return None;\n    }\n    let mut lst = lst;\n    lst.sort();\n    let min\
    \ = lst[0];\n    lst.remove(0);\n    if lst.contains(&min) {\n        None\n \
    \   } else {\n        Some(lst[0])\n    }", "    let mut sorted = lst.clone();\n\
    \    sorted.sort();\n    let mut prev = None;\n    for e in sorted {\n       \
    \ if prev.is_some() && prev.unwrap() != e {\n            return Some(e);\n   \
    \     }\n        prev = Some(e);\n    }\n    None", '    unimplemented!()', " \
    \   if lst.len() == 0 {\n        return None;\n    }\n    if lst.len() == 1 {\n\
    \        return None;\n    }\n    let mut min_num: isize = lst[0];\n    let mut\
    \ min_num_count: usize = 0;\n    let mut second_min_num: isize = lst[0];\n   \
    \ let mut second_min_num_count: usize = 0;\n    for i in lst {\n        if i <\
    \ min_num {\n            second_min_num = min_num;\n            second_min_num_count\
    \ = min_num_count;\n            min_num = i;\n            min_num_count = 1;\n\
    \        } else if i == min_num {\n            min_num_count += 1;\n        }\
    \ else if i < second_min_num {\n            second_min_num = i;\n            second_min_num_count\
    \ = 1;\n        } else if i == second_min_num {\n            second_min_num_count\
    \ += 1;\n        }\n    }\n    if min_num == second_min_num {\n        return\
    \ None;\n    }\n    return Some(second_min_num);", "    let mut min = None;\n\
    \    let mut min2 = None;\n    for &v in &lst {\n        if min.is_none() || v\
    \ < min.unwrap() {\n            min2 = min;\n            min = Some(v);\n    \
    \    } else if min2.is_none() || v < min2.unwrap() {\n            min2 = Some(v);\n\
    \        }\n    }\n    min2", "    if lst.len() < 2 {\n        return None;\n\
    \    }\n    let mut lst = lst;\n    lst.sort();\n    for (index, num) in lst.iter().enumerate()\
    \ {\n        if index + 1 < lst.len() && lst[index + 1] != *num {\n          \
    \  return Some(lst[index + 1]);\n        }\n    }\n    None", "    if lst.len()\
    \ < 2 {\n        return None;\n    }\n    let mut lst = lst;\n    lst.sort();\n\
    \    let mut v: isize = isize::min_value();\n    for &x in lst.iter() {\n    \
    \    if x != v {\n            return Some(x);\n        }\n        v = x;\n   \
    \ }\n    None"]
stop_tokens:
- "\n}"
