name: HumanEval_145_order_by_points
language: rs
prompt: "/// Write a function which sorts the given list of integers\n/// in ascending\
  \ order according to the sum of their digits.\n/// Note: if there are several items\
  \ with similar sum of their digits,\n/// order them based on their index in original\
  \ list.\n/// For example:\n/// >>> order_by_points([1, 11, -1, -11, -12]) == [-1,\
  \ -11, 1, -12, 11]\n/// >>> order_by_points([]) == []\nfn order_by_points(nums:\
  \ Vec<isize>) -> Vec<isize> {\n"
tests: "}\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
  \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
  \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
  \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
  \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
  \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
  \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
  \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
  \ 23, 6, 6]);\n}\n"
completions: ["    // your code here\n    Vec::new()", "    let mut mapped = nums.iter().enumerate().map(|(i,\
    \ &n)| (i, sum_digits(n))).collect::<Vec<_>>();\n    mapped.sort_by(|a, b| a.1.cmp(&b.1));\n\
    \    mapped.iter().map(|&(_, s)| s).collect()", "    let mut v = nums.clone();\n\
    \    v.sort_by(|a, b| (sum_digits(*a), a).cmp(&(sum_digits(*b), b)));\n    v",
  "    fn digit_sum(x: isize) -> usize {\n        let mut s = 0;\n        let mut\
    \ x = x;\n        while x != 0 {\n            s += (x % 10) as usize;\n      \
    \      x /= 10;\n        }\n        s\n    }\n\n    nums.into_iter().enumerate().sorted_by_key(|(i,\
    \ x)| (digit_sum(*x), *i)).map(|(_, x)| x).collect()", "    // TODO\n    vec![]",
  "    let sum_of_digits = |num: &isize| -> isize {\n        let mut sum = 0;\n  \
    \      let mut num = *num;\n        while num != 0 {\n            sum += num %\
    \ 10;\n            num /= 10;\n        }\n        sum\n    };\n    let mut vec\
    \ = nums.to_vec();\n    vec.sort_by_key(|&num| sum_of_digits(&num));\n    vec",
  '    unimplemented!();', '    unimplemented!();', '    nums.iter().enumerate().sorted_by(|a,
    b| a.1.abs().sum::<isize>().cmp(&b.1.abs().sum())).map(|x| x.1).collect()', '    unimplemented!()',
  "    if nums.is_empty() {\n        return vec![];\n    }\n    let mut sorted_nums\
    \ = nums.clone();\n    sorted_nums.sort_by(|a, b| a.abs().to_string().chars().map(|d|\
    \ d.to_digit(10).unwrap()).sum::<u32>().cmp(&b.abs().to_string().chars().map(|d|\
    \ d.to_digit(10).unwrap()).sum::<u32>()));\n    sorted_nums", '    nums.into_iter().enumerate().map(|(i,
    n)| (i, n, digits(n).iter().sum())).collect::<Vec<_>>().sort_by(|(i, n, s), (j,
    m, t)| if s != t { s.cmp(&t) } else { i.cmp(&j) }).into_iter().map(|(_, n, _)|
    n).collect()', "    let mut nums = nums;\n    nums.sort_by_key(|x| x.abs());\n\
    \    nums", "    let mut result = nums.clone();\n    let mut sums: Vec<(usize,\
    \ isize)> = result\n        .iter()\n        .enumerate()\n        .map(|(i, n)|\
    \ (i, n.abs()))\n        .collect();\n    sums.sort_by(|a, b| (a.1 % 10 + a.1\
    \ / 10).cmp(&(b.1 % 10 + b.1 / 10)));\n    for (i, &(j, _)) in sums.iter().enumerate()\
    \ {\n        result[i] = nums[j];\n    }\n    result", "    let mut res = Vec::new();\n\
    \    if nums.len() == 0 {\n        return res;\n    }\n    let mut myVec = Vec::new();\n\
    \    let mut sum_num: usize;\n    for i in 0..nums.len() {\n        sum_num =\
    \ 0;\n        let mut val = nums[i];\n        while val != 0 {\n            sum_num\
    \ += (val % 10) as usize;\n            val /= 10;\n        }\n        myVec.push((sum_num,\
    \ i));\n    }\n    myVec.sort();\n    for i in 0..myVec.len() {\n        res.push(nums[myVec[i].1]);\n\
    \    }\n    res", '    nums.into_iter().enumerate().sorted_by_key(|(x, _)| *x).collect()',
  "    let v: Vec<_> = nums.iter().enumerate().map(|(i, &x)| (i, sum_digits(x), x)).collect();\n\
    \    let mut v = v.into_iter().collect::<Vec<_>>();\n    v.sort_by(|&(a, b, _),\
    \ &(c, d, _)| b.cmp(&d).then(a.cmp(&c)));\n    v.into_iter().map(|(_, _, x)| x).collect()",
  "    if nums.is_empty() {\n        return nums;\n    }\n    let mut nums = nums;\n\
    \    nums.sort_by(|a, b| a.abs().to_string().chars().map(|c| c.to_digit(10).unwrap()).sum::<u32>().cmp(&b.abs().to_string().chars().map(|c|\
    \ c.to_digit(10).unwrap()).sum::<u32>()));\n    nums", '    nums.into_iter().enumerate().sorted_by_key(|x|
    (x.1.abs() as usize, x.0)).map(|x| x.1).collect()', "    nums.into_iter().enumerate().map(|(idx,\
    \ n)| (idx, n, n.abs() as usize)).collect::<Vec<_>>().sort_by(|(idx1, n1, n1sum),\
    \ (idx2, n2, n2sum)| {\n        n1sum.cmp(&n2sum).then(idx1.cmp(&idx2))\n    }).into_iter().map(|(_,\
    \ n, _)| n).collect()"]
stop_tokens:
- "\n}"
