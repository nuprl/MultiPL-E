name: HumanEval_127_intersection
language: rs
results:
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    // Calculate intersection length\n    let length\
    \ = if interval1.0 > interval2.0 {\n        if interval1.0 > interval2.1 {\n \
    \           0\n        } else {\n            (interval2.1 - interval1.0 + 1) as\
    \ usize\n        }\n    } else {\n        if interval2.0 > interval1.1 {\n   \
    \         0\n        } else {\n            (interval1.1 - interval2.0 + 1) as\
    \ usize\n        }\n    };\n    // Return if the length is prime\n    if length\
    \ == 0 {\n        \"NO\".to_string()\n    } else {\n        match is_prime(length)\
    \ {\n            true => \"YES\".to_string(),\n            false => \"NO\".to_string(),\n\
    \        }\n    }\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp6sgld70m.rs:36:15\n\
    \   |\n36 |         match is_prime(length) {\n   |               ^^^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n  let (start1, end1) = interval1;\n  let (start2,\
    \ end2) = interval2;\n  let mut int_s = 0;\n  let mut int_e = 0;\n  if (start1\
    \ > start2 && start1 < end2) || (start2 > start1 && start2 < end1) {\n    if start1\
    \ > start2 {\n      int_s = start1;\n    } else {\n      int_s = start2;\n   \
    \ }\n    if end1 < end2 {\n      int_e = end1;\n    } else {\n      int_e = end2;\n\
    \    }\n    let length = (int_e - int_s) + 1;\n    for i in 2..length {\n    \
    \  if length % i == 0 {\n        return \"NO\".to_string();\n      }\n    }\n\
    \    return \"YES\".to_string();\n  }\n  \"NO\".to_string()\n}\n\nfn main() {\n\
    \    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpt6lx4z78.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (i1_a, i1_b) = interval1;\n    let (i2_a,\
    \ i2_b) = interval2;\n    if i1_a > i2_b || i2_a > i1_b {\n        return \"NO\"\
    .to_string();\n    }\n    let interval = (std::cmp::max(i1_a, i2_a), std::cmp::min(i1_b,\
    \ i2_b));\n    if interval.1 - interval.0 <= 2 {\n        return \"NO\".to_string();\n\
    \    }\n    if (2..(interval.1 - interval.0)).any(|i| (interval.1 - interval.0)\
    \ % i == 0) {\n        return \"NO\".to_string();\n    }\n    \"YES\".to_string()\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"NO\"`,\n right: `\"YES\"`', /tmp/tmpe2etr072.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (s1, e1) = interval1;\n    let (s2, e2)\
    \ = interval2;\n    if s1 > e2 || s2 > e1 {\n        return \"NO\".to_string();\n\
    \    }\n    let int_start = if s1 > s2 { s1 } else { s2 };\n    let int_end =\
    \ if e1 < e2 { e1 } else { e2 };\n    let int_len = int_end - int_start + 1;\n\
    \    if int_len <= 2 {\n        return \"NO\".to_string();\n    }\n    for i in\
    \ 2..(int_len / 2 + 1) {\n        if int_len % i == 0 {\n            return \"\
    NO\".to_string();\n        }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n\
    \    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    // \n    // You can use the functions is_prime(n:\
    \ isize) and gcd(m: isize, n: isize)\n    // to determine whether a number is\
    \ prime and to find the greatest common divisor\n    // between two numbers, respectively.\n\
    \    // You can add a helper function of your own choice to this file.\n    //\n\
    \    // Good luck!\n    //\n    if interval1.0 > interval2.1 || interval2.0 >\
    \ interval1.1 {\n        return \"NO\".to_string();\n    }\n\n    let (a, b) =\
    \ (interval1.0, interval1.1);\n    let (c, d) = (interval2.0, interval2.1);\n\n\
    \    let (mut x, mut y) = (max(a, c), min(b, d));\n\n    // y - x is the length\
    \ of the intersection\n    if y - x <= 1 {\n        return \"NO\".to_string();\n\
    \    }\n\n    // gcd(y - x, x) is the length of the intersection\n    // if it\
    \ is prime, return \"YES\", otherwise, return \"NO\"\n    if is_prime(gcd(y -\
    \ x, x)) {\n        return \"YES\".to_string();\n    } else {\n        return\
    \ \"NO\".to_string();\n    }\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmp7vxd0xmm.rs:33:27\n\
    \   |\n33 |     let (mut x, mut y) = (max(a, c), min(b, d));\n   |           \
    \                ^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ function\n   |\n1  | use std::cmp::max;\n   |\n\nerror[E0425]: cannot find function\
    \ `min` in this scope\n  --> /tmp/tmp7vxd0xmm.rs:33:38\n   |\n33 |     let (mut\
    \ x, mut y) = (max(a, c), min(b, d));\n   |                                  \
    \    ^^^\n...\n49 | fn main() {\n   | --------- similarly named function `main`\
    \ defined here\n   |\nhelp: a function with a similar name exists\n   |\n33 |\
    \     let (mut x, mut y) = (max(a, c), main(b, d));\n   |                    \
    \                  ~~~~\nhelp: consider importing this function\n   |\n1  | use\
    \ std::cmp::min;\n   |\n\nerror[E0425]: cannot find function `is_prime` in this\
    \ scope\n  --> /tmp/tmp7vxd0xmm.rs:42:8\n   |\n42 |     if is_prime(gcd(y - x,\
    \ x)) {\n   |        ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find function `gcd` in this scope\n  --> /tmp/tmp7vxd0xmm.rs:42:17\n   |\n42\
    \ |     if is_prime(gcd(y - x, x)) {\n   |                 ^^^ not found in this\
    \ scope\n\nerror: aborting due to 4 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    // Minus one because they are inclusive\n \
    \   let (a, b) = (interval1.1 - interval1.0 - 1, interval2.1 - interval2.0 - 1);\n\
    \    if a == 0 || b == 0 {\n        return \"NO\".to_string();\n    }\n    if\
    \ a.gcd(&b) == 1 {\n        return \"YES\".to_string();\n    }\n    \"NO\".to_string()\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `gcd` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmp4r4m349s.rs:23:10\n   |\n23 |     if a.gcd(&b) == 1 {\n\
    \   |          ^^^ method not found in `isize`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    use std::cmp::{max, min};\n    if interval1.0\
    \ > interval2.1 || interval2.0 > interval1.1 {\n        return \"NO\".to_string();\n\
    \    }\n    let x = max(interval1.0, interval2.0);\n    let y = min(interval1.1,\
    \ interval2.1);\n    let z = if x > y { 0 } else { y - x + 1 };\n    match z {\n\
    \        2 | 3 | 5 | 7 => \"YES\".to_string(),\n        _ => \"NO\".to_string(),\n\
    \    }\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpjd_6af1n.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (interval1_start, interval1_end) = interval1;\n\
    \    let (interval2_start, interval2_end) = interval2;\n    let interval_start\
    \ = interval1_start.max(interval2_start);\n    let interval_end = interval1_end.min(interval2_end);\n\
    \    let mut is_prime = false;\n    if interval_start > interval_end {\n     \
    \   is_prime = false;\n    } else {\n        is_prime = is_prime_number(interval_end\
    \ - interval_start);\n    }\n    if is_prime {\n        \"YES\".to_string()\n\
    \    } else {\n        \"NO\".to_string()\n    }\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime_number` in this scope\n  -->\
    \ /tmp/tmp6rsr9oob.rs:26:20\n   |\n26 |         is_prime = is_prime_number(interval_end\
    \ - interval_start);\n   |                    ^^^^^^^^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (mut a, mut b) = interval1;\n    let (mut\
    \ c, mut d) = interval2;\n    if b < c || d < a {\n        return \"NO\".to_string();\n\
    \    }\n    if b > d {\n        b = d;\n    }\n    if a < c {\n        a = c;\n\
    \    }\n    let n = b - a + 1;\n    if is_prime(n) {\n        \"YES\".to_string()\n\
    \    } else {\n        \"NO\".to_string()\n    }\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp7onzy3wn.rs:30:8\n\
    \   |\n30 |     if is_prime(n) {\n   |        ^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (left, right) = (interval1.0, interval1.1);\n\
    \    let (other_left, other_right) = (interval2.0, interval2.1);\n    let start\
    \ = std::cmp::max(left, other_left);\n    let end = std::cmp::min(right, other_right);\n\
    \    if start > end {\n        return \"NO\".to_string();\n    }\n    if is_prime(end\
    \ - start + 1) {\n        return \"YES\".to_string();\n    }\n    \"NO\".to_string()\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp06etzie7.rs:25:8\n\
    \   |\n25 |     if is_prime(end - start + 1) {\n   |        ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let inter = (std::cmp::max(interval1.0, interval2.0),\
    \ std::cmp::min(interval1.1, interval2.1));\n    if inter.0 > inter.1 {\n    \
    \    \"NO\".to_string()\n    } else {\n        let len = inter.1 - inter.0 + 1;\n\
    \        if len < 2 {\n            \"NO\".to_string()\n        } else {\n    \
    \        if len == 2 {\n                \"YES\".to_string()\n            } else\
    \ {\n                let mut i = 2;\n                while i * i <= len {\n  \
    \                  if len % i == 0 {\n                        return \"NO\".to_string();\n\
    \                    }\n                    i += 1;\n                }\n     \
    \           \"YES\".to_string()\n            }\n        }\n    }\n}\n\nfn main()\
    \ {\n    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp1ke57vg8.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    if interval1.0 > interval2.1 || interval2.0\
    \ > interval1.1 {\n        return \"NO\".to_string();\n    }\n    let x = isize::max(interval1.0,\
    \ interval2.0);\n    let y = isize::min(interval1.1, interval2.1);\n    let len\
    \ = y - x + 1;\n    if len > 2 && (len % 2 == 0 || len % 3 == 0 || len % 5 ==\
    \ 0 || len % 7 == 0) {\n        return \"NO\".to_string();\n    }\n    \"YES\"\
    .to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp8mdv14e0.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (i1_start, i1_end) = interval1;\n    let\
    \ (i2_start, i2_end) = interval2;\n    if i1_end < i2_start || i2_end < i1_start\
    \ {\n        return \"NO\".to_string();\n    }\n    let (start, end) = (cmp::max(i1_start,\
    \ i2_start), cmp::min(i1_end, i2_end));\n    let mut acc = start;\n    for i in\
    \ start + 1..end {\n        acc = acc.gcd(i);\n    }\n    if acc == 1 {\n    \
    \    \"YES\".to_string()\n    } else {\n        \"NO\".to_string()\n    }\n}\n\
    \nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n\
    \  --> /tmp/tmpp65iw90o.rs:23:25\n   |\n23 |     let (start, end) = (cmp::max(i1_start,\
    \ i2_start), cmp::min(i1_end, i2_end));\n   |                         ^^^ use\
    \ of undeclared crate or module `cmp`\n\nerror[E0433]: failed to resolve: use\
    \ of undeclared crate or module `cmp`\n  --> /tmp/tmpp65iw90o.rs:23:55\n   |\n\
    23 |     let (start, end) = (cmp::max(i1_start, i2_start), cmp::min(i1_end, i2_end));\n\
    \   |                                                       ^^^ use of undeclared\
    \ crate or module `cmp`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    if interval1.0 >= interval2.1 || interval2.0\
    \ >= interval1.1 {\n        return \"NO\".to_string();\n    }\n    let start =\
    \ if interval1.0 > interval2.0 { interval1.0 } else { interval2.0 };\n    let\
    \ end = if interval1.1 < interval2.1 { interval1.1 } else { interval2.1 };\n \
    \   let mut is_prime = true;\n    let mut iterator = (start..end).map(|i| (i -\
    \ start + 1) as usize);\n    while is_prime && iterator.next().unwrap() > 1 {\n\
    \        is_prime = iterator.clone().take_while(|n| *n % iterator.next().unwrap()\
    \ != 0).count() == 0;\n    }\n    if is_prime { \"YES\".to_string() } else { \"\
    NO\".to_string() }\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpgx9xkfm6.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (a, b) = interval1;\n    let (c, d) = interval2;\n\
    \    let upper = a.max(c);\n    let lower = b.min(d);\n    if lower < upper {\n\
    \        return \"NO\".to_string();\n    }\n    let range = (lower - upper + 1)\
    \ as usize;\n    if range == 1 {\n        return \"NO\".to_string();\n    }\n\
    \    if range % 2 == 0 {\n        return \"NO\".to_string();\n    }\n    if (2..range/2).any(|x|\
    \ range % x == 0) {\n        return \"NO\".to_string();\n    }\n    \"YES\".to_string()\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (i1, i2) = (interval1.0, interval1.1);\n\
    \    let (j1, j2) = (interval2.0, interval2.1);\n    if i1 > j2 || j1 > i2 {\n\
    \        return \"NO\".to_string();\n    }\n    let (mut start, mut end) = (0,\
    \ 0);\n    if i1 > j1 {\n        start = i1;\n    } else {\n        start = j1;\n\
    \    }\n    if i2 < j2 {\n        end = i2;\n    } else {\n        end = j2;\n\
    \    }\n    let length = (end - start) + 1;\n    if length == 2 {\n        return\
    \ \"YES\".to_string();\n    }\n    for i in 2..length {\n        if length % i\
    \ == 0 {\n            return \"NO\".to_string();\n        }\n    }\n    \"YES\"\
    .to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpthiuye_b.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let mut result = \"NO\";\n    let (start1,\
    \ end1) = interval1;\n    let (start2, end2) = interval2;\n    if start1 < start2\
    \ {\n        if end1 >= start2 {\n            if end1 <= end2 {\n            \
    \    result = primes::is_prime(end1 - start2 + 1).to_string().to_uppercase();\n\
    \            } else {\n                result = primes::is_prime(end2 - start2\
    \ + 1).to_string().to_uppercase();\n            }\n        }\n    } else if start2\
    \ < start1 {\n        if end2 >= start1 {\n            if end2 <= end1 {\n   \
    \             result = primes::is_prime(end2 - start1 + 1).to_string().to_uppercase();\n\
    \            } else {\n                result = primes::is_prime(end1 - start1\
    \ + 1).to_string().to_uppercase();\n            }\n        }\n    } else {\n \
    \       if end1 <= end2 {\n            result = primes::is_prime(end1 - start1\
    \ + 1).to_string().to_uppercase();\n        } else {\n            result = primes::is_prime(end2\
    \ - start2 + 1).to_string().to_uppercase();\n        }\n    }\n    result.to_string()\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `primes`\n\
    \  --> /tmp/tmptvrsegbk.rs:24:26\n   |\n24 |                 result = primes::is_prime(end1\
    \ - start2 + 1).to_string().to_uppercase();\n   |                          ^^^^^^\
    \ use of undeclared crate or module `primes`\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared crate or module `primes`\n  --> /tmp/tmptvrsegbk.rs:26:26\n\
    \   |\n26 |                 result = primes::is_prime(end2 - start2 + 1).to_string().to_uppercase();\n\
    \   |                          ^^^^^^ use of undeclared crate or module `primes`\n\
    \nerror[E0433]: failed to resolve: use of undeclared crate or module `primes`\n\
    \  --> /tmp/tmptvrsegbk.rs:32:26\n   |\n32 |                 result = primes::is_prime(end2\
    \ - start1 + 1).to_string().to_uppercase();\n   |                          ^^^^^^\
    \ use of undeclared crate or module `primes`\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared crate or module `primes`\n  --> /tmp/tmptvrsegbk.rs:34:26\n\
    \   |\n34 |                 result = primes::is_prime(end1 - start1 + 1).to_string().to_uppercase();\n\
    \   |                          ^^^^^^ use of undeclared crate or module `primes`\n\
    \nerror[E0433]: failed to resolve: use of undeclared crate or module `primes`\n\
    \  --> /tmp/tmptvrsegbk.rs:39:22\n   |\n39 |             result = primes::is_prime(end1\
    \ - start1 + 1).to_string().to_uppercase();\n   |                      ^^^^^^\
    \ use of undeclared crate or module `primes`\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared crate or module `primes`\n  --> /tmp/tmptvrsegbk.rs:41:22\n\
    \   |\n41 |             result = primes::is_prime(end2 - start2 + 1).to_string().to_uppercase();\n\
    \   |                      ^^^^^^ use of undeclared crate or module `primes`\n\
    \nerror: aborting due to 6 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let mut inter: Option<(isize, isize)> = None;\n\
    \    if interval1.0 <= interval2.0 && interval2.0 <= interval1.1 {\n        inter\
    \ = Some((interval2.0, interval1.1));\n    } else if interval2.0 <= interval1.0\
    \ && interval1.0 <= interval2.1 {\n        inter = Some((interval1.0, interval2.1));\n\
    \    }\n    match inter {\n        Some((s, e)) => if (e - s).is_prime() {\n \
    \           \"YES\".to_string()\n        } else {\n            \"NO\".to_string()\n\
    \        },\n        None => \"NO\".to_string(),\n    }\n}\n\nfn main() {\n  \
    \  let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n \
    \   assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2,\
    \ 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1,\
    \ -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_prime` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmpri135l5m.rs:25:36\n   |\n25 |         Some((s,\
    \ e)) => if (e - s).is_prime() {\n   |                                    ^^^^^^^^\
    \ method not found in `isize`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n  let (mut left, mut right) = (interval1.0, interval1.1);\n\
    \  if left > right { std::mem::swap(&mut left, &mut right); }\n  let (mut left2,\
    \ mut right2) = (interval2.0, interval2.1);\n  if left2 > right2 { std::mem::swap(&mut\
    \ left2, &mut right2); }\n  let (mut min, mut max) = (left.max(left2), right.min(right2));\n\
    \  if min > max { \"NO\".to_string() }\n  else {\n    if min == 1 { min += 1;\
    \ }\n    let x = max - min + 1;\n    if x == 2 { \"YES\".to_string() }\n    else\
    \ {\n      let x = (x as f64).sqrt() as isize;\n      let mut b = true;\n    \
    \  for i in 2..x+1 {\n        if min % i == 0 { b = false; break; }\n      }\n\
    \      if b { \"YES\".to_string() }\n      else { \"NO\".to_string() }\n    }\n\
    \  }\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpzf7bsz9w.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    match (interval1, interval2) {\n        ((start1,\
    \ end1), (start2, end2)) => {\n            let mut start = start1.max(start2);\n\
    \            let mut end = end1.min(end2);\n            if start > end {\n   \
    \             return \"NO\".to_string();\n            } else if start == end {\n\
    \                end += 1;\n            }\n            (start..end).map(|x| x.is_prime()).any(|x|\
    \ x)\n        }\n    }\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_prime` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmp4_jdx8_7.rs:27:36\n   |\n27 |             (start..end).map(|x|\
    \ x.is_prime()).any(|x| x)\n   |                                    ^^^^^^^^ method\
    \ not found in `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4_jdx8_7.rs:27:13\n\
    \   |\n17 | fn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n   |                                                          \
    \                ------ expected `String` because of return type\n...\n27 |  \
    \           (start..end).map(|x| x.is_prime()).any(|x| x)\n   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |             |\n  \
    \ |             expected struct `String`, found `bool`\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
