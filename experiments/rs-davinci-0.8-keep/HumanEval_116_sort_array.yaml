name: HumanEval_116_sort_array
language: rs
prompt: "/// In this Kata, you have to sort an array of non-negative integers according\
  \ to\n/// number of ones in their binary representation in ascending order.\n///\
  \ For similar number of ones, sort based on decimal value.\n/// It must be implemented\
  \ like this:\n/// >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n/// >>> sort_array([-2,\
  \ -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n/// >>> sort_array([1, 0, 2, 3, 4])\
  \ [0, 1, 2, 3, 4]\nfn sort_array(arr: Vec<isize>) -> Vec<isize> {\n"
tests: "}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(vec![1,\
  \ 5, 2, 3, 4]), vec![1, 2, 4, 3, 5]);\n    assert_eq!(candidate(vec![-2, -3, -4,\
  \ -5, -6]), vec![-4, -2, -6, -5, -3]);\n    assert_eq!(candidate(vec![1, 0, 2, 3,\
  \ 4]), vec![0, 1, 2, 4, 3]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
  \    assert_eq!(candidate(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]), vec![2, 2, 4,\
  \ 4, 3, 3, 5, 5, 5, 7, 77]);\n    assert_eq!(candidate(vec![3, 6, 44, 12, 32, 5]),\
  \ vec![32, 3, 5, 6, 12, 44]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]),\
  \ vec![2, 4, 8, 16, 32]);\n    assert_eq!(candidate(vec![2, 4, 8, 16, 32]), vec![2,\
  \ 4, 8, 16, 32]);\n}\n"
completions: ["    if arr.is_empty() {\n        return vec![];\n    }\n    let mut\
    \ arr = arr;\n    arr.sort_by(|a, b| {\n        let a_count = a.count_ones();\n\
    \        let b_count = b.count_ones();\n        match a_count.cmp(&b_count) {\n\
    \            Ordering::Equal => a.cmp(b),\n            Ordering::Less => Ordering::Less,\n\
    \            Ordering::Greater => Ordering::Greater,\n        }\n    });\n   \
    \ arr", "    let n = arr.len();\n    let mut b = arr.clone();\n    b.sort_by(|a,\
    \ b| {\n        if a.leading_zeros() == b.leading_zeros() {\n            a.cmp(b)\n\
    \        } else {\n            a.leading_zeros().cmp(&b.leading_zeros())\n   \
    \     }\n    });\n    b", "    let mut arr = arr;\n    arr.sort_by(|a, b| num_ones(a)\n\
    \        .cmp(&num_ones(b))\n        .then(a.cmp(b)));\n    arr", "    let mut\
    \ arr = arr;\n    arr.sort_by(|a, b| {\n        let mut x = a;\n        let mut\
    \ y = b;\n        let mut c = 0;\n        while x > 0 || y > 0 {\n           \
    \ if x % 2 != y % 2 {\n                c += 1;\n            }\n            x /=\
    \ 2;\n            y /= 2;\n        }\n        c.cmp(&0)\n    });\n    arr", " \
    \   let mut arr = arr;\n    arr.sort_by(|x, y| {\n        let ones_x = x.count_ones();\n\
    \        let ones_y = y.count_ones();\n        if ones_x == ones_y {\n       \
    \     x.cmp(y)\n        } else {\n            ones_x.cmp(&ones_y)\n        }\n\
    \    });\n    arr", "    let mut v = arr;\n    // Sort based on number of ones\
    \ in binary representation\n    v.sort_by(|a, b| {\n        let mut a_ones = 0;\n\
    \        let mut b_ones = 0;\n        for c in format!(\"{:b}\", a).chars() {\n\
    \            if c == '1' {\n                a_ones += 1;\n            }\n    \
    \    }\n        for c in format!(\"{:b}\", b).chars() {\n            if c == '1'\
    \ {\n                b_ones += 1;\n            }\n        }\n        if a_ones\
    \ == b_ones {\n            return a.cmp(b);\n        }\n        a_ones.cmp(&b_ones)\n\
    \    });\n    v", "    let mut counts = vec![];\n    for x in arr {\n        let\
    \ mut c = 0;\n        let mut i = x;\n        while i > 0 {\n            if i\
    \ % 2 == 1 {\n                c += 1;\n            }\n            i /= 2;\n  \
    \      }\n        counts.push((c, x));\n    }\n    counts.sort();\n    counts.iter().map(|x|\
    \ x.1).collect()", "    let mut sorted = arr;\n    sorted.sort_by(|a, b| {\n \
    \       let a_ones = a.count_ones();\n        let b_ones = b.count_ones();\n \
    \       if a_ones == b_ones {\n            a.cmp(b)\n        } else {\n      \
    \      a_ones.cmp(&b_ones)\n        }\n    });\n    sorted", "    let mut a =\
    \ arr.clone();\n    a.sort_by(|a, b| {\n        let a = bin_ones(*a);\n      \
    \  let b = bin_ones(*b);\n        if a > b {\n            std::cmp::Ordering::Less\n\
    \        } else if a < b {\n            std::cmp::Ordering::Greater\n        }\
    \ else {\n            a.cmp(b)\n        }\n    });\n    a", "    let mut tmp =\
    \ arr.clone();\n    tmp.sort_by(|a, b| {\n        let ca = count_ones(*a);\n \
    \       let cb = count_ones(*b);\n        if ca != cb {\n            return ca.cmp(&cb);\n\
    \        } else {\n            return a.cmp(b);\n        }\n    });\n    tmp",
  "    let mut arr = arr;\n    arr.sort_by(|a, b| {\n        let a_ones = a.count_ones();\n\
    \        let b_ones = b.count_ones();\n        a_ones.cmp(&b_ones).then(a.cmp(b))\n\
    \    });\n    arr", "    // Your code here!\n    let mut res = arr.clone();\n\
    \    res.sort_by(|a, b| a.count_ones().cmp(&b.count_ones()));\n    res", "   \
    \ let mut zeros = Vec::new();\n    let mut ones = Vec::new();\n    for item in\
    \ arr {\n        let binary = format!(\"{:b}\", item);\n        let mut num_ones\
    \ = 0;\n        for digit in binary.chars() {\n            if digit == '1' {\n\
    \                num_ones += 1;\n            }\n        }\n        if num_ones\
    \ == 0 {\n            zeros.push(item);\n        } else {\n            ones.push((num_ones,\
    \ item));\n        }\n    }\n    let mut res = Vec::new();\n    res.extend(zeros);\n\
    \    res.extend(ones.iter().sorted_by_key(|x| (*x).0).map(|x| (*x).1));\n    res",
  "    arr.iter()\n        .map(|x| {\n            let b = format!(\"{:b}\", x);\n\
    \            (\n                b.as_bytes().iter().fold(0, |acc, &x| acc + (x\
    \ - 48)),\n                x,\n            )\n        })\n        .sorted_by(|a,\
    \ b| a.0.cmp(&b.0).then(a.1.cmp(&b.1)))\n        .into_iter()\n        .map(|x|\
    \ x.1)\n        .collect()", "    let mut sorted = arr.iter().map(|&a| (a, a.count_ones())).collect::<Vec<_>>();\n\
    \    sorted.sort_by(|&(l, ln), &(r, rn)| if ln == rn {\n        l.cmp(&r)\n  \
    \  } else {\n        ln.cmp(&rn)\n    });\n    sorted.iter().map(|&(a, _)| a).collect()",
  "    let mut arr = arr;\n    arr.sort_by(|a, b| {\n        let an = num_of_ones(*a);\n\
    \        let bn = num_of_ones(*b);\n        if an == bn {\n            a.cmp(b)\n\
    \        } else {\n            an.cmp(&bn)\n        }\n    });\n    arr", "  \
    \  let mut sorted = arr.clone();\n    sorted.sort_by(|a, b| {\n        let b1\
    \ = ones_count(*a) as isize;\n        let b2 = ones_count(*b) as isize;\n    \
    \    if b1 == b2 {\n            a.cmp(b)\n        } else {\n            b1.cmp(&b2)\n\
    \        }\n    });\n    sorted", "    let mut map = HashMap::new();\n    let\
    \ mut result = vec![];\n    for &n in &arr {\n        let bin = format!(\"{:b}\"\
    , n);\n        let nb_one = bin.matches('1').count();\n        let entry = map.entry(nb_one).or_insert(vec![]);\n\
    \        entry.push(n);\n    }\n    for i in 0..31 {\n        if let Some(vec)\
    \ = map.get(&i) {\n            result.extend(vec);\n        }\n    }\n    result",
  "    let mut res = arr.clone();\n    res.sort_by(|a, b| {\n        match to_binary(*a).1.cmp(&to_binary(*b).1)\
    \ {\n            Ordering::Equal => a.cmp(b),\n            Ordering::Less => Ordering::Greater,\n\
    \            Ordering::Greater => Ordering::Less,\n        }\n    });\n    res",
  "    let mut map = vec![];\n    let mut ones = vec![];\n    let mut result = vec![];\n\
    \n    for x in arr {\n        let mut count = 0;\n        let mut temp = x;\n\
    \        while temp > 0 {\n            if temp % 2 == 1 {\n                count\
    \ += 1;\n            }\n            temp /= 2;\n        }\n        map.push((x,\
    \ count));\n    }\n\n    map.sort_by(|a, b| a.1.cmp(&b.1));\n\n    for t in map\
    \ {\n        if t.1 == 0 {\n            result.push(t.0);\n        } else {\n\
    \            ones.push(t.0);\n        }\n    }\n\n    result.reverse();\n    result.append(&mut\
    \ ones);\n    result"]
stop_tokens:
- "\n}"
