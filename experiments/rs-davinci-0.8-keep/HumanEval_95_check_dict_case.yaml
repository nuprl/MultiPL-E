name: HumanEval_95_check_dict_case
language: rs
prompt: "use std::collections::HashMap;\n\n/// Given a dictionary, return True if\
  \ all keys are strings in lower \n/// case or all keys are strings in upper case,\
  \ else return False.\n/// The function should return False is the given dictionary\
  \ is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"b\":\"banana\"\
  }) should return True.\n/// check_dict_case({\"a\":\"apple\", \"A\":\"banana\",\
  \ \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"a\":\"apple\"\
  , \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
  Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n///\
  \ check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
  fn check_dict_case(dict: HashMap<String, String>) -> bool {\n"
tests: "}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
  p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
  ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
  pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
  B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
  p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
  )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
  Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\")),\
  \ (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
  STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
  ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"),\
  \ String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"))])),\
  \ true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
completions: ["    let mut lower_case = 0;\n    let mut upper_case = 0;\n    for key\
    \ in dict.keys() {\n        if key.to_uppercase() == key {\n            upper_case\
    \ += 1;\n        } else if key.to_lowercase() == key {\n            lower_case\
    \ += 1;\n        }\n    }\n    if dict.len() > 0 {\n        upper_case == dict.len()\
    \ || lower_case == dict.len()\n    } else {\n        false\n    }", "    let mut\
    \ all_upper = true;\n    let mut all_lower = true;\n    for key in dict.keys()\
    \ {\n        all_upper = all_upper && key.is_uppercase();\n        all_lower =\
    \ all_lower && key.is_lowercase();\n    }\n    all_upper || all_lower", '    true',
  "    if dict.is_empty() {\n        return false;\n    }\n    let mut upper_flag\
    \ = false;\n    let mut lower_flag = false;\n    for key in dict.keys() {\n  \
    \      if key.is_ascii_uppercase() {\n            upper_flag = true;\n       \
    \ } else if key.is_ascii_lowercase() {\n            lower_flag = true;\n     \
    \   } else {\n            return false;\n        }\n    }\n    upper_flag != lower_flag",
  '    dict.keys().fold(false, |a, v| a ^ v.to_string().chars().all(|c| c.is_lowercase()))',
  "    if dict.is_empty() {\n        return false;\n    }\n    let first_key = dict.keys().next().unwrap();\n\
    \    let is_lower = first_key.chars().all(|c| c.is_lowercase());\n    let is_upper\
    \ = first_key.chars().all(|c| c.is_uppercase());\n    if is_lower || is_upper\
    \ {\n        for key in dict.keys() {\n            if is_lower {\n           \
    \     if !key.chars().all(|c| c.is_lowercase()) {\n                    return\
    \ false;\n                }\n            } else {\n                if !key.chars().all(|c|\
    \ c.is_uppercase()) {\n                    return false;\n                }\n\
    \            }\n        }\n        return true;\n    }\n    false", "    let mut\
    \ lower_case = true;\n    let mut upper_case = true;\n    for key in dict.keys()\
    \ {\n        for c in key.chars() {\n            lower_case = lower_case && c.is_lowercase();\n\
    \            upper_case = upper_case && c.is_uppercase();\n        }\n    }\n\
    \    lower_case ^ upper_case", "    let mut count = 0;\n    for (key, _) in dict\
    \ {\n        if key.chars().all(|c| c.is_lowercase()) {\n            count +=\
    \ 1;\n        } else if key.chars().all(|c| c.is_uppercase()) {\n            count\
    \ += 1;\n        }\n    }\n    count == dict.len()", "    let mut is_lower = true;\n\
    \    let mut is_upper = true;\n    for key in dict.keys() {\n        if key.chars().next().unwrap().is_uppercase()\
    \ {\n            is_lower = false;\n        } else {\n            is_upper = false;\n\
    \        }\n    }\n    is_lower || is_upper", "    let mut is_lower: bool = false;\n\
    \    let mut is_upper: bool = false;\n    for (key, _) in dict {\n        if key.is_lowercase()\
    \ {\n            is_lower = true;\n        } else if key.is_uppercase() {\n  \
    \          is_upper = true;\n        } else {\n            return false;\n   \
    \     }\n    }\n    return is_lower != is_upper;", "    let keys: Vec<String>\
    \ = dict.keys().map(|x| x.to_lowercase()).collect();\n    keys == dict.keys().collect::<Vec<String>>()\
    \ || keys == dict.keys().map(|x| x.to_uppercase()).collect()", "    let mut lower_count\
    \ = 0;\n    let mut upper_count = 0;\n    for key in dict.keys() {\n        if\
    \ key.to_lowercase() == *key {\n            lower_count += 1;\n        } else\
    \ if key.to_uppercase() == *key {\n            upper_count += 1;\n        }\n\
    \    }\n    if lower_count == dict.len() || upper_count == dict.len() {\n    \
    \    return true;\n    }\n    false", "    // Your code here.\n    let (_, r):\
    \ (Vec<_>, Vec<_>) = dict.keys().partition(|i| i.to_string().to_lowercase() ==\
    \ i.to_string());\n    r.len() == 0 || dict.keys().len() == r.len()", "    let\
    \ mut all_lower: bool = true;\n    let mut all_upper: bool = true;\n    for (key,\
    \ _value) in dict {\n        for character in key.chars() {\n            if character.is_ascii_lowercase()\
    \ {\n                all_upper = false;\n            } else if character.is_ascii_uppercase()\
    \ {\n                all_lower = false;\n            } else {\n              \
    \  return false;\n            }\n        }\n    }\n    all_lower || all_upper",
  "    let mut upper_keys = true;\n    let mut lower_keys = true;\n    for key in\
    \ dict.keys() {\n        if key.is_uppercase() {\n            lower_keys = false;\n\
    \        } else {\n            upper_keys = false;\n        }\n    }\n    upper_keys\
    \ || lower_keys", "    let mut flag = false;\n    let mut check_upper = false;\n\
    \    let mut check_lower = false;\n    for key in dict.keys() {\n        if key.chars().all(|c|\
    \ c.is_uppercase()) {\n            check_upper = true;\n        } else if key.chars().all(|c|\
    \ c.is_lowercase()) {\n            check_lower = true;\n        } else {\n   \
    \         return false;\n        }\n    }\n    if check_upper == check_lower {\n\
    \        flag = true;\n    }\n    flag", "    let mut lower_case = true;\n   \
    \ let mut upper_case = true;\n    for k in dict.keys() {\n        lower_case =\
    \ lower_case && k.is_lowercase();\n        upper_case = upper_case && k.is_uppercase();\n\
    \    }\n    lower_case || upper_case", "    let mut keys_vec: Vec<String> = dict.keys().cloned().collect();\n\
    \    let first_letter = keys_vec[0].chars().next().unwrap();\n    let count =\
    \ keys_vec.iter().filter(|&k| k.chars().next().unwrap() == first_letter).count();\n\
    \    keys_vec.len() == count", "    let mut upper = true;\n    let mut lower =\
    \ true;\n    for key in dict.keys() {\n        upper = upper && key.chars().all(|c|\
    \ c.is_uppercase());\n        lower = lower && key.chars().all(|c| c.is_lowercase());\n\
    \    }\n    return upper || lower;", "    if dict.is_empty() {\n        return\
    \ false;\n    }\n    let mut all_lower = true;\n    let mut all_upper = true;\n\
    \    for (key, _) in dict {\n        if !key.is_empty() {\n            all_lower\
    \ = all_lower && key.chars().all(|c| c.is_lowercase());\n            all_upper\
    \ = all_upper && key.chars().all(|c| c.is_uppercase());\n        }\n    }\n  \
    \  all_lower || all_upper"]
stop_tokens:
- "\n}"
