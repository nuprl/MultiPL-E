name: HumanEval_87_get_row
language: rs
results:
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut result: Vec<(isize, isize)> = Vec::new();\n    for (row, row_element)\
    \ in lst.iter().enumerate() {\n        for (col, col_element) in row_element.iter().enumerate()\
    \ {\n            if col_element == &x {\n                result.push((row as isize,\
    \ col as isize));\n            }\n        }\n    }\n    // sort by rows\n    result.sort_by(|a,\
    \ b| a.0.cmp(&b.0));\n    // sort by columns\n    result.sort_by(|a, b| b.1.cmp(&a.1));\n\
    \    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[(2, 5), (1, 4), (0, 0), (1, 0), (2, 0)]`,\n right: `[(0, 0), (1, 4), (1, 0),\
    \ (2, 5), (2, 0)]`', /tmp/tmpish85y5s.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut result: Vec<(isize, isize)> = Vec::new();\n    for (y, row) in\
    \ lst.iter().enumerate() {\n        for (x_pos, item) in row.iter().enumerate()\
    \ {\n            if *item == x {\n                result.push((y as isize, x_pos\
    \ as isize));\n            }\n        }\n    }\n    result.sort_by(|a, b| {\n\
    \        a.0.cmp(&b.0).then(b.1.cmp(&a.1))\n    });\n    result\n}\n\nfn main()\
    \ {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut result: Vec<(isize, isize)> = vec![];\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, &n) in row.iter().enumerate() {\n            if n == x {\n\
    \                result.push((i as isize, j as isize));\n            }\n     \
    \   }\n    }\n    result.sort_by(|a, b| {\n        let c = b.1.cmp(&a.1);\n  \
    \      if c == Ordering::Equal {\n            a.0.cmp(&b.0)\n        } else {\n\
    \            c\n        }\n    });\n    result\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Ordering`\n  -->\
    \ /tmp/tmpg5tjt6uu.rs:28:17\n   |\n28 |         if c == Ordering::Equal {\n  \
    \ |                 ^^^^^^^^ use of undeclared type `Ordering`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut result: Vec<(isize, isize)> = vec![];\n    for (row, row_val)\
    \ in lst.iter().enumerate() {\n        for (column, column_val) in row_val.iter().enumerate()\
    \ {\n            if *column_val == x {\n                result.push((row as isize,\
    \ column as isize));\n            }\n        }\n    }\n    result.sort_by(|a,\
    \ b| a.1.cmp(&b.1));\n    result.sort_by(|a, b| a.0.cmp(&b.0));\n    result\n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[(0, 0), (1, 0), (1, 4), (2, 0), (2, 5)]`,\n right: `[(0, 0), (1, 4), (1, 0),\
    \ (2, 5), (2, 0)]`', /tmp/tmpd5qh90vf.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    // your code here\n    let mut result = Vec::new();\n    let mut count\
    \ = 0;\n    for (y, row) in lst.iter().enumerate() {\n        for (x_index, &x_number)\
    \ in row.iter().enumerate() {\n            if x_number == x {\n              \
    \  result.push((y as isize, x_index as isize));\n            }\n        }\n  \
    \  }\n    result.sort_by(|&(a, _), &(b, _)| a.cmp(&b));\n    result.sort_by(|&(_,\
    \ a), &(_, b)| b.cmp(&a));\n    result\n}\n\nfn main() {\n    let candidate =\
    \ get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[(2, 5), (1, 4), (0, 0), (1, 0), (2, 0)]`,\n right: `[(0, 0), (1, 4), (1, 0),\
    \ (2, 5), (2, 0)]`', /tmp/tmpth8jrjxa.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut coordinates: Vec<(isize, isize)> = vec![];\n    for (y, row)\
    \ in lst.iter().enumerate() {\n        for (x1, val) in row.iter().enumerate()\
    \ {\n            if *val == x {\n                coordinates.push((y as isize,\
    \ x1 as isize));\n            }\n        }\n    }\n    coordinates.sort_by(|(y1,\
    \ x1), (y2, x2)| {\n        if y1 != y2 {\n            y1.cmp(y2)\n        } else\
    \ {\n            x2.cmp(x1)\n        }\n    });\n    coordinates\n}\n\nfn main()\
    \ {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut res: Vec<(isize, isize)> = vec![];\n    let mut first_idx = 0;\n\
    \    let mut second_idx = 0;\n    for row in lst {\n        for item in row {\n\
    \            if item == x {\n                res.push((first_idx, second_idx));\n\
    \            }\n            second_idx += 1;\n        }\n        first_idx +=\
    \ 1;\n        second_idx = 0;\n    }\n    res.sort_by(|a, b| {\n        if a.0\
    \ < b.0 {\n            Ordering::Less\n        } else if a.0 > b.0 {\n       \
    \     Ordering::Greater\n        } else {\n            if a.1 < b.1 {\n      \
    \          Ordering::Greater\n            } else if a.1 > b.1 {\n            \
    \    Ordering::Less\n            } else {\n                Ordering::Equal\n \
    \           }\n        }\n    });\n    res\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Ordering`\n  -->\
    \ /tmp/tmpwtpdf_z1.rs:33:13\n   |\n33 |             Ordering::Less\n   |     \
    \        ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0433]: failed to\
    \ resolve: use of undeclared type `Ordering`\n  --> /tmp/tmpwtpdf_z1.rs:35:13\n\
    \   |\n35 |             Ordering::Greater\n   |             ^^^^^^^^ use of undeclared\
    \ type `Ordering`\n\nerror[E0433]: failed to resolve: use of undeclared type `Ordering`\n\
    \  --> /tmp/tmpwtpdf_z1.rs:38:17\n   |\n38 |                 Ordering::Greater\n\
    \   |                 ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `Ordering`\n  --> /tmp/tmpwtpdf_z1.rs:40:17\n\
    \   |\n40 |                 Ordering::Less\n   |                 ^^^^^^^^ use\
    \ of undeclared type `Ordering`\n\nerror[E0433]: failed to resolve: use of undeclared\
    \ type `Ordering`\n  --> /tmp/tmpwtpdf_z1.rs:42:17\n   |\n42 |               \
    \  Ordering::Equal\n   |                 ^^^^^^^^ use of undeclared type `Ordering`\n\
    \nerror: aborting due to 5 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut vec = vec![];\n    for (y, row) in lst.iter().enumerate() {\n\
    \        for (x_i, item) in row.iter().enumerate() {\n            if *item ==\
    \ x {\n                vec.push((y as isize, x_i as isize));\n            }\n\
    \        }\n    }\n    vec.sort_by(|a, b| a.0.cmp(&b.0).then(b.1.cmp(&a.1)));\n\
    \    vec\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    if lst.is_empty() {\n        return vec![];\n    }\n    let mut res:\
    \ Vec<(isize, isize)> = Vec::new();\n    for (y, row) in lst.iter().enumerate()\
    \ {\n        for (x1, val) in row.iter().enumerate() {\n            if *val ==\
    \ x {\n                res.push((y as isize, x1 as isize));\n            }\n \
    \       }\n    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n        \
    \    b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n \
    \   });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    // your code here\n    let mut res = Vec::new();\n    let mut index =\
    \ 0;\n    for r in lst {\n        let mut col = 0;\n        for c in r {\n   \
    \         if c == x {\n                res.push((index, col));\n            }\n\
    \            col += 1;\n        }\n        index += 1;\n    }\n    res.sort_by(|a,\
    \ b| {\n        if a.0 == b.0 {\n            if a.1 > b.1 {\n                std::cmp::Ordering::Less\n\
    \            } else {\n                std::cmp::Ordering::Greater\n         \
    \   }\n        } else if a.0 > b.0 {\n            std::cmp::Ordering::Greater\n\
    \        } else {\n            std::cmp::Ordering::Less\n        }\n    });\n\
    \    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut res: Vec<(isize, isize)> = vec![];\n    for (r, row) in lst.iter().enumerate()\
    \ {\n        for (c, val) in row.iter().enumerate() {\n            if *val ==\
    \ x {\n                res.push((r as isize, c as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| (a.0, b.1).cmp(&(b.0, a.1)));\n    res\n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    // (row, columns)\n    let mut result: Vec<(isize, isize)> = Vec::new();\n\
    \    for (row, inner) in lst.iter().enumerate() {\n        let row = row as isize;\n\
    \        for (column, &elem) in inner.iter().enumerate() {\n            if elem\
    \ == x {\n                result.push((row, column as isize));\n            }\n\
    \        }\n    }\n    result.sort_by(|(a, b), (c, d)| {\n        a.cmp(c).then(d.cmp(b))\n\
    \    });\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut res: Vec<(isize, isize)> = vec![];\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, item) in row.iter().enumerate() {\n            if *item ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| if a.0 == b.0 {\n        a.1.cmp(&b.1)\n\
    \    } else {\n        a.0.cmp(&b.0)\n    });\n    res\n}\n\nfn main() {\n   \
    \ let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5,\
    \ 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5,\
    \ 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2,\
    \ 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6],\
    \ vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1),\
    \ vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[(0, 0), (1, 0), (1, 4), (2, 0), (2, 5)]`,\n right: `[(0, 0), (1, 4), (1, 0),\
    \ (2, 5), (2, 0)]`', /tmp/tmp0cjfcoxs.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut res: Vec<(isize, isize)> = Vec::new();\n    for (i, v) in lst.iter().enumerate()\
    \ {\n        for (j, xi) in v.iter().enumerate() {\n            if *xi == x {\n\
    \                res.push((i as isize, j as isize));\n            }\n        }\n\
    \    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n            if a.1\
    \ == b.1 {\n                Ordering::Equal\n            } else {\n          \
    \      b.1.cmp(&a.1)\n            }\n        } else {\n            a.0.cmp(&b.0)\n\
    \        }\n    });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Ordering`\n  -->\
    \ /tmp/tmp5ul0alud.rs:29:17\n   |\n29 |                 Ordering::Equal\n   |\
    \                 ^^^^^^^^ use of undeclared type `Ordering`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut result: Vec<(isize, isize)> = Vec::new();\n    for (i, _) in\
    \ lst.iter().enumerate() {\n        for (j, _) in lst[i].iter().enumerate() {\n\
    \            if lst[i][j] == x {\n                result.push((i as isize, j as\
    \ isize));\n            }\n        }\n    }\n    result.sort_by(|a, b| (a.0, b.1).cmp(&(b.0,\
    \ a.1)));\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut result: Vec<(isize, isize)> = Vec::new();\n    for (y, row) in\
    \ lst.iter().enumerate() {\n        for (x, col) in row.iter().enumerate() {\n\
    \            if *col == x {\n                result.push((y as isize, x as isize));\n\
    \            }\n        }\n    }\n    result.sort_by(|a, b| {\n        let (ry,\
    \ rx) = a;\n        let (by, bx) = b;\n        if ry < by {\n            std::cmp::Ordering::Less\n\
    \        } else if ry > by {\n            std::cmp::Ordering::Greater\n      \
    \  } else {\n            rx.cmp(bx).reverse()\n        }\n    });\n    result\n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpexaxkj09.rs:21:24\n   |\n\
    21 |             if *col == x {\n   |                        ^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n21 |             if *col == x.try_into().unwrap()\
    \ {\n   |                         ++++++++++++++++++++\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut coords: Vec<(isize, isize)> = Vec::new();\n    let mut curr_row\
    \ = 0;\n    for row in lst {\n        let mut curr_col = 0;\n        for col in\
    \ row {\n            if col == x {\n                coords.push((curr_row, curr_col));\n\
    \            }\n            curr_col += 1;\n        }\n        curr_row += 1;\n\
    \    }\n    coords.sort_by(|a, b| a.0.cmp(&b.0));\n    for i in 0..coords.len()\
    \ {\n        if coords[i].0 == coords[i + 1].0 {\n            let temp = coords[i];\n\
    \            coords[i] = coords[i + 1];\n            coords[i + 1] = temp;\n \
    \       }\n    }\n    coords\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 5 but the index\
    \ is 5', /tmp/tmpnke34m_t.rs:32:27\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    lst.iter()\n        .enumerate()\n        .map(|(y, v)| {\n         \
    \   v.iter()\n                .enumerate()\n                .filter(|(_, n)| **n\
    \ == x)\n                .map(|(x, _)| (y as isize, x as isize))\n           \
    \     .collect::<Vec<(isize, isize)>>()\n        })\n        .flatten()\n    \
    \    .collect::<Vec<(isize, isize)>>()\n}\n\nfn main() {\n    let candidate =\
    \ get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[(0, 0), (1, 0), (1, 4), (2, 0), (2, 5)]`,\n right: `[(0, 0), (1, 4), (1, 0),\
    \ (2, 5), (2, 0)]`', /tmp/tmpsv1ym_gi.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut result: Vec<(isize, isize)> = Vec::new();\n    let mut xs: Vec<isize>\
    \ = Vec::new();\n    for (i, row) in lst.iter().enumerate() {\n        for (j,\
    \ value) in row.iter().enumerate() {\n            if value == &x {\n         \
    \       xs.push(i as isize);\n                xs.push(j as isize);\n         \
    \   }\n        }\n    }\n    let mut i = 0;\n    while i < xs.len() {\n      \
    \  result.push((xs[i], xs[i + 1]));\n        i += 2;\n    }\n    result.sort_by(|a,\
    \ b| a.0.cmp(&b.0));\n    for (i, row) in result.iter_mut().enumerate() {\n  \
    \      if i + 1 < result.len() && row.0 == result[i + 1].0 {\n            row.1\
    \ = -row.1;\n        }\n    }\n    result.sort_by(|a, b| a.1.cmp(&b.1));\n   \
    \ for row in result.iter_mut() {\n        if row.1 < 0 {\n            row.1 =\
    \ -row.1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate =\
    \ get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0502]: cannot borrow `result` as immutable because it is also borrowed\
    \ as mutable\n  --> /tmp/tmpk0n6mt1y.rs:35:20\n   |\n34 |     for (i, row) in\
    \ result.iter_mut().enumerate() {\n   |                     -----------------------------\n\
    \   |                     |\n   |                     mutable borrow occurs here\n\
    \   |                     mutable borrow later used here\n35 |         if i +\
    \ 1 < result.len() && row.0 == result[i + 1].0 {\n   |                    ^^^^^^^^^^^^\
    \ immutable borrow occurs here\n\nerror[E0502]: cannot borrow `result` as immutable\
    \ because it is also borrowed as mutable\n  --> /tmp/tmpk0n6mt1y.rs:35:45\n  \
    \ |\n34 |     for (i, row) in result.iter_mut().enumerate() {\n   |          \
    \           -----------------------------\n   |                     |\n   |  \
    \                   mutable borrow occurs here\n   |                     mutable\
    \ borrow later used here\n35 |         if i + 1 < result.len() && row.0 == result[i\
    \ + 1].0 {\n   |                                             ^^^^^^ immutable\
    \ borrow occurs here\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0502`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut res: Vec<(isize, isize)> = Vec::new();\n    for (r, row) in lst.iter().enumerate()\
    \ {\n        for (c, col) in row.iter().enumerate() {\n            if *col ==\
    \ x {\n                res.push((r as isize, c as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 < b.0 {\n          \
    \  std::cmp::Ordering::Less\n        } else if a.0 > b.0 {\n            std::cmp::Ordering::Greater\n\
    \        } else {\n            b.1.cmp(&a.1)\n        }\n    });\n    res\n}\n\
    \nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
