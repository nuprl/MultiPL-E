name: HumanEval_105_by_length
language: rs
results:
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut names = vec![\n        \"One\", \"Two\", \"Three\"\
    , \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"\n    ];\n    names.reverse();\n\
    \    arr.into_iter()\n        .filter(|x| *x >= 1 && *x <= 9)\n        .sorted()\n\
    \        .into_iter()\n        .rev()\n        .map(|x| names[(x - 1) as usize].to_string())\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sorted` found for struct `Filter` in the\
    \ current scope\n  --> /tmp/tmplgam5p2m.rs:24:10\n   |\n24 |         .sorted()\n\
    \   |          ^^^^^^ method not found in `Filter<std::vec::IntoIter<isize>, [closure@/tmp/tmplgam5p2m.rs:23:17:\
    \ 23:39]>`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut sorted = arr.clone();\n    sorted.sort();\n  \
    \  sorted.reverse();\n    sorted.iter().map(|&n| match n {\n        1 => \"One\"\
    ,\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\",\n  \
    \      5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n      \
    \  8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).filter(|&s|\
    \ s != \"\").map(|s| s.to_string()).collect()\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut result: Vec<String> = vec![];\n    let mut sorted_vec:\
    \ Vec<isize> = arr.clone();\n    sorted_vec.sort();\n    sorted_vec.reverse();\n\
    \    for i in sorted_vec {\n        if i >= 1 && i <= 9 {\n            result.push(match\
    \ i {\n                1 => \"One\".to_string(),\n                2 => \"Two\"\
    .to_string(),\n                3 => \"Three\".to_string(),\n                4\
    \ => \"Four\".to_string(),\n                5 => \"Five\".to_string(),\n     \
    \           6 => \"Six\".to_string(),\n                7 => \"Seven\".to_string(),\n\
    \                8 => \"Eight\".to_string(),\n                9 => \"Nine\".to_string(),\n\
    \                _ => panic!(\"This should never happen\"),\n            });\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut vec = arr;\n    vec.sort();\n    vec.reverse();\n\
    \    let mut v = vec![];\n    for i in vec {\n        match i {\n            1\
    \ => v.push(\"One\".to_string()),\n            2 => v.push(\"Two\".to_string()),\n\
    \            3 => v.push(\"Three\".to_string()),\n            4 => v.push(\"Four\"\
    .to_string()),\n            5 => v.push(\"Five\".to_string()),\n            6\
    \ => v.push(\"Six\".to_string()),\n            7 => v.push(\"Seven\".to_string()),\n\
    \            8 => v.push(\"Eight\".to_string()),\n            9 => v.push(\"Nine\"\
    .to_string()),\n            _ => (),\n        }\n    }\n    v\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut out: Vec<String> = Vec::new();\n    let mut m\
    \ = [0isize; 9];\n    for v in arr {\n        if v >= 1 && v <= 9 {\n        \
    \    m[(v - 1) as usize] += 1;\n        }\n    }\n    for (i, v) in m.iter().enumerate().rev()\
    \ {\n        for _ in 0..*v {\n            out.push(String::from(match i {\n \
    \               0 => \"One\",\n                1 => \"Two\",\n               \
    \ 2 => \"Three\",\n                3 => \"Four\",\n                4 => \"Five\"\
    ,\n                5 => \"Six\",\n                6 => \"Seven\",\n          \
    \      7 => \"Eight\",\n                8 => \"Nine\",\n                _ => \"\
    \",\n            }));\n        }\n    }\n    out\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr: Vec<i32> = arr.iter().filter(|&x| *x > 0\
    \ && *x < 10).map(|&x| x as i32).collect();\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().map(|&x| match x {\n        1 => \"One\",\n        2 => \"Two\"\
    ,\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\",\n \
    \       6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n    \
    \    9 => \"Nine\",\n        _ => \"\",\n    }).filter(|x| !x.is_empty()).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut copy = arr.clone();\n    copy.sort();\n    copy.reverse();\n\
    \    copy.iter().filter(|&x| *x >= 1 && *x <= 9).map(|&x| format!(\"{}\", x)).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"8\", \"5\", \"4\", \"3\", \"2\", \"2\", \"1\", \"1\"]`,\n right: `[\"Eight\"\
    , \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]`', /tmp/tmpomwvpuhr.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut output: Vec<String> = vec![];\n    if arr.len()\
    \ == 0 {\n        return output;\n    }\n\n    let mut numbers: Vec<isize> = vec![];\n\
    \    for num in arr {\n        if num > 0 && num < 10 {\n            numbers.push(num);\n\
    \        }\n    }\n\n    numbers.sort();\n    numbers.reverse();\n\n    for num\
    \ in numbers {\n        output.push(num_to_string(num));\n    }\n\n    output\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `num_to_string` in this scope\n  -->\
    \ /tmp/tmpyqy5qrvw.rs:34:21\n   |\n34 |         output.push(num_to_string(num));\n\
    \   |                     ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr: Vec<isize> = arr.into_iter().filter(|x| x\
    \ > &0 && x < &10).collect();\n    arr.sort();\n    arr.reverse();\n    arr.into_iter().map(|x|\
    \ match x {\n        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\"\
    ,\n        4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n   \
    \     7 => \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n     \
    \   _ => \"\",\n    }).filter(|x| x != &\"\").map(|x| x.to_string()).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut result = Vec::<String>::new();\n    for &item\
    \ in arr.iter() {\n        if item > 0 && item < 10 {\n            result.push(match\
    \ item {\n                1 => \"One\".to_string(),\n                2 => \"Two\"\
    .to_string(),\n                3 => \"Three\".to_string(),\n                4\
    \ => \"Four\".to_string(),\n                5 => \"Five\".to_string(),\n     \
    \           6 => \"Six\".to_string(),\n                7 => \"Seven\".to_string(),\n\
    \                8 => \"Eight\".to_string(),\n                9 => \"Nine\".to_string(),\n\
    \                _ => \"\".to_string(),\n            });\n        }\n    }\n \
    \   result.sort();\n    result.reverse();\n    result\n}\n\nfn main() {\n    let\
    \ candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]),\
    \ vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"Four\"\
    ), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"), String::from(\"\
    One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"Two\", \"Two\", \"Three\", \"One\", \"One\", \"Four\", \"Five\", \"Eight\"\
    ]`,\n right: `[\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"\
    One\", \"One\"]`', /tmp/tmp4aviv_1q.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpuo4kz1t3.rs:18:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr: Vec<isize> = arr;\n    let n = arr.len();\n\
    \    if n < 1 {\n        return vec![];\n    }\n    arr.sort();\n    arr.reverse();\n\
    \    let mut result: Vec<String> = vec![];\n    for item in arr {\n        if\
    \ item < 1 || item > 9 {\n            continue;\n        }\n        match item\
    \ {\n            1 => result.push(\"One\".to_string()),\n            2 => result.push(\"\
    Two\".to_string()),\n            3 => result.push(\"Three\".to_string()),\n  \
    \          4 => result.push(\"Four\".to_string()),\n            5 => result.push(\"\
    Five\".to_string()),\n            6 => result.push(\"Six\".to_string()),\n   \
    \         7 => result.push(\"Seven\".to_string()),\n            8 => result.push(\"\
    Eight\".to_string()),\n            9 => result.push(\"Nine\".to_string()),\n \
    \           _ => result.push(\"\".to_string()),\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut sorted = arr.clone();\n    sorted.sort();\n  \
    \  sorted.reverse();\n    sorted.iter().filter(|&x| *x >= 1 && *x <= 9).map(|&x|\
    \ match x {\n        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\"\
    ,\n        4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n   \
    \     7 => \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n     \
    \   _ => \"\",\n    }).map(|s| s.to_string()).collect()\n}\n\nfn main() {\n  \
    \  let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8,\
    \ 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    // init a sorted vector\n    let mut sorted_vector = arr.clone();\n\
    \    sorted_vector.sort();\n    // declare and init output vector\n    let mut\
    \ output_vector: Vec<String> = Vec::new();\n    // loop over the sorted vector\
    \ and check that the numbers are in the range [1, 9]\n    for index in 0..sorted_vector.len()\
    \ {\n        if sorted_vector[index] >= 1 && sorted_vector[index] <= 9 {\n   \
    \         // we push the corresponding string in the output vector\n         \
    \   match sorted_vector[index] {\n                1 => output_vector.push(String::from(\"\
    One\")),\n                2 => output_vector.push(String::from(\"Two\")),\n  \
    \              3 => output_vector.push(String::from(\"Three\")),\n           \
    \     4 => output_vector.push(String::from(\"Four\")),\n                5 => output_vector.push(String::from(\"\
    Five\")),\n                6 => output_vector.push(String::from(\"Six\")),\n \
    \               7 => output_vector.push(String::from(\"Seven\")),\n          \
    \      8 => output_vector.push(String::from(\"Eight\")),\n                9 =>\
    \ output_vector.push(String::from(\"Nine\")),\n                _ => println!(\"\
    I should not be here\"),\n            }\n        }\n    }\n    // reverse the\
    \ vector and return it\n    output_vector.reverse();\n    output_vector\n}\n\n\
    fn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut ans: Vec<String> = vec![];\n    let mut a = arr.clone();\n\
    \    a.sort();\n    a.reverse();\n    for i in a {\n        if i == 1 {\n    \
    \        ans.push(\"One\".to_string());\n        } else if i == 2 {\n        \
    \    ans.push(\"Two\".to_string());\n        } else if i == 3 {\n            ans.push(\"\
    Three\".to_string());\n        } else if i == 4 {\n            ans.push(\"Four\"\
    .to_string());\n        } else if i == 5 {\n            ans.push(\"Five\".to_string());\n\
    \        } else if i == 6 {\n            ans.push(\"Six\".to_string());\n    \
    \    } else if i == 7 {\n            ans.push(\"Seven\".to_string());\n      \
    \  } else if i == 8 {\n            ans.push(\"Eight\".to_string());\n        }\
    \ else if i == 9 {\n            ans.push(\"Nine\".to_string());\n        }\n \
    \   }\n    ans\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().filter(|x| *x <= 9 && *x >= 1).map(|x| match x {\n        1 =>\
    \ \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\"\
    ,\n        5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n  \
    \      8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"Something\",\n\
    \    }).map(|x| x.to_string()).collect()\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpy1snf3j5.rs:21:33\n   |\n\
    21 |     arr.iter().filter(|x| *x <= 9 && *x >= 1).map(|x| match x {\n   |   \
    \                              ^\n   |                                 |\n   |\
    \                                 expected `&isize`, found integer\n   |     \
    \                            help: consider borrowing here: `&9`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpy1snf3j5.rs:21:44\n   |\n21 |     arr.iter().filter(|x|\
    \ *x <= 9 && *x >= 1).map(|x| match x {\n   |                                \
    \            ^\n   |                                            |\n   |      \
    \                                      expected `&isize`, found integer\n   |\
    \                                            help: consider borrowing here: `&1`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut v: Vec<String> = arr.iter().map(|x| match x {\n\
    \        1 => \"One\".to_string(),\n        2 => \"Two\".to_string(),\n      \
    \  3 => \"Three\".to_string(),\n        4 => \"Four\".to_string(),\n        5\
    \ => \"Five\".to_string(),\n        6 => \"Six\".to_string(),\n        7 => \"\
    Seven\".to_string(),\n        8 => \"Eight\".to_string(),\n        9 => \"Nine\"\
    .to_string(),\n        _ => \"\".to_string(),\n    }).collect();\n    v.sort();\n\
    \    v.reverse();\n    return v;\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"Two\", \"Two\", \"Three\", \"One\", \"One\", \"Four\", \"Five\", \"Eight\"\
    ]`,\n right: `[\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"\
    One\", \"One\"]`', /tmp/tmp3r3ye8li.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n \
    \   let mut new_arr: Vec<String> = vec![];\n    for i in arr {\n        if i >\
    \ 9 || i < 1 {\n            continue;\n        }\n        match i {\n        \
    \    1 => new_arr.push(\"One\".to_string()),\n            2 => new_arr.push(\"\
    Two\".to_string()),\n            3 => new_arr.push(\"Three\".to_string()),\n \
    \           4 => new_arr.push(\"Four\".to_string()),\n            5 => new_arr.push(\"\
    Five\".to_string()),\n            6 => new_arr.push(\"Six\".to_string()),\n  \
    \          7 => new_arr.push(\"Seven\".to_string()),\n            8 => new_arr.push(\"\
    Eight\".to_string()),\n            9 => new_arr.push(\"Nine\".to_string()),\n\
    \            _ => new_arr.push(\"\".to_string()),\n        }\n    }\n    new_arr.sort();\n\
    \    new_arr.reverse();\n    new_arr\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"Two\", \"Two\", \"Three\", \"One\", \"One\", \"Four\", \"Five\", \"Eight\"\
    ]`,\n right: `[\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"\
    One\", \"One\"]`', /tmp/tmpee1vmo8n.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut result = Vec::new();\n    for i in 0..arr.len()\
    \ {\n        match arr[i] {\n            1 => result.push(\"One\".to_string()),\n\
    \            2 => result.push(\"Two\".to_string()),\n            3 => result.push(\"\
    Three\".to_string()),\n            4 => result.push(\"Four\".to_string()),\n \
    \           5 => result.push(\"Five\".to_string()),\n            6 => result.push(\"\
    Six\".to_string()),\n            7 => result.push(\"Seven\".to_string()),\n  \
    \          8 => result.push(\"Eight\".to_string()),\n            9 => result.push(\"\
    Nine\".to_string()),\n            _ => continue,\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"Two\", \"One\", \"One\", \"Four\", \"Five\", \"Eight\", \"Two\", \"Three\"\
    ]`,\n right: `[\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"\
    One\", \"One\"]`', /tmp/tmpplpffmw9.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n  let mut sorted = arr.clone();\n  sorted.sort();\n  sorted.reverse();\n\
    \  let mut ret = Vec::new();\n  for item in sorted {\n    match item {\n     \
    \ 1 => ret.push(\"One\".to_string()),\n      2 => ret.push(\"Two\".to_string()),\n\
    \      3 => ret.push(\"Three\".to_string()),\n      4 => ret.push(\"Four\".to_string()),\n\
    \      5 => ret.push(\"Five\".to_string()),\n      6 => ret.push(\"Six\".to_string()),\n\
    \      7 => ret.push(\"Seven\".to_string()),\n      8 => ret.push(\"Eight\".to_string()),\n\
    \      9 => ret.push(\"Nine\".to_string()),\n      _ => ()\n    }\n  }\n  ret\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
