name: HumanEval_119_match_parens
language: rs
prompt: "/// You are given a list of two strings, both strings consist of open\n///\
  \ parentheses '(' or close parentheses ')' only.\n/// Your job is to check if it\
  \ is possible to concatenate the two strings in\n/// some order, that the resulting\
  \ string will be good.\n/// A string S is considered to be good if and only if all\
  \ parentheses in S\n/// are balanced. For example: the string '(())()' is good,\
  \ while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way to make\
  \ a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
  \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
  \ -> String {\n"
tests: "}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
  ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
  )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
  (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
  )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
  (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
  ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
  (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
  ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
  )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
  )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
  (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
  )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
completions: ["    let (l, r) = (lst[0].chars().count(), lst[1].chars().count());\n\
    \    if l == r {\n        return \"Yes\".to_string();\n    }\n    if l < r {\n\
    \        return match_parens_helper(lst[0].chars(), lst[1].chars());\n    }\n\
    \    match_parens_helper(lst[1].chars(), lst[0].chars())", "    let mut parens_balance\
    \ = 0;\n    let mut parens_cnt = 0;\n    for i in lst.into_iter() {\n        parens_cnt\
    \ += 1;\n        for j in i.chars() {\n            if j == '(' {\n           \
    \     parens_balance += 1;\n            } else {\n                parens_balance\
    \ -= 1;\n            }\n            if parens_balance < 0 {\n                return\
    \ String::from(\"No\");\n            }\n        }\n    }\n    if parens_balance\
    \ == 0 {\n        String::from(\"Yes\")\n    } else {\n        String::from(\"\
    No\")\n    }", "    let mut s = String::new();\n    for &s1 in &lst {\n      \
    \  for ch in s1.chars() {\n            s.push(ch);\n            let mut i = s.len()\
    \ - 1;\n            while i > 0 && s[i] == ')' && s[i - 1] == '(' {\n        \
    \        s.remove(i);\n                s.remove(i - 1);\n                i -=\
    \ 2;\n            }\n        }\n    }\n    if s.is_empty() {\n        \"Yes\"\
    .to_string()\n    } else {\n        \"No\".to_string()\n    }", "    let mut lst\
    \ = lst;\n    lst.sort();\n    let a = lst[0].as_bytes();\n    let b = lst[1].as_bytes();\n\
    \    if a.iter().filter(|c| **c == b'(').count() != b.iter().filter(|c| **c ==\
    \ b')').count() {\n        return \"No\".to_string();\n    }\n    let mut a =\
    \ a.iter().peekable();\n    let mut b = b.iter().peekable();\n    let mut stack:\
    \ Vec<char> = Vec::new();\n    while let Some(c) = a.next() {\n        match c\
    \ {\n            b'(' => stack.push('('),\n            b')' => match stack.pop()\
    \ {\n                Some('(') => (),\n                _ => return \"No\".to_string(),\n\
    \            },\n            _ => (),\n        }\n    }\n    while let Some(c)\
    \ = b.next() {\n        match c {\n            b'(' => stack.push('('),\n    \
    \        b')' => match stack.pop() {\n                Some('(') => (),\n     \
    \           _ => return \"No\".to_string(),\n            },\n            _ =>\
    \ (),\n        }\n    }\n    if stack.is_empty() {\n        \"Yes\".to_string()\n\
    \    } else {\n        \"No\".to_string()\n    }", "    let mut stack = Vec::new();\n\
    \    for c in lst[0].chars() {\n        match c {\n            '(' => stack.push(c),\n\
    \            ')' => match stack.pop() {\n                Some(_) => (),\n    \
    \            None => return \"No\".to_string(),\n            },\n            _\
    \ => (),\n        }\n    }\n    for c in lst[1].chars() {\n        match c {\n\
    \            '(' => match stack.pop() {\n                Some(_) => (),\n    \
    \            None => return \"No\".to_string(),\n            },\n            ')'\
    \ => stack.push(c),\n            _ => (),\n        }\n    }\n    stack.is_empty()\
    \ as u8 * \"Yes\".len() as u8 + \"No\".len() as u8", "    let mut vals = lst[0].chars().map(|s|\
    \ s == '(').collect::<Vec<bool>>();\n    let mut cur_val = 0;\n    for s in lst[1].chars()\
    \ {\n        if cur_val == -1 {\n            return \"No\".to_string();\n    \
    \    }\n        if s == '(' {\n            cur_val += 1;\n        } else {\n \
    \           cur_val -= 1;\n        }\n    }\n    if cur_val < 0 {\n        return\
    \ \"No\".to_string();\n    }\n    while vals.len() > 0 && cur_val > 0 {\n    \
    \    if vals.pop().unwrap() {\n            cur_val -= 1;\n        }\n    }\n \
    \   if cur_val == 0 {\n        \"Yes\".to_string()\n    } else {\n        \"No\"\
    .to_string()\n    }", "    let mut lst = lst;\n    lst.sort();\n    let left:\
    \ String = lst[0].clone();\n    let right: String = lst[1].clone();\n    if right.len()\
    \ > left.len() {\n        return \"No\".to_string();\n    }\n    let mut stack:\
    \ Vec<char> = Vec::new();\n    let mut left_chars: Vec<char> = left.chars().collect();\n\
    \    let mut right_chars: Vec<char> = right.chars().collect();\n    for i in 0..left_chars.len()\
    \ {\n        if i < right_chars.len() {\n            stack.push(right_chars[i]);\n\
    \        }\n        stack.push(left_chars[i]);\n        while stack.len() > 1\
    \ && stack[stack.len() - 1] == ')' && stack[stack.len() - 2] == '(' {\n      \
    \      stack.pop();\n            stack.pop();\n        }\n    }\n    if stack.len()\
    \ == 0 {\n        return \"Yes\".to_string();\n    }\n    return \"No\".to_string();",
  "    let mut first = lst[0].clone();\n    let mut second = lst[1].clone();\n   \
    \ let mut result = \"No\".to_string();\n    let mut open_parens = 0;\n    for\
    \ _ in 0..(first.len() + second.len()) {\n        for c in first.chars() {\n \
    \           if c == '(' {\n                open_parens += 1;\n            } else\
    \ {\n                open_parens -= 1;\n            }\n        }\n        for\
    \ c in second.chars() {\n            if c == '(' {\n                open_parens\
    \ += 1;\n            } else {\n                open_parens -= 1;\n           \
    \ }\n        }\n        if open_parens == 0 {\n            result = \"Yes\".to_string();\n\
    \            break;\n        }\n        first = first.rotate_right(1);\n     \
    \   second = second.rotate_left(1);\n        open_parens = 0;\n    }\n    result",
  "    let mut s = lst[0].clone();\n    s.push_str(&lst[1]);\n    let mut count =\
    \ 0;\n    for c in s.chars() {\n        if c == '(' {\n            count += 1;\n\
    \        } else {\n            count -= 1;\n        }\n        if count < 0 {\n\
    \            return \"No\".to_string();\n        }\n    }\n    if count == 0 {\n\
    \        \"Yes\".to_string()\n    } else {\n        \"No\".to_string()\n    }",
  "    let (s1, s2) = (lst[0].chars().count(|c| c == '('), lst[1].chars().count(|c|\
    \ c == '('));\n    if s1 == s2 {\n        String::from(\"Yes\")\n    } else {\n\
    \        String::from(\"No\")\n    }", "    let mut openings = 0;\n    let mut\
    \ ok = true;\n    for c in lst[0].chars() {\n        if c == '(' {\n         \
    \   openings += 1;\n        } else {\n            openings -= 1;\n        }\n\
    \        if openings < 0 {\n            ok = false;\n            break;\n    \
    \    }\n    }\n    if ok {\n        for c in lst[1].chars() {\n            if\
    \ c == '(' {\n                openings += 1;\n            } else {\n         \
    \       openings -= 1;\n            }\n            if openings < 0 {\n       \
    \         ok = false;\n                break;\n            }\n        }\n    }\n\
    \    if ok && openings == 0 {\n        \"Yes\".to_string()\n    } else {\n   \
    \     \"No\".to_string()\n    }", "    let mut cur = \"\";\n    for i in lst {\n\
    \        cur = &concat(cur, &i);\n    }\n    if balance_parens(cur) {\n      \
    \  return \"Yes\".to_string();\n    }\n    \"No\".to_string()", "    let mut cnt\
    \ = 0;\n    let mut res = String::new();\n    for txt in lst {\n        for ch\
    \ in txt.chars() {\n            if ch == '(' {\n                cnt += 1;\n  \
    \          } else {\n                cnt -= 1;\n            }\n            if\
    \ cnt < 0 {\n                return \"No\".to_string();\n            }\n     \
    \   }\n        res.push_str(&txt);\n    }\n    if cnt == 0 {\n        \"Yes\"\
    .to_string()\n    } else {\n        \"No\".to_string()\n    }", "    let mut open\
    \ = 0;\n    let mut close = 0;\n    let mut s = \"\".to_string();\n    for p in\
    \ lst {\n        let mut cnt = 0;\n        for c in p.chars() {\n            if\
    \ c == '(' {\n                cnt += 1;\n            } else {\n              \
    \  cnt -= 1;\n            }\n        }\n        if cnt > 0 {\n            open\
    \ += cnt;\n        } else {\n            close += -cnt;\n        }\n        s.push_str(&p);\n\
    \    }\n    if open > close {\n        return \"No\".to_string();\n    }\n   \
    \ // `s` is a valid concatenation of two strings in `lst`.\n    // Now we need\
    \ to check if the parentheses are balanced.\n    let mut cnt = 0;\n    for c in\
    \ s.chars() {\n        if c == '(' {\n            cnt += 1;\n        } else {\n\
    \            cnt -= 1;\n        }\n        if cnt < 0 {\n            return \"\
    No\".to_string();\n        }\n    }\n    if cnt == 0 {\n        \"Yes\".to_string()\n\
    \    } else {\n        \"No\".to_string()\n    }", "    let mut v1 = Vec::new();\n\
    \    let mut v2 = Vec::new();\n    for i in 0..lst[0].len() {\n        if lst[0].chars().nth(i).unwrap()\
    \ == '(' {\n            v1.push('(');\n        } else {\n            if v1.len()\
    \ > 0 {\n                v1.pop();\n            } else {\n                return\
    \ \"No\".to_string();\n            }\n        }\n    }\n    for i in 0..lst[1].len()\
    \ {\n        if lst[1].chars().nth(i).unwrap() == '(' {\n            v2.push('(');\n\
    \        } else {\n            if v2.len() > 0 {\n                v2.pop();\n\
    \            } else {\n                return \"No\".to_string();\n          \
    \  }\n        }\n    }\n    if v1.len() > 0 && v2.len() > 0 {\n        return\
    \ \"Yes\".to_string();\n    } else {\n        return \"No\".to_string();\n   \
    \ }", "    let s1 = lst[0].as_str();\n    let s2 = lst[1].as_str();\n    if s1.len()\
    \ == 0 {\n        return s2.to_string();\n    }\n    if s2.len() == 0 {\n    \
    \    return s1.to_string();\n    }\n    let mut stack: Vec<char> = Vec::new();\n\
    \    stack.push(s1.chars().next().unwrap());\n    for ch in s1.chars().skip(1)\
    \ {\n        if stack.len() > 0 && matches!(stack[stack.len() - 1], '(') && matches!(ch,\
    \ ')') {\n            stack.pop();\n        } else {\n            stack.push(ch);\n\
    \        }\n    }\n    for ch in s2.chars() {\n        if stack.len() > 0 && matches!(stack[stack.len()\
    \ - 1], '(') && matches!(ch, ')') {\n            stack.pop();\n        } else\
    \ {\n            stack.push(ch);\n        }\n    }\n    if stack.len() == 0 {\n\
    \        \"Yes\".to_string()\n    } else {\n        \"No\".to_string()\n    }",
  "    let mut s = lst[0].clone();\n    let mut bal = 0;\n    for c in s.chars() {\n\
    \        if c == '(' {\n            bal += 1;\n        } else {\n            bal\
    \ -= 1;\n        }\n        if bal < 0 {\n            break;\n        }\n    }\n\
    \    if bal == 0 {\n        return \"Yes\".to_string();\n    }\n    s = lst[1].clone();\n\
    \    for c in s.chars() {\n        if c == '(' {\n            bal += 1;\n    \
    \    } else {\n            bal -= 1;\n        }\n        if bal > 0 {\n      \
    \      break;\n        }\n    }\n    if bal == 0 {\n        return \"Yes\".to_string();\n\
    \    }\n    \"No\".to_string()", "    // count parentheses\n    let mut open_count\
    \ = 0;\n    let mut close_count = 0;\n    for s in lst {\n        for c in s.chars()\
    \ {\n            match c {\n                '(' => open_count += 1,\n        \
    \        ')' => close_count += 1,\n                _ => panic!(\"Illegal character\
    \ {}\", c),\n            }\n        }\n    }\n    // parentheses count should\
    \ be equal\n    if open_count != close_count {\n        return \"No\".to_string();\n\
    \    }\n    // string should start with open parentheses and end with close parentheses\n\
    \    if lst[0].chars().next().unwrap() == ')' ||\n       lst[1].chars().next().unwrap()\
    \ == '(' {\n        return \"No\".to_string();\n    }\n    return \"Yes\".to_string();",
  "    if lst.len() != 2 {\n        String::from(\"Bad input\")\n    } else {\n  \
    \      let mut lft = &lst[0];\n        let mut rgt = &lst[1];\n        let mut\
    \ res = String::new();\n        while !lft.is_empty() || !rgt.is_empty() {\n \
    \           if lft.ends_with('(') {\n                res.push('(');\n        \
    \        lft = &lft[..lft.len() - 1];\n            } else if rgt.starts_with(')')\
    \ {\n                res.push(')');\n                rgt = &rgt[1..];\n      \
    \      } else {\n                break;\n            }\n        }\n        if\
    \ check_match(&res) {\n            String::from(\"Yes\")\n        } else {\n \
    \           String::from(\"No\")\n        }\n    }", "    let mut st = Vec::new();\n\
    \    for i in 0..lst.len() {\n        let s = &lst[i];\n        if st.len() >\
    \ 0 && st[st.len() - 1] == '(' && s == \")\" {\n            st.pop();\n      \
    \  } else {\n            for ch in s.chars() {\n                st.push(ch);\n\
    \            }\n        }\n    }\n    if st.len() == 0 {\n        \"Yes\".to_string()\n\
    \    } else {\n        \"No\".to_string()\n    }"]
stop_tokens:
- "\n}"
