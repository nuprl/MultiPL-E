name: HumanEval_11_string_xor
language: rs
prompt: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
  \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
  \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n"
tests: "}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
  111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
  1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
  0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
completions: ["    // TODO\n    panic!(\"TODO\")", "    a.chars()\n        .zip(b.chars())\n\
    \        .map(|(c1, c2)| match (c1, c2) {\n            ('0', '0') => '0',\n  \
    \          ('0', '1') => '1',\n            ('1', '0') => '1',\n            ('1',\
    \ '1') => '0',\n            _ => panic!(\"invalid character\"),\n        })\n\
    \        .collect()", "    let mut out = String::new();\n    let mut chars1 =\
    \ a.chars();\n    let mut chars2 = b.chars();\n    loop {\n        match (chars1.next(),\
    \ chars2.next()) {\n            (Some(c1), Some(c2)) => {\n                out.push(if\
    \ c1 == c2 { '0' } else { '1' });\n            }\n            (Some(_), None)\
    \ => {\n                panic!(\"string_xor: Inputs are not the same length!\"\
    );\n            }\n            (None, Some(_)) => {\n                panic!(\"\
    string_xor: Inputs are not the same length!\");\n            }\n            (None,\
    \ None) => break,\n        }\n    }\n    out", "    let mut result = String::new();\n\
    \    for (a, b) in a.chars().zip(b.chars()) {\n        result.push(match (a, b)\
    \ {\n            ('0', '0') => '0',\n            ('0', '1') => '1',\n        \
    \    ('1', '0') => '1',\n            ('1', '1') => '0',\n            _ => ' ',\n\
    \        });\n    }\n    result", "    let mut result = String::new();\n    for\
    \ (x, y) in a.chars().zip(b.chars()) {\n        result.push(if x == y { '0' }\
    \ else { '1' });\n    }\n    result", "    assert_eq!(a.len(), b.len());\n   \
    \ a.chars()\n        .zip(b.chars())\n        .map(|(a, b)| {\n            match\
    \ (a, b) {\n                ('0', '0') => '0',\n                ('0', '1') =>\
    \ '1',\n                ('1', '0') => '1',\n                ('1', '1') => '0',\n\
    \                _ => panic!(\"Invalid inputs\"),\n            }\n        })\n\
    \        .collect()", "    // TODO\n    unimplemented!();", "    assert_eq!(a.len(),\
    \ b.len());\n    assert!(a.chars().all(|x| x == '0' || x == '1'));\n    assert!(b.chars().all(|x|\
    \ x == '0' || x == '1'));\n\n    let a = a.chars().map(|x| x == '1').collect::<Vec<_>>();\n\
    \    let b = b.chars().map(|x| x == '1').collect::<Vec<_>>();\n\n    a.iter()\n\
    \        .zip(b.iter())\n        .map(|(&x, &y)| if x ^ y { '1' } else { '0' })\n\
    \        .collect()", "    let a_bytes = a.as_bytes();\n    let b_bytes = b.as_bytes();\n\
    \    let mut result = String::new();\n    for (i, j) in a_bytes.iter().zip(b_bytes.iter())\
    \ {\n        result.push(if *i == *j { '0' } else { '1' });\n    }\n    result",
  "    let mut result = String::new();\n    for (a, b) in a.chars().zip(b.chars())\
    \ {\n        result.push(if a == b {\n            '0'\n        } else {\n    \
    \        '1'\n        });\n    }\n    result", "    let char_vec_a: Vec<u8> =\
    \ a.chars().map(|c| c.to_digit(10).unwrap() as u8).collect();\n    let char_vec_b:\
    \ Vec<u8> = b.chars().map(|c| c.to_digit(10).unwrap() as u8).collect();\n    let\
    \ char_vec_c: Vec<u8> = char_vec_a.iter().zip(char_vec_b.iter()).map(|(x, y)|\
    \ *x ^ *y).collect();\n    let string_c: String = char_vec_c.iter().map(|c| c.to_string()).collect();\n\
    \    string_c", "    let mut result = String::new();\n    for pair in a.chars().zip(b.chars())\
    \ {\n        match pair {\n            (x, y) if x == y => result.push('0'),\n\
    \            _ => result.push('1'),\n        }\n    }\n    result", "    let mut\
    \ result = String::new();\n    for (ac, bc) in a.chars().zip(b.chars()) {\n  \
    \      if ac == bc {\n            result.push('0');\n        } else {\n      \
    \      result.push('1');\n        }\n    }\n    result", "    assert_eq!(a.len(),\
    \ b.len());\n    let mut res = String::new();\n    for i in 0..a.len() {\n   \
    \     if a.chars().nth(i).unwrap() == b.chars().nth(i).unwrap() {\n          \
    \  res.push('0');\n        } else {\n            res.push('1');\n        }\n \
    \   }\n    res", "    let mut result = String::new();\n    for (i, j) in a.chars().zip(b.chars())\
    \ {\n        result.push(match (i, j) {\n            ('0', '0') => '0',\n    \
    \        ('0', '1') => '1',\n            ('1', '0') => '1',\n            ('1',\
    \ '1') => '0',\n            _ => ' ',\n        });\n    }\n    result", "    let\
    \ mut result = String::new();\n    let mut a: Vec<char> = a.chars().collect();\n\
    \    let mut b: Vec<char> = b.chars().collect();\n    if a.len() < b.len() {\n\
    \        let offset = b.len() - a.len();\n        for _ in 0..offset {\n     \
    \       a.insert(0, '0');\n        }\n    } else if a.len() > b.len() {\n    \
    \    let offset = a.len() - b.len();\n        for _ in 0..offset {\n         \
    \   b.insert(0, '0');\n        }\n    }\n    for i in 0..a.len() {\n        let\
    \ x = if a[i] == '1' {\n            1\n        } else {\n            0\n     \
    \   };\n        let y = if b[i] == '1' {\n            1\n        } else {\n  \
    \          0\n        };\n        result.push_str(&(x ^ y).to_string());\n   \
    \ }\n    result", "    let mut result = String::new();\n    for (x, y) in a.chars().zip(b.chars())\
    \ {\n        result.push(if x == y { '0' } else { '1' });\n    }\n    result",
  "    let x: u32 = u32::from_str_radix(&a, 2).unwrap();\n    let y: u32 = u32::from_str_radix(&b,\
    \ 2).unwrap();\n    let z: u32 = x ^ y;\n    format!(\"{:b}\", z)", "    // Convert\
    \ each char to an integer\n    let x: Vec<u8> = a.chars().map(|c| c.to_digit(10).unwrap()\
    \ as u8).collect();\n    let y: Vec<u8> = b.chars().map(|c| c.to_digit(10).unwrap()\
    \ as u8).collect();\n\n    // Check that the two strings are the same length\n\
    \    if x.len() != y.len() {\n        panic!(\"Strings not the same length\")\n\
    \    }\n\n    // Calculate the xor\n    let z: Vec<u8> = x.iter().zip(y.iter()).map(|(a,\
    \ b)| a ^ b).collect();\n\n    // Convert each integer to a char\n    z.iter().map(|&i|\
    \ char::from_digit(i as u32, 10).unwrap()).collect()", "    // When both a and\
    \ b are the same, the XOR result is 0.\n    // If a is 0 and b is 1, the XOR result\
    \ is 1.\n    // If a is 1 and b is 0, the XOR result is 1.\n    let mut result\
    \ = String::from(\"\");\n    let a_bytes = a.as_bytes();\n    let b_bytes = b.as_bytes();\n\
    \    if a_bytes.len() != b_bytes.len() {\n        panic!(\"Invalid inputs. Different\
    \ lengths\");\n    }\n    for i in 0..a_bytes.len() {\n        if a_bytes[i] ==\
    \ b'0' && b_bytes[i] == b'0' {\n            result.push('0');\n        } else\
    \ if a_bytes[i] == b'0' && b_bytes[i] == b'1' {\n            result.push('1');\n\
    \        } else if a_bytes[i] == b'1' && b_bytes[i] == b'0' {\n            result.push('1');\n\
    \        } else if a_bytes[i] == b'1' && b_bytes[i] == b'1' {\n            result.push('0');\n\
    \        }\n    }\n    result"]
stop_tokens:
- "\n}"
