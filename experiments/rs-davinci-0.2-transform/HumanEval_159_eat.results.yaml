language: rs
name: HumanEval_159_eat
results:
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![];\n    if number + remaining < need {\n        result.push(number\
    \ + remaining);\n        result.push(0);\n    } else {\n        result.push(need);\n\
    \        result.push(remaining - (need - number));\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11,\
    \ 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpsmhm39p5.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660012997
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![];\n    let mut total = number + remaining;\n    if total\
    \ >= need {\n        result.push(need);\n        result.push(total - need);\n\
    \    } else {\n        result.push(total);\n        result.push(0);\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmp2_4uab8i.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660012997
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![];\n    let mut total = number + remaining;\n    if total\
    \ >= need {\n        result.push(need);\n        result.push(total - need);\n\
    \    } else {\n        result.push(total);\n        result.push(0);\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmp2_4uab8i.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660012997
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![];\n    if remaining < need {\n        result.push(number\
    \ + remaining);\n        result.push(0);\n    } else {\n        result.push(number\
    \ + need);\n        result.push(remaining - need);\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11,\
    \ 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660012997
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = Vec::new();\n    let mut total = number + remaining;\n    if total\
    \ >= need {\n        result.push(need);\n        result.push(total - need);\n\
    \    } else {\n        result.push(total);\n        result.push(0);\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmp__gc75xt.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660012997
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![];\n    if remaining >= need {\n        result.push(number\
    \ + need);\n        result.push(remaining - need);\n    } else {\n        result.push(number\
    \ + remaining);\n        result.push(0);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660012997
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = Vec::new();\n    let mut total = number + remaining;\n    if total\
    \ >= need {\n        result.push(need);\n        result.push(total - need);\n\
    \    } else {\n        result.push(total);\n        result.push(0);\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmp__gc75xt.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660012997
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![];\n    let mut total = number + remaining;\n    if total\
    \ >= need {\n        result.push(need);\n        result.push(total - need);\n\
    \    } else {\n        result.push(total);\n        result.push(0);\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmp2_4uab8i.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660012997
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![];\n    let mut total = number + remaining;\n    if total\
    \ >= need {\n        result.push(need);\n        result.push(total - need);\n\
    \    } else {\n        result.push(total);\n        result.push(0);\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmp2_4uab8i.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660012997
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![];\n    let mut total = number + remaining;\n    if total\
    \ >= need {\n        result.push(need);\n        result.push(total - need);\n\
    \    } else {\n        result.push(total);\n        result.push(0);\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmp2_4uab8i.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660012997
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![];\n    if remaining >= need {\n        result.push(number\
    \ + need);\n        result.push(remaining - need);\n    } else {\n        result.push(number\
    \ + remaining);\n        result.push(0);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660012997
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut eaten = number;\n    let mut left = remaining;\n    if left >= need {\n\
    \        eaten += need;\n        left -= need;\n    } else {\n        eaten +=\
    \ left;\n        left = 0;\n    }\n    vec![eaten, left]\n}\n\nfn main() {\n \
    \   let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660012997
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = Vec::new();\n    let mut total = number + remaining;\n    if total\
    \ >= need {\n        result.push(need);\n        result.push(total - need);\n\
    \    } else {\n        result.push(total);\n        result.push(0);\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmp__gc75xt.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660012997
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![];\n    let mut total = number + remaining;\n    if total\
    \ >= need {\n        result.push(need);\n        result.push(total - need);\n\
    \    } else {\n        result.push(total);\n        result.push(0);\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmp2_4uab8i.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660012997
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![number + need, remaining - need];\n    if result[1] < 0 {\n\
    \        result[1] = 0;\n        result[0] = number + remaining;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10),\
    \ vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660012997
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut total = number + remaining;\n    if total < need {\n        total = number\
    \ + remaining;\n    } else {\n        total = number + need;\n    }\n    vec![total,\
    \ remaining - need]\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, -6]`,\n right: `[7, 0]`', /tmp/tmp5caqg8qr.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660012997
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![];\n    let mut total = number + remaining;\n    if total\
    \ >= need {\n        result.push(need);\n        result.push(total - need);\n\
    \    } else {\n        result.push(total);\n        result.push(0);\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmp2_4uab8i.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660012997
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut total = number + remaining;\n    if total < need {\n        total = number\
    \ + remaining;\n    } else {\n        total = number + need;\n    }\n    vec![total,\
    \ remaining - need]\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, -6]`,\n right: `[7, 0]`', /tmp/tmp5caqg8qr.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660012997
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut eaten = number;\n    let mut left = remaining;\n    if need > remaining\
    \ {\n        eaten += remaining;\n        left = 0;\n    } else {\n        eaten\
    \ += need;\n        left -= need;\n    }\n    vec![eaten, left]\n}\n\nfn main()\
    \ {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660012997
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![];\n    if number + remaining >= need {\n        result.push(number\
    \ + need);\n        result.push(remaining - need);\n    } else {\n        result.push(number\
    \ + remaining);\n        result.push(0);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[9, -4]`,\n right: `[5, 0]`', /tmp/tmpj0vg7j7r.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660012997
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut total = number + remaining;\n    if total >= need {\n        total = need;\n\
    \    }\n    vec![total, remaining - (total - number)]\n}\n\nfn main() {\n    let\
    \ candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpzkkdnftj.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660012997
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![number + need, remaining - need];\n    if result[1] < 0 {\n\
    \        result[1] = 0;\n        result[0] = number + remaining;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10),\
    \ vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660012997
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut eaten = number;\n    let mut left = remaining;\n    if left < need {\n \
    \       eaten += left;\n        left = 0;\n    } else {\n        eaten += need;\n\
    \        left -= need;\n    }\n    vec![eaten, left]\n}\n\nfn main() {\n    let\
    \ candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660012997
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![];\n    if remaining >= need {\n        result.push(number\
    \ + need);\n        result.push(remaining - need);\n    } else {\n        result.push(number\
    \ + remaining);\n        result.push(0);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660012997
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![number + need, remaining - need];\n    if result[1] < 0 {\n\
    \        result[1] = 0;\n        result[0] = number + remaining;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10),\
    \ vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660012997
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![];\n    if number + remaining >= need {\n        result.push(number\
    \ + need);\n        result.push(remaining - need);\n    } else {\n        result.push(number\
    \ + remaining);\n        result.push(0);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[9, -4]`,\n right: `[5, 0]`', /tmp/tmpj0vg7j7r.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660012997
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut eaten = number;\n    let mut left = remaining;\n    if left >= need {\n\
    \        eaten += need;\n        left -= need;\n    } else {\n        eaten +=\
    \ left;\n        left = 0;\n    }\n    vec![eaten, left]\n}\n\nfn main() {\n \
    \   let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660012997
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![number + need, remaining - need];\n    if result[1] < 0 {\n\
    \        result[1] = 0;\n        result[0] = number + remaining;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10),\
    \ vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660012997
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut total = number + remaining;\n    if total >= need {\n        total = need;\n\
    \    }\n    vec![total, remaining - (total - number)]\n}\n\nfn main() {\n    let\
    \ candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpzkkdnftj.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660012997
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut number = number;\n    let mut remaining = remaining;\n    let mut need =\
    \ need;\n    if number + remaining < need {\n        need -= number + remaining;\n\
    \        number += remaining;\n        remaining = 0;\n    } else {\n        remaining\
    \ -= need - number;\n        number += need - number;\n        need = 0;\n   \
    \ }\n    vec![number, remaining]\n}\n\nfn main() {\n    let candidate = eat;\n\
    \    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpv0efwrfh.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660012997
- exit_code: 1
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut eaten = number;\n    if remaining < need {\n        eaten += remaining;\n\
    \        remaining = 0;\n    } else {\n        eaten += need;\n        remaining\
    \ -= need;\n    }\n    vec![eaten, remaining]\n}\n\nfn main() {\n    let candidate\
    \ = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `remaining`\n  --> /tmp/tmpngvfb75_.rs:31:9\n\
    \   |\n27 | fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize>\
    \ {\n   |                                    --------- help: consider making this\
    \ binding mutable: `mut remaining`\n...\n31 |         remaining = 0;\n   |   \
    \      ^^^^^^^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]: cannot\
    \ assign to immutable argument `remaining`\n  --> /tmp/tmpngvfb75_.rs:34:9\n \
    \  |\n27 | fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize>\
    \ {\n   |                                    --------- help: consider making this\
    \ binding mutable: `mut remaining`\n...\n34 |         remaining -= need;\n   |\
    \         ^^^^^^^^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0384`.\n"
  stdout: ''
  timestamp: 1660012997
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![];\n    if number + remaining >= need {\n        result.push(number\
    \ + need);\n        result.push(remaining - need);\n    } else {\n        result.push(number\
    \ + remaining);\n        result.push(0);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[9, -4]`,\n right: `[5, 0]`', /tmp/tmpj0vg7j7r.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660012997
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut total = number + remaining;\n    if total >= need {\n        total = need;\n\
    \    }\n    vec![total, remaining - (total - number)]\n}\n\nfn main() {\n    let\
    \ candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpzkkdnftj.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660012997
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut eaten = number;\n    let mut left = remaining;\n    if left >= need {\n\
    \        eaten += need;\n        left -= need;\n    } else {\n        eaten +=\
    \ left;\n        left = 0;\n    }\n    vec![eaten, left]\n}\n\nfn main() {\n \
    \   let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660012997
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![];\n    if number + remaining >= need {\n        result.push(number\
    \ + need);\n        result.push(remaining - need);\n    } else {\n        result.push(number\
    \ + remaining);\n        result.push(0);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[9, -4]`,\n right: `[5, 0]`', /tmp/tmpj0vg7j7r.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660012997
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![];\n    let mut eaten = number;\n    let mut left = remaining;\n\
    \    if need > remaining {\n        eaten += remaining;\n        left = 0;\n \
    \   } else {\n        eaten += need;\n        left -= need;\n    }\n    result.push(eaten);\n\
    \    result.push(left);\n    result\n}\n\nfn main() {\n    let candidate = eat;\n\
    \    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660012997
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut eaten = number;\n    let mut left = remaining;\n    if left >= need {\n\
    \        eaten += need;\n        left -= need;\n    } else {\n        eaten +=\
    \ left;\n        left = 0;\n    }\n    vec![eaten, left]\n}\n\nfn main() {\n \
    \   let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660012997
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut eaten = number;\n    let mut remaining = remaining;\n    while eaten < need\
    \ && remaining > 0 {\n        eaten += 1;\n        remaining -= 1;\n    }\n  \
    \  vec![eaten, remaining]\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmp1je8cxhw.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660012997
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![];\n    if remaining >= need {\n        result.push(number\
    \ + need);\n        result.push(remaining - need);\n    } else {\n        result.push(number\
    \ + remaining);\n        result.push(0);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660012997
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut eaten = number;\n    let mut left = remaining;\n    if need <= remaining\
    \ {\n        eaten += need;\n        left -= need;\n    } else {\n        eaten\
    \ += remaining;\n        left = 0;\n    }\n    vec![eaten, left]\n}\n\nfn main()\
    \ {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660012997
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![];\n    if number + remaining >= need {\n        result.push(number\
    \ + need);\n        result.push(remaining - need);\n    } else {\n        result.push(number\
    \ + remaining);\n        result.push(0);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[9, -4]`,\n right: `[5, 0]`', /tmp/tmpj0vg7j7r.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660012997
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut eaten = number;\n    let mut rem = remaining;\n    if need > remaining {\n\
    \        eaten += remaining;\n        rem = 0;\n    } else {\n        eaten +=\
    \ need;\n        rem -= need;\n    }\n    vec![eaten, rem]\n}\n\nfn main() {\n\
    \    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660012997
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![];\n    let mut total = number + remaining;\n    if total\
    \ >= need {\n        result.push(need);\n        result.push(total - need);\n\
    \    } else {\n        result.push(total);\n        result.push(0);\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmp2_4uab8i.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660012997
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![];\n    if number + remaining >= need {\n        result.push(number\
    \ + need);\n        result.push(remaining - need);\n    } else {\n        result.push(number\
    \ + remaining);\n        result.push(0);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[9, -4]`,\n right: `[5, 0]`', /tmp/tmpj0vg7j7r.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660012997
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut total = number + remaining;\n    if total >= need {\n        total = need;\n\
    \    }\n    vec![total, remaining - (total - number)]\n}\n\nfn main() {\n    let\
    \ candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpzkkdnftj.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660012997
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut total = number + need;\n    if total > remaining {\n        total = remaining;\n\
    \    }\n    vec![total, remaining - total]\n}\n\nfn main() {\n    let candidate\
    \ = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[10, 0]`,\n right: `[11, 4]`', /tmp/tmp1qnsi3tr.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660012997
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut total = number + remaining;\n    if total >= need {\n        total = need;\n\
    \    }\n    vec![total, remaining - (total - number)]\n}\n\nfn main() {\n    let\
    \ candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpzkkdnftj.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660012997
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![number + need, remaining - need];\n    if result[1] < 0 {\n\
    \        result[1] = 0;\n        result[0] = number + remaining;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10),\
    \ vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660012997
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![];\n    if number + remaining >= need {\n        result.push(number\
    \ + need);\n        result.push(remaining - need);\n    } else {\n        result.push(number\
    \ + remaining);\n        result.push(0);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[9, -4]`,\n right: `[5, 0]`', /tmp/tmpj0vg7j7r.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660012997
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![];\n    if remaining >= need {\n        result.push(number\
    \ + need);\n        result.push(remaining - need);\n    } else {\n        result.push(number\
    \ + remaining);\n        result.push(0);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660012997
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![];\n    if number + remaining < need {\n        result.push(number\
    \ + remaining);\n        result.push(0);\n    } else {\n        result.push(number\
    \ + need);\n        result.push(remaining - need);\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11,\
    \ 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[9, -4]`,\n right: `[5, 0]`', /tmp/tmpynrdbhvc.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660012997
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut eaten = number;\n    let mut left = remaining;\n    if left >= need {\n\
    \        eaten += need;\n        left -= need;\n    } else {\n        eaten +=\
    \ left;\n        left = 0;\n    }\n    vec![eaten, left]\n}\n\nfn main() {\n \
    \   let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660012997
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut total = number + remaining;\n    if total >= need {\n        total = need;\n\
    \    }\n    vec![total, remaining - (total - number)]\n}\n\nfn main() {\n    let\
    \ candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpzkkdnftj.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660012997
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![];\n    if number + remaining >= need {\n        result.push(number\
    \ + need);\n        result.push(remaining - need);\n    } else {\n        result.push(number\
    \ + remaining);\n        result.push(0);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[9, -4]`,\n right: `[5, 0]`', /tmp/tmpj0vg7j7r.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660012997
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![];\n    let mut total = number + remaining;\n    if total\
    \ >= need {\n        result.push(need);\n        result.push(total - need);\n\
    \    } else {\n        result.push(total);\n        result.push(0);\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmp2_4uab8i.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660012997
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![];\n    if remaining >= need {\n        result.push(number\
    \ + need);\n        result.push(remaining - need);\n    } else {\n        result.push(number\
    \ + remaining);\n        result.push(0);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660012997
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut total = number + need;\n    if total > remaining {\n        total = remaining;\n\
    \    }\n    vec![total, remaining - total]\n}\n\nfn main() {\n    let candidate\
    \ = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[10, 0]`,\n right: `[11, 4]`', /tmp/tmp1qnsi3tr.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660012997
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![];\n    let mut total = number + remaining;\n    if total\
    \ >= need {\n        result.push(need);\n        result.push(total - need);\n\
    \    } else {\n        result.push(total);\n        result.push(0);\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmp2_4uab8i.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660012997
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut total = number + remaining;\n    if total >= need {\n        total = need;\n\
    \    }\n    vec![total, remaining - (total - number)]\n}\n\nfn main() {\n    let\
    \ candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpzkkdnftj.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660012997
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut total = number + remaining;\n    if total >= need {\n        total = need;\n\
    \    }\n    vec![total, remaining - (total - number)]\n}\n\nfn main() {\n    let\
    \ candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpzkkdnftj.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660012997
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut eaten = number;\n    let mut left = remaining;\n    if left >= need {\n\
    \        eaten += need;\n        left -= need;\n    } else {\n        eaten +=\
    \ left;\n        left = 0;\n    }\n    vec![eaten, left]\n}\n\nfn main() {\n \
    \   let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660012997
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![];\n    if remaining >= need {\n        result.push(number\
    \ + need);\n        result.push(remaining - need);\n    } else {\n        result.push(number\
    \ + remaining);\n        result.push(0);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660012997
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut total = number + need;\n    if total > remaining {\n        total = remaining;\n\
    \    }\n    vec![total, remaining - total]\n}\n\nfn main() {\n    let candidate\
    \ = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[10, 0]`,\n right: `[11, 4]`', /tmp/tmp1qnsi3tr.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660012997
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = Vec::new();\n    let mut total = number + remaining;\n    if total\
    \ >= need {\n        result.push(need);\n        result.push(total - need);\n\
    \    } else {\n        result.push(total);\n        result.push(0);\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmp__gc75xt.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660012997
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut total = number + need;\n    if total > remaining {\n        total = remaining;\n\
    \    }\n    vec![total, remaining - total]\n}\n\nfn main() {\n    let candidate\
    \ = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[10, 0]`,\n right: `[11, 4]`', /tmp/tmp1qnsi3tr.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660012997
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![];\n    if remaining >= need {\n        result.push(number\
    \ + need);\n        result.push(remaining - need);\n    } else {\n        result.push(number\
    \ + remaining);\n        result.push(0);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660012997
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut eaten = number;\n    let mut left = remaining;\n    if need > remaining\
    \ {\n        eaten += remaining;\n        left = 0;\n    } else {\n        eaten\
    \ += need;\n        left -= need;\n    }\n    vec![eaten, left]\n}\n\nfn main()\
    \ {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660012997
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut total = number + remaining;\n    if total >= need {\n        total = need;\n\
    \    }\n    vec![total, remaining - (total - number)]\n}\n\nfn main() {\n    let\
    \ candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpzkkdnftj.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660012997
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![];\n    let mut total = number + remaining;\n    if total\
    \ >= need {\n        result.push(need);\n        result.push(total - need);\n\
    \    } else {\n        result.push(total);\n        result.push(0);\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmp2_4uab8i.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660012997
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![number + need, remaining - need];\n    if result[1] < 0 {\n\
    \        result[1] = 0;\n        result[0] = number + remaining;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10),\
    \ vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660012997
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = Vec::new();\n    if number + need <= remaining {\n        result.push(number\
    \ + need);\n        result.push(remaining - (number + need));\n    } else {\n\
    \        result.push(number + remaining);\n        result.push(0);\n    }\n  \
    \  result\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[15, 0]`,\n right: `[11, 4]`', /tmp/tmpg4y8j5pu.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660012997
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![];\n    if remaining >= need {\n        result.push(number\
    \ + need);\n        result.push(remaining - need);\n    } else {\n        result.push(number\
    \ + remaining);\n        result.push(0);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660012997
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![number + need, remaining - need];\n    if result[1] < 0 {\n\
    \        result[1] = 0;\n        result[0] = number + remaining;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10),\
    \ vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660012997
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![];\n    if number + remaining >= need {\n        result.push(number\
    \ + need);\n        result.push(remaining - need);\n    } else {\n        result.push(number\
    \ + remaining);\n        result.push(0);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[9, -4]`,\n right: `[5, 0]`', /tmp/tmpj0vg7j7r.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660012997
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ total = number + need;\n    if total <= remaining {\n        vec![total, remaining\
    \ - total]\n    } else {\n        vec![remaining + number, 0]\n    }\n}\n\nfn\
    \ main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11,\
    \ 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[15, 0]`,\n right: `[11, 4]`', /tmp/tmpi_jdz2pt.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660012997
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![];\n    if number + remaining >= need {\n        result.push(number\
    \ + need);\n        result.push(remaining - need);\n    } else {\n        result.push(number\
    \ + remaining);\n        result.push(0);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[9, -4]`,\n right: `[5, 0]`', /tmp/tmpj0vg7j7r.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660012997
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![number + need, remaining - need];\n    if result[1] < 0 {\n\
    \        result[1] = 0;\n        result[0] = number + remaining;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10),\
    \ vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660012997
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = Vec::new();\n    let mut total = number + remaining;\n    if total\
    \ >= need {\n        result.push(need);\n        result.push(total - need);\n\
    \    } else {\n        result.push(total);\n        result.push(0);\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmp__gc75xt.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660012997
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![];\n    let mut total = number + remaining;\n    if total\
    \ >= need {\n        total -= need;\n    } else {\n        total = 0;\n    }\n\
    \    result.push(number + remaining - total);\n    result.push(total);\n    result\n\
    }\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10),\
    \ vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpzcjry88a.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660012997
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut total = number + need;\n    if total > remaining {\n        total = remaining;\n\
    \    }\n    vec![total, remaining - total]\n}\n\nfn main() {\n    let candidate\
    \ = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[10, 0]`,\n right: `[11, 4]`', /tmp/tmp1qnsi3tr.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660012997
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut total = number + remaining;\n    if total >= need {\n        total = need;\n\
    \    }\n    vec![total, remaining - (total - number)]\n}\n\nfn main() {\n    let\
    \ candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpzkkdnftj.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660012997
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut total = number + need;\n    if total > remaining {\n        total = remaining;\n\
    \    }\n    vec![total, remaining - total]\n}\n\nfn main() {\n    let candidate\
    \ = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[10, 0]`,\n right: `[11, 4]`', /tmp/tmp1qnsi3tr.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660012997
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![];\n    if remaining >= need {\n        result.push(number\
    \ + need);\n        result.push(remaining - need);\n    } else {\n        result.push(number\
    \ + remaining);\n        result.push(0);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660012997
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![];\n    if number + remaining >= need {\n        result.push(number\
    \ + need);\n        result.push(remaining - need);\n    } else {\n        result.push(number\
    \ + remaining);\n        result.push(0);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[9, -4]`,\n right: `[5, 0]`', /tmp/tmpj0vg7j7r.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660012997
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut total = number + remaining;\n    if total >= need {\n        total = need;\n\
    \    }\n    vec![total, remaining - (total - number)]\n}\n\nfn main() {\n    let\
    \ candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpzkkdnftj.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660012997
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![];\n    let mut total = number + remaining;\n    if total\
    \ >= need {\n        result.push(need);\n        result.push(total - need);\n\
    \    } else {\n        result.push(total);\n        result.push(0);\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmp2_4uab8i.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660012997
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut total = number + remaining;\n    if total >= need {\n        total = need;\n\
    \    }\n    vec![total, remaining - (total - number)]\n}\n\nfn main() {\n    let\
    \ candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpzkkdnftj.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660012997
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![];\n    if number + remaining >= need {\n        result.push(number\
    \ + need);\n        result.push(remaining - need);\n    } else {\n        result.push(number\
    \ + remaining);\n        result.push(0);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[9, -4]`,\n right: `[5, 0]`', /tmp/tmpj0vg7j7r.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660012997
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut eaten = number;\n    let mut left = remaining;\n    if left < need {\n \
    \       eaten += left;\n        left = 0;\n    } else {\n        eaten += need;\n\
    \        left -= need;\n    }\n    vec![eaten, left]\n}\n\nfn main() {\n    let\
    \ candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660012997
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![];\n    let mut eaten = number;\n    let mut left = remaining;\n\
    \    if left >= need {\n        eaten += need;\n        left -= need;\n    } else\
    \ {\n        eaten += left;\n        left = 0;\n    }\n    result.push(eaten);\n\
    \    result.push(left);\n    result\n}\n\nfn main() {\n    let candidate = eat;\n\
    \    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660012997
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut eaten = number;\n    let mut left = remaining;\n    if remaining >= need\
    \ {\n        eaten += need;\n        left -= need;\n    } else {\n        eaten\
    \ += remaining;\n        left = 0;\n    }\n    vec![eaten, left]\n}\n\nfn main()\
    \ {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660012997
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut total = number + remaining;\n    if total >= need {\n        total = need;\n\
    \    }\n    vec![total, remaining - (total - number)]\n}\n\nfn main() {\n    let\
    \ candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpzkkdnftj.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660012997
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut total = number + remaining;\n    if total >= need {\n        total = need;\n\
    \    }\n    vec![total, remaining - (total - number)]\n}\n\nfn main() {\n    let\
    \ candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpzkkdnftj.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660012997
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut eaten = number;\n    let mut left = remaining;\n    if left >= need {\n\
    \        eaten += need;\n        left -= need;\n    } else {\n        eaten +=\
    \ left;\n        left = 0;\n    }\n    vec![eaten, left]\n}\n\nfn main() {\n \
    \   let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660012997
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![];\n    if number + remaining < need {\n        result.push(number\
    \ + remaining);\n        result.push(0);\n    } else {\n        result.push(need);\n\
    \        result.push(remaining - (need - number));\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11,\
    \ 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpsmhm39p5.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660012997
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![];\n    let mut total = number + remaining;\n    if total\
    \ >= need {\n        result.push(need);\n        result.push(total - need);\n\
    \    } else {\n        result.push(total);\n        result.push(0);\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmp2_4uab8i.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660012997
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = Vec::new();\n    let mut total = number + remaining;\n    if total\
    \ >= need {\n        result.push(need);\n        result.push(total - need);\n\
    \    } else {\n        result.push(total);\n        result.push(0);\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmp__gc75xt.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660012997
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![number + need, remaining - need];\n    if result[1] < 0 {\n\
    \        result[1] = 0;\n        result[0] = number + remaining;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10),\
    \ vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660012997
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![];\n    let mut total = number + remaining;\n    if total\
    \ >= need {\n        result.push(need);\n        result.push(total - need);\n\
    \    } else {\n        result.push(total);\n        result.push(0);\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmp2_4uab8i.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660012997
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut eaten = number;\n    let mut left = remaining;\n    if left >= need {\n\
    \        eaten += need;\n        left -= need;\n    } else {\n        eaten +=\
    \ left;\n        left = 0;\n    }\n    vec![eaten, left]\n}\n\nfn main() {\n \
    \   let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660012997
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![number + need, remaining - need];\n    if result[1] < 0 {\n\
    \        result[1] = 0;\n        result[0] = number + remaining;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10),\
    \ vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660012997
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut total = number + remaining;\n    if total >= need {\n        total = need;\n\
    \    }\n    vec![total, remaining - (total - number)]\n}\n\nfn main() {\n    let\
    \ candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpzkkdnftj.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660012997
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![];\n    let mut total = number + remaining;\n    if total\
    \ >= need {\n        result.push(need);\n        result.push(total - need);\n\
    \    } else {\n        result.push(total);\n        result.push(0);\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmp2_4uab8i.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660012997
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut eaten = number;\n    let mut left = remaining;\n    if left >= need {\n\
    \        eaten += need;\n        left -= need;\n    } else {\n        eaten +=\
    \ left;\n        left = 0;\n    }\n    vec![eaten, left]\n}\n\nfn main() {\n \
    \   let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660012997
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![number + need, remaining - need];\n    if result[1] < 0 {\n\
    \        result[1] = 0;\n        result[0] = number + remaining;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10),\
    \ vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660012997
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut total = number + remaining;\n    if total < need {\n        total = number\
    \ + remaining;\n    } else {\n        total = number + need;\n    }\n    vec![total,\
    \ remaining - need]\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, -6]`,\n right: `[7, 0]`', /tmp/tmp5caqg8qr.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660012997
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut eaten = number;\n    let mut left = remaining;\n    if need > remaining\
    \ {\n        eaten += remaining;\n        left = 0;\n    } else {\n        eaten\
    \ += need;\n        left -= need;\n    }\n    vec![eaten, left]\n}\n\nfn main()\
    \ {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660012997
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut eaten = number;\n    let mut left = remaining;\n    if left >= need {\n\
    \        eaten += need;\n        left -= need;\n    } else {\n        eaten +=\
    \ left;\n        left = 0;\n    }\n    vec![eaten, left]\n}\n\nfn main() {\n \
    \   let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660012997
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut eaten = number;\n    let mut left = remaining;\n    if left >= need {\n\
    \        eaten += need;\n        left -= need;\n    } else {\n        eaten +=\
    \ left;\n        left = 0;\n    }\n    vec![eaten, left]\n}\n\nfn main() {\n \
    \   let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660012997
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut eaten = number;\n    let mut left = remaining;\n    if need > remaining\
    \ {\n        eaten += remaining;\n        left = 0;\n    } else {\n        eaten\
    \ += need;\n        left -= need;\n    }\n    vec![eaten, left]\n}\n\nfn main()\
    \ {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660012997
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut total = number + remaining;\n    if total >= need {\n        total = need;\n\
    \    }\n    vec![total, remaining - (total - number)]\n}\n\nfn main() {\n    let\
    \ candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpzkkdnftj.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660012997
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![];\n    if number + remaining >= need {\n        result.push(number\
    \ + need);\n        result.push(remaining - need);\n    } else {\n        result.push(number\
    \ + remaining);\n        result.push(0);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[9, -4]`,\n right: `[5, 0]`', /tmp/tmpj0vg7j7r.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660012997
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![];\n    let mut total = number + remaining;\n    if total\
    \ >= need {\n        result.push(need);\n        result.push(total - need);\n\
    \    } else {\n        result.push(total);\n        result.push(0);\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmp2_4uab8i.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660012997
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut number = number;\n    let mut remaining = remaining;\n    let mut need =\
    \ need;\n    if remaining >= need {\n        number += need;\n        remaining\
    \ -= need;\n    } else {\n        number += remaining;\n        remaining = 0;\n\
    \    }\n    vec![number, remaining]\n}\n\nfn main() {\n    let candidate = eat;\n\
    \    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660012997
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![];\n    if remaining >= need {\n        result.push(number\
    \ + need);\n        result.push(remaining - need);\n    } else {\n        result.push(number\
    \ + remaining);\n        result.push(0);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660012997
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![];\n    let mut total_eaten = number + need;\n    if total_eaten\
    \ > remaining {\n        total_eaten = remaining;\n    }\n    result.push(total_eaten);\n\
    \    result.push(remaining - total_eaten);\n    result\n}\n\nfn main() {\n   \
    \ let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n  \
    \  assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10,\
    \ 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[10, 0]`,\n right: `[11, 4]`', /tmp/tmpymw82lmd.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660012997
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut total = number + remaining;\n    if total >= need {\n        total = need;\n\
    \    }\n    vec![total, remaining - (total - number)]\n}\n\nfn main() {\n    let\
    \ candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpzkkdnftj.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660012997
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![];\n    let mut total_carrots = number + remaining;\n    if\
    \ total_carrots >= need {\n        result.push(need);\n        result.push(total_carrots\
    \ - need);\n    } else {\n        result.push(total_carrots);\n        result.push(0);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpcmttblbo.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660012997
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![];\n    let mut total = number + remaining;\n    if total\
    \ >= need {\n        result.push(need);\n        result.push(total - need);\n\
    \    } else {\n        result.push(total);\n        result.push(0);\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmp2_4uab8i.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660012997
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut total = number + remaining;\n    if total >= need {\n        total = need;\n\
    \    }\n    vec![total, remaining - (total - number)]\n}\n\nfn main() {\n    let\
    \ candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpzkkdnftj.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660012997
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![];\n    let mut total_eaten = number + need;\n    let mut\
    \ remaining_carrots = remaining - need;\n    if remaining_carrots < 0 {\n    \
    \    total_eaten += remaining_carrots;\n        remaining_carrots = 0;\n    }\n\
    \    result.push(total_eaten);\n    result.push(remaining_carrots);\n    result\n\
    }\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10),\
    \ vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660012997
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![number + need, remaining - need];\n    if result[1] < 0 {\n\
    \        result[1] = 0;\n        result[0] = number + remaining;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10),\
    \ vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660012997
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![];\n    if remaining >= need {\n        result.push(number\
    \ + need);\n        result.push(remaining - need);\n    } else {\n        result.push(number\
    \ + remaining);\n        result.push(0);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660012997
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![];\n    if number + remaining >= need {\n        result.push(number\
    \ + need);\n        result.push(remaining - need);\n    } else {\n        result.push(number\
    \ + remaining);\n        result.push(0);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[9, -4]`,\n right: `[5, 0]`', /tmp/tmpj0vg7j7r.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660012997
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut eaten = number;\n    let mut left = remaining;\n    if left >= need {\n\
    \        eaten += need;\n        left -= need;\n    } else {\n        eaten +=\
    \ left;\n        left = 0;\n    }\n    vec![eaten, left]\n}\n\nfn main() {\n \
    \   let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660012997
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![];\n    if remaining >= need {\n        result.push(number\
    \ + need);\n        result.push(remaining - need);\n    } else {\n        result.push(number\
    \ + remaining);\n        result.push(0);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660012997
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![number + need, remaining - need];\n    if result[1] < 0 {\n\
    \        result[1] = 0;\n        result[0] = number + remaining;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10),\
    \ vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660012997
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut eaten = number;\n    let mut left = remaining;\n    if left >= need {\n\
    \        eaten += need;\n        left -= need;\n    } else {\n        eaten +=\
    \ left;\n        left = 0;\n    }\n    vec![eaten, left]\n}\n\nfn main() {\n \
    \   let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660012997
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut total = number + remaining;\n    if total >= need {\n        total = need;\n\
    \    }\n    vec![total, remaining - (total - number)]\n}\n\nfn main() {\n    let\
    \ candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpzkkdnftj.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660012997
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![];\n    if remaining < need {\n        result.push(number\
    \ + remaining);\n        result.push(0);\n    } else {\n        result.push(number\
    \ + need);\n        result.push(remaining - need);\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11,\
    \ 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660012997
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut total = number + remaining;\n    if total < need {\n        total = number\
    \ + remaining;\n    } else {\n        total = number + need;\n    }\n    vec![total,\
    \ remaining - need]\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, -6]`,\n right: `[7, 0]`', /tmp/tmp5caqg8qr.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660012997
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut total = number + remaining;\n    if total >= need {\n        total = need;\n\
    \    }\n    vec![total, remaining - (total - number)]\n}\n\nfn main() {\n    let\
    \ candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpzkkdnftj.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660012997
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![];\n    if remaining >= need {\n        result.push(number\
    \ + need);\n        result.push(remaining - need);\n    } else {\n        result.push(number\
    \ + remaining);\n        result.push(0);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660012997
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut eaten = number;\n    let mut left = remaining;\n    if left >= need {\n\
    \        eaten += need;\n        left -= need;\n    } else {\n        eaten +=\
    \ left;\n        left = 0;\n    }\n    vec![eaten, left]\n}\n\nfn main() {\n \
    \   let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660012997
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![];\n    let mut total = number + remaining;\n    if total\
    \ >= need {\n        result.push(need);\n        result.push(total - need);\n\
    \    } else {\n        result.push(total);\n        result.push(0);\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmp2_4uab8i.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660012997
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut total = number + remaining;\n    if total >= need {\n        total = need;\n\
    \    }\n    vec![total, remaining - (total - number)]\n}\n\nfn main() {\n    let\
    \ candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpzkkdnftj.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660012997
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut eaten = number;\n    let mut left = remaining;\n    if left >= need {\n\
    \        eaten += need;\n        left -= need;\n    } else {\n        eaten +=\
    \ left;\n        left = 0;\n    }\n    vec![eaten, left]\n}\n\nfn main() {\n \
    \   let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660012997
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![number + need, remaining - need];\n    if result[1] < 0 {\n\
    \        result[1] = 0;\n        result[0] = number + remaining;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10),\
    \ vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660012997
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut total = number + remaining;\n    let mut left = 0;\n    if total >= need\
    \ {\n        total = need;\n        left = remaining - (need - number);\n    }\n\
    \    vec![total, left]\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpkesy7i3m.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660012997
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut total = number + remaining;\n    if total >= need {\n        total = need;\n\
    \    }\n    vec![total, remaining - (total - number)]\n}\n\nfn main() {\n    let\
    \ candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpzkkdnftj.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660012997
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut eaten = number;\n    let mut left = remaining;\n    if left >= need {\n\
    \        eaten += need;\n        left -= need;\n    } else {\n        eaten +=\
    \ left;\n        left = 0;\n    }\n    vec![eaten, left]\n}\n\nfn main() {\n \
    \   let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660012997
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut number = number;\n    let mut need = need;\n    let mut remaining = remaining;\n\
    \    if number + remaining < need {\n        return vec![number + remaining, 0];\n\
    \    }\n    number += need;\n    remaining -= need;\n    vec![number, remaining]\n\
    }\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10),\
    \ vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[9, -4]`,\n right: `[5, 0]`', /tmp/tmptb_f31ce.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660012997
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut eaten = number;\n    let mut left = remaining;\n    if left >= need {\n\
    \        eaten += need;\n        left -= need;\n    } else {\n        eaten +=\
    \ left;\n        left = 0;\n    }\n    vec![eaten, left]\n}\n\nfn main() {\n \
    \   let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660012997
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut eaten = number;\n    let mut left = remaining;\n    if left >= need {\n\
    \        eaten += need;\n        left -= need;\n    } else {\n        eaten +=\
    \ left;\n        left = 0;\n    }\n    vec![eaten, left]\n}\n\nfn main() {\n \
    \   let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660012997
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut total = number + remaining;\n    if total >= need {\n        total = need;\n\
    \    }\n    vec![total, remaining - (total - number)]\n}\n\nfn main() {\n    let\
    \ candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpzkkdnftj.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660012997
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![];\n    if number + remaining < need {\n        result.push(number\
    \ + remaining);\n        result.push(0);\n    } else {\n        result.push(number\
    \ + need);\n        result.push(remaining - need);\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11,\
    \ 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[9, -4]`,\n right: `[5, 0]`', /tmp/tmpynrdbhvc.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660012997
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![];\n    if number + remaining < need {\n        result.push(number\
    \ + remaining);\n        result.push(0);\n    } else {\n        result.push(number\
    \ + need);\n        result.push(remaining - need);\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11,\
    \ 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[9, -4]`,\n right: `[5, 0]`', /tmp/tmpynrdbhvc.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660012997
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![number + need, remaining - need];\n    if result[1] < 0 {\n\
    \        result[1] = 0;\n        result[0] = number + remaining;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10),\
    \ vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660012997
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![];\n    if remaining >= need {\n        result.push(number\
    \ + need);\n        result.push(remaining - need);\n    } else {\n        result.push(number\
    \ + remaining);\n        result.push(0);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660012997
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut total = number + remaining;\n    if total >= need {\n        total = need;\n\
    \    }\n    vec![total, remaining - (total - number)]\n}\n\nfn main() {\n    let\
    \ candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpzkkdnftj.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660012997
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut total = number + remaining;\n    if total >= need {\n        total = need;\n\
    \    }\n    vec![total, remaining - (total - number)]\n}\n\nfn main() {\n    let\
    \ candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpzkkdnftj.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660012997
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![number + need, remaining - need];\n    if result[1] < 0 {\n\
    \        result[1] = 0;\n        result[0] = number + remaining;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10),\
    \ vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660012997
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut total = number + need;\n    if total > remaining {\n        total = remaining;\n\
    \    }\n    vec![total, remaining - total]\n}\n\nfn main() {\n    let candidate\
    \ = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[10, 0]`,\n right: `[11, 4]`', /tmp/tmp1qnsi3tr.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660012997
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![];\n    let mut eaten = number;\n    let mut left = remaining;\n\
    \    if need > remaining {\n        eaten += remaining;\n        left = 0;\n \
    \   } else {\n        eaten += need;\n        left -= need;\n    }\n    result.push(eaten);\n\
    \    result.push(left);\n    result\n}\n\nfn main() {\n    let candidate = eat;\n\
    \    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660012997
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![number + need, remaining - need];\n    if result[1] < 0 {\n\
    \        result[1] = 0;\n        result[0] = number + remaining;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10),\
    \ vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660012997
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut eaten = number;\n    let mut left = remaining;\n    if need > remaining\
    \ {\n        eaten += remaining;\n        left = 0;\n    } else {\n        eaten\
    \ += need;\n        left -= need;\n    }\n    vec![eaten, left]\n}\n\nfn main()\
    \ {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660012997
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut total = number + need;\n    if total > remaining {\n        total = remaining;\n\
    \    }\n    vec![total, remaining - total]\n}\n\nfn main() {\n    let candidate\
    \ = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[10, 0]`,\n right: `[11, 4]`', /tmp/tmp1qnsi3tr.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660012997
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut eaten = number;\n    let mut left = remaining;\n    if left >= need {\n\
    \        eaten += need;\n        left -= need;\n    } else {\n        eaten +=\
    \ left;\n        left = 0;\n    }\n    vec![eaten, left]\n}\n\nfn main() {\n \
    \   let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660012997
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut eaten = number;\n    let mut left = remaining;\n    if left >= need {\n\
    \        eaten += need;\n        left -= need;\n    } else {\n        eaten +=\
    \ left;\n        left = 0;\n    }\n    vec![eaten, left]\n}\n\nfn main() {\n \
    \   let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660012997
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut eaten = number;\n    let mut left = remaining;\n    if left >= need {\n\
    \        eaten += need;\n        left -= need;\n    } else {\n        eaten +=\
    \ left;\n        left = 0;\n    }\n    vec![eaten, left]\n}\n\nfn main() {\n \
    \   let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660012997
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut total = number + need;\n    if total > remaining {\n        total = remaining;\n\
    \    }\n    vec![total, remaining - total]\n}\n\nfn main() {\n    let candidate\
    \ = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[10, 0]`,\n right: `[11, 4]`', /tmp/tmp1qnsi3tr.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660012997
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut total = number + remaining;\n    if total >= need {\n        total = need;\n\
    \    }\n    vec![total, remaining - (total - number)]\n}\n\nfn main() {\n    let\
    \ candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpzkkdnftj.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660012997
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut total = number + remaining;\n    if total >= need {\n        total = need;\n\
    \    }\n    vec![total, remaining - (total - number)]\n}\n\nfn main() {\n    let\
    \ candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpzkkdnftj.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660012997
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut eaten = number;\n    let mut left = remaining;\n    if left >= need {\n\
    \        eaten += need;\n        left -= need;\n    } else {\n        eaten +=\
    \ left;\n        left = 0;\n    }\n    vec![eaten, left]\n}\n\nfn main() {\n \
    \   let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660012997
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut eaten = number;\n    let mut left = remaining;\n    if left >= need {\n\
    \        eaten += need;\n        left -= need;\n    } else {\n        eaten +=\
    \ left;\n        left = 0;\n    }\n    vec![eaten, left]\n}\n\nfn main() {\n \
    \   let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660012997
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![];\n    let mut total = number + remaining;\n    if total\
    \ >= need {\n        result.push(need);\n        result.push(total - need);\n\
    \    } else {\n        result.push(total);\n        result.push(0);\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmp2_4uab8i.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660012997
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut total = number + remaining;\n    if total >= need {\n        total = need;\n\
    \    }\n    vec![total, remaining - (total - number)]\n}\n\nfn main() {\n    let\
    \ candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpzkkdnftj.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660012997
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = Vec::new();\n    if remaining >= need {\n        result.push(number\
    \ + need);\n        result.push(remaining - need);\n    } else {\n        result.push(number\
    \ + remaining);\n        result.push(0);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660012997
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut eaten = number;\n    let mut left = remaining;\n    if left < need {\n \
    \       eaten += left;\n        left = 0;\n    } else {\n        eaten += need;\n\
    \        left -= need;\n    }\n    vec![eaten, left]\n}\n\nfn main() {\n    let\
    \ candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660012997
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![];\n    let mut eaten = number;\n    let mut left = remaining;\n\
    \    if left >= need {\n        eaten += need;\n        left -= need;\n    } else\
    \ {\n        eaten += left;\n        left = 0;\n    }\n    result.push(eaten);\n\
    \    result.push(left);\n    result\n}\n\nfn main() {\n    let candidate = eat;\n\
    \    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660012997
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![];\n    let mut total = number + remaining;\n    if total\
    \ >= need {\n        result.push(need);\n        result.push(total - need);\n\
    \    } else {\n        result.push(total);\n        result.push(0);\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmp2_4uab8i.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660012997
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![];\n    if remaining >= need {\n        result.push(number\
    \ + need);\n        result.push(remaining - need);\n    } else {\n        result.push(number\
    \ + remaining);\n        result.push(0);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660012997
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![number + need, remaining - need];\n    if result[1] < 0 {\n\
    \        result[1] = 0;\n        result[0] = number + remaining;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10),\
    \ vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660012997
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = Vec::new();\n    if remaining >= need {\n        result.push(number\
    \ + need);\n        result.push(remaining - need);\n    } else {\n        result.push(number\
    \ + remaining);\n        result.push(0);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660012997
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut eaten = number;\n    let mut left = remaining;\n    if left >= need {\n\
    \        eaten += need;\n        left -= need;\n    } else {\n        eaten +=\
    \ left;\n        left = 0;\n    }\n    vec![eaten, left]\n}\n\nfn main() {\n \
    \   let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660012997
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![];\n    let mut total = number + remaining;\n    if total\
    \ >= need {\n        result.push(need);\n        result.push(total - need);\n\
    \    } else {\n        result.push(total);\n        result.push(0);\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmp2_4uab8i.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660012997
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![];\n    if number + remaining >= need {\n        result.push(number\
    \ + need);\n        result.push(remaining - need);\n    } else {\n        result.push(number\
    \ + remaining);\n        result.push(0);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[9, -4]`,\n right: `[5, 0]`', /tmp/tmpj0vg7j7r.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660012997
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![];\n    let mut total = number + remaining;\n    if total\
    \ >= need {\n        result.push(need);\n        result.push(total - need);\n\
    \    } else {\n        result.push(total);\n        result.push(0);\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmp2_4uab8i.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660012997
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut total = number + need;\n    if total > remaining {\n        total = remaining;\n\
    \    }\n    vec![total, remaining - total]\n}\n\nfn main() {\n    let candidate\
    \ = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[10, 0]`,\n right: `[11, 4]`', /tmp/tmp1qnsi3tr.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660012997
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut total = number + remaining;\n    let mut left = 0;\n    if total >= need\
    \ {\n        total = need;\n        left = remaining - (need - number);\n    }\n\
    \    vec![total, left]\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpkesy7i3m.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660012997
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![];\n    let mut total = number + remaining;\n    if total\
    \ >= need {\n        result.push(need);\n        result.push(total - need);\n\
    \    } else {\n        result.push(total);\n        result.push(0);\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmp2_4uab8i.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660012997
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut eaten = number;\n    let mut left = remaining;\n    if left >= need {\n\
    \        eaten += need;\n        left -= need;\n    } else {\n        eaten +=\
    \ left;\n        left = 0;\n    }\n    vec![eaten, left]\n}\n\nfn main() {\n \
    \   let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660012997
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut total = number + remaining;\n    if total >= need {\n        total = need;\n\
    \    }\n    vec![total, remaining - (total - number)]\n}\n\nfn main() {\n    let\
    \ candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpzkkdnftj.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660012997
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut eaten = number;\n    let mut left = remaining;\n    if need > remaining\
    \ {\n        eaten += remaining;\n        left = 0;\n    } else {\n        eaten\
    \ += need;\n        left -= need;\n    }\n    vec![eaten, left]\n}\n\nfn main()\
    \ {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660012997
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![number + need, remaining - need];\n    if result[1] < 0 {\n\
    \        result[1] = 0;\n        result[0] = number + remaining;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10),\
    \ vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660012997
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![number + need, remaining - need];\n    if result[1] < 0 {\n\
    \        result[1] = 0;\n        result[0] = number + remaining;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10),\
    \ vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660012997
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut number = number;\n    let mut need = need;\n    let mut remaining = remaining;\n\
    \    let mut result = vec![];\n    if number + remaining >= need {\n        result.push(number\
    \ + need);\n        result.push(remaining - need);\n    } else {\n        result.push(number\
    \ + remaining);\n        result.push(0);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[9, -4]`,\n right: `[5, 0]`', /tmp/tmpiss2desy.rs:49:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660012997
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut total = number + remaining;\n    if total >= need {\n        total = need;\n\
    \    }\n    vec![total, remaining - (total - number)]\n}\n\nfn main() {\n    let\
    \ candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpzkkdnftj.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660012997
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![];\n    if number + remaining >= need {\n        result.push(number\
    \ + need);\n        result.push(remaining - need);\n    } else {\n        result.push(number\
    \ + remaining);\n        result.push(0);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[9, -4]`,\n right: `[5, 0]`', /tmp/tmpj0vg7j7r.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660012997
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut total = number + remaining;\n    if total < need {\n        total = number\
    \ + remaining;\n    } else {\n        total = number + need;\n    }\n    vec![total,\
    \ remaining - need]\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[7, -6]`,\n right: `[7, 0]`', /tmp/tmp5caqg8qr.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660012997
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut eaten = number;\n    let mut left = remaining;\n    if left >= need {\n\
    \        eaten += need;\n        left -= need;\n    } else {\n        eaten +=\
    \ left;\n        left = 0;\n    }\n    vec![eaten, left]\n}\n\nfn main() {\n \
    \   let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660012997
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut eaten = number;\n    let mut left = remaining;\n    if left >= need {\n\
    \        eaten += need;\n        left -= need;\n    } else {\n        eaten +=\
    \ left;\n        left = 0;\n    }\n    vec![eaten, left]\n}\n\nfn main() {\n \
    \   let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660012997
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![];\n    if number + remaining >= need {\n        result.push(number\
    \ + need);\n        result.push(remaining - need);\n    } else {\n        result.push(number\
    \ + remaining);\n        result.push(0);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[9, -4]`,\n right: `[5, 0]`', /tmp/tmpj0vg7j7r.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660012997
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut total = number + need;\n    if total > remaining {\n        total = remaining;\n\
    \    }\n    vec![total, remaining - total]\n}\n\nfn main() {\n    let candidate\
    \ = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[10, 0]`,\n right: `[11, 4]`', /tmp/tmp1qnsi3tr.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660012997
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut total = number + remaining;\n    if total >= need {\n        total = need;\n\
    \    }\n    vec![total, remaining - (total - number)]\n}\n\nfn main() {\n    let\
    \ candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpzkkdnftj.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660012997
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = vec![number + need, remaining - need];\n    if result[1] < 0 {\n\
    \        result[1] = 0;\n        result[0] = number + remaining;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10),\
    \ vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660012997
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut result = Vec::new();\n    let mut total = number + remaining;\n    if total\
    \ >= need {\n        result.push(need);\n        result.push(total - need);\n\
    \    } else {\n        result.push(total);\n        result.push(0);\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = eat;\n    assert_eq!(candidate(5,\
    \ 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n  \
    \  assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2,\
    \ 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4,\
    \ 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmp__gc75xt.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660012997
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut eaten = number;\n    let mut left = remaining;\n    if need > remaining\
    \ {\n        eaten += remaining;\n        left = 0;\n    } else {\n        eaten\
    \ += need;\n        left -= need;\n    }\n    vec![eaten, left]\n}\n\nfn main()\
    \ {\n    let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660012997
- exit_code: 101
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut total = number + remaining;\n    if total >= need {\n        total = need;\n\
    \    }\n    vec![total, remaining - (total - number)]\n}\n\nfn main() {\n    let\
    \ candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n    assert_eq!(candidate(4,\
    \ 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1, 10, 10), vec![11, 0]);\n \
    \   assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n    assert_eq!(candidate(4,\
    \ 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5, 1), vec![5, 0]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 9]`,\n right: `[11, 4]`', /tmp/tmpzkkdnftj.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660012997
- exit_code: 0
  program: "/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(5, 6, 10)\n/// vec![11, 4]\n///\
    \ >>> eat(4, 8, 9)\n/// vec![12, 1]\n/// >>> eat(1, 10, 10)\n/// vec![11, 0]\n\
    /// >>> eat(2, 11, 5)\n/// vec![7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    fn eat(number: isize, need: isize, remaining: isize) -> Vec<isize> {\n    let\
    \ mut eaten = number;\n    let mut left = remaining;\n    if left >= need {\n\
    \        eaten += need;\n        left -= need;\n    } else {\n        eaten +=\
    \ left;\n        left = 0;\n    }\n    vec![eaten, left]\n}\n\nfn main() {\n \
    \   let candidate = eat;\n    assert_eq!(candidate(5, 6, 10), vec![11, 4]);\n\
    \    assert_eq!(candidate(4, 8, 9), vec![12, 1]);\n    assert_eq!(candidate(1,\
    \ 10, 10), vec![11, 0]);\n    assert_eq!(candidate(2, 11, 5), vec![7, 0]);\n \
    \   assert_eq!(candidate(4, 5, 7), vec![9, 2]);\n    assert_eq!(candidate(4, 5,\
    \ 1), vec![5, 0]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660012997
