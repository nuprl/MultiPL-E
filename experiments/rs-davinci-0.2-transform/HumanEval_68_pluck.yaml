name: HumanEval_68_pluck
language: rs
prompt: "/// \"Given an array representing a branch of a tree that has non-negative\
  \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
  \ The plucked node should be the node with the smallest even value.\n/// If multiple\
  \ nodes with the same smallest even value are found return the node that has smallest\
  \ index.\n/// The plucked node should be returned in a list, [ smalest_value, its\
  \ index ],\n/// If there are no even values or the given array is empty, return\
  \ [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
  \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
  /// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation: 2 has the smallest\
  \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(vec![])\n\
  /// Vec::<isize>::new()\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3, 0, 4, 2])\n\
  /// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
  /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
  /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>)\
  \ -> Vec<isize> {\n"
tests: "}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!({left}, {right});\n\
  \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
  \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
  \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
completions: ["    let mut min_even = std::isize::MAX;\n    let mut min_even_idx =\
    \ std::isize::MAX;\n    for (idx, val) in arr.iter().enumerate() {\n        if\
    \ val % 2 == 0 && val < &min_even {\n            min_even = *val;\n          \
    \  min_even_idx = idx as isize;\n        }\n    }\n    if min_even == std::isize::MAX\
    \ {\n        Vec::<isize>::new()\n    } else {\n        vec![min_even, min_even_idx]\n\
    \    }", "    let mut min_even = std::isize::MAX;\n    let mut min_even_idx =\
    \ std::isize::MAX;\n    for (idx, val) in arr.iter().enumerate() {\n        if\
    \ val % 2 == 0 && val < &min_even {\n            min_even = *val;\n          \
    \  min_even_idx = idx as isize;\n        }\n    }\n    if min_even == std::isize::MAX\
    \ {\n        return Vec::<isize>::new();\n    }\n    vec![min_even, min_even_idx]",
  "    let mut min_even = std::isize::MAX;\n    let mut min_even_index = std::isize::MAX;\n\
    \    for (i, x) in arr.iter().enumerate() {\n        if x % 2 == 0 && x < &min_even\
    \ {\n            min_even = *x;\n            min_even_index = i as isize;\n  \
    \      }\n    }\n    if min_even == std::isize::MAX {\n        Vec::<isize>::new()\n\
    \    } else {\n        vec![min_even, min_even_index]\n    }", "    let mut min_even\
    \ = None;\n    let mut min_even_index = None;\n    for (i, &x) in arr.iter().enumerate()\
    \ {\n        if x % 2 == 0 {\n            if min_even.is_none() || x < min_even.unwrap()\
    \ {\n                min_even = Some(x);\n                min_even_index = Some(i);\n\
    \            }\n        }\n    }\n    match (min_even, min_even_index) {\n   \
    \     (Some(x), Some(i)) => vec![x, i as isize],\n        _ => Vec::<isize>::new(),\n\
    \    }", "    let mut evens: Vec<isize> = Vec::new();\n    let mut even_indexes:\
    \ Vec<usize> = Vec::new();\n    for (index, value) in arr.iter().enumerate() {\n\
    \        if value % 2 == 0 {\n            evens.push(*value);\n            even_indexes.push(index);\n\
    \        }\n    }\n    if evens.len() == 0 {\n        return Vec::<isize>::new();\n\
    \    }\n    let mut min_even = evens[0];\n    let mut min_even_index = even_indexes[0];\n\
    \    for (index, value) in evens.iter().enumerate() {\n        if value < &min_even\
    \ {\n            min_even = *value;\n            min_even_index = even_indexes[index];\n\
    \        }\n    }\n    vec![min_even, min_even_index as isize]", "    let mut\
    \ evens: Vec<isize> = Vec::new();\n    for (i, n) in arr.iter().enumerate() {\n\
    \        if n % 2 == 0 {\n            evens.push(i as isize);\n        }\n   \
    \ }\n    if evens.is_empty() {\n        return Vec::<isize>::new();\n    }\n \
    \   let min_index = evens.iter().min().unwrap();\n    let min_value = arr[*min_index\
    \ as usize];\n    vec![min_value, *min_index]", "    let mut evens: Vec<isize>\
    \ = arr.iter().filter(|&x| x % 2 == 0).cloned().collect();\n    evens.sort();\n\
    \    if evens.is_empty() {\n        return Vec::<isize>::new();\n    }\n    let\
    \ min = evens[0];\n    let mut min_index = 0;\n    for (i, &x) in arr.iter().enumerate()\
    \ {\n        if x == min {\n            min_index = i;\n            break;\n \
    \       }\n    }\n    vec![min, min_index as isize]", "    let mut evens: Vec<isize>\
    \ = Vec::new();\n    for (i, n) in arr.iter().enumerate() {\n        if n % 2\
    \ == 0 {\n            evens.push(i as isize);\n        }\n    }\n    if evens.is_empty()\
    \ {\n        return Vec::<isize>::new();\n    }\n    let min_index = evens[0];\n\
    \    let min_value = arr[min_index as usize];\n    for i in evens {\n        if\
    \ arr[i as usize] < min_value {\n            min_index = i;\n            min_value\
    \ = arr[i as usize];\n        }\n    }\n    vec![min_value, min_index]", "   \
    \ let mut min_even = std::isize::MAX;\n    let mut min_even_index = std::isize::MAX;\n\
    \    for (index, value) in arr.iter().enumerate() {\n        if value % 2 == 0\
    \ && value < &min_even {\n            min_even = *value;\n            min_even_index\
    \ = index as isize;\n        }\n    }\n    if min_even == std::isize::MAX {\n\
    \        return Vec::<isize>::new();\n    }\n    vec![min_even, min_even_index]",
  "    let mut min_even = std::isize::MAX;\n    let mut min_even_idx = std::isize::MAX;\n\
    \    for (idx, val) in arr.iter().enumerate() {\n        if val % 2 == 0 && val\
    \ < &min_even {\n            min_even = *val;\n            min_even_idx = idx\
    \ as isize;\n        }\n    }\n    if min_even == std::isize::MAX {\n        return\
    \ Vec::<isize>::new();\n    }\n    vec![min_even, min_even_idx]", "    let mut\
    \ min_even = std::isize::MAX;\n    let mut min_even_idx = std::isize::MAX;\n \
    \   for (idx, &val) in arr.iter().enumerate() {\n        if val % 2 == 0 && val\
    \ < min_even {\n            min_even = val;\n            min_even_idx = idx as\
    \ isize;\n        }\n    }\n    if min_even == std::isize::MAX {\n        Vec::<isize>::new()\n\
    \    } else {\n        vec![min_even, min_even_idx]\n    }", "    let mut min_even\
    \ = std::isize::MAX;\n    let mut min_even_idx = std::isize::MAX;\n    for (idx,\
    \ &val) in arr.iter().enumerate() {\n        if val % 2 == 0 && val < min_even\
    \ {\n            min_even = val;\n            min_even_idx = idx as isize;\n \
    \       }\n    }\n    if min_even == std::isize::MAX {\n        Vec::<isize>::new()\n\
    \    } else {\n        vec![min_even, min_even_idx]\n    }", "    let mut evens:\
    \ Vec<isize> = Vec::new();\n    let mut even_idx: Vec<usize> = Vec::new();\n \
    \   for (idx, val) in arr.iter().enumerate() {\n        if val % 2 == 0 {\n  \
    \          evens.push(*val);\n            even_idx.push(idx);\n        }\n   \
    \ }\n    if evens.len() == 0 {\n        return Vec::<isize>::new();\n    }\n \
    \   let mut min_even = evens[0];\n    let mut min_even_idx = even_idx[0];\n  \
    \  for (idx, val) in evens.iter().enumerate() {\n        if *val < min_even {\n\
    \            min_even = *val;\n            min_even_idx = even_idx[idx];\n   \
    \     }\n    }\n    vec![min_even, min_even_idx as isize]", "    let mut smallest_even\
    \ = std::isize::MAX;\n    let mut smallest_even_index = std::isize::MAX;\n   \
    \ for (i, v) in arr.iter().enumerate() {\n        if v % 2 == 0 && v < &smallest_even\
    \ {\n            smallest_even = *v;\n            smallest_even_index = i as isize;\n\
    \        }\n    }\n    if smallest_even == std::isize::MAX {\n        return Vec::<isize>::new();\n\
    \    }\n    vec![smallest_even, smallest_even_index]", "    let mut evens: Vec<isize>\
    \ = Vec::new();\n    for (i, n) in arr.iter().enumerate() {\n        if n % 2\
    \ == 0 {\n            evens.push(i as isize);\n        }\n    }\n    if evens.is_empty()\
    \ {\n        return Vec::<isize>::new();\n    }\n    let mut min_index = evens[0];\n\
    \    let mut min_value = arr[evens[0] as usize];\n    for i in evens {\n     \
    \   if arr[i as usize] < min_value {\n            min_value = arr[i as usize];\n\
    \            min_index = i;\n        }\n    }\n    vec![min_value, min_index]",
  "    let mut evens: Vec<isize> = Vec::new();\n    let mut even_indexes: Vec<usize>\
    \ = Vec::new();\n    for (i, v) in arr.iter().enumerate() {\n        if v % 2\
    \ == 0 {\n            evens.push(*v);\n            even_indexes.push(i);\n   \
    \     }\n    }\n    if evens.len() == 0 {\n        return Vec::<isize>::new();\n\
    \    }\n    let min_even = evens.iter().min().unwrap();\n    let min_even_index\
    \ = even_indexes[evens.iter().position(|&r| r == *min_even).unwrap()];\n    vec![*min_even,\
    \ min_even_index as isize]", "    let mut min_even = std::isize::MAX;\n    let\
    \ mut min_even_idx = std::isize::MAX;\n    for (idx, val) in arr.iter().enumerate()\
    \ {\n        if val % 2 == 0 && val < &min_even {\n            min_even = *val;\n\
    \            min_even_idx = idx as isize;\n        }\n    }\n    if min_even_idx\
    \ == std::isize::MAX {\n        Vec::<isize>::new()\n    } else {\n        vec![min_even,\
    \ min_even_idx]\n    }", "    let mut min_even = std::isize::MAX;\n    let mut\
    \ min_even_idx = std::isize::MAX;\n    for (idx, val) in arr.iter().enumerate()\
    \ {\n        if val % 2 == 0 && val < &min_even {\n            min_even = *val;\n\
    \            min_even_idx = idx as isize;\n        }\n    }\n    if min_even ==\
    \ std::isize::MAX {\n        return Vec::<isize>::new();\n    }\n    vec![min_even,\
    \ min_even_idx]", "    let mut min_even = std::isize::MAX;\n    let mut min_even_idx\
    \ = std::isize::MAX;\n    for (idx, val) in arr.iter().enumerate() {\n       \
    \ if val % 2 == 0 && val < &min_even {\n            min_even = *val;\n       \
    \     min_even_idx = idx as isize;\n        }\n    }\n    if min_even == std::isize::MAX\
    \ {\n        Vec::<isize>::new()\n    } else {\n        vec![min_even, min_even_idx]\n\
    \    }", "    let mut smallest_even = std::isize::MAX;\n    let mut smallest_even_index\
    \ = std::isize::MAX;\n    for (i, v) in arr.iter().enumerate() {\n        if *v\
    \ % 2 == 0 && *v < smallest_even {\n            smallest_even = *v;\n        \
    \    smallest_even_index = i as isize;\n        }\n    }\n    if smallest_even\
    \ == std::isize::MAX {\n        return Vec::<isize>::new();\n    }\n    vec![smallest_even,\
    \ smallest_even_index]"]
stop_tokens:
- "\n}"
