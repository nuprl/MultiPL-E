language: rs
name: HumanEval_12_longest
results:
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for string in strings {\n\
    \        match longest {\n            None => longest = Some(string),\n      \
    \      Some(ref mut l) => {\n                if l.len() < string.len() {\n   \
    \                 *l = string;\n                }\n            }\n        }\n\
    \    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest_string = None;\n    for string in strings\
    \ {\n        match longest_string {\n            None => longest_string = Some(string),\n\
    \            Some(ref mut longest) => {\n                if string.len() > longest.len()\
    \ {\n                    *longest = string;\n                }\n            }\n\
    \        }\n    }\n    longest_string\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for string in strings {\n\
    \        match longest {\n            None => longest = Some(string),\n      \
    \      Some(ref mut current) => {\n                if string.len() > current.len()\
    \ {\n                    *current = string;\n                }\n            }\n\
    \        }\n    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for s in strings {\n    \
    \    match longest {\n            None => longest = Some(s),\n            Some(ref\
    \ l) => if s.len() > l.len() {\n                longest = Some(s);\n         \
    \   },\n        }\n    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for s in strings {\n    \
    \    match longest {\n            None => longest = Some(s),\n            Some(ref\
    \ mut l) => {\n                if s.len() > l.len() {\n                    *l\
    \ = s;\n                }\n            }\n        }\n    }\n    longest\n}\n\n\
    fn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for s in strings {\n    \
    \    match longest {\n            None => longest = Some(s),\n            Some(ref\
    \ l) => if s.len() > l.len() {\n                longest = Some(s);\n         \
    \   },\n        }\n    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for string in strings {\n\
    \        match longest {\n            None => longest = Some(string),\n      \
    \      Some(ref mut l) => {\n                if l.len() < string.len() {\n   \
    \                 *l = string;\n                }\n            }\n        }\n\
    \    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest_string = None;\n    for string in strings\
    \ {\n        match longest_string {\n            None => longest_string = Some(string),\n\
    \            Some(ref mut longest) => {\n                if string.len() > longest.len()\
    \ {\n                    *longest = string;\n                }\n            }\n\
    \        }\n    }\n    longest_string\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for string in strings {\n\
    \        match longest {\n            None => longest = Some(string),\n      \
    \      Some(ref mut longest_string) => {\n                if string.len() > longest_string.len()\
    \ {\n                    *longest_string = string;\n                }\n      \
    \      }\n        }\n    }\n    longest\n}\n\nfn main() {\n    let candidate =\
    \ longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for s in strings {\n    \
    \    match longest {\n            None => longest = Some(s),\n            Some(ref\
    \ l) => {\n                if s.len() > l.len() {\n                    longest\
    \ = Some(s);\n                }\n            }\n        }\n    }\n    longest\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for s in strings {\n    \
    \    match longest {\n            None => longest = Some(s),\n            Some(ref\
    \ mut l) => {\n                if s.len() > l.len() {\n                    *l\
    \ = s;\n                }\n            }\n        }\n    }\n    longest\n}\n\n\
    fn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    if strings.is_empty() {\n        return None;\n    }\n\
    \    let mut longest = &strings[0];\n    for string in &strings {\n        if\
    \ string.len() > longest.len() {\n            longest = string;\n        }\n \
    \   }\n    Some(longest.clone())\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for s in strings {\n    \
    \    match longest {\n            None => longest = Some(s),\n            Some(ref\
    \ l) => if s.len() > l.len() {\n                longest = Some(s);\n         \
    \   },\n        }\n    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    if strings.is_empty() {\n        return None;\n    }\n\
    \    let mut longest = &strings[0];\n    for string in &strings {\n        if\
    \ string.len() > longest.len() {\n            longest = string;\n        }\n \
    \   }\n    Some(longest.clone())\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    if strings.is_empty() {\n        return None;\n    }\n\
    \    let mut longest = &strings[0];\n    for string in &strings {\n        if\
    \ string.len() > longest.len() {\n            longest = string;\n        }\n \
    \   }\n    Some(longest.clone())\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut max_len = 0;\n    let mut max_string = None;\n\
    \    for s in strings {\n        if s.len() > max_len {\n            max_len =\
    \ s.len();\n            max_string = Some(s);\n        }\n    }\n    max_string\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for s in strings {\n    \
    \    match longest {\n            None => longest = Some(s),\n            Some(ref\
    \ mut l) => {\n                if s.len() > l.len() {\n                    *l\
    \ = s;\n                }\n            }\n        }\n    }\n    longest\n}\n\n\
    fn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for string in strings {\n\
    \        match longest {\n            None => longest = Some(string),\n      \
    \      Some(ref mut l) => {\n                if l.len() < string.len() {\n   \
    \                 *l = string;\n                }\n            }\n        }\n\
    \    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 1
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for s in strings {\n    \
    \    if longest.is_none() || s.len() > longest.as_ref().unwrap().len() {\n   \
    \         longest = Some(s);\n        }\n    }\n    longest\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `Option<T>`\n  --> /tmp/tmpyq7uh8bw.rs:12:51\n\
    \   |\n10 |     let mut longest = None;\n   |         ----------- consider giving\
    \ `longest` the explicit type `Option<T>`, where the type parameter `T` is specified\n\
    11 |     for s in strings {\n12 |         if longest.is_none() || s.len() > longest.as_ref().unwrap().len()\
    \ {\n   |                                                   ^^^^^^ cannot infer\
    \ type for type parameter `T`\n   |\n   = note: type must be known at this point\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for string in strings {\n\
    \        match longest {\n            None => longest = Some(string),\n      \
    \      Some(ref mut l) => {\n                if l.len() < string.len() {\n   \
    \                 *l = string;\n                }\n            }\n        }\n\
    \    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for s in strings {\n    \
    \    match longest {\n            None => longest = Some(s),\n            Some(ref\
    \ mut l) => {\n                if s.len() > l.len() {\n                    *l\
    \ = s;\n                }\n            }\n        }\n    }\n    longest\n}\n\n\
    fn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest_string = None;\n    for string in strings\
    \ {\n        match longest_string {\n            None => longest_string = Some(string),\n\
    \            Some(ref mut longest) => {\n                if string.len() > longest.len()\
    \ {\n                    *longest = string;\n                }\n            }\n\
    \        }\n    }\n    longest_string\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    if strings.is_empty() {\n        return None;\n    }\n\
    \    let mut longest = strings[0].clone();\n    for s in strings {\n        if\
    \ s.len() > longest.len() {\n            longest = s;\n        }\n    }\n    Some(longest)\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for string in strings {\n\
    \        match longest {\n            None => longest = Some(string),\n      \
    \      Some(ref mut l) => {\n                if l.len() < string.len() {\n   \
    \                 *l = string;\n                }\n            }\n        }\n\
    \    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for s in strings {\n    \
    \    match longest {\n            None => longest = Some(s),\n            Some(ref\
    \ l) => if s.len() > l.len() {\n                longest = Some(s);\n         \
    \   },\n        }\n    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for s in strings {\n    \
    \    match longest {\n            None => longest = Some(s),\n            Some(ref\
    \ mut l) => {\n                if s.len() > l.len() {\n                    *l\
    \ = s;\n                }\n            }\n        }\n    }\n    longest\n}\n\n\
    fn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 1
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    strings.into_iter().max_by_key(|s| s.len()).cloned()\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `Option<String>` is not an iterator\n   --> /tmp/tmpqbfc7us7.rs:10:49\n\
    \    |\n10  |       strings.into_iter().max_by_key(|s| s.len()).cloned()\n   \
    \ |                                                   ^^^^^^ `Option<String>`\
    \ is not an iterator\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `Option<String>: Iterator`\n            which is required by `&mut\
    \ Option<String>: Iterator`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest_string = None;\n    for string in strings\
    \ {\n        match longest_string {\n            None => longest_string = Some(string),\n\
    \            Some(ref mut longest) => {\n                if string.len() > longest.len()\
    \ {\n                    *longest = string;\n                }\n            }\n\
    \        }\n    }\n    longest_string\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut max_len = 0;\n    let mut max_string = None;\n\
    \    for s in strings {\n        if s.len() > max_len {\n            max_len =\
    \ s.len();\n            max_string = Some(s);\n        }\n    }\n    max_string\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for s in strings {\n    \
    \    match longest {\n            None => longest = Some(s),\n            Some(ref\
    \ mut l) => {\n                if s.len() > l.len() {\n                    *l\
    \ = s;\n                }\n            }\n        }\n    }\n    longest\n}\n\n\
    fn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for s in strings {\n    \
    \    match longest {\n            None => longest = Some(s),\n            Some(ref\
    \ mut l) => {\n                if s.len() > l.len() {\n                    *l\
    \ = s;\n                }\n            }\n        }\n    }\n    longest\n}\n\n\
    fn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for s in strings {\n    \
    \    longest = match longest {\n            None => Some(s),\n            Some(ref\
    \ l) => {\n                if s.len() > l.len() {\n                    Some(s)\n\
    \                } else {\n                    Some(l.clone())\n             \
    \   }\n            }\n        }\n    }\n    longest\n}\n\nfn main() {\n    let\
    \ candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"), String::from(\"\
    z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for string in strings {\n\
    \        match longest {\n            None => longest = Some(string),\n      \
    \      Some(ref mut l) => {\n                if l.len() < string.len() {\n   \
    \                 *l = string;\n                }\n            }\n        }\n\
    \    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for s in strings {\n    \
    \    match longest {\n            None => longest = Some(s),\n            Some(ref\
    \ mut l) => {\n                if s.len() > l.len() {\n                    *l\
    \ = s;\n                }\n            }\n        }\n    }\n    longest\n}\n\n\
    fn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for s in strings {\n    \
    \    match longest {\n            None => longest = Some(s),\n            Some(ref\
    \ l) => {\n                if s.len() > l.len() {\n                    longest\
    \ = Some(s);\n                }\n            }\n        }\n    }\n    longest\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for s in strings {\n    \
    \    match longest {\n            None => longest = Some(s),\n            Some(ref\
    \ mut l) => {\n                if s.len() > l.len() {\n                    *l\
    \ = s;\n                }\n            }\n        }\n    }\n    longest\n}\n\n\
    fn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for s in strings {\n    \
    \    match longest {\n            None => longest = Some(s),\n            Some(ref\
    \ l) => {\n                if s.len() > l.len() {\n                    longest\
    \ = Some(s);\n                }\n            }\n        }\n    }\n    longest\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for s in strings {\n    \
    \    match longest {\n            None => longest = Some(s),\n            Some(ref\
    \ mut l) => {\n                if s.len() > l.len() {\n                    *l\
    \ = s;\n                }\n            }\n        }\n    }\n    longest\n}\n\n\
    fn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    if strings.is_empty() {\n        return None;\n    }\n\
    \    let mut longest = strings[0].clone();\n    for string in strings {\n    \
    \    if string.len() > longest.len() {\n            longest = string;\n      \
    \  }\n    }\n    Some(longest)\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for s in strings {\n    \
    \    match longest {\n            None => longest = Some(s),\n            Some(ref\
    \ mut l) => {\n                if s.len() > l.len() {\n                    *l\
    \ = s;\n                }\n            }\n        }\n    }\n    longest\n}\n\n\
    fn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for s in strings {\n    \
    \    match longest {\n            None => longest = Some(s),\n            Some(ref\
    \ mut l) => {\n                if s.len() > l.len() {\n                    *l\
    \ = s;\n                }\n            }\n        }\n    }\n    longest\n}\n\n\
    fn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for s in strings {\n    \
    \    match longest {\n            None => longest = Some(s),\n            Some(ref\
    \ mut l) => {\n                if s.len() > l.len() {\n                    *l\
    \ = s;\n                }\n            }\n        }\n    }\n    longest\n}\n\n\
    fn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for s in strings {\n    \
    \    match longest {\n            None => longest = Some(s),\n            Some(ref\
    \ l) => if s.len() > l.len() {\n                longest = Some(s);\n         \
    \   },\n        }\n    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut max_length = 0;\n    let mut max_string = None;\n\
    \    for s in strings {\n        if s.len() > max_length {\n            max_length\
    \ = s.len();\n            max_string = Some(s);\n        }\n    }\n    max_string\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for s in strings {\n    \
    \    match longest {\n            None => longest = Some(s),\n            Some(ref\
    \ l) => {\n                if s.len() > l.len() {\n                    longest\
    \ = Some(s);\n                }\n            }\n        }\n    }\n    longest\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 1
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for s in strings {\n    \
    \    match longest {\n            None => longest = Some(s),\n            Some(l)\
    \ => if s.len() > l.len() {\n                longest = Some(s);\n            },\n\
    \        }\n    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value\n  --> /tmp/tmp6yqrm965.rs:14:18\n   |\n\
    14 |             Some(l) => if s.len() > l.len() {\n   |                  ^ value\
    \ moved here, in previous iteration of loop\n   |\nnote: these 2 reinitializations\
    \ might get skipped\n  --> /tmp/tmp6yqrm965.rs:13:21\n   |\n13 |             None\
    \ => longest = Some(s),\n   |                     ^^^^^^^\n14 |             Some(l)\
    \ => if s.len() > l.len() {\n15 |                 longest = Some(s);\n   |   \
    \              ^^^^^^^\n   = note: move occurs because value has type `String`,\
    \ which does not implement the `Copy` trait\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    if strings.is_empty() {\n        return None;\n    }\n\
    \    let mut longest = &strings[0];\n    for string in &strings {\n        if\
    \ string.len() > longest.len() {\n            longest = string;\n        }\n \
    \   }\n    Some(longest.clone())\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut max_len = 0;\n    let mut max_str = None;\n  \
    \  for s in strings {\n        if s.len() > max_len {\n            max_len = s.len();\n\
    \            max_str = Some(s);\n        }\n    }\n    max_str\n}\n\nfn main()\
    \ {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for s in strings {\n    \
    \    match longest {\n            None => longest = Some(s),\n            Some(ref\
    \ mut l) => {\n                if s.len() > l.len() {\n                    *l\
    \ = s;\n                }\n            }\n        }\n    }\n    longest\n}\n\n\
    fn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut max_len = 0;\n    let mut max_string = None;\n\
    \    for s in strings {\n        if s.len() > max_len {\n            max_len =\
    \ s.len();\n            max_string = Some(s);\n        }\n    }\n    max_string\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for string in strings {\n\
    \        match longest {\n            None => longest = Some(string),\n      \
    \      Some(ref mut l) => {\n                if l.len() < string.len() {\n   \
    \                 *l = string;\n                }\n            }\n        }\n\
    \    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut max_len = 0;\n    let mut max_str = None;\n  \
    \  for s in strings {\n        if s.len() > max_len {\n            max_len = s.len();\n\
    \            max_str = Some(s);\n        }\n    }\n    max_str\n}\n\nfn main()\
    \ {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for string in strings {\n\
    \        match longest {\n            None => longest = Some(string),\n      \
    \      Some(ref mut s) => {\n                if s.len() < string.len() {\n   \
    \                 *s = string;\n                }\n            }\n        }\n\
    \    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for string in strings {\n\
    \        match longest {\n            None => longest = Some(string),\n      \
    \      Some(ref mut l) => {\n                if l.len() < string.len() {\n   \
    \                 *l = string;\n                }\n            }\n        }\n\
    \    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for s in strings {\n    \
    \    match longest {\n            None => longest = Some(s),\n            Some(ref\
    \ mut l) => {\n                if s.len() > l.len() {\n                    *l\
    \ = s;\n                }\n            }\n        }\n    }\n    longest\n}\n\n\
    fn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for string in strings {\n\
    \        match longest {\n            None => longest = Some(string),\n      \
    \      Some(ref mut l) => {\n                if l.len() < string.len() {\n   \
    \                 *l = string;\n                }\n            }\n        }\n\
    \    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for s in strings {\n    \
    \    match longest {\n            None => longest = Some(s),\n            Some(ref\
    \ mut l) => {\n                if s.len() > l.len() {\n                    *l\
    \ = s;\n                }\n            }\n        }\n    }\n    longest\n}\n\n\
    fn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest_string = None;\n    for string in strings\
    \ {\n        match longest_string {\n            None => longest_string = Some(string),\n\
    \            Some(ref mut s) => {\n                if s.len() < string.len() {\n\
    \                    *s = string;\n                }\n            }\n        }\n\
    \    }\n    longest_string\n}\n\nfn main() {\n    let candidate = longest;\n \
    \   assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for string in strings {\n\
    \        match longest {\n            None => longest = Some(string),\n      \
    \      Some(ref mut s) => {\n                if s.len() < string.len() {\n   \
    \                 *s = string;\n                }\n            }\n        }\n\
    \    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut max_len = 0;\n    let mut max_string = None;\n\
    \    for s in strings {\n        if s.len() > max_len {\n            max_len =\
    \ s.len();\n            max_string = Some(s);\n        }\n    }\n    max_string\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for s in strings {\n    \
    \    match longest {\n            None => longest = Some(s),\n            Some(ref\
    \ mut l) => {\n                if s.len() > l.len() {\n                    *l\
    \ = s;\n                }\n            }\n        }\n    }\n    longest\n}\n\n\
    fn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for s in strings {\n    \
    \    match longest {\n            None => longest = Some(s),\n            Some(ref\
    \ mut l) => {\n                if s.len() > l.len() {\n                    *l\
    \ = s;\n                }\n            }\n        }\n    }\n    longest\n}\n\n\
    fn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut max_len = 0;\n    let mut max_string = None;\n\
    \    for s in strings {\n        if s.len() > max_len {\n            max_len =\
    \ s.len();\n            max_string = Some(s);\n        }\n    }\n    max_string\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for s in strings {\n    \
    \    match longest {\n            None => longest = Some(s),\n            Some(ref\
    \ mut l) => {\n                if s.len() > l.len() {\n                    *l\
    \ = s;\n                }\n            }\n        }\n    }\n    longest\n}\n\n\
    fn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 1
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for string in strings {\n\
    \        if let Some(ref current_longest) = longest {\n            if string.len()\
    \ > current_longest.len() {\n                longest = Some(string);\n       \
    \     }\n        } else {\n            longest = Some(string);\n        }\n  \
    \  }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `Option<T>`\n  --> /tmp/tmpabv_e6d7.rs:12:16\n\
    \   |\n10 |     let mut longest = None;\n   |         ----------- consider giving\
    \ `longest` the explicit type `Option<T>`, where the type parameter `T` is specified\n\
    11 |     for string in strings {\n12 |         if let Some(ref current_longest)\
    \ = longest {\n   |                ^^^^^^^^^^^^^^^^^^^^^^^^^ cannot infer type\
    \ for type parameter `T` declared on the enum `Option`\n   |\n   = note: type\
    \ must be known at this point\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    if strings.is_empty() {\n        return None;\n    }\n\
    \    let mut longest = &strings[0];\n    for string in &strings {\n        if\
    \ string.len() > longest.len() {\n            longest = string;\n        }\n \
    \   }\n    Some(longest.clone())\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest_string = None;\n    for string in strings\
    \ {\n        match longest_string {\n            None => longest_string = Some(string),\n\
    \            Some(ref mut longest) => {\n                if string.len() > longest.len()\
    \ {\n                    *longest = string;\n                }\n            }\n\
    \        }\n    }\n    longest_string\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for s in strings {\n    \
    \    match longest {\n            None => longest = Some(s),\n            Some(ref\
    \ mut l) => {\n                if s.len() > l.len() {\n                    *l\
    \ = s;\n                }\n            }\n        }\n    }\n    longest\n}\n\n\
    fn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    if strings.is_empty() {\n        return None;\n    }\n\
    \    let mut longest = &strings[0];\n    for string in &strings {\n        if\
    \ string.len() > longest.len() {\n            longest = string;\n        }\n \
    \   }\n    Some(longest.clone())\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for s in strings {\n    \
    \    match longest {\n            None => longest = Some(s),\n            Some(ref\
    \ l) => if s.len() > l.len() {\n                longest = Some(s);\n         \
    \   },\n        }\n    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for s in strings {\n    \
    \    match longest {\n            None => longest = Some(s),\n            Some(ref\
    \ mut l) => {\n                if s.len() > l.len() {\n                    *l\
    \ = s;\n                }\n            }\n        }\n    }\n    longest\n}\n\n\
    fn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for s in strings {\n    \
    \    match longest {\n            None => longest = Some(s),\n            Some(ref\
    \ mut l) => {\n                if s.len() > l.len() {\n                    *l\
    \ = s;\n                }\n            }\n        }\n    }\n    longest\n}\n\n\
    fn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for s in strings {\n    \
    \    match longest {\n            None => longest = Some(s),\n            Some(ref\
    \ l) => if s.len() > l.len() {\n                longest = Some(s);\n         \
    \   },\n        }\n    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for s in strings {\n    \
    \    match longest {\n            None => longest = Some(s),\n            Some(ref\
    \ mut l) => {\n                if s.len() > l.len() {\n                    *l\
    \ = s;\n                }\n            }\n        }\n    }\n    longest\n}\n\n\
    fn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for s in strings {\n    \
    \    match longest {\n            None => longest = Some(s),\n            Some(ref\
    \ mut l) => {\n                if s.len() > l.len() {\n                    *l\
    \ = s;\n                }\n            }\n        }\n    }\n    longest\n}\n\n\
    fn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for s in strings {\n    \
    \    match longest {\n            None => longest = Some(s),\n            Some(ref\
    \ mut l) => {\n                if s.len() > l.len() {\n                    *l\
    \ = s;\n                }\n            }\n        }\n    }\n    longest\n}\n\n\
    fn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest_string = None;\n    for s in strings {\n\
    \        match longest_string {\n            None => longest_string = Some(s),\n\
    \            Some(ref mut l) => {\n                if s.len() > l.len() {\n  \
    \                  *l = s;\n                }\n            }\n        }\n    }\n\
    \    longest_string\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for string in strings {\n\
    \        longest = match longest {\n            None => Some(string),\n      \
    \      Some(ref mut longest) => {\n                if string.len() > longest.len()\
    \ {\n                    *longest = string;\n                }\n             \
    \   Some(longest.clone())\n            }\n        }\n    }\n    longest\n}\n\n\
    fn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for string in strings {\n\
    \        match longest {\n            None => longest = Some(string),\n      \
    \      Some(ref mut l) => {\n                if l.len() < string.len() {\n   \
    \                 *l = string;\n                }\n            }\n        }\n\
    \    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for s in strings {\n    \
    \    match longest {\n            None => longest = Some(s),\n            Some(ref\
    \ mut l) => {\n                if s.len() > l.len() {\n                    *l\
    \ = s;\n                }\n            }\n        }\n    }\n    longest\n}\n\n\
    fn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for string in strings {\n\
    \        match longest {\n            None => longest = Some(string),\n      \
    \      Some(ref mut l) => {\n                if l.len() < string.len() {\n   \
    \                 *l = string;\n                }\n            }\n        }\n\
    \    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    if strings.is_empty() {\n        return None;\n    }\n\
    \    let mut longest = &strings[0];\n    for s in &strings {\n        if s.len()\
    \ > longest.len() {\n            longest = s;\n        }\n    }\n    Some(longest.clone())\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for string in strings {\n\
    \        match longest {\n            None => longest = Some(string),\n      \
    \      Some(ref mut l) => {\n                if l.len() < string.len() {\n   \
    \                 *l = string;\n                }\n            }\n        }\n\
    \    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut max_len = 0;\n    let mut max_string = None;\n\
    \    for s in strings {\n        if s.len() > max_len {\n            max_len =\
    \ s.len();\n            max_string = Some(s);\n        }\n    }\n    max_string\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 1
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    strings.into_iter().max_by_key(|s| s.len()).cloned()\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `Option<String>` is not an iterator\n   --> /tmp/tmpqbfc7us7.rs:10:49\n\
    \    |\n10  |       strings.into_iter().max_by_key(|s| s.len()).cloned()\n   \
    \ |                                                   ^^^^^^ `Option<String>`\
    \ is not an iterator\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `Option<String>: Iterator`\n            which is required by `&mut\
    \ Option<String>: Iterator`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for s in strings {\n    \
    \    match longest {\n            None => longest = Some(s),\n            Some(ref\
    \ mut l) => {\n                if s.len() > l.len() {\n                    *l\
    \ = s;\n                }\n            }\n        }\n    }\n    longest\n}\n\n\
    fn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for string in strings {\n\
    \        match longest {\n            None => longest = Some(string),\n      \
    \      Some(ref mut l) => {\n                if l.len() < string.len() {\n   \
    \                 *l = string;\n                }\n            }\n        }\n\
    \    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for string in strings {\n\
    \        match longest {\n            None => longest = Some(string),\n      \
    \      Some(ref mut current) => {\n                if string.len() > current.len()\
    \ {\n                    *current = string;\n                }\n            }\n\
    \        }\n    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for s in strings {\n    \
    \    match longest {\n            None => longest = Some(s),\n            Some(ref\
    \ mut l) => {\n                if s.len() > l.len() {\n                    *l\
    \ = s;\n                }\n            }\n        }\n    }\n    longest\n}\n\n\
    fn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for s in strings {\n    \
    \    match longest {\n            None => longest = Some(s),\n            Some(ref\
    \ mut l) => {\n                if s.len() > l.len() {\n                    *l\
    \ = s;\n                }\n            }\n        }\n    }\n    longest\n}\n\n\
    fn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut max_length = 0;\n    let mut max_string = None;\n\
    \    for string in strings {\n        if string.len() > max_length {\n       \
    \     max_length = string.len();\n            max_string = Some(string);\n   \
    \     }\n    }\n    max_string\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for s in strings {\n    \
    \    match longest {\n            None => longest = Some(s),\n            Some(ref\
    \ mut l) => {\n                if s.len() > l.len() {\n                    *l\
    \ = s;\n                }\n            }\n        }\n    }\n    longest\n}\n\n\
    fn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for s in strings {\n    \
    \    match longest {\n            None => longest = Some(s),\n            Some(ref\
    \ l) => if s.len() > l.len() {\n                longest = Some(s);\n         \
    \   },\n        }\n    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 1
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    strings.into_iter().max_by_key(|s| s.len()).cloned()\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `Option<String>` is not an iterator\n   --> /tmp/tmpqbfc7us7.rs:10:49\n\
    \    |\n10  |       strings.into_iter().max_by_key(|s| s.len()).cloned()\n   \
    \ |                                                   ^^^^^^ `Option<String>`\
    \ is not an iterator\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `Option<String>: Iterator`\n            which is required by `&mut\
    \ Option<String>: Iterator`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut max_len = 0;\n    let mut max_str = None;\n  \
    \  for s in strings {\n        if s.len() > max_len {\n            max_len = s.len();\n\
    \            max_str = Some(s);\n        }\n    }\n    max_str\n}\n\nfn main()\
    \ {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    if strings.is_empty() {\n        return None;\n    }\n\
    \    let mut longest = &strings[0];\n    for s in &strings {\n        if s.len()\
    \ > longest.len() {\n            longest = s;\n        }\n    }\n    Some(longest.clone())\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    if strings.is_empty() {\n        return None;\n    }\n\
    \    let mut longest = &strings[0];\n    for s in &strings {\n        if s.len()\
    \ > longest.len() {\n            longest = s;\n        }\n    }\n    Some(longest.clone())\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 1
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for string in strings {\n\
    \        if let Some(ref current_longest) = longest {\n            if string.len()\
    \ > current_longest.len() {\n                longest = Some(string);\n       \
    \     }\n        } else {\n            longest = Some(string);\n        }\n  \
    \  }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `Option<T>`\n  --> /tmp/tmpabv_e6d7.rs:12:16\n\
    \   |\n10 |     let mut longest = None;\n   |         ----------- consider giving\
    \ `longest` the explicit type `Option<T>`, where the type parameter `T` is specified\n\
    11 |     for string in strings {\n12 |         if let Some(ref current_longest)\
    \ = longest {\n   |                ^^^^^^^^^^^^^^^^^^^^^^^^^ cannot infer type\
    \ for type parameter `T` declared on the enum `Option`\n   |\n   = note: type\
    \ must be known at this point\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for string in strings {\n\
    \        match longest {\n            None => longest = Some(string),\n      \
    \      Some(ref mut l) => {\n                if l.len() < string.len() {\n   \
    \                 *l = string;\n                }\n            }\n        }\n\
    \    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for s in strings {\n    \
    \    match longest {\n            None => longest = Some(s),\n            Some(ref\
    \ l) => if s.len() > l.len() {\n                longest = Some(s);\n         \
    \   },\n        }\n    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for s in strings {\n    \
    \    match longest {\n            None => longest = Some(s),\n            Some(ref\
    \ mut l) => {\n                if s.len() > l.len() {\n                    *l\
    \ = s;\n                }\n            }\n        }\n    }\n    longest\n}\n\n\
    fn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for string in strings {\n\
    \        match longest {\n            None => longest = Some(string),\n      \
    \      Some(ref mut l) => {\n                if l.len() < string.len() {\n   \
    \                 *l = string;\n                }\n            }\n        }\n\
    \    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest_string = None;\n    for string in strings\
    \ {\n        match longest_string {\n            None => longest_string = Some(string),\n\
    \            Some(ref current_longest) => {\n                if string.len() >\
    \ current_longest.len() {\n                    longest_string = Some(string);\n\
    \                }\n            }\n        }\n    }\n    longest_string\n}\n\n\
    fn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest_string = None;\n    for string in strings\
    \ {\n        match longest_string {\n            None => longest_string = Some(string),\n\
    \            Some(ref mut longest) => {\n                if string.len() > longest.len()\
    \ {\n                    *longest = string;\n                }\n            }\n\
    \        }\n    }\n    longest_string\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    if strings.is_empty() {\n        return None;\n    }\n\
    \    let mut longest = strings[0].clone();\n    for string in strings {\n    \
    \    if string.len() > longest.len() {\n            longest = string;\n      \
    \  }\n    }\n    Some(longest)\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for s in strings {\n    \
    \    match longest {\n            None => longest = Some(s),\n            Some(ref\
    \ mut l) => {\n                if s.len() > l.len() {\n                    *l\
    \ = s;\n                }\n            }\n        }\n    }\n    longest\n}\n\n\
    fn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for string in strings {\n\
    \        match longest {\n            None => longest = Some(string),\n      \
    \      Some(ref mut s) => {\n                if s.len() < string.len() {\n   \
    \                 *s = string;\n                }\n            }\n        }\n\
    \    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for string in strings {\n\
    \        match longest {\n            None => longest = Some(string),\n      \
    \      Some(ref mut s) => {\n                if s.len() < string.len() {\n   \
    \                 *s = string;\n                }\n            }\n        }\n\
    \    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for s in strings {\n    \
    \    match longest {\n            None => longest = Some(s),\n            Some(ref\
    \ l) => if s.len() > l.len() {\n                longest = Some(s);\n         \
    \   },\n        }\n    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for string in strings {\n\
    \        match longest {\n            None => longest = Some(string),\n      \
    \      Some(ref mut s) => {\n                if s.len() < string.len() {\n   \
    \                 *s = string;\n                }\n            }\n        }\n\
    \    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut max_len = 0;\n    let mut longest_string = None;\n\
    \    for string in strings {\n        if string.len() > max_len {\n          \
    \  max_len = string.len();\n            longest_string = Some(string);\n     \
    \   }\n    }\n    longest_string\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for s in strings {\n    \
    \    match longest {\n            None => longest = Some(s),\n            Some(ref\
    \ mut l) => {\n                if s.len() > l.len() {\n                    *l\
    \ = s;\n                }\n            }\n        }\n    }\n    longest\n}\n\n\
    fn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 1
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for s in strings {\n    \
    \    if longest.is_none() || s.len() > longest.as_ref().unwrap().len() {\n   \
    \         longest = Some(s);\n        }\n    }\n    longest\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `Option<T>`\n  --> /tmp/tmpyq7uh8bw.rs:12:51\n\
    \   |\n10 |     let mut longest = None;\n   |         ----------- consider giving\
    \ `longest` the explicit type `Option<T>`, where the type parameter `T` is specified\n\
    11 |     for s in strings {\n12 |         if longest.is_none() || s.len() > longest.as_ref().unwrap().len()\
    \ {\n   |                                                   ^^^^^^ cannot infer\
    \ type for type parameter `T`\n   |\n   = note: type must be known at this point\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for s in strings {\n    \
    \    match longest {\n            None => longest = Some(s),\n            Some(ref\
    \ mut l) => {\n                if s.len() > l.len() {\n                    *l\
    \ = s;\n                }\n            }\n        }\n    }\n    longest\n}\n\n\
    fn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for string in strings {\n\
    \        match longest {\n            None => longest = Some(string),\n      \
    \      Some(ref mut l) => {\n                if l.len() < string.len() {\n   \
    \                 *l = string;\n                }\n            }\n        }\n\
    \    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for s in strings {\n    \
    \    match longest {\n            None => longest = Some(s),\n            Some(ref\
    \ mut l) => {\n                if s.len() > l.len() {\n                    *l\
    \ = s;\n                }\n            }\n        }\n    }\n    longest\n}\n\n\
    fn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut max_len = 0;\n    let mut max_str = None;\n  \
    \  for s in strings {\n        if s.len() > max_len {\n            max_len = s.len();\n\
    \            max_str = Some(s);\n        }\n    }\n    max_str\n}\n\nfn main()\
    \ {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for string in strings {\n\
    \        match longest {\n            None => longest = Some(string),\n      \
    \      Some(ref mut l) => {\n                if l.len() < string.len() {\n   \
    \                 *l = string;\n                }\n            }\n        }\n\
    \    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for s in strings {\n    \
    \    match longest {\n            None => longest = Some(s),\n            Some(ref\
    \ l) => if s.len() > l.len() {\n                longest = Some(s);\n         \
    \   },\n        }\n    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for string in strings {\n\
    \        match longest {\n            None => longest = Some(string),\n      \
    \      Some(ref mut l) => {\n                if l.len() < string.len() {\n   \
    \                 *l = string;\n                }\n            }\n        }\n\
    \    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for s in strings {\n    \
    \    match longest {\n            None => longest = Some(s),\n            Some(ref\
    \ mut l) => {\n                if s.len() > l.len() {\n                    *l\
    \ = s;\n                }\n            }\n        }\n    }\n    longest\n}\n\n\
    fn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for string in strings {\n\
    \        match longest {\n            None => longest = Some(string),\n      \
    \      Some(ref mut l) => {\n                if l.len() < string.len() {\n   \
    \                 *l = string;\n                }\n            }\n        }\n\
    \    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut max_len = 0;\n    let mut max_str = None;\n  \
    \  for s in strings {\n        if s.len() > max_len {\n            max_len = s.len();\n\
    \            max_str = Some(s);\n        }\n    }\n    max_str\n}\n\nfn main()\
    \ {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for s in strings {\n    \
    \    match longest {\n            None => longest = Some(s),\n            Some(ref\
    \ mut l) => {\n                if s.len() > l.len() {\n                    *l\
    \ = s;\n                }\n            }\n        }\n    }\n    longest\n}\n\n\
    fn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for string in strings {\n\
    \        match longest {\n            None => longest = Some(string),\n      \
    \      Some(ref mut l) => {\n                if l.len() < string.len() {\n   \
    \                 *l = string;\n                }\n            }\n        }\n\
    \    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for s in strings {\n    \
    \    match longest {\n            None => longest = Some(s),\n            Some(ref\
    \ l) => if s.len() > l.len() {\n                longest = Some(s);\n         \
    \   },\n        }\n    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for s in strings {\n    \
    \    match longest {\n            None => longest = Some(s),\n            Some(ref\
    \ mut l) => {\n                if s.len() > l.len() {\n                    *l\
    \ = s;\n                }\n            }\n        }\n    }\n    longest\n}\n\n\
    fn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut max_len = 0;\n    let mut max_string = None;\n\
    \    for s in strings {\n        if s.len() > max_len {\n            max_len =\
    \ s.len();\n            max_string = Some(s);\n        }\n    }\n    max_string\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for s in strings {\n    \
    \    match longest {\n            None => longest = Some(s),\n            Some(ref\
    \ mut l) => {\n                if s.len() > l.len() {\n                    *l\
    \ = s;\n                }\n            }\n        }\n    }\n    longest\n}\n\n\
    fn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    strings.into_iter().fold(None, |acc, s| {\n        match\
    \ acc {\n            None => Some(s),\n            Some(acc_s) => {\n        \
    \        if acc_s.len() < s.len() {\n                    Some(s)\n           \
    \     } else {\n                    Some(acc_s)\n                }\n         \
    \   }\n        }\n    })\n}\n\nfn main() {\n    let candidate = longest;\n   \
    \ assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for s in strings {\n    \
    \    match longest {\n            None => longest = Some(s),\n            Some(ref\
    \ l) => if s.len() > l.len() {\n                longest = Some(s);\n         \
    \   },\n        }\n    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest_string = None;\n    for s in strings {\n\
    \        match longest_string {\n            None => longest_string = Some(s),\n\
    \            Some(ref mut l) => {\n                if l.len() < s.len() {\n  \
    \                  *l = s;\n                }\n            }\n        }\n    }\n\
    \    longest_string\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for string in strings {\n\
    \        match longest {\n            None => longest = Some(string),\n      \
    \      Some(ref mut l) => {\n                if l.len() < string.len() {\n   \
    \                 *l = string;\n                }\n            }\n        }\n\
    \    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for s in strings {\n    \
    \    match longest {\n            None => longest = Some(s),\n            Some(ref\
    \ mut l) => {\n                if s.len() > l.len() {\n                    *l\
    \ = s;\n                }\n            }\n        }\n    }\n    longest\n}\n\n\
    fn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    if strings.is_empty() {\n        return None;\n    }\n\
    \    let mut longest = &strings[0];\n    for string in &strings {\n        if\
    \ string.len() > longest.len() {\n            longest = string;\n        }\n \
    \   }\n    Some(longest.clone())\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest_string = None;\n    for string in strings\
    \ {\n        match longest_string {\n            None => longest_string = Some(string),\n\
    \            Some(ref mut s) => {\n                if s.len() < string.len() {\n\
    \                    *s = string;\n                }\n            }\n        }\n\
    \    }\n    longest_string\n}\n\nfn main() {\n    let candidate = longest;\n \
    \   assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for s in strings {\n    \
    \    match longest {\n            None => longest = Some(s),\n            Some(ref\
    \ mut l) => {\n                if s.len() > l.len() {\n                    *l\
    \ = s;\n                }\n            }\n        }\n    }\n    longest\n}\n\n\
    fn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for s in strings {\n    \
    \    longest = match longest {\n            None => Some(s),\n            Some(ref\
    \ mut l) => {\n                if s.len() > l.len() {\n                    *l\
    \ = s;\n                }\n                Some(l.clone())\n            }\n  \
    \      }\n    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    if strings.is_empty() {\n        return None;\n    }\n\
    \    let mut longest = &strings[0];\n    for s in &strings {\n        if s.len()\
    \ > longest.len() {\n            longest = s;\n        }\n    }\n    Some(longest.clone())\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 1
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    strings.into_iter().max_by_key(|s| s.len()).cloned()\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `Option<String>` is not an iterator\n   --> /tmp/tmpqbfc7us7.rs:10:49\n\
    \    |\n10  |       strings.into_iter().max_by_key(|s| s.len()).cloned()\n   \
    \ |                                                   ^^^^^^ `Option<String>`\
    \ is not an iterator\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `Option<String>: Iterator`\n            which is required by `&mut\
    \ Option<String>: Iterator`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for s in strings {\n    \
    \    match longest {\n            None => longest = Some(s),\n            Some(ref\
    \ mut l) => {\n                if s.len() > l.len() {\n                    *l\
    \ = s;\n                }\n            }\n        }\n    }\n    longest\n}\n\n\
    fn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 101
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    // TODO: implement this function\n    None\n}\n\nfn main()\
    \ {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `None`,\n right: `Some(\"x\")`', /tmp/tmpwar6_2_e.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for s in strings {\n    \
    \    match longest {\n            None => longest = Some(s),\n            Some(ref\
    \ l) => if s.len() > l.len() {\n                longest = Some(s);\n         \
    \   },\n        }\n    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for s in strings {\n    \
    \    longest = match longest {\n            None => Some(s),\n            Some(ref\
    \ l) => {\n                if s.len() > l.len() {\n                    Some(s)\n\
    \                } else {\n                    Some(l.clone())\n             \
    \   }\n            }\n        }\n    }\n    longest\n}\n\nfn main() {\n    let\
    \ candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"), String::from(\"\
    z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for string in strings {\n\
    \        match longest {\n            None => longest = Some(string),\n      \
    \      Some(ref mut s) => {\n                if s.len() < string.len() {\n   \
    \                 *s = string;\n                }\n            }\n        }\n\
    \    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    if strings.is_empty() {\n        return None;\n    }\n\
    \    let mut longest = strings[0].clone();\n    for string in strings {\n    \
    \    if string.len() > longest.len() {\n            longest = string;\n      \
    \  }\n    }\n    Some(longest)\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for string in strings {\n\
    \        match longest {\n            None => longest = Some(string),\n      \
    \      Some(ref mut l) => {\n                if l.len() < string.len() {\n   \
    \                 *l = string;\n                }\n            }\n        }\n\
    \    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for string in strings {\n\
    \        match longest {\n            None => longest = Some(string),\n      \
    \      Some(ref mut l) => {\n                if l.len() < string.len() {\n   \
    \                 *l = string;\n                }\n            }\n        }\n\
    \    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut max_len = 0;\n    let mut max_string = None;\n\
    \    for s in strings {\n        if s.len() > max_len {\n            max_len =\
    \ s.len();\n            max_string = Some(s);\n        }\n    }\n    max_string\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for string in strings {\n\
    \        match longest {\n            None => longest = Some(string),\n      \
    \      Some(ref mut s) => {\n                if s.len() < string.len() {\n   \
    \                 *s = string;\n                }\n            }\n        }\n\
    \    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    if strings.is_empty() {\n        return None;\n    }\n\
    \    let mut longest = &strings[0];\n    for s in &strings {\n        if s.len()\
    \ > longest.len() {\n            longest = s;\n        }\n    }\n    Some(longest.clone())\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for s in strings {\n    \
    \    match longest {\n            None => longest = Some(s),\n            Some(ref\
    \ mut l) => {\n                if s.len() > l.len() {\n                    *l\
    \ = s;\n                }\n            }\n        }\n    }\n    longest\n}\n\n\
    fn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut max_len = 0;\n    let mut max_string = None;\n\
    \    for s in strings {\n        if s.len() > max_len {\n            max_len =\
    \ s.len();\n            max_string = Some(s);\n        }\n    }\n    max_string\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for string in strings {\n\
    \        match longest {\n            None => longest = Some(string),\n      \
    \      Some(ref mut l) => {\n                if l.len() < string.len() {\n   \
    \                 *l = string;\n                }\n            }\n        }\n\
    \    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for s in strings {\n    \
    \    match longest {\n            None => longest = Some(s),\n            Some(ref\
    \ mut l) => {\n                if s.len() > l.len() {\n                    *l\
    \ = s;\n                }\n            }\n        }\n    }\n    longest\n}\n\n\
    fn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for string in strings {\n\
    \        longest = match longest {\n            None => Some(string),\n      \
    \      Some(ref mut l) => {\n                if l.len() < string.len() {\n   \
    \                 *l = string;\n                }\n                Some(l.clone())\n\
    \            }\n        }\n    }\n    longest\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    strings.into_iter().fold(None, |acc, s| {\n        match\
    \ acc {\n            None => Some(s),\n            Some(acc_s) => if acc_s.len()\
    \ < s.len() { Some(s) } else { Some(acc_s) },\n        }\n    })\n}\n\nfn main()\
    \ {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for s in strings {\n    \
    \    match longest {\n            None => longest = Some(s),\n            Some(ref\
    \ l) => {\n                if s.len() > l.len() {\n                    longest\
    \ = Some(s);\n                }\n            }\n        }\n    }\n    longest\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for s in strings {\n    \
    \    match longest {\n            None => longest = Some(s),\n            Some(ref\
    \ mut l) => {\n                if s.len() > l.len() {\n                    *l\
    \ = s;\n                }\n            }\n        }\n    }\n    longest\n}\n\n\
    fn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for s in strings {\n    \
    \    match longest {\n            None => longest = Some(s),\n            Some(ref\
    \ mut l) => {\n                if s.len() > l.len() {\n                    *l\
    \ = s;\n                }\n            }\n        }\n    }\n    longest\n}\n\n\
    fn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for string in strings {\n\
    \        match longest {\n            None => longest = Some(string),\n      \
    \      Some(ref mut l) => {\n                if l.len() < string.len() {\n   \
    \                 *l = string;\n                }\n            }\n        }\n\
    \    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 101
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    strings.into_iter().max_by_key(|s| s.len()).map(|s| s.to_string())\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(\"z\")`,\n right: `Some(\"x\")`', /tmp/tmpgl56ne21.rs:16:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for string in strings {\n\
    \        match longest {\n            None => longest = Some(string),\n      \
    \      Some(ref mut l) => {\n                if l.len() < string.len() {\n   \
    \                 *l = string;\n                }\n            }\n        }\n\
    \    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for s in strings {\n    \
    \    match longest {\n            None => longest = Some(s),\n            Some(ref\
    \ mut l) => {\n                if s.len() > l.len() {\n                    *l\
    \ = s;\n                }\n            }\n        }\n    }\n    longest\n}\n\n\
    fn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for s in strings {\n    \
    \    match longest {\n            None => longest = Some(s),\n            Some(ref\
    \ mut l) => {\n                if s.len() > l.len() {\n                    *l\
    \ = s;\n                }\n            }\n        }\n    }\n    longest\n}\n\n\
    fn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for s in strings {\n    \
    \    match longest {\n            None => longest = Some(s),\n            Some(ref\
    \ mut l) => {\n                if s.len() > l.len() {\n                    *l\
    \ = s;\n                }\n            }\n        }\n    }\n    longest\n}\n\n\
    fn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    if strings.is_empty() {\n        return None;\n    }\n\
    \    let mut longest = &strings[0];\n    for string in &strings {\n        if\
    \ string.len() > longest.len() {\n            longest = string;\n        }\n \
    \   }\n    Some(longest.clone())\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for s in strings {\n    \
    \    match longest {\n            None => longest = Some(s),\n            Some(ref\
    \ mut l) => {\n                if s.len() > l.len() {\n                    *l\
    \ = s;\n                }\n            }\n        }\n    }\n    longest\n}\n\n\
    fn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for string in strings {\n\
    \        match longest {\n            None => longest = Some(string),\n      \
    \      Some(ref mut longest_string) => {\n                if string.len() > longest_string.len()\
    \ {\n                    *longest_string = string;\n                }\n      \
    \      }\n        }\n    }\n    longest\n}\n\nfn main() {\n    let candidate =\
    \ longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for s in strings {\n    \
    \    match longest {\n            None => longest = Some(s),\n            Some(ref\
    \ mut l) => {\n                if s.len() > l.len() {\n                    *l\
    \ = s;\n                }\n            }\n        }\n    }\n    longest\n}\n\n\
    fn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 1
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for string in strings {\n\
    \        if longest.is_none() || string.len() > longest.as_ref().unwrap().len()\
    \ {\n            longest = Some(string);\n        }\n    }\n    longest\n}\n\n\
    fn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `Option<T>`\n  --> /tmp/tmp103m5ql1.rs:12:56\n\
    \   |\n10 |     let mut longest = None;\n   |         ----------- consider giving\
    \ `longest` the explicit type `Option<T>`, where the type parameter `T` is specified\n\
    11 |     for string in strings {\n12 |         if longest.is_none() || string.len()\
    \ > longest.as_ref().unwrap().len() {\n   |                                  \
    \                      ^^^^^^ cannot infer type for type parameter `T`\n   |\n\
    \   = note: type must be known at this point\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for s in strings {\n    \
    \    match longest {\n            None => longest = Some(s),\n            Some(ref\
    \ mut l) => {\n                if s.len() > l.len() {\n                    *l\
    \ = s;\n                }\n            }\n        }\n    }\n    longest\n}\n\n\
    fn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for s in strings {\n    \
    \    match longest {\n            None => longest = Some(s),\n            Some(ref\
    \ mut l) => {\n                if s.len() > l.len() {\n                    *l\
    \ = s;\n                }\n            }\n        }\n    }\n    longest\n}\n\n\
    fn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 1
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for string in strings {\n\
    \        if let Some(ref mut l) = longest {\n            if string.len() > l.len()\
    \ {\n                *l = string;\n            }\n        } else {\n         \
    \   longest = Some(string);\n        }\n    }\n    longest\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `Option<T>`\n  --> /tmp/tmp7ujx4vlb.rs:12:16\n\
    \   |\n10 |     let mut longest = None;\n   |         ----------- consider giving\
    \ `longest` the explicit type `Option<T>`, where the type parameter `T` is specified\n\
    11 |     for string in strings {\n12 |         if let Some(ref mut l) = longest\
    \ {\n   |                ^^^^^^^^^^^^^^^ cannot infer type for type parameter\
    \ `T` declared on the enum `Option`\n   |\n   = note: type must be known at this\
    \ point\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut max_len = 0;\n    let mut max_string = None;\n\
    \    for s in strings {\n        if s.len() > max_len {\n            max_len =\
    \ s.len();\n            max_string = Some(s);\n        }\n    }\n    max_string\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for s in strings {\n    \
    \    match longest {\n            None => longest = Some(s),\n            Some(ref\
    \ mut l) => {\n                if s.len() > l.len() {\n                    *l\
    \ = s;\n                }\n            }\n        }\n    }\n    longest\n}\n\n\
    fn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for s in strings {\n    \
    \    longest = match longest {\n            None => Some(s),\n            Some(ref\
    \ l) => if s.len() > l.len() { Some(s) } else { Some(l.clone()) },\n        }\n\
    \    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for s in strings {\n    \
    \    match longest {\n            None => longest = Some(s),\n            Some(ref\
    \ l) => {\n                if s.len() > l.len() {\n                    longest\
    \ = Some(s);\n                }\n            }\n        }\n    }\n    longest\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for string in strings {\n\
    \        match longest {\n            None => longest = Some(string),\n      \
    \      Some(ref mut longest_string) => {\n                if string.len() > longest_string.len()\
    \ {\n                    *longest_string = string;\n                }\n      \
    \      }\n        }\n    }\n    longest\n}\n\nfn main() {\n    let candidate =\
    \ longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut max_len = 0;\n    let mut max_string = None;\n\
    \    for s in strings {\n        if s.len() > max_len {\n            max_len =\
    \ s.len();\n            max_string = Some(s);\n        }\n    }\n    max_string\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut max_len = 0;\n    let mut max_string = None;\n\
    \    for s in strings {\n        if s.len() > max_len {\n            max_len =\
    \ s.len();\n            max_string = Some(s);\n        }\n    }\n    max_string\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for s in strings {\n    \
    \    match longest {\n            None => longest = Some(s),\n            Some(ref\
    \ mut l) => {\n                if s.len() > l.len() {\n                    *l\
    \ = s;\n                }\n            }\n        }\n    }\n    longest\n}\n\n\
    fn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for s in strings {\n    \
    \    match longest {\n            None => longest = Some(s),\n            Some(ref\
    \ mut l) => {\n                if s.len() > l.len() {\n                    *l\
    \ = s;\n                }\n            }\n        }\n    }\n    longest\n}\n\n\
    fn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest_string = None;\n    for string in strings\
    \ {\n        match longest_string {\n            None => longest_string = Some(string),\n\
    \            Some(ref mut longest) => {\n                if string.len() > longest.len()\
    \ {\n                    *longest = string;\n                }\n            }\n\
    \        }\n    }\n    longest_string\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for s in strings {\n    \
    \    match longest {\n            None => longest = Some(s),\n            Some(ref\
    \ mut l) => {\n                if s.len() > l.len() {\n                    *l\
    \ = s;\n                }\n            }\n        }\n    }\n    longest\n}\n\n\
    fn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for s in strings {\n    \
    \    match longest {\n            None => longest = Some(s),\n            Some(ref\
    \ mut l) => {\n                if s.len() > l.len() {\n                    *l\
    \ = s;\n                }\n            }\n        }\n    }\n    longest\n}\n\n\
    fn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest_string = None;\n    for string in strings\
    \ {\n        match longest_string {\n            None => longest_string = Some(string),\n\
    \            Some(ref mut longest) => {\n                if string.len() > longest.len()\
    \ {\n                    *longest = string;\n                }\n            }\n\
    \        }\n    }\n    longest_string\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest_string: Option<String> = None;\n    for\
    \ string in strings {\n        if longest_string.is_none() || string.len() > longest_string.as_ref().unwrap().len()\
    \ {\n            longest_string = Some(string);\n        }\n    }\n    longest_string\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for s in strings {\n    \
    \    match longest {\n            None => longest = Some(s),\n            Some(ref\
    \ mut l) => {\n                if s.len() > l.len() {\n                    *l\
    \ = s;\n                }\n            }\n        }\n    }\n    longest\n}\n\n\
    fn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for string in strings {\n\
    \        match longest {\n            None => longest = Some(string),\n      \
    \      Some(ref mut s) => {\n                if s.len() < string.len() {\n   \
    \                 *s = string;\n                }\n            }\n        }\n\
    \    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut max_len = 0;\n    let mut max_string = None;\n\
    \    for s in strings {\n        if s.len() > max_len {\n            max_len =\
    \ s.len();\n            max_string = Some(s);\n        }\n    }\n    max_string\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    if strings.is_empty() {\n        return None;\n    }\n\
    \    let mut longest = strings[0].clone();\n    for s in strings {\n        if\
    \ s.len() > longest.len() {\n            longest = s;\n        }\n    }\n    Some(longest)\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for s in strings {\n    \
    \    match longest {\n            None => longest = Some(s),\n            Some(ref\
    \ mut l) => {\n                if s.len() > l.len() {\n                    *l\
    \ = s;\n                }\n            }\n        }\n    }\n    longest\n}\n\n\
    fn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for s in strings {\n    \
    \    match longest {\n            None => longest = Some(s),\n            Some(ref\
    \ mut l) => {\n                if s.len() > l.len() {\n                    *l\
    \ = s;\n                }\n            }\n        }\n    }\n    longest\n}\n\n\
    fn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for s in strings {\n    \
    \    match longest {\n            None => longest = Some(s),\n            Some(ref\
    \ mut l) => {\n                if s.len() > l.len() {\n                    *l\
    \ = s;\n                }\n            }\n        }\n    }\n    longest\n}\n\n\
    fn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for s in strings {\n    \
    \    match longest {\n            None => longest = Some(s),\n            Some(ref\
    \ mut l) => {\n                if s.len() > l.len() {\n                    *l\
    \ = s;\n                }\n            }\n        }\n    }\n    longest\n}\n\n\
    fn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for s in strings {\n    \
    \    match longest {\n            None => longest = Some(s),\n            Some(ref\
    \ mut l) => {\n                if s.len() > l.len() {\n                    *l\
    \ = s;\n                }\n            }\n        }\n    }\n    longest\n}\n\n\
    fn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for s in strings {\n    \
    \    match longest {\n            None => longest = Some(s),\n            Some(ref\
    \ mut l) => {\n                if s.len() > l.len() {\n                    *l\
    \ = s;\n                }\n            }\n        }\n    }\n    longest\n}\n\n\
    fn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    if strings.is_empty() {\n        return None;\n    }\n\
    \    let mut longest = &strings[0];\n    for string in &strings {\n        if\
    \ string.len() > longest.len() {\n            longest = string;\n        }\n \
    \   }\n    Some(longest.clone())\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
- exit_code: 0
  program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"\
    ))\n/// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
    ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) ->\
    \ Option<String> {\n    let mut longest = None;\n    for string in strings {\n\
    \        match longest {\n            None => longest = Some(string),\n      \
    \      Some(ref mut l) => {\n                if l.len() < string.len() {\n   \
    \                 *l = string;\n                }\n            }\n        }\n\
    \    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011823
