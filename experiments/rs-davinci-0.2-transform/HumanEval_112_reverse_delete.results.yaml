language: rs
name: HumanEval_112_reverse_delete
results:
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    (result, result == result.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpexretf5q.rs:20:14\n\
    \   |\n14 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n20 |     (result, result == result.chars().rev().collect::<String>())\n\
    \   |      ------  ^^^^^^ value borrowed here after move\n   |      |\n   |  \
    \    value moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let mut reversed = String::new();\n\
    \    for ch in result.chars().rev() {\n        reversed.push(ch);\n    }\n   \
    \ (result, result == reversed)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmp50xukb94.rs:24:14\n\
    \   |\n14 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n24 |     (result, result == reversed)\n   |      ------  ^^^^^^\
    \ value borrowed here after move\n   |      |\n   |      value moved here\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    let mut chars = s.chars().collect::<Vec<char>>();\n\
    \    let c_chars = c.chars().collect::<Vec<char>>();\n    for i in 0..chars.len()\
    \ {\n        if !c_chars.contains(&chars[i]) {\n            result.push(chars[i]);\n\
    \        }\n    }\n    let mut result_chars = result.chars().collect::<Vec<char>>();\n\
    \    result_chars.reverse();\n    let result_str = result_chars.into_iter().collect::<String>();\n\
    \    (result, result_str == result)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmprytkjcbq.rs:15:9\n\
    \   |\n15 |     let mut chars = s.chars().collect::<Vec<char>>();\n   |      \
    \   ----^^^^^\n   |         |\n   |         help: remove this `mut`\n   |\n  \
    \ = note: `#[warn(unused_mut)]` on by default\n\nerror[E0382]: borrow of moved\
    \ value: `result`\n  --> /tmp/tmprytkjcbq.rs:25:28\n   |\n14 |     let mut result\
    \ = String::new();\n   |         ---------- move occurs because `result` has type\
    \ `String`, which does not implement the `Copy` trait\n...\n25 |     (result,\
    \ result_str == result)\n   |      ------                ^^^^^^ value borrowed\
    \ here after move\n   |      |\n   |      value moved here\n\nerror: aborting\
    \ due to previous error; 1 warning emitted\n\nFor more information about this\
    \ error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let mut reversed = String::new();\n\
    \    for ch in result.chars().rev() {\n        reversed.push(ch);\n    }\n   \
    \ (result, result == reversed)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmp50xukb94.rs:24:14\n\
    \   |\n14 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n24 |     (result, result == reversed)\n   |      ------  ^^^^^^\
    \ value borrowed here after move\n   |      |\n   |      value moved here\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut s: Vec<char> = s.chars().collect();\n    let c: HashSet<char> = c.chars().collect();\n\
    \    s.retain(|&x| !c.contains(&x));\n    let res = s.iter().rev().eq(s.iter());\n\
    \    (s.iter().collect(), res)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmppotewxpu.rs:15:12\n\
    \   |\n15 |     let c: HashSet<char> = c.chars().collect();\n   |            ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0412`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 101
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    let mut is_palindrome = true;\n    for\
    \ ch in s.chars() {\n        if !c.contains(ch) {\n            result.push(ch);\n\
    \        }\n    }\n    let mut i = 0;\n    let mut j = result.len() - 1;\n   \
    \ while i < j {\n        if result.chars().nth(i) != result.chars().nth(j) {\n\
    \            is_palindrome = false;\n            break;\n        }\n        i\
    \ += 1;\n        j -= 1;\n    }\n    (result, is_palindrome)\n}\n\nfn main() {\n\
    \    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpziuprwlm.rs:22:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010151
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut s = s;\n    for ch in c.chars() {\n        s = s.replace(ch, \"\"\
    );\n    }\n    (s, s == s.chars().rev().collect::<String>())\n}\n\nfn main() {\n\
    \    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpvrvscyx8.rs:18:9\n\
    \   |\n14 |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n18 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut s: Vec<char> = s.chars().collect();\n    let c: HashSet<char> = c.chars().collect();\n\
    \    s.retain(|&x| !c.contains(&x));\n    let s: String = s.into_iter().collect();\n\
    \    (s, s == s.chars().rev().collect::<String>())\n}\n\nfn main() {\n    let\
    \ candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"\
    ), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpvui9isht.rs:15:12\n\
    \   |\n15 |     let c: HashSet<char> = c.chars().collect();\n   |            ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0412`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result.chars().eq(result.chars().rev());\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010152
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result.chars().eq(result.chars().rev());\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010152
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result.chars().eq(result.chars().rev());\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010152
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result.chars().eq(result.chars().rev());\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010152
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut res = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            res.push(ch);\n        }\n    }\n    let mut res_rev = String::new();\n\
    \    for ch in res.chars().rev() {\n        res_rev.push(ch);\n    }\n    (res,\
    \ res == res_rev)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n   \
    \ assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `res`\n  --> /tmp/tmp3_wbvous.rs:24:11\n\
    \   |\n14 |     let mut res = String::new();\n   |         ------- move occurs\
    \ because `res` has type `String`, which does not implement the `Copy` trait\n\
    ...\n24 |     (res, res == res_rev)\n   |      ---  ^^^ value borrowed here after\
    \ move\n   |      |\n   |      value moved here\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result.chars().eq(result.chars().rev());\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010152
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut s: Vec<char> = s.chars().collect();\n    let mut c: Vec<char> = c.chars().collect();\n\
    \    s.retain(|x| !c.contains(x));\n    let s: String = s.into_iter().collect();\n\
    \    (s, s == s.chars().rev().collect::<String>())\n}\n\nfn main() {\n    let\
    \ candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"\
    ), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpnuiu56st.rs:15:9\n\
    \   |\n15 |     let mut c: Vec<char> = c.chars().collect();\n   |         ----^\n\
    \   |         |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpnuiu56st.rs:18:9\n\
    \   |\n17 |     let s: String = s.into_iter().collect();\n   |         - move\
    \ occurs because `s` has type `String`, which does not implement the `Copy` trait\n\
    18 |     (s, s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed\
    \ here after move\n   |      |\n   |      value moved here\n\nerror: aborting\
    \ due to previous error; 1 warning emitted\n\nFor more information about this\
    \ error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = s;\n    for ch in c.chars() {\n        result = result.replace(ch,\
    \ \"\");\n    }\n    let is_palindrome = result.chars().eq(result.chars().rev());\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010152
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    let mut chars = s.chars().collect::<Vec<char>>();\n\
    \    let mut chars_c = c.chars().collect::<Vec<char>>();\n    let mut i = 0;\n\
    \    while i < chars.len() {\n        if chars_c.contains(&chars[i]) {\n     \
    \       chars.remove(i);\n        } else {\n            i += 1;\n        }\n \
    \   }\n    for i in chars {\n        result.push(i);\n    }\n    (result, result\
    \ == result.chars().rev().collect::<String>())\n}\n\nfn main() {\n    let candidate\
    \ = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"\
    ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmp_hy0dusv.rs:16:9\n\
    \   |\n16 |     let mut chars_c = c.chars().collect::<Vec<char>>();\n   |    \
    \     ----^^^^^^^\n   |         |\n   |         help: remove this `mut`\n   |\n\
    \   = note: `#[warn(unused_mut)]` on by default\n\nerror[E0382]: borrow of moved\
    \ value: `result`\n  --> /tmp/tmp_hy0dusv.rs:28:14\n   |\n14 |     let mut result\
    \ = String::new();\n   |         ---------- move occurs because `result` has type\
    \ `String`, which does not implement the `Copy` trait\n...\n28 |     (result,\
    \ result == result.chars().rev().collect::<String>())\n   |      ------  ^^^^^^\
    \ value borrowed here after move\n   |      |\n   |      value moved here\n\n\
    error: aborting due to previous error; 1 warning emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut s = s;\n    for c in c.chars() {\n        s = s.replace(c, \"\");\n\
    \    }\n    (s, s == s.chars().rev().collect::<String>())\n}\n\nfn main() {\n\
    \    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpyis0ikmx.rs:18:9\n\
    \   |\n14 |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n18 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut res = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            res.push(ch);\n        }\n    }\n    (res, res == res.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `res`\n  --> /tmp/tmpa446nnix.rs:20:11\n\
    \   |\n14 |     let mut res = String::new();\n   |         ------- move occurs\
    \ because `res` has type `String`, which does not implement the `Copy` trait\n\
    ...\n20 |     (res, res == res.chars().rev().collect::<String>())\n   |      ---\
    \  ^^^ value borrowed here after move\n   |      |\n   |      value moved here\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    let mut chars = s.chars().collect::<Vec<char>>();\n\
    \    let mut chars_c = c.chars().collect::<Vec<char>>();\n    chars.retain(|&x|\
    \ !chars_c.contains(&x));\n    for i in chars {\n        result.push(i);\n   \
    \ }\n    (result, result == result.chars().rev().collect::<String>())\n}\n\nfn\
    \ main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpi2bcvocn.rs:16:9\n\
    \   |\n16 |     let mut chars_c = c.chars().collect::<Vec<char>>();\n   |    \
    \     ----^^^^^^^\n   |         |\n   |         help: remove this `mut`\n   |\n\
    \   = note: `#[warn(unused_mut)]` on by default\n\nerror[E0382]: borrow of moved\
    \ value: `result`\n  --> /tmp/tmpi2bcvocn.rs:21:14\n   |\n14 |     let mut result\
    \ = String::new();\n   |         ---------- move occurs because `result` has type\
    \ `String`, which does not implement the `Copy` trait\n...\n21 |     (result,\
    \ result == result.chars().rev().collect::<String>())\n   |      ------  ^^^^^^\
    \ value borrowed here after move\n   |      |\n   |      value moved here\n\n\
    error: aborting due to previous error; 1 warning emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    let mut is_palindrome = true;\n    let\
    \ mut c_chars = c.chars().collect::<Vec<char>>();\n    c_chars.sort();\n    for\
    \ c in s.chars() {\n        if !c_chars.binary_search(&c).is_ok() {\n        \
    \    result.push(c);\n        }\n    }\n    let mut result_chars = result.chars().collect::<Vec<char>>();\n\
    \    result_chars.reverse();\n    for (i, c) in result_chars.iter().enumerate()\
    \ {\n        if c != &result.chars().nth(i).unwrap() {\n            is_palindrome\
    \ = false;\n            break;\n        }\n    }\n    (result, is_palindrome)\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010152
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    (result, result == result.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpexretf5q.rs:20:14\n\
    \   |\n14 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n20 |     (result, result == result.chars().rev().collect::<String>())\n\
    \   |      ------  ^^^^^^ value borrowed here after move\n   |      |\n   |  \
    \    value moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result.chars().eq(result.chars().rev());\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010152
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    let mut chars = s.chars().collect::<Vec<char>>();\n\
    \    let mut chars_c = c.chars().collect::<Vec<char>>();\n    let mut i = 0;\n\
    \    while i < chars.len() {\n        if chars_c.contains(&chars[i]) {\n     \
    \       chars.remove(i);\n        } else {\n            i += 1;\n        }\n \
    \   }\n    for i in chars {\n        result.push(i);\n    }\n    let mut is_palindrome\
    \ = true;\n    for i in 0..result.len() / 2 {\n        if result.chars().nth(i)\
    \ != result.chars().nth(result.len() - i - 1) {\n            is_palindrome = false;\n\
    \            break;\n        }\n    }\n    (result, is_palindrome)\n}\n\nfn main()\
    \ {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010151
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result.chars().eq(result.chars().rev());\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010152
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut s = s;\n    for c in c.chars() {\n        s = s.replace(c, \"\");\n\
    \    }\n    (s, s == s.chars().rev().collect::<String>())\n}\n\nfn main() {\n\
    \    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpyis0ikmx.rs:18:9\n\
    \   |\n14 |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n18 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    (result, result == result.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpexretf5q.rs:20:14\n\
    \   |\n14 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n20 |     (result, result == result.chars().rev().collect::<String>())\n\
    \   |      ------  ^^^^^^ value borrowed here after move\n   |      |\n   |  \
    \    value moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut s: Vec<char> = s.chars().collect();\n    let c: HashSet<char> = c.chars().collect();\n\
    \    s.retain(|x| !c.contains(x));\n    let s: String = s.into_iter().collect();\n\
    \    (s, s == s.chars().rev().collect::<String>())\n}\n\nfn main() {\n    let\
    \ candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"\
    ), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmp92wtfpqg.rs:15:12\n\
    \   |\n15 |     let c: HashSet<char> = c.chars().collect();\n   |            ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0412`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 101
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let mut is_palindrome\
    \ = true;\n    let mut i = 0;\n    let mut j = result.len() - 1;\n    while i\
    \ < j {\n        if result.chars().nth(i) != result.chars().nth(j) {\n       \
    \     is_palindrome = false;\n            break;\n        }\n        i += 1;\n\
    \        j -= 1;\n    }\n    (result, is_palindrome)\n}\n\nfn main() {\n    let\
    \ candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"\
    ), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmp4w7ovbx8.rs:22:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010151
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut s = s;\n    let mut c = c;\n    let mut i = 0;\n    while i < s.len()\
    \ {\n        if c.contains(s.get(i..i + 1).unwrap()) {\n            s.remove(i);\n\
    \        } else {\n            i += 1;\n        }\n    }\n    (s, is_palindrome(&s))\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmphgx1l1d5.rs:24:9\n   |\n24 |     (s, is_palindrome(&s))\n   |      \
    \   ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    let mut chars = s.chars().collect::<Vec<char>>();\n\
    \    let mut chars_c = c.chars().collect::<Vec<char>>();\n    chars.retain(|x|\
    \ !chars_c.contains(x));\n    for i in chars {\n        result.push(i);\n    }\n\
    \    (result, result == result.chars().rev().collect::<String>())\n}\n\nfn main()\
    \ {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpcw4jh6en.rs:16:9\n\
    \   |\n16 |     let mut chars_c = c.chars().collect::<Vec<char>>();\n   |    \
    \     ----^^^^^^^\n   |         |\n   |         help: remove this `mut`\n   |\n\
    \   = note: `#[warn(unused_mut)]` on by default\n\nerror[E0382]: borrow of moved\
    \ value: `result`\n  --> /tmp/tmpcw4jh6en.rs:21:14\n   |\n14 |     let mut result\
    \ = String::new();\n   |         ---------- move occurs because `result` has type\
    \ `String`, which does not implement the `Copy` trait\n...\n21 |     (result,\
    \ result == result.chars().rev().collect::<String>())\n   |      ------  ^^^^^^\
    \ value borrowed here after move\n   |      |\n   |      value moved here\n\n\
    error: aborting due to previous error; 1 warning emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result.chars().eq(result.chars().rev());\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010152
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result.chars().eq(result.chars().rev());\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010152
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result.chars().eq(result.chars().rev());\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010152
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result.chars().eq(result.chars().rev());\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010152
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    (result, result == result.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpexretf5q.rs:20:14\n\
    \   |\n14 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n20 |     (result, result == result.chars().rev().collect::<String>())\n\
    \   |      ------  ^^^^^^ value borrowed here after move\n   |      |\n   |  \
    \    value moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut s: Vec<char> = s.chars().collect();\n    let c: HashSet<char> = c.chars().collect();\n\
    \    s.retain(|&x| !c.contains(&x));\n    let s: String = s.into_iter().collect();\n\
    \    (s, s == s.chars().rev().collect::<String>())\n}\n\nfn main() {\n    let\
    \ candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"\
    ), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpvui9isht.rs:15:12\n\
    \   |\n15 |     let c: HashSet<char> = c.chars().collect();\n   |            ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0412`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result.chars().eq(result.chars().rev());\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010152
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    let mut chars = s.chars().collect::<Vec<char>>();\n\
    \    let mut chars_c = c.chars().collect::<Vec<char>>();\n    chars.retain(|x|\
    \ !chars_c.contains(x));\n    for i in chars {\n        result.push(i);\n    }\n\
    \    (result, result == result.chars().rev().collect::<String>())\n}\n\nfn main()\
    \ {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpcw4jh6en.rs:16:9\n\
    \   |\n16 |     let mut chars_c = c.chars().collect::<Vec<char>>();\n   |    \
    \     ----^^^^^^^\n   |         |\n   |         help: remove this `mut`\n   |\n\
    \   = note: `#[warn(unused_mut)]` on by default\n\nerror[E0382]: borrow of moved\
    \ value: `result`\n  --> /tmp/tmpcw4jh6en.rs:21:14\n   |\n14 |     let mut result\
    \ = String::new();\n   |         ---------- move occurs because `result` has type\
    \ `String`, which does not implement the `Copy` trait\n...\n21 |     (result,\
    \ result == result.chars().rev().collect::<String>())\n   |      ------  ^^^^^^\
    \ value borrowed here after move\n   |      |\n   |      value moved here\n\n\
    error: aborting due to previous error; 1 warning emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result.chars().eq(result.chars().rev());\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010152
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut s_chars: Vec<char> = s.chars().collect();\n    let c_chars: Vec<char>\
    \ = c.chars().collect();\n    s_chars.retain(|x| !c_chars.contains(x));\n    let\
    \ s_chars_rev: Vec<char> = s_chars.clone();\n    s_chars_rev.reverse();\n    (s_chars.into_iter().collect(),\
    \ s_chars == s_chars_rev)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `s_chars_rev` as mutable, as it is not declared\
    \ as mutable\n  --> /tmp/tmp6xc8q75e.rs:18:5\n   |\n17 |     let s_chars_rev:\
    \ Vec<char> = s_chars.clone();\n   |         ----------- help: consider changing\
    \ this to be mutable: `mut s_chars_rev`\n18 |     s_chars_rev.reverse();\n   |\
    \     ^^^^^^^^^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0382]: borrow of\
    \ moved value: `s_chars`\n   --> /tmp/tmp6xc8q75e.rs:19:37\n    |\n14  |     let\
    \ mut s_chars: Vec<char> = s.chars().collect();\n    |         ----------- move\
    \ occurs because `s_chars` has type `Vec<char>`, which does not implement the\
    \ `Copy` trait\n...\n19  |     (s_chars.into_iter().collect(), s_chars == s_chars_rev)\n\
    \    |              -----------            ^^^^^^^ value borrowed here after move\n\
    \    |              |\n    |              `s_chars` moved due to this method call\n\
    \    |\nnote: this function takes ownership of the receiver `self`, which moves\
    \ `s_chars`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0382, E0596.\nFor more information about an error, try `rustc\
    \ --explain E0382`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    (result, result == result.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpexretf5q.rs:20:14\n\
    \   |\n14 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n20 |     (result, result == result.chars().rev().collect::<String>())\n\
    \   |      ------  ^^^^^^ value borrowed here after move\n   |      |\n   |  \
    \    value moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    (result, result == result.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpexretf5q.rs:20:14\n\
    \   |\n14 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n20 |     (result, result == result.chars().rev().collect::<String>())\n\
    \   |      ------  ^^^^^^ value borrowed here after move\n   |      |\n   |  \
    \    value moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut s: Vec<char> = s.chars().collect();\n    let c: HashSet<char> = c.chars().collect();\n\
    \    s.retain(|&x| !c.contains(&x));\n    let s: String = s.into_iter().collect();\n\
    \    (s, s == s.chars().rev().collect::<String>())\n}\n\nfn main() {\n    let\
    \ candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"\
    ), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpvui9isht.rs:15:12\n\
    \   |\n15 |     let c: HashSet<char> = c.chars().collect();\n   |            ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0412`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    (result, result == result.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpexretf5q.rs:20:14\n\
    \   |\n14 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n20 |     (result, result == result.chars().rev().collect::<String>())\n\
    \   |      ------  ^^^^^^ value borrowed here after move\n   |      |\n   |  \
    \    value moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for i in s.chars() {\n        if !c.contains(i)\
    \ {\n            result.push(i);\n        }\n    }\n    let mut result_rev = String::new();\n\
    \    for i in result.chars().rev() {\n        result_rev.push(i);\n    }\n   \
    \ (result, result == result_rev)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpdbc_wlyb.rs:24:14\n\
    \   |\n14 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n24 |     (result, result == result_rev)\n   |      ------  ^^^^^^\
    \ value borrowed here after move\n   |      |\n   |      value moved here\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut s: Vec<char> = s.chars().collect();\n    let c: HashSet<char> = c.chars().collect();\n\
    \    s.retain(|x| !c.contains(x));\n    let s: String = s.into_iter().collect();\n\
    \    (s, s == s.chars().rev().collect::<String>())\n}\n\nfn main() {\n    let\
    \ candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"\
    ), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmp92wtfpqg.rs:15:12\n\
    \   |\n15 |     let c: HashSet<char> = c.chars().collect();\n   |            ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0412`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    (result, result == result.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpexretf5q.rs:20:14\n\
    \   |\n14 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n20 |     (result, result == result.chars().rev().collect::<String>())\n\
    \   |      ------  ^^^^^^ value borrowed here after move\n   |      |\n   |  \
    \    value moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result.chars().eq(result.chars().rev());\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010152
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    let mut chars = s.chars().collect::<Vec<char>>();\n\
    \    let mut chars_c = c.chars().collect::<Vec<char>>();\n    chars.retain(|&x|\
    \ !chars_c.contains(&x));\n    for i in chars {\n        result.push(i);\n   \
    \ }\n    (result, result == result.chars().rev().collect::<String>())\n}\n\nfn\
    \ main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpi2bcvocn.rs:16:9\n\
    \   |\n16 |     let mut chars_c = c.chars().collect::<Vec<char>>();\n   |    \
    \     ----^^^^^^^\n   |         |\n   |         help: remove this `mut`\n   |\n\
    \   = note: `#[warn(unused_mut)]` on by default\n\nerror[E0382]: borrow of moved\
    \ value: `result`\n  --> /tmp/tmpi2bcvocn.rs:21:14\n   |\n14 |     let mut result\
    \ = String::new();\n   |         ---------- move occurs because `result` has type\
    \ `String`, which does not implement the `Copy` trait\n...\n21 |     (result,\
    \ result == result.chars().rev().collect::<String>())\n   |      ------  ^^^^^^\
    \ value borrowed here after move\n   |      |\n   |      value moved here\n\n\
    error: aborting due to previous error; 1 warning emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result.chars().eq(result.chars().rev());\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010152
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let result_string = result.chars().rev().collect::<String>();\n\
    \    (result, result == result_string)\n}\n\nfn main() {\n    let candidate =\
    \ reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"\
    ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpptcnwtap.rs:21:14\n\
    \   |\n14 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n21 |     (result, result == result_string)\n   |      ------  ^^^^^^\
    \ value borrowed here after move\n   |      |\n   |      value moved here\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut s = s;\n    for c in c.chars() {\n        s = s.replace(c, \"\");\n\
    \    }\n    (s, s == s.chars().rev().collect::<String>())\n}\n\nfn main() {\n\
    \    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpyis0ikmx.rs:18:9\n\
    \   |\n14 |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n18 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result.chars().eq(result.chars().rev());\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010152
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result.chars().eq(result.chars().rev());\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010152
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    (result, result == result.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpexretf5q.rs:20:14\n\
    \   |\n14 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n20 |     (result, result == result.chars().rev().collect::<String>())\n\
    \   |      ------  ^^^^^^ value borrowed here after move\n   |      |\n   |  \
    \    value moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result.chars().eq(result.chars().rev());\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010152
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result.chars().eq(result.chars().rev());\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010152
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result.chars().eq(result.chars().rev());\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010152
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let mut reversed = String::new();\n\
    \    for ch in result.chars().rev() {\n        reversed.push(ch);\n    }\n   \
    \ (result, result == reversed)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmp50xukb94.rs:24:14\n\
    \   |\n14 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n24 |     (result, result == reversed)\n   |      ------  ^^^^^^\
    \ value borrowed here after move\n   |      |\n   |      value moved here\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result.chars().eq(result.chars().rev());\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010152
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result.chars().eq(result.chars().rev());\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010152
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    (result, result == result.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpexretf5q.rs:20:14\n\
    \   |\n14 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n20 |     (result, result == result.chars().rev().collect::<String>())\n\
    \   |      ------  ^^^^^^ value borrowed here after move\n   |      |\n   |  \
    \    value moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    let mut chars = s.chars().collect::<Vec<char>>();\n\
    \    let c_chars = c.chars().collect::<Vec<char>>();\n    let mut i = 0;\n   \
    \ while i < chars.len() {\n        if c_chars.contains(&chars[i]) {\n        \
    \    chars.remove(i);\n        } else {\n            i += 1;\n        }\n    }\n\
    \    for c in chars {\n        result.push(c);\n    }\n    (result, is_palindrome(&result))\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpsyocg5p3.rs:28:14\n   |\n28 |     (result, is_palindrome(&result))\n\
    \   |              ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = s;\n    for ch in c.chars() {\n        result = result.replace(ch,\
    \ \"\");\n    }\n    (result, result == result.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpuu4kwmb5.rs:18:14\n\
    \   |\n14 |     let mut result = s;\n   |         ---------- move occurs because\
    \ `result` has type `String`, which does not implement the `Copy` trait\n...\n\
    18 |     (result, result == result.chars().rev().collect::<String>())\n   |  \
    \    ------  ^^^^^^ value borrowed here after move\n   |      |\n   |      value\
    \ moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result.chars().eq(result.chars().rev());\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010152
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut s: Vec<char> = s.chars().collect();\n    let c: HashSet<char> = c.chars().collect();\n\
    \    s.retain(|&x| !c.contains(&x));\n    let s: String = s.into_iter().collect();\n\
    \    (s, s == s.chars().rev().collect::<String>())\n}\n\nfn main() {\n    let\
    \ candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"\
    ), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpvui9isht.rs:15:12\n\
    \   |\n15 |     let c: HashSet<char> = c.chars().collect();\n   |            ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0412`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result.chars().eq(result.chars().rev());\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010152
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    let mut chars = s.chars().collect::<Vec<char>>();\n\
    \    let c_chars = c.chars().collect::<Vec<char>>();\n    let mut i = 0;\n   \
    \ while i < chars.len() {\n        if c_chars.contains(&chars[i]) {\n        \
    \    chars.remove(i);\n        } else {\n            i += 1;\n        }\n    }\n\
    \    for c in chars {\n        result.push(c);\n    }\n    let mut reversed =\
    \ String::new();\n    for c in result.chars().rev() {\n        reversed.push(c);\n\
    \    }\n    (result, result == reversed)\n}\n\nfn main() {\n    let candidate\
    \ = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"\
    ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpd9_ano69.rs:32:14\n\
    \   |\n14 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n32 |     (result, result == reversed)\n   |      ------  ^^^^^^\
    \ value borrowed here after move\n   |      |\n   |      value moved here\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result.chars().eq(result.chars().rev());\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010152
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result.chars().eq(result.chars().rev());\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010152
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result.chars().eq(result.chars().rev());\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010152
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    (result, result == result.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpexretf5q.rs:20:14\n\
    \   |\n14 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n20 |     (result, result == result.chars().rev().collect::<String>())\n\
    \   |      ------  ^^^^^^ value borrowed here after move\n   |      |\n   |  \
    \    value moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result.chars().eq(result.chars().rev());\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010152
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut s_chars: Vec<char> = s.chars().collect();\n    let mut c_chars: Vec<char>\
    \ = c.chars().collect();\n    s_chars.retain(|x| !c_chars.contains(x));\n    let\
    \ s_chars_len = s_chars.len();\n    let mut s_chars_rev = s_chars.clone();\n \
    \   s_chars_rev.reverse();\n    let mut is_palindrome = true;\n    for i in 0..s_chars_len\
    \ {\n        if s_chars[i] != s_chars_rev[i] {\n            is_palindrome = false;\n\
    \            break;\n        }\n    }\n    (s_chars.into_iter().collect(), is_palindrome)\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010151
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result.chars().eq(result.chars().rev());\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010152
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut res = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            res.push(ch);\n        }\n    }\n    let is_palindrome = res.chars().eq(res.chars().rev());\n\
    \    (res, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010152
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    (result, result == result.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpexretf5q.rs:20:14\n\
    \   |\n14 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n20 |     (result, result == result.chars().rev().collect::<String>())\n\
    \   |      ------  ^^^^^^ value borrowed here after move\n   |      |\n   |  \
    \    value moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut res = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            res.push(ch);\n        }\n    }\n    let mut rev = res.clone();\n\
    \    rev.chars().rev();\n    (res, res == rev)\n}\n\nfn main() {\n    let candidate\
    \ = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"\
    ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpttxa53r2.rs:20:9\n\
    \   |\n20 |     let mut rev = res.clone();\n   |         ----^^^\n   |       \
    \  |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: borrow of moved value: `res`\n  --> /tmp/tmpttxa53r2.rs:22:11\n\
    \   |\n14 |     let mut res = String::new();\n   |         ------- move occurs\
    \ because `res` has type `String`, which does not implement the `Copy` trait\n\
    ...\n22 |     (res, res == rev)\n   |      ---  ^^^ value borrowed here after\
    \ move\n   |      |\n   |      value moved here\n\nerror: aborting due to previous\
    \ error; 1 warning emitted\n\nFor more information about this error, try `rustc\
    \ --explain E0382`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result.chars().eq(result.chars().rev());\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010152
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut s: Vec<char> = s.chars().collect();\n    let c: HashSet<char> = c.chars().collect();\n\
    \    s.retain(|&x| !c.contains(&x));\n    let s: String = s.into_iter().collect();\n\
    \    (s, s == s.chars().rev().collect::<String>())\n}\n\nfn main() {\n    let\
    \ candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"\
    ), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpvui9isht.rs:15:12\n\
    \   |\n15 |     let c: HashSet<char> = c.chars().collect();\n   |            ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0412`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = s;\n    for ch in c.chars() {\n        result = result.replace(ch,\
    \ \"\");\n    }\n    let mut result_chars: Vec<char> = result.chars().collect();\n\
    \    result_chars.reverse();\n    let result_str: String = result_chars.into_iter().collect();\n\
    \    (result, result == result_str)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmp2g1bsh8w.rs:21:14\n\
    \   |\n14 |     let mut result = s;\n   |         ---------- move occurs because\
    \ `result` has type `String`, which does not implement the `Copy` trait\n...\n\
    21 |     (result, result == result_str)\n   |      ------  ^^^^^^ value borrowed\
    \ here after move\n   |      |\n   |      value moved here\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result.chars().eq(result.chars().rev());\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010152
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut s: Vec<char> = s.chars().collect();\n    let mut c: Vec<char> = c.chars().collect();\n\
    \    s.retain(|x| !c.contains(x));\n    let s: String = s.into_iter().collect();\n\
    \    (s, s == s.chars().rev().collect::<String>())\n}\n\nfn main() {\n    let\
    \ candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"\
    ), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpnuiu56st.rs:15:9\n\
    \   |\n15 |     let mut c: Vec<char> = c.chars().collect();\n   |         ----^\n\
    \   |         |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpnuiu56st.rs:18:9\n\
    \   |\n17 |     let s: String = s.into_iter().collect();\n   |         - move\
    \ occurs because `s` has type `String`, which does not implement the `Copy` trait\n\
    18 |     (s, s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed\
    \ here after move\n   |      |\n   |      value moved here\n\nerror: aborting\
    \ due to previous error; 1 warning emitted\n\nFor more information about this\
    \ error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result.chars().eq(result.chars().rev());\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010152
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut s: Vec<char> = s.chars().collect();\n    let c: HashSet<char> = c.chars().collect();\n\
    \    s.retain(|&x| !c.contains(&x));\n    let s: String = s.into_iter().collect();\n\
    \    (s, s == s.chars().rev().collect::<String>())\n}\n\nfn main() {\n    let\
    \ candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"\
    ), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpvui9isht.rs:15:12\n\
    \   |\n15 |     let c: HashSet<char> = c.chars().collect();\n   |            ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0412`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut s: Vec<char> = s.chars().collect();\n    let c: HashSet<char> = c.chars().collect();\n\
    \    s.retain(|&x| !c.contains(&x));\n    let s: String = s.into_iter().collect();\n\
    \    (s, s == s.chars().rev().collect::<String>())\n}\n\nfn main() {\n    let\
    \ candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"\
    ), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpvui9isht.rs:15:12\n\
    \   |\n15 |     let c: HashSet<char> = c.chars().collect();\n   |            ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0412`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut res = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            res.push(ch);\n        }\n    }\n    (res, res == res.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `res`\n  --> /tmp/tmpa446nnix.rs:20:11\n\
    \   |\n14 |     let mut res = String::new();\n   |         ------- move occurs\
    \ because `res` has type `String`, which does not implement the `Copy` trait\n\
    ...\n20 |     (res, res == res.chars().rev().collect::<String>())\n   |      ---\
    \  ^^^ value borrowed here after move\n   |      |\n   |      value moved here\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut s = s;\n    for c in c.chars() {\n        s = s.replace(c, \"\");\n\
    \    }\n    (s, s == s.chars().rev().collect::<String>())\n}\n\nfn main() {\n\
    \    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpyis0ikmx.rs:18:9\n\
    \   |\n14 |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n18 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result.chars().eq(result.chars().rev());\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010152
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    (result, result == result.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpexretf5q.rs:20:14\n\
    \   |\n14 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n20 |     (result, result == result.chars().rev().collect::<String>())\n\
    \   |      ------  ^^^^^^ value borrowed here after move\n   |      |\n   |  \
    \    value moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result\
    \ == result.chars().rev().collect::<String>();\n    (result, is_palindrome)\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010152
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let mut result_rev =\
    \ String::new();\n    for ch in result.chars().rev() {\n        result_rev.push(ch);\n\
    \    }\n    (result, result == result_rev)\n}\n\nfn main() {\n    let candidate\
    \ = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"\
    ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpr36poq3x.rs:24:14\n\
    \   |\n14 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n24 |     (result, result == result_rev)\n   |      ------  ^^^^^^\
    \ value borrowed here after move\n   |      |\n   |      value moved here\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    (result, result == result.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpexretf5q.rs:20:14\n\
    \   |\n14 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n20 |     (result, result == result.chars().rev().collect::<String>())\n\
    \   |      ------  ^^^^^^ value borrowed here after move\n   |      |\n   |  \
    \    value moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result\
    \ == result.chars().rev().collect::<String>();\n    (result, is_palindrome)\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010152
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut res = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            res.push(ch);\n        }\n    }\n    (res, res == res.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `res`\n  --> /tmp/tmpa446nnix.rs:20:11\n\
    \   |\n14 |     let mut res = String::new();\n   |         ------- move occurs\
    \ because `res` has type `String`, which does not implement the `Copy` trait\n\
    ...\n20 |     (res, res == res.chars().rev().collect::<String>())\n   |      ---\
    \  ^^^ value borrowed here after move\n   |      |\n   |      value moved here\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut s = s;\n    for ch in c.chars() {\n        s = s.replace(ch, \"\"\
    );\n    }\n    (s, s == s.chars().rev().collect::<String>())\n}\n\nfn main() {\n\
    \    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpvrvscyx8.rs:18:9\n\
    \   |\n14 |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n18 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    (result, result == result.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpexretf5q.rs:20:14\n\
    \   |\n14 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n20 |     (result, result == result.chars().rev().collect::<String>())\n\
    \   |      ------  ^^^^^^ value borrowed here after move\n   |      |\n   |  \
    \    value moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut s: Vec<char> = s.chars().collect();\n    let c: HashSet<char> = c.chars().collect();\n\
    \    s.retain(|&x| !c.contains(&x));\n    let s = s.iter().collect::<String>();\n\
    \    (s, s == s.chars().rev().collect::<String>())\n}\n\nfn main() {\n    let\
    \ candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"\
    ), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpdxm0zzdg.rs:15:12\n\
    \   |\n15 |     let c: HashSet<char> = c.chars().collect();\n   |            ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0412`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result\
    \ == result.chars().rev().collect::<String>();\n    (result, is_palindrome)\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010152
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    let mut chars = s.chars().collect::<Vec<char>>();\n\
    \    let mut chars_c = c.chars().collect::<Vec<char>>();\n    chars.retain(|x|\
    \ !chars_c.contains(x));\n    for i in chars {\n        result.push(i);\n    }\n\
    \    (result, result == result.chars().rev().collect::<String>())\n}\n\nfn main()\
    \ {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpcw4jh6en.rs:16:9\n\
    \   |\n16 |     let mut chars_c = c.chars().collect::<Vec<char>>();\n   |    \
    \     ----^^^^^^^\n   |         |\n   |         help: remove this `mut`\n   |\n\
    \   = note: `#[warn(unused_mut)]` on by default\n\nerror[E0382]: borrow of moved\
    \ value: `result`\n  --> /tmp/tmpcw4jh6en.rs:21:14\n   |\n14 |     let mut result\
    \ = String::new();\n   |         ---------- move occurs because `result` has type\
    \ `String`, which does not implement the `Copy` trait\n...\n21 |     (result,\
    \ result == result.chars().rev().collect::<String>())\n   |      ------  ^^^^^^\
    \ value borrowed here after move\n   |      |\n   |      value moved here\n\n\
    error: aborting due to previous error; 1 warning emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 101
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let mut is_palindrome\
    \ = true;\n    let mut i = 0;\n    let mut j = result.len() - 1;\n    while i\
    \ < j {\n        if result.chars().nth(i) != result.chars().nth(j) {\n       \
    \     is_palindrome = false;\n            break;\n        }\n        i += 1;\n\
    \        j -= 1;\n    }\n    (result, is_palindrome)\n}\n\nfn main() {\n    let\
    \ candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"\
    ), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmp4w7ovbx8.rs:22:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010151
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result\
    \ == result.chars().rev().collect::<String>();\n    (result, is_palindrome)\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010152
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result\
    \ == result.chars().rev().collect::<String>();\n    (result, is_palindrome)\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010152
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    (result, result == result.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpexretf5q.rs:20:14\n\
    \   |\n14 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n20 |     (result, result == result.chars().rev().collect::<String>())\n\
    \   |      ------  ^^^^^^ value borrowed here after move\n   |      |\n   |  \
    \    value moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut s = s;\n    for ch in c.chars() {\n        s = s.replace(ch, \"\"\
    );\n    }\n    (s, s == s.chars().rev().collect::<String>())\n}\n\nfn main() {\n\
    \    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpvrvscyx8.rs:18:9\n\
    \   |\n14 |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n18 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result.chars().eq(result.chars().rev());\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010152
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    (result, result == result.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpexretf5q.rs:20:14\n\
    \   |\n14 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n20 |     (result, result == result.chars().rev().collect::<String>())\n\
    \   |      ------  ^^^^^^ value borrowed here after move\n   |      |\n   |  \
    \    value moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result.chars().eq(result.chars().rev());\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010152
- exit_code: 101
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    unimplemented!()\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp249ugmjx.rs:14:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010151
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result.chars().eq(result.chars().rev());\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010152
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut s = s;\n    for ch in c.chars() {\n        s = s.replace(ch, \"\"\
    );\n    }\n    (s, s == s.chars().rev().collect::<String>())\n}\n\nfn main() {\n\
    \    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpvrvscyx8.rs:18:9\n\
    \   |\n14 |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n18 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut s: Vec<char> = s.chars().collect();\n    let c: HashSet<char> = c.chars().collect();\n\
    \    s.retain(|x| !c.contains(x));\n    let s: String = s.into_iter().collect();\n\
    \    (s, s == s.chars().rev().collect::<String>())\n}\n\nfn main() {\n    let\
    \ candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"\
    ), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmp92wtfpqg.rs:15:12\n\
    \   |\n15 |     let c: HashSet<char> = c.chars().collect();\n   |            ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0412`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result.chars().eq(result.chars().rev());\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010152
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut s: Vec<char> = s.chars().collect();\n    let c: HashSet<char> = c.chars().collect();\n\
    \    s.retain(|&x| !c.contains(&x));\n    let s: String = s.into_iter().collect();\n\
    \    (s, s == s.chars().rev().collect::<String>())\n}\n\nfn main() {\n    let\
    \ candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"\
    ), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpvui9isht.rs:15:12\n\
    \   |\n15 |     let c: HashSet<char> = c.chars().collect();\n   |            ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0412`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 101
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut chars: Vec<char> = s.chars().collect();\n    let mut chars_c: Vec<char>\
    \ = c.chars().collect();\n    let mut i = 0;\n    while i < chars.len() {\n  \
    \      if chars_c.contains(&chars[i]) {\n            chars.remove(i);\n      \
    \  } else {\n            i += 1;\n        }\n    }\n    let mut j = 0;\n    let\
    \ mut k = chars.len() - 1;\n    while j < k {\n        if chars[j] != chars[k]\
    \ {\n            return (chars.into_iter().collect(), false);\n        }\n   \
    \     j += 1;\n        k -= 1;\n    }\n    (chars.into_iter().collect(), true)\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpvk3edi2l.rs:25:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010151
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let mut result_rev =\
    \ String::new();\n    for ch in result.chars().rev() {\n        result_rev.push(ch);\n\
    \    }\n    (result, result == result_rev)\n}\n\nfn main() {\n    let candidate\
    \ = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"\
    ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpr36poq3x.rs:24:14\n\
    \   |\n14 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n24 |     (result, result == result_rev)\n   |      ------  ^^^^^^\
    \ value borrowed here after move\n   |      |\n   |      value moved here\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    (result, result == result.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpexretf5q.rs:20:14\n\
    \   |\n14 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n20 |     (result, result == result.chars().rev().collect::<String>())\n\
    \   |      ------  ^^^^^^ value borrowed here after move\n   |      |\n   |  \
    \    value moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut s: Vec<char> = s.chars().collect();\n    let c: HashSet<char> = c.chars().collect();\n\
    \    s.retain(|&x| !c.contains(&x));\n    let s: String = s.into_iter().collect();\n\
    \    (s, s == s.chars().rev().collect::<String>())\n}\n\nfn main() {\n    let\
    \ candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"\
    ), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpvui9isht.rs:15:12\n\
    \   |\n15 |     let c: HashSet<char> = c.chars().collect();\n   |            ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0412`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result.chars().eq(result.chars().rev());\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010152
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    (result, result == result.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpexretf5q.rs:20:14\n\
    \   |\n14 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n20 |     (result, result == result.chars().rev().collect::<String>())\n\
    \   |      ------  ^^^^^^ value borrowed here after move\n   |      |\n   |  \
    \    value moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let mut result_rev =\
    \ String::new();\n    for ch in result.chars().rev() {\n        result_rev.push(ch);\n\
    \    }\n    (result, result == result_rev)\n}\n\nfn main() {\n    let candidate\
    \ = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"\
    ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpr36poq3x.rs:24:14\n\
    \   |\n14 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n24 |     (result, result == result_rev)\n   |      ------  ^^^^^^\
    \ value borrowed here after move\n   |      |\n   |      value moved here\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    (result, result == result.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpexretf5q.rs:20:14\n\
    \   |\n14 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n20 |     (result, result == result.chars().rev().collect::<String>())\n\
    \   |      ------  ^^^^^^ value borrowed here after move\n   |      |\n   |  \
    \    value moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut s: Vec<char> = s.chars().collect();\n    let c: HashSet<char> = c.chars().collect();\n\
    \    s.retain(|&x| !c.contains(&x));\n    let is_palindrome = s.iter().eq(s.iter().rev());\n\
    \    (s.into_iter().collect(), is_palindrome)\n}\n\nfn main() {\n    let candidate\
    \ = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"\
    ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmp188g06uj.rs:15:12\n\
    \   |\n15 |     let c: HashSet<char> = c.chars().collect();\n   |            ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0412`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    (result, result == result.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpexretf5q.rs:20:14\n\
    \   |\n14 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n20 |     (result, result == result.chars().rev().collect::<String>())\n\
    \   |      ------  ^^^^^^ value borrowed here after move\n   |      |\n   |  \
    \    value moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = s;\n    for ch in c.chars() {\n        result = result.replace(ch,\
    \ \"\");\n    }\n    (result, result == result.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpuu4kwmb5.rs:18:14\n\
    \   |\n14 |     let mut result = s;\n   |         ---------- move occurs because\
    \ `result` has type `String`, which does not implement the `Copy` trait\n...\n\
    18 |     (result, result == result.chars().rev().collect::<String>())\n   |  \
    \    ------  ^^^^^^ value borrowed here after move\n   |      |\n   |      value\
    \ moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    let mut chars: Vec<char> = s.chars().collect();\n\
    \    let mut chars_c: Vec<char> = c.chars().collect();\n    for i in 0..chars.len()\
    \ {\n        if !chars_c.contains(&chars[i]) {\n            result.push(chars[i]);\n\
    \        }\n    }\n    let mut result_chars: Vec<char> = result.chars().collect();\n\
    \    result_chars.reverse();\n    let mut result_reverse = String::new();\n  \
    \  for i in 0..result_chars.len() {\n        result_reverse.push(result_chars[i]);\n\
    \    }\n    (result, result == result_reverse)\n}\n\nfn main() {\n    let candidate\
    \ = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"\
    ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpb5levpz2.rs:15:9\n\
    \   |\n15 |     let mut chars: Vec<char> = s.chars().collect();\n   |        \
    \ ----^^^^^\n   |         |\n   |         help: remove this `mut`\n   |\n   =\
    \ note: `#[warn(unused_mut)]` on by default\n\nwarning: variable does not need\
    \ to be mutable\n  --> /tmp/tmpb5levpz2.rs:16:9\n   |\n16 |     let mut chars_c:\
    \ Vec<char> = c.chars().collect();\n   |         ----^^^^^^^\n   |         |\n\
    \   |         help: remove this `mut`\n\nerror[E0382]: borrow of moved value:\
    \ `result`\n  --> /tmp/tmpb5levpz2.rs:28:14\n   |\n14 |     let mut result = String::new();\n\
    \   |         ---------- move occurs because `result` has type `String`, which\
    \ does not implement the `Copy` trait\n...\n28 |     (result, result == result_reverse)\n\
    \   |      ------  ^^^^^^ value borrowed here after move\n   |      |\n   |  \
    \    value moved here\n\nerror: aborting due to previous error; 2 warnings emitted\n\
    \nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    let mut chars = s.chars().collect::<Vec<char>>();\n\
    \    let mut chars_to_delete = c.chars().collect::<Vec<char>>();\n    for i in\
    \ 0..chars.len() {\n        if !chars_to_delete.contains(&chars[i]) {\n      \
    \      result.push(chars[i]);\n        }\n    }\n    let mut is_palindrome = true;\n\
    \    for i in 0..result.len() / 2 {\n        if result.chars().nth(i) != result.chars().nth(result.len()\
    \ - i - 1) {\n            is_palindrome = false;\n            break;\n       \
    \ }\n    }\n    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate =\
    \ reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"\
    ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010152
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    (result, result == result.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpexretf5q.rs:20:14\n\
    \   |\n14 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n20 |     (result, result == result.chars().rev().collect::<String>())\n\
    \   |      ------  ^^^^^^ value borrowed here after move\n   |      |\n   |  \
    \    value moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut s_chars: Vec<char> = s.chars().collect();\n    let c_chars: Vec<char>\
    \ = c.chars().collect();\n    s_chars.retain(|&x| !c_chars.contains(&x));\n  \
    \  let s_chars_len = s_chars.len();\n    let mut result = String::new();\n   \
    \ for i in 0..s_chars_len {\n        result.push(s_chars[i]);\n    }\n    let\
    \ mut is_palindrome = true;\n    for i in 0..s_chars_len / 2 {\n        if s_chars[i]\
    \ != s_chars[s_chars_len - i - 1] {\n            is_palindrome = false;\n    \
    \        break;\n        }\n    }\n    (result, is_palindrome)\n}\n\nfn main()\
    \ {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010151
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    (result, result == result.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpexretf5q.rs:20:14\n\
    \   |\n14 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n20 |     (result, result == result.chars().rev().collect::<String>())\n\
    \   |      ------  ^^^^^^ value borrowed here after move\n   |      |\n   |  \
    \    value moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut s = s;\n    for c in c.chars() {\n        s = s.replace(c, \"\");\n\
    \    }\n    (s, s == s.chars().rev().collect::<String>())\n}\n\nfn main() {\n\
    \    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpyis0ikmx.rs:18:9\n\
    \   |\n14 |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n18 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut s: Vec<char> = s.chars().collect();\n    let c: HashSet<char> = c.chars().collect();\n\
    \    s.retain(|x| !c.contains(x));\n    let s: String = s.into_iter().collect();\n\
    \    (s, s == s.chars().rev().collect::<String>())\n}\n\nfn main() {\n    let\
    \ candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"\
    ), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmp92wtfpqg.rs:15:12\n\
    \   |\n15 |     let c: HashSet<char> = c.chars().collect();\n   |            ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0412`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut s = s;\n    for c in c.chars() {\n        s = s.replace(c, \"\");\n\
    \    }\n    (s, s == s.chars().rev().collect::<String>())\n}\n\nfn main() {\n\
    \    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpyis0ikmx.rs:18:9\n\
    \   |\n14 |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n18 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result.chars().eq(result.chars().rev());\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010152
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result.chars().eq(result.chars().rev());\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010152
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result.chars().eq(result.chars().rev());\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010152
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result.chars().eq(result.chars().rev());\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010152
- exit_code: 101
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    let mut chars = s.chars().collect::<Vec<char>>();\n\
    \    let mut chars_c = c.chars().collect::<Vec<char>>();\n    chars.sort();\n\
    \    chars_c.sort();\n    let mut i = 0;\n    let mut j = 0;\n    while i < chars.len()\
    \ && j < chars_c.len() {\n        if chars[i] == chars_c[j] {\n            i +=\
    \ 1;\n        } else if chars[i] < chars_c[j] {\n            result.push(chars[i]);\n\
    \            i += 1;\n        } else {\n            j += 1;\n        }\n    }\n\
    \    while i < chars.len() {\n        result.push(chars[i]);\n        i += 1;\n\
    \    }\n    let mut result_chars = result.chars().collect::<Vec<char>>();\n  \
    \  result_chars.reverse();\n    let mut is_palindrome = true;\n    for i in 0..result_chars.len()\
    \ {\n        if result_chars[i] != result.chars().nth(i).unwrap() {\n        \
    \    is_palindrome = false;\n            break;\n        }\n    }\n    (result,\
    \ is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(\"ccdde\", false)`,\n right: `(\"cdedc\", true)`', /tmp/tmpmdhgnj8l.rs:51:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result.chars().eq(result.chars().rev());\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010152
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut s: Vec<char> = s.chars().collect();\n    let c: HashSet<char> = c.chars().collect();\n\
    \    s.retain(|&x| !c.contains(&x));\n    let s: String = s.into_iter().collect();\n\
    \    (s, s == s.chars().rev().collect::<String>())\n}\n\nfn main() {\n    let\
    \ candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"\
    ), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpvui9isht.rs:15:12\n\
    \   |\n15 |     let c: HashSet<char> = c.chars().collect();\n   |            ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0412`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    (result, result == result.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpexretf5q.rs:20:14\n\
    \   |\n14 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n20 |     (result, result == result.chars().rev().collect::<String>())\n\
    \   |      ------  ^^^^^^ value borrowed here after move\n   |      |\n   |  \
    \    value moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result.chars().eq(result.chars().rev());\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010152
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result.chars().eq(result.chars().rev());\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010152
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    (result, result == result.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpexretf5q.rs:20:14\n\
    \   |\n14 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n20 |     (result, result == result.chars().rev().collect::<String>())\n\
    \   |      ------  ^^^^^^ value borrowed here after move\n   |      |\n   |  \
    \    value moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut res = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            res.push(ch);\n        }\n    }\n    let mut rev = res.clone();\n\
    \    rev.chars().rev();\n    (res, res == rev)\n}\n\nfn main() {\n    let candidate\
    \ = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"\
    ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpttxa53r2.rs:20:9\n\
    \   |\n20 |     let mut rev = res.clone();\n   |         ----^^^\n   |       \
    \  |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: borrow of moved value: `res`\n  --> /tmp/tmpttxa53r2.rs:22:11\n\
    \   |\n14 |     let mut res = String::new();\n   |         ------- move occurs\
    \ because `res` has type `String`, which does not implement the `Copy` trait\n\
    ...\n22 |     (res, res == rev)\n   |      ---  ^^^ value borrowed here after\
    \ move\n   |      |\n   |      value moved here\n\nerror: aborting due to previous\
    \ error; 1 warning emitted\n\nFor more information about this error, try `rustc\
    \ --explain E0382`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    let mut chars = s.chars().collect::<Vec<char>>();\n\
    \    let mut chars_c = c.chars().collect::<Vec<char>>();\n    chars.retain(|&x|\
    \ !chars_c.contains(&x));\n    for i in chars {\n        result.push(i);\n   \
    \ }\n    let mut is_palindrome = true;\n    for i in 0..result.len() / 2 {\n \
    \       if result.chars().nth(i) != result.chars().nth(result.len() - i - 1) {\n\
    \            is_palindrome = false;\n            break;\n        }\n    }\n  \
    \  (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010151
- exit_code: 101
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    let mut chars = s.chars().collect::<Vec<char>>();\n\
    \    let mut c_chars = c.chars().collect::<Vec<char>>();\n    c_chars.sort();\n\
    \    chars.sort();\n    let mut i = 0;\n    let mut j = 0;\n    while i < chars.len()\
    \ && j < c_chars.len() {\n        if chars[i] == c_chars[j] {\n            i +=\
    \ 1;\n        } else if chars[i] < c_chars[j] {\n            result.push(chars[i]);\n\
    \            i += 1;\n        } else {\n            j += 1;\n        }\n    }\n\
    \    while i < chars.len() {\n        result.push(chars[i]);\n        i += 1;\n\
    \    }\n    let mut is_palindrome = true;\n    let mut i = 0;\n    let mut j =\
    \ result.len() - 1;\n    while i < j {\n        if result.chars().nth(i) != result.chars().nth(j)\
    \ {\n            is_palindrome = false;\n            break;\n        }\n     \
    \   i += 1;\n        j -= 1;\n    }\n    (result, is_palindrome)\n}\n\nfn main()\
    \ {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(\"ccdde\", false)`,\n right: `(\"cdedc\", true)`', /tmp/tmp3wchzom9.rs:53:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010152
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let s: Vec<char> = s.chars().collect();\n    let c: Vec<char> = c.chars().collect();\n\
    \    let mut result = String::new();\n    for i in s {\n        if !c.contains(&i)\
    \ {\n            result.push(i);\n        }\n    }\n    let result: Vec<char>\
    \ = result.chars().collect();\n    let mut result_rev = String::new();\n    for\
    \ i in result.iter().rev() {\n        result_rev.push(*i);\n    }\n    (result_rev,\
    \ result_rev == result.iter().collect::<String>())\n}\n\nfn main() {\n    let\
    \ candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"\
    ), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `result_rev`\n  --> /tmp/tmp9a6p0no2.rs:27:18\n\
    \   |\n23 |     let mut result_rev = String::new();\n   |         --------------\
    \ move occurs because `result_rev` has type `String`, which does not implement\
    \ the `Copy` trait\n...\n27 |     (result_rev, result_rev == result.iter().collect::<String>())\n\
    \   |      ----------  ^^^^^^^^^^ value borrowed here after move\n   |      |\n\
    \   |      value moved here\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut s: Vec<char> = s.chars().collect();\n    let c: HashSet<char> = c.chars().collect();\n\
    \    s.retain(|&x| !c.contains(&x));\n    let s: String = s.into_iter().collect();\n\
    \    (s, s == s.chars().rev().collect::<String>())\n}\n\nfn main() {\n    let\
    \ candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"\
    ), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpvui9isht.rs:15:12\n\
    \   |\n15 |     let c: HashSet<char> = c.chars().collect();\n   |            ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0412`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut s = s;\n    for c in c.chars() {\n        s = s.replace(c, \"\");\n\
    \    }\n    (s, s == s.chars().rev().collect::<String>())\n}\n\nfn main() {\n\
    \    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpyis0ikmx.rs:18:9\n\
    \   |\n14 |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n18 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    let mut chars = s.chars().collect::<Vec<char>>();\n\
    \    let mut chars_c = c.chars().collect::<Vec<char>>();\n    chars.retain(|c|\
    \ !chars_c.contains(c));\n    for c in chars {\n        result.push(c);\n    }\n\
    \    (result, result == result.chars().rev().collect::<String>())\n}\n\nfn main()\
    \ {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmp30c87tx1.rs:16:9\n\
    \   |\n16 |     let mut chars_c = c.chars().collect::<Vec<char>>();\n   |    \
    \     ----^^^^^^^\n   |         |\n   |         help: remove this `mut`\n   |\n\
    \   = note: `#[warn(unused_mut)]` on by default\n\nerror[E0382]: borrow of moved\
    \ value: `result`\n  --> /tmp/tmp30c87tx1.rs:21:14\n   |\n14 |     let mut result\
    \ = String::new();\n   |         ---------- move occurs because `result` has type\
    \ `String`, which does not implement the `Copy` trait\n...\n21 |     (result,\
    \ result == result.chars().rev().collect::<String>())\n   |      ------  ^^^^^^\
    \ value borrowed here after move\n   |      |\n   |      value moved here\n\n\
    error: aborting due to previous error; 1 warning emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    let mut chars = s.chars().collect::<Vec<char>>();\n\
    \    let mut chars_c = c.chars().collect::<Vec<char>>();\n    chars.retain(|x|\
    \ !chars_c.contains(x));\n    for i in chars {\n        result.push(i);\n    }\n\
    \    (result, result == result.chars().rev().collect::<String>())\n}\n\nfn main()\
    \ {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpcw4jh6en.rs:16:9\n\
    \   |\n16 |     let mut chars_c = c.chars().collect::<Vec<char>>();\n   |    \
    \     ----^^^^^^^\n   |         |\n   |         help: remove this `mut`\n   |\n\
    \   = note: `#[warn(unused_mut)]` on by default\n\nerror[E0382]: borrow of moved\
    \ value: `result`\n  --> /tmp/tmpcw4jh6en.rs:21:14\n   |\n14 |     let mut result\
    \ = String::new();\n   |         ---------- move occurs because `result` has type\
    \ `String`, which does not implement the `Copy` trait\n...\n21 |     (result,\
    \ result == result.chars().rev().collect::<String>())\n   |      ------  ^^^^^^\
    \ value borrowed here after move\n   |      |\n   |      value moved here\n\n\
    error: aborting due to previous error; 1 warning emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result.chars().eq(result.chars().rev());\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010152
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut s: Vec<char> = s.chars().collect();\n    let c: HashSet<char> = c.chars().collect();\n\
    \    s.retain(|&x| !c.contains(&x));\n    let s: String = s.into_iter().collect();\n\
    \    (s, s == s.chars().rev().collect::<String>())\n}\n\nfn main() {\n    let\
    \ candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"\
    ), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpvui9isht.rs:15:12\n\
    \   |\n15 |     let c: HashSet<char> = c.chars().collect();\n   |            ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0412`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result.chars().eq(result.chars().rev());\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010152
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let mut reversed = String::new();\n\
    \    for ch in result.chars().rev() {\n        reversed.push(ch);\n    }\n   \
    \ (result, result == reversed)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmp50xukb94.rs:24:14\n\
    \   |\n14 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n24 |     (result, result == reversed)\n   |      ------  ^^^^^^\
    \ value borrowed here after move\n   |      |\n   |      value moved here\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut s: Vec<char> = s.chars().collect();\n    let c: HashSet<char> = c.chars().collect();\n\
    \    s.retain(|&x| !c.contains(&x));\n    let s: String = s.into_iter().collect();\n\
    \    (s, s == s.chars().rev().collect::<String>())\n}\n\nfn main() {\n    let\
    \ candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"\
    ), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpvui9isht.rs:15:12\n\
    \   |\n15 |     let c: HashSet<char> = c.chars().collect();\n   |            ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0412`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result: String = s.chars().filter(|&x| !c.contains(x)).collect();\n\
    \    let is_palindrome = result == result.chars().rev().collect::<String>();\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010151
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let mut is_palindrome\
    \ = true;\n    for i in 0..result.len() / 2 {\n        if result.chars().nth(i)\
    \ != result.chars().nth(result.len() - i - 1) {\n            is_palindrome = false;\n\
    \            break;\n        }\n    }\n    (result, is_palindrome)\n}\n\nfn main()\
    \ {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010151
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut s = s;\n    for c in c.chars() {\n        s = s.replace(c, \"\");\n\
    \    }\n    (s, s == s.chars().rev().collect::<String>())\n}\n\nfn main() {\n\
    \    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpyis0ikmx.rs:18:9\n\
    \   |\n14 |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n18 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut s = s;\n    let mut c = c;\n    for i in c.chars() {\n        s =\
    \ s.replace(i, \"\");\n    }\n    let mut s = s.chars().collect::<Vec<char>>();\n\
    \    s.reverse();\n    let s = s.iter().collect::<String>();\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpgwmgk3im.rs:15:9\n\
    \   |\n15 |     let mut c = c;\n   |         ----^\n   |         |\n   |     \
    \    help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]` on by default\n\
    \nerror[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpgwmgk3im.rs:22:9\n \
    \  |\n21 |     let s = s.iter().collect::<String>();\n   |         - move occurs\
    \ because `s` has type `String`, which does not implement the `Copy` trait\n22\
    \ |     (s, s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed\
    \ here after move\n   |      |\n   |      value moved here\n\nerror: aborting\
    \ due to previous error; 1 warning emitted\n\nFor more information about this\
    \ error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    (result, result == result.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpexretf5q.rs:20:14\n\
    \   |\n14 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n20 |     (result, result == result.chars().rev().collect::<String>())\n\
    \   |      ------  ^^^^^^ value borrowed here after move\n   |      |\n   |  \
    \    value moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result.chars().eq(result.chars().rev());\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010152
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    (result, result == result.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpexretf5q.rs:20:14\n\
    \   |\n14 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n20 |     (result, result == result.chars().rev().collect::<String>())\n\
    \   |      ------  ^^^^^^ value borrowed here after move\n   |      |\n   |  \
    \    value moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result.chars().eq(result.chars().rev());\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010152
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result.chars().eq(result.chars().rev());\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010152
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    (result, result == result.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpexretf5q.rs:20:14\n\
    \   |\n14 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n20 |     (result, result == result.chars().rev().collect::<String>())\n\
    \   |      ------  ^^^^^^ value borrowed here after move\n   |      |\n   |  \
    \    value moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    (result, result == result.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpexretf5q.rs:20:14\n\
    \   |\n14 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n20 |     (result, result == result.chars().rev().collect::<String>())\n\
    \   |      ------  ^^^^^^ value borrowed here after move\n   |      |\n   |  \
    \    value moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let mut reversed = String::new();\n\
    \    for ch in result.chars().rev() {\n        reversed.push(ch);\n    }\n   \
    \ (result, result == reversed)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmp50xukb94.rs:24:14\n\
    \   |\n14 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n24 |     (result, result == reversed)\n   |      ------  ^^^^^^\
    \ value borrowed here after move\n   |      |\n   |      value moved here\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    let mut chars = s.chars().collect::<Vec<char>>();\n\
    \    let mut chars_c = c.chars().collect::<Vec<char>>();\n    chars.retain(|x|\
    \ !chars_c.contains(x));\n    for i in chars {\n        result.push(i);\n    }\n\
    \    (result, result == result.chars().rev().collect::<String>())\n}\n\nfn main()\
    \ {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpcw4jh6en.rs:16:9\n\
    \   |\n16 |     let mut chars_c = c.chars().collect::<Vec<char>>();\n   |    \
    \     ----^^^^^^^\n   |         |\n   |         help: remove this `mut`\n   |\n\
    \   = note: `#[warn(unused_mut)]` on by default\n\nerror[E0382]: borrow of moved\
    \ value: `result`\n  --> /tmp/tmpcw4jh6en.rs:21:14\n   |\n14 |     let mut result\
    \ = String::new();\n   |         ---------- move occurs because `result` has type\
    \ `String`, which does not implement the `Copy` trait\n...\n21 |     (result,\
    \ result == result.chars().rev().collect::<String>())\n   |      ------  ^^^^^^\
    \ value borrowed here after move\n   |      |\n   |      value moved here\n\n\
    error: aborting due to previous error; 1 warning emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut s: Vec<char> = s.chars().collect();\n    let c: HashSet<char> = c.chars().collect();\n\
    \    s.retain(|x| !c.contains(x));\n    let s = s.iter().collect::<String>();\n\
    \    (s, s == s.chars().rev().collect::<String>())\n}\n\nfn main() {\n    let\
    \ candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"\
    ), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmp9haxjq21.rs:15:12\n\
    \   |\n15 |     let c: HashSet<char> = c.chars().collect();\n   |            ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0412`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut s: Vec<char> = s.chars().collect();\n    let c: HashSet<char> = c.chars().collect();\n\
    \    s.retain(|&x| !c.contains(&x));\n    let s: String = s.into_iter().collect();\n\
    \    (s, s == s.chars().rev().collect::<String>())\n}\n\nfn main() {\n    let\
    \ candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"\
    ), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpvui9isht.rs:15:12\n\
    \   |\n15 |     let c: HashSet<char> = c.chars().collect();\n   |            ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0412`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut s = s;\n    for ch in c.chars() {\n        s = s.replace(ch, \"\"\
    );\n    }\n    (s, s == s.chars().rev().collect::<String>())\n}\n\nfn main() {\n\
    \    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpvrvscyx8.rs:18:9\n\
    \   |\n14 |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n18 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    let mut chars = s.chars().collect::<Vec<char>>();\n\
    \    let mut chars_c = c.chars().collect::<Vec<char>>();\n    chars.retain(|x|\
    \ !chars_c.contains(x));\n    for i in chars {\n        result.push(i);\n    }\n\
    \    let mut result_chars = result.chars().collect::<Vec<char>>();\n    result_chars.reverse();\n\
    \    let mut result_reverse = String::new();\n    for i in result_chars {\n  \
    \      result_reverse.push(i);\n    }\n    (result, result == result_reverse)\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmp5wibvwlc.rs:16:9\n\
    \   |\n16 |     let mut chars_c = c.chars().collect::<Vec<char>>();\n   |    \
    \     ----^^^^^^^\n   |         |\n   |         help: remove this `mut`\n   |\n\
    \   = note: `#[warn(unused_mut)]` on by default\n\nerror[E0382]: borrow of moved\
    \ value: `result`\n  --> /tmp/tmp5wibvwlc.rs:27:14\n   |\n14 |     let mut result\
    \ = String::new();\n   |         ---------- move occurs because `result` has type\
    \ `String`, which does not implement the `Copy` trait\n...\n27 |     (result,\
    \ result == result_reverse)\n   |      ------  ^^^^^^ value borrowed here after\
    \ move\n   |      |\n   |      value moved here\n\nerror: aborting due to previous\
    \ error; 1 warning emitted\n\nFor more information about this error, try `rustc\
    \ --explain E0382`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    let mut chars = s.chars().collect::<Vec<char>>();\n\
    \    let mut chars_c = c.chars().collect::<Vec<char>>();\n    chars.retain(|x|\
    \ !chars_c.contains(x));\n    result.push_str(&chars.iter().collect::<String>());\n\
    \    (result, result == result.chars().rev().collect::<String>())\n}\n\nfn main()\
    \ {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpe7wu0kea.rs:16:9\n\
    \   |\n16 |     let mut chars_c = c.chars().collect::<Vec<char>>();\n   |    \
    \     ----^^^^^^^\n   |         |\n   |         help: remove this `mut`\n   |\n\
    \   = note: `#[warn(unused_mut)]` on by default\n\nerror[E0382]: borrow of moved\
    \ value: `result`\n  --> /tmp/tmpe7wu0kea.rs:19:14\n   |\n14 |     let mut result\
    \ = String::new();\n   |         ---------- move occurs because `result` has type\
    \ `String`, which does not implement the `Copy` trait\n...\n19 |     (result,\
    \ result == result.chars().rev().collect::<String>())\n   |      ------  ^^^^^^\
    \ value borrowed here after move\n   |      |\n   |      value moved here\n\n\
    error: aborting due to previous error; 1 warning emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut s: Vec<char> = s.chars().collect();\n    let c: HashSet<char> = c.chars().collect();\n\
    \    s.retain(|x| !c.contains(x));\n    let s: String = s.into_iter().collect();\n\
    \    (s, s == s.chars().rev().collect::<String>())\n}\n\nfn main() {\n    let\
    \ candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"\
    ), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmp92wtfpqg.rs:15:12\n\
    \   |\n15 |     let c: HashSet<char> = c.chars().collect();\n   |            ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0412`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 101
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut s = s;\n    for c in c.chars() {\n        s = s.replace(c, \"\");\n\
    \    }\n    let s = s.chars().collect::<Vec<char>>();\n    let mut i = 0;\n  \
    \  let mut j = s.len() - 1;\n    while i < j {\n        if s[i] != s[j] {\n  \
    \          return (s.iter().collect(), false);\n        }\n        i += 1;\n \
    \       j -= 1;\n    }\n    (s.iter().collect(), true)\n}\n\nfn main() {\n   \
    \ let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"\
    ), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpvtfbkx8u.rs:20:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010152
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    let mut chars = s.chars().collect::<Vec<char>>();\n\
    \    let mut chars_c = c.chars().collect::<Vec<char>>();\n    chars.retain(|x|\
    \ !chars_c.contains(x));\n    for i in chars {\n        result.push(i);\n    }\n\
    \    (result, result == result.chars().rev().collect::<String>())\n}\n\nfn main()\
    \ {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpcw4jh6en.rs:16:9\n\
    \   |\n16 |     let mut chars_c = c.chars().collect::<Vec<char>>();\n   |    \
    \     ----^^^^^^^\n   |         |\n   |         help: remove this `mut`\n   |\n\
    \   = note: `#[warn(unused_mut)]` on by default\n\nerror[E0382]: borrow of moved\
    \ value: `result`\n  --> /tmp/tmpcw4jh6en.rs:21:14\n   |\n14 |     let mut result\
    \ = String::new();\n   |         ---------- move occurs because `result` has type\
    \ `String`, which does not implement the `Copy` trait\n...\n21 |     (result,\
    \ result == result.chars().rev().collect::<String>())\n   |      ------  ^^^^^^\
    \ value borrowed here after move\n   |      |\n   |      value moved here\n\n\
    error: aborting due to previous error; 1 warning emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut s = s;\n    let mut c = c;\n    for ch in c.chars() {\n        s\
    \ = s.replace(ch, \"\");\n    }\n    let mut s_rev = s.clone();\n    s_rev.chars().rev().collect::<String>();\n\
    \    (s, s == s_rev)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmp1b71ni7i.rs:15:9\n\
    \   |\n15 |     let mut c = c;\n   |         ----^\n   |         |\n   |     \
    \    help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]` on by default\n\
    \nwarning: variable does not need to be mutable\n  --> /tmp/tmp1b71ni7i.rs:19:9\n\
    \   |\n19 |     let mut s_rev = s.clone();\n   |         ----^^^^^\n   |     \
    \    |\n   |         help: remove this `mut`\n\nerror[E0382]: borrow of moved\
    \ value: `s`\n  --> /tmp/tmp1b71ni7i.rs:21:9\n   |\n14 |     let mut s = s;\n\
    \   |         ----- move occurs because `s` has type `String`, which does not\
    \ implement the `Copy` trait\n...\n21 |     (s, s == s_rev)\n   |      -  ^ value\
    \ borrowed here after move\n   |      |\n   |      value moved here\n\nerror:\
    \ aborting due to previous error; 2 warnings emitted\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut s: Vec<char> = s.chars().collect();\n    let c: HashSet<char> = c.chars().collect();\n\
    \    s.retain(|&x| !c.contains(&x));\n    let s: String = s.into_iter().collect();\n\
    \    (s, s == s.chars().rev().collect::<String>())\n}\n\nfn main() {\n    let\
    \ candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"\
    ), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpvui9isht.rs:15:12\n\
    \   |\n15 |     let c: HashSet<char> = c.chars().collect();\n   |            ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0412`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result.chars().eq(result.chars().rev());\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010152
- exit_code: 101
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    unimplemented!()\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp249ugmjx.rs:14:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010151
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut s: Vec<char> = s.chars().collect();\n    let c: HashSet<char> = c.chars().collect();\n\
    \    s.retain(|x| !c.contains(x));\n    let s: String = s.into_iter().collect();\n\
    \    (s, s == s.chars().rev().collect::<String>())\n}\n\nfn main() {\n    let\
    \ candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"\
    ), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmp92wtfpqg.rs:15:12\n\
    \   |\n15 |     let c: HashSet<char> = c.chars().collect();\n   |            ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0412`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    (result, result == result.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpexretf5q.rs:20:14\n\
    \   |\n14 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n20 |     (result, result == result.chars().rev().collect::<String>())\n\
    \   |      ------  ^^^^^^ value borrowed here after move\n   |      |\n   |  \
    \    value moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut s = s;\n    for ch in c.chars() {\n        s = s.chars().filter(|&x|\
    \ x != ch).collect();\n    }\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmp_kxjnjz_.rs:18:9\n\
    \   |\n14 |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n18 |     (s,\
    \ s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut s: Vec<char> = s.chars().collect();\n    let c: HashSet<char> = c.chars().collect();\n\
    \    s.retain(|&x| !c.contains(&x));\n    let s: String = s.into_iter().collect();\n\
    \    (s, s == s.chars().rev().collect::<String>())\n}\n\nfn main() {\n    let\
    \ candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"\
    ), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpvui9isht.rs:15:12\n\
    \   |\n15 |     let c: HashSet<char> = c.chars().collect();\n   |            ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0412`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    let mut chars = s.chars().collect::<Vec<char>>();\n\
    \    let mut chars_c = c.chars().collect::<Vec<char>>();\n    chars.retain(|x|\
    \ !chars_c.contains(x));\n    for i in chars {\n        result.push(i);\n    }\n\
    \    let mut result_chars = result.chars().collect::<Vec<char>>();\n    result_chars.reverse();\n\
    \    let mut result_reverse = String::new();\n    for i in result_chars {\n  \
    \      result_reverse.push(i);\n    }\n    (result, result == result_reverse)\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmp5wibvwlc.rs:16:9\n\
    \   |\n16 |     let mut chars_c = c.chars().collect::<Vec<char>>();\n   |    \
    \     ----^^^^^^^\n   |         |\n   |         help: remove this `mut`\n   |\n\
    \   = note: `#[warn(unused_mut)]` on by default\n\nerror[E0382]: borrow of moved\
    \ value: `result`\n  --> /tmp/tmp5wibvwlc.rs:27:14\n   |\n14 |     let mut result\
    \ = String::new();\n   |         ---------- move occurs because `result` has type\
    \ `String`, which does not implement the `Copy` trait\n...\n27 |     (result,\
    \ result == result_reverse)\n   |      ------  ^^^^^^ value borrowed here after\
    \ move\n   |      |\n   |      value moved here\n\nerror: aborting due to previous\
    \ error; 1 warning emitted\n\nFor more information about this error, try `rustc\
    \ --explain E0382`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result.chars().eq(result.chars().rev());\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010152
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result.chars().eq(result.chars().rev());\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010152
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let mut result_rev =\
    \ String::new();\n    for ch in result.chars().rev() {\n        result_rev.push(ch);\n\
    \    }\n    (result, result == result_rev)\n}\n\nfn main() {\n    let candidate\
    \ = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"\
    ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpr36poq3x.rs:24:14\n\
    \   |\n14 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n24 |     (result, result == result_rev)\n   |      ------  ^^^^^^\
    \ value borrowed here after move\n   |      |\n   |      value moved here\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result.chars().eq(result.chars().rev());\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010152
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result.chars().eq(result.chars().rev());\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010152
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let mut reversed = String::new();\n\
    \    for ch in result.chars().rev() {\n        reversed.push(ch);\n    }\n   \
    \ (result, result == reversed)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmp50xukb94.rs:24:14\n\
    \   |\n14 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n24 |     (result, result == reversed)\n   |      ------  ^^^^^^\
    \ value borrowed here after move\n   |      |\n   |      value moved here\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    (result, result == result.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpexretf5q.rs:20:14\n\
    \   |\n14 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n20 |     (result, result == result.chars().rev().collect::<String>())\n\
    \   |      ------  ^^^^^^ value borrowed here after move\n   |      |\n   |  \
    \    value moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    let mut chars = s.chars().collect::<Vec<char>>();\n\
    \    let mut chars_c = c.chars().collect::<Vec<char>>();\n    chars.retain(|x|\
    \ !chars_c.contains(x));\n    for i in chars {\n        result.push(i);\n    }\n\
    \    (result, result == result.chars().rev().collect::<String>())\n}\n\nfn main()\
    \ {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpcw4jh6en.rs:16:9\n\
    \   |\n16 |     let mut chars_c = c.chars().collect::<Vec<char>>();\n   |    \
    \     ----^^^^^^^\n   |         |\n   |         help: remove this `mut`\n   |\n\
    \   = note: `#[warn(unused_mut)]` on by default\n\nerror[E0382]: borrow of moved\
    \ value: `result`\n  --> /tmp/tmpcw4jh6en.rs:21:14\n   |\n14 |     let mut result\
    \ = String::new();\n   |         ---------- move occurs because `result` has type\
    \ `String`, which does not implement the `Copy` trait\n...\n21 |     (result,\
    \ result == result.chars().rev().collect::<String>())\n   |      ------  ^^^^^^\
    \ value borrowed here after move\n   |      |\n   |      value moved here\n\n\
    error: aborting due to previous error; 1 warning emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result.chars().eq(result.chars().rev());\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010152
- exit_code: 101
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut s = s;\n    for c in c.chars() {\n        s = s.replace(c, \"\");\n\
    \    }\n    let s = s.chars().collect::<Vec<char>>();\n    let mut i = 0;\n  \
    \  let mut j = s.len() - 1;\n    while i < j {\n        if s[i] != s[j] {\n  \
    \          return (s.iter().collect(), false);\n        }\n        i += 1;\n \
    \       j -= 1;\n    }\n    (s.iter().collect(), true)\n}\n\nfn main() {\n   \
    \ let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"\
    ), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpvtfbkx8u.rs:20:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010152
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    (result, result == result.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpexretf5q.rs:20:14\n\
    \   |\n14 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n20 |     (result, result == result.chars().rev().collect::<String>())\n\
    \   |      ------  ^^^^^^ value borrowed here after move\n   |      |\n   |  \
    \    value moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
    abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
    abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>>\
    \ reverse_delete(String::from(\"abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"\
    cdedc\"), true)\nfn reverse_delete(s: String, c: String) -> (String, bool) {\n\
    \    let mut s = s;\n    for ch in c.chars() {\n        s = s.replace(ch, \"\"\
    );\n    }\n    let is_palindrome = s.chars().eq(s.chars().rev());\n    (s, is_palindrome)\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010152
