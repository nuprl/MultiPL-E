name: HumanEval_6_parse_nested_parens
language: rs
prompt: "/// Input to this function is a string represented multiple groups for nested\
  \ parentheses separated by spaces.\n/// For each of the group, output the deepest\
  \ level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting\
  \ while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((()))\
  \ () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
  \ String) -> Vec<isize> {\n"
tests: "}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!({left},\
  \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
  }\n"
completions: ["    let mut paren_vec: Vec<isize> = Vec::new();\n    let mut paren_stack:\
    \ Vec<isize> = Vec::new();\n    let mut max_depth: isize = 0;\n    let mut curr_depth:\
    \ isize = 0;\n    let mut paren_string = paren_string.chars();\n    while let\
    \ Some(c) = paren_string.next() {\n        match c {\n            '(' => {\n \
    \               paren_stack.push(c);\n                curr_depth += 1;\n     \
    \           if curr_depth > max_depth {\n                    max_depth = curr_depth;\n\
    \                }\n            }\n            ')' => {\n                if paren_stack.pop()\
    \ != Some('(') {\n                    panic!(\"Mismatched parentheses\");\n  \
    \              }\n                curr_depth -= 1;\n            }\n          \
    \  ' ' => {\n                if paren_stack.is_empty() {\n                   \
    \ paren_vec.push(max_depth);\n                    max_depth = 0;\n           \
    \         curr_depth = 0;\n                }\n            }\n            _ =>\
    \ panic!(\"Invalid character\"),\n        }\n    }\n    paren_vec", "    let mut\
    \ max_nesting = 0;\n    let mut current_nesting = 0;\n    let mut result = Vec::new();\n\
    \    for c in paren_string.chars() {\n        match c {\n            '(' => {\n\
    \                current_nesting += 1;\n                if current_nesting > max_nesting\
    \ {\n                    max_nesting = current_nesting;\n                }\n \
    \           }\n            ')' => {\n                current_nesting -= 1;\n \
    \           }\n            ' ' => {\n                result.push(max_nesting);\n\
    \                max_nesting = 0;\n                current_nesting = 0;\n    \
    \        }\n            _ => {}\n        }\n    }\n    result.push(max_nesting);\n\
    \    result", "    let mut max_nesting = 0;\n    let mut current_nesting = 0;\n\
    \    let mut result = Vec::new();\n    for c in paren_string.chars() {\n     \
    \   match c {\n            '(' => {\n                current_nesting += 1;\n \
    \               if current_nesting > max_nesting {\n                    max_nesting\
    \ = current_nesting;\n                }\n            }\n            ')' => {\n\
    \                current_nesting -= 1;\n            }\n            ' ' => {\n\
    \                result.push(max_nesting);\n                max_nesting = 0;\n\
    \                current_nesting = 0;\n            }\n            _ => panic!(\"\
    Unexpected character in input string\"),\n        }\n    }\n    result.push(max_nesting);\n\
    \    result", "    let mut max_nested_level: isize = 0;\n    let mut current_nested_level:\
    \ isize = 0;\n    let mut result: Vec<isize> = Vec::new();\n\n    for c in paren_string.chars()\
    \ {\n        match c {\n            '(' => {\n                current_nested_level\
    \ += 1;\n                if current_nested_level > max_nested_level {\n      \
    \              max_nested_level = current_nested_level;\n                }\n \
    \           }\n            ')' => {\n                current_nested_level -= 1;\n\
    \            }\n            ' ' => {\n                result.push(max_nested_level);\n\
    \                max_nested_level = 0;\n                current_nested_level =\
    \ 0;\n            }\n            _ => {}\n        }\n    }\n    result.push(max_nested_level);\n\
    \    result", "    let mut paren_vec: Vec<isize> = Vec::new();\n    let mut paren_stack:\
    \ Vec<char> = Vec::new();\n    let mut max_nesting: isize = 0;\n    let mut current_nesting:\
    \ isize = 0;\n    for c in paren_string.chars() {\n        if c == '(' {\n   \
    \         paren_stack.push(c);\n            current_nesting += 1;\n          \
    \  if current_nesting > max_nesting {\n                max_nesting = current_nesting;\n\
    \            }\n        } else if c == ')' {\n            paren_stack.pop();\n\
    \            current_nesting -= 1;\n        } else if c == ' ' {\n           \
    \ paren_vec.push(max_nesting);\n            max_nesting = 0;\n            current_nesting\
    \ = 0;\n        }\n    }\n    paren_vec.push(max_nesting);\n    paren_vec", " \
    \   let mut max_depth = 0;\n    let mut depth = 0;\n    let mut result = Vec::new();\n\
    \    for c in paren_string.chars() {\n        match c {\n            '(' => {\n\
    \                depth += 1;\n                if depth > max_depth {\n       \
    \             max_depth = depth;\n                }\n            }\n         \
    \   ')' => {\n                depth -= 1;\n            }\n            ' ' => {\n\
    \                result.push(max_depth);\n                max_depth = 0;\n   \
    \             depth = 0;\n            }\n            _ => {}\n        }\n    }\n\
    \    result.push(max_depth);\n    result", "    let mut result = Vec::new();\n\
    \    for paren_group in paren_string.split_whitespace() {\n        let mut max_nesting\
    \ = 0;\n        let mut current_nesting = 0;\n        for paren in paren_group.chars()\
    \ {\n            if paren == '(' {\n                current_nesting += 1;\n  \
    \          } else if paren == ')' {\n                current_nesting -= 1;\n \
    \           }\n            if current_nesting > max_nesting {\n              \
    \  max_nesting = current_nesting;\n            }\n        }\n        result.push(max_nesting);\n\
    \    }\n    result", "    let mut max_depth = 0;\n    let mut depth = 0;\n   \
    \ let mut depths = Vec::new();\n    for c in paren_string.chars() {\n        match\
    \ c {\n            '(' => {\n                depth += 1;\n                if depth\
    \ > max_depth {\n                    max_depth = depth;\n                }\n \
    \           }\n            ')' => {\n                depth -= 1;\n           \
    \ }\n            ' ' => {\n                depths.push(max_depth);\n         \
    \       max_depth = 0;\n                depth = 0;\n            }\n          \
    \  _ => {}\n        }\n    }\n    depths.push(max_depth);\n    depths", "    let\
    \ mut max_nesting = 0;\n    let mut current_nesting = 0;\n    let mut result =\
    \ Vec::new();\n    for c in paren_string.chars() {\n        match c {\n      \
    \      '(' => {\n                current_nesting += 1;\n                if current_nesting\
    \ > max_nesting {\n                    max_nesting = current_nesting;\n      \
    \          }\n            }\n            ')' => {\n                current_nesting\
    \ -= 1;\n            }\n            ' ' => {\n                result.push(max_nesting);\n\
    \                max_nesting = 0;\n                current_nesting = 0;\n    \
    \        }\n            _ => {}\n        }\n    }\n    result.push(max_nesting);\n\
    \    result", "    let mut max_nesting = 0;\n    let mut current_nesting = 0;\n\
    \    let mut result = Vec::new();\n    for c in paren_string.chars() {\n     \
    \   match c {\n            '(' => {\n                current_nesting += 1;\n \
    \               if current_nesting > max_nesting {\n                    max_nesting\
    \ = current_nesting;\n                }\n            }\n            ')' => {\n\
    \                current_nesting -= 1;\n            }\n            ' ' => {\n\
    \                result.push(max_nesting);\n                max_nesting = 0;\n\
    \                current_nesting = 0;\n            }\n            _ => {}\n  \
    \      }\n    }\n    result.push(max_nesting);\n    result", "    let mut max_depth\
    \ = 0;\n    let mut depth = 0;\n    let mut depths = Vec::new();\n    for c in\
    \ paren_string.chars() {\n        match c {\n            '(' => {\n          \
    \      depth += 1;\n                if depth > max_depth {\n                 \
    \   max_depth = depth;\n                }\n            }\n            ')' => {\n\
    \                depth -= 1;\n            }\n            ' ' => {\n          \
    \      depths.push(max_depth);\n                max_depth = 0;\n             \
    \   depth = 0;\n            }\n            _ => {}\n        }\n    }\n    depths.push(max_depth);\n\
    \    depths", "    let mut max_depth = 0;\n    let mut depth = 0;\n    let mut\
    \ result = Vec::new();\n    for c in paren_string.chars() {\n        match c {\n\
    \            '(' => {\n                depth += 1;\n                if depth >\
    \ max_depth {\n                    max_depth = depth;\n                }\n   \
    \         }\n            ')' => {\n                depth -= 1;\n            }\n\
    \            ' ' => {\n                result.push(max_depth);\n             \
    \   max_depth = 0;\n                depth = 0;\n            }\n            _ =>\
    \ {}\n        }\n    }\n    result.push(max_depth);\n    result", "    let mut\
    \ max_nesting = 0;\n    let mut current_nesting = 0;\n    let mut result = Vec::new();\n\
    \    for c in paren_string.chars() {\n        match c {\n            '(' => {\n\
    \                current_nesting += 1;\n                if current_nesting > max_nesting\
    \ {\n                    max_nesting = current_nesting;\n                }\n \
    \           }\n            ')' => {\n                current_nesting -= 1;\n \
    \           }\n            ' ' => {\n                result.push(max_nesting);\n\
    \                max_nesting = 0;\n                current_nesting = 0;\n    \
    \        }\n            _ => {}\n        }\n    }\n    result.push(max_nesting);\n\
    \    result", "    let mut max_nesting_levels = Vec::new();\n    let mut current_nesting_level\
    \ = 0;\n    let mut max_nesting_level = 0;\n    for c in paren_string.chars()\
    \ {\n        match c {\n            '(' => {\n                current_nesting_level\
    \ += 1;\n                if current_nesting_level > max_nesting_level {\n    \
    \                max_nesting_level = current_nesting_level;\n                }\n\
    \            }\n            ')' => {\n                current_nesting_level -=\
    \ 1;\n            }\n            ' ' => {\n                max_nesting_levels.push(max_nesting_level);\n\
    \                max_nesting_level = 0;\n                current_nesting_level\
    \ = 0;\n            }\n            _ => {}\n        }\n    }\n    max_nesting_levels.push(max_nesting_level);\n\
    \    max_nesting_levels", "    let mut max_nesting_level = 0;\n    let mut current_nesting_level\
    \ = 0;\n    let mut result = Vec::new();\n    for c in paren_string.chars() {\n\
    \        match c {\n            '(' => {\n                current_nesting_level\
    \ += 1;\n                if current_nesting_level > max_nesting_level {\n    \
    \                max_nesting_level = current_nesting_level;\n                }\n\
    \            }\n            ')' => {\n                current_nesting_level -=\
    \ 1;\n            }\n            ' ' => {\n                result.push(max_nesting_level);\n\
    \                max_nesting_level = 0;\n                current_nesting_level\
    \ = 0;\n            }\n            _ => {}\n        }\n    }\n    result.push(max_nesting_level);\n\
    \    result", "    let mut max_depth = 0;\n    let mut depth = 0;\n    let mut\
    \ result = Vec::new();\n    for c in paren_string.chars() {\n        match c {\n\
    \            '(' => {\n                depth += 1;\n                if depth >\
    \ max_depth {\n                    max_depth = depth;\n                }\n   \
    \         }\n            ')' => {\n                depth -= 1;\n            }\n\
    \            ' ' => {\n                result.push(max_depth);\n             \
    \   max_depth = 0;\n                depth = 0;\n            }\n            _ =>\
    \ {}\n        }\n    }\n    result.push(max_depth);\n    result", "    let mut\
    \ result = Vec::new();\n    let mut max_depth = 0;\n    let mut current_depth\
    \ = 0;\n    for c in paren_string.chars() {\n        match c {\n            '('\
    \ => {\n                current_depth += 1;\n                if current_depth\
    \ > max_depth {\n                    max_depth = current_depth;\n            \
    \    }\n            }\n            ')' => {\n                current_depth -=\
    \ 1;\n            }\n            ' ' => {\n                result.push(max_depth);\n\
    \                max_depth = 0;\n                current_depth = 0;\n        \
    \    }\n            _ => {}\n        }\n    }\n    result.push(max_depth);\n \
    \   result", "    let mut max_depth = 0;\n    let mut depth = 0;\n    let mut\
    \ depths = Vec::new();\n    for c in paren_string.chars() {\n        match c {\n\
    \            '(' => {\n                depth += 1;\n                if depth >\
    \ max_depth {\n                    max_depth = depth;\n                }\n   \
    \         }\n            ')' => {\n                depth -= 1;\n            }\n\
    \            ' ' => {\n                depths.push(max_depth);\n             \
    \   max_depth = 0;\n                depth = 0;\n            }\n            _ =>\
    \ {}\n        }\n    }\n    depths.push(max_depth);\n    depths", "    let mut\
    \ max_nesting = 0;\n    let mut curr_nesting = 0;\n    let mut result = Vec::new();\n\
    \    for c in paren_string.chars() {\n        match c {\n            '(' => {\n\
    \                curr_nesting += 1;\n                if curr_nesting > max_nesting\
    \ {\n                    max_nesting = curr_nesting;\n                }\n    \
    \        }\n            ')' => {\n                curr_nesting -= 1;\n       \
    \     }\n            ' ' => {\n                result.push(max_nesting);\n   \
    \             max_nesting = 0;\n                curr_nesting = 0;\n          \
    \  }\n            _ => {}\n        }\n    }\n    result.push(max_nesting);\n \
    \   result", "    // TODO: Implement this function\n    let mut result: Vec<isize>\
    \ = Vec::new();\n    let mut count: isize = 0;\n    let mut max: isize = 0;\n\
    \    for c in paren_string.chars() {\n        if c == '(' {\n            count\
    \ += 1;\n            if count > max {\n                max = count;\n        \
    \    }\n        } else if c == ')' {\n            count -= 1;\n        } else\
    \ if c == ' ' {\n            result.push(max);\n            max = 0;\n       \
    \     count = 0;\n        }\n    }\n    result.push(max);\n    result"]
stop_tokens:
- "\n}"
