language: rs
name: HumanEval_11_string_xor
results:
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (a, b)\
    \ in a.chars().zip(b.chars()) {\n        result.push(match (a, b) {\n        \
    \    ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1', '0')\
    \ => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid input\"\
    ),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (i, j)\
    \ in a.chars().zip(b.chars()) {\n        result.push(if i == j { '0' } else {\
    \ '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (c1, c2)\
    \ in a.chars().zip(b.chars()) {\n        result.push(if c1 == c2 { '0' } else\
    \ { '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (i, j)\
    \ in a.chars().zip(b.chars()) {\n        result.push(if i == j { '0' } else {\
    \ '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 101
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    let a_bytes\
    \ = a.as_bytes();\n    let b_bytes = b.as_bytes();\n    for i in 0..a_bytes.len()\
    \ {\n        let a_byte = a_bytes[i];\n        let b_byte = b_bytes[i];\n    \
    \    let xor_byte = a_byte ^ b_byte;\n        result.push(xor_byte as char);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\\0\\u{1}\\0\\0\\u{1}\\0\"`,\n right: `\"010010\"`', /tmp/tmpexzq2zs0.rs:20:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (i, j)\
    \ in a.chars().zip(b.chars()) {\n        result.push(match (i, j) {\n        \
    \    ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1', '0')\
    \ => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid input\"\
    ),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (a, b)\
    \ in a.chars().zip(b.chars()) {\n        result.push(if a == b { '0' } else {\
    \ '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (i, j)\
    \ in a.chars().zip(b.chars()) {\n        result.push(match (i, j) {\n        \
    \    ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1', '0')\
    \ => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid input\"\
    ),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (i, j)\
    \ in a.chars().zip(b.chars()) {\n        result.push(if i == j { '0' } else {\
    \ '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (a, b)\
    \ in a.chars().zip(b.chars()) {\n        result.push(match (a, b) {\n        \
    \    ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1', '0')\
    \ => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid input\"\
    ),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (i, j)\
    \ in a.chars().zip(b.chars()) {\n        result.push(match (i, j) {\n        \
    \    ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1', '0')\
    \ => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid input\"\
    ),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (a, b)\
    \ in a.chars().zip(b.chars()) {\n        result.push(match (a, b) {\n        \
    \    ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1', '0')\
    \ => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid input\"\
    ),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (a, b)\
    \ in a.chars().zip(b.chars()) {\n        result.push(match (a, b) {\n        \
    \    ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1', '0')\
    \ => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"invalid input\"\
    ),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (i, j)\
    \ in a.chars().zip(b.chars()) {\n        result.push(if i == j { '0' } else {\
    \ '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    let mut a_iter\
    \ = a.chars();\n    let mut b_iter = b.chars();\n    loop {\n        match (a_iter.next(),\
    \ b_iter.next()) {\n            (Some(a_char), Some(b_char)) => {\n          \
    \      result.push(if a_char == b_char { '0' } else { '1' });\n            }\n\
    \            _ => break,\n        }\n    }\n    result\n}\n\nfn main() {\n   \
    \ let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (i, j)\
    \ in a.chars().zip(b.chars()) {\n        let x = i.to_digit(10).unwrap();\n  \
    \      let y = j.to_digit(10).unwrap();\n        result.push_str(&(x ^ y).to_string());\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (c1, c2)\
    \ in a.chars().zip(b.chars()) {\n        let c = if c1 == c2 { '0' } else { '1'\
    \ };\n        result.push(c);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (i, j)\
    \ in a.chars().zip(b.chars()) {\n        result.push(match (i, j) {\n        \
    \    ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1', '0')\
    \ => '1',\n            ('1', '1') => '0',\n            _ => '0',\n        });\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (i, j)\
    \ in a.chars().zip(b.chars()) {\n        result.push(if i == j { '0' } else {\
    \ '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (a, b)\
    \ in a.chars().zip(b.chars()) {\n        result.push(match (a, b) {\n        \
    \    ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1', '0')\
    \ => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid input\"\
    ),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 101
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    // TODO: implement this function\n    unimplemented!()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpy2v88po9.rs:7:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (i, j)\
    \ in a.chars().zip(b.chars()) {\n        if i == j {\n            result.push('0');\n\
    \        } else {\n            result.push('1');\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    let mut a_iter\
    \ = a.chars();\n    let mut b_iter = b.chars();\n    loop {\n        match (a_iter.next(),\
    \ b_iter.next()) {\n            (Some(a_char), Some(b_char)) => {\n          \
    \      if a_char == b_char {\n                    result.push('0');\n        \
    \        } else {\n                    result.push('1');\n                }\n\
    \            }\n            _ => break,\n        }\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (a, b)\
    \ in a.chars().zip(b.chars()) {\n        result.push(if a == b { '0' } else {\
    \ '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (i, j)\
    \ in a.chars().zip(b.chars()) {\n        result.push(match (i, j) {\n        \
    \    ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1', '0')\
    \ => '1',\n            ('1', '1') => '0',\n            _ => ' ',\n        });\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (i, j)\
    \ in a.chars().zip(b.chars()) {\n        result.push(if i == j { '0' } else {\
    \ '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (i, j)\
    \ in a.chars().zip(b.chars()) {\n        result.push(if i == j { '0' } else {\
    \ '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (i, j)\
    \ in a.chars().zip(b.chars()) {\n        result.push(if i == j { '0' } else {\
    \ '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (a, b)\
    \ in a.chars().zip(b.chars()) {\n        result.push(if a == b { '0' } else {\
    \ '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (a, b)\
    \ in a.chars().zip(b.chars()) {\n        if a == b {\n            result.push('0');\n\
    \        } else {\n            result.push('1');\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (i, j)\
    \ in a.chars().zip(b.chars()) {\n        result.push(if i == j { '0' } else {\
    \ '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    let mut a_iter\
    \ = a.chars();\n    let mut b_iter = b.chars();\n    loop {\n        match (a_iter.next(),\
    \ b_iter.next()) {\n            (Some(a_char), Some(b_char)) => {\n          \
    \      result.push(if a_char == b_char { '0' } else { '1' });\n            }\n\
    \            _ => break,\n        }\n    }\n    result\n}\n\nfn main() {\n   \
    \ let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (a, b)\
    \ in a.chars().zip(b.chars()) {\n        result.push(match (a, b) {\n        \
    \    ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1', '0')\
    \ => '1',\n            ('1', '1') => '0',\n            _ => '0',\n        });\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (i, j)\
    \ in a.chars().zip(b.chars()) {\n        result.push(match (i, j) {\n        \
    \    ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1', '0')\
    \ => '1',\n            ('1', '1') => '0',\n            _ => '0',\n        });\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (a, b)\
    \ in a.chars().zip(b.chars()) {\n        result.push(match (a, b) {\n        \
    \    ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1', '0')\
    \ => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid input\"\
    ),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 101
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    let a_bytes\
    \ = a.as_bytes();\n    let b_bytes = b.as_bytes();\n    for i in 0..a_bytes.len()\
    \ {\n        let a_char = a_bytes[i];\n        let b_char = b_bytes[i];\n    \
    \    let xor_result = a_char ^ b_char;\n        result.push(xor_result as char);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\\0\\u{1}\\0\\0\\u{1}\\0\"`,\n right: `\"010010\"`', /tmp/tmpy3yir74d.rs:20:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (i, j)\
    \ in a.chars().zip(b.chars()) {\n        if i == j {\n            result.push('0');\n\
    \        } else {\n            result.push('1');\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (a, b)\
    \ in a.chars().zip(b.chars()) {\n        result.push(match (a, b) {\n        \
    \    ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1', '0')\
    \ => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid input\"\
    ),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    let a_chars:\
    \ Vec<char> = a.chars().collect();\n    let b_chars: Vec<char> = b.chars().collect();\n\
    \    for i in 0..a_chars.len() {\n        let a_char = a_chars[i];\n        let\
    \ b_char = b_chars[i];\n        if a_char == b_char {\n            result.push('0');\n\
    \        } else {\n            result.push('1');\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 101
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    let a_bytes\
    \ = a.as_bytes();\n    let b_bytes = b.as_bytes();\n    for i in 0..a_bytes.len()\
    \ {\n        let a_byte = a_bytes[i];\n        let b_byte = b_bytes[i];\n    \
    \    let xor_result = a_byte ^ b_byte;\n        result.push(xor_result as char);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\\0\\u{1}\\0\\0\\u{1}\\0\"`,\n right: `\"010010\"`', /tmp/tmpzds9spwf.rs:20:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (i, j)\
    \ in a.chars().zip(b.chars()) {\n        result.push(if i == j { '0' } else {\
    \ '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (a, b)\
    \ in a.chars().zip(b.chars()) {\n        result.push(match (a, b) {\n        \
    \    ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1', '0')\
    \ => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid input\"\
    ),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (i, j)\
    \ in a.chars().zip(b.chars()) {\n        result.push(if i == j { '0' } else {\
    \ '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    let mut a_iter\
    \ = a.chars();\n    let mut b_iter = b.chars();\n    loop {\n        match (a_iter.next(),\
    \ b_iter.next()) {\n            (Some(a_char), Some(b_char)) => {\n          \
    \      result.push(if a_char == b_char { '0' } else { '1' });\n            }\n\
    \            _ => break,\n        }\n    }\n    result\n}\n\nfn main() {\n   \
    \ let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (i, j)\
    \ in a.chars().zip(b.chars()) {\n        result.push(match (i, j) {\n        \
    \    ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1', '0')\
    \ => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid input\"\
    ),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (i, j)\
    \ in a.chars().zip(b.chars()) {\n        result.push(if i == j { '0' } else {\
    \ '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (i, j)\
    \ in a.chars().zip(b.chars()) {\n        result.push(if i == j { '0' } else {\
    \ '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (i, j)\
    \ in a.chars().zip(b.chars()) {\n        result.push(if i == j { '0' } else {\
    \ '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (c1, c2)\
    \ in a.chars().zip(b.chars()) {\n        result.push(if c1 == c2 { '0' } else\
    \ { '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (i, j)\
    \ in a.chars().zip(b.chars()) {\n        result.push(if i == j { '0' } else {\
    \ '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    let mut a_iter\
    \ = a.chars();\n    let mut b_iter = b.chars();\n    loop {\n        let a_char\
    \ = a_iter.next();\n        let b_char = b_iter.next();\n        if a_char.is_none()\
    \ || b_char.is_none() {\n            break;\n        }\n        let a_char = a_char.unwrap();\n\
    \        let b_char = b_char.unwrap();\n        if a_char == b_char {\n      \
    \      result.push('0');\n        } else {\n            result.push('1');\n  \
    \      }\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (a, b)\
    \ in a.chars().zip(b.chars()) {\n        result.push(if a == b { '0' } else {\
    \ '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    let mut a_iter\
    \ = a.chars();\n    let mut b_iter = b.chars();\n    loop {\n        match (a_iter.next(),\
    \ b_iter.next()) {\n            (Some(a_char), Some(b_char)) => {\n          \
    \      result.push(if a_char == b_char { '0' } else { '1' });\n            }\n\
    \            _ => break,\n        }\n    }\n    result\n}\n\nfn main() {\n   \
    \ let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (a, b)\
    \ in a.chars().zip(b.chars()) {\n        result.push(match (a, b) {\n        \
    \    ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1', '0')\
    \ => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid input\"\
    ),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (a, b)\
    \ in a.chars().zip(b.chars()) {\n        result.push(if a == b { '0' } else {\
    \ '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (c1, c2)\
    \ in a.chars().zip(b.chars()) {\n        result.push(if c1 == c2 { '0' } else\
    \ { '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (a, b)\
    \ in a.chars().zip(b.chars()) {\n        result.push(match (a, b) {\n        \
    \    ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1', '0')\
    \ => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid input\"\
    ),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (a, b)\
    \ in a.chars().zip(b.chars()) {\n        result.push(match (a, b) {\n        \
    \    ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1', '0')\
    \ => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid input\"\
    ),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (a, b)\
    \ in a.chars().zip(b.chars()) {\n        result.push(if a == b { '0' } else {\
    \ '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (a, b)\
    \ in a.chars().zip(b.chars()) {\n        result.push(if a == b { '0' } else {\
    \ '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    let mut a_iter\
    \ = a.chars();\n    let mut b_iter = b.chars();\n    loop {\n        match (a_iter.next(),\
    \ b_iter.next()) {\n            (Some(a_char), Some(b_char)) => {\n          \
    \      result.push(if a_char == b_char { '0' } else { '1' });\n            }\n\
    \            _ => break,\n        }\n    }\n    result\n}\n\nfn main() {\n   \
    \ let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (a, b)\
    \ in a.chars().zip(b.chars()) {\n        result.push(if a == b { '0' } else {\
    \ '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (a, b)\
    \ in a.chars().zip(b.chars()) {\n        result.push(if a == b { '0' } else {\
    \ '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (a, b)\
    \ in a.chars().zip(b.chars()) {\n        result.push(match (a, b) {\n        \
    \    ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1', '0')\
    \ => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid input\"\
    ),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (a, b)\
    \ in a.chars().zip(b.chars()) {\n        result.push(if a == b { '0' } else {\
    \ '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (i, j)\
    \ in a.chars().zip(b.chars()) {\n        result.push(match (i, j) {\n        \
    \    ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1', '0')\
    \ => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid input\"\
    ),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (a, b)\
    \ in a.chars().zip(b.chars()) {\n        result.push(match (a, b) {\n        \
    \    ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1', '0')\
    \ => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid input\"\
    ),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (c1, c2)\
    \ in a.chars().zip(b.chars()) {\n        let x = c1.to_digit(2).unwrap() ^ c2.to_digit(2).unwrap();\n\
    \        result.push_str(&x.to_string());\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (a, b)\
    \ in a.chars().zip(b.chars()) {\n        result.push(if a == b { '0' } else {\
    \ '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut res = String::new();\n    for (i, j) in\
    \ a.chars().zip(b.chars()) {\n        res.push(match (i, j) {\n            ('0',\
    \ '0') => '0',\n            ('0', '1') => '1',\n            ('1', '0') => '1',\n\
    \            ('1', '1') => '0',\n            _ => panic!(\"Invalid input\"),\n\
    \        });\n    }\n    res\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (i, j)\
    \ in a.chars().zip(b.chars()) {\n        result.push(match (i, j) {\n        \
    \    ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1', '0')\
    \ => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid input\"\
    ),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (c1, c2)\
    \ in a.chars().zip(b.chars()) {\n        let x = c1.to_digit(2).unwrap() ^ c2.to_digit(2).unwrap();\n\
    \        result.push_str(&x.to_string());\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (i, j)\
    \ in a.chars().zip(b.chars()) {\n        result.push(if i == j { '0' } else {\
    \ '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (i, j)\
    \ in a.chars().zip(b.chars()) {\n        result.push(match (i, j) {\n        \
    \    ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1', '0')\
    \ => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid input\"\
    ),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (a, b)\
    \ in a.chars().zip(b.chars()) {\n        result.push(if a == b { '0' } else {\
    \ '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (i, j)\
    \ in a.chars().zip(b.chars()) {\n        result.push(if i == j { '0' } else {\
    \ '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (a, b)\
    \ in a.chars().zip(b.chars()) {\n        result.push(if a == b { '0' } else {\
    \ '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (a, b)\
    \ in a.chars().zip(b.chars()) {\n        result.push(if a == b { '0' } else {\
    \ '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (a, b)\
    \ in a.chars().zip(b.chars()) {\n        result.push(if a == b { '0' } else {\
    \ '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (c1, c2)\
    \ in a.chars().zip(b.chars()) {\n        let c = c1.to_digit(2).unwrap() ^ c2.to_digit(2).unwrap();\n\
    \        result.push_str(&c.to_string());\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008951
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (a, b)\
    \ in a.chars().zip(b.chars()) {\n        result.push(if a == b { '0' } else {\
    \ '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (a, b)\
    \ in a.chars().zip(b.chars()) {\n        result.push(match (a, b) {\n        \
    \    ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1', '0')\
    \ => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid input\"\
    ),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (a, b)\
    \ in a.chars().zip(b.chars()) {\n        result.push(match (a, b) {\n        \
    \    ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1', '0')\
    \ => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid input\"\
    ),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 101
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    let a_bytes\
    \ = a.as_bytes();\n    let b_bytes = b.as_bytes();\n    for i in 0..a_bytes.len()\
    \ {\n        let a_byte = a_bytes[i];\n        let b_byte = b_bytes[i];\n    \
    \    let c = a_byte ^ b_byte;\n        result.push(c as char);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\\0\\u{1}\\0\\0\\u{1}\\0\"`,\n right: `\"010010\"`', /tmp/tmpgzfxdzd8.rs:20:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008951
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (a, b)\
    \ in a.chars().zip(b.chars()) {\n        result.push(if a == b { '0' } else {\
    \ '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (i, j)\
    \ in a.chars().zip(b.chars()) {\n        result.push(match (i, j) {\n        \
    \    ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1', '0')\
    \ => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid input\"\
    ),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (i, j)\
    \ in a.chars().zip(b.chars()) {\n        result.push(if i == j { '0' } else {\
    \ '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (i, j)\
    \ in a.chars().zip(b.chars()) {\n        result.push(if i == j { '0' } else {\
    \ '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    let mut a_iter\
    \ = a.chars();\n    let mut b_iter = b.chars();\n    loop {\n        match (a_iter.next(),\
    \ b_iter.next()) {\n            (Some(a_char), Some(b_char)) => {\n          \
    \      result.push(if a_char == b_char { '0' } else { '1' });\n            }\n\
    \            _ => break,\n        }\n    }\n    result\n}\n\nfn main() {\n   \
    \ let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (a, b)\
    \ in a.chars().zip(b.chars()) {\n        result.push(match (a, b) {\n        \
    \    ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1', '0')\
    \ => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid input\"\
    ),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (a, b)\
    \ in a.chars().zip(b.chars()) {\n        result.push(match (a, b) {\n        \
    \    ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1', '0')\
    \ => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid input\"\
    ),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (a, b)\
    \ in a.chars().zip(b.chars()) {\n        result.push(if a == b { '0' } else {\
    \ '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (i, j)\
    \ in a.chars().zip(b.chars()) {\n        if i == j {\n            result.push('0');\n\
    \        } else {\n            result.push('1');\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (i, j)\
    \ in a.chars().zip(b.chars()) {\n        result.push(match (i, j) {\n        \
    \    ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1', '0')\
    \ => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid input\"\
    ),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (a, b)\
    \ in a.chars().zip(b.chars()) {\n        result.push(match (a, b) {\n        \
    \    ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1', '0')\
    \ => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid input\"\
    ),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (c1, c2)\
    \ in a.chars().zip(b.chars()) {\n        result.push(if c1 == c2 { '0' } else\
    \ { '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (a, b)\
    \ in a.chars().zip(b.chars()) {\n        result.push(match (a, b) {\n        \
    \    ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1', '0')\
    \ => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid input\"\
    ),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    let mut a_iter\
    \ = a.chars();\n    let mut b_iter = b.chars();\n    loop {\n        match (a_iter.next(),\
    \ b_iter.next()) {\n            (Some(a_char), Some(b_char)) => {\n          \
    \      let a_int = a_char.to_digit(10).unwrap();\n                let b_int =\
    \ b_char.to_digit(10).unwrap();\n                result.push_str(&(a_int ^ b_int).to_string());\n\
    \            }\n            (Some(_), None) => {\n                panic!(\"a is\
    \ longer than b\");\n            }\n            (None, Some(_)) => {\n       \
    \         panic!(\"b is longer than a\");\n            }\n            (None, None)\
    \ => {\n                break;\n            }\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008951
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (a, b)\
    \ in a.chars().zip(b.chars()) {\n        result.push(if a == b { '0' } else {\
    \ '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (c1, c2)\
    \ in a.chars().zip(b.chars()) {\n        result.push(if c1 == c2 { '0' } else\
    \ { '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (i, j)\
    \ in a.chars().zip(b.chars()) {\n        result.push(if i == j { '0' } else {\
    \ '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (i, j)\
    \ in a.chars().zip(b.chars()) {\n        result.push(if i == j { '0' } else {\
    \ '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    let mut a_iter\
    \ = a.chars();\n    let mut b_iter = b.chars();\n    loop {\n        match (a_iter.next(),\
    \ b_iter.next()) {\n            (Some(a_char), Some(b_char)) => {\n          \
    \      if a_char == b_char {\n                    result.push('0');\n        \
    \        } else {\n                    result.push('1');\n                }\n\
    \            }\n            _ => break,\n        }\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (i, j)\
    \ in a.chars().zip(b.chars()) {\n        result.push(match (i, j) {\n        \
    \    ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1', '0')\
    \ => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid input\"\
    ),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    let mut a_iter\
    \ = a.chars();\n    let mut b_iter = b.chars();\n    loop {\n        let a_char\
    \ = a_iter.next();\n        let b_char = b_iter.next();\n        if a_char.is_none()\
    \ || b_char.is_none() {\n            break;\n        }\n        let a_char = a_char.unwrap();\n\
    \        let b_char = b_char.unwrap();\n        if a_char == b_char {\n      \
    \      result.push('0');\n        } else {\n            result.push('1');\n  \
    \      }\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (a, b)\
    \ in a.chars().zip(b.chars()) {\n        result.push(match (a, b) {\n        \
    \    ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1', '0')\
    \ => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid input\"\
    ),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (i, j)\
    \ in a.chars().zip(b.chars()) {\n        result.push(match (i, j) {\n        \
    \    ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1', '0')\
    \ => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid input\"\
    ),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    let mut a_iter\
    \ = a.chars();\n    let mut b_iter = b.chars();\n    loop {\n        match (a_iter.next(),\
    \ b_iter.next()) {\n            (Some(a_char), Some(b_char)) => {\n          \
    \      result.push(if a_char == b_char { '0' } else { '1' });\n            }\n\
    \            _ => break,\n        }\n    }\n    result\n}\n\nfn main() {\n   \
    \ let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (i, j)\
    \ in a.chars().zip(b.chars()) {\n        if i == j {\n            result.push('0');\n\
    \        } else {\n            result.push('1');\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    let mut a_iter\
    \ = a.chars();\n    let mut b_iter = b.chars();\n    loop {\n        let a_char\
    \ = a_iter.next();\n        let b_char = b_iter.next();\n        if a_char.is_none()\
    \ || b_char.is_none() {\n            break;\n        }\n        let a_char = a_char.unwrap();\n\
    \        let b_char = b_char.unwrap();\n        if a_char == b_char {\n      \
    \      result.push('0');\n        } else {\n            result.push('1');\n  \
    \      }\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (i, j)\
    \ in a.chars().zip(b.chars()) {\n        result.push(if i == j { '0' } else {\
    \ '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (a, b)\
    \ in a.chars().zip(b.chars()) {\n        result.push(if a == b { '0' } else {\
    \ '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (a, b)\
    \ in a.chars().zip(b.chars()) {\n        result.push(match (a, b) {\n        \
    \    ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1', '0')\
    \ => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid input\"\
    ),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    let mut a_iter\
    \ = a.chars();\n    let mut b_iter = b.chars();\n    loop {\n        match (a_iter.next(),\
    \ b_iter.next()) {\n            (Some(a_char), Some(b_char)) => {\n          \
    \      result.push(if a_char == b_char { '0' } else { '1' });\n            }\n\
    \            _ => break,\n        }\n    }\n    result\n}\n\nfn main() {\n   \
    \ let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (a, b)\
    \ in a.chars().zip(b.chars()) {\n        result.push(if a == b { '0' } else {\
    \ '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (a, b)\
    \ in a.chars().zip(b.chars()) {\n        result.push(match (a, b) {\n        \
    \    ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1', '0')\
    \ => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid input\"\
    ),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (i, j)\
    \ in a.chars().zip(b.chars()) {\n        result.push(match (i, j) {\n        \
    \    ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1', '0')\
    \ => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid input\"\
    ),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (a, b)\
    \ in a.chars().zip(b.chars()) {\n        result.push(match (a, b) {\n        \
    \    ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1', '0')\
    \ => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid input\"\
    ),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (i, j)\
    \ in a.chars().zip(b.chars()) {\n        result.push(match (i, j) {\n        \
    \    ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1', '0')\
    \ => '1',\n            ('1', '1') => '0',\n            _ => '0',\n        });\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (i, j)\
    \ in a.chars().zip(b.chars()) {\n        result.push(if i == j { '0' } else {\
    \ '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (i, j)\
    \ in a.chars().zip(b.chars()) {\n        if i == j {\n            result.push('0');\n\
    \        } else {\n            result.push('1');\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (i, j)\
    \ in a.chars().zip(b.chars()) {\n        result.push(if i == j { '0' } else {\
    \ '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    let mut a_iter\
    \ = a.chars();\n    let mut b_iter = b.chars();\n    loop {\n        let a_char\
    \ = a_iter.next();\n        let b_char = b_iter.next();\n        if a_char.is_none()\
    \ || b_char.is_none() {\n            break;\n        }\n        let a_char = a_char.unwrap();\n\
    \        let b_char = b_char.unwrap();\n        if a_char == b_char {\n      \
    \      result.push('0');\n        } else {\n            result.push('1');\n  \
    \      }\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (a, b)\
    \ in a.chars().zip(b.chars()) {\n        result.push(if a == b { '0' } else {\
    \ '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (i, j)\
    \ in a.chars().zip(b.chars()) {\n        result.push(if i == j { '0' } else {\
    \ '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (i, j)\
    \ in a.chars().zip(b.chars()) {\n        result.push(match (i, j) {\n        \
    \    ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1', '0')\
    \ => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid input\"\
    ),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (a, b)\
    \ in a.chars().zip(b.chars()) {\n        result.push(match (a, b) {\n        \
    \    ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1', '0')\
    \ => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid input\"\
    ),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (i, j)\
    \ in a.chars().zip(b.chars()) {\n        result.push(match (i, j) {\n        \
    \    ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1', '0')\
    \ => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid input\"\
    ),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (i, j)\
    \ in a.chars().zip(b.chars()) {\n        result.push(match (i, j) {\n        \
    \    ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1', '0')\
    \ => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid input\"\
    ),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (a, b)\
    \ in a.chars().zip(b.chars()) {\n        result.push(match (a, b) {\n        \
    \    ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1', '0')\
    \ => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"invalid input\"\
    ),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (a, b)\
    \ in a.chars().zip(b.chars()) {\n        result.push(if a == b { '0' } else {\
    \ '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (i, j)\
    \ in a.chars().zip(b.chars()) {\n        result.push(match (i, j) {\n        \
    \    ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1', '0')\
    \ => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid input\"\
    ),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for i in 0..a.len()\
    \ {\n        if a.chars().nth(i).unwrap() == b.chars().nth(i).unwrap() {\n   \
    \         result.push('0');\n        } else {\n            result.push('1');\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008951
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (a, b)\
    \ in a.chars().zip(b.chars()) {\n        result.push(if a == b { '0' } else {\
    \ '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (i, j)\
    \ in a.chars().zip(b.chars()) {\n        result.push(match (i, j) {\n        \
    \    ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1', '0')\
    \ => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid input\"\
    ),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (a, b)\
    \ in a.chars().zip(b.chars()) {\n        result.push(if a == b { '0' } else {\
    \ '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (a, b)\
    \ in a.chars().zip(b.chars()) {\n        result.push(if a == b { '0' } else {\
    \ '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (i, j)\
    \ in a.chars().zip(b.chars()) {\n        result.push(match (i, j) {\n        \
    \    ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1', '0')\
    \ => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid input\"\
    ),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (a, b)\
    \ in a.chars().zip(b.chars()) {\n        result.push(if a == b { '0' } else {\
    \ '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (a, b)\
    \ in a.chars().zip(b.chars()) {\n        result.push(if a == b { '0' } else {\
    \ '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (i, j)\
    \ in a.chars().zip(b.chars()) {\n        result.push(if i == j { '0' } else {\
    \ '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (i, j)\
    \ in a.chars().zip(b.chars()) {\n        if i == j {\n            result.push('0');\n\
    \        } else {\n            result.push('1');\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (i, j)\
    \ in a.chars().zip(b.chars()) {\n        result.push(match (i, j) {\n        \
    \    ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1', '0')\
    \ => '1',\n            ('1', '1') => '0',\n            _ => '0',\n        });\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (a, b)\
    \ in a.chars().zip(b.chars()) {\n        result.push(if a == b { '0' } else {\
    \ '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (a, b)\
    \ in a.chars().zip(b.chars()) {\n        result.push(if a == b { '0' } else {\
    \ '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (a, b)\
    \ in a.chars().zip(b.chars()) {\n        result.push(match (a, b) {\n        \
    \    ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1', '0')\
    \ => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid input\"\
    ),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    let mut a_iter\
    \ = a.chars();\n    let mut b_iter = b.chars();\n    loop {\n        match (a_iter.next(),\
    \ b_iter.next()) {\n            (Some(a_char), Some(b_char)) => {\n          \
    \      if a_char == b_char {\n                    result.push('0');\n        \
    \        } else {\n                    result.push('1');\n                }\n\
    \            }\n            (None, None) => break,\n            _ => panic!(\"\
    Strings must be of equal length\"),\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008951
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (a, b)\
    \ in a.chars().zip(b.chars()) {\n        result.push(match (a, b) {\n        \
    \    ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1', '0')\
    \ => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid input\"\
    ),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (c1, c2)\
    \ in a.chars().zip(b.chars()) {\n        result.push(match (c1, c2) {\n      \
    \      ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1', '0')\
    \ => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid input\"\
    ),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008951
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (i, j)\
    \ in a.chars().zip(b.chars()) {\n        result.push(match (i, j) {\n        \
    \    ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1', '0')\
    \ => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid input\"\
    ),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (a, b)\
    \ in a.chars().zip(b.chars()) {\n        result.push(match (a, b) {\n        \
    \    ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1', '0')\
    \ => '1',\n            ('1', '1') => '0',\n            _ => '0',\n        });\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (a, b)\
    \ in a.chars().zip(b.chars()) {\n        result.push(match (a, b) {\n        \
    \    ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1', '0')\
    \ => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid input\"\
    ),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    let mut a_iter\
    \ = a.chars();\n    let mut b_iter = b.chars();\n    loop {\n        match (a_iter.next(),\
    \ b_iter.next()) {\n            (Some(a_char), Some(b_char)) => {\n          \
    \      result.push(if a_char == b_char { '0' } else { '1' });\n            }\n\
    \            _ => break,\n        }\n    }\n    result\n}\n\nfn main() {\n   \
    \ let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    let mut a_iter\
    \ = a.chars();\n    let mut b_iter = b.chars();\n    loop {\n        match (a_iter.next(),\
    \ b_iter.next()) {\n            (Some(a_char), Some(b_char)) => {\n          \
    \      result.push(if a_char == b_char { '0' } else { '1' });\n            }\n\
    \            _ => break,\n        }\n    }\n    result\n}\n\nfn main() {\n   \
    \ let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (a, b)\
    \ in a.chars().zip(b.chars()) {\n        result.push(if a == b { '0' } else {\
    \ '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (i, j)\
    \ in a.chars().zip(b.chars()) {\n        result.push(if i == j { '0' } else {\
    \ '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut output = String::new();\n    for (a, b)\
    \ in a.chars().zip(b.chars()) {\n        output.push(match (a, b) {\n        \
    \    ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1', '0')\
    \ => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid input\"\
    ),\n        });\n    }\n    output\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008951
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (i, j)\
    \ in a.chars().zip(b.chars()) {\n        result.push(if i == j { '0' } else {\
    \ '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (a, b)\
    \ in a.chars().zip(b.chars()) {\n        result.push(match (a, b) {\n        \
    \    ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1', '0')\
    \ => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid input\"\
    ),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    let mut a_chars\
    \ = a.chars();\n    let mut b_chars = b.chars();\n    loop {\n        match (a_chars.next(),\
    \ b_chars.next()) {\n            (Some(a_char), Some(b_char)) => {\n         \
    \       result.push(if a_char == b_char { '0' } else { '1' });\n            }\n\
    \            _ => break,\n        }\n    }\n    result\n}\n\nfn main() {\n   \
    \ let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008951
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (i, j)\
    \ in a.chars().zip(b.chars()) {\n        result.push(match (i, j) {\n        \
    \    ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1', '0')\
    \ => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid input\"\
    ),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (i, j)\
    \ in a.chars().zip(b.chars()) {\n        result.push(match (i, j) {\n        \
    \    ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1', '0')\
    \ => '1',\n            ('1', '1') => '0',\n            _ => '0',\n        });\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (i, j)\
    \ in a.chars().zip(b.chars()) {\n        result.push(if i == j { '0' } else {\
    \ '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut a_chars = a.chars();\n    let mut b_chars\
    \ = b.chars();\n    let mut result = String::new();\n    loop {\n        match\
    \ (a_chars.next(), b_chars.next()) {\n            (Some(a_char), Some(b_char))\
    \ => {\n                result.push(if a_char == b_char { '0' } else { '1' });\n\
    \            }\n            _ => break,\n        }\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008951
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (c1, c2)\
    \ in a.chars().zip(b.chars()) {\n        result.push(if c1 == c2 { '0' } else\
    \ { '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (i, j)\
    \ in a.chars().zip(b.chars()) {\n        result.push(match (i, j) {\n        \
    \    ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1', '0')\
    \ => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid input\"\
    ),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (a, b)\
    \ in a.chars().zip(b.chars()) {\n        result.push(match (a, b) {\n        \
    \    ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1', '0')\
    \ => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid input\"\
    ),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (a, b)\
    \ in a.chars().zip(b.chars()) {\n        result.push(match (a, b) {\n        \
    \    ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1', '0')\
    \ => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"invalid input\"\
    ),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (a, b)\
    \ in a.chars().zip(b.chars()) {\n        result.push(match (a, b) {\n        \
    \    ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1', '0')\
    \ => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid input\"\
    ),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    let mut a_chars\
    \ = a.chars();\n    let mut b_chars = b.chars();\n    loop {\n        match (a_chars.next(),\
    \ b_chars.next()) {\n            (Some(a_char), Some(b_char)) => {\n         \
    \       result.push(if a_char == b_char { '0' } else { '1' });\n            }\n\
    \            _ => break,\n        }\n    }\n    result\n}\n\nfn main() {\n   \
    \ let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008951
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (i, j)\
    \ in a.chars().zip(b.chars()) {\n        result.push(match (i, j) {\n        \
    \    ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1', '0')\
    \ => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid input\"\
    ),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (a, b)\
    \ in a.chars().zip(b.chars()) {\n        result.push(if a == b { '0' } else {\
    \ '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (a, b)\
    \ in a.chars().zip(b.chars()) {\n        result.push(if a == b { '0' } else {\
    \ '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (i, j)\
    \ in a.chars().zip(b.chars()) {\n        result.push(if i == j { '0' } else {\
    \ '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (a, b)\
    \ in a.chars().zip(b.chars()) {\n        result.push(match (a, b) {\n        \
    \    ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1', '0')\
    \ => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid input\"\
    ),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (a, b)\
    \ in a.chars().zip(b.chars()) {\n        if a == b {\n            result.push('0');\n\
    \        } else {\n            result.push('1');\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (a, b)\
    \ in a.chars().zip(b.chars()) {\n        result.push(if a == b { '0' } else {\
    \ '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (a, b)\
    \ in a.chars().zip(b.chars()) {\n        result.push(match (a, b) {\n        \
    \    ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1', '0')\
    \ => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid input\"\
    ),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (a, b)\
    \ in a.chars().zip(b.chars()) {\n        result.push(if a == b { '0' } else {\
    \ '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (a, b)\
    \ in a.chars().zip(b.chars()) {\n        result.push(if a == b { '0' } else {\
    \ '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (i, j)\
    \ in a.chars().zip(b.chars()) {\n        result.push(if i == j { '0' } else {\
    \ '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (i, j)\
    \ in a.chars().zip(b.chars()) {\n        result.push(if i == j { '0' } else {\
    \ '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (c1, c2)\
    \ in a.chars().zip(b.chars()) {\n        result.push(if c1 == c2 { '0' } else\
    \ { '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (i, j)\
    \ in a.chars().zip(b.chars()) {\n        result.push(if i == j { '0' } else {\
    \ '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (i, j)\
    \ in a.chars().zip(b.chars()) {\n        result.push(match (i, j) {\n        \
    \    ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1', '0')\
    \ => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid input\"\
    ),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (c1, c2)\
    \ in a.chars().zip(b.chars()) {\n        result.push(if c1 == c2 { '0' } else\
    \ { '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (i, j)\
    \ in a.chars().zip(b.chars()) {\n        result.push(match (i, j) {\n        \
    \    ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1', '0')\
    \ => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid input\"\
    ),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (a, b)\
    \ in a.chars().zip(b.chars()) {\n        result.push(if a == b { '0' } else {\
    \ '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (i, j)\
    \ in a.chars().zip(b.chars()) {\n        result.push(match (i, j) {\n        \
    \    ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1', '0')\
    \ => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid input\"\
    ),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (i, j)\
    \ in a.chars().zip(b.chars()) {\n        result.push(match (i, j) {\n        \
    \    ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1', '0')\
    \ => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid input\"\
    ),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    let mut a_iter\
    \ = a.chars();\n    let mut b_iter = b.chars();\n    loop {\n        match (a_iter.next(),\
    \ b_iter.next()) {\n            (Some(a_char), Some(b_char)) => {\n          \
    \      if a_char == b_char {\n                    result.push('0');\n        \
    \        } else {\n                    result.push('1');\n                }\n\
    \            }\n            _ => break,\n        }\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (i, j)\
    \ in a.chars().zip(b.chars()) {\n        result.push(if i == j { '0' } else {\
    \ '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (a, b)\
    \ in a.chars().zip(b.chars()) {\n        result.push(match (a, b) {\n        \
    \    ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1', '0')\
    \ => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid input\"\
    ),\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (i, j)\
    \ in a.chars().zip(b.chars()) {\n        result.push(if i == j { '0' } else {\
    \ '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (i, j)\
    \ in a.chars().zip(b.chars()) {\n        result.push(if i == j { '0' } else {\
    \ '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (i, j)\
    \ in a.chars().zip(b.chars()) {\n        if i == j {\n            result.push('0');\n\
    \        } else {\n            result.push('1');\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 101
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let a_bytes = a.into_bytes();\n    let b_bytes =\
    \ b.into_bytes();\n    let mut result = Vec::new();\n    for i in 0..a_bytes.len()\
    \ {\n        result.push(a_bytes[i] ^ b_bytes[i]);\n    }\n    String::from_utf8(result).unwrap()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\\0\\u{1}\\0\\0\\u{1}\\0\"`,\n right: `\"010010\"`', /tmp/tmp3ejfan5a.rs:17:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008951
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (i, j)\
    \ in a.chars().zip(b.chars()) {\n        result.push(if i == j { '0' } else {\
    \ '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (a, b)\
    \ in a.chars().zip(b.chars()) {\n        if a == b {\n            result.push('0');\n\
    \        } else {\n            result.push('1');\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (a, b)\
    \ in a.chars().zip(b.chars()) {\n        result.push(if a == b { '0' } else {\
    \ '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008950
