name: HumanEval_112_reverse_delete
language: rs
prompt: "/// Task\n/// We are given two strings s and c, you have to deleted all the\
  \ characters in s that are equal to any character in c\n/// then check if the result\
  \ string is palindrome.\n/// A string is called palindrome if it reads the same\
  \ backward as forward.\n/// You should return a tuple containing the result string\
  \ and True/False for the check.\n/// Example\n/// >>> reverse_delete(String::from(\"\
  abcde\"), String::from(\"ae\"))\n/// (String::from(\"bcd\"), false)\n/// >>> reverse_delete(String::from(\"\
  abcdef\"), String::from(\"b\"))\n/// (String::from(\"acdef\"), false)\n/// >>> reverse_delete(String::from(\"\
  abcdedcba\"), String::from(\"ab\"))\n/// (String::from(\"cdedc\"), true)\nfn reverse_delete(s:\
  \ String, c: String) -> (String, bool) {\n"
tests: "}\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!({left},\
  \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
  \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
  \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
  \    assert_eq!({left}, {right});\n}\n"
completions: ["    let mut result = String::new();\n    for ch in s.chars() {\n  \
    \      if !c.contains(ch) {\n            result.push(ch);\n        }\n    }\n\
    \    (result, result == result.chars().rev().collect::<String>())", "    let mut\
    \ result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    (result, result == result.chars().rev().collect::<String>())",
  "    let mut result = String::new();\n    let mut chars = s.chars().collect::<Vec<char>>();\n\
    \    let mut chars_c = c.chars().collect::<Vec<char>>();\n    chars.sort();\n\
    \    chars_c.sort();\n    let mut i = 0;\n    let mut j = 0;\n    while i < chars.len()\
    \ && j < chars_c.len() {\n        if chars[i] == chars_c[j] {\n            i +=\
    \ 1;\n        } else if chars[i] < chars_c[j] {\n            result.push(chars[i]);\n\
    \            i += 1;\n        } else {\n            j += 1;\n        }\n    }\n\
    \    while i < chars.len() {\n        result.push(chars[i]);\n        i += 1;\n\
    \    }\n    (result, result == result.chars().rev().collect::<String>())", " \
    \   let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result.chars().eq(result.chars().rev());\n\
    \    (result, is_palindrome)", "    let mut result = s;\n    for i in c.chars()\
    \ {\n        result = result.replace(i, \"\");\n    }\n    (result, result ==\
    \ result.chars().rev().collect::<String>())", "    let mut s: Vec<char> = s.chars().collect();\n\
    \    let mut c: Vec<char> = c.chars().collect();\n    s.retain(|x| !c.contains(x));\n\
    \    let s: String = s.into_iter().collect();\n    (s, s == s.chars().rev().collect::<String>())",
  "    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let mut is_palindrome\
    \ = true;\n    let mut i = 0;\n    let mut j = result.len() - 1;\n    while i\
    \ < j {\n        if result.chars().nth(i) != result.chars().nth(j) {\n       \
    \     is_palindrome = false;\n            break;\n        }\n        i += 1;\n\
    \        j -= 1;\n    }\n    (result, is_palindrome)", "    let mut result = String::new();\n\
    \    let mut chars = s.chars().collect::<Vec<char>>();\n    for i in (0..chars.len()).rev()\
    \ {\n        if !c.contains(chars[i]) {\n            result.push(chars[i]);\n\
    \        }\n    }\n    (result, result == result.chars().rev().collect::<String>())",
  "    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    (result, result == result.chars().rev().collect::<String>())",
  "    let mut result = String::new();\n    let mut chars: Vec<char> = s.chars().collect();\n\
    \    let mut chars_c: Vec<char> = c.chars().collect();\n    chars_c.sort();\n\
    \    chars.sort();\n    let mut i = 0;\n    let mut j = 0;\n    while i < chars.len()\
    \ && j < chars_c.len() {\n        if chars[i] < chars_c[j] {\n            result.push(chars[i]);\n\
    \            i += 1;\n        } else if chars[i] > chars_c[j] {\n            j\
    \ += 1;\n        } else {\n            i += 1;\n            j += 1;\n        }\n\
    \    }\n    while i < chars.len() {\n        result.push(chars[i]);\n        i\
    \ += 1;\n    }\n    let mut is_palindrome = true;\n    let mut i = 0;\n    let\
    \ mut j = result.len() - 1;\n    while i < j {\n        if result.chars().nth(i)\
    \ != result.chars().nth(j) {\n            is_palindrome = false;\n           \
    \ break;\n        }\n        i += 1;\n        j -= 1;\n    }\n    (result, is_palindrome)",
  "    let mut result = String::new();\n    let mut is_palindrome = true;\n    let\
    \ mut chars = s.chars().collect::<Vec<char>>();\n    chars.reverse();\n    for\
    \ ch in chars {\n        if !c.contains(ch) {\n            result.push(ch);\n\
    \        }\n    }\n    for i in 0..result.len() / 2 {\n        if result.chars().nth(i)\
    \ != result.chars().nth(result.len() - i - 1) {\n            is_palindrome = false;\n\
    \            break;\n        }\n    }\n    (result, is_palindrome)", "    let\
    \ mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    (result, result == result.chars().rev().collect::<String>())",
  "    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let is_palindrome = result.chars().eq(result.chars().rev());\n\
    \    (result, is_palindrome)", "    let mut result = String::new();\n    for ch\
    \ in s.chars() {\n        if !c.contains(ch) {\n            result.push(ch);\n\
    \        }\n    }\n    (result, result == result.chars().rev().collect::<String>())",
  "    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    (result, result == result.chars().rev().collect::<String>())",
  "    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    (result, result == result.chars().rev().collect::<String>())",
  "    let mut result = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        }\n    }\n    let mut reversed = String::new();\n\
    \    for ch in result.chars().rev() {\n        reversed.push(ch);\n    }\n   \
    \ (result, result == reversed)", "    let mut s_chars: Vec<char> = s.chars().collect();\n\
    \    let c_chars: Vec<char> = c.chars().collect();\n    let mut i = 0;\n    while\
    \ i < s_chars.len() {\n        if c_chars.contains(&s_chars[i]) {\n          \
    \  s_chars.remove(i);\n        } else {\n            i += 1;\n        }\n    }\n\
    \    let s_chars_reversed: Vec<char> = s_chars.iter().rev().cloned().collect();\n\
    \    (s_chars.iter().collect(), s_chars == s_chars_reversed)", "    let mut result\
    \ = String::new();\n    for ch in s.chars() {\n        if !c.contains(ch) {\n\
    \            result.push(ch);\n        }\n    }\n    let mut reversed = String::new();\n\
    \    for ch in result.chars().rev() {\n        reversed.push(ch);\n    }\n   \
    \ (result, result == reversed)", "    let mut result = String::new();\n    let\
    \ mut chars = s.chars().collect::<Vec<char>>();\n    let mut chars_c = c.chars().collect::<Vec<char>>();\n\
    \    chars.retain(|x| !chars_c.contains(x));\n    for i in chars {\n        result.push(i);\n\
    \    }\n    (result, result == result.chars().rev().collect::<String>())"]
stop_tokens:
- "\n}"
