language: rs
name: HumanEval_89_encrypt
results:
- exit_code: 0
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut new_char = c as u8 + 2 * 2;\n        if new_char > 122 {\n\
    \            new_char = new_char - 26;\n        }\n        result.push(new_char\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010896
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let c_num = c as u8;\n        let c_num_new = c_num + 4;\n      \
    \  let c_new = c_num_new as char;\n        result.push(c_new);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmp1ixcbwtg.rs:31:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010897
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let c_num = c as u8;\n        let c_num_shifted = c_num + 2 * 2;\n\
    \        let c_shifted = c_num_shifted as char;\n        result.push(c_shifted);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmppv9os1np.rs:31:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010897
- exit_code: 0
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 2 * 2;\n        if c > 122 {\n\
    \            c -= 26;\n        }\n        result.push(c as char);\n    }\n   \
    \ result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010897
- exit_code: 0
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c = c + 2 * 2;\n        if c > 122\
    \ {\n            c = c - 26;\n        }\n        result.push(c as char);\n   \
    \ }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010896
- exit_code: 0
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut encrypted = String::new();\n    for c in s.chars()\
    \ {\n        let mut new_char = c as u8 + 2 * 2;\n        if new_char > 122 {\n\
    \            new_char = new_char - 26;\n        }\n        encrypted.push(new_char\
    \ as char);\n    }\n    encrypted\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010897
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut new_c = c as u8;\n        new_c += 2;\n        if new_c >\
    \ 'z' as u8 {\n            new_c -= 26;\n        }\n        result.push(new_c\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmp9gfbxd4t.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010897
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut encrypted_string = String::new();\n    for\
    \ c in s.chars() {\n        let mut encrypted_char = c as u8;\n        encrypted_char\
    \ += 2;\n        encrypted_char *= 2;\n        encrypted_string.push(encrypted_char\
    \ as char);\n    }\n    encrypted_string\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\xD4\xD6\"`,\n right: `\"lm\"`', /tmp/tmpho7_ebuf.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010896
- exit_code: 0
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut encrypted = String::new();\n    for c in s.chars()\
    \ {\n        let mut new_char = c as u8 + 2 * 2;\n        if new_char > 122 {\n\
    \            new_char = new_char - 26;\n        }\n        encrypted.push(new_char\
    \ as char);\n    }\n    encrypted\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010897
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut encrypted_string = String::new();\n    for\
    \ c in s.chars() {\n        let encrypted_char = match c {\n            'a' =>\
    \ 'c',\n            'b' => 'd',\n            'c' => 'e',\n            'd' => 'f',\n\
    \            'e' => 'g',\n            'f' => 'h',\n            'g' => 'i',\n \
    \           'h' => 'j',\n            'i' => 'k',\n            'j' => 'l',\n  \
    \          'k' => 'm',\n            'l' => 'n',\n            'm' => 'o',\n   \
    \         'n' => 'p',\n            'o' => 'q',\n            'p' => 'r',\n    \
    \        'q' => 's',\n            'r' => 't',\n            's' => 'u',\n     \
    \       't' => 'v',\n            'u' => 'w',\n            'v' => 'x',\n      \
    \      'w' => 'y',\n            'x' => 'z',\n            'y' => 'a',\n       \
    \     'z' => 'b',\n            _ => c,\n        };\n        encrypted_string.push(encrypted_char);\n\
    \    }\n    encrypted_string\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmpkwn3l3i1.rs:53:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010897
- exit_code: 0
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c_num = c as u8;\n        c_num += 2 * 2;\n        if c_num\
    \ > 122 {\n            c_num -= 26;\n        }\n        result.push(c_num as char);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010896
- exit_code: 0
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c = c + 2 * 2;\n        if c > 122\
    \ {\n            c = c - 26;\n        }\n        result.push(c as char);\n   \
    \ }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010896
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 2 * 2;\n        result.push(c\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmp02cwroll.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010897
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut new_char = c as u8;\n        new_char += 2;\n        new_char\
    \ *= 2;\n        result.push(new_char as char);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\xD4\xD6\"`,\n right: `\"lm\"`', /tmp/tmpsf30u9yy.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010896
- exit_code: 0
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let c_num = c as u8;\n        if c_num >= 97 && c_num <= 122 {\n\
    \            let new_num = c_num + 4;\n            if new_num > 122 {\n      \
    \          let new_num = new_num - 26;\n                result.push(new_num as\
    \ char);\n            } else {\n                result.push(new_num as char);\n\
    \            }\n        } else {\n            result.push(c);\n        }\n   \
    \ }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010897
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 2 * 2;\n        result.push(c\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmp02cwroll.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010897
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 2 * 2;\n        result.push(c\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmp02cwroll.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010897
- exit_code: 0
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut new_char = c as u8 + 2 * 2;\n        if new_char > 122 {\n\
    \            new_char = new_char - 26;\n        }\n        result.push(new_char\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010896
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut encrypted = String::new();\n    for c in s.chars()\
    \ {\n        let mut new_char = c as u8 + 2;\n        if new_char > 122 {\n  \
    \          new_char = new_char - 26;\n        }\n        encrypted.push(new_char\
    \ as char);\n    }\n    encrypted\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmpdziloiye.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010896
- exit_code: 0
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c_num = c as u8;\n        c_num += 2 * 2;\n        if c_num\
    \ > 122 {\n            c_num -= 26;\n        }\n        result.push(c_num as char);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010896
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let c = match c {\n            'a' => 'c',\n            'b' => 'd',\n\
    \            'c' => 'e',\n            'd' => 'f',\n            'e' => 'g',\n \
    \           'f' => 'h',\n            'g' => 'i',\n            'h' => 'j',\n  \
    \          'i' => 'k',\n            'j' => 'l',\n            'k' => 'm',\n   \
    \         'l' => 'n',\n            'm' => 'o',\n            'n' => 'p',\n    \
    \        'o' => 'q',\n            'p' => 'r',\n            'q' => 's',\n     \
    \       'r' => 't',\n            's' => 'u',\n            't' => 'v',\n      \
    \      'u' => 'w',\n            'v' => 'x',\n            'w' => 'y',\n       \
    \     'x' => 'z',\n            'y' => 'a',\n            'z' => 'b',\n        \
    \    _ => c,\n        };\n        result.push(c);\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmp3olixez6.rs:53:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010897
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut new_char = c as u8;\n        new_char += 2;\n        new_char\
    \ *= 2;\n        result.push(new_char as char);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\xD4\xD6\"`,\n right: `\"lm\"`', /tmp/tmpsf30u9yy.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010896
- exit_code: 0
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut new_char = c as u8 + 2 * 2;\n        if new_char > 122 {\n\
    \            new_char = new_char - 26;\n        }\n        result.push(new_char\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010896
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 2;\n        if c > 122 {\n   \
    \         c -= 26;\n        }\n        result.push(c as char);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmpko1bkpq0.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010897
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        result.push(c.wrapping_add(2));\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `wrapping_add` found for type `char` in the\
    \ current scope\n  --> /tmp/tmp9j39_8ng.rs:17:23\n   |\n17 |         result.push(c.wrapping_add(2));\n\
    \   |                       ^^^^^^^^^^^^ method not found in `char`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010896
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        result.push(rotate_char(c, 2 * 2));\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `rotate_char` in this scope\n  --> /tmp/tmptggjk2n7.rs:17:21\n\
    \   |\n17 |         result.push(rotate_char(c, 2 * 2));\n   |                \
    \     ^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010896
- exit_code: 0
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut new_char = c as u8 + 2 * 2;\n        if new_char > 122 {\n\
    \            new_char = new_char - 26;\n        }\n        result.push(new_char\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010896
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut encrypted = String::new();\n    for c in s.chars()\
    \ {\n        let c = match c {\n            'a' => 'c',\n            'b' => 'd',\n\
    \            'c' => 'e',\n            'd' => 'f',\n            'e' => 'g',\n \
    \           'f' => 'h',\n            'g' => 'i',\n            'h' => 'j',\n  \
    \          'i' => 'k',\n            'j' => 'l',\n            'k' => 'm',\n   \
    \         'l' => 'n',\n            'm' => 'o',\n            'n' => 'p',\n    \
    \        'o' => 'q',\n            'p' => 'r',\n            'q' => 's',\n     \
    \       'r' => 't',\n            's' => 'u',\n            't' => 'v',\n      \
    \      'u' => 'w',\n            'v' => 'x',\n            'w' => 'y',\n       \
    \     'x' => 'z',\n            'y' => 'a',\n            'z' => 'b',\n        \
    \    _ => c,\n        };\n        encrypted.push(c);\n    }\n    encrypted\n}\n\
    \nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmp3873rf7_.rs:53:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010897
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        result.push(match c {\n            'a' => 'c',\n            'b' =>\
    \ 'd',\n            'c' => 'e',\n            'd' => 'f',\n            'e' => 'g',\n\
    \            'f' => 'h',\n            'g' => 'i',\n            'h' => 'j',\n \
    \           'i' => 'k',\n            'j' => 'l',\n            'k' => 'm',\n  \
    \          'l' => 'n',\n            'm' => 'o',\n            'n' => 'p',\n   \
    \         'o' => 'q',\n            'p' => 'r',\n            'q' => 's',\n    \
    \        'r' => 't',\n            's' => 'u',\n            't' => 'v',\n     \
    \       'u' => 'w',\n            'v' => 'x',\n            'w' => 'y',\n      \
    \      'x' => 'z',\n            'y' => 'a',\n            'z' => 'b',\n       \
    \     _ => c,\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmp_x43t3oi.rs:52:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010897
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let c = match c {\n            'a' => 'c',\n            'b' => 'd',\n\
    \            'c' => 'e',\n            'd' => 'f',\n            'e' => 'g',\n \
    \           'f' => 'h',\n            'g' => 'i',\n            'h' => 'j',\n  \
    \          'i' => 'k',\n            'j' => 'l',\n            'k' => 'm',\n   \
    \         'l' => 'n',\n            'm' => 'o',\n            'n' => 'p',\n    \
    \        'o' => 'q',\n            'p' => 'r',\n            'q' => 's',\n     \
    \       'r' => 't',\n            's' => 'u',\n            't' => 'v',\n      \
    \      'u' => 'w',\n            'v' => 'x',\n            'w' => 'y',\n       \
    \     'x' => 'z',\n            'y' => 'a',\n            'z' => 'b',\n        \
    \    _ => c,\n        };\n        result.push(c);\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmp3olixez6.rs:53:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010897
- exit_code: 0
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut new_char = c as u8 + 2 * 2;\n        if new_char > 122 {\n\
    \            new_char = new_char - 26;\n        }\n        result.push(new_char\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010896
- exit_code: 0
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 2 * 2;\n        if c > b'z' {\n\
    \            c -= 26;\n        }\n        result.push(c as char);\n    }\n   \
    \ result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010897
- exit_code: 0
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut encrypted_string = String::new();\n    for\
    \ c in s.chars() {\n        let mut encrypted_char = c as u8 + 2 * 2;\n      \
    \  if encrypted_char > 122 {\n            encrypted_char = encrypted_char - 26;\n\
    \        }\n        encrypted_string.push(encrypted_char as char);\n    }\n  \
    \  encrypted_string\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010897
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 2 * 2;\n        result.push(c\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmp02cwroll.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010897
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        result.push(c.wrapping_add(2));\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `wrapping_add` found for type `char` in the\
    \ current scope\n  --> /tmp/tmp9j39_8ng.rs:17:23\n   |\n17 |         result.push(c.wrapping_add(2));\n\
    \   |                       ^^^^^^^^^^^^ method not found in `char`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010896
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let new_char = match c {\n            'a' => 'c',\n            'b'\
    \ => 'd',\n            'c' => 'e',\n            'd' => 'f',\n            'e' =>\
    \ 'g',\n            'f' => 'h',\n            'g' => 'i',\n            'h' => 'j',\n\
    \            'i' => 'k',\n            'j' => 'l',\n            'k' => 'm',\n \
    \           'l' => 'n',\n            'm' => 'o',\n            'n' => 'p',\n  \
    \          'o' => 'q',\n            'p' => 'r',\n            'q' => 's',\n   \
    \         'r' => 't',\n            's' => 'u',\n            't' => 'v',\n    \
    \        'u' => 'w',\n            'v' => 'x',\n            'w' => 'y',\n     \
    \       'x' => 'z',\n            'y' => 'a',\n            'z' => 'b',\n      \
    \      _ => c,\n        };\n        result.push(new_char);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmpufkmm4p6.rs:53:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010897
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut encrypted = String::new();\n    for c in s.chars()\
    \ {\n        let mut new_char = c as u8;\n        new_char += 2;\n        new_char\
    \ *= 2;\n        encrypted.push(new_char as char);\n    }\n    encrypted\n}\n\n\
    fn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\xD4\xD6\"`,\n right: `\"lm\"`', /tmp/tmp0hdrdnla.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010897
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        result.push(rotate_char(c, 2 * 2));\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `rotate_char` in this scope\n  --> /tmp/tmptggjk2n7.rs:17:21\n\
    \   |\n17 |         result.push(rotate_char(c, 2 * 2));\n   |                \
    \     ^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010896
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        result.push(shift_char(c, 2));\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `shift_char` in this scope\n  --> /tmp/tmpuhyq5cec.rs:17:21\n\
    \   |\n17 |         result.push(shift_char(c, 2));\n   |                     ^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010896
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let c = match c {\n            'a' => 'c',\n            'b' => 'd',\n\
    \            'c' => 'e',\n            'd' => 'f',\n            'e' => 'g',\n \
    \           'f' => 'h',\n            'g' => 'i',\n            'h' => 'j',\n  \
    \          'i' => 'k',\n            'j' => 'l',\n            'k' => 'm',\n   \
    \         'l' => 'n',\n            'm' => 'o',\n            'n' => 'p',\n    \
    \        'o' => 'q',\n            'p' => 'r',\n            'q' => 's',\n     \
    \       'r' => 't',\n            's' => 'u',\n            't' => 'v',\n      \
    \      'u' => 'w',\n            'v' => 'x',\n            'w' => 'y',\n       \
    \     'x' => 'z',\n            'y' => 'a',\n            'z' => 'b',\n        \
    \    _ => c,\n        };\n        result.push(c);\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmp3olixez6.rs:53:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010897
- exit_code: 0
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut new_char = c as u8 + 2 * 2;\n        if new_char > 122 {\n\
    \            new_char = new_char - 26;\n        }\n        result.push(new_char\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010896
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 2 * 2;\n        result.push(c\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmp02cwroll.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010897
- exit_code: 0
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 2 * 2;\n        if c > 122 {\n\
    \            c -= 26;\n        }\n        result.push(c as char);\n    }\n   \
    \ result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010897
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        result.push(c.to_ascii_lowercase());\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hi\"`,\n right: `\"lm\"`', /tmp/tmpyqlzra9o.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010897
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c = c + 2 * 2;\n        result.push(c\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmput_bpx6x.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010897
- exit_code: 0
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 2 * 2;\n        if c > 'z' as\
    \ u8 {\n            c -= 26;\n        }\n        result.push(c as char);\n   \
    \ }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010897
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let c = c as u8;\n        let c = if c >= 97 && c <= 122 {\n    \
    \        ((c - 97 + 2) % 26) + 97\n        } else if c >= 65 && c <= 90 {\n  \
    \          ((c - 65 + 2) % 26) + 65\n        } else {\n            c\n       \
    \ };\n        result.push(c as char);\n    }\n    result\n}\n\nfn main() {\n \
    \   let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")),\
    \ String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmpbzzb72bc.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010897
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut new_char = c as u8;\n        new_char += 2;\n        if new_char\
    \ > 122 {\n            new_char -= 26;\n        }\n        result.push(new_char\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmp_bdykylg.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010897
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut new_char = c as u8;\n        new_char += 2;\n        new_char\
    \ *= 2;\n        result.push(new_char as char);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\xD4\xD6\"`,\n right: `\"lm\"`', /tmp/tmpsf30u9yy.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010896
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let c = c as u8;\n        let c = c + 2 * 2;\n        result.push(c\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpvrsm5lo8.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010897
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let c = c as u8;\n        let c = c + 2 * 2;\n        result.push(c\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpvrsm5lo8.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010897
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let c = match c {\n            'a' => 'c',\n            'b' => 'd',\n\
    \            'c' => 'e',\n            'd' => 'f',\n            'e' => 'g',\n \
    \           'f' => 'h',\n            'g' => 'i',\n            'h' => 'j',\n  \
    \          'i' => 'k',\n            'j' => 'l',\n            'k' => 'm',\n   \
    \         'l' => 'n',\n            'm' => 'o',\n            'n' => 'p',\n    \
    \        'o' => 'q',\n            'p' => 'r',\n            'q' => 's',\n     \
    \       'r' => 't',\n            's' => 'u',\n            't' => 'v',\n      \
    \      'u' => 'w',\n            'v' => 'x',\n            'w' => 'y',\n       \
    \     'x' => 'z',\n            'y' => 'a',\n            'z' => 'b',\n        \
    \    _ => c,\n        };\n        result.push(c);\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmp3olixez6.rs:53:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010897
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut i = c as u8;\n        i += 2 * 2;\n        result.push(i\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmp7xlzt953.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010897
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c = c + 2 * 2;\n        result.push(c\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmput_bpx6x.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010897
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let c_num = c as u8;\n        let c_num_new = c_num + (2 * 2);\n\
    \        let c_new = c_num_new as char;\n        result.push(c_new);\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmp5q22lav7.rs:31:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010897
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        result.push(rotate_char(c, 2));\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `rotate_char` in this scope\n  --> /tmp/tmpnes5icj4.rs:17:21\n\
    \   |\n17 |         result.push(rotate_char(c, 2));\n   |                    \
    \ ^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010897
- exit_code: 0
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 2 * 2;\n        if c > b'z' {\n\
    \            c -= 26;\n        }\n        result.push(c as char);\n    }\n   \
    \ result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010897
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c_int = c as u8;\n        c_int += 2 * 2;\n        result.push(c_int\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpohge3d7s.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010897
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let shifted = c as u8 + 2 * 2;\n        result.push(shifted as char);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpjinpjhl1.rs:29:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010897
- exit_code: 0
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c_num = c as u8;\n        c_num += 2 * 2;\n        if c_num\
    \ > 122 {\n            c_num -= 26;\n        }\n        result.push(c_num as char);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010896
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut encrypted_string = String::new();\n    for\
    \ c in s.chars() {\n        let mut encrypted_char = c as u8;\n        if encrypted_char\
    \ >= 97 && encrypted_char <= 122 {\n            encrypted_char += 2;\n       \
    \     if encrypted_char > 122 {\n                encrypted_char -= 26;\n     \
    \       }\n        }\n        encrypted_string.push(encrypted_char as char);\n\
    \    }\n    encrypted_string\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmpj_dkwpyd.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010897
- exit_code: 0
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut new_c = c as u8 + 2 * 2;\n        if new_c > 122 {\n    \
    \        new_c = new_c - 26;\n        }\n        result.push(new_c as char);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010897
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut new_string = String::new();\n    for c in s.chars()\
    \ {\n        let mut new_char = c as u8;\n        new_char += 2;\n        new_char\
    \ *= 2;\n        new_string.push(new_char as char);\n    }\n    new_string\n}\n\
    \nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\xD4\xD6\"`,\n right: `\"lm\"`', /tmp/tmpm7erxw2e.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010897
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 2 * 2;\n        result.push(c\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmp02cwroll.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010897
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        result.push(rotate_char(c, 2));\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `rotate_char` in this scope\n  --> /tmp/tmpnes5icj4.rs:17:21\n\
    \   |\n17 |         result.push(rotate_char(c, 2));\n   |                    \
    \ ^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010897
- exit_code: 0
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 2 * 2;\n        if c > 122 {\n\
    \            c -= 26;\n        }\n        result.push(c as char);\n    }\n   \
    \ result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010897
- exit_code: 0
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut new_char = c as u8 + 2 * 2;\n        if new_char > 'z' as\
    \ u8 {\n            new_char = new_char - 26;\n        }\n        result.push(new_char\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010897
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut encrypted = String::new();\n    for c in s.chars()\
    \ {\n        encrypted.push(rotate_char(c, 2*2));\n    }\n    encrypted\n}\n\n\
    fn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `rotate_char` in this scope\n  --> /tmp/tmp2tqez2nr.rs:17:24\n\
    \   |\n17 |         encrypted.push(rotate_char(c, 2*2));\n   |               \
    \         ^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010897
- exit_code: 0
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut new_char = c as u8 + 2 * 2;\n        if new_char > 122 {\n\
    \            new_char = new_char - 26;\n        }\n        result.push(new_char\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010896
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let c = match c {\n            'a' => 'c',\n            'b' => 'd',\n\
    \            'c' => 'e',\n            'd' => 'f',\n            'e' => 'g',\n \
    \           'f' => 'h',\n            'g' => 'i',\n            'h' => 'j',\n  \
    \          'i' => 'k',\n            'j' => 'l',\n            'k' => 'm',\n   \
    \         'l' => 'n',\n            'm' => 'o',\n            'n' => 'p',\n    \
    \        'o' => 'q',\n            'p' => 'r',\n            'q' => 's',\n     \
    \       'r' => 't',\n            's' => 'u',\n            't' => 'v',\n      \
    \      'u' => 'w',\n            'v' => 'x',\n            'w' => 'y',\n       \
    \     'x' => 'z',\n            'y' => 'a',\n            'z' => 'b',\n        \
    \    _ => c,\n        };\n        result.push(c);\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmp3olixez6.rs:53:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010897
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 2 * 2;\n        result.push(c\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmp02cwroll.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010897
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut new_string = String::new();\n    for c in s.chars()\
    \ {\n        new_string.push(rotate_char(c, 2));\n    }\n    new_string\n}\n\n\
    fn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `rotate_char` in this scope\n  --> /tmp/tmpllhf_44a.rs:17:25\n\
    \   |\n17 |         new_string.push(rotate_char(c, 2));\n   |                \
    \         ^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010897
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let c = match c {\n            'a' => 'c',\n            'b' => 'd',\n\
    \            'c' => 'e',\n            'd' => 'f',\n            'e' => 'g',\n \
    \           'f' => 'h',\n            'g' => 'i',\n            'h' => 'j',\n  \
    \          'i' => 'k',\n            'j' => 'l',\n            'k' => 'm',\n   \
    \         'l' => 'n',\n            'm' => 'o',\n            'n' => 'p',\n    \
    \        'o' => 'q',\n            'p' => 'r',\n            'q' => 's',\n     \
    \       'r' => 't',\n            's' => 'u',\n            't' => 'v',\n      \
    \      'u' => 'w',\n            'v' => 'x',\n            'w' => 'y',\n       \
    \     'x' => 'z',\n            'y' => 'a',\n            'z' => 'b',\n        \
    \    _ => c,\n        };\n        result.push(c);\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmp3olixez6.rs:53:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010897
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut new_c = c as u8;\n        new_c += 2;\n        if new_c >\
    \ 'z' as u8 {\n            new_c -= 26;\n        }\n        result.push(new_c\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmp9gfbxd4t.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010897
- exit_code: 0
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut new_char = c as u8 + 2 * 2;\n        if new_char > 'z' as\
    \ u8 {\n            new_char = new_char - 26;\n        }\n        result.push(new_char\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010897
- exit_code: 0
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 2 * 2;\n        if c > 'z' as\
    \ u8 {\n            c -= 26;\n        }\n        result.push(c as char);\n   \
    \ }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010897
- exit_code: 0
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut encrypted = String::new();\n    for c in s.chars()\
    \ {\n        let mut new_char = c as u8 + 2 * 2;\n        if new_char > 122 {\n\
    \            new_char = new_char - 26;\n        }\n        encrypted.push(new_char\
    \ as char);\n    }\n    encrypted\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010897
- exit_code: 0
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c = c + 4;\n        if c > 122 {\n\
    \            c = c - 26;\n        }\n        result.push(c as char);\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010897
- exit_code: 0
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut new_char = c as u8 + 2 * 2;\n        if new_char > 122 {\n\
    \            new_char = new_char - 26;\n        }\n        result.push(new_char\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010896
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let c = c as u8;\n        let new_c = if c >= 97 && c <= 122 {\n\
    \            (c + 2 * 2) as char\n        } else {\n            c as char\n  \
    \      };\n        result.push(new_c);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")),\
    \ String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpfk6vf7xp.rs:34:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010897
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c = c + 2 * 2;\n        result.push(c\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmput_bpx6x.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010897
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let c = c as u8;\n        let c = if c >= 97 && c <= 122 {\n    \
    \        (c + 4) % 122\n        } else if c >= 65 && c <= 90 {\n            (c\
    \ + 4) % 90\n        } else {\n            c\n        };\n        result.push(c\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei\\u{1}je\\u{1}ijei\\u{1}k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpxjju2bbt.rs:36:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010897
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let new_char = match c {\n            'a' => 'c',\n            'b'\
    \ => 'd',\n            'c' => 'e',\n            'd' => 'f',\n            'e' =>\
    \ 'g',\n            'f' => 'h',\n            'g' => 'i',\n            'h' => 'j',\n\
    \            'i' => 'k',\n            'j' => 'l',\n            'k' => 'm',\n \
    \           'l' => 'n',\n            'm' => 'o',\n            'n' => 'p',\n  \
    \          'o' => 'q',\n            'p' => 'r',\n            'q' => 's',\n   \
    \         'r' => 't',\n            's' => 'u',\n            't' => 'v',\n    \
    \        'u' => 'w',\n            'v' => 'x',\n            'w' => 'y',\n     \
    \       'x' => 'z',\n            'y' => 'a',\n            'z' => 'b',\n      \
    \      _ => c,\n        };\n        result.push(new_char);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmpufkmm4p6.rs:53:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010897
- exit_code: 0
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut new_char = c as u8;\n        new_char += 2 * 2;\n       \
    \ if new_char > 122 {\n            new_char -= 26;\n        }\n        result.push(new_char\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010897
- exit_code: 0
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c = c + 2 * 2;\n        if c > 122\
    \ {\n            c = 96 + (c - 122);\n        }\n        result.push(c as char);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010897
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut x = c as u8;\n        x += 2;\n        x *= 2;\n        result.push(x\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\xD4\xD6\"`,\n right: `\"lm\"`', /tmp/tmpszg5voou.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010897
- exit_code: 0
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 2 * 2;\n        if c > 122 {\n\
    \            c -= 26;\n        }\n        result.push(c as char);\n    }\n   \
    \ result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010897
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let c = c as u8;\n        let c = c + 2 * 2;\n        result.push(c\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpvrsm5lo8.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010897
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c = c + 2 * 2;\n        result.push(c\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmput_bpx6x.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010897
- exit_code: 0
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut new_char = c as u8 + 2 * 2;\n        if new_char > 122 {\n\
    \            new_char = new_char - 26;\n        }\n        result.push(new_char\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010896
- exit_code: 0
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c_int = c as u8;\n        c_int += 2 * 2;\n        if c_int\
    \ > 'z' as u8 {\n            c_int -= 26;\n        }\n        result.push(c_int\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010897
- exit_code: 0
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut new_char = c as u8 + 2 * 2;\n        if new_char > 122 {\n\
    \            new_char = new_char - 26;\n        }\n        result.push(new_char\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010896
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        result.push(match c {\n            'a' => 'c',\n            'b' =>\
    \ 'd',\n            'c' => 'e',\n            'd' => 'f',\n            'e' => 'g',\n\
    \            'f' => 'h',\n            'g' => 'i',\n            'h' => 'j',\n \
    \           'i' => 'k',\n            'j' => 'l',\n            'k' => 'm',\n  \
    \          'l' => 'n',\n            'm' => 'o',\n            'n' => 'p',\n   \
    \         'o' => 'q',\n            'p' => 'r',\n            'q' => 's',\n    \
    \        'r' => 't',\n            's' => 'u',\n            't' => 'v',\n     \
    \       'u' => 'w',\n            'v' => 'x',\n            'w' => 'y',\n      \
    \      'x' => 'z',\n            'y' => 'a',\n            'z' => 'b',\n       \
    \     _ => c,\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmp_x43t3oi.rs:52:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010897
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let x = c as u8;\n        let y = x + 2 * 2;\n        result.push(y\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpimjwlodj.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010897
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 2 * 2;\n        result.push(c\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmp02cwroll.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010897
- exit_code: 0
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut new_char = c as u8 + 2 * 2;\n        if new_char > 122 {\n\
    \            new_char = new_char - 26;\n        }\n        result.push(new_char\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010896
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut new_char = c as u8;\n        if new_char >= 97 && new_char\
    \ <= 122 {\n            new_char += 2;\n            if new_char > 122 {\n    \
    \            new_char -= 26;\n            }\n        }\n        result.push(new_char\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmps97eha8z.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010897
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 2 * 2;\n        result.push(c\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmp02cwroll.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010897
- exit_code: 0
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 2 * 2;\n        if c > b'z' {\n\
    \            c -= 26;\n        }\n        result.push(c as char);\n    }\n   \
    \ result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010897
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 2 * 2;\n        result.push(c\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmp02cwroll.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010897
- exit_code: 0
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut new_char = c as u8 + 2 * 2;\n        if new_char > 122 {\n\
    \            new_char = new_char - 26;\n        }\n        result.push(new_char\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010896
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 2 * 2;\n        result.push(c\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmp02cwroll.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010897
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 2;\n        if c > 122 {\n   \
    \         c -= 26;\n        }\n        result.push(c as char);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmpko1bkpq0.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010897
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut new_char = c as u8;\n        new_char += 2;\n        new_char\
    \ *= 2;\n        result.push(new_char as char);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\xD4\xD6\"`,\n right: `\"lm\"`', /tmp/tmpsf30u9yy.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010896
- exit_code: 0
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut new_char = c as u8 + 2 * 2;\n        if new_char > 122 {\n\
    \            new_char = new_char - 26;\n        }\n        result.push(new_char\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010896
- exit_code: 0
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut s = s.chars().collect::<Vec<char>>();\n   \
    \ for i in 0..s.len() {\n        let c = s[i];\n        let mut d = c as u8;\n\
    \        d += 2 * 2;\n        if d > 'z' as u8 {\n            d -= 26;\n     \
    \   }\n        s[i] = d as char;\n    }\n    s.into_iter().collect()\n}\n\nfn\
    \ main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010897
- exit_code: 0
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut new_char = c as u8 + 2 * 2;\n        if new_char > 122 {\n\
    \            new_char = new_char - 26;\n        }\n        result.push(new_char\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010896
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 2 * 2;\n        result.push(c\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmp02cwroll.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010897
- exit_code: 0
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c = c + 2 * 2;\n        if c > 122\
    \ {\n            c = 96 + (c - 122);\n        }\n        result.push(c as char);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010897
- exit_code: 0
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut new_char = c as u8 + 2 * 2;\n        if new_char > 122 {\n\
    \            new_char = new_char - 26;\n        }\n        result.push(new_char\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010896
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let c = match c {\n            'a' => 'c',\n            'b' => 'd',\n\
    \            'c' => 'e',\n            'd' => 'f',\n            'e' => 'g',\n \
    \           'f' => 'h',\n            'g' => 'i',\n            'h' => 'j',\n  \
    \          'i' => 'k',\n            'j' => 'l',\n            'k' => 'm',\n   \
    \         'l' => 'n',\n            'm' => 'o',\n            'n' => 'p',\n    \
    \        'o' => 'q',\n            'p' => 'r',\n            'q' => 's',\n     \
    \       'r' => 't',\n            's' => 'u',\n            't' => 'v',\n      \
    \      'u' => 'w',\n            'v' => 'x',\n            'w' => 'y',\n       \
    \     'x' => 'z',\n            'y' => 'a',\n            'z' => 'b',\n        \
    \    _ => c,\n        };\n        result.push(c);\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmp3olixez6.rs:53:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010897
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 2 * 2;\n        result.push(c\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmp02cwroll.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010897
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut encrypted = String::new();\n    for c in s.chars()\
    \ {\n        let mut new_char = c as u8;\n        if new_char >= 97 && new_char\
    \ <= 122 {\n            new_char += 2;\n            if new_char > 122 {\n    \
    \            new_char -= 26;\n            }\n        }\n        encrypted.push(new_char\
    \ as char);\n    }\n    encrypted\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmpxs25isih.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010897
- exit_code: 0
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut new_char = c as u8 + 4;\n        if new_char > 122 {\n  \
    \          new_char = new_char - 26;\n        }\n        result.push(new_char\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010897
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 2;\n        c *= 2;\n        result.push(c\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\xD4\xD6\"`,\n right: `\"lm\"`', /tmp/tmpxgld_w8g.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010897
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut new_char = c as u8;\n        new_char += 2;\n        new_char\
    \ *= 2;\n        result.push(new_char as char);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\xD4\xD6\"`,\n right: `\"lm\"`', /tmp/tmpsf30u9yy.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010896
- exit_code: 0
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut new_char = c as u8 + 2 * 2;\n        if new_char > 122 {\n\
    \            new_char = new_char - 26;\n        }\n        result.push(new_char\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010896
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 2 * 2;\n        result.push(c\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmp02cwroll.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010897
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 2 * 2;\n        result.push(c\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmp02cwroll.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010897
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c = c + 2 * 2;\n        result.push(c\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmput_bpx6x.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010897
- exit_code: 0
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut encrypted_string = String::new();\n    for\
    \ c in s.chars() {\n        let mut new_char = c as u8;\n        new_char += 2\
    \ * 2;\n        if new_char > 122 {\n            new_char -= 26;\n        }\n\
    \        encrypted_string.push(new_char as char);\n    }\n    encrypted_string\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010897
- exit_code: 0
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 2 * 2;\n        if c > 122 {\n\
    \            c -= 26;\n        }\n        result.push(c as char);\n    }\n   \
    \ result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010897
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let c = match c {\n            'a' => 'c',\n            'b' => 'd',\n\
    \            'c' => 'e',\n            'd' => 'f',\n            'e' => 'g',\n \
    \           'f' => 'h',\n            'g' => 'i',\n            'h' => 'j',\n  \
    \          'i' => 'k',\n            'j' => 'l',\n            'k' => 'm',\n   \
    \         'l' => 'n',\n            'm' => 'o',\n            'n' => 'p',\n    \
    \        'o' => 'q',\n            'p' => 'r',\n            'q' => 's',\n     \
    \       'r' => 't',\n            's' => 'u',\n            't' => 'v',\n      \
    \      'u' => 'w',\n            'v' => 'x',\n            'w' => 'y',\n       \
    \     'x' => 'z',\n            'y' => 'a',\n            'z' => 'b',\n        \
    \    _ => c,\n        };\n        result.push(c);\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmp3olixez6.rs:53:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010897
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 2 * 2;\n        result.push(c\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmp02cwroll.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010897
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        result.push(rotate_char(c, 2 * 2));\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `rotate_char` in this scope\n  --> /tmp/tmptggjk2n7.rs:17:21\n\
    \   |\n17 |         result.push(rotate_char(c, 2 * 2));\n   |                \
    \     ^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010896
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c = c + 2 * 2;\n        result.push(c\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmput_bpx6x.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010897
- exit_code: 0
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut encrypted = String::new();\n    for c in s.chars()\
    \ {\n        let mut new_char = c as u8 + 2 * 2;\n        if new_char > 122 {\n\
    \            new_char = new_char - 26;\n        }\n        encrypted.push(new_char\
    \ as char);\n    }\n    encrypted\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010897
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let c = c as u8;\n        let c = c + 2 * 2;\n        result.push(c\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpvrsm5lo8.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010897
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut new_c = c as u8;\n        new_c += 2 * 2;\n        result.push(new_c\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpak2q2ewe.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010897
- exit_code: 0
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 2 * 2;\n        if c > b'z' {\n\
    \            c -= 26;\n        }\n        result.push(c as char);\n    }\n   \
    \ result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010897
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        result.push(match c {\n            'a' => 'c',\n            'b' =>\
    \ 'd',\n            'c' => 'e',\n            'd' => 'f',\n            'e' => 'g',\n\
    \            'f' => 'h',\n            'g' => 'i',\n            'h' => 'j',\n \
    \           'i' => 'k',\n            'j' => 'l',\n            'k' => 'm',\n  \
    \          'l' => 'n',\n            'm' => 'o',\n            'n' => 'p',\n   \
    \         'o' => 'q',\n            'p' => 'r',\n            'q' => 's',\n    \
    \        'r' => 't',\n            's' => 'u',\n            't' => 'v',\n     \
    \       'u' => 'w',\n            'v' => 'x',\n            'w' => 'y',\n      \
    \      'x' => 'z',\n            'y' => 'a',\n            'z' => 'b',\n       \
    \     _ => c,\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmp_x43t3oi.rs:52:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010897
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 2 * 2;\n        result.push(c\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmp02cwroll.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010897
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 2 * 2;\n        result.push(c\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmp02cwroll.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010897
- exit_code: 0
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut new_char = c as u8;\n        new_char += 2 * 2;\n       \
    \ if new_char > 122 {\n            new_char -= 26;\n        }\n        result.push(new_char\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010897
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        result.push(rotate_char(c, 2 * 2));\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `rotate_char` in this scope\n  --> /tmp/tmptggjk2n7.rs:17:21\n\
    \   |\n17 |         result.push(rotate_char(c, 2 * 2));\n   |                \
    \     ^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010896
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        result.push(c.to_ascii_lowercase());\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hi\"`,\n right: `\"lm\"`', /tmp/tmpyqlzra9o.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010897
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut new_char = c as u8 + 2;\n        if new_char > 122 {\n  \
    \          new_char = new_char - 26;\n        }\n        result.push(new_char\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmp19v3q_yy.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010897
- exit_code: 0
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c = c + 2 * 2;\n        if c > 122\
    \ {\n            c = c - 26;\n        }\n        result.push(c as char);\n   \
    \ }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010896
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut new_char = c as u8;\n        if new_char >= 97 && new_char\
    \ <= 122 {\n            new_char += 2;\n            if new_char > 122 {\n    \
    \            new_char -= 26;\n            }\n        }\n        result.push(new_char\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmps97eha8z.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010897
- exit_code: 0
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut encrypted = String::new();\n    for c in s.chars()\
    \ {\n        let mut new_char = c as u8 + 2 * 2;\n        if new_char > 122 {\n\
    \            new_char = new_char - 26;\n        }\n        encrypted.push(new_char\
    \ as char);\n    }\n    encrypted\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010897
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut new_char = c as u8;\n        new_char += 2;\n        if new_char\
    \ > 122 {\n            new_char -= 26;\n        }\n        result.push(new_char\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmp_bdykylg.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010897
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut x = c as u8;\n        x = x + 2 * 2;\n        result.push(x\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmp919g5nj5.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010897
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut encrypted = String::new();\n    for c in s.chars()\
    \ {\n        let mut new_char = c as u8;\n        if new_char >= 97 && new_char\
    \ <= 122 {\n            new_char += 2;\n            if new_char > 122 {\n    \
    \            new_char -= 26;\n            }\n        }\n        encrypted.push(new_char\
    \ as char);\n    }\n    encrypted\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmpxs25isih.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010897
- exit_code: 0
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut new_char = c as u8 + 2 * 2;\n        if new_char > 122 {\n\
    \            new_char = new_char - 26;\n        }\n        result.push(new_char\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010896
- exit_code: 0
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    s.chars().map(|c| {\n        let mut c = c as u8;\n\
    \        c = c + 2 * 2;\n        if c > 122 {\n            c = c - 26;\n     \
    \   }\n        c as char\n    }).collect()\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010897
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        result.push(match c {\n            'a' => 'c',\n            'b' =>\
    \ 'd',\n            'c' => 'e',\n            'd' => 'f',\n            'e' => 'g',\n\
    \            'f' => 'h',\n            'g' => 'i',\n            'h' => 'j',\n \
    \           'i' => 'k',\n            'j' => 'l',\n            'k' => 'm',\n  \
    \          'l' => 'n',\n            'm' => 'o',\n            'n' => 'p',\n   \
    \         'o' => 'q',\n            'p' => 'r',\n            'q' => 's',\n    \
    \        'r' => 't',\n            's' => 'u',\n            't' => 'v',\n     \
    \       'u' => 'w',\n            'v' => 'x',\n            'w' => 'y',\n      \
    \      'x' => 'z',\n            'y' => 'a',\n            'z' => 'b',\n       \
    \     _ => c,\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmp_x43t3oi.rs:52:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010897
- exit_code: 0
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut new_char = c as u8;\n        new_char += 2 * 2;\n       \
    \ if new_char > 122 {\n            new_char -= 26;\n        }\n        result.push(new_char\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010897
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut i = c as u8;\n        i += 2 * 2;\n        result.push(i\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmp7xlzt953.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010897
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        result.push(rotate_char(c, 2));\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `rotate_char` in this scope\n  --> /tmp/tmpnes5icj4.rs:17:21\n\
    \   |\n17 |         result.push(rotate_char(c, 2));\n   |                    \
    \ ^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010897
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 2;\n        if c > 122 {\n   \
    \         c -= 26;\n        }\n        result.push(c as char);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmpko1bkpq0.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010897
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 2 * 2;\n        result.push(c\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmp02cwroll.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010897
- exit_code: 0
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut new_char = c as u8;\n        new_char += 4;\n        if new_char\
    \ > 122 {\n            new_char -= 26;\n        }\n        result.push(new_char\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010897
- exit_code: 0
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c_num = c as u8;\n        c_num += 2 * 2;\n        if c_num\
    \ > 122 {\n            c_num -= 26;\n        }\n        result.push(c_num as char);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010896
- exit_code: 0
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut new_char = c as u8 + 2 * 2;\n        if new_char > 122 {\n\
    \            new_char = new_char - 26;\n        }\n        result.push(new_char\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010896
- exit_code: 0
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut new_char = c as u8 + 2 * 2;\n        if new_char > 122 {\n\
    \            new_char = new_char - 26;\n        }\n        result.push(new_char\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010896
- exit_code: 0
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 4;\n        if c > 122 {\n   \
    \         c -= 26;\n        }\n        result.push(c as char);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010897
- exit_code: 0
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 2 * 2;\n        if c > 122 {\n\
    \            c -= 26;\n        }\n        result.push(c as char);\n    }\n   \
    \ result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010897
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut encrypted = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c = c + 2 * 2;\n        encrypted.push(c\
    \ as char);\n    }\n    encrypted\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpb25n5yen.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010897
- exit_code: 0
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut encrypted = String::new();\n    for c in s.chars()\
    \ {\n        let mut new_char = c as u8 + 2 * 2;\n        if new_char > 122 {\n\
    \            new_char = new_char - 26;\n        }\n        encrypted.push(new_char\
    \ as char);\n    }\n    encrypted\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010897
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        result.push(rotate_char(c, 2 * 2));\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `rotate_char` in this scope\n  --> /tmp/tmptggjk2n7.rs:17:21\n\
    \   |\n17 |         result.push(rotate_char(c, 2 * 2));\n   |                \
    \     ^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010896
- exit_code: 0
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut new_char = c as u8 + 4;\n        if new_char > 122 {\n  \
    \          new_char = new_char - 26;\n        }\n        result.push(new_char\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010897
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let c = c as u8;\n        let c = c + 2 * 2;\n        result.push(c\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpvrsm5lo8.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010897
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 2 * 2;\n        result.push(c\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmp02cwroll.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010897
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 2 * 2;\n        result.push(c\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmp02cwroll.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010897
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut encrypted = String::new();\n    for c in s.chars()\
    \ {\n        encrypted.push(c.wrapping_add(2));\n    }\n    encrypted\n}\n\nfn\
    \ main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `wrapping_add` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpq0358pmg.rs:17:26\n   |\n17 |         encrypted.push(c.wrapping_add(2));\n\
    \   |                          ^^^^^^^^^^^^ method not found in `char`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010897
- exit_code: 0
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c = c + 2 * 2;\n        if c > 122\
    \ {\n            c = c - 26;\n        }\n        result.push(c as char);\n   \
    \ }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010896
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        result.push(rotate_char(c, 2));\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `rotate_char` in this scope\n  --> /tmp/tmpnes5icj4.rs:17:21\n\
    \   |\n17 |         result.push(rotate_char(c, 2));\n   |                    \
    \ ^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010897
- exit_code: 0
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut x = c as u8;\n        x = x + 4;\n        if x > 122 {\n\
    \            x = x - 26;\n        }\n        result.push(x as char);\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010897
- exit_code: 0
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut new_char = c as u8 + 4;\n        if new_char > 122 {\n  \
    \          new_char = new_char - 26;\n        }\n        result.push(new_char\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010897
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let c = c as u8;\n        let c = if c >= 97 && c <= 122 {\n    \
    \        (c + 4) % 122\n        } else if c >= 65 && c <= 90 {\n            (c\
    \ + 4) % 90\n        } else {\n            c\n        };\n        result.push(c\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei\\u{1}je\\u{1}ijei\\u{1}k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpxjju2bbt.rs:36:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010897
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 2 * 2;\n        result.push(c\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmp02cwroll.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010897
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 2 * 2;\n        result.push(c\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmp02cwroll.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010897
- exit_code: 0
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut x = c as u8;\n        x += 2 * 2;\n        if x > 122 {\n\
    \            x -= 26;\n        }\n        result.push(x as char);\n    }\n   \
    \ result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010897
- exit_code: 0
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c = c + 2 * 2;\n        if c > 122\
    \ {\n            c = c - 26;\n        }\n        result.push(c as char);\n   \
    \ }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010896
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 2 * 2;\n        result.push(c\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmp02cwroll.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010897
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 2;\n        c *= 2;\n        result.push(c\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\xD4\xD6\"`,\n right: `\"lm\"`', /tmp/tmpxgld_w8g.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010897
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let c_num = c as u8;\n        let c_num_new = c_num + (2 * 2);\n\
    \        let c_new = c_num_new as char;\n        result.push(c_new);\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmp5q22lav7.rs:31:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010897
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 2 * 2;\n        result.push(c\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmp02cwroll.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010897
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        result.push(rotate_char(c, 2));\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `rotate_char` in this scope\n  --> /tmp/tmpnes5icj4.rs:17:21\n\
    \   |\n17 |         result.push(rotate_char(c, 2));\n   |                    \
    \ ^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010897
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let c = c as u8;\n        let c = match c {\n            b'a'...b'y'\
    \ => c + 2,\n            b'z' => b'a',\n            b'A'...b'Y' => c + 2,\n  \
    \          b'Z' => b'A',\n            _ => c,\n        };\n        result.push(c\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmpzl35bawu.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010897
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut new_char = c as u8;\n        new_char += 2;\n        if new_char\
    \ > 122 {\n            new_char -= 26;\n        }\n        result.push(new_char\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmp_bdykylg.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010897
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut res = String::new();\n    for c in s.chars()\
    \ {\n        let c = match c {\n            'a' => 'c',\n            'b' => 'd',\n\
    \            'c' => 'e',\n            'd' => 'f',\n            'e' => 'g',\n \
    \           'f' => 'h',\n            'g' => 'i',\n            'h' => 'j',\n  \
    \          'i' => 'k',\n            'j' => 'l',\n            'k' => 'm',\n   \
    \         'l' => 'n',\n            'm' => 'o',\n            'n' => 'p',\n    \
    \        'o' => 'q',\n            'p' => 'r',\n            'q' => 's',\n     \
    \       'r' => 't',\n            's' => 'u',\n            't' => 'v',\n      \
    \      'u' => 'w',\n            'v' => 'x',\n            'w' => 'y',\n       \
    \     'x' => 'z',\n            'y' => 'a',\n            'z' => 'b',\n        \
    \    _ => c,\n        };\n        res.push(c);\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmpcjx_kc7s.rs:53:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010897
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        result.push(rotate_char(c, 2));\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `rotate_char` in this scope\n  --> /tmp/tmpnes5icj4.rs:17:21\n\
    \   |\n17 |         result.push(rotate_char(c, 2));\n   |                    \
    \ ^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010897
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut encrypted_string = String::new();\n    for\
    \ c in s.chars() {\n        let mut encrypted_char = c as u8;\n        encrypted_char\
    \ += 2;\n        encrypted_char *= 2;\n        encrypted_string.push(encrypted_char\
    \ as char);\n    }\n    encrypted_string\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\xD4\xD6\"`,\n right: `\"lm\"`', /tmp/tmpho7_ebuf.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010896
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut i = c as u8;\n        i += 2;\n        i *= 2;\n        result.push(i\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\xD4\xD6\"`,\n right: `\"lm\"`', /tmp/tmpw1td5xa2.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010897
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c = c + 2 * 2;\n        result.push(c\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmput_bpx6x.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010897
- exit_code: 0
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c = c + 2 * 2;\n        if c > 'z'\
    \ as u8 {\n            c = c - 26;\n        }\n        result.push(c as char);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010897
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 2 * 2;\n        result.push(c\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmp02cwroll.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010897
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 2 * 2;\n        result.push(c\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmp02cwroll.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010897
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 2 * 2;\n        result.push(c\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmp02cwroll.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010897
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 2 * 2;\n        result.push(c\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmp02cwroll.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010897
- exit_code: 0
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 2 * 2;\n        if c > 'z' as\
    \ u8 {\n            c -= 26;\n        }\n        result.push(c as char);\n   \
    \ }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010897
- exit_code: 0
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut new_char = c as u8 + 2 * 2;\n        if new_char > 122 {\n\
    \            new_char = new_char - 26;\n        }\n        result.push(new_char\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010896
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let c_num = c as u8;\n        let c_num_encrypted = c_num + 4;\n\
    \        let c_encrypted = c_num_encrypted as char;\n        result.push(c_encrypted);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpz4rz1_ce.rs:31:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010897
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 2 * 2;\n        result.push(c\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmp02cwroll.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010897
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        result.push(rotate(c, 2 * 2));\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `rotate` in this scope\n  --> /tmp/tmpj5tlg5be.rs:17:21\n\
    \   |\n17 |         result.push(rotate(c, 2 * 2));\n   |                     ^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010897
- exit_code: 0
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c = c + 2 * 2;\n        if c > 122\
    \ {\n            c = c - 26;\n        }\n        result.push(c as char);\n   \
    \ }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010896
- exit_code: 0
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c = c + 2 * 2;\n        if c > 122\
    \ {\n            c = c - 26;\n        }\n        result.push(c as char);\n   \
    \ }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010896
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c += 2 * 2;\n        result.push(c\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmp02cwroll.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010897
- exit_code: 0
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        let mut c = c as u8;\n        c = c + 2 * 2;\n        if c > 122\
    \ {\n            c = c - 26;\n        }\n        result.push(c as char);\n   \
    \ }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010896
