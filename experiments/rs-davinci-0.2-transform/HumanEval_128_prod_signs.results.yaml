language: rs
name: HumanEval_128_prod_signs
results:
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 101
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    unimplemented!()\n}\n\n\
    fn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpzi6t2343.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for num in arr {\n        if num > 0 {\n            prod *= 1;\n        } else\
    \ if num < 0 {\n            prod *= -1;\n        } else {\n            prod *=\
    \ 0;\n        }\n        sum += num.abs();\n    }\n    Some(sum * prod)\n}\n\n\
    fn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 1
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    let mut prod = 1;\n   \
    \ let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n            prod *=\
    \ 1;\n            sum += i;\n        } else if i < 0 {\n            prod *= -1;\n\
    \            sum += i.abs();\n        } else {\n            prod *= 0;\n     \
    \   }\n    }\n    if arr.len() == 0 {\n        None\n    } else {\n        Some(sum\
    \ * prod)\n    }\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `arr`\n   --> /tmp/tmpydc7k1n2.rs:26:8\n\
    \    |\n12  | fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    |       \
    \        --- move occurs because `arr` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n15  |     for i in arr {\n    |              --- `arr`\
    \ moved due to this implicit call to `.into_iter()`\n...\n26  |     if arr.len()\
    \ == 0 {\n    |        ^^^^^^^^^ value borrowed here after move\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `arr`\nhelp:\
    \ consider iterating over a slice of the `Vec<isize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n15  |     for i in &arr {\n    |              +\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660008726
- exit_code: 101
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i < 0 {\n            prod *= -1;\n        } else\
    \ if i > 0 {\n            sum += i;\n        }\n    }\n    Some(sum * prod)\n\
    }\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-5)`,\n right: `Some(-9)`', /tmp/tmpqdp1kgpl.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 101
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i < 0 {\n            prod *= -1;\n        } else\
    \ if i > 0 {\n            sum += i;\n        }\n    }\n    Some(sum * prod)\n\
    }\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-5)`,\n right: `Some(-9)`', /tmp/tmpqdp1kgpl.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 1
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    let mut prod = 1;\n   \
    \ let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n            prod *=\
    \ 1;\n            sum += i;\n        } else if i < 0 {\n            prod *= -1;\n\
    \            sum += i.abs();\n        } else {\n            prod *= 0;\n     \
    \   }\n    }\n    if arr.len() == 0 {\n        None\n    } else {\n        Some(sum\
    \ * prod)\n    }\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `arr`\n   --> /tmp/tmpydc7k1n2.rs:26:8\n\
    \    |\n12  | fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    |       \
    \        --- move occurs because `arr` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n15  |     for i in arr {\n    |              --- `arr`\
    \ moved due to this implicit call to `.into_iter()`\n...\n26  |     if arr.len()\
    \ == 0 {\n    |        ^^^^^^^^^ value borrowed here after move\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `arr`\nhelp:\
    \ consider iterating over a slice of the `Vec<isize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n15  |     for i in &arr {\n    |              +\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660008726
- exit_code: 101
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    unimplemented!()\n}\n\n\
    fn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpzi6t2343.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 1
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    let mut prod = 1;\n   \
    \ let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n            prod *=\
    \ 1;\n            sum += i;\n        } else if i < 0 {\n            prod *= -1;\n\
    \            sum += -i;\n        } else {\n            prod *= 0;\n        }\n\
    \    }\n    if arr.len() == 0 {\n        None\n    } else {\n        Some(sum\
    \ * prod)\n    }\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `arr`\n   --> /tmp/tmpyuaseirl.rs:26:8\n\
    \    |\n12  | fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    |       \
    \        --- move occurs because `arr` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n15  |     for i in arr {\n    |              --- `arr`\
    \ moved due to this implicit call to `.into_iter()`\n...\n26  |     if arr.len()\
    \ == 0 {\n    |        ^^^^^^^^^ value borrowed here after move\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `arr`\nhelp:\
    \ consider iterating over a slice of the `Vec<isize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n15  |     for i in &arr {\n    |              +\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660008726
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for n in arr {\n        if n > 0 {\n            prod *= 1;\n        } else if\
    \ n < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += n.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for num in arr {\n        if num > 0 {\n            prod *= 1;\n        } else\
    \ if num < 0 {\n            prod *= -1;\n        } else {\n            prod *=\
    \ 0;\n        }\n        sum += num.abs();\n    }\n    Some(sum * prod)\n}\n\n\
    fn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        prod *= i.signum();\n        sum += i.abs();\n    }\n\
    \    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n   \
    \ assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 101
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    unimplemented!()\n}\n\n\
    fn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpzi6t2343.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 101
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    unimplemented!(\"return\
    \ sum of magnitudes of integers multiplied by product of all signs of each number\
    \ in the array {:?}\", arr)\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented: return sum of magnitudes
    of integers multiplied by product of all signs of each number in the array [1,
    2, 2, -4]'', /tmp/tmpj0z6rl13.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 101
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    unimplemented!();\n}\n\n\
    fn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpoen7oyql.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 101
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    unimplemented!()\n}\n\n\
    fn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpzi6t2343.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut sign_prod = 1;\n    let mut sum = 0;\n\
    \    for i in arr {\n        if i > 0 {\n            sign_prod *= 1;\n       \
    \ } else if i < 0 {\n            sign_prod *= -1;\n        } else {\n        \
    \    sign_prod *= 0;\n        }\n        sum += i.abs();\n    }\n    Some(sum\
    \ * sign_prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for num in arr {\n        if num > 0 {\n            prod *= 1;\n        } else\
    \ if num < 0 {\n            prod *= -1;\n        } else {\n            prod *=\
    \ 0;\n        }\n        sum += num.abs();\n    }\n    Some(sum * prod)\n}\n\n\
    fn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 101
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i < 0 {\n            prod *= -1;\n        } else\
    \ if i > 0 {\n            sum += i;\n        }\n    }\n    Some(sum * prod)\n\
    }\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-5)`,\n right: `Some(-9)`', /tmp/tmpqdp1kgpl.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008727
- exit_code: 101
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    unimplemented!()\n}\n\n\
    fn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpzi6t2343.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660008727
- exit_code: 1
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    let mut prod = 1;\n   \
    \ let mut sum = 0;\n    for n in arr {\n        if n > 0 {\n            prod *=\
    \ 1;\n            sum += n;\n        } else if n < 0 {\n            prod *= -1;\n\
    \            sum += -n;\n        }\n    }\n    if arr.len() == 0 {\n        None\n\
    \    } else {\n        Some(sum * prod)\n    }\n}\n\nfn main() {\n    let candidate\
    \ = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n   \
    \ assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `arr`\n   --> /tmp/tmpqze9gjwo.rs:24:8\n\
    \    |\n12  | fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    |       \
    \        --- move occurs because `arr` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n15  |     for n in arr {\n    |              --- `arr`\
    \ moved due to this implicit call to `.into_iter()`\n...\n24  |     if arr.len()\
    \ == 0 {\n    |        ^^^^^^^^^ value borrowed here after move\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `arr`\nhelp:\
    \ consider iterating over a slice of the `Vec<isize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n15  |     for n in &arr {\n    |              +\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660008726
- exit_code: 101
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    unimplemented!()\n}\n\n\
    fn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpzi6t2343.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660008727
- exit_code: 1
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    let mut prod = 1;\n   \
    \ let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n            prod *=\
    \ 1;\n            sum += i;\n        } else if i < 0 {\n            prod *= -1;\n\
    \            sum += i.abs();\n        } else {\n            prod *= 0;\n     \
    \   }\n    }\n    if arr.len() == 0 {\n        None\n    } else {\n        Some(sum\
    \ * prod)\n    }\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `arr`\n   --> /tmp/tmpydc7k1n2.rs:26:8\n\
    \    |\n12  | fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    |       \
    \        --- move occurs because `arr` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n15  |     for i in arr {\n    |              --- `arr`\
    \ moved due to this implicit call to `.into_iter()`\n...\n26  |     if arr.len()\
    \ == 0 {\n    |        ^^^^^^^^^ value borrowed here after move\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `arr`\nhelp:\
    \ consider iterating over a slice of the `Vec<isize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n15  |     for i in &arr {\n    |              +\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660008726
- exit_code: 1
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    let mut prod = 1;\n   \
    \ let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n            prod *=\
    \ 1;\n            sum += i;\n        } else if i < 0 {\n            prod *= -1;\n\
    \            sum += i.abs();\n        } else {\n            prod *= 0;\n     \
    \   }\n    }\n    if arr.len() == 0 {\n        None\n    } else {\n        Some(sum\
    \ * prod)\n    }\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `arr`\n   --> /tmp/tmpydc7k1n2.rs:26:8\n\
    \    |\n12  | fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    |       \
    \        --- move occurs because `arr` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n15  |     for i in arr {\n    |              --- `arr`\
    \ moved due to this implicit call to `.into_iter()`\n...\n26  |     if arr.len()\
    \ == 0 {\n    |        ^^^^^^^^^ value borrowed here after move\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `arr`\nhelp:\
    \ consider iterating over a slice of the `Vec<isize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n15  |     for i in &arr {\n    |              +\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660008726
- exit_code: 101
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    unimplemented!(\"Return\
    \ sum of magnitudes of integers multiplied by product of all signs of each number\
    \ in {:?}\", arr);\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented: Return sum of magnitudes
    of integers multiplied by product of all signs of each number in [1, 2, 2, -4]'',
    /tmp/tmpfusd1_ix.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 101
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    unimplemented!();\n}\n\n\
    fn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpoen7oyql.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 101
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    unimplemented!()\n}\n\n\
    fn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpzi6t2343.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 101
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i == 0 {\n            continue;\n        }\n    \
    \    prod *= i.signum();\n        sum += i.abs();\n    }\n    Some(sum * prod)\n\
    }\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(0)`', /tmp/tmpadq_72nh.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 1
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    let mut prod = 1;\n   \
    \ let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n            prod *=\
    \ 1;\n            sum += i;\n        } else if i < 0 {\n            prod *= -1;\n\
    \            sum += i.abs();\n        } else {\n            prod *= 0;\n     \
    \   }\n    }\n    if arr.len() == 0 {\n        None\n    } else {\n        Some(sum\
    \ * prod)\n    }\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `arr`\n   --> /tmp/tmpydc7k1n2.rs:26:8\n\
    \    |\n12  | fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    |       \
    \        --- move occurs because `arr` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n15  |     for i in arr {\n    |              --- `arr`\
    \ moved due to this implicit call to `.into_iter()`\n...\n26  |     if arr.len()\
    \ == 0 {\n    |        ^^^^^^^^^ value borrowed here after move\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `arr`\nhelp:\
    \ consider iterating over a slice of the `Vec<isize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n15  |     for i in &arr {\n    |              +\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660008726
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 101
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i < 0 {\n            prod *= -1;\n        } else\
    \ if i > 0 {\n            sum += i;\n        }\n    }\n    Some(sum * prod)\n\
    }\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-5)`,\n right: `Some(-9)`', /tmp/tmpqdp1kgpl.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008727
- exit_code: 101
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    unimplemented!()\n}\n\n\
    fn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpzi6t2343.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 101
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i == 0 {\n            continue;\n        }\n    \
    \    prod *= i.signum();\n        sum += i.abs();\n    }\n    Some(sum * prod)\n\
    }\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(0)`', /tmp/tmpadq_72nh.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 101
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    unimplemented!(\"Return\
    \ the sum of magnitudes of integers multiplied by product of all signs of each\
    \ number in the array {:?}\", arr);\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented: Return the sum of magnitudes
    of integers multiplied by product of all signs of each number in the array [1,
    2, 2, -4]'', /tmp/tmp_iqufpl5.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660008727
- exit_code: 101
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    unimplemented!(\"Return\
    \ sum of magnitudes of integers multiplied by product of all signs of each number\
    \ in the array {:?}\", arr);\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented: Return sum of magnitudes
    of integers multiplied by product of all signs of each number in the array [1,
    2, 2, -4]'', /tmp/tmph4110ers.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 1
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    let mut prod = 1;\n   \
    \ let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n            prod *=\
    \ 1;\n            sum += i;\n        } else if i < 0 {\n            prod *= -1;\n\
    \            sum += -i;\n        } else {\n            prod *= 0;\n        }\n\
    \    }\n    if arr.len() == 0 {\n        None\n    } else {\n        Some(sum\
    \ * prod)\n    }\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `arr`\n   --> /tmp/tmpyuaseirl.rs:26:8\n\
    \    |\n12  | fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    |       \
    \        --- move occurs because `arr` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n15  |     for i in arr {\n    |              --- `arr`\
    \ moved due to this implicit call to `.into_iter()`\n...\n26  |     if arr.len()\
    \ == 0 {\n    |        ^^^^^^^^^ value borrowed here after move\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `arr`\nhelp:\
    \ consider iterating over a slice of the `Vec<isize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n15  |     for i in &arr {\n    |              +\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660008726
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 101
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    unimplemented!()\n}\n\n\
    fn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpzi6t2343.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for x in arr {\n        if x > 0 {\n            prod *= 1;\n        } else if\
    \ x < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += x.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 101
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    unimplemented!()\n}\n\n\
    fn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpzi6t2343.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 1
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    let mut prod = 1;\n   \
    \ let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n            prod *=\
    \ 1;\n            sum += i;\n        } else if i < 0 {\n            prod *= -1;\n\
    \            sum += i.abs();\n        } else {\n            prod *= 0;\n     \
    \   }\n    }\n    if arr.len() == 0 {\n        None\n    } else {\n        Some(sum\
    \ * prod)\n    }\n}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `arr`\n   --> /tmp/tmpydc7k1n2.rs:26:8\n\
    \    |\n12  | fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    |       \
    \        --- move occurs because `arr` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n15  |     for i in arr {\n    |              --- `arr`\
    \ moved due to this implicit call to `.into_iter()`\n...\n26  |     if arr.len()\
    \ == 0 {\n    |        ^^^^^^^^^ value borrowed here after move\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `arr`\nhelp:\
    \ consider iterating over a slice of the `Vec<isize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n15  |     for i in &arr {\n    |              +\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660008726
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 101
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i == 0 {\n            continue;\n        }\n    \
    \    prod *= i.signum();\n        sum += i.abs();\n    }\n    Some(sum * prod)\n\
    }\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(0)`', /tmp/tmpadq_72nh.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut product = 1;\n    let mut sum = 0;\n\
    \    for i in arr {\n        if i > 0 {\n            product *= 1;\n        }\
    \ else if i < 0 {\n            product *= -1;\n        } else {\n            product\
    \ *= 0;\n        }\n        sum += i.abs();\n    }\n    Some(sum * product)\n\
    }\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 101
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i < 0 {\n            prod *= -1;\n        } else\
    \ if i > 0 {\n            sum += i;\n        }\n    }\n    Some(sum * prod)\n\
    }\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-5)`,\n right: `Some(-9)`', /tmp/tmpqdp1kgpl.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008727
- exit_code: 101
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    unimplemented!(\"Return\
    \ sum of magnitudes of integers multiplied by product of all signs of each number\
    \ in the array {:?}\", arr);\n}\n\nfn main() {\n    let candidate = prod_signs;\n\
    \    assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented: Return sum of magnitudes
    of integers multiplied by product of all signs of each number in the array [1,
    2, 2, -4]'', /tmp/tmph4110ers.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660008727
- exit_code: 101
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    unimplemented!()\n}\n\n\
    fn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpzi6t2343.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 101
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    unimplemented!()\n}\n\n\
    fn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpzi6t2343.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 101
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    unimplemented!();\n}\n\n\
    fn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpoen7oyql.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for num in arr {\n        if num > 0 {\n            prod *= 1;\n        } else\
    \ if num < 0 {\n            prod *= -1;\n        } else {\n            prod *=\
    \ 0;\n        }\n        sum += num.abs();\n    }\n    Some(sum * prod)\n}\n\n\
    fn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 101
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i < 0 {\n            prod *= -1;\n        } else\
    \ if i > 0 {\n            sum += i;\n        }\n    }\n    Some(sum * prod)\n\
    }\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-5)`,\n right: `Some(-9)`', /tmp/tmpqdp1kgpl.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 101
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    unimplemented!();\n}\n\n\
    fn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpoen7oyql.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        sum += i.abs();\n        prod *= i.signum();\n    }\n\
    \    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n   \
    \ assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 101
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    unimplemented!()\n}\n\n\
    fn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpzi6t2343.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        sum += i.abs();\n        prod *= i.signum();\n    }\n\
    \    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n   \
    \ assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 101
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    unimplemented!()\n}\n\n\
    fn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpzi6t2343.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 101
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i < 0 {\n            prod *= -1;\n        } else\
    \ if i > 0 {\n            sum += i;\n        }\n    }\n    Some(sum * prod)\n\
    }\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(-5)`,\n right: `Some(-9)`', /tmp/tmpqdp1kgpl.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        prod *= i.signum();\n        sum += i.abs();\n    }\n\
    \    Some(sum * prod)\n}\n\nfn main() {\n    let candidate = prod_signs;\n   \
    \ assert_eq!(candidate(vec![1, 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0,\
    \ 1]), Some(0));\n    assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 2, -1, -1, 9]), Some(20));\n    assert_eq!(candidate(vec![-1, 1, -1, 1]),\
    \ Some(4));\n    assert_eq!(candidate(vec![-1, 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 0]), Some(0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 101
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i == 0 {\n            continue;\n        }\n    \
    \    prod *= i.signum();\n        sum += i.abs();\n    }\n    Some(sum * prod)\n\
    }\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(1)`,\n right: `Some(0)`', /tmp/tmpadq_72nh.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 101
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    unimplemented!()\n}\n\n\
    fn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpzi6t2343.rs:13:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
- exit_code: 0
  program: "/// You are given an array arr of integers and you need to return\n///\
    \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(vec![1, 2, 2, -4])\n/// Some(9)\n///\
    \ >>> prod_signs(vec![0, 1])\n/// Some(0)\n/// >>> prod_signs(vec![])\n/// None\n\
    fn prod_signs(arr: Vec<isize>) -> Option<isize> {\n    if arr.is_empty() {\n \
    \       return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n   \
    \ for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if\
    \ i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)\n}\n\nfn main()\
    \ {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1, 2, 2, -4]),\
    \ Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n\
    \    assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
    \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660008727
