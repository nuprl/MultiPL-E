name: HumanEval_41_car_race_collision
language: rs
prompt: "/// Imagine a road that's a perfectly straight infinitely long line.\n///\
  \ n cars are driving left to right;  simultaneously, a different set of n cars\n\
  /// are driving right to left.   The two sets of cars start out being very far from\n\
  /// each other.  All cars move in the same speed.  Two cars are said to collide\n\
  /// when a car that's moving left to right hits a car that's moving right to left.\n\
  /// However, the cars are infinitely sturdy and strong; as a result, they continue\
  \ moving\n/// in their trajectory as if they did not collide.\n/// This function\
  \ outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize\
  \ {\n"
tests: "}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!({left},\
  \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
  \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
completions: ["    // TODO: implement this function\n    0", "    let mut left_to_right:\
    \ Vec<isize> = (0..n).collect();\n    let mut right_to_left: Vec<isize> = (0..n).collect();\n\
    \    left_to_right.sort();\n    right_to_left.sort();\n    let mut collisions\
    \ = 0;\n    let mut i = 0;\n    let mut j = 0;\n    while i < n && j < n {\n \
    \       if left_to_right[i] < right_to_left[j] {\n            collisions += j;\n\
    \            i += 1;\n        } else {\n            j += 1;\n        }\n    }\n\
    \    collisions", "    let mut left_to_right = Vec::new();\n    let mut right_to_left\
    \ = Vec::new();\n    for i in 0..n {\n        left_to_right.push(i);\n       \
    \ right_to_left.push(n - i - 1);\n    }\n    let mut collisions = 0;\n    while\
    \ !left_to_right.is_empty() && !right_to_left.is_empty() {\n        let left_car\
    \ = left_to_right.remove(0);\n        let right_car = right_to_left.remove(0);\n\
    \        if left_car == right_car {\n            collisions += 1;\n        } else\
    \ {\n            if left_car < right_car {\n                left_to_right.push(left_car);\n\
    \                right_to_left.push(right_car);\n            } else {\n      \
    \          left_to_right.push(right_car);\n                right_to_left.push(left_car);\n\
    \            }\n        }\n    }\n    collisions", "    let mut left_to_right:\
    \ Vec<isize> = (0..n).collect();\n    let mut right_to_left: Vec<isize> = (0..n).rev().collect();\n\
    \    let mut collisions = 0;\n    while !left_to_right.is_empty() && !right_to_left.is_empty()\
    \ {\n        let l = left_to_right[0];\n        let r = right_to_left[0];\n  \
    \      if l == r {\n            collisions += 1;\n        }\n        if l < r\
    \ {\n            left_to_right.remove(0);\n        } else {\n            right_to_left.remove(0);\n\
    \        }\n    }\n    collisions", "    let mut left_to_right = Vec::new();\n\
    \    let mut right_to_left = Vec::new();\n    for i in 0..n {\n        left_to_right.push(i);\n\
    \        right_to_left.push(n - i - 1);\n    }\n    let mut collisions = 0;\n\
    \    while !left_to_right.is_empty() {\n        let left = left_to_right.pop().unwrap();\n\
    \        let right = right_to_left.pop().unwrap();\n        if left == right {\n\
    \            collisions += 1;\n        }\n    }\n    collisions", "    let mut\
    \ left_to_right = Vec::new();\n    let mut right_to_left = Vec::new();\n    for\
    \ i in 0..n {\n        left_to_right.push(i);\n        right_to_left.push(n -\
    \ i - 1);\n    }\n    let mut collisions = 0;\n    while !left_to_right.is_empty()\
    \ {\n        let left = left_to_right.pop().unwrap();\n        let right = right_to_left.pop().unwrap();\n\
    \        if left == right {\n            collisions += 1;\n        }\n    }\n\
    \    collisions", "    let mut left_to_right = vec![0; n as usize];\n    let mut\
    \ right_to_left = vec![0; n as usize];\n    for i in 0..n {\n        left_to_right[i\
    \ as usize] = i;\n        right_to_left[i as usize] = n - i - 1;\n    }\n    let\
    \ mut count = 0;\n    for i in 0..n {\n        for j in 0..n {\n            if\
    \ left_to_right[i as usize] == right_to_left[j as usize] {\n                count\
    \ += 1;\n            }\n        }\n    }\n    count", "    // TODO: implement\
    \ this function\n    0", "    let mut left_to_right = vec![0; n as usize];\n \
    \   let mut right_to_left = vec![0; n as usize];\n    for i in 0..n {\n      \
    \  left_to_right[i as usize] = i;\n        right_to_left[i as usize] = n - i -\
    \ 1;\n    }\n    let mut collisions = 0;\n    for i in 0..n {\n        for j in\
    \ 0..n {\n            if left_to_right[i as usize] == right_to_left[j as usize]\
    \ {\n                collisions += 1;\n            }\n        }\n    }\n    collisions",
  "    if n <= 1 {\n        return 0;\n    }\n    let mut left_to_right = Vec::new();\n\
    \    let mut right_to_left = Vec::new();\n    for i in 0..n {\n        left_to_right.push(i);\n\
    \        right_to_left.push(n - i - 1);\n    }\n    let mut collisions = 0;\n\
    \    while !left_to_right.is_empty() && !right_to_left.is_empty() {\n        let\
    \ l = left_to_right.pop().unwrap();\n        let r = right_to_left.pop().unwrap();\n\
    \        if l > r {\n            collisions += 1;\n        }\n    }\n    collisions",
  "    let mut collisions = 0;\n    for i in 0..n {\n        for j in 0..n {\n   \
    \         if i < j {\n                collisions += 1;\n            }\n      \
    \  }\n    }\n    collisions", "    let mut collisions = 0;\n    let mut left_to_right\
    \ = vec![0; n as usize];\n    let mut right_to_left = vec![0; n as usize];\n \
    \   for i in 0..n {\n        left_to_right[i as usize] = i;\n        right_to_left[i\
    \ as usize] = n - i - 1;\n    }\n    for i in 0..n {\n        for j in 0..n {\n\
    \            if left_to_right[i as usize] == right_to_left[j as usize] {\n   \
    \             collisions += 1;\n            }\n        }\n    }\n    collisions",
  "    // TODO\n    0", "    let mut left_to_right = vec![];\n    let mut right_to_left\
    \ = vec![];\n    for i in 0..n {\n        left_to_right.push(i);\n        right_to_left.push(n\
    \ - i - 1);\n    }\n    let mut collisions = 0;\n    while !left_to_right.is_empty()\
    \ && !right_to_left.is_empty() {\n        let l = left_to_right.pop().unwrap();\n\
    \        let r = right_to_left.pop().unwrap();\n        if l > r {\n         \
    \   collisions += 1;\n        }\n    }\n    collisions", "    if n <= 1 {\n  \
    \      return 0;\n    }\n    let mut left_to_right: Vec<isize> = (0..n).collect();\n\
    \    let mut right_to_left: Vec<isize> = (0..n).rev().collect();\n    let mut\
    \ collisions = 0;\n    let mut i = 0;\n    let mut j = 0;\n    while i < n &&\
    \ j < n {\n        if left_to_right[i] < right_to_left[j] {\n            collisions\
    \ += j;\n            i += 1;\n        } else {\n            j += 1;\n        }\n\
    \    }\n    collisions += (n - i) * j;\n    collisions", "    let mut left_to_right\
    \ = vec![];\n    let mut right_to_left = vec![];\n    for i in 0..n {\n      \
    \  left_to_right.push(i);\n        right_to_left.push(n + i);\n    }\n    let\
    \ mut collisions = 0;\n    while !left_to_right.is_empty() && !right_to_left.is_empty()\
    \ {\n        let left_car = left_to_right.pop().unwrap();\n        let right_car\
    \ = right_to_left.pop().unwrap();\n        if left_car > right_car {\n       \
    \     collisions += 1;\n        }\n    }\n    collisions", "    let mut collisions\
    \ = 0;\n    for i in 0..n {\n        for j in 0..n {\n            if i < j {\n\
    \                collisions += 1;\n            }\n        }\n    }\n    collisions",
  "    if n == 0 {\n        return 0;\n    }\n    let mut left_to_right = vec![0;\
    \ n as usize];\n    let mut right_to_left = vec![0; n as usize];\n    for i in\
    \ 0..n {\n        left_to_right[i as usize] = i;\n        right_to_left[i as usize]\
    \ = n - i - 1;\n    }\n    let mut collisions = 0;\n    let mut i = 0;\n    let\
    \ mut j = 0;\n    while i < n && j < n {\n        if left_to_right[i as usize]\
    \ < right_to_left[j as usize] {\n            collisions += j;\n            i +=\
    \ 1;\n        } else {\n            j += 1;\n        }\n    }\n    collisions\
    \ += (n - i) * (n - i - 1) / 2;\n    collisions", "    let mut collisions = 0;\n\
    \    let mut left_to_right = 0;\n    let mut right_to_left = 0;\n    for i in\
    \ 0..n {\n        left_to_right += i;\n        right_to_left += n - i - 1;\n \
    \       collisions += left_to_right * (n - i - 1) + right_to_left * i;\n    }\n\
    \    collisions", "    let mut cars = vec![0; n as usize];\n    let mut collisions\
    \ = 0;\n    for i in 0..n {\n        cars[i as usize] = i;\n    }\n    for i in\
    \ 0..n {\n        for j in 0..n {\n            if cars[i as usize] > cars[j as\
    \ usize] {\n                collisions += 1;\n            }\n        }\n    }\n\
    \    collisions"]
stop_tokens:
- "\n}"
