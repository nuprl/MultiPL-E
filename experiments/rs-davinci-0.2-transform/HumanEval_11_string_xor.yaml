name: HumanEval_11_string_xor
language: rs
prompt: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
  \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
  010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
  \ b: String) -> String {\n"
tests: "}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!({left},\
  \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
  }\n"
completions: ["    let mut result = String::new();\n    for (a, b) in a.chars().zip(b.chars())\
    \ {\n        result.push(match (a, b) {\n            ('0', '0') => '0',\n    \
    \        ('0', '1') => '1',\n            ('1', '0') => '1',\n            ('1',\
    \ '1') => '0',\n            _ => panic!(\"Invalid input\"),\n        });\n   \
    \ }\n    result", "    let mut result = String::new();\n    for (i, j) in a.chars().zip(b.chars())\
    \ {\n        result.push(match (i, j) {\n            ('0', '0') => '0',\n    \
    \        ('0', '1') => '1',\n            ('1', '0') => '1',\n            ('1',\
    \ '1') => '0',\n            _ => panic!(\"Invalid input\"),\n        });\n   \
    \ }\n    result", "    let mut result = String::new();\n    for (i, j) in a.chars().zip(b.chars())\
    \ {\n        result.push(match (i, j) {\n            ('0', '0') => '0',\n    \
    \        ('0', '1') => '1',\n            ('1', '0') => '1',\n            ('1',\
    \ '1') => '0',\n            _ => panic!(\"Invalid input\"),\n        });\n   \
    \ }\n    result", "    let mut result = String::new();\n    for (i, j) in a.chars().zip(b.chars())\
    \ {\n        result.push(match (i, j) {\n            ('0', '0') => '0',\n    \
    \        ('0', '1') => '1',\n            ('1', '0') => '1',\n            ('1',\
    \ '1') => '0',\n            _ => panic!(\"Invalid input\"),\n        });\n   \
    \ }\n    result", "    let mut result = String::new();\n    for (c1, c2) in a.chars().zip(b.chars())\
    \ {\n        result.push(if c1 == c2 { '0' } else { '1' });\n    }\n    result",
  "    let mut result = String::new();\n    for (a, b) in a.chars().zip(b.chars())\
    \ {\n        result.push(if a == b { '0' } else { '1' });\n    }\n    result",
  "    let mut result = String::new();\n    for (i, j) in a.chars().zip(b.chars())\
    \ {\n        result.push(if i == j { '0' } else { '1' });\n    }\n    result",
  "    let mut result = String::new();\n    for (a, b) in a.chars().zip(b.chars())\
    \ {\n        result.push(match (a, b) {\n            ('0', '0') => '0',\n    \
    \        ('0', '1') => '1',\n            ('1', '0') => '1',\n            ('1',\
    \ '1') => '0',\n            _ => panic!(\"Invalid input\"),\n        });\n   \
    \ }\n    result", "    let mut result = String::new();\n    for (c1, c2) in a.chars().zip(b.chars())\
    \ {\n        let c = if c1 == c2 { '0' } else { '1' };\n        result.push(c);\n\
    \    }\n    result", "    let mut result = String::new();\n    for (i, j) in a.chars().zip(b.chars())\
    \ {\n        result.push(match (i, j) {\n            ('0', '0') => '0',\n    \
    \        ('0', '1') => '1',\n            ('1', '0') => '1',\n            ('1',\
    \ '1') => '0',\n            _ => panic!(\"Invalid input\"),\n        });\n   \
    \ }\n    result", "    let mut result = String::new();\n    for (i, j) in a.chars().zip(b.chars())\
    \ {\n        result.push(match (i, j) {\n            ('0', '0') => '0',\n    \
    \        ('0', '1') => '1',\n            ('1', '0') => '1',\n            ('1',\
    \ '1') => '0',\n            _ => '0',\n        });\n    }\n    result", "    let\
    \ mut result = String::new();\n    for i in 0..a.len() {\n        let a_char =\
    \ a.chars().nth(i).unwrap();\n        let b_char = b.chars().nth(i).unwrap();\n\
    \        let a_int = a_char.to_digit(10).unwrap();\n        let b_int = b_char.to_digit(10).unwrap();\n\
    \        let xor_int = a_int ^ b_int;\n        let xor_char = xor_int.to_string().chars().nth(0).unwrap();\n\
    \        result.push(xor_char);\n    }\n    result", "    let mut result = String::new();\n\
    \    for (c1, c2) in a.chars().zip(b.chars()) {\n        result.push(if c1 ==\
    \ c2 { '0' } else { '1' });\n    }\n    result", "    let mut result = String::new();\n\
    \    for (i, j) in a.chars().zip(b.chars()) {\n        result.push(if i == j {\
    \ '0' } else { '1' });\n    }\n    result", "    let mut result = String::new();\n\
    \    for (a, b) in a.chars().zip(b.chars()) {\n        result.push(match (a, b)\
    \ {\n            ('0', '0') => '0',\n            ('0', '1') => '1',\n        \
    \    ('1', '0') => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"\
    Invalid input\"),\n        });\n    }\n    result", "    let mut result = String::new();\n\
    \    let a_bytes = a.into_bytes();\n    let b_bytes = b.into_bytes();\n    for\
    \ i in 0..a_bytes.len() {\n        result.push(match (a_bytes[i], b_bytes[i])\
    \ {\n            (48, 48) => '0',\n            (48, 49) => '1',\n            (49,\
    \ 48) => '1',\n            (49, 49) => '0',\n            _ => panic!(\"Invalid\
    \ input\"),\n        });\n    }\n    result", "    let mut result = String::new();\n\
    \    for (a, b) in a.chars().zip(b.chars()) {\n        result.push(if a == b {\
    \ '0' } else { '1' });\n    }\n    result", "    let mut result = String::new();\n\
    \    let a_bytes = a.as_bytes();\n    let b_bytes = b.as_bytes();\n    for i in\
    \ 0..a_bytes.len() {\n        if a_bytes[i] == b_bytes[i] {\n            result.push('0');\n\
    \        } else {\n            result.push('1');\n        }\n    }\n    result",
  "    let mut result = String::new();\n    let mut a_iter = a.chars();\n    let mut\
    \ b_iter = b.chars();\n    loop {\n        match (a_iter.next(), b_iter.next())\
    \ {\n            (Some(a_char), Some(b_char)) => {\n                result.push(if\
    \ a_char == b_char { '0' } else { '1' });\n            }\n            _ => break,\n\
    \        }\n    }\n    result", "    let mut result = String::new();\n    for\
    \ (a, b) in a.chars().zip(b.chars()) {\n        result.push(if a == b { '0' }\
    \ else { '1' });\n    }\n    result"]
stop_tokens:
- "\n}"
