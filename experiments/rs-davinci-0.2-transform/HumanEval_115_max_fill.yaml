name: HumanEval_115_max_fill
language: rs
prompt: "/// You are given a rectangular grid of wells. Each row represents a single\
  \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each well\
  \ has a corresponding bucket that can be used to extract water from it, \n/// and\
  \ all buckets have the same capacity.\n/// Your task is to use the buckets to empty\
  \ the wells.\n/// Output the number of times you need to lower the buckets.\n///\
  \ Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
  \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
  \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
  \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
  /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <=\
  \ grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\n\
  fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n"
tests: "}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!({left}, {right});\n\
  \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
  \ {right});\n    assert_eq!({left}, {right});\n}\n"
completions: ["    let mut max_fill = 0;\n    let mut fill = 0;\n    for row in grid\
    \ {\n        for col in row {\n            if col == 1 {\n                fill\
    \ += 1;\n            } else {\n                if fill > max_fill {\n        \
    \            max_fill = fill;\n                }\n                fill = 0;\n\
    \            }\n        }\n        if fill > max_fill {\n            max_fill\
    \ = fill;\n        }\n        fill = 0;\n    }\n    max_fill / capacity", "  \
    \  let mut max_fill = 0;\n    let mut current_fill = 0;\n    for row in grid {\n\
    \        for well in row {\n            if well == 1 {\n                current_fill\
    \ += 1;\n            } else {\n                if current_fill > max_fill {\n\
    \                    max_fill = current_fill;\n                }\n           \
    \     current_fill = 0;\n            }\n        }\n        if current_fill > max_fill\
    \ {\n            max_fill = current_fill;\n        }\n        current_fill = 0;\n\
    \    }\n    max_fill / capacity", "    let mut grid = grid;\n    let mut count\
    \ = 0;\n    let mut row_max = vec![0; grid.len()];\n    let mut col_max = vec![0;\
    \ grid[0].len()];\n    for i in 0..grid.len() {\n        for j in 0..grid[i].len()\
    \ {\n            row_max[i] = row_max[i].max(grid[i][j]);\n            col_max[j]\
    \ = col_max[j].max(grid[i][j]);\n        }\n    }\n    for i in 0..grid.len()\
    \ {\n        for j in 0..grid[i].len() {\n            let max = row_max[i].min(col_max[j]);\n\
    \            if max > grid[i][j] {\n                count += max - grid[i][j];\n\
    \                grid[i][j] = max;\n            }\n        }\n    }\n    count",
  "    let mut grid = grid;\n    let mut count = 0;\n    let mut max_height = 0;\n\
    \    for row in grid.iter_mut() {\n        let mut height = 0;\n        for cell\
    \ in row.iter_mut() {\n            if *cell == 1 {\n                height +=\
    \ 1;\n            } else {\n                height = 0;\n            }\n     \
    \   }\n        if height > max_height {\n            max_height = height;\n  \
    \      }\n    }\n    for _ in 0..max_height {\n        for row in grid.iter_mut()\
    \ {\n            for cell in row.iter_mut() {\n                if *cell == 1 {\n\
    \                    *cell = 0;\n                    count += 1;\n           \
    \     }\n            }\n        }\n    }\n    count", "    let mut result = 0;\n\
    \    let mut grid = grid;\n    let mut row_max = vec![0; grid.len()];\n    let\
    \ mut col_max = vec![0; grid[0].len()];\n    for i in 0..grid.len() {\n      \
    \  for j in 0..grid[i].len() {\n            if grid[i][j] == 1 {\n           \
    \     row_max[i] += 1;\n                col_max[j] += 1;\n            }\n    \
    \    }\n    }\n    for i in 0..grid.len() {\n        for j in 0..grid[i].len()\
    \ {\n            if grid[i][j] == 1 {\n                let max = std::cmp::min(row_max[i],\
    \ col_max[j]);\n                if max > capacity {\n                    result\
    \ += max - capacity;\n                    row_max[i] -= max - capacity;\n    \
    \                col_max[j] -= max - capacity;\n                }\n          \
    \  }\n        }\n    }\n    result", "    let mut result = 0;\n    let mut grid\
    \ = grid;\n    let mut row_max = vec![0; grid.len()];\n    let mut col_max = vec![0;\
    \ grid[0].len()];\n    for i in 0..grid.len() {\n        for j in 0..grid[i].len()\
    \ {\n            row_max[i] = std::cmp::max(row_max[i], grid[i][j]);\n       \
    \     col_max[j] = std::cmp::max(col_max[j], grid[i][j]);\n        }\n    }\n\
    \    for i in 0..grid.len() {\n        for j in 0..grid[i].len() {\n         \
    \   let max = std::cmp::min(row_max[i], col_max[j]);\n            if max > grid[i][j]\
    \ {\n                result += max - grid[i][j];\n                grid[i][j] =\
    \ max;\n            }\n        }\n    }\n    result", "    let mut max_fill =\
    \ 0;\n    for row in grid {\n        let mut fill = 0;\n        for well in row\
    \ {\n            if well == 1 {\n                fill += 1;\n            } else\
    \ {\n                if fill > 0 {\n                    max_fill += 1;\n     \
    \               fill = 0;\n                }\n            }\n        }\n     \
    \   if fill > 0 {\n            max_fill += 1;\n        }\n    }\n    max_fill\
    \ * capacity", "    let mut max_fill = 0;\n    let mut fill = 0;\n    for row\
    \ in grid {\n        for cell in row {\n            if cell == 1 {\n         \
    \       fill += 1;\n            } else {\n                if fill > max_fill {\n\
    \                    max_fill = fill;\n                }\n                fill\
    \ = 0;\n            }\n        }\n        if fill > max_fill {\n            max_fill\
    \ = fill;\n        }\n        fill = 0;\n    }\n    max_fill / capacity", "  \
    \  let mut result = 0;\n    let mut max_height = 0;\n    for row in grid {\n \
    \       let mut height = 0;\n        for &cell in row.iter() {\n            if\
    \ cell == 1 {\n                height += 1;\n            }\n        }\n      \
    \  if height > max_height {\n            max_height = height;\n        }\n   \
    \ }\n    for row in grid {\n        let mut height = 0;\n        for &cell in\
    \ row.iter() {\n            if cell == 1 {\n                height += 1;\n   \
    \         }\n        }\n        result += max_height - height;\n    }\n    result",
  "    let mut grid = grid;\n    let mut count = 0;\n    let mut row_max = 0;\n  \
    \  let mut col_max = 0;\n    let mut row_min = 0;\n    let mut col_min = 0;\n\
    \    let mut row_max_index = 0;\n    let mut col_max_index = 0;\n    let mut row_min_index\
    \ = 0;\n    let mut col_min_index = 0;\n    let mut row_max_index_vec = Vec::new();\n\
    \    let mut col_max_index_vec = Vec::new();\n    let mut row_min_index_vec =\
    \ Vec::new();\n    let mut col_min_index_vec = Vec::new();\n    let mut row_max_vec\
    \ = Vec::new();\n    let mut col_max_vec = Vec::new();\n    let mut row_min_vec\
    \ = Vec::new();\n    let mut col_min_vec = Vec::new();\n    let mut row_max_vec_vec\
    \ = Vec::new();\n    let mut col_max_vec_vec = Vec::new();\n    let mut row_min_vec_vec\
    \ = Vec::new();\n    let mut col_min_vec_vec = Vec::new();\n    let mut row_max_index_vec_vec\
    \ = Vec::new();\n    let mut col_max_index_vec_vec = Vec::new();\n    let mut\
    \ row_min_index_vec_vec = Vec::new();\n    let mut col_min_index_vec_vec = Vec::new();\n\
    \    let mut row_max_vec_vec_vec = Vec::new();\n    let mut col_max_vec_vec_vec\
    \ = Vec::new();\n    let mut row_min_vec_vec_vec = Vec::new();\n    let mut col_min_vec_vec_vec\
    \ = Vec::new();\n    let mut row_max_index_vec_vec_vec = Vec::new();\n    let\
    \ mut col_max_index_vec_vec_vec = Vec::new();\n    let mut row_min_index_vec_vec_vec\
    \ = Vec::new();\n    let mut col_min_index_vec_vec_vec = Vec::new();", "    let\
    \ mut result = 0;\n    let mut max_height = 0;\n    for row in grid {\n      \
    \  let mut height = 0;\n        for cell in row {\n            if cell == 1 {\n\
    \                height += 1;\n            }\n        }\n        if height > max_height\
    \ {\n            max_height = height;\n        }\n    }\n    for row in grid {\n\
    \        let mut height = 0;\n        for cell in row {\n            if cell ==\
    \ 1 {\n                height += 1;\n            }\n        }\n        result\
    \ += max_height - height;\n    }\n    result", "    let mut count = 0;\n    let\
    \ mut grid = grid;\n    let mut row_max = vec![0; grid.len()];\n    let mut col_max\
    \ = vec![0; grid[0].len()];\n    for i in 0..grid.len() {\n        for j in 0..grid[i].len()\
    \ {\n            if grid[i][j] == 1 {\n                row_max[i] += 1;\n    \
    \            col_max[j] += 1;\n            }\n        }\n    }\n    let mut row_max\
    \ = row_max;\n    let mut col_max = col_max;\n    for i in 0..grid.len() {\n \
    \       for j in 0..grid[i].len() {\n            if grid[i][j] == 1 {\n      \
    \          let min = row_max[i].min(col_max[j]);\n                if min < capacity\
    \ {\n                    count += capacity - min;\n                }\n       \
    \     }\n        }\n    }\n    count", "    let mut result = 0;\n    let mut max_height\
    \ = 0;\n    for row in grid {\n        let mut height = 0;\n        for cell in\
    \ row {\n            if cell == 1 {\n                height += 1;\n          \
    \  }\n        }\n        if height > max_height {\n            result += height\
    \ - max_height;\n            max_height = height;\n        }\n    }\n    result",
  "    let mut result = 0;\n    let mut max_height = 0;\n    for row in grid {\n \
    \       let mut height = 0;\n        for &well in row.iter() {\n            if\
    \ well == 1 {\n                height += 1;\n            } else {\n          \
    \      if height > max_height {\n                    max_height = height;\n  \
    \              }\n                height = 0;\n            }\n        }\n    \
    \    if height > max_height {\n            max_height = height;\n        }\n \
    \   }\n    for row in grid {\n        let mut height = 0;\n        for &well in\
    \ row.iter() {\n            if well == 1 {\n                height += 1;\n   \
    \         } else {\n                result += max_height - height;\n         \
    \       height = 0;\n            }\n        }\n        result += max_height -\
    \ height;\n    }\n    result", "    let mut count = 0;\n    let mut max_height\
    \ = 0;\n    for row in grid {\n        let mut height = 0;\n        for well in\
    \ row {\n            if well == 1 {\n                height += 1;\n          \
    \  }\n        }\n        if height > max_height {\n            max_height = height;\n\
    \        }\n    }\n    for row in grid {\n        let mut height = 0;\n      \
    \  for well in row {\n            if well == 1 {\n                height += 1;\n\
    \            }\n        }\n        if height < max_height {\n            count\
    \ += max_height - height;\n        }\n    }\n    count", "    let mut count =\
    \ 0;\n    let mut grid = grid;\n    let mut row_max = vec![0; grid.len()];\n \
    \   for i in 0..grid.len() {\n        for j in 0..grid[i].len() {\n          \
    \  if grid[i][j] == 1 {\n                row_max[i] = j;\n            }\n    \
    \    }\n    }\n    let mut col_max = vec![0; grid[0].len()];\n    for j in 0..grid[0].len()\
    \ {\n        for i in 0..grid.len() {\n            if grid[i][j] == 1 {\n    \
    \            col_max[j] = i;\n            }\n        }\n    }\n    for i in 0..grid.len()\
    \ {\n        for j in 0..grid[i].len() {\n            if grid[i][j] == 1 {\n \
    \               count += 1;\n                let mut row_max_i = row_max[i];\n\
    \                let mut col_max_j = col_max[j];\n                for k in i..row_max_i\
    \ + 1 {\n                    for l in j..col_max_j + 1 {\n                   \
    \     grid[k][l] = 0;\n                    }\n                }\n            \
    \    for k in 0..grid.len() {\n                    for l in 0..grid[k].len() {\n\
    \                        if grid[k][l] == 1 {\n                            row_max[k]\
    \ = l;\n                        }\n                    }\n                }\n\
    \                for k in 0..grid[0].len() {\n                    for l in 0..grid.len()\
    \ {\n                        if grid[l][k] == 1 {\n                          \
    \  col_max[k] = l;\n                        }\n                    }\n       \
    \         }\n            }\n        }\n    }\n    count", "    let mut count =\
    \ 0;\n    let mut grid = grid;\n    let mut row_max = vec![0; grid.len()];\n \
    \   let mut col_max = vec![0; grid[0].len()];\n    for i in 0..grid.len() {\n\
    \        for j in 0..grid[i].len() {\n            if grid[i][j] == 1 {\n     \
    \           row_max[i] += 1;\n                col_max[j] += 1;\n            }\n\
    \        }\n    }\n    let mut row_max = row_max;\n    let mut col_max = col_max;\n\
    \    loop {\n        let mut changed = false;\n        for i in 0..grid.len()\
    \ {\n            for j in 0..grid[i].len() {\n                if grid[i][j] ==\
    \ 1 && row_max[i] + col_max[j] - 1 <= capacity {\n                    grid[i][j]\
    \ = 0;\n                    row_max[i] -= 1;\n                    col_max[j] -=\
    \ 1;\n                    changed = true;\n                }\n            }\n\
    \        }\n        if !changed {\n            break;\n        }\n        count\
    \ += 1;\n    }\n    count", "    let mut wells = grid.iter().map(|row| row.iter().sum::<isize>()).collect::<Vec<isize>>();\n\
    \    let mut count = 0;\n    let mut i = 0;\n    while i < wells.len() {\n   \
    \     if wells[i] > capacity {\n            wells[i] -= capacity;\n          \
    \  count += 1;\n        } else {\n            i += 1;\n        }\n    }\n    count",
  "    let mut max_fill = 0;\n    for row in grid {\n        let mut fill = 0;\n \
    \       for well in row {\n            if well == 1 {\n                fill +=\
    \ 1;\n            } else {\n                if fill > 0 {\n                  \
    \  max_fill += 1;\n                    fill = 0;\n                }\n        \
    \    }\n        }\n        if fill > 0 {\n            max_fill += 1;\n       \
    \ }\n    }\n    max_fill", "    let mut count = 0;\n    let mut grid = grid;\n\
    \    let mut row_max = vec![0; grid.len()];\n    for row in 0..grid.len() {\n\
    \        for col in 0..grid[row].len() {\n            if grid[row][col] == 1 {\n\
    \                row_max[row] = col;\n            }\n        }\n    }\n    let\
    \ mut col_max = vec![0; grid[0].len()];\n    for col in 0..grid[0].len() {\n \
    \       for row in 0..grid.len() {\n            if grid[row][col] == 1 {\n   \
    \             col_max[col] = row;\n            }\n        }\n    }\n    let mut\
    \ row_max_iter = row_max.iter();\n    let mut col_max_iter = col_max.iter();\n\
    \    let mut row_max = row_max_iter.next().unwrap();\n    let mut col_max = col_max_iter.next().unwrap();\n\
    \    while row_max != &0 || col_max != &0 {\n        let mut row_max_copy = *row_max;\n\
    \        let mut col_max_copy = *col_max;\n        for row in 0..*col_max + 1\
    \ {\n            for col in 0..*row_max + 1 {\n                if grid[row][col]\
    \ == 1 {\n                    grid[row][col] = 0;\n                    count +=\
    \ 1;\n                }\n            }\n        }\n        row_max = row_max_iter.next().unwrap_or(&0);\n\
    \        col_max = col_max_iter.next().unwrap_or(&0);\n        if row_max_copy\
    \ > *row_max {\n            row_max = &row_max_copy;\n        }\n        if col_max_copy\
    \ > *col_max {\n            col_max = &col_max_copy;\n        }\n    }\n    count"]
stop_tokens:
- "\n}"
