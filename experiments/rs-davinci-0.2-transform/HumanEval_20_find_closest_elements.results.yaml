language: rs
name: HumanEval_20_find_closest_elements
results:
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = closest_pair.1 - closest_pair.0;\n    for i in\
    \ 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n            let\
    \ distance = numbers[j] - numbers[i];\n            if distance < closest_distance\
    \ {\n                closest_pair = (numbers[i], numbers[j]);\n              \
    \  closest_distance = distance;\n            }\n        }\n    }\n    closest_pair\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmplvf_jjre.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 0
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut numbers = numbers;\n    numbers.sort_by(|a,\
    \ b| a.partial_cmp(b).unwrap());\n    let mut min_diff = numbers[1] - numbers[0];\n\
    \    let mut min_pair = (numbers[0], numbers[1]);\n    for i in 1..numbers.len()\
    \ - 1 {\n        let diff = numbers[i + 1] - numbers[i];\n        if diff < min_diff\
    \ {\n            min_diff = diff;\n            min_pair = (numbers[i], numbers[i\
    \ + 1]);\n        }\n    }\n    min_pair\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in\
    \ 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n            let\
    \ distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_distance = distance;\n                closest_elements\
    \ = (numbers[i], numbers[j]);\n            }\n        }\n    }\n    closest_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpstya4n5x.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min_diff = f64::MAX;\n    let mut closest_pair\
    \ = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            let diff = (numbers[i] - numbers[j]).abs();\n            if diff\
    \ < min_diff {\n                min_diff = diff;\n                closest_pair\
    \ = (numbers[i], numbers[j]);\n            }\n        }\n    }\n    closest_pair\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmp20ted4y5.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min_distance = std::f64::MAX;\n    let\
    \ mut closest_pair = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for\
    \ j in i + 1..numbers.len() {\n            let distance = (numbers[i] - numbers[j]).abs();\n\
    \            if distance < min_distance {\n                min_distance = distance;\n\
    \                closest_pair = (numbers[i], numbers[j]);\n            }\n   \
    \     }\n    }\n    closest_pair\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpypcqzchw.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min_diff = std::f64::MAX;\n    let mut\
    \ min_pair = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in i\
    \ + 1..numbers.len() {\n            let diff = (numbers[i] - numbers[j]).abs();\n\
    \            if diff < min_diff {\n                min_diff = diff;\n        \
    \        min_pair = (numbers[i], numbers[j]);\n            }\n        }\n    }\n\
    \    min_pair\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmp3fym7hj0.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = closest_elements.1 - closest_elements.0;\n   \
    \ for i in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n     \
    \       let distance = numbers[j] - numbers[i];\n            if distance < closest_distance\
    \ {\n                closest_elements = (numbers[i], numbers[j]);\n          \
    \      closest_distance = distance;\n            }\n        }\n    }\n    closest_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmp3p8mn86d.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = closest_elements.1 - closest_elements.0;\n   \
    \ for i in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n     \
    \       let distance = numbers[j] - numbers[i];\n            if distance < closest_distance\
    \ {\n                closest_elements = (numbers[i], numbers[j]);\n          \
    \      closest_distance = distance;\n            }\n        }\n    }\n    closest_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmp3p8mn86d.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min_diff = f64::MAX;\n    let mut min_pair\
    \ = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            let diff = (numbers[i] - numbers[j]).abs();\n            if diff\
    \ < min_diff {\n                min_diff = diff;\n                min_pair = (numbers[i],\
    \ numbers[j]);\n            }\n        }\n    }\n    min_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpeh6dif4v.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = closest_pair.1 - closest_pair.0;\n    for i in\
    \ 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n            let\
    \ distance = numbers[j] - numbers[i];\n            if distance < closest_distance\
    \ {\n                closest_pair = (numbers[i], numbers[j]);\n              \
    \  closest_distance = distance;\n            }\n        }\n    }\n    closest_pair\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmplvf_jjre.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min_diff = std::f64::MAX;\n    let mut\
    \ min_pair = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in i\
    \ + 1..numbers.len() {\n            let diff = (numbers[i] - numbers[j]).abs();\n\
    \            if diff < min_diff {\n                min_diff = diff;\n        \
    \        min_pair = (numbers[i], numbers[j]);\n            }\n        }\n    }\n\
    \    min_pair\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmp3fym7hj0.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in\
    \ 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n            let\
    \ distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_pair = (numbers[i], numbers[j]);\n              \
    \  closest_distance = distance;\n            }\n        }\n    }\n    closest_pair\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpbd6j4x07.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = closest_elements.1 - closest_elements.0;\n   \
    \ for i in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n     \
    \       let distance = numbers[j] - numbers[i];\n            if distance < closest_distance\
    \ {\n                closest_elements = (numbers[i], numbers[j]);\n          \
    \      closest_distance = distance;\n            }\n        }\n    }\n    closest_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmp3p8mn86d.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in\
    \ 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n            let\
    \ distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_distance = distance;\n                closest_pair\
    \ = (numbers[i], numbers[j]);\n            }\n        }\n    }\n    closest_pair\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpgae0_fql.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min_diff = std::f64::MAX;\n    let mut\
    \ min_pair = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in i\
    \ + 1..numbers.len() {\n            let diff = (numbers[i] - numbers[j]).abs();\n\
    \            if diff < min_diff {\n                min_diff = diff;\n        \
    \        min_pair = (numbers[i], numbers[j]);\n            }\n        }\n    }\n\
    \    min_pair\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmp3fym7hj0.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    // TODO: implement this function\n    unimplemented!();\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmps_rzzqxu.rs:9:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min_diff = f64::MAX;\n    let mut min_pair\
    \ = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            let diff = (numbers[i] - numbers[j]).abs();\n            if diff\
    \ < min_diff {\n                min_diff = diff;\n                min_pair = (numbers[i],\
    \ numbers[j]);\n            }\n        }\n    }\n    min_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpeh6dif4v.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in\
    \ 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n            let\
    \ distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_distance = distance;\n                closest_elements\
    \ = (numbers[i], numbers[j]);\n            }\n        }\n    }\n    closest_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpstya4n5x.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = closest_pair.1 - closest_pair.0;\n    for i in\
    \ 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n            let\
    \ distance = numbers[j] - numbers[i];\n            if distance < closest_distance\
    \ {\n                closest_pair = (numbers[i], numbers[j]);\n              \
    \  closest_distance = distance;\n            }\n        }\n    }\n    closest_pair\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmplvf_jjre.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_numbers = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n\n    for i\
    \ in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n           \
    \ let distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_numbers = (numbers[i], numbers[j]);\n           \
    \     closest_distance = distance;\n            }\n        }\n    }\n\n    closest_numbers\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpw2qkhs3e.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_elements: (f64, f64) = (numbers[0],\
    \ numbers[1]);\n    let mut closest_distance: f64 = closest_elements.1 - closest_elements.0;\n\
    \    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n  \
    \          let distance = numbers[j] - numbers[i];\n            if distance <\
    \ closest_distance {\n                closest_elements = (numbers[i], numbers[j]);\n\
    \                closest_distance = distance;\n            }\n        }\n    }\n\
    \    closest_elements\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpew5y0o65.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_elements: (f64, f64) = (numbers[0],\
    \ numbers[1]);\n    let mut closest_distance: f64 = (numbers[0] - numbers[1]).abs();\n\
    \    for i in 0..numbers.len() - 1 {\n        for j in i + 1..numbers.len() {\n\
    \            let distance = (numbers[i] - numbers[j]).abs();\n            if distance\
    \ < closest_distance {\n                closest_elements = (numbers[i], numbers[j]);\n\
    \                closest_distance = distance;\n            }\n        }\n    }\n\
    \    closest_elements\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmp_80n_p8l.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min_diff = std::f64::MAX;\n    let mut\
    \ min_pair = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in i\
    \ + 1..numbers.len() {\n            let diff = (numbers[i] - numbers[j]).abs();\n\
    \            if diff < min_diff {\n                min_diff = diff;\n        \
    \        min_pair = (numbers[i], numbers[j]);\n            }\n        }\n    }\n\
    \    min_pair\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmp3fym7hj0.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min_diff = f64::MAX;\n    let mut min_pair\
    \ = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            let diff = (numbers[i] - numbers[j]).abs();\n            if diff\
    \ < min_diff {\n                min_diff = diff;\n                min_pair = (numbers[i],\
    \ numbers[j]);\n            }\n        }\n    }\n    min_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpeh6dif4v.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in\
    \ 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n            let\
    \ distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_distance = distance;\n                closest_elements\
    \ = (numbers[i], numbers[j]);\n            }\n        }\n    }\n    closest_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpstya4n5x.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = closest_pair.1 - closest_pair.0;\n    for i in\
    \ 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n            let\
    \ distance = numbers[j] - numbers[i];\n            if distance < closest_distance\
    \ {\n                closest_pair = (numbers[i], numbers[j]);\n              \
    \  closest_distance = distance;\n            }\n        }\n    }\n    closest_pair\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmplvf_jjre.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = closest_pair.1 - closest_pair.0;\n    for i in\
    \ 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n            let\
    \ distance = numbers[j] - numbers[i];\n            if distance < closest_distance\
    \ {\n                closest_pair = (numbers[i], numbers[j]);\n              \
    \  closest_distance = distance;\n            }\n        }\n    }\n    closest_pair\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmplvf_jjre.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in\
    \ 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n            let\
    \ distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_pair = (numbers[i], numbers[j]);\n              \
    \  closest_distance = distance;\n            }\n        }\n    }\n    closest_pair\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpbd6j4x07.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = closest_pair.1 - closest_pair.0;\n    for i in\
    \ 0..numbers.len() {\n        for j in i+1..numbers.len() {\n            let distance\
    \ = numbers[j] - numbers[i];\n            if distance < closest_distance {\n \
    \               closest_pair = (numbers[i], numbers[j]);\n                closest_distance\
    \ = distance;\n            }\n        }\n    }\n    closest_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmp9rw4in3x.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_numbers = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n\n    for i\
    \ in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n           \
    \ let distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_numbers = (numbers[i], numbers[j]);\n           \
    \     closest_distance = distance;\n            }\n        }\n    }\n\n    closest_numbers\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpw2qkhs3e.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = closest_pair.1 - closest_pair.0;\n    for i in\
    \ 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n            let\
    \ distance = numbers[j] - numbers[i];\n            if distance < closest_distance\
    \ {\n                closest_pair = (numbers[i], numbers[j]);\n              \
    \  closest_distance = distance;\n            }\n        }\n    }\n    closest_pair\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmplvf_jjre.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in\
    \ 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n            let\
    \ distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_pair = (numbers[i], numbers[j]);\n              \
    \  closest_distance = distance;\n            }\n        }\n    }\n    closest_pair\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpbd6j4x07.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = closest_pair.1 - closest_pair.0;\n    for i in\
    \ 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n            let\
    \ distance = numbers[j] - numbers[i];\n            if distance < closest_distance\
    \ {\n                closest_pair = (numbers[i], numbers[j]);\n              \
    \  closest_distance = distance;\n            }\n        }\n    }\n    closest_pair\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmplvf_jjre.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in\
    \ 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n            let\
    \ distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_pair = (numbers[i], numbers[j]);\n              \
    \  closest_distance = distance;\n            }\n        }\n    }\n    closest_pair\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpbd6j4x07.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in\
    \ 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n            let\
    \ distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_distance = distance;\n                closest_pair\
    \ = (numbers[i], numbers[j]);\n            }\n        }\n    }\n    closest_pair\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpgae0_fql.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in\
    \ 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n            let\
    \ distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_distance = distance;\n                closest_pair\
    \ = (numbers[i], numbers[j]);\n            }\n        }\n    }\n    closest_pair\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpgae0_fql.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in\
    \ 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n            let\
    \ distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_distance = distance;\n                closest_pair\
    \ = (numbers[i], numbers[j]);\n            }\n        }\n    }\n    closest_pair\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpgae0_fql.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min_diff = std::f64::MAX;\n    let mut\
    \ min_pair = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in i\
    \ + 1..numbers.len() {\n            let diff = (numbers[i] - numbers[j]).abs();\n\
    \            if diff < min_diff {\n                min_diff = diff;\n        \
    \        min_pair = (numbers[i], numbers[j]);\n            }\n        }\n    }\n\
    \    min_pair\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmp3fym7hj0.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in\
    \ 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n            let\
    \ distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_distance = distance;\n                closest_pair\
    \ = (numbers[i], numbers[j]);\n            }\n        }\n    }\n    closest_pair\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpgae0_fql.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in\
    \ 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n            let\
    \ distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_pair = (numbers[i], numbers[j]);\n              \
    \  closest_distance = distance;\n            }\n        }\n    }\n    closest_pair\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpbd6j4x07.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min_distance = std::f64::MAX;\n    let\
    \ mut closest_elements = (0.0, 0.0);\n    for i in 0..numbers.len() {\n      \
    \  for j in i + 1..numbers.len() {\n            let distance = (numbers[i] - numbers[j]).abs();\n\
    \            if distance < min_distance {\n                min_distance = distance;\n\
    \                closest_elements = (numbers[i], numbers[j]);\n            }\n\
    \        }\n    }\n    closest_elements\n}\n\nfn main() {\n    let candidate =\
    \ find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]),\
    \ (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]),\
    \ (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]),\
    \ (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2,\
    \ 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpw2u3j4k4.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min_diff = f64::MAX;\n    let mut min_pair\
    \ = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            let diff = (numbers[i] - numbers[j]).abs();\n            if diff\
    \ < min_diff {\n                min_diff = diff;\n                min_pair = (numbers[i],\
    \ numbers[j]);\n            }\n        }\n    }\n    min_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpeh6dif4v.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_elements: (f64, f64) = (numbers[0],\
    \ numbers[1]);\n    let mut closest_distance: f64 = (numbers[0] - numbers[1]).abs();\n\
    \    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n  \
    \          let distance = (numbers[i] - numbers[j]).abs();\n            if distance\
    \ < closest_distance {\n                closest_elements = (numbers[i], numbers[j]);\n\
    \                closest_distance = distance;\n            }\n        }\n    }\n\
    \    closest_elements\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpplg5gxv5.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min_distance = std::f64::MAX;\n    let\
    \ mut closest_elements = (0.0, 0.0);\n    for i in 0..numbers.len() {\n      \
    \  for j in i + 1..numbers.len() {\n            let distance = (numbers[i] - numbers[j]).abs();\n\
    \            if distance < min_distance {\n                min_distance = distance;\n\
    \                closest_elements = (numbers[i], numbers[j]);\n            }\n\
    \        }\n    }\n    closest_elements\n}\n\nfn main() {\n    let candidate =\
    \ find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]),\
    \ (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]),\
    \ (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]),\
    \ (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2,\
    \ 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpw2u3j4k4.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = closest_pair.1 - closest_pair.0;\n    for i in\
    \ 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n            let\
    \ distance = numbers[j] - numbers[i];\n            if distance < closest_distance\
    \ {\n                closest_pair = (numbers[i], numbers[j]);\n              \
    \  closest_distance = distance;\n            }\n        }\n    }\n    closest_pair\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmplvf_jjre.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in\
    \ 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n            let\
    \ distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_pair = (numbers[i], numbers[j]);\n              \
    \  closest_distance = distance;\n            }\n        }\n    }\n    closest_pair\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpbd6j4x07.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n\
    \    let mut smallest_difference = (numbers[1] - numbers[0]).abs();\n    for i\
    \ in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n           \
    \ let difference = (numbers[j] - numbers[i]).abs();\n            if difference\
    \ < smallest_difference {\n                smallest_difference = difference;\n\
    \                closest_pair = (numbers[i], numbers[j]);\n            }\n   \
    \     }\n    }\n    closest_pair\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmp95b27r6_.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in\
    \ 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n            let\
    \ distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_distance = distance;\n                closest_pair\
    \ = (numbers[i], numbers[j]);\n            }\n        }\n    }\n    closest_pair\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpgae0_fql.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in\
    \ 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n            let\
    \ distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_pair = (numbers[i], numbers[j]);\n              \
    \  closest_distance = distance;\n            }\n        }\n    }\n    closest_pair\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpbd6j4x07.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in\
    \ 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n            let\
    \ distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_distance = distance;\n                closest_elements\
    \ = (numbers[i], numbers[j]);\n            }\n        }\n    }\n    closest_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpstya4n5x.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min_diff = std::f64::MAX;\n    let mut\
    \ closest_pair = (0.0, 0.0);\n    for i in 0..numbers.len() - 1 {\n        for\
    \ j in i + 1..numbers.len() {\n            let diff = (numbers[i] - numbers[j]).abs();\n\
    \            if diff < min_diff {\n                min_diff = diff;\n        \
    \        closest_pair = (numbers[i], numbers[j]);\n            }\n        }\n\
    \    }\n    closest_pair\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpfnyv3a24.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min_diff = std::f64::MAX;\n    let mut\
    \ min_pair = (0.0, 0.0);\n    for (i, x) in numbers.iter().enumerate() {\n   \
    \     for y in numbers.iter().skip(i + 1) {\n            let diff = (x - y).abs();\n\
    \            if diff < min_diff {\n                min_diff = diff;\n        \
    \        min_pair = (*x, *y);\n            }\n        }\n    }\n    min_pair\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpyr4js0nt.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in\
    \ 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n            let\
    \ distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_pair = (numbers[i], numbers[j]);\n              \
    \  closest_distance = distance;\n            }\n        }\n    }\n    closest_pair\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpbd6j4x07.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in\
    \ 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n            let\
    \ distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_elements = (numbers[i], numbers[j]);\n          \
    \      closest_distance = distance;\n            }\n        }\n    }\n    closest_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpy_e2jh04.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in\
    \ 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n            let\
    \ distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_distance = distance;\n                closest_elements\
    \ = (numbers[i], numbers[j]);\n            }\n        }\n    }\n    closest_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpstya4n5x.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in\
    \ 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n            let\
    \ distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_distance = distance;\n                closest_pair\
    \ = (numbers[i], numbers[j]);\n            }\n        }\n    }\n    closest_pair\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpgae0_fql.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_elements: (f64, f64) = (numbers[0],\
    \ numbers[1]);\n    let mut closest_distance: f64 = numbers[1] - numbers[0];\n\
    \    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n  \
    \          let distance = numbers[j] - numbers[i];\n            if distance <\
    \ closest_distance {\n                closest_elements = (numbers[i], numbers[j]);\n\
    \                closest_distance = distance;\n            }\n        }\n    }\n\
    \    closest_elements\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmp4v46y4pw.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min_distance = f64::INFINITY;\n    let\
    \ mut min_pair = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in\
    \ i + 1..numbers.len() {\n            let distance = (numbers[i] - numbers[j]).abs();\n\
    \            if distance < min_distance {\n                min_distance = distance;\n\
    \                min_pair = (numbers[i], numbers[j]);\n            }\n       \
    \ }\n    }\n    min_pair\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpjp1goglv.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min_distance = numbers[1] - numbers[0];\n\
    \    let mut min_pair = (numbers[0], numbers[1]);\n    for i in 0..numbers.len()\
    \ {\n        for j in i + 1..numbers.len() {\n            let distance = numbers[j]\
    \ - numbers[i];\n            if distance < min_distance {\n                min_distance\
    \ = distance;\n                min_pair = (numbers[i], numbers[j]);\n        \
    \    }\n        }\n    }\n    min_pair\n}\n\nfn main() {\n    let candidate =\
    \ find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]),\
    \ (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]),\
    \ (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]),\
    \ (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2,\
    \ 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpno7gvuro.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_elements: (f64, f64) = (numbers[0],\
    \ numbers[1]);\n    let mut closest_distance: f64 = (numbers[0] - numbers[1]).abs();\n\
    \    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n  \
    \          let distance = (numbers[i] - numbers[j]).abs();\n            if distance\
    \ < closest_distance {\n                closest_elements = (numbers[i], numbers[j]);\n\
    \                closest_distance = distance;\n            }\n        }\n    }\n\
    \    closest_elements\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpplg5gxv5.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in\
    \ 0..numbers.len() - 1 {\n        for j in i + 1..numbers.len() {\n          \
    \  let distance = (numbers[j] - numbers[i]).abs();\n            if distance <\
    \ closest_distance {\n                closest_distance = distance;\n         \
    \       closest_pair = (numbers[i], numbers[j]);\n            }\n        }\n \
    \   }\n    closest_pair\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmph79hbje3.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in\
    \ 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n            let\
    \ distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_pair = (numbers[i], numbers[j]);\n              \
    \  closest_distance = distance;\n            }\n        }\n    }\n    closest_pair\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpbd6j4x07.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min_diff = f64::MAX;\n    let mut min_pair\
    \ = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            let diff = (numbers[i] - numbers[j]).abs();\n            if diff\
    \ < min_diff {\n                min_diff = diff;\n                min_pair = (numbers[i],\
    \ numbers[j]);\n            }\n        }\n    }\n    min_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpeh6dif4v.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = closest_pair.1 - closest_pair.0;\n    for i in\
    \ 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n            let\
    \ distance = numbers[j] - numbers[i];\n            if distance < closest_distance\
    \ {\n                closest_pair = (numbers[i], numbers[j]);\n              \
    \  closest_distance = distance;\n            }\n        }\n    }\n    closest_pair\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmplvf_jjre.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_elements: (f64, f64) = (numbers[0],\
    \ numbers[1]);\n    let mut closest_distance: f64 = closest_elements.1 - closest_elements.0;\n\
    \    for i in 0..numbers.len() - 1 {\n        for j in i + 1..numbers.len() {\n\
    \            let distance = numbers[j] - numbers[i];\n            if distance\
    \ < closest_distance {\n                closest_elements = (numbers[i], numbers[j]);\n\
    \                closest_distance = distance;\n            }\n        }\n    }\n\
    \    closest_elements\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpykcc717b.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min_distance = std::f64::MAX;\n    let\
    \ mut result = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in\
    \ i + 1..numbers.len() {\n            let distance = (numbers[i] - numbers[j]).abs();\n\
    \            if distance < min_distance {\n                min_distance = distance;\n\
    \                result = (numbers[i], numbers[j]);\n            }\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmprqk4pxmq.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min_diff = std::f64::MAX;\n    let mut\
    \ min_pair = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in i\
    \ + 1..numbers.len() {\n            let diff = (numbers[i] - numbers[j]).abs();\n\
    \            if diff < min_diff {\n                min_diff = diff;\n        \
    \        min_pair = (numbers[i], numbers[j]);\n            }\n        }\n    }\n\
    \    min_pair\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmp3fym7hj0.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in\
    \ 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n            let\
    \ distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_distance = distance;\n                closest_pair\
    \ = (numbers[i], numbers[j]);\n            }\n        }\n    }\n    closest_pair\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpgae0_fql.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in\
    \ 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n            let\
    \ distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_pair = (numbers[i], numbers[j]);\n              \
    \  closest_distance = distance;\n            }\n        }\n    }\n    closest_pair\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpbd6j4x07.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min_diff = std::f64::MAX;\n    let mut\
    \ closest_pair = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in\
    \ i + 1..numbers.len() {\n            let diff = (numbers[i] - numbers[j]).abs();\n\
    \            if diff < min_diff {\n                min_diff = diff;\n        \
    \        closest_pair = (numbers[i], numbers[j]);\n            }\n        }\n\
    \    }\n    closest_pair\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmp3544a77g.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in\
    \ 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n            let\
    \ distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_distance = distance;\n                closest_elements\
    \ = (numbers[i], numbers[j]);\n            }\n        }\n    }\n    closest_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpstya4n5x.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in\
    \ 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n            let\
    \ distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_pair = (numbers[i], numbers[j]);\n              \
    \  closest_distance = distance;\n            }\n        }\n    }\n    closest_pair\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpbd6j4x07.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min_diff = std::f64::MAX;\n    let mut\
    \ min_pair = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in i\
    \ + 1..numbers.len() {\n            let diff = (numbers[i] - numbers[j]).abs();\n\
    \            if diff < min_diff {\n                min_diff = diff;\n        \
    \        min_pair = (numbers[i], numbers[j]);\n            }\n        }\n    }\n\
    \    min_pair\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmp3fym7hj0.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min_distance = std::f64::MAX;\n    let\
    \ mut closest_elements = (0.0, 0.0);\n    for i in 0..numbers.len() {\n      \
    \  for j in i + 1..numbers.len() {\n            let distance = (numbers[i] - numbers[j]).abs();\n\
    \            if distance < min_distance {\n                min_distance = distance;\n\
    \                closest_elements = (numbers[i], numbers[j]);\n            }\n\
    \        }\n    }\n    closest_elements\n}\n\nfn main() {\n    let candidate =\
    \ find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]),\
    \ (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]),\
    \ (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]),\
    \ (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2,\
    \ 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpw2u3j4k4.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 0
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut numbers = numbers;\n    numbers.sort_by(|a,\
    \ b| a.partial_cmp(b).unwrap());\n    let mut min_diff = numbers[1] - numbers[0];\n\
    \    let mut min_pair = (numbers[0], numbers[1]);\n    for i in 1..numbers.len()\
    \ - 1 {\n        let diff = numbers[i + 1] - numbers[i];\n        if diff < min_diff\
    \ {\n            min_diff = diff;\n            min_pair = (numbers[i], numbers[i\
    \ + 1]);\n        }\n    }\n    min_pair\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min_diff = f64::MAX;\n    let mut min_pair\
    \ = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            let diff = (numbers[i] - numbers[j]).abs();\n            if diff\
    \ < min_diff {\n                min_diff = diff;\n                min_pair = (numbers[i],\
    \ numbers[j]);\n            }\n        }\n    }\n    min_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpeh6dif4v.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min_diff = f64::MAX;\n    let mut min_pair\
    \ = (0.0, 0.0);\n    for (i, x) in numbers.iter().enumerate() {\n        for y\
    \ in numbers.iter().skip(i + 1) {\n            let diff = (x - y).abs();\n   \
    \         if diff < min_diff {\n                min_diff = diff;\n           \
    \     min_pair = (*x, *y);\n            }\n        }\n    }\n    min_pair\n}\n\
    \nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmp5mdzltgc.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in\
    \ 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n            let\
    \ distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_distance = distance;\n                closest_elements\
    \ = (numbers[i], numbers[j]);\n            }\n        }\n    }\n    closest_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpstya4n5x.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in\
    \ 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n            let\
    \ distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_distance = distance;\n                closest_elements\
    \ = (numbers[i], numbers[j]);\n            }\n        }\n    }\n    closest_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpstya4n5x.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in\
    \ 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n            let\
    \ distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_distance = distance;\n                closest_pair\
    \ = (numbers[i], numbers[j]);\n            }\n        }\n    }\n    closest_pair\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpgae0_fql.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in\
    \ 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n            let\
    \ distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_elements = (numbers[i], numbers[j]);\n          \
    \      closest_distance = distance;\n            }\n        }\n    }\n    closest_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpy_e2jh04.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in\
    \ 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n            let\
    \ distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_distance = distance;\n                closest_pair\
    \ = (numbers[i], numbers[j]);\n            }\n        }\n    }\n    closest_pair\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpgae0_fql.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min_distance = std::f64::MAX;\n    let\
    \ mut closest_elements = (0.0, 0.0);\n    for i in 0..numbers.len() {\n      \
    \  for j in i + 1..numbers.len() {\n            let distance = (numbers[i] - numbers[j]).abs();\n\
    \            if distance < min_distance {\n                min_distance = distance;\n\
    \                closest_elements = (numbers[i], numbers[j]);\n            }\n\
    \        }\n    }\n    closest_elements\n}\n\nfn main() {\n    let candidate =\
    \ find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]),\
    \ (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]),\
    \ (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]),\
    \ (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2,\
    \ 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpw2u3j4k4.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_elements: (f64, f64) = (numbers[0],\
    \ numbers[1]);\n    let mut closest_difference: f64 = (numbers[1] - numbers[0]).abs();\n\
    \    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n  \
    \          let difference = (numbers[j] - numbers[i]).abs();\n            if difference\
    \ < closest_difference {\n                closest_elements = (numbers[i], numbers[j]);\n\
    \                closest_difference = difference;\n            }\n        }\n\
    \    }\n    closest_elements\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmp_75qskc7.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in\
    \ 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n            let\
    \ distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_distance = distance;\n                closest_pair\
    \ = (numbers[i], numbers[j]);\n            }\n        }\n    }\n    closest_pair\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpgae0_fql.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_elements: (f64, f64) = (numbers[0],\
    \ numbers[1]);\n    let mut closest_distance: f64 = (numbers[0] - numbers[1]).abs();\n\
    \    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n  \
    \          let distance = (numbers[i] - numbers[j]).abs();\n            if distance\
    \ < closest_distance {\n                closest_elements = (numbers[i], numbers[j]);\n\
    \                closest_distance = distance;\n            }\n        }\n    }\n\
    \    closest_elements\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpplg5gxv5.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in\
    \ 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n            let\
    \ distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_distance = distance;\n                closest_pair\
    \ = (numbers[i], numbers[j]);\n            }\n        }\n    }\n    closest_pair\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpgae0_fql.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in\
    \ 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n            let\
    \ distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_distance = distance;\n                closest_elements\
    \ = (numbers[i], numbers[j]);\n            }\n        }\n    }\n    closest_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpstya4n5x.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in\
    \ 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n            let\
    \ distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_distance = distance;\n                closest_pair\
    \ = (numbers[i], numbers[j]);\n            }\n        }\n    }\n    closest_pair\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpgae0_fql.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in\
    \ 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n            let\
    \ distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_distance = distance;\n                closest_pair\
    \ = (numbers[i], numbers[j]);\n            }\n        }\n    }\n    closest_pair\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpgae0_fql.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min_diff = std::f64::MAX;\n    let mut\
    \ min_pair = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in i\
    \ + 1..numbers.len() {\n            let diff = (numbers[i] - numbers[j]).abs();\n\
    \            if diff < min_diff {\n                min_diff = diff;\n        \
    \        min_pair = (numbers[i], numbers[j]);\n            }\n        }\n    }\n\
    \    min_pair\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmp3fym7hj0.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in\
    \ 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n            let\
    \ distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_elements = (numbers[i], numbers[j]);\n          \
    \      closest_distance = distance;\n            }\n        }\n    }\n    closest_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpy_e2jh04.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in\
    \ 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n            let\
    \ distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_distance = distance;\n                closest_pair\
    \ = (numbers[i], numbers[j]);\n            }\n        }\n    }\n    closest_pair\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpgae0_fql.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in\
    \ 0..numbers.len() - 1 {\n        for j in i + 1..numbers.len() {\n          \
    \  let distance = (numbers[j] - numbers[i]).abs();\n            if distance <\
    \ closest_distance {\n                closest_distance = distance;\n         \
    \       closest_pair = (numbers[i], numbers[j]);\n            }\n        }\n \
    \   }\n    closest_pair\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmph79hbje3.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min_distance = std::f64::MAX;\n    let\
    \ mut closest_elements = (0.0, 0.0);\n    for i in 0..numbers.len() {\n      \
    \  for j in i + 1..numbers.len() {\n            let distance = (numbers[i] - numbers[j]).abs();\n\
    \            if distance < min_distance {\n                min_distance = distance;\n\
    \                closest_elements = (numbers[i], numbers[j]);\n            }\n\
    \        }\n    }\n    closest_elements\n}\n\nfn main() {\n    let candidate =\
    \ find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]),\
    \ (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]),\
    \ (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]),\
    \ (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2,\
    \ 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpw2u3j4k4.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min_diff = f64::MAX;\n    let mut min_pair\
    \ = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            let diff = (numbers[i] - numbers[j]).abs();\n            if diff\
    \ < min_diff {\n                min_diff = diff;\n                min_pair = (numbers[i],\
    \ numbers[j]);\n            }\n        }\n    }\n    min_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpeh6dif4v.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = closest_pair.1 - closest_pair.0;\n    for i in\
    \ 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n            let\
    \ distance = numbers[j] - numbers[i];\n            if distance < closest_distance\
    \ {\n                closest_pair = (numbers[i], numbers[j]);\n              \
    \  closest_distance = distance;\n            }\n        }\n    }\n    closest_pair\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmplvf_jjre.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_elements: (f64, f64) = (numbers[0],\
    \ numbers[1]);\n    let mut closest_distance: f64 = (numbers[0] - numbers[1]).abs();\n\
    \    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n  \
    \          let distance = (numbers[i] - numbers[j]).abs();\n            if distance\
    \ < closest_distance {\n                closest_elements = (numbers[i], numbers[j]);\n\
    \                closest_distance = distance;\n            }\n        }\n    }\n\
    \    closest_elements\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpplg5gxv5.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min_distance = f64::INFINITY;\n    let\
    \ mut closest_elements = (0.0, 0.0);\n    for i in 0..numbers.len() {\n      \
    \  for j in i + 1..numbers.len() {\n            let distance = (numbers[i] - numbers[j]).abs();\n\
    \            if distance < min_distance {\n                min_distance = distance;\n\
    \                closest_elements = (numbers[i], numbers[j]);\n            }\n\
    \        }\n    }\n    closest_elements\n}\n\nfn main() {\n    let candidate =\
    \ find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]),\
    \ (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]),\
    \ (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]),\
    \ (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2,\
    \ 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmp3d8dw4q7.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in\
    \ 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n            let\
    \ distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_distance = distance;\n                closest_pair\
    \ = (numbers[i], numbers[j]);\n            }\n        }\n    }\n    closest_pair\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpgae0_fql.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_elements: (f64, f64) = (numbers[0],\
    \ numbers[1]);\n    let mut closest_difference: f64 = (numbers[1] - numbers[0]).abs();\n\
    \    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n  \
    \          let difference = (numbers[j] - numbers[i]).abs();\n            if difference\
    \ < closest_difference {\n                closest_elements = (numbers[i], numbers[j]);\n\
    \                closest_difference = difference;\n            }\n        }\n\
    \    }\n    closest_elements\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmp_75qskc7.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = closest_pair.1 - closest_pair.0;\n    for i in\
    \ 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n            let\
    \ distance = numbers[j] - numbers[i];\n            if distance < closest_distance\
    \ {\n                closest_pair = (numbers[i], numbers[j]);\n              \
    \  closest_distance = distance;\n            }\n        }\n    }\n    closest_pair\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmplvf_jjre.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in\
    \ 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n            let\
    \ distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_distance = distance;\n                closest_elements\
    \ = (numbers[i], numbers[j]);\n            }\n        }\n    }\n    closest_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpstya4n5x.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 0
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut numbers = numbers;\n    numbers.sort_by(|a,\
    \ b| a.partial_cmp(b).unwrap());\n    let mut closest_pair = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = closest_pair.1 - closest_pair.0;\n    for i in\
    \ 0..numbers.len() - 1 {\n        let distance = numbers[i + 1] - numbers[i];\n\
    \        if distance < closest_distance {\n            closest_pair = (numbers[i],\
    \ numbers[i + 1]);\n            closest_distance = distance;\n        }\n    }\n\
    \    closest_pair\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = closest_pair.1 - closest_pair.0;\n    for i in\
    \ 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n            let\
    \ distance = numbers[j] - numbers[i];\n            if distance < closest_distance\
    \ {\n                closest_pair = (numbers[i], numbers[j]);\n              \
    \  closest_distance = distance;\n            }\n        }\n    }\n    closest_pair\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmplvf_jjre.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in\
    \ 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n            let\
    \ distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_distance = distance;\n                closest_pair\
    \ = (numbers[i], numbers[j]);\n            }\n        }\n    }\n    closest_pair\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpgae0_fql.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min_distance = std::f64::MAX;\n    let\
    \ mut closest_elements = (0.0, 0.0);\n    for i in 0..numbers.len() {\n      \
    \  for j in i + 1..numbers.len() {\n            let distance = (numbers[i] - numbers[j]).abs();\n\
    \            if distance < min_distance {\n                min_distance = distance;\n\
    \                closest_elements = (numbers[i], numbers[j]);\n            }\n\
    \        }\n    }\n    closest_elements\n}\n\nfn main() {\n    let candidate =\
    \ find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]),\
    \ (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]),\
    \ (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]),\
    \ (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2,\
    \ 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpw2u3j4k4.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n\
    \    let mut closest_diff = (numbers[1] - numbers[0]).abs();\n    for i in 0..numbers.len()\
    \ {\n        for j in i + 1..numbers.len() {\n            let diff = (numbers[j]\
    \ - numbers[i]).abs();\n            if diff < closest_diff {\n               \
    \ closest_pair = (numbers[i], numbers[j]);\n                closest_diff = diff;\n\
    \            }\n        }\n    }\n    closest_pair\n}\n\nfn main() {\n    let\
    \ candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmp9akofdqr.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min_diff = std::f64::MAX;\n    let mut\
    \ min_pair = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in i\
    \ + 1..numbers.len() {\n            let diff = (numbers[i] - numbers[j]).abs();\n\
    \            if diff < min_diff {\n                min_diff = diff;\n        \
    \        min_pair = (numbers[i], numbers[j]);\n            }\n        }\n    }\n\
    \    min_pair\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmp3fym7hj0.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min_distance = std::f64::MAX;\n    let\
    \ mut closest_elements = (0.0, 0.0);\n    for i in 0..numbers.len() {\n      \
    \  for j in i + 1..numbers.len() {\n            let distance = (numbers[i] - numbers[j]).abs();\n\
    \            if distance < min_distance {\n                min_distance = distance;\n\
    \                closest_elements = (numbers[i], numbers[j]);\n            }\n\
    \        }\n    }\n    closest_elements\n}\n\nfn main() {\n    let candidate =\
    \ find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]),\
    \ (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]),\
    \ (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]),\
    \ (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2,\
    \ 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpw2u3j4k4.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in\
    \ 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n            let\
    \ distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_distance = distance;\n                closest_elements\
    \ = (numbers[i], numbers[j]);\n            }\n        }\n    }\n    closest_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpstya4n5x.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in\
    \ 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n            let\
    \ distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_distance = distance;\n                closest_elements\
    \ = (numbers[i], numbers[j]);\n            }\n        }\n    }\n    closest_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpstya4n5x.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in\
    \ 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n            let\
    \ distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_distance = distance;\n                closest_pair\
    \ = (numbers[i], numbers[j]);\n            }\n        }\n    }\n    closest_pair\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpgae0_fql.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in\
    \ 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n            let\
    \ distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_distance = distance;\n                closest_pair\
    \ = (numbers[i], numbers[j]);\n            }\n        }\n    }\n    closest_pair\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpgae0_fql.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in\
    \ 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n            let\
    \ distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_distance = distance;\n                closest_elements\
    \ = (numbers[i], numbers[j]);\n            }\n        }\n    }\n    closest_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpstya4n5x.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_elements: (f64, f64) = (numbers[0],\
    \ numbers[1]);\n    let mut smallest_difference: f64 = closest_elements.1 - closest_elements.0;\n\
    \    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n  \
    \          let difference = numbers[j] - numbers[i];\n            if difference\
    \ < smallest_difference {\n                closest_elements = (numbers[i], numbers[j]);\n\
    \                smallest_difference = difference;\n            }\n        }\n\
    \    }\n    closest_elements\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmp_chnq_vv.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_elements: (f64, f64) = (numbers[0],\
    \ numbers[1]);\n    let mut closest_distance: f64 = closest_elements.1 - closest_elements.0;\n\
    \    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n  \
    \          let distance = numbers[j] - numbers[i];\n            if distance <\
    \ closest_distance {\n                closest_elements = (numbers[i], numbers[j]);\n\
    \                closest_distance = distance;\n            }\n        }\n    }\n\
    \    closest_elements\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpew5y0o65.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min_diff = f64::INFINITY;\n    let mut\
    \ min_pair = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in i\
    \ + 1..numbers.len() {\n            let diff = (numbers[i] - numbers[j]).abs();\n\
    \            if diff < min_diff {\n                min_diff = diff;\n        \
    \        min_pair = (numbers[i], numbers[j]);\n            }\n        }\n    }\n\
    \    min_pair\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpf3qiwz0l.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min_distance = std::f64::MAX;\n    let\
    \ mut closest_elements = (0.0, 0.0);\n    for i in 0..numbers.len() {\n      \
    \  for j in (i + 1)..numbers.len() {\n            let distance = (numbers[i] -\
    \ numbers[j]).abs();\n            if distance < min_distance {\n             \
    \   min_distance = distance;\n                closest_elements = (numbers[i],\
    \ numbers[j]);\n            }\n        }\n    }\n    closest_elements\n}\n\nfn\
    \ main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpw7gccbzs.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in\
    \ 0..numbers.len() - 1 {\n        for j in i + 1..numbers.len() {\n          \
    \  let distance = (numbers[j] - numbers[i]).abs();\n            if distance <\
    \ closest_distance {\n                closest_pair = (numbers[i], numbers[j]);\n\
    \                closest_distance = distance;\n            }\n        }\n    }\n\
    \    closest_pair\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpk3vbogfy.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min_diff = std::f64::MAX;\n    let mut\
    \ min_pair = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in i\
    \ + 1..numbers.len() {\n            let diff = (numbers[i] - numbers[j]).abs();\n\
    \            if diff < min_diff {\n                min_diff = diff;\n        \
    \        min_pair = (numbers[i], numbers[j]);\n            }\n        }\n    }\n\
    \    min_pair\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmp3fym7hj0.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in\
    \ 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n            let\
    \ distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_pair = (numbers[i], numbers[j]);\n              \
    \  closest_distance = distance;\n            }\n        }\n    }\n    closest_pair\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpbd6j4x07.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min_diff = f64::MAX;\n    let mut min_pair\
    \ = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            let diff = (numbers[i] - numbers[j]).abs();\n            if diff\
    \ < min_diff {\n                min_diff = diff;\n                min_pair = (numbers[i],\
    \ numbers[j]);\n            }\n        }\n    }\n    min_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpeh6dif4v.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in\
    \ 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n            let\
    \ distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_pair = (numbers[i], numbers[j]);\n              \
    \  closest_distance = distance;\n            }\n        }\n    }\n    closest_pair\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpbd6j4x07.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n\
    \    let mut closest_diff = (numbers[1] - numbers[0]).abs();\n    for i in 0..numbers.len()\
    \ {\n        for j in i + 1..numbers.len() {\n            let diff = (numbers[j]\
    \ - numbers[i]).abs();\n            if diff < closest_diff {\n               \
    \ closest_pair = (numbers[i], numbers[j]);\n                closest_diff = diff;\n\
    \            }\n        }\n    }\n    closest_pair\n}\n\nfn main() {\n    let\
    \ candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmp9akofdqr.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in\
    \ 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n            let\
    \ distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_distance = distance;\n                closest_elements\
    \ = (numbers[i], numbers[j]);\n            }\n        }\n    }\n    closest_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpstya4n5x.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min_diff = std::f64::MAX;\n    let mut\
    \ min_pair = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in i\
    \ + 1..numbers.len() {\n            let diff = (numbers[i] - numbers[j]).abs();\n\
    \            if diff < min_diff {\n                min_diff = diff;\n        \
    \        min_pair = (numbers[i], numbers[j]);\n            }\n        }\n    }\n\
    \    min_pair\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmp3fym7hj0.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in\
    \ 0..numbers.len() {\n        for j in i+1..numbers.len() {\n            let distance\
    \ = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_pair = (numbers[i], numbers[j]);\n              \
    \  closest_distance = distance;\n            }\n        }\n    }\n    closest_pair\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmp95uruptf.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min_distance = std::f64::MAX;\n    let\
    \ mut min_pair = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in\
    \ i + 1..numbers.len() {\n            let distance = (numbers[i] - numbers[j]).abs();\n\
    \            if distance < min_distance {\n                min_distance = distance;\n\
    \                min_pair = (numbers[i], numbers[j]);\n            }\n       \
    \ }\n    }\n    min_pair\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpb4a9hn3r.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = closest_elements.1 - closest_elements.0;\n   \
    \ for i in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n     \
    \       let distance = numbers[j] - numbers[i];\n            if distance < closest_distance\
    \ {\n                closest_elements = (numbers[i], numbers[j]);\n          \
    \      closest_distance = distance;\n            }\n        }\n    }\n    closest_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmp3p8mn86d.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = closest_pair.1 - closest_pair.0;\n    for i in\
    \ 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n            let\
    \ distance = numbers[j] - numbers[i];\n            if distance < closest_distance\
    \ {\n                closest_pair = (numbers[i], numbers[j]);\n              \
    \  closest_distance = distance;\n            }\n        }\n    }\n    closest_pair\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmplvf_jjre.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_elements: (f64, f64) = (numbers[0],\
    \ numbers[1]);\n    let mut closest_distance: f64 = (numbers[0] - numbers[1]).abs();\n\
    \    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n  \
    \          let distance = (numbers[i] - numbers[j]).abs();\n            if distance\
    \ < closest_distance {\n                closest_elements = (numbers[i], numbers[j]);\n\
    \                closest_distance = distance;\n            }\n        }\n    }\n\
    \    closest_elements\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpplg5gxv5.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in\
    \ 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n            let\
    \ distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_pair = (numbers[i], numbers[j]);\n              \
    \  closest_distance = distance;\n            }\n        }\n    }\n    closest_pair\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpbd6j4x07.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min_distance = std::f64::MAX;\n    let\
    \ mut closest_elements = (0.0, 0.0);\n    for (i, n) in numbers.iter().enumerate()\
    \ {\n        for m in numbers.iter().skip(i + 1) {\n            let distance =\
    \ (n - m).abs();\n            if distance < min_distance {\n                min_distance\
    \ = distance;\n                closest_elements = (*n, *m);\n            }\n \
    \       }\n    }\n    closest_elements\n}\n\nfn main() {\n    let candidate =\
    \ find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]),\
    \ (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]),\
    \ (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]),\
    \ (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2,\
    \ 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpta98gmpr.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 0
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut numbers = numbers;\n    numbers.sort_by(|a,\
    \ b| a.partial_cmp(b).unwrap());\n    let mut min_diff = numbers[1] - numbers[0];\n\
    \    let mut min_pair = (numbers[0], numbers[1]);\n    for i in 1..numbers.len()\
    \ - 1 {\n        let diff = numbers[i + 1] - numbers[i];\n        if diff < min_diff\
    \ {\n            min_diff = diff;\n            min_pair = (numbers[i], numbers[i\
    \ + 1]);\n        }\n    }\n    min_pair\n}\n\nfn main() {\n    let candidate\
    \ = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]),\
    \ (2.2, 3.1));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_elements: (f64, f64) = (numbers[0],\
    \ numbers[1]);\n    let mut closest_distance: f64 = (numbers[0] - numbers[1]).abs();\n\
    \    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n  \
    \          let distance = (numbers[i] - numbers[j]).abs();\n            if distance\
    \ < closest_distance {\n                closest_elements = (numbers[i], numbers[j]);\n\
    \                closest_distance = distance;\n            }\n        }\n    }\n\
    \    closest_elements\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpplg5gxv5.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in\
    \ 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n            let\
    \ distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_distance = distance;\n                closest_pair\
    \ = (numbers[i], numbers[j]);\n            }\n        }\n    }\n    closest_pair\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpgae0_fql.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = closest_pair.1 - closest_pair.0;\n    for i in\
    \ 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n            let\
    \ distance = numbers[j] - numbers[i];\n            if distance < closest_distance\
    \ {\n                closest_pair = (numbers[i], numbers[j]);\n              \
    \  closest_distance = distance;\n            }\n        }\n    }\n    closest_pair\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmplvf_jjre.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in\
    \ 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n            let\
    \ distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_distance = distance;\n                closest_elements\
    \ = (numbers[i], numbers[j]);\n            }\n        }\n    }\n    closest_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpstya4n5x.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min_distance = f64::MAX;\n    let mut\
    \ min_elements = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in\
    \ i + 1..numbers.len() {\n            let distance = (numbers[i] - numbers[j]).abs();\n\
    \            if distance < min_distance {\n                min_distance = distance;\n\
    \                min_elements = (numbers[i], numbers[j]);\n            }\n   \
    \     }\n    }\n    min_elements\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpjn49_cte.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min_diff = std::f64::MAX;\n    let mut\
    \ min_pair = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in i\
    \ + 1..numbers.len() {\n            let diff = (numbers[i] - numbers[j]).abs();\n\
    \            if diff < min_diff {\n                min_diff = diff;\n        \
    \        min_pair = (numbers[i], numbers[j]);\n            }\n        }\n    }\n\
    \    min_pair\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmp3fym7hj0.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in\
    \ 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n            let\
    \ distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_pair = (numbers[i], numbers[j]);\n              \
    \  closest_distance = distance;\n            }\n        }\n    }\n    closest_pair\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpbd6j4x07.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in\
    \ 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n            let\
    \ distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_pair = (numbers[i], numbers[j]);\n              \
    \  closest_distance = distance;\n            }\n        }\n    }\n    closest_pair\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpbd6j4x07.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min_diff = std::f64::MAX;\n    let mut\
    \ min_pair = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in i\
    \ + 1..numbers.len() {\n            let diff = (numbers[i] - numbers[j]).abs();\n\
    \            if diff < min_diff {\n                min_diff = diff;\n        \
    \        min_pair = (numbers[i], numbers[j]);\n            }\n        }\n    }\n\
    \    min_pair\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmp3fym7hj0.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in\
    \ 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n            let\
    \ distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_pair = (numbers[i], numbers[j]);\n              \
    \  closest_distance = distance;\n            }\n        }\n    }\n    closest_pair\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpbd6j4x07.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min_diff = std::f64::MAX;\n    let mut\
    \ min_pair = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in i\
    \ + 1..numbers.len() {\n            let diff = (numbers[i] - numbers[j]).abs();\n\
    \            if diff < min_diff {\n                min_diff = diff;\n        \
    \        min_pair = (numbers[i], numbers[j]);\n            }\n        }\n    }\n\
    \    min_pair\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmp3fym7hj0.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_elements: (f64, f64) = (numbers[0],\
    \ numbers[1]);\n    let mut closest_distance: f64 = (numbers[0] - numbers[1]).abs();\n\
    \    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n  \
    \          let distance = (numbers[i] - numbers[j]).abs();\n            if distance\
    \ < closest_distance {\n                closest_elements = (numbers[i], numbers[j]);\n\
    \                closest_distance = distance;\n            }\n        }\n    }\n\
    \    closest_elements\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpplg5gxv5.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min_diff = std::f64::MAX;\n    let mut\
    \ min_pair = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in i\
    \ + 1..numbers.len() {\n            let diff = (numbers[i] - numbers[j]).abs();\n\
    \            if diff < min_diff {\n                min_diff = diff;\n        \
    \        min_pair = (numbers[i], numbers[j]);\n            }\n        }\n    }\n\
    \    min_pair\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmp3fym7hj0.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in\
    \ 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n            let\
    \ distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_distance = distance;\n                closest_pair\
    \ = (numbers[i], numbers[j]);\n            }\n        }\n    }\n    closest_pair\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpgae0_fql.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_elements: (f64, f64) = (numbers[0],\
    \ numbers[1]);\n    let mut closest_distance: f64 = closest_elements.1 - closest_elements.0;\n\
    \    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n  \
    \          let distance = numbers[j] - numbers[i];\n            if distance <\
    \ closest_distance {\n                closest_elements = (numbers[i], numbers[j]);\n\
    \                closest_distance = distance;\n            }\n        }\n    }\n\
    \    closest_elements\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpew5y0o65.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min_diff = std::f64::MAX;\n    let mut\
    \ closest_pair = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in\
    \ i + 1..numbers.len() {\n            let diff = (numbers[i] - numbers[j]).abs();\n\
    \            if diff < min_diff {\n                min_diff = diff;\n        \
    \        closest_pair = (numbers[i], numbers[j]);\n            }\n        }\n\
    \    }\n    closest_pair\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmp3544a77g.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_elements: (f64, f64) = (numbers[0],\
    \ numbers[1]);\n    let mut closest_distance: f64 = closest_elements.1 - closest_elements.0;\n\
    \    for i in 0..numbers.len() - 1 {\n        for j in i + 1..numbers.len() {\n\
    \            let distance = numbers[j] - numbers[i];\n            if distance\
    \ < closest_distance {\n                closest_elements = (numbers[i], numbers[j]);\n\
    \                closest_distance = distance;\n            }\n        }\n    }\n\
    \    closest_elements\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpykcc717b.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in\
    \ 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n            let\
    \ distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_distance = distance;\n                closest_elements\
    \ = (numbers[i], numbers[j]);\n            }\n        }\n    }\n    closest_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpstya4n5x.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in\
    \ 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n            let\
    \ distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_pair = (numbers[i], numbers[j]);\n              \
    \  closest_distance = distance;\n            }\n        }\n    }\n    closest_pair\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpbd6j4x07.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in\
    \ 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n            let\
    \ distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_pair = (numbers[i], numbers[j]);\n              \
    \  closest_distance = distance;\n            }\n        }\n    }\n    closest_pair\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpbd6j4x07.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in\
    \ 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n            let\
    \ distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_pair = (numbers[i], numbers[j]);\n              \
    \  closest_distance = distance;\n            }\n        }\n    }\n    closest_pair\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpbd6j4x07.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in\
    \ 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n            let\
    \ distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_distance = distance;\n                closest_elements\
    \ = (numbers[i], numbers[j]);\n            }\n        }\n    }\n    closest_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpstya4n5x.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min_distance = std::f64::MAX;\n    let\
    \ mut min_distance_pair = (0.0, 0.0);\n    for i in 0..numbers.len() {\n     \
    \   for j in i + 1..numbers.len() {\n            let distance = (numbers[i] -\
    \ numbers[j]).abs();\n            if distance < min_distance {\n             \
    \   min_distance = distance;\n                min_distance_pair = (numbers[i],\
    \ numbers[j]);\n            }\n        }\n    }\n    min_distance_pair\n}\n\n\
    fn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpyvt0lxcx.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in\
    \ 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n            let\
    \ distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_distance = distance;\n                closest_pair\
    \ = (numbers[i], numbers[j]);\n            }\n        }\n    }\n    closest_pair\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpgae0_fql.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min_distance = f64::MAX;\n    let mut\
    \ min_pair = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in i\
    \ + 1..numbers.len() {\n            let distance = (numbers[i] - numbers[j]).abs();\n\
    \            if distance < min_distance {\n                min_distance = distance;\n\
    \                min_pair = (numbers[i], numbers[j]);\n            }\n       \
    \ }\n    }\n    min_pair\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmp03eftfoc.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = closest_pair.1 - closest_pair.0;\n    for i in\
    \ 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n            let\
    \ distance = numbers[j] - numbers[i];\n            if distance < closest_distance\
    \ {\n                closest_pair = (numbers[i], numbers[j]);\n              \
    \  closest_distance = distance;\n            }\n        }\n    }\n    closest_pair\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmplvf_jjre.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_elements: (f64, f64) = (numbers[0],\
    \ numbers[1]);\n    let mut closest_distance: f64 = closest_elements.1 - closest_elements.0;\n\
    \    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n  \
    \          let distance = numbers[j] - numbers[i];\n            if distance <\
    \ closest_distance {\n                closest_elements = (numbers[i], numbers[j]);\n\
    \                closest_distance = distance;\n            }\n        }\n    }\n\
    \    closest_elements\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpew5y0o65.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min_distance = std::f64::MAX;\n    let\
    \ mut min_distance_pair = (0.0, 0.0);\n    for i in 0..numbers.len() - 1 {\n \
    \       for j in i + 1..numbers.len() {\n            let distance = (numbers[i]\
    \ - numbers[j]).abs();\n            if distance < min_distance {\n           \
    \     min_distance = distance;\n                min_distance_pair = (numbers[i],\
    \ numbers[j]);\n            }\n        }\n    }\n    min_distance_pair\n}\n\n\
    fn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpccwgszo1.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_elements: (f64, f64) = (numbers[0],\
    \ numbers[1]);\n    let mut closest_distance: f64 = (numbers[0] - numbers[1]).abs();\n\
    \    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n  \
    \          let distance = (numbers[i] - numbers[j]).abs();\n            if distance\
    \ < closest_distance {\n                closest_elements = (numbers[i], numbers[j]);\n\
    \                closest_distance = distance;\n            }\n        }\n    }\n\
    \    closest_elements\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpplg5gxv5.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n\
    \    let mut closest_diff = (numbers[1] - numbers[0]).abs();\n    for i in 0..numbers.len()\
    \ {\n        for j in i + 1..numbers.len() {\n            let diff = (numbers[j]\
    \ - numbers[i]).abs();\n            if diff < closest_diff {\n               \
    \ closest_pair = (numbers[i], numbers[j]);\n                closest_diff = diff;\n\
    \            }\n        }\n    }\n    closest_pair\n}\n\nfn main() {\n    let\
    \ candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmp9akofdqr.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min_distance = std::f64::MAX;\n    let\
    \ mut closest_elements = (0.0, 0.0);\n    for i in 0..numbers.len() {\n      \
    \  for j in i + 1..numbers.len() {\n            let distance = (numbers[i] - numbers[j]).abs();\n\
    \            if distance < min_distance {\n                min_distance = distance;\n\
    \                closest_elements = (numbers[i], numbers[j]);\n            }\n\
    \        }\n    }\n    closest_elements\n}\n\nfn main() {\n    let candidate =\
    \ find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]),\
    \ (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]),\
    \ (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]),\
    \ (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2,\
    \ 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpw2u3j4k4.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min_diff = f64::MAX;\n    let mut closest_elements\
    \ = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            let diff = (numbers[i] - numbers[j]).abs();\n            if diff\
    \ < min_diff {\n                min_diff = diff;\n                closest_elements\
    \ = (numbers[i], numbers[j]);\n            }\n        }\n    }\n    closest_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpuh8razdk.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in\
    \ 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n            let\
    \ distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_distance = distance;\n                closest_pair\
    \ = (numbers[i], numbers[j]);\n            }\n        }\n    }\n    closest_pair\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpgae0_fql.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in\
    \ 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n            let\
    \ distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_pair = (numbers[i], numbers[j]);\n              \
    \  closest_distance = distance;\n            }\n        }\n    }\n    closest_pair\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpbd6j4x07.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min_diff = std::f64::MAX;\n    let mut\
    \ min_pair = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in i\
    \ + 1..numbers.len() {\n            let diff = (numbers[i] - numbers[j]).abs();\n\
    \            if diff < min_diff {\n                min_diff = diff;\n        \
    \        min_pair = (numbers[i], numbers[j]);\n            }\n        }\n    }\n\
    \    min_pair\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmp3fym7hj0.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in\
    \ 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n            let\
    \ distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_pair = (numbers[i], numbers[j]);\n              \
    \  closest_distance = distance;\n            }\n        }\n    }\n    closest_pair\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpbd6j4x07.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in\
    \ 0..numbers.len() {\n        for j in i+1..numbers.len() {\n            let distance\
    \ = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_pair = (numbers[i], numbers[j]);\n              \
    \  closest_distance = distance;\n            }\n        }\n    }\n    closest_pair\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmp95uruptf.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_difference = (numbers[1] - numbers[0]).abs();\n    for i\
    \ in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n           \
    \ let difference = (numbers[j] - numbers[i]).abs();\n            if difference\
    \ < closest_difference {\n                closest_elements = (numbers[i], numbers[j]);\n\
    \                closest_difference = difference;\n            }\n        }\n\
    \    }\n    closest_elements\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpfxmhsayf.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in\
    \ 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n            let\
    \ distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest = (numbers[i], numbers[j]);\n                closest_distance\
    \ = distance;\n            }\n        }\n    }\n    closest\n}\n\nfn main() {\n\
    \    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpdhk_uy0l.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_difference = (numbers[1] - numbers[0]).abs();\n    for i\
    \ in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n           \
    \ let difference = (numbers[j] - numbers[i]).abs();\n            if difference\
    \ < closest_difference {\n                closest_elements = (numbers[i], numbers[j]);\n\
    \                closest_difference = difference;\n            }\n        }\n\
    \    }\n    closest_elements\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpfxmhsayf.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in\
    \ 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n            let\
    \ distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_distance = distance;\n                closest_pair\
    \ = (numbers[i], numbers[j]);\n            }\n        }\n    }\n    closest_pair\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpgae0_fql.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_elements: (f64, f64) = (numbers[0],\
    \ numbers[1]);\n    let mut closest_distance: f64 = closest_elements.1 - closest_elements.0;\n\
    \    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n  \
    \          let distance = numbers[j] - numbers[i];\n            if distance <\
    \ closest_distance {\n                closest_elements = (numbers[i], numbers[j]);\n\
    \                closest_distance = distance;\n            }\n        }\n    }\n\
    \    closest_elements\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmpew5y0o65.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = closest_pair.1 - closest_pair.0;\n    for i in\
    \ 0..numbers.len() {\n        for j in i+1..numbers.len() {\n            let distance\
    \ = numbers[j] - numbers[i];\n            if distance < closest_distance {\n \
    \               closest_pair = (numbers[i], numbers[j]);\n                closest_distance\
    \ = distance;\n            }\n        }\n    }\n    closest_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmp9rw4in3x.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = closest_pair.1 - closest_pair.0;\n    for i in\
    \ 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n            let\
    \ distance = numbers[j] - numbers[i];\n            if distance < closest_distance\
    \ {\n                closest_pair = (numbers[i], numbers[j]);\n              \
    \  closest_distance = distance;\n            }\n        }\n    }\n    closest_pair\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmplvf_jjre.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min_diff = std::f64::MAX;\n    let mut\
    \ min_pair = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in i\
    \ + 1..numbers.len() {\n            let diff = (numbers[i] - numbers[j]).abs();\n\
    \            if diff < min_diff {\n                min_diff = diff;\n        \
    \        min_pair = (numbers[i], numbers[j]);\n            }\n        }\n    }\n\
    \    min_pair\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmp3fym7hj0.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in\
    \ 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n            let\
    \ distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_distance = distance;\n                closest_pair\
    \ = (numbers[i], numbers[j]);\n            }\n        }\n    }\n    closest_pair\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpgae0_fql.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = closest_elements.1 - closest_elements.0;\n   \
    \ for i in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n     \
    \       let distance = numbers[j] - numbers[i];\n            if distance < closest_distance\
    \ {\n                closest_elements = (numbers[i], numbers[j]);\n          \
    \      closest_distance = distance;\n            }\n        }\n    }\n    closest_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmp3p8mn86d.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in\
    \ 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n            let\
    \ distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_distance = distance;\n                closest_pair\
    \ = (numbers[i], numbers[j]);\n            }\n        }\n    }\n    closest_pair\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpgae0_fql.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in\
    \ 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n            let\
    \ distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_distance = distance;\n                closest_pair\
    \ = (numbers[i], numbers[j]);\n            }\n        }\n    }\n    closest_pair\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpgae0_fql.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in\
    \ 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n            let\
    \ distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_distance = distance;\n                closest_pair\
    \ = (numbers[i], numbers[j]);\n            }\n        }\n    }\n    closest_pair\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpgae0_fql.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in\
    \ 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n            let\
    \ distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_pair = (numbers[i], numbers[j]);\n              \
    \  closest_distance = distance;\n            }\n        }\n    }\n    closest_pair\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpbd6j4x07.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in\
    \ 0..numbers.len() {\n        for j in (i + 1)..numbers.len() {\n            let\
    \ distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_distance = distance;\n                closest_elements\
    \ = (numbers[i], numbers[j]);\n            }\n        }\n    }\n    closest_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpn4c1_9lq.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011329
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = closest_pair.1 - closest_pair.0;\n    for i in\
    \ 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n            let\
    \ distance = numbers[j] - numbers[i];\n            if distance < closest_distance\
    \ {\n                closest_pair = (numbers[i], numbers[j]);\n              \
    \  closest_distance = distance;\n            }\n        }\n    }\n    closest_pair\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.0, 2.2)`,\n right: `(3.9, 4.0)`', /tmp/tmplvf_jjre.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min_diff = std::f64::MAX;\n    let mut\
    \ min_pair = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in i\
    \ + 1..numbers.len() {\n            let diff = (numbers[i] - numbers[j]).abs();\n\
    \            if diff < min_diff {\n                min_diff = diff;\n        \
    \        min_pair = (numbers[i], numbers[j]);\n            }\n        }\n    }\n\
    \    min_pair\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmp3fym7hj0.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in\
    \ 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n            let\
    \ distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_distance = distance;\n                closest_elements\
    \ = (numbers[i], numbers[j]);\n            }\n        }\n    }\n    closest_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpstya4n5x.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_elements = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in\
    \ 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n            let\
    \ distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_distance = distance;\n                closest_elements\
    \ = (numbers[i], numbers[j]);\n            }\n        }\n    }\n    closest_elements\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpstya4n5x.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_numbers = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n\n    for i\
    \ in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n           \
    \ let distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_numbers = (numbers[i], numbers[j]);\n           \
    \     closest_distance = distance;\n            }\n        }\n    }\n\n    closest_numbers\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpw2qkhs3e.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_elements: (f64, f64) = (numbers[0],\
    \ numbers[1]);\n    let mut closest_distance: f64 = (numbers[0] - numbers[1]).abs();\n\
    \    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n  \
    \          let distance = (numbers[i] - numbers[j]).abs();\n            if distance\
    \ < closest_distance {\n                closest_elements = (numbers[i], numbers[j]);\n\
    \                closest_distance = distance;\n            }\n        }\n    }\n\
    \    closest_elements\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpplg5gxv5.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min_distance = std::f64::MAX;\n    let\
    \ mut closest_elements = (0.0, 0.0);\n    for (i, x) in numbers.iter().enumerate()\
    \ {\n        for y in numbers.iter().skip(i + 1) {\n            let distance =\
    \ (x - y).abs();\n            if distance < min_distance {\n                min_distance\
    \ = distance;\n                closest_elements = (*x, *y);\n            }\n \
    \       }\n    }\n    closest_elements\n}\n\nfn main() {\n    let candidate =\
    \ find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]),\
    \ (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]),\
    \ (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]),\
    \ (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2,\
    \ 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpasuvyelp.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011329
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in\
    \ 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n            let\
    \ distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_distance = distance;\n                closest_pair\
    \ = (numbers[i], numbers[j]);\n            }\n        }\n    }\n    closest_pair\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpgae0_fql.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min_diff = f64::MAX;\n    let mut min_pair\
    \ = (0.0, 0.0);\n    for i in 0..numbers.len() {\n        for j in i + 1..numbers.len()\
    \ {\n            let diff = (numbers[i] - numbers[j]).abs();\n            if diff\
    \ < min_diff {\n                min_diff = diff;\n                min_pair = (numbers[i],\
    \ numbers[j]);\n            }\n        }\n    }\n    min_pair\n}\n\nfn main()\
    \ {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpeh6dif4v.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min_distance = std::f64::MAX;\n    let\
    \ mut closest_elements = (0.0, 0.0);\n    for i in 0..numbers.len() {\n      \
    \  for j in i + 1..numbers.len() {\n            let distance = (numbers[i] - numbers[j]).abs();\n\
    \            if distance < min_distance {\n                min_distance = distance;\n\
    \                closest_elements = (numbers[i], numbers[j]);\n            }\n\
    \        }\n    }\n    closest_elements\n}\n\nfn main() {\n    let candidate =\
    \ find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]),\
    \ (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]),\
    \ (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]),\
    \ (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2,\
    \ 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpw2u3j4k4.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut closest_pair = (numbers[0], numbers[1]);\n\
    \    let mut closest_distance = (numbers[1] - numbers[0]).abs();\n    for i in\
    \ 0..numbers.len() {\n        for j in i + 1..numbers.len() {\n            let\
    \ distance = (numbers[j] - numbers[i]).abs();\n            if distance < closest_distance\
    \ {\n                closest_distance = distance;\n                closest_pair\
    \ = (numbers[i], numbers[j]);\n            }\n        }\n    }\n    closest_pair\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpgae0_fql.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min_dist = std::f64::MAX;\n    let mut\
    \ min_pair = (0.0, 0.0);\n    for (i, x) in numbers.iter().enumerate() {\n   \
    \     for y in numbers.iter().skip(i + 1) {\n            let dist = (x - y).abs();\n\
    \            if dist < min_dist {\n                min_dist = dist;\n        \
    \        min_pair = (*x, *y);\n            }\n        }\n    }\n    min_pair\n\
    }\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2,\
    \ 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpnvkczi46.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011329
- exit_code: 101
  program: "/// From a supplied list of numbers (of length at least two) select and\
    \ return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers:\
    \ Vec<f64>) -> (f64, f64) {\n    let mut min_distance = std::f64::MAX;\n    let\
    \ mut closest_elements = (0.0, 0.0);\n    for i in 0..numbers.len() {\n      \
    \  for j in i + 1..numbers.len() {\n            let distance = (numbers[i] - numbers[j]).abs();\n\
    \            if distance < min_distance {\n                min_distance = distance;\n\
    \                closest_elements = (numbers[i], numbers[j]);\n            }\n\
    \        }\n    }\n    closest_elements\n}\n\nfn main() {\n    let candidate =\
    \ find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]),\
    \ (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]),\
    \ (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]),\
    \ (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2,\
    \ 3.1));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(5.9, 5.0)`,\n right: `(5.0, 5.9)`', /tmp/tmpw2u3j4k4.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011328
