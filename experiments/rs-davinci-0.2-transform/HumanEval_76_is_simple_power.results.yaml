language: rs
name: HumanEval_76_is_simple_power
results:
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    if n == 1 {\n \
    \       return false;\n    }\n    let mut i = 1;\n    let mut result = n;\n  \
    \  while result < x {\n        result *= n;\n        i += 1;\n    }\n    result\
    \ == x\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    let mut i = 1;\n    while i < x {\n        i *= n;\n    }\n \
    \   i == x\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 1;\n\
    \    while i <= x {\n        if i == x {\n            return true;\n        }\n\
    \        i *= n;\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: -1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    let mut x = x;\n    let mut n = n;\n    while x % n == 0 {\n\
    \        x /= n;\n    }\n    x == 1\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660010217
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 1;\n\
    \    while i.pow(n as u32) <= x {\n        if i.pow(n as u32) == x {\n       \
    \     return true;\n        }\n        i += 1;\n    }\n    false\n}\n\nfn main()\
    \ {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0689]: can't call method `pow` on ambiguous numeric type `{integer}`\n\
    \  --> /tmp/tmp7p61spy1.rs:22:13\n   |\n22 |     while i.pow(n as u32) <= x {\n\
    \   |             ^^^\n   |\nhelp: you must specify a type for this binding, like\
    \ `i32`\n   |\n21 |     let mut i: i32 = 1;\n   |         ~~~~~~~~~~\n\nerror[E0689]:\
    \ can't call method `pow` on ambiguous numeric type `{integer}`\n  --> /tmp/tmp7p61spy1.rs:23:14\n\
    \   |\n23 |         if i.pow(n as u32) == x {\n   |              ^^^\n   |\nhelp:\
    \ you must specify a type for this binding, like `i32`\n   |\n21 |     let mut\
    \ i: i32 = 1;\n   |         ~~~~~~~~~~\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0689`.\n"
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 1;\n\
    \    while i < x {\n        i *= n;\n        if i == x {\n            return true;\n\
    \        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut power =\
    \ n;\n    while power < x {\n        power *= n;\n    }\n    power == x\n}\n\n\
    fn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 1;\n\
    \    let mut result = n;\n    while result < x {\n        result *= n;\n     \
    \   i += 1;\n    }\n    result == x\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 1;\n\
    \    while i < x {\n        i *= n;\n    }\n    i == x\n}\n\nfn main() {\n   \
    \ let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    if n == 1 {\n \
    \       return false;\n    }\n    let mut i = 2;\n    let mut result = n;\n  \
    \  while result < x {\n        result *= n;\n        i += 1;\n    }\n    result\
    \ == x\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    if n == 1 {\n \
    \       return false;\n    }\n    let mut i = 1;\n    let mut result = n;\n  \
    \  while result <= x {\n        if result == x {\n            return true;\n \
    \       }\n        i += 1;\n        result = n.pow(i);\n    }\n    false\n}\n\n\
    fn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    if n == 1 {\n \
    \       return false;\n    }\n    let mut i = 1;\n    let mut result = n;\n  \
    \  while result < x {\n        result *= n;\n        i += 1;\n    }\n    result\
    \ == x\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    let mut power = n;\n    while power < x {\n        power *= n;\n\
    \    }\n    power == x\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp9so268y9.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010212
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    if n == 1 {\n \
    \       return false;\n    }\n    let mut i = 1;\n    while i.pow(n as u32) <=\
    \ x {\n        if i.pow(n as u32) == x {\n            return true;\n        }\n\
    \        i += 1;\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0689]: can't call method `pow` on ambiguous numeric type `{integer}`\n\
    \  --> /tmp/tmp6772yo9e.rs:25:13\n   |\n25 |     while i.pow(n as u32) <= x {\n\
    \   |             ^^^\n   |\nhelp: you must specify a type for this binding, like\
    \ `i32`\n   |\n24 |     let mut i: i32 = 1;\n   |         ~~~~~~~~~~\n\nerror[E0689]:\
    \ can't call method `pow` on ambiguous numeric type `{integer}`\n  --> /tmp/tmp6772yo9e.rs:26:14\n\
    \   |\n26 |         if i.pow(n as u32) == x {\n   |              ^^^\n   |\nhelp:\
    \ you must specify a type for this binding, like `i32`\n   |\n24 |     let mut\
    \ i: i32 = 1;\n   |         ~~~~~~~~~~\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0689`.\n"
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    if n == 1 {\n \
    \       return false;\n    }\n    let mut i = 1;\n    while i < x {\n        i\
    \ *= n;\n    }\n    i == x\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 0 {\n        return false;\n    }\n    let mut i = 1;\n\
    \    while i <= x {\n        if i == x {\n            return true;\n        }\n\
    \        i *= n;\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 1;\n\
    \    while i.pow(n as u32) <= x {\n        if i.pow(n as u32) == x {\n       \
    \     return true;\n        }\n        i += 1;\n    }\n    false\n}\n\nfn main()\
    \ {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0689]: can't call method `pow` on ambiguous numeric type `{integer}`\n\
    \  --> /tmp/tmp7p61spy1.rs:22:13\n   |\n22 |     while i.pow(n as u32) <= x {\n\
    \   |             ^^^\n   |\nhelp: you must specify a type for this binding, like\
    \ `i32`\n   |\n21 |     let mut i: i32 = 1;\n   |         ~~~~~~~~~~\n\nerror[E0689]:\
    \ can't call method `pow` on ambiguous numeric type `{integer}`\n  --> /tmp/tmp7p61spy1.rs:23:14\n\
    \   |\n23 |         if i.pow(n as u32) == x {\n   |              ^^^\n   |\nhelp:\
    \ you must specify a type for this binding, like `i32`\n   |\n21 |     let mut\
    \ i: i32 = 1;\n   |         ~~~~~~~~~~\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0689`.\n"
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 2;\n\
    \    let mut result = n;\n    while result < x {\n        result *= n;\n     \
    \   i += 1;\n    }\n    if result == x {\n        return true;\n    }\n    false\n\
    }\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    let mut i = 1;\n    let mut result = n;\n    while result < x\
    \ {\n        result *= n;\n        i += 1;\n    }\n    result == x\n}\n\nfn main()\
    \ {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpiv1ejzpo.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 1;\n\
    \    let mut result = n;\n    while result <= x {\n        if result == x {\n\
    \            return true;\n        }\n        i += 1;\n        result = n.pow(i);\n\
    \    }\n    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n  \
    \  assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 2;\n\
    \    let mut result = n;\n    while result <= x {\n        if result == x {\n\
    \            return true;\n        }\n        result *= n;\n        i += 1;\n\
    \    }\n    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n  \
    \  assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 1;\n\
    \    while i < x {\n        i *= n;\n    }\n    i == x\n}\n\nfn main() {\n   \
    \ let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    if n == 1 {\n \
    \       return false;\n    }\n    let mut i = 1;\n    let mut result = n;\n  \
    \  while result < x {\n        result *= n;\n        i += 1;\n    }\n    result\
    \ == x\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 1;\n\
    \    while i.pow(n as u32) <= x {\n        if i.pow(n as u32) == x {\n       \
    \     return true;\n        }\n        i += 1;\n    }\n    false\n}\n\nfn main()\
    \ {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0689]: can't call method `pow` on ambiguous numeric type `{integer}`\n\
    \  --> /tmp/tmp7p61spy1.rs:22:13\n   |\n22 |     while i.pow(n as u32) <= x {\n\
    \   |             ^^^\n   |\nhelp: you must specify a type for this binding, like\
    \ `i32`\n   |\n21 |     let mut i: i32 = 1;\n   |         ~~~~~~~~~~\n\nerror[E0689]:\
    \ can't call method `pow` on ambiguous numeric type `{integer}`\n  --> /tmp/tmp7p61spy1.rs:23:14\n\
    \   |\n23 |         if i.pow(n as u32) == x {\n   |              ^^^\n   |\nhelp:\
    \ you must specify a type for this binding, like `i32`\n   |\n21 |     let mut\
    \ i: i32 = 1;\n   |         ~~~~~~~~~~\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0689`.\n"
  stdout: ''
  timestamp: 1660010212
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    let mut i = 1;\n    while i.pow(n as u32) < x {\n        i +=\
    \ 1;\n    }\n    i.pow(n as u32) == x\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0689]: can't call method `pow` on ambiguous numeric type `{integer}`\n\
    \  --> /tmp/tmp51ogj6x_.rs:19:13\n   |\n19 |     while i.pow(n as u32) < x {\n\
    \   |             ^^^\n   |\nhelp: you must specify a type for this binding, like\
    \ `i32`\n   |\n18 |     let mut i: i32 = 1;\n   |         ~~~~~~~~~~\n\nerror[E0689]:\
    \ can't call method `pow` on ambiguous numeric type `{integer}`\n  --> /tmp/tmp51ogj6x_.rs:22:7\n\
    \   |\n22 |     i.pow(n as u32) == x\n   |       ^^^\n   |\nhelp: you must specify\
    \ a type for this binding, like `i32`\n   |\n18 |     let mut i: i32 = 1;\n  \
    \ |         ~~~~~~~~~~\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0689`.\n"
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    if n == 1 {\n \
    \       return false;\n    }\n    let mut result = n;\n    while result < x {\n\
    \        result *= n;\n    }\n    result == x\n}\n\nfn main() {\n    let candidate\
    \ = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 1;\n\
    \    while i < x {\n        i *= n;\n        if i == x {\n            return true;\n\
    \        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 1;\n\
    \    while i < x {\n        i *= n;\n        if i == x {\n            return true;\n\
    \        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 2;\n\
    \    let mut result = n;\n    while result <= x {\n        if result == x {\n\
    \            return true;\n        }\n        result *= n;\n        i += 1;\n\
    \    }\n    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n  \
    \  assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 1;\n\
    \    let mut result = n;\n    while result < x {\n        result *= n;\n     \
    \   i += 1;\n    }\n    result == x\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 2;\n\
    \    let mut res = n;\n    while res < x {\n        res *= n;\n        i += 1;\n\
    \    }\n    res == x\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 1;\n\
    \    let mut result = n;\n    while result < x {\n        result *= n;\n     \
    \   i += 1;\n    }\n    result == x\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 1;\n\
    \    let mut res = n;\n    while res <= x {\n        if res == x {\n         \
    \   return true;\n        }\n        i += 1;\n        res *= n;\n    }\n    false\n\
    }\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 1;\n\
    \    let mut res = n;\n    while res <= x {\n        if res == x {\n         \
    \   return true;\n        }\n        i += 1;\n        res *= n;\n    }\n    false\n\
    }\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 1;\n\
    \    while i < x {\n        i *= n;\n        if i == x {\n            return true;\n\
    \        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 2;\n\
    \    let mut result = n;\n    while result < x {\n        result *= n;\n     \
    \   i += 1;\n    }\n    result == x\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    let mut i = 1;\n    while i.pow(n as u32) <= x {\n        if\
    \ i.pow(n as u32) == x {\n            return true;\n        }\n        i += 1;\n\
    \    }\n    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n  \
    \  assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0689]: can't call method `pow` on ambiguous numeric type `{integer}`\n\
    \  --> /tmp/tmp7ozxxqbl.rs:19:13\n   |\n19 |     while i.pow(n as u32) <= x {\n\
    \   |             ^^^\n   |\nhelp: you must specify a type for this binding, like\
    \ `i32`\n   |\n18 |     let mut i: i32 = 1;\n   |         ~~~~~~~~~~\n\nerror[E0689]:\
    \ can't call method `pow` on ambiguous numeric type `{integer}`\n  --> /tmp/tmp7ozxxqbl.rs:20:14\n\
    \   |\n20 |         if i.pow(n as u32) == x {\n   |              ^^^\n   |\nhelp:\
    \ you must specify a type for this binding, like `i32`\n   |\n18 |     let mut\
    \ i: i32 = 1;\n   |         ~~~~~~~~~~\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0689`.\n"
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    if n == 1 {\n \
    \       return false;\n    }\n    let mut res = n;\n    while res < x {\n    \
    \    res *= n;\n    }\n    res == x\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    if n == 1 {\n \
    \       return false;\n    }\n    let mut i = 1;\n    let mut result = n;\n  \
    \  while result < x {\n        result *= n;\n        i += 1;\n    }\n    result\
    \ == x\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 1;\n\
    \    while i < x {\n        i *= n;\n        if i == x {\n            return true;\n\
    \        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 1;\n\
    \    while i <= x {\n        if i == x {\n            return true;\n        }\n\
    \        i *= n;\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 1;\n\
    \    let mut result = n;\n    while result <= x {\n        if result == x {\n\
    \            return true;\n        }\n        i += 1;\n        result = n.pow(i);\n\
    \    }\n    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n  \
    \  assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 2;\n\
    \    let mut result = n;\n    while result < x {\n        result *= n;\n     \
    \   i += 1;\n    }\n    result == x\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    if n == 1 {\n \
    \       return false;\n    }\n    let mut result = n;\n    while result < x {\n\
    \        result *= n;\n    }\n    result == x\n}\n\nfn main() {\n    let candidate\
    \ = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 1;\n\
    \    while i <= x {\n        if i == x {\n            return true;\n        }\n\
    \        i *= n;\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    let mut i = 1;\n    while i <= x {\n        if i == x {\n   \
    \         return true;\n        }\n        i *= n;\n    }\n    false\n}\n\nfn\
    \ main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 1;\n\
    \    while i.pow(n as u32) <= x {\n        if i.pow(n as u32) == x {\n       \
    \     return true;\n        }\n        i += 1;\n    }\n    false\n}\n\nfn main()\
    \ {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0689]: can't call method `pow` on ambiguous numeric type `{integer}`\n\
    \  --> /tmp/tmp7p61spy1.rs:22:13\n   |\n22 |     while i.pow(n as u32) <= x {\n\
    \   |             ^^^\n   |\nhelp: you must specify a type for this binding, like\
    \ `i32`\n   |\n21 |     let mut i: i32 = 1;\n   |         ~~~~~~~~~~\n\nerror[E0689]:\
    \ can't call method `pow` on ambiguous numeric type `{integer}`\n  --> /tmp/tmp7p61spy1.rs:23:14\n\
    \   |\n23 |         if i.pow(n as u32) == x {\n   |              ^^^\n   |\nhelp:\
    \ you must specify a type for this binding, like `i32`\n   |\n21 |     let mut\
    \ i: i32 = 1;\n   |         ~~~~~~~~~~\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0689`.\n"
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut x = x;\n\
    \    while x % n == 0 {\n        x /= n;\n    }\n    x == 1\n}\n\nfn main() {\n\
    \    let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010213
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    x == n.pow(x.trailing_zeros() as u32)\n}\n\nfn main() {\n   \
    \ let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmper58zdug.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010213
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 1;\n\
    \    let mut res = n;\n    while res <= x {\n        if res == x {\n         \
    \   return true;\n        }\n        i += 1;\n        res *= n;\n    }\n    false\n\
    }\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 1;\n\
    \    let mut result = n;\n    while result < x {\n        result *= n;\n     \
    \   i += 1;\n    }\n    result == x\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    let mut p = n;\n    while p < x {\n        p *= n;\n    }\n \
    \   p == x\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpt2kbj3cg.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010213
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 1;\n\
    \    while i.pow(n as u32) <= x {\n        if i.pow(n as u32) == x {\n       \
    \     return true;\n        }\n        i += 1;\n    }\n    false\n}\n\nfn main()\
    \ {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0689]: can't call method `pow` on ambiguous numeric type `{integer}`\n\
    \  --> /tmp/tmp7p61spy1.rs:22:13\n   |\n22 |     while i.pow(n as u32) <= x {\n\
    \   |             ^^^\n   |\nhelp: you must specify a type for this binding, like\
    \ `i32`\n   |\n21 |     let mut i: i32 = 1;\n   |         ~~~~~~~~~~\n\nerror[E0689]:\
    \ can't call method `pow` on ambiguous numeric type `{integer}`\n  --> /tmp/tmp7p61spy1.rs:23:14\n\
    \   |\n23 |         if i.pow(n as u32) == x {\n   |              ^^^\n   |\nhelp:\
    \ you must specify a type for this binding, like `i32`\n   |\n21 |     let mut\
    \ i: i32 = 1;\n   |         ~~~~~~~~~~\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0689`.\n"
  stdout: ''
  timestamp: 1660010212
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    let mut power = n;\n    while power < x {\n        power *= n;\n\
    \    }\n    power == x\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp9so268y9.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    let mut i = 1;\n    while i < x {\n        i *= n;\n    }\n \
    \   i == x\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 1;\n\
    \    let mut result = n;\n    while result < x {\n        result *= n;\n     \
    \   i += 1;\n    }\n    result == x\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 1;\n\
    \    while i <= x {\n        if i == x {\n            return true;\n        }\n\
    \        i *= n;\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    let mut i = 1;\n    while i < x {\n        if i == x {\n    \
    \        return true;\n        }\n        i *= n;\n    }\n    false\n}\n\nfn main()\
    \ {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp4den9lex.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010213
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 0 {\n        return false;\n    }\n    let mut i = 1;\n\
    \    while i <= x {\n        if i == x {\n            return true;\n        }\n\
    \        i *= n;\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 2;\n\
    \    let mut result = n;\n    while result < x {\n        result *= n;\n     \
    \   i += 1;\n    }\n    result == x\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 1;\n\
    \    let mut result = n;\n    while result <= x {\n        if result == x {\n\
    \            return true;\n        }\n        i += 1;\n        result = n.pow(i);\n\
    \    }\n    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n  \
    \  assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    if n == 1 {\n \
    \       return false;\n    }\n    let mut i = 1;\n    let mut result = n;\n  \
    \  while result < x {\n        result *= n;\n        i += 1;\n    }\n    result\
    \ == x\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 1;\n\
    \    while i <= x {\n        if i == x {\n            return true;\n        }\n\
    \        i *= n;\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    if n == 1 {\n \
    \       return false;\n    }\n    let mut i = 1;\n    while i < x {\n        i\
    \ *= n;\n    }\n    i == x\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 0 {\n        return false;\n    }\n    let mut i = 1;\n\
    \    while i <= x {\n        if i == x {\n            return true;\n        }\n\
    \        i *= n;\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 1;\n\
    \    while i <= x {\n        if i == x {\n            return true;\n        }\n\
    \        i *= n;\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    let mut i = 0;\n    let mut result = n;\n    while result <=\
    \ x {\n        if result == x {\n            return true;\n        }\n       \
    \ i += 1;\n        result = n.pow(i);\n    }\n    false\n}\n\nfn main() {\n  \
    \  let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmplqgup02m.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010213
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 1;\n\
    \    while i < x {\n        i *= n;\n        if i == x {\n            return true;\n\
    \        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 1;\n\
    \    let mut result = n;\n    while result < x {\n        result *= n;\n     \
    \   i += 1;\n    }\n    result == x\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 2;\n\
    \    let mut result = n;\n    while result <= x {\n        if result == x {\n\
    \            return true;\n        }\n        result *= n;\n        i += 1;\n\
    \    }\n    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n  \
    \  assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    let mut power = n;\n    while power < x {\n        power *= n;\n\
    \    }\n    power == x\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp9so268y9.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010212
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    let mut result = n;\n    while result < x {\n        result *=\
    \ n;\n    }\n    result == x\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp0tjdfhdl.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010213
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 1;\n\
    \    while i < x {\n        i *= n;\n        if i == x {\n            return true;\n\
    \        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    if n == 1 {\n \
    \       return false;\n    }\n    let mut i = 1;\n    let mut result = n;\n  \
    \  while result < x {\n        result *= n;\n        i += 1;\n    }\n    result\
    \ == x\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 1;\n\
    \    while i <= x {\n        if i == x {\n            return true;\n        }\n\
    \        i *= n;\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 1;\n\
    \    let mut res = n;\n    while res < x {\n        res *= n;\n        i += 1;\n\
    \    }\n    res == x\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010213
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 0 {\n        return false;\n    }\n    let mut power\
    \ = 1;\n    while power < x {\n        power *= n;\n    }\n    power == x\n}\n\
    \nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010213
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 1;\n\
    \    while i <= x {\n        if i == x {\n            return true;\n        }\n\
    \        i *= n;\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 1;\n\
    \    let mut result = n;\n    while result < x {\n        result *= n;\n     \
    \   i += 1;\n    }\n    result == x\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 1;\n\
    \    let mut result = n;\n    while result <= x {\n        if result == x {\n\
    \            return true;\n        }\n        i += 1;\n        result = n.pow(i);\n\
    \    }\n    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n  \
    \  assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    if n == 1 {\n \
    \       return false;\n    }\n    let mut i = 1;\n    let mut result = n;\n  \
    \  while result < x {\n        result *= n;\n        i += 1;\n    }\n    result\
    \ == x\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    let mut i = 1;\n    let mut result = n;\n    while result < x\
    \ {\n        result *= n;\n        i += 1;\n    }\n    result == x\n}\n\nfn main()\
    \ {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpiv1ejzpo.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 1;\n\
    \    let mut result = n;\n    while result < x {\n        result *= n;\n     \
    \   i += 1;\n    }\n    result == x\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 1;\n\
    \    let mut result = n;\n    while result <= x {\n        if result == x {\n\
    \            return true;\n        }\n        i += 1;\n        result = n.pow(i);\n\
    \    }\n    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n  \
    \  assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 1;\n\
    \    let mut result = n;\n    while result < x {\n        result *= n;\n     \
    \   i += 1;\n    }\n    result == x\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 0;\n\
    \    let mut result = 1;\n    while result < x {\n        i += 1;\n        result\
    \ = n.pow(i);\n    }\n    result == x\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010213
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 1;\n\
    \    while i <= x {\n        if i == x {\n            return true;\n        }\n\
    \        i *= n;\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 1;\n\
    \    let mut res = n;\n    while res <= x {\n        if res == x {\n         \
    \   return true;\n        }\n        i += 1;\n        res *= n;\n    }\n    false\n\
    }\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 1;\n\
    \    while i < x {\n        i *= n;\n        if i == x {\n            return true;\n\
    \        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 1;\n\
    \    while i.pow(n as u32) <= x {\n        if i.pow(n as u32) == x {\n       \
    \     return true;\n        }\n        i += 1;\n    }\n    false\n}\n\nfn main()\
    \ {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0689]: can't call method `pow` on ambiguous numeric type `{integer}`\n\
    \  --> /tmp/tmp7p61spy1.rs:22:13\n   |\n22 |     while i.pow(n as u32) <= x {\n\
    \   |             ^^^\n   |\nhelp: you must specify a type for this binding, like\
    \ `i32`\n   |\n21 |     let mut i: i32 = 1;\n   |         ~~~~~~~~~~\n\nerror[E0689]:\
    \ can't call method `pow` on ambiguous numeric type `{integer}`\n  --> /tmp/tmp7p61spy1.rs:23:14\n\
    \   |\n23 |         if i.pow(n as u32) == x {\n   |              ^^^\n   |\nhelp:\
    \ you must specify a type for this binding, like `i32`\n   |\n21 |     let mut\
    \ i: i32 = 1;\n   |         ~~~~~~~~~~\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0689`.\n"
  stdout: ''
  timestamp: 1660010212
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 1;\n\
    \    while i.pow(n as u32) <= x {\n        if i.pow(n as u32) == x {\n       \
    \     return true;\n        }\n        i += 1;\n    }\n    false\n}\n\nfn main()\
    \ {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0689]: can't call method `pow` on ambiguous numeric type `{integer}`\n\
    \  --> /tmp/tmp7p61spy1.rs:22:13\n   |\n22 |     while i.pow(n as u32) <= x {\n\
    \   |             ^^^\n   |\nhelp: you must specify a type for this binding, like\
    \ `i32`\n   |\n21 |     let mut i: i32 = 1;\n   |         ~~~~~~~~~~\n\nerror[E0689]:\
    \ can't call method `pow` on ambiguous numeric type `{integer}`\n  --> /tmp/tmp7p61spy1.rs:23:14\n\
    \   |\n23 |         if i.pow(n as u32) == x {\n   |              ^^^\n   |\nhelp:\
    \ you must specify a type for this binding, like `i32`\n   |\n21 |     let mut\
    \ i: i32 = 1;\n   |         ~~~~~~~~~~\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0689`.\n"
  stdout: ''
  timestamp: 1660010212
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    let mut result = n;\n    while result < x {\n        result *=\
    \ n;\n    }\n    result == x\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp0tjdfhdl.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010213
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 1;\n\
    \    while i < x {\n        i *= n;\n        if i == x {\n            return true;\n\
    \        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 1;\n\
    \    while i <= x {\n        if i == x {\n            return true;\n        }\n\
    \        i *= n;\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 1;\n\
    \    while i.pow(n as u32) <= x {\n        if i.pow(n as u32) == x {\n       \
    \     return true;\n        }\n        i += 1;\n    }\n    false\n}\n\nfn main()\
    \ {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0689]: can't call method `pow` on ambiguous numeric type `{integer}`\n\
    \  --> /tmp/tmp7p61spy1.rs:22:13\n   |\n22 |     while i.pow(n as u32) <= x {\n\
    \   |             ^^^\n   |\nhelp: you must specify a type for this binding, like\
    \ `i32`\n   |\n21 |     let mut i: i32 = 1;\n   |         ~~~~~~~~~~\n\nerror[E0689]:\
    \ can't call method `pow` on ambiguous numeric type `{integer}`\n  --> /tmp/tmp7p61spy1.rs:23:14\n\
    \   |\n23 |         if i.pow(n as u32) == x {\n   |              ^^^\n   |\nhelp:\
    \ you must specify a type for this binding, like `i32`\n   |\n21 |     let mut\
    \ i: i32 = 1;\n   |         ~~~~~~~~~~\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0689`.\n"
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 2;\n\
    \    let mut result = n;\n    while result <= x {\n        if result == x {\n\
    \            return true;\n        }\n        result *= n;\n        i += 1;\n\
    \    }\n    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n  \
    \  assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 1;\n\
    \    while i <= x {\n        if i == x {\n            return true;\n        }\n\
    \        i *= n;\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 1;\n\
    \    while i < x {\n        i *= n;\n        if i == x {\n            return true;\n\
    \        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 1;\n\
    \    while i < x {\n        i *= n;\n        if i == x {\n            return true;\n\
    \        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 0;\n\
    \    let mut result = n;\n    while result <= x {\n        if result == x {\n\
    \            return true;\n        }\n        i += 1;\n        result = n.pow(i);\n\
    \    }\n    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n  \
    \  assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010213
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 1;\n\
    \    let mut result = n;\n    while result < x {\n        result *= n;\n     \
    \   i += 1;\n    }\n    result == x\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 1;\n\
    \    while i < x {\n        i *= n;\n        if i == x {\n            return true;\n\
    \        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 1;\n\
    \    while i.pow(n as u32) <= x {\n        if i.pow(n as u32) == x {\n       \
    \     return true;\n        }\n        i += 1;\n    }\n    false\n}\n\nfn main()\
    \ {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0689]: can't call method `pow` on ambiguous numeric type `{integer}`\n\
    \  --> /tmp/tmp7p61spy1.rs:22:13\n   |\n22 |     while i.pow(n as u32) <= x {\n\
    \   |             ^^^\n   |\nhelp: you must specify a type for this binding, like\
    \ `i32`\n   |\n21 |     let mut i: i32 = 1;\n   |         ~~~~~~~~~~\n\nerror[E0689]:\
    \ can't call method `pow` on ambiguous numeric type `{integer}`\n  --> /tmp/tmp7p61spy1.rs:23:14\n\
    \   |\n23 |         if i.pow(n as u32) == x {\n   |              ^^^\n   |\nhelp:\
    \ you must specify a type for this binding, like `i32`\n   |\n21 |     let mut\
    \ i: i32 = 1;\n   |         ~~~~~~~~~~\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0689`.\n"
  stdout: ''
  timestamp: 1660010212
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    let mut i = 1;\n    while i.pow(n as u32) <= x {\n        if\
    \ i.pow(n as u32) == x {\n            return true;\n        }\n        i += 1;\n\
    \    }\n    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n  \
    \  assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0689]: can't call method `pow` on ambiguous numeric type `{integer}`\n\
    \  --> /tmp/tmp7ozxxqbl.rs:19:13\n   |\n19 |     while i.pow(n as u32) <= x {\n\
    \   |             ^^^\n   |\nhelp: you must specify a type for this binding, like\
    \ `i32`\n   |\n18 |     let mut i: i32 = 1;\n   |         ~~~~~~~~~~\n\nerror[E0689]:\
    \ can't call method `pow` on ambiguous numeric type `{integer}`\n  --> /tmp/tmp7ozxxqbl.rs:20:14\n\
    \   |\n20 |         if i.pow(n as u32) == x {\n   |              ^^^\n   |\nhelp:\
    \ you must specify a type for this binding, like `i32`\n   |\n18 |     let mut\
    \ i: i32 = 1;\n   |         ~~~~~~~~~~\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0689`.\n"
  stdout: ''
  timestamp: 1660010212
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    let mut i = 1;\n    let mut result = n;\n    while result < x\
    \ {\n        result *= n;\n        i += 1;\n    }\n    result == x\n}\n\nfn main()\
    \ {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpiv1ejzpo.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 1;\n\
    \    while i <= x {\n        if i == x {\n            return true;\n        }\n\
    \        i *= n;\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 1;\n\
    \    while i <= x {\n        if i == x {\n            return true;\n        }\n\
    \        i *= n;\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 1;\n\
    \    while i <= x {\n        if i == x {\n            return true;\n        }\n\
    \        i *= n;\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 2;\n\
    \    let mut result = n;\n    while result <= x {\n        if result == x {\n\
    \            return true;\n        }\n        result *= n;\n        i += 1;\n\
    \    }\n    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n  \
    \  assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 1;\n\
    \    while i <= x {\n        if i == x {\n            return true;\n        }\n\
    \        i *= n;\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 1;\n\
    \    while i <= x {\n        if i == x {\n            return true;\n        }\n\
    \        i *= n;\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 1;\n\
    \    while i.pow(n as u32) <= x {\n        if i.pow(n as u32) == x {\n       \
    \     return true;\n        }\n        i += 1;\n    }\n    false\n}\n\nfn main()\
    \ {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0689]: can't call method `pow` on ambiguous numeric type `{integer}`\n\
    \  --> /tmp/tmp7p61spy1.rs:22:13\n   |\n22 |     while i.pow(n as u32) <= x {\n\
    \   |             ^^^\n   |\nhelp: you must specify a type for this binding, like\
    \ `i32`\n   |\n21 |     let mut i: i32 = 1;\n   |         ~~~~~~~~~~\n\nerror[E0689]:\
    \ can't call method `pow` on ambiguous numeric type `{integer}`\n  --> /tmp/tmp7p61spy1.rs:23:14\n\
    \   |\n23 |         if i.pow(n as u32) == x {\n   |              ^^^\n   |\nhelp:\
    \ you must specify a type for this binding, like `i32`\n   |\n21 |     let mut\
    \ i: i32 = 1;\n   |         ~~~~~~~~~~\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0689`.\n"
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 2;\n\
    \    let mut result = n;\n    while result < x {\n        result *= n;\n     \
    \   i += 1;\n    }\n    result == x\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 1;\n\
    \    while i < x {\n        i *= n;\n        if i == x {\n            return true;\n\
    \        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 1;\n\
    \    let mut result = n;\n    while result < x {\n        result *= n;\n     \
    \   i += 1;\n    }\n    result == x\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 1;\n\
    \    while i < x {\n        i *= n;\n        if i == x {\n            return true;\n\
    \        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    if n == 1 {\n \
    \       return false;\n    }\n    let mut i = 1;\n    while i <= x {\n       \
    \ if i == x {\n            return true;\n        }\n        i *= n;\n    }\n \
    \   false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010213
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 1;\n\
    \    while i.pow(n as u32) <= x {\n        if i.pow(n as u32) == x {\n       \
    \     return true;\n        }\n        i += 1;\n    }\n    false\n}\n\nfn main()\
    \ {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0689]: can't call method `pow` on ambiguous numeric type `{integer}`\n\
    \  --> /tmp/tmp7p61spy1.rs:22:13\n   |\n22 |     while i.pow(n as u32) <= x {\n\
    \   |             ^^^\n   |\nhelp: you must specify a type for this binding, like\
    \ `i32`\n   |\n21 |     let mut i: i32 = 1;\n   |         ~~~~~~~~~~\n\nerror[E0689]:\
    \ can't call method `pow` on ambiguous numeric type `{integer}`\n  --> /tmp/tmp7p61spy1.rs:23:14\n\
    \   |\n23 |         if i.pow(n as u32) == x {\n   |              ^^^\n   |\nhelp:\
    \ you must specify a type for this binding, like `i32`\n   |\n21 |     let mut\
    \ i: i32 = 1;\n   |         ~~~~~~~~~~\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0689`.\n"
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    if n == 1 {\n \
    \       return false;\n    }\n    let mut y = n;\n    while y < x {\n        y\
    \ *= n;\n    }\n    y == x\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010213
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    let mut i = 1;\n    while i.pow(n as u32) <= x {\n        if\
    \ i.pow(n as u32) == x {\n            return true;\n        }\n        i += 1;\n\
    \    }\n    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n  \
    \  assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0689]: can't call method `pow` on ambiguous numeric type `{integer}`\n\
    \  --> /tmp/tmp7ozxxqbl.rs:19:13\n   |\n19 |     while i.pow(n as u32) <= x {\n\
    \   |             ^^^\n   |\nhelp: you must specify a type for this binding, like\
    \ `i32`\n   |\n18 |     let mut i: i32 = 1;\n   |         ~~~~~~~~~~\n\nerror[E0689]:\
    \ can't call method `pow` on ambiguous numeric type `{integer}`\n  --> /tmp/tmp7ozxxqbl.rs:20:14\n\
    \   |\n20 |         if i.pow(n as u32) == x {\n   |              ^^^\n   |\nhelp:\
    \ you must specify a type for this binding, like `i32`\n   |\n18 |     let mut\
    \ i: i32 = 1;\n   |         ~~~~~~~~~~\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0689`.\n"
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 1;\n\
    \    while i < x {\n        i *= n;\n        if i == x {\n            return true;\n\
    \        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 1;\n\
    \    let mut result = n;\n    while result < x {\n        result *= n;\n     \
    \   i += 1;\n    }\n    result == x\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    let mut i = 1;\n    while i.pow(n as u32) <= x {\n        if\
    \ i.pow(n as u32) == x {\n            return true;\n        }\n        i += 1;\n\
    \    }\n    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n  \
    \  assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0689]: can't call method `pow` on ambiguous numeric type `{integer}`\n\
    \  --> /tmp/tmp7ozxxqbl.rs:19:13\n   |\n19 |     while i.pow(n as u32) <= x {\n\
    \   |             ^^^\n   |\nhelp: you must specify a type for this binding, like\
    \ `i32`\n   |\n18 |     let mut i: i32 = 1;\n   |         ~~~~~~~~~~\n\nerror[E0689]:\
    \ can't call method `pow` on ambiguous numeric type `{integer}`\n  --> /tmp/tmp7ozxxqbl.rs:20:14\n\
    \   |\n20 |         if i.pow(n as u32) == x {\n   |              ^^^\n   |\nhelp:\
    \ you must specify a type for this binding, like `i32`\n   |\n18 |     let mut\
    \ i: i32 = 1;\n   |         ~~~~~~~~~~\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0689`.\n"
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 1;\n\
    \    while i <= x {\n        if i == x {\n            return true;\n        }\n\
    \        i *= n;\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    if n == 1 {\n \
    \       return false;\n    }\n    let mut i = 1;\n    let mut result = n;\n  \
    \  while result < x {\n        result *= n;\n        i += 1;\n    }\n    result\
    \ == x\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 0 {\n        return false;\n    }\n    let mut i = 1;\n\
    \    while i <= x {\n        if i == x {\n            return true;\n        }\n\
    \        i *= n;\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 0 {\n        return false;\n    }\n    let mut i = 1;\n\
    \    while i < x {\n        i *= n;\n    }\n    i == x\n}\n\nfn main() {\n   \
    \ let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010213
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 1;\n\
    \    while i < x {\n        i *= n;\n        if i == x {\n            return true;\n\
    \        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 1;\n\
    \    while i <= x {\n        if i == x {\n            return true;\n        }\n\
    \        i *= n;\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    if n == 1 {\n \
    \       return false;\n    }\n    let mut x = x;\n    let mut n = n;\n    while\
    \ x % n == 0 {\n        x /= n;\n        if x == 1 {\n            return true;\n\
    \        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010213
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 2;\n\
    \    let mut result = n;\n    while result <= x {\n        if result == x {\n\
    \            return true;\n        }\n        result *= n;\n        i += 1;\n\
    \    }\n    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n  \
    \  assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 1;\n\
    \    while i <= x {\n        if i == x {\n            return true;\n        }\n\
    \        i *= n;\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    let mut i = 1;\n    while i.pow(n as u32) <= x {\n        if\
    \ i.pow(n as u32) == x {\n            return true;\n        }\n        i += 1;\n\
    \    }\n    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n  \
    \  assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0689]: can't call method `pow` on ambiguous numeric type `{integer}`\n\
    \  --> /tmp/tmp7ozxxqbl.rs:19:13\n   |\n19 |     while i.pow(n as u32) <= x {\n\
    \   |             ^^^\n   |\nhelp: you must specify a type for this binding, like\
    \ `i32`\n   |\n18 |     let mut i: i32 = 1;\n   |         ~~~~~~~~~~\n\nerror[E0689]:\
    \ can't call method `pow` on ambiguous numeric type `{integer}`\n  --> /tmp/tmp7ozxxqbl.rs:20:14\n\
    \   |\n20 |         if i.pow(n as u32) == x {\n   |              ^^^\n   |\nhelp:\
    \ you must specify a type for this binding, like `i32`\n   |\n18 |     let mut\
    \ i: i32 = 1;\n   |         ~~~~~~~~~~\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0689`.\n"
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 1;\n\
    \    while i <= x {\n        if i == x {\n            return true;\n        }\n\
    \        i *= n;\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    if n == 1 {\n \
    \       return false;\n    }\n    let mut i = 1;\n    while i.pow(n as u32) <=\
    \ x {\n        if i.pow(n as u32) == x {\n            return true;\n        }\n\
    \        i += 1;\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0689]: can't call method `pow` on ambiguous numeric type `{integer}`\n\
    \  --> /tmp/tmp6772yo9e.rs:25:13\n   |\n25 |     while i.pow(n as u32) <= x {\n\
    \   |             ^^^\n   |\nhelp: you must specify a type for this binding, like\
    \ `i32`\n   |\n24 |     let mut i: i32 = 1;\n   |         ~~~~~~~~~~\n\nerror[E0689]:\
    \ can't call method `pow` on ambiguous numeric type `{integer}`\n  --> /tmp/tmp6772yo9e.rs:26:14\n\
    \   |\n26 |         if i.pow(n as u32) == x {\n   |              ^^^\n   |\nhelp:\
    \ you must specify a type for this binding, like `i32`\n   |\n24 |     let mut\
    \ i: i32 = 1;\n   |         ~~~~~~~~~~\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0689`.\n"
  stdout: ''
  timestamp: 1660010212
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 0 {\n        return false;\n    }\n    let mut i = 1;\n\
    \    let mut res = n;\n    while res <= x {\n        if res == x {\n         \
    \   return true;\n        }\n        i += 1;\n        res = n.pow(i);\n    }\n\
    \    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpedzdzog3.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010213
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 1;\n\
    \    while i <= x {\n        if i == x {\n            return true;\n        }\n\
    \        i *= n;\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    let mut i = 1;\n    while i < x {\n        i *= n;\n    }\n \
    \   i == x\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    if n == 1 {\n \
    \       return false;\n    }\n    let mut i = 1;\n    let mut result = n;\n  \
    \  while result < x {\n        result *= n;\n        i += 1;\n    }\n    result\
    \ == x\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    if n == 1 {\n \
    \       return false;\n    }\n    let mut i = 1;\n    while i.pow(n as u32) <=\
    \ x {\n        if i.pow(n as u32) == x {\n            return true;\n        }\n\
    \        i += 1;\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0689]: can't call method `pow` on ambiguous numeric type `{integer}`\n\
    \  --> /tmp/tmp6772yo9e.rs:25:13\n   |\n25 |     while i.pow(n as u32) <= x {\n\
    \   |             ^^^\n   |\nhelp: you must specify a type for this binding, like\
    \ `i32`\n   |\n24 |     let mut i: i32 = 1;\n   |         ~~~~~~~~~~\n\nerror[E0689]:\
    \ can't call method `pow` on ambiguous numeric type `{integer}`\n  --> /tmp/tmp6772yo9e.rs:26:14\n\
    \   |\n26 |         if i.pow(n as u32) == x {\n   |              ^^^\n   |\nhelp:\
    \ you must specify a type for this binding, like `i32`\n   |\n24 |     let mut\
    \ i: i32 = 1;\n   |         ~~~~~~~~~~\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0689`.\n"
  stdout: ''
  timestamp: 1660010212
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    let mut i = 1;\n    while i.pow(n as u32) <= x {\n        if\
    \ i.pow(n as u32) == x {\n            return true;\n        }\n        i += 1;\n\
    \    }\n    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n  \
    \  assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0689]: can't call method `pow` on ambiguous numeric type `{integer}`\n\
    \  --> /tmp/tmp7ozxxqbl.rs:19:13\n   |\n19 |     while i.pow(n as u32) <= x {\n\
    \   |             ^^^\n   |\nhelp: you must specify a type for this binding, like\
    \ `i32`\n   |\n18 |     let mut i: i32 = 1;\n   |         ~~~~~~~~~~\n\nerror[E0689]:\
    \ can't call method `pow` on ambiguous numeric type `{integer}`\n  --> /tmp/tmp7ozxxqbl.rs:20:14\n\
    \   |\n20 |         if i.pow(n as u32) == x {\n   |              ^^^\n   |\nhelp:\
    \ you must specify a type for this binding, like `i32`\n   |\n18 |     let mut\
    \ i: i32 = 1;\n   |         ~~~~~~~~~~\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0689`.\n"
  stdout: ''
  timestamp: 1660010212
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    let mut i = 1;\n    while i.pow(n as u32) <= x {\n        if\
    \ i.pow(n as u32) == x {\n            return true;\n        }\n        i += 1;\n\
    \    }\n    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n  \
    \  assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0689]: can't call method `pow` on ambiguous numeric type `{integer}`\n\
    \  --> /tmp/tmp7ozxxqbl.rs:19:13\n   |\n19 |     while i.pow(n as u32) <= x {\n\
    \   |             ^^^\n   |\nhelp: you must specify a type for this binding, like\
    \ `i32`\n   |\n18 |     let mut i: i32 = 1;\n   |         ~~~~~~~~~~\n\nerror[E0689]:\
    \ can't call method `pow` on ambiguous numeric type `{integer}`\n  --> /tmp/tmp7ozxxqbl.rs:20:14\n\
    \   |\n20 |         if i.pow(n as u32) == x {\n   |              ^^^\n   |\nhelp:\
    \ you must specify a type for this binding, like `i32`\n   |\n18 |     let mut\
    \ i: i32 = 1;\n   |         ~~~~~~~~~~\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0689`.\n"
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 2;\n\
    \    let mut result = n;\n    while result <= x {\n        if result == x {\n\
    \            return true;\n        }\n        result *= n;\n        i += 1;\n\
    \    }\n    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n  \
    \  assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    let mut i = 1;\n    while i.pow(n as u32) <= x {\n        if\
    \ i.pow(n as u32) == x {\n            return true;\n        }\n        i += 1;\n\
    \    }\n    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n  \
    \  assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0689]: can't call method `pow` on ambiguous numeric type `{integer}`\n\
    \  --> /tmp/tmp7ozxxqbl.rs:19:13\n   |\n19 |     while i.pow(n as u32) <= x {\n\
    \   |             ^^^\n   |\nhelp: you must specify a type for this binding, like\
    \ `i32`\n   |\n18 |     let mut i: i32 = 1;\n   |         ~~~~~~~~~~\n\nerror[E0689]:\
    \ can't call method `pow` on ambiguous numeric type `{integer}`\n  --> /tmp/tmp7ozxxqbl.rs:20:14\n\
    \   |\n20 |         if i.pow(n as u32) == x {\n   |              ^^^\n   |\nhelp:\
    \ you must specify a type for this binding, like `i32`\n   |\n18 |     let mut\
    \ i: i32 = 1;\n   |         ~~~~~~~~~~\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0689`.\n"
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 1;\n\
    \    let mut result = n;\n    while result < x {\n        result *= n;\n     \
    \   i += 1;\n    }\n    result == x\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 1;\n\
    \    while i < x {\n        i *= n;\n        if i == x {\n            return true;\n\
    \        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 1;\n\
    \    while n.pow(i) <= x {\n        if n.pow(i) == x {\n            return true;\n\
    \        }\n        i += 1;\n    }\n    false\n}\n\nfn main() {\n    let candidate\
    \ = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010213
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 1;\n\
    \    let mut r = n;\n    while r < x {\n        r *= n;\n        i += 1;\n   \
    \ }\n    r == x\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010213
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 1;\n\
    \    while n.pow(i) <= x {\n        if n.pow(i) == x {\n            return true;\n\
    \        }\n        i += 1;\n    }\n    false\n}\n\nfn main() {\n    let candidate\
    \ = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010213
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 1;\n\
    \    let mut result = n;\n    while result < x {\n        result *= n;\n     \
    \   i += 1;\n    }\n    result == x\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    let mut i = 1;\n    while i.pow(n as u32) <= x {\n        if\
    \ i.pow(n as u32) == x {\n            return true;\n        }\n        i += 1;\n\
    \    }\n    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n  \
    \  assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0689]: can't call method `pow` on ambiguous numeric type `{integer}`\n\
    \  --> /tmp/tmp7ozxxqbl.rs:19:13\n   |\n19 |     while i.pow(n as u32) <= x {\n\
    \   |             ^^^\n   |\nhelp: you must specify a type for this binding, like\
    \ `i32`\n   |\n18 |     let mut i: i32 = 1;\n   |         ~~~~~~~~~~\n\nerror[E0689]:\
    \ can't call method `pow` on ambiguous numeric type `{integer}`\n  --> /tmp/tmp7ozxxqbl.rs:20:14\n\
    \   |\n20 |         if i.pow(n as u32) == x {\n   |              ^^^\n   |\nhelp:\
    \ you must specify a type for this binding, like `i32`\n   |\n18 |     let mut\
    \ i: i32 = 1;\n   |         ~~~~~~~~~~\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0689`.\n"
  stdout: ''
  timestamp: 1660010212
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 1;\n\
    \    while i.pow(n as u32) <= x {\n        if i.pow(n as u32) == x {\n       \
    \     return true;\n        }\n        i += 1;\n    }\n    false\n}\n\nfn main()\
    \ {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0689]: can't call method `pow` on ambiguous numeric type `{integer}`\n\
    \  --> /tmp/tmp7p61spy1.rs:22:13\n   |\n22 |     while i.pow(n as u32) <= x {\n\
    \   |             ^^^\n   |\nhelp: you must specify a type for this binding, like\
    \ `i32`\n   |\n21 |     let mut i: i32 = 1;\n   |         ~~~~~~~~~~\n\nerror[E0689]:\
    \ can't call method `pow` on ambiguous numeric type `{integer}`\n  --> /tmp/tmp7p61spy1.rs:23:14\n\
    \   |\n23 |         if i.pow(n as u32) == x {\n   |              ^^^\n   |\nhelp:\
    \ you must specify a type for this binding, like `i32`\n   |\n21 |     let mut\
    \ i: i32 = 1;\n   |         ~~~~~~~~~~\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0689`.\n"
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    if n == 1 {\n \
    \       return false;\n    }\n    let mut i = 2;\n    let mut result = n;\n  \
    \  while result < x {\n        result *= n;\n        i += 1;\n    }\n    result\
    \ == x\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 2;\n\
    \    let mut result = n;\n    while result < x {\n        result *= n;\n     \
    \   i += 1;\n    }\n    result == x\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 2;\n\
    \    let mut res = n;\n    while res < x {\n        res *= n;\n        i += 1;\n\
    \    }\n    res == x\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut power =\
    \ n;\n    while power < x {\n        power *= n;\n    }\n    power == x\n}\n\n\
    fn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 1;\n\
    \    while i < x {\n        i *= n;\n        if i == x {\n            return true;\n\
    \        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 0 || n == 0 {\n        return false;\n    }\n    let\
    \ mut tmp = n;\n    while tmp < x {\n        tmp *= n;\n    }\n    tmp == x\n\
    }\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp8az7k31t.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010213
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    let mut i = 1;\n    while i <= x {\n        if i == x {\n   \
    \         return true;\n        }\n        i *= n;\n    }\n    false\n}\n\nfn\
    \ main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 2;\n\
    \    let mut result = n;\n    while result < x {\n        result *= n;\n     \
    \   i += 1;\n    }\n    result == x\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    let mut i = 1;\n    while i.pow(n as u32) <= x {\n        if\
    \ i.pow(n as u32) == x {\n            return true;\n        }\n        i += 1;\n\
    \    }\n    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n  \
    \  assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0689]: can't call method `pow` on ambiguous numeric type `{integer}`\n\
    \  --> /tmp/tmp7ozxxqbl.rs:19:13\n   |\n19 |     while i.pow(n as u32) <= x {\n\
    \   |             ^^^\n   |\nhelp: you must specify a type for this binding, like\
    \ `i32`\n   |\n18 |     let mut i: i32 = 1;\n   |         ~~~~~~~~~~\n\nerror[E0689]:\
    \ can't call method `pow` on ambiguous numeric type `{integer}`\n  --> /tmp/tmp7ozxxqbl.rs:20:14\n\
    \   |\n20 |         if i.pow(n as u32) == x {\n   |              ^^^\n   |\nhelp:\
    \ you must specify a type for this binding, like `i32`\n   |\n18 |     let mut\
    \ i: i32 = 1;\n   |         ~~~~~~~~~~\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0689`.\n"
  stdout: ''
  timestamp: 1660010212
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    let mut i = 0;\n    let mut result = n;\n    while result < x\
    \ {\n        result *= n;\n        i += 1;\n    }\n    result == x\n}\n\nfn main()\
    \ {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmptfk16mgh.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010213
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 1;\n\
    \    while i <= x {\n        if i == x {\n            return true;\n        }\n\
    \        i *= n;\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 1;\n\
    \    while i < x {\n        i *= n;\n        if i == x {\n            return true;\n\
    \        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 2;\n\
    \    let mut result = n;\n    while result < x {\n        result *= n;\n     \
    \   i += 1;\n    }\n    result == x\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 1;\n\
    \    let mut result = n;\n    while result < x {\n        result *= n;\n     \
    \   i += 1;\n    }\n    result == x\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    if n == 1 {\n \
    \       return false;\n    }\n    let mut result = n;\n    while result < x {\n\
    \        result *= n;\n    }\n    result == x\n}\n\nfn main() {\n    let candidate\
    \ = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    if n == 1 {\n \
    \       return false;\n    }\n    let mut i = 1;\n    while n.pow(i) <= x {\n\
    \        if n.pow(i) == x {\n            return true;\n        }\n        i +=\
    \ 1;\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010213
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut power =\
    \ n;\n    while power < x {\n        power *= n;\n    }\n    power == x\n}\n\n\
    fn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    let mut i = 1;\n    while i.pow(n as u32) <= x {\n        if\
    \ i.pow(n as u32) == x {\n            return true;\n        }\n        i += 1;\n\
    \    }\n    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n  \
    \  assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0689]: can't call method `pow` on ambiguous numeric type `{integer}`\n\
    \  --> /tmp/tmp7ozxxqbl.rs:19:13\n   |\n19 |     while i.pow(n as u32) <= x {\n\
    \   |             ^^^\n   |\nhelp: you must specify a type for this binding, like\
    \ `i32`\n   |\n18 |     let mut i: i32 = 1;\n   |         ~~~~~~~~~~\n\nerror[E0689]:\
    \ can't call method `pow` on ambiguous numeric type `{integer}`\n  --> /tmp/tmp7ozxxqbl.rs:20:14\n\
    \   |\n20 |         if i.pow(n as u32) == x {\n   |              ^^^\n   |\nhelp:\
    \ you must specify a type for this binding, like `i32`\n   |\n18 |     let mut\
    \ i: i32 = 1;\n   |         ~~~~~~~~~~\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0689`.\n"
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 0 {\n        return false;\n    }\n    if n == 0 {\n\
    \        return false;\n    }\n    if x == 1 {\n        return true;\n    }\n\
    \    let mut i = 1;\n    let mut result = n;\n    while result < x {\n       \
    \ result *= n;\n        i += 1;\n    }\n    result == x\n}\n\nfn main() {\n  \
    \  let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010213
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 1;\n\
    \    while i <= x {\n        if i == x {\n            return true;\n        }\n\
    \        i *= n;\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n\n    let mut power\
    \ = n;\n    while power < x {\n        power *= n;\n    }\n\n    power == x\n\
    }\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010213
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 1;\n\
    \    while i < x {\n        i *= n;\n        if i == x {\n            return true;\n\
    \        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 1;\n\
    \    while i <= x {\n        if i == x {\n            return true;\n        }\n\
    \        i *= n;\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 1;\n\
    \    while i <= x {\n        if i == x {\n            return true;\n        }\n\
    \        i *= n;\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 1;\n\
    \    while i < x {\n        i *= n;\n        if i == x {\n            return true;\n\
    \        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    if n == 1 {\n \
    \       return false;\n    }\n    let mut i = 1;\n    let mut result = n;\n  \
    \  while result < x {\n        result *= n;\n        i += 1;\n    }\n    result\
    \ == x\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    if n == 1 {\n \
    \       return false;\n    }\n    let mut i = 1;\n    let mut result = n;\n  \
    \  while result < x {\n        result *= n;\n        i += 1;\n    }\n    result\
    \ == x\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 1;\n\
    \    while i.pow(n as u32) <= x {\n        if i.pow(n as u32) == x {\n       \
    \     return true;\n        }\n        i += 1;\n    }\n    false\n}\n\nfn main()\
    \ {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0689]: can't call method `pow` on ambiguous numeric type `{integer}`\n\
    \  --> /tmp/tmp7p61spy1.rs:22:13\n   |\n22 |     while i.pow(n as u32) <= x {\n\
    \   |             ^^^\n   |\nhelp: you must specify a type for this binding, like\
    \ `i32`\n   |\n21 |     let mut i: i32 = 1;\n   |         ~~~~~~~~~~\n\nerror[E0689]:\
    \ can't call method `pow` on ambiguous numeric type `{integer}`\n  --> /tmp/tmp7p61spy1.rs:23:14\n\
    \   |\n23 |         if i.pow(n as u32) == x {\n   |              ^^^\n   |\nhelp:\
    \ you must specify a type for this binding, like `i32`\n   |\n21 |     let mut\
    \ i: i32 = 1;\n   |         ~~~~~~~~~~\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0689`.\n"
  stdout: ''
  timestamp: 1660010212
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 1;\n\
    \    while i.pow(n as u32) <= x {\n        if i.pow(n as u32) == x {\n       \
    \     return true;\n        }\n        i += 1;\n    }\n    false\n}\n\nfn main()\
    \ {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0689]: can't call method `pow` on ambiguous numeric type `{integer}`\n\
    \  --> /tmp/tmp7p61spy1.rs:22:13\n   |\n22 |     while i.pow(n as u32) <= x {\n\
    \   |             ^^^\n   |\nhelp: you must specify a type for this binding, like\
    \ `i32`\n   |\n21 |     let mut i: i32 = 1;\n   |         ~~~~~~~~~~\n\nerror[E0689]:\
    \ can't call method `pow` on ambiguous numeric type `{integer}`\n  --> /tmp/tmp7p61spy1.rs:23:14\n\
    \   |\n23 |         if i.pow(n as u32) == x {\n   |              ^^^\n   |\nhelp:\
    \ you must specify a type for this binding, like `i32`\n   |\n21 |     let mut\
    \ i: i32 = 1;\n   |         ~~~~~~~~~~\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0689`.\n"
  stdout: ''
  timestamp: 1660010212
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    let mut i = 1;\n    let mut result = n;\n    while result < x\
    \ {\n        result *= n;\n        i += 1;\n    }\n    result == x\n}\n\nfn main()\
    \ {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpiv1ejzpo.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010212
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    if n == 1 {\n \
    \       return false;\n    }\n    let mut i = 1;\n    while i.pow(n as u32) <=\
    \ x {\n        if i.pow(n as u32) == x {\n            return true;\n        }\n\
    \        i += 1;\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0689]: can't call method `pow` on ambiguous numeric type `{integer}`\n\
    \  --> /tmp/tmp6772yo9e.rs:25:13\n   |\n25 |     while i.pow(n as u32) <= x {\n\
    \   |             ^^^\n   |\nhelp: you must specify a type for this binding, like\
    \ `i32`\n   |\n24 |     let mut i: i32 = 1;\n   |         ~~~~~~~~~~\n\nerror[E0689]:\
    \ can't call method `pow` on ambiguous numeric type `{integer}`\n  --> /tmp/tmp6772yo9e.rs:26:14\n\
    \   |\n26 |         if i.pow(n as u32) == x {\n   |              ^^^\n   |\nhelp:\
    \ you must specify a type for this binding, like `i32`\n   |\n24 |     let mut\
    \ i: i32 = 1;\n   |         ~~~~~~~~~~\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0689`.\n"
  stdout: ''
  timestamp: 1660010212
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    let mut i = 1;\n    let mut result = n;\n    while result < x\
    \ {\n        result *= n;\n        i += 1;\n    }\n    result == x\n}\n\nfn main()\
    \ {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpiv1ejzpo.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 1;\n\
    \    while i <= x {\n        if i == x {\n            return true;\n        }\n\
    \        i *= n;\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 1;\n\
    \    while i < x {\n        i *= n;\n        if i == x {\n            return true;\n\
    \        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    let mut i = 1;\n    while i.pow(n as u32) <= x {\n        if\
    \ i.pow(n as u32) == x {\n            return true;\n        }\n        i += 1;\n\
    \    }\n    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n  \
    \  assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0689]: can't call method `pow` on ambiguous numeric type `{integer}`\n\
    \  --> /tmp/tmp7ozxxqbl.rs:19:13\n   |\n19 |     while i.pow(n as u32) <= x {\n\
    \   |             ^^^\n   |\nhelp: you must specify a type for this binding, like\
    \ `i32`\n   |\n18 |     let mut i: i32 = 1;\n   |         ~~~~~~~~~~\n\nerror[E0689]:\
    \ can't call method `pow` on ambiguous numeric type `{integer}`\n  --> /tmp/tmp7ozxxqbl.rs:20:14\n\
    \   |\n20 |         if i.pow(n as u32) == x {\n   |              ^^^\n   |\nhelp:\
    \ you must specify a type for this binding, like `i32`\n   |\n18 |     let mut\
    \ i: i32 = 1;\n   |         ~~~~~~~~~~\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0689`.\n"
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 1;\n\
    \    while i < x {\n        i *= n;\n        if i == x {\n            return true;\n\
    \        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 1;\n\
    \    while i < x {\n        i *= n;\n        if i == x {\n            return true;\n\
    \        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 1;\n\
    \    while i.pow(n as u32) <= x {\n        if i.pow(n as u32) == x {\n       \
    \     return true;\n        }\n        i += 1;\n    }\n    false\n}\n\nfn main()\
    \ {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0689]: can't call method `pow` on ambiguous numeric type `{integer}`\n\
    \  --> /tmp/tmp7p61spy1.rs:22:13\n   |\n22 |     while i.pow(n as u32) <= x {\n\
    \   |             ^^^\n   |\nhelp: you must specify a type for this binding, like\
    \ `i32`\n   |\n21 |     let mut i: i32 = 1;\n   |         ~~~~~~~~~~\n\nerror[E0689]:\
    \ can't call method `pow` on ambiguous numeric type `{integer}`\n  --> /tmp/tmp7p61spy1.rs:23:14\n\
    \   |\n23 |         if i.pow(n as u32) == x {\n   |              ^^^\n   |\nhelp:\
    \ you must specify a type for this binding, like `i32`\n   |\n21 |     let mut\
    \ i: i32 = 1;\n   |         ~~~~~~~~~~\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0689`.\n"
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 1;\n\
    \    while i <= x {\n        if i == x {\n            return true;\n        }\n\
    \        i *= n;\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    if n == 1 {\n \
    \       return false;\n    }\n    let mut i = 1;\n    let mut result = n;\n  \
    \  while result <= x {\n        if result == x {\n            return true;\n \
    \       }\n        i += 1;\n        result = n.pow(i);\n    }\n    false\n}\n\n\
    fn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 1;\n\
    \    let mut result = n;\n    while result < x {\n        result *= n;\n     \
    \   i += 1;\n    }\n    result == x\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 1;\n\
    \    let mut r = n;\n    while r < x {\n        r *= n;\n        i += 1;\n   \
    \ }\n    r == x\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010213
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 2;\n\
    \    let mut res = n;\n    while res < x {\n        res *= n;\n        i += 1;\n\
    \    }\n    res == x\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010212
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 1;\n\
    \    while i.pow(n as u32) <= x {\n        if i.pow(n as u32) == x {\n       \
    \     return true;\n        }\n        i += 1;\n    }\n    false\n}\n\nfn main()\
    \ {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0689]: can't call method `pow` on ambiguous numeric type `{integer}`\n\
    \  --> /tmp/tmp7p61spy1.rs:22:13\n   |\n22 |     while i.pow(n as u32) <= x {\n\
    \   |             ^^^\n   |\nhelp: you must specify a type for this binding, like\
    \ `i32`\n   |\n21 |     let mut i: i32 = 1;\n   |         ~~~~~~~~~~\n\nerror[E0689]:\
    \ can't call method `pow` on ambiguous numeric type `{integer}`\n  --> /tmp/tmp7p61spy1.rs:23:14\n\
    \   |\n23 |         if i.pow(n as u32) == x {\n   |              ^^^\n   |\nhelp:\
    \ you must specify a type for this binding, like `i32`\n   |\n21 |     let mut\
    \ i: i32 = 1;\n   |         ~~~~~~~~~~\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0689`.\n"
  stdout: ''
  timestamp: 1660010212
- exit_code: 101
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    let mut i = 1;\n    let mut result = n;\n    while result < x\
    \ {\n        result *= n;\n        i += 1;\n    }\n    result == x\n}\n\nfn main()\
    \ {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpiv1ejzpo.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010212
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    if n == 1 {\n \
    \       return false;\n    }\n    let mut i = 1;\n    let mut result = n;\n  \
    \  while result < x {\n        result *= n;\n        i += 1;\n    }\n    if result\
    \ == x {\n        return true;\n    }\n    false\n}\n\nfn main() {\n    let candidate\
    \ = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010213
- exit_code: 1
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n    let mut i = 0;\n\
    \    while i < x {\n        if n.pow(i) == x {\n            return true;\n   \
    \     }\n        i += 1;\n    }\n    false\n}\n\nfn main() {\n    let candidate\
    \ = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpyqqx0cyc.rs:23:18\n   |\n\
    23 |         if n.pow(i) == x {\n   |                  ^ expected `u32`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `u32` and panic if the\
    \ converted value doesn't fit\n   |\n23 |         if n.pow(i.try_into().unwrap())\
    \ == x {\n   |                   ++++++++++++++++++++\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010213
- exit_code: 0
  program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// >>> is_simple_power(1, 4)\n/// true\n\
    /// >>> is_simple_power(2, 2)\n/// true\n/// >>> is_simple_power(8, 2)\n/// true\n\
    /// >>> is_simple_power(3, 2)\n/// false\n/// >>> is_simple_power(3, 1)\n/// false\n\
    /// >>> is_simple_power(5, 3)\n/// false\nfn is_simple_power(x: isize, n: isize)\
    \ -> bool {\n    if x == 1 {\n        return true;\n    }\n\n    let mut i = 1;\n\
    \    let mut result = n;\n    while result <= x {\n        if result == x {\n\
    \            return true;\n        }\n        i += 1;\n        result = n.pow(i);\n\
    \    }\n\n    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010213
