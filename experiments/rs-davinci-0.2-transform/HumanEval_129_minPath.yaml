name: HumanEval_129_minPath
language: rs
prompt: "/// Given a grid with N rows and N columns (N >= 2) and a positive integer\
  \ k, \n/// each cell of the grid contains a value. Every integer in the range [1,\
  \ N * N]\n/// inclusive appears exactly once on the cells of the grid.\n/// You\
  \ have to find the minimum path of length k in the grid. You can start\n/// from\
  \ any cell, and in each step you can move to any of the neighbor cells,\n/// in\
  \ other words, you can go to cells which share an edge with you current\n/// cell.\n\
  /// Please note that a path of length k means visiting exactly k cells (not\n///\
  \ necessarily distinct).\n/// You CANNOT go off the grid.\n/// A path A (of length\
  \ k) is considered less than a path B (of length k) if\n/// after making the ordered\
  \ lists of the values on the cells that A and B go\n/// through (let's call them\
  \ lst_A and lst_B), lst_A is lexicographically less\n/// than lst_B, in other words,\
  \ there exist an integer index i (1 <= i <= k)\n/// such that lst_A[i] < lst_B[i]\
  \ and for any j (1 <= j < i) we have\n/// lst_A[j] = lst_B[j].\n/// It is guaranteed\
  \ that the answer is unique.\n/// Return an ordered list of the values on the cells\
  \ that the minimum path go through.\n/// Examples:    \n/// >>> minPath(vec![vec![1,\
  \ 2, 3], vec![4, 5, 6], vec![7, 8, 9]], 3)\n/// vec![1, 2, 1]\n/// >>> minPath(vec![vec![5,\
  \ 9, 3], vec![4, 1, 6], vec![7, 8, 2]], 1)\n/// vec![1]\nfn minPath(grid: Vec<Vec<isize>>,\
  \ k: isize) -> Vec<isize> {\n"
tests: "}\n\nfn main() {\n    let candidate = minPath;\n    assert_eq!({left}, {right});\n\
  \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
  \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
  \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
  \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
  }\n"
completions: ["    let mut grid = grid;\n    let n = grid.len();\n    let mut path\
    \ = Vec::new();\n    let mut cur = (0, 0);\n    let mut visited = vec![vec![false;\
    \ n]; n];\n    visited[0][0] = true;\n    for _ in 0..k {\n        let mut min\
    \ = isize::max_value();\n        let mut next = (0, 0);\n        for &(i, j) in\
    \ &[(cur.0 - 1, cur.1), (cur.0 + 1, cur.1),\n                         (cur.0,\
    \ cur.1 - 1), (cur.0, cur.1 + 1)] {\n            if i >= 0 && i < n && j >= 0\
    \ && j < n && !visited[i][j] {\n                if grid[i][j] < min {\n      \
    \              min = grid[i][j];\n                    next = (i, j);\n       \
    \         }\n            }\n        }\n        path.push(grid[cur.0][cur.1]);\n\
    \        cur = next;\n        visited[cur.0][cur.1] = true;\n    }\n    path.push(grid[cur.0][cur.1]);\n\
    \    path", "    let mut grid = grid;\n    let mut result = Vec::new();\n    let\
    \ mut i = 0;\n    let mut j = 0;\n    let mut k = k;\n    while k > 0 {\n    \
    \    result.push(grid[i][j]);\n        let mut min = std::isize::MAX;\n      \
    \  let mut min_i = 0;\n        let mut min_j = 0;\n        if i > 0 && grid[i\
    \ - 1][j] < min {\n            min = grid[i - 1][j];\n            min_i = i -\
    \ 1;\n            min_j = j;\n        }\n        if i < grid.len() - 1 && grid[i\
    \ + 1][j] < min {\n            min = grid[i + 1][j];\n            min_i = i +\
    \ 1;\n            min_j = j;\n        }\n        if j > 0 && grid[i][j - 1] <\
    \ min {\n            min = grid[i][j - 1];\n            min_i = i;\n         \
    \   min_j = j - 1;\n        }\n        if j < grid[0].len() - 1 && grid[i][j +\
    \ 1] < min {\n            min = grid[i][j + 1];\n            min_i = i;\n    \
    \        min_j = j + 1;\n        }\n        i = min_i;\n        j = min_j;\n \
    \       k -= 1;\n    }\n    result", "    let n = grid.len();\n    let mut dp\
    \ = vec![vec![vec![vec![]; n]; n]; k as usize + 1];\n    for i in 0..n {\n   \
    \     for j in 0..n {\n            dp[0][i][j] = vec![grid[i][j]];\n        }\n\
    \    }\n    for l in 1..=k as usize {\n        for i in 0..n {\n            for\
    \ j in 0..n {\n                let mut min_path = vec![];\n                if\
    \ i > 0 {\n                    let mut path = dp[l - 1][i - 1][j].clone();\n \
    \                   path.push(grid[i][j]);\n                    if min_path.is_empty()\
    \ || path < min_path {\n                        min_path = path;\n           \
    \         }\n                }\n                if i < n - 1 {\n             \
    \       let mut path = dp[l - 1][i + 1][j].clone();\n                    path.push(grid[i][j]);\n\
    \                    if min_path.is_empty() || path < min_path {\n           \
    \             min_path = path;\n                    }\n                }\n   \
    \             if j > 0 {\n                    let mut path = dp[l - 1][i][j -\
    \ 1].clone();\n                    path.push(grid[i][j]);\n                  \
    \  if min_path.is_empty() || path < min_path {\n                        min_path\
    \ = path;\n                    }\n                }\n                if j < n\
    \ - 1 {\n                    let mut path = dp[l - 1][i][j + 1].clone();\n   \
    \                 path.push(grid[i][j]);\n                    if min_path.is_empty()\
    \ || path < min_path {\n                        min_path = path;\n           \
    \         }\n                }\n                dp[l][i][j] = min_path;\n    \
    \        }\n        }\n    }\n    dp[k as usize][0][0].clone()", "    let n =\
    \ grid.len();\n    let mut dp = vec![vec![vec![vec![]; n]; n]; k as usize + 1];\n\
    \    for i in 0..n {\n        for j in 0..n {\n            dp[0][i][j] = vec![grid[i][j]];\n\
    \        }\n    }\n    for l in 1..k as usize + 1 {\n        for i in 0..n {\n\
    \            for j in 0..n {\n                let mut min_path = vec![];\n   \
    \             if i > 0 {\n                    let mut path = dp[l - 1][i - 1][j].clone();\n\
    \                    path.push(grid[i][j]);\n                    if min_path.is_empty()\
    \ || path < min_path {\n                        min_path = path;\n           \
    \         }\n                }\n                if i < n - 1 {\n             \
    \       let mut path = dp[l - 1][i + 1][j].clone();\n                    path.push(grid[i][j]);\n\
    \                    if min_path.is_empty() || path < min_path {\n           \
    \             min_path = path;\n                    }\n                }\n   \
    \             if j > 0 {\n                    let mut path = dp[l - 1][i][j -\
    \ 1].clone();\n                    path.push(grid[i][j]);\n                  \
    \  if min_path.is_empty() || path < min_path {\n                        min_path\
    \ = path;\n                    }\n                }\n                if j < n\
    \ - 1 {\n                    let mut path = dp[l - 1][i][j + 1].clone();\n   \
    \                 path.push(grid[i][j]);\n                    if min_path.is_empty()\
    \ || path < min_path {\n                        min_path = path;\n           \
    \         }\n                }\n                dp[l][i][j] = min_path;\n    \
    \        }\n        }\n    }\n    dp[k as usize][0][0].clone()", "    let n =\
    \ grid.len();\n    let mut dp = vec![vec![vec![vec![]; n]; n]; k as usize + 1];\n\
    \    let mut min_path = vec![];\n    let mut min_sum = std::isize::MAX;\n    for\
    \ i in 0..n {\n        for j in 0..n {\n            dp[0][i][j] = vec![grid[i][j]];\n\
    \            if grid[i][j] < min_sum {\n                min_sum = grid[i][j];\n\
    \                min_path = dp[0][i][j].clone();\n            }\n        }\n \
    \   }\n    for t in 1..=k as usize {\n        for i in 0..n {\n            for\
    \ j in 0..n {\n                let mut min_sum = std::isize::MAX;\n          \
    \      let mut min_path = vec![];\n                for &(di, dj) in &[(0, 1),\
    \ (0, -1), (1, 0), (-1, 0)] {\n                    let ni = i as isize + di;\n\
    \                    let nj = j as isize + dj;\n                    if ni >= 0\
    \ && ni < n as isize && nj >= 0 && nj < n as isize {\n                       \
    \ let mut path = dp[t - 1][ni as usize][nj as usize].clone();\n              \
    \          path.push(grid[i][j]);\n                        let sum = path.iter().sum();\n\
    \                        if sum < min_sum {\n                            min_sum\
    \ = sum;\n                            min_path = path;\n                     \
    \   }\n                    }\n                }\n                dp[t][i][j] =\
    \ min_path;\n            }\n        }\n    }\n    dp[k as usize][0][0].clone()",
  "    let n = grid.len();\n    let mut dp = vec![vec![vec![vec![]; n]; n]; k as usize\
    \ + 1];\n    for i in 0..n {\n        for j in 0..n {\n            dp[0][i][j]\
    \ = vec![grid[i][j]];\n        }\n    }\n    for l in 1..=k as usize {\n     \
    \   for i in 0..n {\n            for j in 0..n {\n                let mut min\
    \ = vec![];\n                if i > 0 {\n                    let mut tmp = dp[l\
    \ - 1][i - 1][j].clone();\n                    tmp.push(grid[i][j]);\n       \
    \             if min.is_empty() || tmp < min {\n                        min =\
    \ tmp;\n                    }\n                }\n                if i < n - 1\
    \ {\n                    let mut tmp = dp[l - 1][i + 1][j].clone();\n        \
    \            tmp.push(grid[i][j]);\n                    if min.is_empty() || tmp\
    \ < min {\n                        min = tmp;\n                    }\n       \
    \         }\n                if j > 0 {\n                    let mut tmp = dp[l\
    \ - 1][i][j - 1].clone();\n                    tmp.push(grid[i][j]);\n       \
    \             if min.is_empty() || tmp < min {\n                        min =\
    \ tmp;\n                    }\n                }\n                if j < n - 1\
    \ {\n                    let mut tmp = dp[l - 1][i][j + 1].clone();\n        \
    \            tmp.push(grid[i][j]);\n                    if min.is_empty() || tmp\
    \ < min {\n                        min = tmp;\n                    }\n       \
    \         }\n                dp[l][i][j] = min;\n            }\n        }\n  \
    \  }\n    dp[k as usize][0][0].clone()", "    let n = grid.len();\n    let mut\
    \ dp = vec![vec![vec![None; n]; n]; k as usize + 1];\n    let mut ans = vec![];\n\
    \    let mut min = std::isize::MAX;\n    for i in 0..n {\n        for j in 0..n\
    \ {\n            let mut cur = vec![];\n            let mut val = dfs(&grid, &mut\
    \ dp, i, j, k, &mut cur);\n            if val < min {\n                min = val;\n\
    \                ans = cur;\n            }\n        }\n    }\n    ans", "    let\
    \ mut res = Vec::new();\n    let mut min = std::isize::MAX;\n    let mut min_path\
    \ = Vec::new();\n    let mut visited = vec![vec![false; grid.len()]; grid.len()];\n\
    \    let mut path = Vec::new();\n    let mut dfs = |x: usize, y: usize, k: isize|\
    \ {\n        if k == 0 {\n            let mut path_sum = 0;\n            for i\
    \ in 0..path.len() {\n                path_sum += path[i];\n            }\n  \
    \          if path_sum < min {\n                min = path_sum;\n            \
    \    min_path = path.clone();\n            }\n            return;\n        }\n\
    \        if x > 0 && !visited[x - 1][y] {\n            visited[x - 1][y] = true;\n\
    \            path.push(grid[x - 1][y]);\n            dfs(x - 1, y, k - 1);\n \
    \           path.pop();\n            visited[x - 1][y] = false;\n        }\n \
    \       if x < grid.len() - 1 && !visited[x + 1][y] {\n            visited[x +\
    \ 1][y] = true;\n            path.push(grid[x + 1][y]);\n            dfs(x + 1,\
    \ y, k - 1);\n            path.pop();\n            visited[x + 1][y] = false;\n\
    \        }\n        if y > 0 && !visited[x][y - 1] {\n            visited[x][y\
    \ - 1] = true;\n            path.push(grid[x][y - 1]);\n            dfs(x, y -\
    \ 1, k - 1);\n            path.pop();\n            visited[x][y - 1] = false;\n\
    \        }\n        if y < grid.len() - 1 && !visited[x][y + 1] {\n          \
    \  visited[x][y + 1] = true;\n            path.push(grid[x][y + 1]);\n       \
    \     dfs(x, y + 1, k - 1);\n            path.pop();\n            visited[x][y\
    \ + 1] = false;\n        }\n   ", "    let mut grid = grid;\n    let mut k = k;\n\
    \    let mut path = Vec::new();\n    let mut i = 0;\n    let mut j = 0;\n    while\
    \ k > 0 {\n        path.push(grid[i][j]);\n        grid[i][j] = 0;\n        let\
    \ mut min = grid[i][j];\n        let mut min_i = i;\n        let mut min_j = j;\n\
    \        if i > 0 && grid[i - 1][j] > 0 && grid[i - 1][j] < min {\n          \
    \  min = grid[i - 1][j];\n            min_i = i - 1;\n            min_j = j;\n\
    \        }\n        if i < grid.len() - 1 && grid[i + 1][j] > 0 && grid[i + 1][j]\
    \ < min {\n            min = grid[i + 1][j];\n            min_i = i + 1;\n   \
    \         min_j = j;\n        }\n        if j > 0 && grid[i][j - 1] > 0 && grid[i][j\
    \ - 1] < min {\n            min = grid[i][j - 1];\n            min_i = i;\n  \
    \          min_j = j - 1;\n        }\n        if j < grid[0].len() - 1 && grid[i][j\
    \ + 1] > 0 && grid[i][j + 1] < min {\n            min = grid[i][j + 1];\n    \
    \        min_i = i;\n            min_j = j + 1;\n        }\n        i = min_i;\n\
    \        j = min_j;\n        k -= 1;\n    }\n    path", "    let n = grid.len();\n\
    \    let mut dp = vec![vec![vec![vec![]; k as usize + 1]; n]; n];\n    let mut\
    \ min_path = vec![];\n    let mut min_val = std::isize::MAX;\n    for i in 0..n\
    \ {\n        for j in 0..n {\n            dp[i][j][0] = vec![grid[i][j]];\n  \
    \          if grid[i][j] < min_val {\n                min_val = grid[i][j];\n\
    \                min_path = vec![grid[i][j]];\n            }\n        }\n    }\n\
    \    for l in 1..=k {\n        for i in 0..n {\n            for j in 0..n {\n\
    \                let mut min_val = std::isize::MAX;\n                let mut min_path\
    \ = vec![];\n                if i > 0 {\n                    let mut path = dp[i\
    \ - 1][j][(l - 1) as usize].clone();\n                    path.push(grid[i][j]);\n\
    \                    if path < min_path || min_path.is_empty() {\n           \
    \             min_path = path;\n                        min_val = path[l as usize\
    \ - 1];\n                    }\n                }\n                if i < n -\
    \ 1 {\n                    let mut path = dp[i + 1][j][(l - 1) as usize].clone();\n\
    \                    path.push(grid[i][j]);\n                    if path < min_path\
    \ || min_path.is_empty() {\n                        min_path = path;\n       \
    \                 min_val = path[l as usize - 1];\n                    }\n   \
    \             }\n                if j > 0 {\n                    let mut path\
    \ = dp[i][j - 1][(l - 1) as usize].clone();\n                    path.push(grid[i][j]);\n\
    \                    if path < min_path || min_path.is_empty() {\n           \
    \             min_path = path;\n                        min_val = path[l as usize\
    \ - 1];\n                    }\n                }\n                if j < n -\
    \ 1 {\n                    let mut path = dp[i][j", "    let n = grid.len();\n\
    \    let mut dp = vec![vec![vec![None; n]; n]; k as usize + 1];\n    let mut min_path\
    \ = vec![];\n    let mut min_sum = std::isize::MAX;\n    for i in 0..n {\n   \
    \     for j in 0..n {\n            let mut path = vec![];\n            let mut\
    \ sum = 0;\n            dfs(grid, i, j, k, &mut path, &mut sum, &mut dp);\n  \
    \          if sum < min_sum {\n                min_sum = sum;\n              \
    \  min_path = path;\n            }\n        }\n    }\n    min_path", "    let\
    \ n = grid.len();\n    let mut dp = vec![vec![vec![vec![]; n]; n]; k as usize\
    \ + 1];\n    for i in 0..n {\n        for j in 0..n {\n            dp[0][i][j]\
    \ = vec![grid[i][j]];\n        }\n    }\n    for l in 1..=k as usize {\n     \
    \   for i in 0..n {\n            for j in 0..n {\n                let mut min\
    \ = vec![];\n                if i > 0 {\n                    min = dp[l - 1][i\
    \ - 1][j].clone();\n                    min.push(grid[i][j]);\n              \
    \  }\n                if i < n - 1 && (min.is_empty() || min > dp[l - 1][i + 1][j].clone())\
    \ {\n                    min = dp[l - 1][i + 1][j].clone();\n                \
    \    min.push(grid[i][j]);\n                }\n                if j > 0 && (min.is_empty()\
    \ || min > dp[l - 1][i][j - 1].clone()) {\n                    min = dp[l - 1][i][j\
    \ - 1].clone();\n                    min.push(grid[i][j]);\n                }\n\
    \                if j < n - 1 && (min.is_empty() || min > dp[l - 1][i][j + 1].clone())\
    \ {\n                    min = dp[l - 1][i][j + 1].clone();\n                \
    \    min.push(grid[i][j]);\n                }\n                dp[l][i][j] = min;\n\
    \            }\n        }\n    }\n    dp[k as usize][0][0].clone()", "    let\
    \ n = grid.len();\n    let mut dp = vec![vec![vec![vec![]; n]; n]; k as usize\
    \ + 1];\n    for i in 0..n {\n        for j in 0..n {\n            dp[0][i][j]\
    \ = vec![grid[i][j]];\n        }\n    }\n    for l in 1..=k as usize {\n     \
    \   for i in 0..n {\n            for j in 0..n {\n                let mut min_path\
    \ = vec![];\n                if i > 0 {\n                    let mut path = dp[l\
    \ - 1][i - 1][j].clone();\n                    path.push(grid[i][j]);\n      \
    \              if min_path.is_empty() || path < min_path {\n                 \
    \       min_path = path;\n                    }\n                }\n         \
    \       if i < n - 1 {\n                    let mut path = dp[l - 1][i + 1][j].clone();\n\
    \                    path.push(grid[i][j]);\n                    if min_path.is_empty()\
    \ || path < min_path {\n                        min_path = path;\n           \
    \         }\n                }\n                if j > 0 {\n                 \
    \   let mut path = dp[l - 1][i][j - 1].clone();\n                    path.push(grid[i][j]);\n\
    \                    if min_path.is_empty() || path < min_path {\n           \
    \             min_path = path;\n                    }\n                }\n   \
    \             if j < n - 1 {\n                    let mut path = dp[l - 1][i][j\
    \ + 1].clone();\n                    path.push(grid[i][j]);\n                \
    \    if min_path.is_empty() || path < min_path {\n                        min_path\
    \ = path;\n                    }\n                }\n                dp[l][i][j]\
    \ = min_path;\n            }\n        }\n    }\n    dp[k as usize][0][0].clone()",
  "    let n = grid.len();\n    let mut dp = vec![vec![vec![vec![]; n]; n]; k as usize\
    \ + 1];\n    for i in 0..n {\n        for j in 0..n {\n            dp[0][i][j]\
    \ = vec![grid[i][j]];\n        }\n    }\n    for l in 1..=k as usize {\n     \
    \   for i in 0..n {\n            for j in 0..n {\n                let mut min_path\
    \ = vec![];\n                for &(di, dj) in &[(0, 1), (0, -1), (1, 0), (-1,\
    \ 0)] {\n                    let ni = i as isize + di;\n                    let\
    \ nj = j as isize + dj;\n                    if ni >= 0 && ni < n as isize &&\
    \ nj >= 0 && nj < n as isize {\n                        let mut path = dp[l -\
    \ 1][ni as usize][nj as usize].clone();\n                        path.push(grid[i][j]);\n\
    \                        if min_path.is_empty() || path < min_path {\n       \
    \                     min_path = path;\n                        }\n          \
    \          }\n                }\n                dp[l][i][j] = min_path;\n   \
    \         }\n        }\n    }\n    dp[k as usize][0][0].clone()", "    let n =\
    \ grid.len();\n    let mut dp = vec![vec![vec![std::isize::MAX; n]; n]; k as usize\
    \ + 1];\n    for i in 0..n {\n        for j in 0..n {\n            dp[0][i][j]\
    \ = grid[i][j];\n        }\n    }\n    for i in 1..k as usize + 1 {\n        for\
    \ j in 0..n {\n            for l in 0..n {\n                dp[i][j][l] = std::cmp::min(dp[i\
    \ - 1][j][l],\n                                            std::cmp::min(dp[i\
    \ - 1][j][(l + 1) % n],\n                                                    \
    \      dp[i - 1][(j + 1) % n][l]));\n            }\n        }\n    }\n    let\
    \ mut res = vec![];\n    let mut i = 0;\n    let mut j = 0;\n    for _ in 0..k\
    \ {\n        res.push(dp[k as usize][i][j]);\n        if dp[k as usize][i][j]\
    \ == dp[k as usize - 1][i][j] {\n            i = (i + 1) % n;\n        } else\
    \ if dp[k as usize][i][j] == dp[k as usize - 1][i][(j + 1) % n] {\n          \
    \  j = (j + 1) % n;\n        } else {\n            i = (i + 1) % n;\n        \
    \    j = (j + 1) % n;\n        }\n    }\n    res", "    let n = grid.len();\n\
    \    let mut dp = vec![vec![vec![vec![]; n]; n]; k as usize + 1];\n    let mut\
    \ min_path = vec![];\n    for i in 0..n {\n        for j in 0..n {\n         \
    \   dp[0][i][j] = vec![grid[i][j]];\n        }\n    }\n    for l in 1..=k as usize\
    \ {\n        for i in 0..n {\n            for j in 0..n {\n                let\
    \ mut min_path = vec![];\n                if i > 0 {\n                    let\
    \ mut path = dp[l - 1][i - 1][j].clone();\n                    path.push(grid[i][j]);\n\
    \                    if min_path.is_empty() || path < min_path {\n           \
    \             min_path = path;\n                    }\n                }\n   \
    \             if i < n - 1 {\n                    let mut path = dp[l - 1][i +\
    \ 1][j].clone();\n                    path.push(grid[i][j]);\n               \
    \     if min_path.is_empty() || path < min_path {\n                        min_path\
    \ = path;\n                    }\n                }\n                if j > 0\
    \ {\n                    let mut path = dp[l - 1][i][j - 1].clone();\n       \
    \             path.push(grid[i][j]);\n                    if min_path.is_empty()\
    \ || path < min_path {\n                        min_path = path;\n           \
    \         }\n                }\n                if j < n - 1 {\n             \
    \       let mut path = dp[l - 1][i][j + 1].clone();\n                    path.push(grid[i][j]);\n\
    \                    if min_path.is_empty() || path < min_path {\n           \
    \             min_path = path;\n                    }\n                }\n   \
    \             dp[l][i][j] = min_path;\n            }\n        }\n    }\n    dp[k\
    \ as usize][0][0].clone()", "    let n = grid.len();\n    let mut dp = vec![vec![vec![vec![];\
    \ n]; n]; k as usize + 1];\n    for i in 0..n {\n        for j in 0..n {\n   \
    \         dp[0][i][j] = vec![grid[i][j]];\n        }\n    }\n    for l in 1..=k\
    \ as usize {\n        for i in 0..n {\n            for j in 0..n {\n         \
    \       let mut min_path = vec![];\n                for &(di, dj) in &[(0, 1),\
    \ (0, -1), (1, 0), (-1, 0)] {\n                    let ni = i as isize + di;\n\
    \                    let nj = j as isize + dj;\n                    if ni >= 0\
    \ && ni < n as isize && nj >= 0 && nj < n as isize {\n                       \
    \ let mut path = dp[l - 1][ni as usize][nj as usize].clone();\n              \
    \          path.push(grid[i][j]);\n                        if min_path.is_empty()\
    \ || path < min_path {\n                            min_path = path;\n       \
    \                 }\n                    }\n                }\n              \
    \  dp[l][i][j] = min_path;\n            }\n        }\n    }\n    dp[k as usize][0][0].clone()",
  "    let n = grid.len();\n    let mut min_path = Vec::with_capacity(k as usize);\n\
    \    let mut min_val = std::isize::MAX;\n    let mut min_path_val = std::isize::MAX;\n\
    \    let mut visited = vec![vec![false; n]; n];\n    for i in 0..n {\n       \
    \ for j in 0..n {\n            if grid[i][j] < min_val {\n                min_val\
    \ = grid[i][j];\n                min_path.clear();\n                min_path.push(grid[i][j]);\n\
    \                min_path_val = min_val;\n            }\n        }\n    }\n  \
    \  let mut queue = VecDeque::new();\n    queue.push_back((0, 0, 0));\n    while\
    \ !queue.is_empty() {\n        let (i, j, path_len) = queue.pop_front().unwrap();\n\
    \        if path_len == k {\n            break;\n        }\n        if i > 0 &&\
    \ !visited[i - 1][j] {\n            visited[i - 1][j] = true;\n            if\
    \ grid[i - 1][j] < min_path_val {\n                min_path.clear();\n       \
    \         min_path.push(grid[i - 1][j]);\n                min_path_val = grid[i\
    \ - 1][j];\n            } else if grid[i - 1][j] == min_path_val {\n         \
    \       min_path.push(grid[i - 1][j]);\n            }\n            queue.push_back((i\
    \ - 1, j, path_len + 1));\n        }\n        if i < n - 1 && !visited[i + 1][j]\
    \ {\n            visited[i + 1][j] = true;\n            if grid[i + 1][j] < min_path_val\
    \ {\n                min_path.clear();\n                min_path.push(grid[i +\
    \ 1][j]);\n                min_path_val = grid[i + 1][j];\n            } else\
    \ if grid[i + 1][j] == min_path_val {\n                min_path.push(grid[", " \
    \   let n = grid.len();\n    let mut dp = vec![vec![vec![vec![]; n]; n]; k as\
    \ usize + 1];\n    for i in 0..n {\n        for j in 0..n {\n            dp[0][i][j]\
    \ = vec![grid[i][j]];\n        }\n    }\n    for t in 1..k as usize + 1 {\n  \
    \      for i in 0..n {\n            for j in 0..n {\n                let mut min_path\
    \ = vec![];\n                if i > 0 {\n                    let mut path = dp[t\
    \ - 1][i - 1][j].clone();\n                    path.push(grid[i][j]);\n      \
    \              if min_path.is_empty() || path < min_path {\n                 \
    \       min_path = path;\n                    }\n                }\n         \
    \       if i < n - 1 {\n                    let mut path = dp[t - 1][i + 1][j].clone();\n\
    \                    path.push(grid[i][j]);\n                    if min_path.is_empty()\
    \ || path < min_path {\n                        min_path = path;\n           \
    \         }\n                }\n                if j > 0 {\n                 \
    \   let mut path = dp[t - 1][i][j - 1].clone();\n                    path.push(grid[i][j]);\n\
    \                    if min_path.is_empty() || path < min_path {\n           \
    \             min_path = path;\n                    }\n                }\n   \
    \             if j < n - 1 {\n                    let mut path = dp[t - 1][i][j\
    \ + 1].clone();\n                    path.push(grid[i][j]);\n                \
    \    if min_path.is_empty() || path < min_path {\n                        min_path\
    \ = path;\n                    }\n                }\n                dp[t][i][j]\
    \ = min_path;\n            }\n        }\n    }\n    dp[k as usize][0][0].clone()",
  "    let n = grid.len();\n    let mut dp = vec![vec![vec![vec![]; n]; n]; k as usize\
    \ + 1];\n    for i in 0..n {\n        for j in 0..n {\n            dp[0][i][j]\
    \ = vec![grid[i][j]];\n        }\n    }\n    for l in 1..k as usize + 1 {\n  \
    \      for i in 0..n {\n            for j in 0..n {\n                let mut min\
    \ = vec![];\n                if i > 0 {\n                    min = min.iter().min_by(|x,\
    \ y| x.cmp(y)).unwrap().clone();\n                }\n                if j > 0\
    \ {\n                    min = min.iter().min_by(|x, y| x.cmp(y)).unwrap().clone();\n\
    \                }\n                if i < n - 1 {\n                    min =\
    \ min.iter().min_by(|x, y| x.cmp(y)).unwrap().clone();\n                }\n  \
    \              if j < n - 1 {\n                    min = min.iter().min_by(|x,\
    \ y| x.cmp(y)).unwrap().clone();\n                }\n                dp[l][i][j]\
    \ = min;\n            }\n        }\n    }\n    dp[k as usize][0][0].clone()"]
stop_tokens:
- "\n}"
