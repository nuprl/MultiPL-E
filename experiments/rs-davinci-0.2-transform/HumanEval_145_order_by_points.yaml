name: HumanEval_145_order_by_points
language: rs
prompt: "/// Write a function which sorts the given list of integers\n/// in ascending\
  \ order according to the sum of their digits.\n/// Note: if there are several items\
  \ with similar sum of their digits,\n/// order them based on their index in original\
  \ list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1, -11, -12])\n\
  /// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n/// Vec::<isize>::new()\n\
  fn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n"
tests: "}\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!({left},\
  \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
  \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
  \ {right});\n}\n"
completions: ["    let mut result = nums.clone();\n    result.sort_by(|a, b| {\n \
    \       let a_sum = a.to_string().chars().map(|c| c.to_digit(10).unwrap()).sum::<u32>();\n\
    \        let b_sum = b.to_string().chars().map(|c| c.to_digit(10).unwrap()).sum::<u32>();\n\
    \        a_sum.cmp(&b_sum)\n    });\n    result", "    let mut nums = nums;\n\
    \    nums.sort_by_key(|&x| (x.abs() as usize).to_string().chars().map(|c| c.to_digit(10).unwrap()).sum::<u32>());\n\
    \    nums", "    let mut nums = nums;\n    nums.sort_by_key(|&x| {\n        let\
    \ mut sum = 0;\n        let mut x = x;\n        if x < 0 {\n            x = -x;\n\
    \        }\n        while x > 0 {\n            sum += x % 10;\n            x /=\
    \ 10;\n        }\n        sum\n    });\n    nums", "    let mut nums = nums;\n\
    \    nums.sort_by_key(|x| {\n        let mut sum = 0;\n        let mut x = *x;\n\
    \        while x != 0 {\n            sum += x % 10;\n            x /= 10;\n  \
    \      }\n        sum\n    });\n    nums", "    let mut nums: Vec<isize> = nums;\n\
    \    nums.sort_by(|a, b| {\n        let a_sum: isize = a.to_string().chars().map(|c|\
    \ c.to_digit(10).unwrap() as isize).sum();\n        let b_sum: isize = b.to_string().chars().map(|c|\
    \ c.to_digit(10).unwrap() as isize).sum();\n        a_sum.cmp(&b_sum)\n    });\n\
    \    nums", "    let mut nums = nums;\n    nums.sort_by_key(|&x| (x.abs() as usize).to_string().chars().map(|c|\
    \ c.to_digit(10).unwrap()).sum::<u32>());\n    nums", "    let mut nums = nums;\n\
    \    nums.sort_by_key(|&x| (sum_digits(x), x));\n    nums", "    let mut nums\
    \ = nums;\n    nums.sort_by_key(|&x| {\n        let mut sum = 0;\n        let\
    \ mut x = x;\n        while x != 0 {\n            sum += x % 10;\n           \
    \ x /= 10;\n        }\n        sum\n    });\n    nums", "    let mut nums_with_points:\
    \ Vec<(isize, usize)> = nums\n        .iter()\n        .enumerate()\n        .map(|(i,\
    \ &n)| (n, i))\n        .collect();\n    nums_with_points.sort_by_key(|&(n, _)|\
    \ {\n        let mut sum = 0;\n        let mut n = n;\n        while n != 0 {\n\
    \            sum += (n % 10).abs();\n            n /= 10;\n        }\n       \
    \ sum\n    });\n    nums_with_points.into_iter().map(|(n, _)| n).collect()", " \
    \   let mut nums = nums;\n    nums.sort_by_key(|&x| (x.abs() as usize).to_string().chars().map(|c|\
    \ c.to_digit(10).unwrap()).sum::<u32>());\n    nums", "    let mut nums = nums;\n\
    \    nums.sort_by_key(|x| {\n        let mut sum = 0;\n        let mut x = *x;\n\
    \        if x < 0 {\n            x = -x;\n        }\n        while x > 0 {\n \
    \           sum += x % 10;\n            x /= 10;\n        }\n        sum\n   \
    \ });\n    nums", "    let mut nums = nums;\n    nums.sort_by_key(|x| x.abs()\
    \ % 10 + x.abs() / 10);\n    nums", "    let mut nums = nums;\n    nums.sort_by_key(|&x|\
    \ {\n        let mut sum = 0;\n        let mut x = x;\n        while x != 0 {\n\
    \            sum += x % 10;\n            x /= 10;\n        }\n        sum\n  \
    \  });\n    nums", "    let mut nums = nums;\n    nums.sort_by_key(|x| x.abs()\
    \ % 10 + x.abs() / 10);\n    nums", "    let mut nums = nums;\n    nums.sort_by_key(|n|\
    \ {\n        let mut sum = 0;\n        let mut n = *n;\n        while n != 0 {\n\
    \            sum += n % 10;\n            n /= 10;\n        }\n        sum\n  \
    \  });\n    nums", "    let mut nums = nums;\n    nums.sort_by_key(|n| {\n   \
    \     let mut sum = 0;\n        let mut n = *n;\n        while n != 0 {\n    \
    \        sum += n % 10;\n            n /= 10;\n        }\n        sum\n    });\n\
    \    nums", "    let mut nums = nums;\n    nums.sort_by_key(|&n| (n.abs() as usize).to_string().chars().map(|c|\
    \ c.to_digit(10).unwrap()).sum::<u32>());\n    nums", "    let mut nums = nums;\n\
    \    nums.sort_by_key(|&x| (x.abs() as usize).to_string().chars().map(|c| c.to_digit(10).unwrap()).sum::<u32>());\n\
    \    nums", "    let mut nums = nums;\n    nums.sort_by_key(|&x| (sum_digits(x),\
    \ x));\n    nums", "    let mut nums = nums;\n    nums.sort_by_key(|n| sum_digits(*n));\n\
    \    nums"]
stop_tokens:
- "\n}"
