name: HumanEval_49_modp
language: rs
prompt: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n///\
  \ 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
  \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
  \ {\n"
tests: "}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!({left}, {right});\n\
  \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
  \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
  \    assert_eq!({left}, {right});\n}\n"
completions: ["    if n == 0 {\n        return 1;\n    }\n    if n % 2 == 0 {\n  \
    \      let m = modp(n / 2, p);\n        return (m * m) % p;\n    }\n    return\
    \ (modp(n - 1, p) * n) % p;", "    let mut res = 1;\n    let mut n = n;\n    while\
    \ n > 0 {\n        if n % 2 == 1 {\n            res = (res * n) % p;\n       \
    \ }\n        n = n / 2;\n    }\n    res", "    let mut res = 1;\n    let mut n\
    \ = n;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * n)\
    \ % p;\n        }\n        n = n / 2;\n    }\n    res", "    let mut res = 1;\n\
    \    let mut n = n;\n    while n > 0 {\n        if n % 2 == 1 {\n            res\
    \ = (res * n) % p;\n        }\n        n = n / 2;\n    }\n    res", "    let mut\
    \ res = 1;\n    let mut n = n;\n    let mut p = p;\n    while n > 0 {\n      \
    \  if n % 2 == 1 {\n            res = (res * n) % p;\n        }\n        n = n\
    \ / 2;\n        p = (p * p) % p;\n    }\n    res", "    if n == 0 {\n        return\
    \ 1;\n    }\n    if n % 2 == 0 {\n        let x = modp(n / 2, p);\n        return\
    \ (x * x) % p;\n    }\n    return (n * modp(n - 1, p)) % p;", "    let mut res\
    \ = 1;\n    let mut n = n;\n    let mut p = p;\n    while n > 0 {\n        if\
    \ n % 2 == 1 {\n            res = (res * n) % p;\n        }\n        n = n / 2;\n\
    \        p = (p * p) % p;\n    }\n    res", "    let mut res = 1;\n    let mut\
    \ n = n;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res *\
    \ n) % p;\n        }\n        n = n / 2;\n    }\n    res", "    let mut res =\
    \ 1;\n    let mut n = n;\n    while n > 0 {\n        if n % 2 == 1 {\n       \
    \     res = (res * n) % p;\n        }\n        n = n / 2;\n    }\n    res", " \
    \   if n == 0 {\n        return 1;\n    }\n    let mut res = 1;\n    let mut n\
    \ = n;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * n)\
    \ % p;\n        }\n        n = n / 2;\n        n = (n * n) % p;\n    }\n    res",
  "    let mut res = 1;\n    let mut n = n;\n    while n > 0 {\n        if n % 2 ==\
    \ 1 {\n            res = (res * n) % p;\n        }\n        n = n / 2;\n    }\n\
    \    res", "    if n == 0 {\n        return 1;\n    }\n    let mut res = modp(n\
    \ / 2, p);\n    res = (res * res) % p;\n    if n % 2 == 1 {\n        res = (res\
    \ * 2) % p;\n    }\n    res", "    if n == 0 {\n        return 1;\n    }\n   \
    \ if n % 2 == 0 {\n        return modp(n / 2, p) * modp(n / 2, p) % p;\n    }\n\
    \    return modp(n - 1, p) * modp(n, p) % p;", "    let mut res = 1;\n    let\
    \ mut n = n;\n    let mut p = p;\n    while n > 0 {\n        if n % 2 == 1 {\n\
    \            res = (res * n) % p;\n        }\n        n = n / 2;\n        p =\
    \ (p * p) % p;\n    }\n    res", "    let mut result = 1;\n    let mut base =\
    \ n;\n    let mut exponent = p;\n    while exponent > 0 {\n        if exponent\
    \ % 2 == 1 {\n            result = (result * base) % p;\n        }\n        exponent\
    \ = exponent >> 1;\n        base = (base * base) % p;\n    }\n    result", " \
    \   let mut res = 1;\n    let mut n = n;\n    while n > 0 {\n        if n % 2\
    \ == 1 {\n            res = (res * n) % p;\n        }\n        n = n / 2;\n  \
    \  }\n    res", "    let mut res = 1;\n    let mut n = n;\n    while n > 0 {\n\
    \        if n % 2 == 1 {\n            res = (res * n) % p;\n        }\n      \
    \  n = n / 2;\n    }\n    res", "    let mut res = 1;\n    let mut n = n;\n  \
    \  while n > 0 {\n        if n % 2 == 1 {\n            res = (res * n) % p;\n\
    \        }\n        n = n / 2;\n    }\n    res", "    let mut res = 1;\n    let\
    \ mut n = n;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res\
    \ * n) % p;\n        }\n        n = n / 2;\n    }\n    res", "    if n == 0 {\n\
    \        return 1;\n    }\n    if n % 2 == 0 {\n        let x = modp(n / 2, p);\n\
    \        return x * x % p;\n    }\n    return n * modp(n - 1, p) % p;"]
stop_tokens:
- "\n}"
