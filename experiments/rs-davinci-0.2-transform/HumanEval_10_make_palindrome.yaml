name: HumanEval_10_make_palindrome
language: rs
prompt: "/// Find the shortest palindrome that begins with a supplied string.\n///\
  \ Algorithm idea is simple:\n/// - Find the longest postfix of supplied string that\
  \ is a palindrome.\n/// - Append to the end of the string reverse of a string prefix\
  \ that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
  \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n///\
  \ String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n///\
  \ String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n"
tests: "}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!({left},\
  \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
  \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
completions: ["    let mut string = string;\n    let mut longest_palindrome_suffix\
    \ = String::new();\n    for i in 0..string.len() {\n        if is_palindrome(&string[i..])\
    \ {\n            longest_palindrome_suffix = string[i..].to_string();\n      \
    \      break;\n        }\n    }\n    let prefix = string[..string.len() - longest_palindrome_suffix.len()].chars().rev().collect::<String>();\n\
    \    string.push_str(&prefix);\n    string", "    let mut string = string;\n \
    \   let mut palindrome_suffix = find_longest_palindrome_suffix(&string);\n   \
    \ let mut prefix = string.split_off(string.len() - palindrome_suffix.len());\n\
    \    prefix.reverse();\n    string.push_str(&prefix);\n    string", "    let mut\
    \ result = string.clone();\n    let mut suffix = String::new();\n    for c in\
    \ string.chars().rev() {\n        suffix.push(c);\n        if is_palindrome(&string,\
    \ &suffix) {\n            result.push_str(&suffix);\n            break;\n    \
    \    }\n    }\n    result", "    let mut string = string;\n    let mut palindrome_suffix\
    \ = String::new();\n    let mut palindrome_suffix_len = 0;\n    let mut i = string.len();\n\
    \    while i > 0 {\n        if is_palindrome(&string[..i]) {\n            palindrome_suffix\
    \ = string[i..].to_string();\n            palindrome_suffix_len = palindrome_suffix.len();\n\
    \            break;\n        }\n        i -= 1;\n    }\n    string.push_str(&palindrome_suffix.chars().rev().collect::<String>());\n\
    \    string", "    let mut result = string.clone();\n    let mut prefix = String::new();\n\
    \    let mut suffix = String::new();\n    let mut suffix_len = 0;\n    let mut\
    \ prefix_len = 0;\n    let mut i = 0;\n    let mut j = string.len() - 1;\n   \
    \ while i < j {\n        if string.chars().nth(i) == string.chars().nth(j) {\n\
    \            suffix.push(string.chars().nth(i).unwrap());\n            suffix_len\
    \ += 1;\n            i += 1;\n            j -= 1;\n        } else {\n        \
    \    if suffix_len > prefix_len {\n                prefix_len = suffix_len;\n\
    \                prefix = suffix.clone();\n            }\n            suffix =\
    \ String::new();\n            suffix_len = 0;\n            i = 0;\n          \
    \  j -= 1;\n        }\n    }\n    if suffix_len > prefix_len {\n        prefix_len\
    \ = suffix_len;\n        prefix = suffix.clone();\n    }\n    result.push_str(&prefix.chars().rev().collect::<String>());\n\
    \    result", "    let mut result = string.clone();\n    let mut prefix = String::new();\n\
    \    let mut postfix = String::new();\n    let mut is_palindrome = false;\n  \
    \  for (i, c) in string.chars().enumerate() {\n        if is_palindrome {\n  \
    \          prefix.push(c);\n        } else {\n            postfix.push(c);\n \
    \       }\n        if postfix == prefix.chars().rev().collect::<String>() {\n\
    \            is_palindrome = true;\n        }\n        if i == string.len() -\
    \ 1 {\n            result.push_str(&prefix.chars().rev().collect::<String>());\n\
    \        }\n    }\n    result", "    let mut string = string;\n    let mut palindrome_suffix\
    \ = String::new();\n    let mut palindrome_prefix = String::new();\n    let mut\
    \ palindrome_suffix_len = 0;\n    let mut palindrome_prefix_len = 0;\n    let\
    \ mut palindrome_len = 0;\n    let mut palindrome_len_max = 0;\n    let mut palindrome_len_max_index\
    \ = 0;\n    let mut palindrome_len_max_index_max = 0;\n    let mut palindrome_len_max_index_max_len\
    \ = 0;\n    let mut palindrome_len_max_index_max_len_max = 0;\n    let mut palindrome_len_max_index_max_len_max_index\
    \ = 0;\n    let mut palindrome_len_max_index_max_len_max_index_max = 0;\n    let\
    \ mut palindrome_len_max_index_max_len_max_index_max_len = 0;\n    let mut palindrome_len_max_index_max_len_max_index_max_len_max\
    \ = 0;\n    let mut palindrome_len_max_index_max_len_max_index_max_len_max_index\
    \ = 0;\n    let mut palindrome_len_max_index_max_len_max_index_max_len_max_index_max\
    \ = 0;\n    let mut palindrome_len_max_index_max_len_max_index_max_len_max_index_max_len\
    \ = 0;\n    let mut palindrome_len_max_index_max_len_max_index_max_len_max_index_max_len_max\
    \ = 0;\n    let mut palindrome_len_max_index_max_len_max_index_max_len_max_index_max_len_max_index\
    \ = 0;\n    let mut palindrome_len_max_index_max_len_max_index_max_len_max_index_max_len_max_index_max\
    \ = 0;\n    let mut palindrome_len_max_index_", "    let mut string = string;\n\
    \    let mut prefix = String::new();\n    let mut suffix = String::new();\n  \
    \  let mut longest_palindrome_length = 0;\n    for i in 0..string.len() {\n  \
    \      let (prefix_part, suffix_part) = string.split_at(i);\n        if is_palindrome(suffix_part)\
    \ && suffix_part.len() > longest_palindrome_length {\n            longest_palindrome_length\
    \ = suffix_part.len();\n            prefix = prefix_part.to_string();\n      \
    \      suffix = suffix_part.to_string();\n        }\n    }\n    suffix.push_str(&prefix.chars().rev().collect::<String>());\n\
    \    suffix", "    let mut string = string;\n    let mut suffix = String::new();\n\
    \    let mut prefix = String::new();\n    let mut palindrome = String::new();\n\
    \    let mut is_palindrome = false;\n    let mut i = string.len();\n    while\
    \ !is_palindrome {\n        suffix = string.chars().skip(i).collect();\n     \
    \   prefix = string.chars().take(i).collect();\n        palindrome = suffix.clone()\
    \ + &prefix.chars().rev().collect::<String>();\n        is_palindrome = is_palindrome(&palindrome);\n\
    \        i -= 1;\n    }\n    palindrome", "    let mut string = string;\n    let\
    \ mut palindrome_suffix = String::new();\n    let mut palindrome_prefix = String::new();\n\
    \    let mut longest_palindrome_suffix_length = 0;\n    let mut longest_palindrome_suffix_index\
    \ = 0;\n    let mut string_length = string.len();\n    let mut i = 0;\n    while\
    \ i < string_length {\n        let mut j = i;\n        let mut k = string_length\
    \ - 1;\n        while j < k {\n            if string.chars().nth(j) != string.chars().nth(k)\
    \ {\n                break;\n            }\n            j += 1;\n            k\
    \ -= 1;\n        }\n        if j >= k && j - i + 1 > longest_palindrome_suffix_length\
    \ {\n            longest_palindrome_suffix_length = j - i + 1;\n            longest_palindrome_suffix_index\
    \ = i;\n        }\n        i += 1;\n    }\n    if longest_palindrome_suffix_length\
    \ > 0 {\n        palindrome_suffix = string.chars().skip(longest_palindrome_suffix_index).take(longest_palindrome_suffix_length).collect();\n\
    \        palindrome_prefix = string.chars().take(longest_palindrome_suffix_index).collect();\n\
    \        palindrome_prefix = palindrome_prefix.chars().rev().collect();\n    \
    \    string = palindrome_prefix + &palindrome_suffix;\n    }\n    string", " \
    \   let mut string = string;\n    let mut reversed = string.clone();\n    reversed.reverse();\n\
    \    let mut longest_suffix = String::new();\n    for i in 0..string.len() {\n\
    \        if string.ends_with(&reversed[i..]) {\n            longest_suffix = reversed[i..].to_string();\n\
    \            break;\n        }\n    }\n    string.push_str(&longest_suffix);\n\
    \    string", "    let mut result = string.clone();\n    let mut palindrome_suffix\
    \ = String::new();\n    let mut palindrome_suffix_len = 0;\n    for i in 0..string.len()\
    \ {\n        let suffix = &string[i..];\n        if is_palindrome(suffix) {\n\
    \            palindrome_suffix = suffix.to_string();\n            palindrome_suffix_len\
    \ = palindrome_suffix.len();\n            break;\n        }\n    }\n    let prefix\
    \ = &string[..string.len() - palindrome_suffix_len];\n    let reversed_prefix\
    \ = reverse(prefix);\n    result.push_str(&reversed_prefix);\n    result", " \
    \   let mut string = string;\n    let mut prefix = String::new();\n    let mut\
    \ suffix = String::new();\n    let mut suffix_len = 0;\n    let mut prefix_len\
    \ = 0;\n    let mut i = 0;\n    let mut j = string.len() - 1;\n    while i < j\
    \ {\n        if string.chars().nth(i) == string.chars().nth(j) {\n           \
    \ suffix.push(string.chars().nth(i).unwrap());\n            suffix_len += 1;\n\
    \            i += 1;\n            j -= 1;\n        } else {\n            if suffix_len\
    \ > 0 {\n                prefix.push_str(&suffix);\n                prefix_len\
    \ += suffix_len;\n                suffix.clear();\n                suffix_len\
    \ = 0;\n            } else {\n                prefix.push(string.chars().nth(i).unwrap());\n\
    \                prefix_len += 1;\n                i += 1;\n            }\n  \
    \      }\n    }\n    if suffix_len > 0 {\n        prefix.push_str(&suffix);\n\
    \        prefix_len += suffix_len;\n    }\n    prefix.push_str(&prefix[0..prefix_len].chars().rev().collect::<String>());\n\
    \    prefix", "    let mut string = string;\n    let mut suffix = String::new();\n\
    \    let mut prefix = String::new();\n    let mut palindrome = String::new();\n\
    \    let mut palindrome_length = 0;\n    let mut string_length = string.len();\n\
    \    let mut string_chars = string.chars();\n    let mut string_chars_rev = string.chars().rev();\n\
    \n    // Find the longest postfix of supplied string that is a palindrome.\n \
    \   while let Some(c) = string_chars.next() {\n        if let Some(c_rev) = string_chars_rev.next()\
    \ {\n            if c == c_rev {\n                palindrome.push(c);\n      \
    \          palindrome_length += 1;\n            } else {\n                break;\n\
    \            }\n        }\n    }\n\n    // Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    if palindrome_length\
    \ < string_length {\n        suffix = string.chars().skip(palindrome_length).collect();\n\
    \        prefix = string.chars().take(string_length - palindrome_length).collect();\n\
    \        string = format!(\"{}{}{}\", prefix, palindrome, suffix.chars().rev().collect::<String>());\n\
    \    }\n\n    string", "    let mut result = string.clone();\n    let mut prefix_len\
    \ = 0;\n    let mut suffix_len = 0;\n    let mut suffix_start = 0;\n    let mut\
    \ suffix_end = 0;\n    let mut prefix_start = 0;\n    let mut prefix_end = 0;\n\
    \    let mut is_palindrome = false;\n    let mut is_palindrome_found = false;\n\
    \    let mut is_prefix_found = false;\n    let mut is_suffix_found = false;\n\
    \    let mut is_suffix_palindrome = false;\n    let mut is_prefix_palindrome =\
    \ false;\n    let mut is_prefix_palindrome_found = false;\n    let mut is_suffix_palindrome_found\
    \ = false;\n    let mut is_prefix_palindrome_found_first = false;\n    let mut\
    \ is_suffix_palindrome_found_first = false;\n    let mut is_prefix_palindrome_found_second\
    \ = false;\n    let mut is_suffix_palindrome_found_second = false;\n    let mut\
    \ is_prefix_palindrome_found_third = false;\n    let mut is_suffix_palindrome_found_third\
    \ = false;\n    let mut is_prefix_palindrome_found_fourth = false;\n    let mut\
    \ is_suffix_palindrome_found_fourth = false;\n    let mut is_prefix_palindrome_found_fifth\
    \ = false;\n    let mut is_suffix_palindrome_found_fifth = false;\n    let mut\
    \ is_prefix_palindrome_found_sixth = false;\n    let mut is_suffix_palindrome_found_sixth\
    \ = false;\n    let mut is_prefix_palindrome_found_seventh = false;\n    let mut\
    \ is_suffix_palindrome_found_seventh = false;\n    let mut is_prefix_palindrome_found_eighth\
    \ = false;\n    let mut is_suffix_palindrome_found_eighth = false;\n    let mut\
    \ is_prefix_palindrome_found_ninth = false;\n    let mut is_suffix", "    let\
    \ mut result = string.clone();\n    let mut prefix = String::new();\n    let mut\
    \ suffix = String::new();\n    let mut i = 0;\n    let mut j = string.len() -\
    \ 1;\n    while i < j {\n        if string.chars().nth(i) == string.chars().nth(j)\
    \ {\n            prefix.push(string.chars().nth(i).unwrap());\n            suffix.push(string.chars().nth(j).unwrap());\n\
    \            i += 1;\n            j -= 1;\n        } else {\n            break;\n\
    \        }\n    }\n    if i == j {\n        prefix.push(string.chars().nth(i).unwrap());\n\
    \    }\n    result.push_str(&prefix.chars().rev().collect::<String>());\n    result",
  "    let mut result = string.clone();\n    let mut suffix = String::new();\n   \
    \ let mut prefix = String::new();\n    let mut is_palindrome = false;\n    let\
    \ mut i = 0;\n    while i < string.len() {\n        let mut j = string.len() -\
    \ 1 - i;\n        if string.chars().nth(i) == string.chars().nth(j) {\n      \
    \      suffix.push(string.chars().nth(i).unwrap());\n            prefix.push(string.chars().nth(j).unwrap());\n\
    \            is_palindrome = true;\n        } else {\n            suffix.clear();\n\
    \            prefix.clear();\n            is_palindrome = false;\n        }\n\
    \        i += 1;\n    }\n    if is_palindrome {\n        result.push_str(&prefix.chars().rev().collect::<String>());\n\
    \    }\n    result", "    let mut string = string;\n    let mut longest_palindrome_suffix\
    \ = String::new();\n    for i in (0..string.len()).rev() {\n        if is_palindrome(&string[i..])\
    \ {\n            longest_palindrome_suffix = string[i..].to_string();\n      \
    \      break;\n        }\n    }\n    string.push_str(&string[..string.len() -\
    \ longest_palindrome_suffix.len()].chars().rev().collect::<String>());\n    string",
  "    let mut prefix = String::new();\n    let mut suffix = String::new();\n    let\
    \ mut longest_palindrome_length = 0;\n    let mut longest_palindrome_start = 0;\n\
    \    let mut longest_palindrome_end = 0;\n    let string_length = string.len();\n\
    \    let string_chars: Vec<char> = string.chars().collect();\n    for i in 0..string_length\
    \ {\n        let mut j = 0;\n        while i - j >= 0 && i + j < string_length\
    \ && string_chars[i - j] == string_chars[i + j] {\n            j += 1;\n     \
    \   }\n        if j > longest_palindrome_length {\n            longest_palindrome_length\
    \ = j;\n            longest_palindrome_start = i - j + 1;\n            longest_palindrome_end\
    \ = i + j;\n        }\n    }\n    for i in 0..string_length {\n        let mut\
    \ j = 0;\n        while i - j >= 0 && i + j + 1 < string_length && string_chars[i\
    \ - j] == string_chars[i + j + 1] {\n            j += 1;\n        }\n        if\
    \ j > longest_palindrome_length {\n            longest_palindrome_length = j;\n\
    \            longest_palindrome_start = i - j + 1;\n            longest_palindrome_end\
    \ = i + j + 1;\n        }\n    }\n    for i in 0..longest_palindrome_start {\n\
    \        prefix.push(string_chars[i]);\n    }\n    for i in longest_palindrome_end..string_length\
    \ {\n        suffix.push(string_chars[i]);\n    }\n    prefix.push_str(&suffix);\n\
    \    prefix.push_str(&suffix.chars().rev().collect::<String>());\n    prefix",
  "    let mut string = string;\n    let mut suffix = String::new();\n    let mut\
    \ prefix = String::new();\n    let mut i = string.len();\n    while i > 0 {\n\
    \        if is_palindrome(&string) {\n            break;\n        }\n        suffix.push(string.pop().unwrap());\n\
    \        i -= 1;\n    }\n    prefix = suffix.chars().rev().collect();\n    string.push_str(&prefix);\n\
    \    string"]
stop_tokens:
- "\n}"
