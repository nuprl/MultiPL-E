language: rs
name: HumanEval_88_sort_array
results:
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 0 {\n        array.sort();\n    } else {\n        array.sort_by(|a, b|\
    \ b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpdaax5gn8.rs:18:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut sorted = false;\n \
    \   while !sorted {\n        sorted = true;\n        for i in 0..array.len() -\
    \ 1 {\n            if array[i] > array[i + 1] {\n                array.swap(i,\
    \ i + 1);\n                sorted = false;\n            }\n        }\n    }\n\
    \    if array.len() > 1 && (array[0] + array[array.len() - 1]) % 2 == 0 {\n  \
    \      array.reverse();\n    }\n    array\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpje0dejmj.rs:20:21

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 0 {\n        array.sort();\n    } else {\n        array.sort_by(|a, b|\
    \ b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpdaax5gn8.rs:18:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut sorted = false;\n \
    \   while !sorted {\n        sorted = true;\n        for i in 0..array.len() -\
    \ 1 {\n            if (array[0] + array[array.len() - 1]) % 2 == 0 {\n       \
    \         if array[i] < array[i + 1] {\n                    array.swap(i, i +\
    \ 1);\n                    sorted = false;\n                }\n            } else\
    \ {\n                if array[i] > array[i + 1] {\n                    array.swap(i,\
    \ i + 1);\n                    sorted = false;\n                }\n          \
    \  }\n        }\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpyh3_gwcf.rs:20:21

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 0
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    if array.len() > 1 {\n    \
    \    let (first, last) = (array[0], array[array.len() - 1]);\n        if (first\
    \ + last) % 2 == 0 {\n            array.sort_by(|a, b| b.cmp(a));\n        } else\
    \ {\n            array.sort_by(|a, b| a.cmp(b));\n        }\n    }\n    array\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 0 {\n        array.sort();\n    } else {\n        array.sort_by(|a, b|\
    \ b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpdaax5gn8.rs:18:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 0 {\n        array.sort();\n    } else {\n        array.sort_by(|a, b|\
    \ b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpdaax5gn8.rs:18:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 0 {\n        array.sort();\n    } else {\n        array.sort_by(|a, b|\
    \ b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpdaax5gn8.rs:18:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 0 {\n        array.sort();\n    } else {\n        array.sort_by(|a, b|\
    \ b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpdaax5gn8.rs:18:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 0 {\n        array.sort();\n    } else {\n        array.sort_by(|a, b|\
    \ b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpdaax5gn8.rs:18:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let len = array.len();\n  \
    \  if len == 0 {\n        return array;\n    }\n    let mut i = 0;\n    let mut\
    \ j = len - 1;\n    while i < j {\n        if array[i] > array[j] {\n        \
    \    array.swap(i, j);\n        }\n        i += 1;\n        j -= 1;\n    }\n \
    \   if (array[0] + array[len - 1]) % 2 == 0 {\n        array.reverse();\n    }\n\
    \    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 1, 0, 3, 4, 5]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmpro3sw8qn.rs:40:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 0 {\n        array.sort();\n    } else {\n        array.sort_by(|a, b|\
    \ b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpdaax5gn8.rs:18:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 0 {\n        array.sort();\n    } else {\n        array.sort_by(|a, b|\
    \ b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpdaax5gn8.rs:18:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 0
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let sum = array.first().unwrap_or(&0)\
    \ + array.last().unwrap_or(&0);\n    array.sort_by(|a, b| if sum % 2 == 0 { b.cmp(a)\
    \ } else { a.cmp(b) });\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    if array.len() > 1 {\n    \
    \    let mut i = 0;\n        let mut j = array.len() - 1;\n        while i < j\
    \ {\n            if array[i] % 2 == 0 && array[j] % 2 == 1 {\n               \
    \ array.swap(i, j);\n                i += 1;\n                j -= 1;\n      \
    \      } else if array[i] % 2 == 1 {\n                i += 1;\n            } else\
    \ if array[j] % 2 == 0 {\n                j -= 1;\n            } else {\n    \
    \            i += 1;\n                j -= 1;\n            }\n        }\n    \
    \    if i == j && array[i] % 2 == 0 {\n            array.swap(i, i + 1);\n   \
    \     }\n        if (array[0] + array[array.len() - 1]) % 2 == 0 {\n         \
    \   array.reverse();\n        }\n    }\n    array\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 1, 3, 4, 0, 2]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmp6_6yuckd.rs:48:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011761
- exit_code: 0
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    if array.len() > 1 {\n    \
    \    let (first, last) = (array[0], array[array.len() - 1]);\n        if (first\
    \ + last) % 2 == 0 {\n            array.sort_by(|a, b| b.cmp(a));\n        } else\
    \ {\n            array.sort_by(|a, b| a.cmp(b));\n        }\n    }\n    array\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011761
- exit_code: 0
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    if array.len() > 1 {\n    \
    \    let (first, last) = (array[0], array[array.len() - 1]);\n        if (first\
    \ + last) % 2 == 0 {\n            array.sort_by(|a, b| b.cmp(a));\n        } else\
    \ {\n            array.sort_by(|a, b| a.cmp(b));\n        }\n    }\n    array\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 0 {\n        array.sort();\n    } else {\n        array.sort_by(|a, b|\
    \ b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpdaax5gn8.rs:18:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 0 {\n        array.sort();\n    } else {\n        array.sort_by(|a, b|\
    \ b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpdaax5gn8.rs:18:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut sorted = false;\n \
    \   while !sorted {\n        sorted = true;\n        for i in 0..array.len() -\
    \ 1 {\n            if array[i] > array[i + 1] {\n                array.swap(i,\
    \ i + 1);\n                sorted = false;\n            }\n        }\n    }\n\
    \    if array.len() > 1 && array[0] + array[array.len() - 1] % 2 == 0 {\n    \
    \    array.reverse();\n    }\n    array\n}\n\nfn main() {\n    let candidate =\
    \ sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpm8mf3x68.rs:20:21

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 0 {\n        array.sort();\n    } else {\n        array.sort_by(|a, b|\
    \ b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpdaax5gn8.rs:18:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 0 {\n        array.sort();\n    } else {\n        array.sort_by(|a, b|\
    \ b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpdaax5gn8.rs:18:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 0 {\n        array.sort();\n    } else {\n        array.sort_by(|a, b|\
    \ b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpdaax5gn8.rs:18:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] > array[j] {\n\
    \            array.swap(i, j);\n        }\n        i += 1;\n        j -= 1;\n\
    \    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpmchu6ryg.rs:18:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 0 {\n        array.sort();\n    } else {\n        array.sort_by(|a, b|\
    \ b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpdaax5gn8.rs:18:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    if array.len() > 1 {\n    \
    \    let mut i = 0;\n        let mut j = array.len() - 1;\n        while i < j\
    \ {\n            if array[i] % 2 == 0 && array[j] % 2 == 1 {\n               \
    \ array.swap(i, j);\n                i += 1;\n                j -= 1;\n      \
    \      } else if array[i] % 2 == 1 {\n                i += 1;\n            } else\
    \ if array[j] % 2 == 0 {\n                j -= 1;\n            } else {\n    \
    \            i += 1;\n                j -= 1;\n            }\n        }\n    \
    \    if array[i] % 2 == 0 {\n            array.sort_by(|a, b| b.cmp(a));\n   \
    \     } else {\n            array.sort_by(|a, b| a.cmp(b));\n        }\n    }\n\
    \    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 4, 3, 2, 1, 0]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmpe2u37e47.rs:47:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011761
- exit_code: 0
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = array.clone();\n    if result.len() >\
    \ 1 {\n        if (result[0] + result[result.len() - 1]) % 2 == 0 {\n        \
    \    result.sort_by(|a, b| b.cmp(a));\n        } else {\n            result.sort_by(|a,\
    \ b| a.cmp(b));\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    let mut sorted = false;\n    while !sorted {\n   \
    \     sorted = true;\n        while i < j {\n            if array[i] > array[i\
    \ + 1] {\n                array.swap(i, i + 1);\n                sorted = false;\n\
    \            }\n            i += 1;\n        }\n        while j > i {\n      \
    \      if array[j] < array[j - 1] {\n                array.swap(j, j - 1);\n \
    \               sorted = false;\n            }\n            j -= 1;\n        }\n\
    \    }\n    if array[0] + array[array.len() - 1] % 2 == 0 {\n        array.reverse();\n\
    \    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpaphmhh9a.rs:18:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if i == j && array[i]\
    \ % 2 == 0 {\n        array.swap(i, i + 1);\n    }\n    array\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpf6rfe7qe.rs:18:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    if array.len() < 2 {\n        return array;\n    }\n\
    \    while i < j {\n        if (array[i] + array[j]) % 2 == 0 {\n            array.swap(i,\
    \ j);\n        }\n        i += 1;\n        j -= 1;\n    }\n    array\n}\n\nfn\
    \ main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmp5goaofvt.rs:18:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 0
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    if array.len() > 1 {\n    \
    \    let (first, last) = (array[0], array[array.len() - 1]);\n        if (first\
    \ + last) % 2 == 0 {\n            array.sort_by(|a, b| b.cmp(a));\n        } else\
    \ {\n            array.sort_by(|a, b| a.cmp(b));\n        }\n    }\n    array\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 0 {\n        array.sort();\n    } else {\n        array.sort_by(|a, b|\
    \ b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpdaax5gn8.rs:18:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = array.clone();\n    let mut i = 0;\n \
    \   let mut j = result.len() - 1;\n    while i < j {\n        if result[i] % 2\
    \ == 0 && result[j] % 2 == 1 {\n            result.swap(i, j);\n            i\
    \ += 1;\n            j -= 1;\n        } else if result[i] % 2 == 1 {\n       \
    \     i += 1;\n        } else if result[j] % 2 == 0 {\n            j -= 1;\n \
    \       } else {\n            i += 1;\n            j -= 1;\n        }\n    }\n\
    \    if result.len() % 2 == 1 {\n        result.sort_by(|a, b| b.cmp(a));\n  \
    \  } else {\n        result.sort();\n    }\n    result\n}\n\nfn main() {\n   \
    \ let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmp87jdzntn.rs:18:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    if array.len() > 1 {\n    \
    \    let mut i = 0;\n        let mut j = array.len() - 1;\n        while i < j\
    \ {\n            if array[i] % 2 == 0 && array[j] % 2 == 1 {\n               \
    \ array.swap(i, j);\n                i += 1;\n                j -= 1;\n      \
    \      } else if array[i] % 2 == 1 {\n                i += 1;\n            } else\
    \ if array[j] % 2 == 0 {\n                j -= 1;\n            } else {\n    \
    \            i += 1;\n                j -= 1;\n            }\n        }\n    \
    \    if i == j && array[i] % 2 == 0 {\n            array.swap(i, j);\n       \
    \ }\n        if array[0] % 2 == 0 {\n            array.sort_by(|a, b| b.cmp(a));\n\
    \        } else {\n            array.sort();\n        }\n    }\n    array\n}\n\
    \nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpr9vcex8h.rs:51:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    if array.len() > 1 {\n    \
    \    let (mut i, mut j) = (0, array.len() - 1);\n        while i < j {\n     \
    \       if array[i] % 2 == 0 {\n                array.swap(i, j);\n          \
    \      j -= 1;\n            } else {\n                i += 1;\n            }\n\
    \        }\n        if array[i] % 2 == 0 {\n            i += 1;\n        }\n \
    \       array[..i].sort();\n        array[i..].sort_by(|a, b| b.cmp(a));\n   \
    \ }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 3, 5, 4, 2]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmp8elvhgxv.rs:40:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011761
- exit_code: 0
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = array.clone();\n    if result.len() >\
    \ 1 {\n        if (result[0] + result[result.len() - 1]) % 2 == 0 {\n        \
    \    result.sort_by(|a, b| b.cmp(a));\n        } else {\n            result.sort_by(|a,\
    \ b| a.cmp(b));\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 0 {\n        array.sort();\n    } else {\n        array.sort_by(|a, b|\
    \ b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpdaax5gn8.rs:18:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    if array.len() > 1 {\n    \
    \    let mut i = 0;\n        let mut j = array.len() - 1;\n        while i < j\
    \ {\n            if (array[i] + array[j]) % 2 == 0 {\n                array.swap(i,\
    \ j);\n            }\n            i += 1;\n            j -= 1;\n        }\n  \
    \      array.sort();\n    }\n    array\n}\n\nfn main() {\n    let candidate =\
    \ sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmptx0m2s36.rs:37:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 0 {\n        array.sort();\n    } else {\n        array.sort_by(|a, b|\
    \ b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpdaax5gn8.rs:18:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    if array.len() > 1 {\n    \
    \    let (mut left, mut right) = array.split_at_mut(array.len() / 2);\n      \
    \  left = sort_array(left.to_vec()).as_mut_slice();\n        right = sort_array(right.to_vec()).as_mut_slice();\n\
    \        let mut i = 0;\n        let mut j = 0;\n        while i < left.len()\
    \ && j < right.len() {\n            if left[i] < right[j] {\n                array[i\
    \ + j] = left[i];\n                i += 1;\n            } else {\n           \
    \     array[i + j] = right[j];\n                j += 1;\n            }\n     \
    \   }\n        while i < left.len() {\n            array[i + j] = left[i];\n \
    \           i += 1;\n        }\n        while j < right.len() {\n            array[i\
    \ + j] = right[j];\n            j += 1;\n        }\n    }\n    if array.len()\
    \ > 1 && (array[0] + array[array.len() - 1]) % 2 == 0 {\n        array.reverse();\n\
    \    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0502]: cannot borrow `array` as immutable because it is also borrowed\
    \ as mutable\n  --> /tmp/tmpad1_y_u7.rs:18:56\n   |\n18 |         let (mut left,\
    \ mut right) = array.split_at_mut(array.len() / 2);\n   |                    \
    \                 -------------------^^^^^^^^^^^-----\n   |                  \
    \                   |     |            |\n   |                               \
    \      |     |            immutable borrow occurs here\n   |                 \
    \                    |     mutable borrow later used by call\n   |           \
    \                          mutable borrow occurs here\n   |\nhelp: try adding\
    \ a local storing this argument...\n  --> /tmp/tmpad1_y_u7.rs:18:56\n   |\n18\
    \ |         let (mut left, mut right) = array.split_at_mut(array.len() / 2);\n\
    \   |                                                        ^^^^^^^^^^^\nhelp:\
    \ ...and then using that local as the argument to this call\n  --> /tmp/tmpad1_y_u7.rs:18:37\n\
    \   |\n18 |         let (mut left, mut right) = array.split_at_mut(array.len()\
    \ / 2);\n   |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror[E0716]: temporary value dropped while borrowed\n  --> /tmp/tmpad1_y_u7.rs:19:16\n\
    \   |\n19 |         left = sort_array(left.to_vec()).as_mut_slice();\n   |   \
    \             ^^^^^^^^^^^^^^^^^^^^^^^^^               - temporary value is freed\
    \ at the end of this statement\n   |                |\n   |                creates\
    \ a temporary which is freed while still in use\n...\n23 |         while i < left.len()\
    \ && j < right.len() {\n   |                   ---------- borrow later used here\n\
    \   |\n   = note: consider using a `let` binding to create a longer lived value\n\
    \nerror[E0716]: temporary value dropped while borrowed\n  --> /tmp/tmpad1_y_u7.rs:20:17\n\
    \   |\n20 |         right = sort_array(right.to_vec()).as_mut_slice();\n   | \
    \                ^^^^^^^^^^^^^^^^^^^^^^^^^^               - temporary value is\
    \ freed at the end of this statement\n   |                 |\n   |           \
    \      creates a temporary which is freed while still in use\n...\n23 |      \
    \   while i < left.len() &&"
  stdout: ''
  timestamp: 1660011760
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 0 {\n        array.sort();\n    } else {\n        array.sort_by(|a, b|\
    \ b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpdaax5gn8.rs:18:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut sorted = false;\n \
    \   while !sorted {\n        sorted = true;\n        for i in 0..array.len() -\
    \ 1 {\n            if array[i] > array[i + 1] {\n                array.swap(i,\
    \ i + 1);\n                sorted = false;\n            }\n        }\n    }\n\
    \    if array.len() > 1 && (array[0] + array[array.len() - 1]) % 2 == 0 {\n  \
    \      array.reverse();\n    }\n    array\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpje0dejmj.rs:20:21

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 0 {\n        array.sort();\n    } else {\n        array.sort_by(|a, b|\
    \ b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpdaax5gn8.rs:18:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 0 {\n        array.sort();\n    } else {\n        array.sort_by(|a, b|\
    \ b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpdaax5gn8.rs:18:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    let mut sorted = false;\n    while !sorted {\n   \
    \     sorted = true;\n        while i < j {\n            if array[i] > array[i\
    \ + 1] {\n                array.swap(i, i + 1);\n                sorted = false;\n\
    \            }\n            i += 1;\n        }\n        while j > i {\n      \
    \      if array[j] < array[j - 1] {\n                array.swap(j, j - 1);\n \
    \               sorted = false;\n            }\n            j -= 1;\n        }\n\
    \    }\n    if array[0] + array[array.len() - 1] % 2 == 0 {\n        array.reverse();\n\
    \    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpaphmhh9a.rs:18:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    if array.len() > 1 {\n    \
    \    let (mut left, mut right) = array.split_at_mut(array.len() / 2);\n      \
    \  left = sort_array(left.to_vec()).as_mut_slice();\n        right = sort_array(right.to_vec()).as_mut_slice();\n\
    \        let mut i = 0;\n        let mut j = 0;\n        let mut k = 0;\n    \
    \    while i < left.len() && j < right.len() {\n            if (left[i] + right[j])\
    \ % 2 == 0 {\n                array[k] = left[i];\n                i += 1;\n \
    \           } else {\n                array[k] = right[j];\n                j\
    \ += 1;\n            }\n            k += 1;\n        }\n        while i < left.len()\
    \ {\n            array[k] = left[i];\n            i += 1;\n            k += 1;\n\
    \        }\n        while j < right.len() {\n            array[k] = right[j];\n\
    \            j += 1;\n            k += 1;\n        }\n    }\n    array\n}\n\n\
    fn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0502]: cannot borrow `array` as immutable because it is also borrowed\
    \ as mutable\n  --> /tmp/tmpt9fvgrtt.rs:18:56\n   |\n18 |         let (mut left,\
    \ mut right) = array.split_at_mut(array.len() / 2);\n   |                    \
    \                 -------------------^^^^^^^^^^^-----\n   |                  \
    \                   |     |            |\n   |                               \
    \      |     |            immutable borrow occurs here\n   |                 \
    \                    |     mutable borrow later used by call\n   |           \
    \                          mutable borrow occurs here\n   |\nhelp: try adding\
    \ a local storing this argument...\n  --> /tmp/tmpt9fvgrtt.rs:18:56\n   |\n18\
    \ |         let (mut left, mut right) = array.split_at_mut(array.len() / 2);\n\
    \   |                                                        ^^^^^^^^^^^\nhelp:\
    \ ...and then using that local as the argument to this call\n  --> /tmp/tmpt9fvgrtt.rs:18:37\n\
    \   |\n18 |         let (mut left, mut right) = array.split_at_mut(array.len()\
    \ / 2);\n   |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror[E0716]: temporary value dropped while borrowed\n  --> /tmp/tmpt9fvgrtt.rs:19:16\n\
    \   |\n19 |         left = sort_array(left.to_vec()).as_mut_slice();\n   |   \
    \             ^^^^^^^^^^^^^^^^^^^^^^^^^               - temporary value is freed\
    \ at the end of this statement\n   |                |\n   |                creates\
    \ a temporary which is freed while still in use\n...\n24 |         while i < left.len()\
    \ && j < right.len() {\n   |                   ---------- borrow later used here\n\
    \   |\n   = note: consider using a `let` binding to create a longer lived value\n\
    \nerror[E0716]: temporary value dropped while borrowed\n  --> /tmp/tmpt9fvgrtt.rs:20:17\n\
    \   |\n20 |         right = sort_array(right.to_vec()).as_mut_slice();\n   | \
    \                ^^^^^^^^^^^^^^^^^^^^^^^^^^               - temporary value is\
    \ freed at the end of this statement\n   |                 |\n   |           \
    \      creates a temporary which is freed while still in use\n...\n24 |      \
    \   while i < left.len() &&"
  stdout: ''
  timestamp: 1660011760
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 0 {\n        array.sort();\n    } else {\n        array.sort_by(|a, b|\
    \ b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpdaax5gn8.rs:18:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 1 && array[j]\
    \ % 2 == 0 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 0 {\n            j -= 1;\n      \
    \  } else {\n            i += 1;\n        }\n    }\n    if array.len() % 2 ==\
    \ 0 {\n        array.sort();\n    } else {\n        array.sort_by(|a, b| b.cmp(a));\n\
    \    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmptp5zt0ip.rs:18:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut first = 0;\n    let\
    \ mut last = array.len() - 1;\n    while first < last {\n        if array[first]\
    \ % 2 == 0 {\n            while last > first {\n                if array[last]\
    \ % 2 == 1 {\n                    array.swap(first, last);\n                 \
    \   break;\n                }\n                last -= 1;\n            }\n   \
    \     }\n        first += 1;\n    }\n    if array.len() % 2 == 0 {\n        array.sort();\n\
    \    } else {\n        array.sort_by(|a, b| b.cmp(a));\n    }\n    array\n}\n\n\
    fn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmp0qlb_9f2.rs:18:20

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 0
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let len = array.len();\n  \
    \  if len == 0 {\n        return Vec::<isize>::new();\n    }\n    if len == 1\
    \ {\n        return array;\n    }\n    if (array[0] + array[len - 1]) % 2 == 0\
    \ {\n        array.sort_by(|a, b| b.cmp(a));\n    } else {\n        array.sort_by(|a,\
    \ b| a.cmp(b));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011761
- exit_code: 0
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = array.clone();\n    if result.len() >\
    \ 1 {\n        if (result[0] + result[result.len() - 1]) % 2 == 0 {\n        \
    \    result.sort_by(|a, b| b.cmp(a));\n        } else {\n            result.sort_by(|a,\
    \ b| a.cmp(b));\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let len = array.len();\n  \
    \  if len == 0 {\n        return array;\n    }\n    if len == 1 {\n        return\
    \ array;\n    }\n    let mut i = 0;\n    let mut j = len - 1;\n    while i < j\
    \ {\n        if array[i] > array[j] {\n            let tmp = array[i];\n     \
    \       array[i] = array[j];\n            array[j] = tmp;\n        }\n       \
    \ i += 1;\n        j -= 1;\n    }\n    array\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 1, 0, 3, 4, 5]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmpi0e7edp8.rs:42:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 1 && array[j]\
    \ % 2 == 0 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 0 {\n            j -= 1;\n      \
    \  } else {\n            i += 1;\n        }\n    }\n    if array.len() % 2 ==\
    \ 1 {\n        array[i..].sort();\n        array[..i].sort_by(|a, b| b.cmp(a));\n\
    \    } else {\n        array[i..].sort_by(|a, b| b.cmp(a));\n        array[..i].sort();\n\
    \    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpkz1ubjvc.rs:18:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    let mut sorted = false;\n    while !sorted {\n   \
    \     sorted = true;\n        while i < j {\n            if array[i] > array[i\
    \ + 1] {\n                array.swap(i, i + 1);\n                sorted = false;\n\
    \            }\n            i += 1;\n        }\n        while j > i {\n      \
    \      if array[j] < array[j - 1] {\n                array.swap(j, j - 1);\n \
    \               sorted = false;\n            }\n            j -= 1;\n        }\n\
    \    }\n    if array[0] + array[array.len() - 1] % 2 == 0 {\n        array.reverse();\n\
    \    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpaphmhh9a.rs:18:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    if array.len() > 1 {\n    \
    \    let mut i = 0;\n        let mut j = array.len() - 1;\n        while i < j\
    \ {\n            if array[i] % 2 == 0 && array[j] % 2 == 1 {\n               \
    \ array.swap(i, j);\n                i += 1;\n                j -= 1;\n      \
    \      } else if array[i] % 2 == 1 {\n                i += 1;\n            } else\
    \ if array[j] % 2 == 0 {\n                j -= 1;\n            } else {\n    \
    \            i += 1;\n                j -= 1;\n            }\n        }\n    \
    \    if array[i] % 2 == 0 {\n            array.sort_by(|a, b| b.cmp(a));\n   \
    \     } else {\n            array.sort_by(|a, b| a.cmp(b));\n        }\n    }\n\
    \    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 4, 3, 2, 1, 0]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmpe2u37e47.rs:47:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 0 {\n        array.sort();\n    } else {\n        array.sort_by(|a, b|\
    \ b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpdaax5gn8.rs:18:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if (array[i] + array[j]) %\
    \ 2 == 0 {\n            array.swap(i, j);\n        }\n        i += 1;\n      \
    \  j -= 1;\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpfu_nz2b7.rs:18:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let len = array.len();\n  \
    \  if len == 0 {\n        return array;\n    }\n    if len == 1 {\n        return\
    \ array;\n    }\n    let mut i = 0;\n    let mut j = len - 1;\n    while i < j\
    \ {\n        if array[i] > array[j] {\n            let temp = array[i];\n    \
    \        array[i] = array[j];\n            array[j] = temp;\n        }\n     \
    \   i += 1;\n        j -= 1;\n    }\n    array\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 1, 0, 3, 4, 5]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmp2idom1ud.rs:42:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011761
- exit_code: 0
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = array.clone();\n    if result.len() >\
    \ 1 {\n        if (result[0] + result[result.len() - 1]) % 2 == 0 {\n        \
    \    result.sort_by(|a, b| b.cmp(a));\n        } else {\n            result.sort_by(|a,\
    \ b| a.cmp(b));\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011761
- exit_code: 0
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    if array.len() > 1 {\n    \
    \    let (first, last) = (array[0], array[array.len() - 1]);\n        if (first\
    \ + last) % 2 == 0 {\n            array.sort_by(|a, b| b.cmp(a));\n        } else\
    \ {\n            array.sort_by(|a, b| a.cmp(b));\n        }\n    }\n    array\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011761
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    if array.len() > 1 {\n    \
    \    let (mut left, mut right) = array.split_at_mut(array.len() / 2);\n      \
    \  left = sort_array(left.to_vec()).as_mut_slice();\n        right = sort_array(right.to_vec()).as_mut_slice();\n\
    \        let mut i = 0;\n        let mut j = 0;\n        let mut k = 0;\n    \
    \    while i < left.len() && j < right.len() {\n            if (left[i] + right[j])\
    \ % 2 == 0 {\n                array[k] = right[j];\n                j += 1;\n\
    \            } else {\n                array[k] = left[i];\n                i\
    \ += 1;\n            }\n            k += 1;\n        }\n        while i < left.len()\
    \ {\n            array[k] = left[i];\n            i += 1;\n            k += 1;\n\
    \        }\n        while j < right.len() {\n            array[k] = right[j];\n\
    \            j += 1;\n            k += 1;\n        }\n    }\n    array\n}\n\n\
    fn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0502]: cannot borrow `array` as immutable because it is also borrowed\
    \ as mutable\n  --> /tmp/tmpi88ss2xw.rs:18:56\n   |\n18 |         let (mut left,\
    \ mut right) = array.split_at_mut(array.len() / 2);\n   |                    \
    \                 -------------------^^^^^^^^^^^-----\n   |                  \
    \                   |     |            |\n   |                               \
    \      |     |            immutable borrow occurs here\n   |                 \
    \                    |     mutable borrow later used by call\n   |           \
    \                          mutable borrow occurs here\n   |\nhelp: try adding\
    \ a local storing this argument...\n  --> /tmp/tmpi88ss2xw.rs:18:56\n   |\n18\
    \ |         let (mut left, mut right) = array.split_at_mut(array.len() / 2);\n\
    \   |                                                        ^^^^^^^^^^^\nhelp:\
    \ ...and then using that local as the argument to this call\n  --> /tmp/tmpi88ss2xw.rs:18:37\n\
    \   |\n18 |         let (mut left, mut right) = array.split_at_mut(array.len()\
    \ / 2);\n   |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror[E0716]: temporary value dropped while borrowed\n  --> /tmp/tmpi88ss2xw.rs:19:16\n\
    \   |\n19 |         left = sort_array(left.to_vec()).as_mut_slice();\n   |   \
    \             ^^^^^^^^^^^^^^^^^^^^^^^^^               - temporary value is freed\
    \ at the end of this statement\n   |                |\n   |                creates\
    \ a temporary which is freed while still in use\n...\n24 |         while i < left.len()\
    \ && j < right.len() {\n   |                   ---------- borrow later used here\n\
    \   |\n   = note: consider using a `let` binding to create a longer lived value\n\
    \nerror[E0716]: temporary value dropped while borrowed\n  --> /tmp/tmpi88ss2xw.rs:20:17\n\
    \   |\n20 |         right = sort_array(right.to_vec()).as_mut_slice();\n   | \
    \                ^^^^^^^^^^^^^^^^^^^^^^^^^^               - temporary value is\
    \ freed at the end of this statement\n   |                 |\n   |           \
    \      creates a temporary which is freed while still in use\n...\n24 |      \
    \   while i < left.len() &&"
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    array.sort_by(|a, b| {\n  \
    \      if (a + b) % 2 == 0 {\n            b.cmp(a)\n        } else {\n       \
    \     a.cmp(b)\n        }\n    });\n    array\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[4, 2, 0, 5, 3, 1]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmpg988ikvb.rs:31:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    if array.len() > 1 {\n    \
    \    let mut first = 0;\n        let mut last = array.len() - 1;\n        while\
    \ first < last {\n            if array[first] % 2 == 0 && array[last] % 2 == 0\
    \ {\n                last -= 1;\n            } else if array[first] % 2 == 1 &&\
    \ array[last] % 2 == 1 {\n                first += 1;\n            } else if array[first]\
    \ % 2 == 0 && array[last] % 2 == 1 {\n                array.swap(first, last);\n\
    \                first += 1;\n                last -= 1;\n            } else {\n\
    \                if array[first] > array[last] {\n                    array.swap(first,\
    \ last);\n                }\n                first += 1;\n                last\
    \ -= 1;\n            }\n        }\n        if array.len() % 2 == 0 {\n       \
    \     array.reverse();\n        }\n    }\n    array\n}\n\nfn main() {\n    let\
    \ candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 4, 3, 0, 1, 5]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmphjpuaklq.rs:48:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    if array.len() > 1 {\n    \
    \    if array[0] + array[array.len() - 1] % 2 == 0 {\n            array.sort_by(|a,\
    \ b| b.cmp(a));\n        } else {\n            array.sort_by(|a, b| a.cmp(b));\n\
    \        }\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpdcraklrj.rs:32:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    if array.len() > 1 {\n    \
    \    let (first, last) = (array[0], array[array.len() - 1]);\n        let (mut\
    \ left, mut right) = (0, array.len() - 1);\n        while left < right {\n   \
    \         if (first + last) % 2 == 0 {\n                if array[left] > array[right]\
    \ {\n                    array.swap(left, right);\n                }\n       \
    \     } else {\n                if array[left] < array[right] {\n            \
    \        array.swap(left, right);\n                }\n            }\n        \
    \    left += 1;\n            right -= 1;\n        }\n    }\n    array\n}\n\nfn\
    \ main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 4, 3, 0, 1, 2]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmpgr0b_qfl.rs:41:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = array.clone();\n    let mut i = 0;\n \
    \   let mut j = result.len() - 1;\n    while i < j {\n        if result[i] % 2\
    \ == 0 && result[j] % 2 == 1 {\n            result.swap(i, j);\n            i\
    \ += 1;\n            j -= 1;\n        } else if result[i] % 2 == 1 {\n       \
    \     i += 1;\n        } else if result[j] % 2 == 0 {\n            j -= 1;\n \
    \       } else {\n            i += 1;\n            j -= 1;\n        }\n    }\n\
    \    if result.len() % 2 == 1 {\n        result.sort_by(|a, b| b.cmp(a));\n  \
    \  } else {\n        result.sort();\n    }\n    result\n}\n\nfn main() {\n   \
    \ let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmp87jdzntn.rs:18:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 0
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sorted = array.clone();\n    if array.len() > 1\
    \ {\n        if (array[0] + array[array.len() - 1]) % 2 == 0 {\n            sorted.sort_by(|a,\
    \ b| b.cmp(a));\n        } else {\n            sorted.sort_by(|a, b| a.cmp(b));\n\
    \        }\n    }\n    sorted\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 0 {\n        array.sort();\n    } else {\n        array.sort_by(|a, b|\
    \ b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpdaax5gn8.rs:18:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 0 {\n        array.sort();\n    } else {\n        array.sort_by(|a, b|\
    \ b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpdaax5gn8.rs:18:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 0 {\n        array.sort();\n    } else {\n        array.sort_by(|a, b|\
    \ b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpdaax5gn8.rs:18:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            let tmp = array[i];\n            array[i] = array[j];\n\
    \            array[j] = tmp;\n            i += 1;\n            j -= 1;\n     \
    \   } else if array[i] % 2 == 1 {\n            i += 1;\n        } else if array[j]\
    \ % 2 == 0 {\n            j -= 1;\n        } else {\n            i += 1;\n   \
    \         j -= 1;\n        }\n    }\n    if array.len() % 2 == 1 {\n        array.sort_by(|a,\
    \ b| b.cmp(a));\n    } else {\n        array.sort();\n    }\n    array\n}\n\n\
    fn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpq30r3uqc.rs:18:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 0
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    if array.len() > 1 {\n    \
    \    let (first, last) = (array[0], array[array.len() - 1]);\n        if (first\
    \ + last) % 2 == 0 {\n            array.sort_by(|a, b| b.cmp(a));\n        } else\
    \ {\n            array.sort_by(|a, b| a.cmp(b));\n        }\n    }\n    array\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 0 {\n        array.sort();\n    } else {\n        array.sort_by(|a, b|\
    \ b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpdaax5gn8.rs:18:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    if array.len() > 1 {\n    \
    \    let (first, last) = (array[0], array[array.len() - 1]);\n        let (mut\
    \ left, mut right) = (1, array.len() - 2);\n        while left <= right {\n  \
    \          if (first + last) % 2 == 0 {\n                if array[left] > array[right]\
    \ {\n                    array.swap(left, right);\n                }\n       \
    \     } else {\n                if array[left] < array[right] {\n            \
    \        array.swap(left, right);\n                }\n            }\n        \
    \    left += 1;\n            right -= 1;\n        }\n    }\n    array\n}\n\nfn\
    \ main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 4, 3, 0, 1, 5]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmp8txh6wio.rs:41:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    if array.len() > 1 {\n    \
    \    let (mut start, mut end) = (0, array.len() - 1);\n        while start < end\
    \ {\n            while start < end && (array[start] + array[end]) % 2 == 1 {\n\
    \                start += 1;\n            }\n            while start < end &&\
    \ (array[start] + array[end]) % 2 == 0 {\n                end -= 1;\n        \
    \    }\n            if start < end {\n                array.swap(start, end);\n\
    \            }\n        }\n        array[..start].sort();\n        array[start..].sort_by(|a,\
    \ b| b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 2, 4, 5, 3, 1]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmpzgjl51ln.rs:40:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 0 {\n        array.sort();\n    } else {\n        array.sort_by(|a, b|\
    \ b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpdaax5gn8.rs:18:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 0 {\n        array.sort();\n    } else {\n        array.sort_by(|a, b|\
    \ b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpdaax5gn8.rs:18:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if i == j && array[i]\
    \ % 2 == 0 {\n        array.swap(i, 0);\n    }\n    if array.len() % 2 == 0 {\n\
    \        array.sort();\n    } else {\n        array.sort_by(|a, b| b.cmp(a));\n\
    \    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmp2p1zkhlj.rs:18:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let len = array.len();\n  \
    \  if len == 0 {\n        return Vec::<isize>::new();\n    }\n    if len == 1\
    \ {\n        return array;\n    }\n    let mut i = 0;\n    let mut j = len - 1;\n\
    \    while i < j {\n        if array[i] > array[j] {\n            let tmp = array[i];\n\
    \            array[i] = array[j];\n            array[j] = tmp;\n        }\n  \
    \      i += 1;\n        j -= 1;\n    }\n    array\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 1, 0, 3, 4, 5]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmp4celqgl8.rs:42:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if i == j && array[i]\
    \ % 2 == 0 {\n        array.swap(i, j);\n    }\n    array\n}\n\nfn main() {\n\
    \    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpgzdzpjnv.rs:18:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    if array.len() > 1 {\n    \
    \    let mut i = 0;\n        let mut j = array.len() - 1;\n        while i < j\
    \ {\n            if array[i] % 2 == 0 && array[j] % 2 == 1 {\n               \
    \ array.swap(i, j);\n                i += 1;\n                j -= 1;\n      \
    \      } else if array[i] % 2 == 1 {\n                i += 1;\n            } else\
    \ if array[j] % 2 == 0 {\n                j -= 1;\n            } else {\n    \
    \            i += 1;\n                j -= 1;\n            }\n        }\n    \
    \    if array[i] % 2 == 0 {\n            array.sort_by(|a, b| b.cmp(a));\n   \
    \     } else {\n            array.sort_by(|a, b| a.cmp(b));\n        }\n    }\n\
    \    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 4, 3, 2, 1, 0]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmpe2u37e47.rs:47:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011761
- exit_code: 0
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let len = array.len();\n  \
    \  if len == 0 {\n        return array;\n    }\n    if len == 1 {\n        return\
    \ array;\n    }\n    if (array[0] + array[len - 1]) % 2 == 0 {\n        array.sort_by(|a,\
    \ b| b.cmp(a));\n    } else {\n        array.sort_by(|a, b| a.cmp(b));\n    }\n\
    \    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    array.sort_by(|a, b| {\n  \
    \      if (a + b) % 2 == 0 {\n            b.cmp(a)\n        } else {\n       \
    \     a.cmp(b)\n        }\n    });\n    array\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[4, 2, 0, 5, 3, 1]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmpg988ikvb.rs:31:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 0 {\n        array.sort();\n    } else {\n        array.sort_by(|a, b|\
    \ b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpdaax5gn8.rs:18:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 0 {\n        array.sort();\n    } else {\n        array.sort_by(|a, b|\
    \ b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpdaax5gn8.rs:18:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 0 {\n        array.sort();\n    } else {\n        array.sort_by(|a, b|\
    \ b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpdaax5gn8.rs:18:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 0
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    if array.len() > 1 {\n    \
    \    let (first, last) = (array[0], array[array.len() - 1]);\n        if (first\
    \ + last) % 2 == 0 {\n            array.sort_by(|a, b| b.cmp(a));\n        } else\
    \ {\n            array.sort_by(|a, b| a.cmp(b));\n        }\n    }\n    array\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if (array[i] + array[j]) %\
    \ 2 == 0 {\n            array.swap(i, j);\n        }\n        i += 1;\n      \
    \  j -= 1;\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpfu_nz2b7.rs:18:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if i == j && array[i]\
    \ % 2 == 0 {\n        array.swap(i, j);\n    }\n    if array.len() % 2 == 0 {\n\
    \        array.sort();\n    } else {\n        array.sort_by(|a, b| b.cmp(a));\n\
    \    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpqc_1e2hq.rs:18:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 0 {\n        array.sort();\n    } else {\n        array.sort_by(|a, b|\
    \ b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpdaax5gn8.rs:18:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    let mut is_odd = false;\n    if array.len() > 1 {\n\
    \        if (array[0] + array[array.len() - 1]) % 2 == 1 {\n            is_odd\
    \ = true;\n        }\n    }\n    while i < j {\n        if is_odd {\n        \
    \    if array[i] % 2 == 0 {\n                i += 1;\n            } else if array[j]\
    \ % 2 == 1 {\n                j -= 1;\n            } else {\n                array.swap(i,\
    \ j);\n                i += 1;\n                j -= 1;\n            }\n     \
    \   } else {\n            if array[i] % 2 == 1 {\n                i += 1;\n  \
    \          } else if array[j] % 2 == 0 {\n                j -= 1;\n          \
    \  } else {\n                array.swap(i, j);\n                i += 1;\n    \
    \            j -= 1;\n            }\n        }\n    }\n    array\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmp2e017skp.rs:18:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 0 {\n        array.sort();\n    } else {\n        array.sort_by(|a, b|\
    \ b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpdaax5gn8.rs:18:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 0 {\n        array.sort();\n    } else {\n        array.sort_by(|a, b|\
    \ b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpdaax5gn8.rs:18:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if i == j && array[i]\
    \ % 2 == 0 {\n        array.reverse();\n    }\n    array\n}\n\nfn main() {\n \
    \   let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpx1j_hilv.rs:18:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    if array.len() < 2 {\n    \
    \    return array;\n    }\n    let mut i = 0;\n    let mut j = array.len() - 1;\n\
    \    while i < j {\n        if array[i] > array[j] {\n            array.swap(i,\
    \ j);\n        }\n        i += 1;\n        j -= 1;\n    }\n    if array[0] + array[array.len()\
    \ - 1] % 2 == 0 {\n        array.reverse();\n    }\n    array\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 1, 0, 3, 4, 5]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmpwuw9a8c1.rs:39:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 0 {\n        array.sort();\n    } else {\n        array.sort_by(|a, b|\
    \ b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpdaax5gn8.rs:18:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut index = 0;\n    let\
    \ mut sorted = false;\n    while !sorted {\n        sorted = true;\n        for\
    \ i in index..array.len() - 1 {\n            if array[0] + array[array.len() -\
    \ 1] % 2 == 0 {\n                if array[i] < array[i + 1] {\n              \
    \      array.swap(i, i + 1);\n                    sorted = false;\n          \
    \      }\n            } else {\n                if array[i] > array[i + 1] {\n\
    \                    array.swap(i, i + 1);\n                    sorted = false;\n\
    \                }\n            }\n        }\n        index += 1;\n    }\n   \
    \ array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmp_oanmu8x.rs:21:25

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 0
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let len = array.len();\n  \
    \  if len == 0 {\n        return array;\n    }\n    if len == 1 {\n        return\
    \ array;\n    }\n    let mut is_odd = false;\n    if (array[0] + array[len - 1])\
    \ % 2 == 1 {\n        is_odd = true;\n    }\n    if is_odd {\n        array.sort();\n\
    \    } else {\n        array.sort_by(|a, b| b.cmp(a));\n    }\n    array\n}\n\n\
    fn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] > array[j] {\n\
    \            array.swap(i, j);\n        }\n        i += 1;\n        j -= 1;\n\
    \    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpmchu6ryg.rs:18:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 0 {\n        array.sort();\n    } else {\n        array.sort_by(|a, b|\
    \ b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpdaax5gn8.rs:18:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut sorted = false;\n \
    \   while !sorted {\n        sorted = true;\n        for i in 0..array.len() -\
    \ 1 {\n            if (array[0] + array[array.len() - 1]) % 2 == 0 {\n       \
    \         if array[i] < array[i + 1] {\n                    array.swap(i, i +\
    \ 1);\n                    sorted = false;\n                }\n            } else\
    \ {\n                if array[i] > array[i + 1] {\n                    array.swap(i,\
    \ i + 1);\n                    sorted = false;\n                }\n          \
    \  }\n        }\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpyh3_gwcf.rs:20:21

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = array.clone();\n    let mut i = 0;\n \
    \   let mut j = array.len() - 1;\n    let mut is_odd = true;\n    if array.len()\
    \ > 1 {\n        is_odd = (array[0] + array[array.len() - 1]) % 2 == 0;\n    }\n\
    \    while i < j {\n        if is_odd {\n            if result[i] > result[j]\
    \ {\n                let tmp = result[i];\n                result[i] = result[j];\n\
    \                result[j] = tmp;\n            }\n        } else {\n         \
    \   if result[i] < result[j] {\n                let tmp = result[i];\n       \
    \         result[i] = result[j];\n                result[j] = tmp;\n         \
    \   }\n        }\n        i += 1;\n        j -= 1;\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpoekodyqf.rs:18:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut sorted = false;\n \
    \   while !sorted {\n        sorted = true;\n        for i in 0..array.len() -\
    \ 1 {\n            if (array[0] + array[array.len() - 1]) % 2 == 0 {\n       \
    \         if array[i] < array[i + 1] {\n                    array.swap(i, i +\
    \ 1);\n                    sorted = false;\n                }\n            } else\
    \ {\n                if array[i] > array[i + 1] {\n                    array.swap(i,\
    \ i + 1);\n                    sorted = false;\n                }\n          \
    \  }\n        }\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpyh3_gwcf.rs:20:21

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    if array.len() > 1 {\n    \
    \    let (first, last) = (array[0], array[array.len() - 1]);\n        let (mut\
    \ left, mut right) = (0, array.len() - 1);\n        while left < right {\n   \
    \         if (first + last) % 2 == 0 {\n                if array[left] > array[right]\
    \ {\n                    array.swap(left, right);\n                }\n       \
    \     } else {\n                if array[left] < array[right] {\n            \
    \        array.swap(left, right);\n                }\n            }\n        \
    \    left += 1;\n            right -= 1;\n        }\n    }\n    array\n}\n\nfn\
    \ main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 4, 3, 0, 1, 2]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmpgr0b_qfl.rs:41:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = array.clone();\n    if array.len() > 1\
    \ {\n        let mut i = 0;\n        let mut j = array.len() - 1;\n        while\
    \ i < j {\n            if array[i] > array[j] {\n                result.swap(i,\
    \ j);\n            }\n            i += 1;\n            j -= 1;\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 1, 0, 3, 4, 5]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmpaixf4qke.rs:35:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 0 {\n        array.sort();\n    } else {\n        array.sort_by(|a, b|\
    \ b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpdaax5gn8.rs:18:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 0 {\n        array.sort();\n    } else {\n        array.sort_by(|a, b|\
    \ b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpdaax5gn8.rs:18:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 0
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    if array.len() > 1 {\n    \
    \    let (first, last) = (array[0], array[array.len() - 1]);\n        if (first\
    \ + last) % 2 == 0 {\n            array.sort_by(|a, b| b.cmp(a));\n        } else\
    \ {\n            array.sort_by(|a, b| a.cmp(b));\n        }\n    }\n    array\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    if array.len() > 1 {\n    \
    \    let mut i = 0;\n        let mut j = array.len() - 1;\n        while i < j\
    \ {\n            if array[i] > array[j] {\n                array.swap(i, j);\n\
    \            }\n            i += 1;\n            j -= 1;\n        }\n    }\n \
    \   array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 1, 0, 3, 4, 5]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmpsljwzi0o.rs:35:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011761
- exit_code: 0
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    if array.len() > 1 {\n    \
    \    let (first, last) = (array[0], array[array.len() - 1]);\n        if (first\
    \ + last) % 2 == 0 {\n            array.sort_by(|a, b| b.cmp(a));\n        } else\
    \ {\n            array.sort_by(|a, b| a.cmp(b));\n        }\n    }\n    array\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011761
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    if array.len() > 1 {\n    \
    \    let (mut left, mut right) = array.split_at_mut(array.len() / 2);\n      \
    \  left = sort_array(left.to_vec()).as_mut_slice();\n        right = sort_array(right.to_vec()).as_mut_slice();\n\
    \        let mut i = 0;\n        let mut j = 0;\n        let mut k = 0;\n    \
    \    while i < left.len() && j < right.len() {\n            if left[i] < right[j]\
    \ {\n                array[k] = left[i];\n                i += 1;\n          \
    \  } else {\n                array[k] = right[j];\n                j += 1;\n \
    \           }\n            k += 1;\n        }\n        while i < left.len() {\n\
    \            array[k] = left[i];\n            i += 1;\n            k += 1;\n \
    \       }\n        while j < right.len() {\n            array[k] = right[j];\n\
    \            j += 1;\n            k += 1;\n        }\n    }\n    if array.len()\
    \ > 1 && (array[0] + array[array.len() - 1]) % 2 == 0 {\n        array.reverse();\n\
    \    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0502]: cannot borrow `array` as immutable because it is also borrowed\
    \ as mutable\n  --> /tmp/tmp_85xv1nq.rs:18:56\n   |\n18 |         let (mut left,\
    \ mut right) = array.split_at_mut(array.len() / 2);\n   |                    \
    \                 -------------------^^^^^^^^^^^-----\n   |                  \
    \                   |     |            |\n   |                               \
    \      |     |            immutable borrow occurs here\n   |                 \
    \                    |     mutable borrow later used by call\n   |           \
    \                          mutable borrow occurs here\n   |\nhelp: try adding\
    \ a local storing this argument...\n  --> /tmp/tmp_85xv1nq.rs:18:56\n   |\n18\
    \ |         let (mut left, mut right) = array.split_at_mut(array.len() / 2);\n\
    \   |                                                        ^^^^^^^^^^^\nhelp:\
    \ ...and then using that local as the argument to this call\n  --> /tmp/tmp_85xv1nq.rs:18:37\n\
    \   |\n18 |         let (mut left, mut right) = array.split_at_mut(array.len()\
    \ / 2);\n   |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror[E0716]: temporary value dropped while borrowed\n  --> /tmp/tmp_85xv1nq.rs:19:16\n\
    \   |\n19 |         left = sort_array(left.to_vec()).as_mut_slice();\n   |   \
    \             ^^^^^^^^^^^^^^^^^^^^^^^^^               - temporary value is freed\
    \ at the end of this statement\n   |                |\n   |                creates\
    \ a temporary which is freed while still in use\n...\n24 |         while i < left.len()\
    \ && j < right.len() {\n   |                   ---------- borrow later used here\n\
    \   |\n   = note: consider using a `let` binding to create a longer lived value\n\
    \nerror[E0716]: temporary value dropped while borrowed\n  --> /tmp/tmp_85xv1nq.rs:20:17\n\
    \   |\n20 |         right = sort_array(right.to_vec()).as_mut_slice();\n   | \
    \                ^^^^^^^^^^^^^^^^^^^^^^^^^^               - temporary value is\
    \ freed at the end of this statement\n   |                 |\n   |           \
    \      creates a temporary which is freed while still in use\n...\n24 |      \
    \   while i < left.len() &&"
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 0 {\n        array.sort();\n    } else {\n        array.sort_by(|a, b|\
    \ b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpdaax5gn8.rs:18:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 0
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    if array.len() > 1 {\n    \
    \    let (first, last) = (array[0], array[array.len() - 1]);\n        if (first\
    \ + last) % 2 == 0 {\n            array.sort_by(|a, b| b.cmp(a));\n        } else\
    \ {\n            array.sort_by(|a, b| a.cmp(b));\n        }\n    }\n    array\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut sorted = false;\n \
    \   while !sorted {\n        sorted = true;\n        for i in 0..array.len() -\
    \ 1 {\n            if (array[0] + array[array.len() - 1]) % 2 == 0 {\n       \
    \         if array[i] < array[i + 1] {\n                    array.swap(i, i +\
    \ 1);\n                    sorted = false;\n                }\n            } else\
    \ {\n                if array[i] > array[i + 1] {\n                    array.swap(i,\
    \ i + 1);\n                    sorted = false;\n                }\n          \
    \  }\n        }\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpyh3_gwcf.rs:20:21

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 0 {\n        array.sort();\n    } else {\n        array.sort_by(|a, b|\
    \ b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpdaax5gn8.rs:18:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    if array.len() > 1 {\n    \
    \    let (mut i, mut j) = (0, array.len() - 1);\n        while i < j {\n     \
    \       if array[i] % 2 == 0 {\n                array.swap(i, j);\n          \
    \      j -= 1;\n            } else {\n                i += 1;\n            }\n\
    \        }\n        if array[0] % 2 == 0 {\n            array.sort_by(|a, b| b.cmp(a));\n\
    \        } else {\n            array.sort();\n        }\n    }\n    array\n}\n\
    \nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmp0vyjtq_9.rs:41:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut index = 0;\n    let\
    \ mut sorted = false;\n    while !sorted {\n        sorted = true;\n        for\
    \ i in index..array.len() - 1 {\n            if array[index] % 2 == 0 {\n    \
    \            if array[i] < array[i + 1] {\n                    sorted = false;\n\
    \                    array.swap(i, i + 1);\n                }\n            } else\
    \ {\n                if array[i] > array[i + 1] {\n                    sorted\
    \ = false;\n                    array.swap(i, i + 1);\n                }\n   \
    \         }\n        }\n        index += 1;\n    }\n    array\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpfn6f17te.rs:21:25

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    if array.len() > 1 {\n    \
    \    let mut i = 0;\n        let mut j = array.len() - 1;\n        while i < j\
    \ {\n            if array[i] % 2 == 0 && array[j] % 2 == 1 {\n               \
    \ array.swap(i, j);\n                i += 1;\n                j -= 1;\n      \
    \      } else if array[i] % 2 == 1 {\n                i += 1;\n            } else\
    \ if array[j] % 2 == 0 {\n                j -= 1;\n            } else {\n    \
    \            i += 1;\n                j -= 1;\n            }\n        }\n    \
    \    if array[i] % 2 == 0 {\n            array.sort_by(|a, b| b.cmp(a));\n   \
    \     } else {\n            array.sort_by(|a, b| a.cmp(b));\n        }\n    }\n\
    \    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 4, 3, 2, 1, 0]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmpe2u37e47.rs:47:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 0 {\n        array.sort();\n    } else {\n        array.sort_by(|a, b|\
    \ b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpdaax5gn8.rs:18:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 0 {\n        array.sort();\n    } else {\n        array.sort_by(|a, b|\
    \ b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpdaax5gn8.rs:18:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    if array.len() > 1 {\n    \
    \    let (mut start, mut end) = (0, array.len() - 1);\n        while start < end\
    \ {\n            if (array[start] + array[end]) % 2 == 0 {\n                array.swap(start,\
    \ end);\n            }\n            start += 1;\n            end -= 1;\n     \
    \   }\n        array.sort();\n    }\n    array\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmptc_an_kf.rs:36:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let len = array.len();\n  \
    \  if len == 0 {\n        return array;\n    }\n    let mut i = 0;\n    let mut\
    \ j = len - 1;\n    while i < j {\n        if array[i] > array[j] {\n        \
    \    array.swap(i, j);\n        }\n        i += 1;\n        j -= 1;\n    }\n \
    \   if len % 2 == 0 {\n        array.reverse();\n    }\n    array\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 4, 3, 0, 1, 2]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmp3sutu2y9.rs:40:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 0 {\n        array.sort();\n    } else {\n        array.sort_by(|a, b|\
    \ b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpdaax5gn8.rs:18:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 0
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    if array.len() > 1 {\n    \
    \    let (first, last) = (array[0], array[array.len() - 1]);\n        if (first\
    \ + last) % 2 == 0 {\n            array.sort_by(|a, b| b.cmp(a));\n        } else\
    \ {\n            array.sort_by(|a, b| a.cmp(b));\n        }\n    }\n    array\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 0 {\n        array.sort();\n    } else {\n        array.sort_by(|a, b|\
    \ b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpdaax5gn8.rs:18:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 0
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let sum = array.first().unwrap_or(&0)\
    \ + array.last().unwrap_or(&0);\n    if sum % 2 == 0 {\n        array.sort_by(|a,\
    \ b| b.cmp(a));\n    } else {\n        array.sort();\n    }\n    array\n}\n\n\
    fn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    let mut is_odd = array[0] + array[j] % 2 == 1;\n \
    \   while i < j {\n        if is_odd {\n            if array[i] > array[j] {\n\
    \                array.swap(i, j);\n            }\n        } else {\n        \
    \    if array[i] < array[j] {\n                array.swap(i, j);\n           \
    \ }\n        }\n        i += 1;\n        j -= 1;\n    }\n    array\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmp83_85xba.rs:18:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    if array.len() > 1 {\n    \
    \    let (mut left, mut right) = array.split_at_mut(array.len() / 2);\n      \
    \  left = sort_array(left.to_vec()).as_mut_slice();\n        right = sort_array(right.to_vec()).as_mut_slice();\n\
    \        let mut i = 0;\n        let mut j = 0;\n        let mut k = 0;\n    \
    \    while i < left.len() && j < right.len() {\n            if (left[i] + right[j])\
    \ % 2 == 0 {\n                array[k] = left[i];\n                i += 1;\n \
    \           } else {\n                array[k] = right[j];\n                j\
    \ += 1;\n            }\n            k += 1;\n        }\n        while i < left.len()\
    \ {\n            array[k] = left[i];\n            i += 1;\n            k += 1;\n\
    \        }\n        while j < right.len() {\n            array[k] = right[j];\n\
    \            j += 1;\n            k += 1;\n        }\n    }\n    array\n}\n\n\
    fn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0502]: cannot borrow `array` as immutable because it is also borrowed\
    \ as mutable\n  --> /tmp/tmpt9fvgrtt.rs:18:56\n   |\n18 |         let (mut left,\
    \ mut right) = array.split_at_mut(array.len() / 2);\n   |                    \
    \                 -------------------^^^^^^^^^^^-----\n   |                  \
    \                   |     |            |\n   |                               \
    \      |     |            immutable borrow occurs here\n   |                 \
    \                    |     mutable borrow later used by call\n   |           \
    \                          mutable borrow occurs here\n   |\nhelp: try adding\
    \ a local storing this argument...\n  --> /tmp/tmpt9fvgrtt.rs:18:56\n   |\n18\
    \ |         let (mut left, mut right) = array.split_at_mut(array.len() / 2);\n\
    \   |                                                        ^^^^^^^^^^^\nhelp:\
    \ ...and then using that local as the argument to this call\n  --> /tmp/tmpt9fvgrtt.rs:18:37\n\
    \   |\n18 |         let (mut left, mut right) = array.split_at_mut(array.len()\
    \ / 2);\n   |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror[E0716]: temporary value dropped while borrowed\n  --> /tmp/tmpt9fvgrtt.rs:19:16\n\
    \   |\n19 |         left = sort_array(left.to_vec()).as_mut_slice();\n   |   \
    \             ^^^^^^^^^^^^^^^^^^^^^^^^^               - temporary value is freed\
    \ at the end of this statement\n   |                |\n   |                creates\
    \ a temporary which is freed while still in use\n...\n24 |         while i < left.len()\
    \ && j < right.len() {\n   |                   ---------- borrow later used here\n\
    \   |\n   = note: consider using a `let` binding to create a longer lived value\n\
    \nerror[E0716]: temporary value dropped while borrowed\n  --> /tmp/tmpt9fvgrtt.rs:20:17\n\
    \   |\n20 |         right = sort_array(right.to_vec()).as_mut_slice();\n   | \
    \                ^^^^^^^^^^^^^^^^^^^^^^^^^^               - temporary value is\
    \ freed at the end of this statement\n   |                 |\n   |           \
    \      creates a temporary which is freed while still in use\n...\n24 |      \
    \   while i < left.len() &&"
  stdout: ''
  timestamp: 1660011760
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 0 {\n        array.sort();\n    } else {\n        array.sort_by(|a, b|\
    \ b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpdaax5gn8.rs:18:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut sorted = false;\n \
    \   while !sorted {\n        sorted = true;\n        for i in 0..array.len() -\
    \ 1 {\n            if array[i] > array[i + 1] {\n                array.swap(i,\
    \ i + 1);\n                sorted = false;\n            }\n        }\n    }\n\
    \    if array.len() > 1 && (array[0] + array[array.len() - 1]) % 2 == 0 {\n  \
    \      array.reverse();\n    }\n    array\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpje0dejmj.rs:20:21

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let len = array.len();\n  \
    \  if len == 0 {\n        return Vec::<isize>::new();\n    }\n    if len == 1\
    \ {\n        return array;\n    }\n    let mut i = 0;\n    let mut j = len - 1;\n\
    \    while i < j {\n        if array[i] > array[j] {\n            array.swap(i,\
    \ j);\n        }\n        i += 1;\n        j -= 1;\n    }\n    if len % 2 == 0\
    \ {\n        array.reverse();\n    }\n    array\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 4, 3, 0, 1, 2]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmplkh9g4ui.rs:43:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 0 {\n        array.sort();\n    } else {\n        array.sort_by(|a, b|\
    \ b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpdaax5gn8.rs:18:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let len = array.len();\n  \
    \  if len == 0 {\n        return array;\n    }\n    if len == 1 {\n        return\
    \ array;\n    }\n    if array[0] + array[len - 1] % 2 == 0 {\n        array.sort_by(|a,\
    \ b| b.cmp(a));\n    } else {\n        array.sort_by(|a, b| a.cmp(b));\n    }\n\
    \    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmp0cf5qa8t.rs:37:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011761
- exit_code: 0
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let len = array.len();\n  \
    \  if len > 1 {\n        if (array[0] + array[len - 1]) % 2 == 0 {\n         \
    \   array.sort_by(|a, b| b.cmp(a));\n        } else {\n            array.sort_by(|a,\
    \ b| a.cmp(b));\n        }\n    }\n    array\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 0 {\n        array.sort();\n    } else {\n        array.sort_by(|a, b|\
    \ b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpdaax5gn8.rs:18:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 0
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    if array.len() > 1 {\n    \
    \    let (first, last) = (array[0], array[array.len() - 1]);\n        if (first\
    \ + last) % 2 == 0 {\n            array.sort_by(|a, b| b.cmp(a));\n        } else\
    \ {\n            array.sort_by(|a, b| a.cmp(b));\n        }\n    }\n    array\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 != 0 && array[j]\
    \ % 2 == 0 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 0 {\n            j -= 1;\n      \
    \  } else {\n            i += 1;\n        }\n    }\n    if array.len() % 2 ==\
    \ 0 {\n        array.sort();\n    } else {\n        array.sort_by(|a, b| b.cmp(a));\n\
    \    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpabd_wtnf.rs:18:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    if array.len() > 1 {\n    \
    \    let (mut left, mut right) = array.split_at_mut(array.len() / 2);\n      \
    \  left = sort_array(left.to_vec()).as_mut_slice();\n        right = sort_array(right.to_vec()).as_mut_slice();\n\
    \        let mut i = 0;\n        let mut j = 0;\n        let mut k = 0;\n    \
    \    while i < left.len() && j < right.len() {\n            if (left[i] + right[j])\
    \ % 2 == 0 {\n                array[k] = left[i];\n                i += 1;\n \
    \           } else {\n                array[k] = right[j];\n                j\
    \ += 1;\n            }\n            k += 1;\n        }\n        while i < left.len()\
    \ {\n            array[k] = left[i];\n            i += 1;\n            k += 1;\n\
    \        }\n        while j < right.len() {\n            array[k] = right[j];\n\
    \            j += 1;\n            k += 1;\n        }\n    }\n    array\n}\n\n\
    fn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0502]: cannot borrow `array` as immutable because it is also borrowed\
    \ as mutable\n  --> /tmp/tmpt9fvgrtt.rs:18:56\n   |\n18 |         let (mut left,\
    \ mut right) = array.split_at_mut(array.len() / 2);\n   |                    \
    \                 -------------------^^^^^^^^^^^-----\n   |                  \
    \                   |     |            |\n   |                               \
    \      |     |            immutable borrow occurs here\n   |                 \
    \                    |     mutable borrow later used by call\n   |           \
    \                          mutable borrow occurs here\n   |\nhelp: try adding\
    \ a local storing this argument...\n  --> /tmp/tmpt9fvgrtt.rs:18:56\n   |\n18\
    \ |         let (mut left, mut right) = array.split_at_mut(array.len() / 2);\n\
    \   |                                                        ^^^^^^^^^^^\nhelp:\
    \ ...and then using that local as the argument to this call\n  --> /tmp/tmpt9fvgrtt.rs:18:37\n\
    \   |\n18 |         let (mut left, mut right) = array.split_at_mut(array.len()\
    \ / 2);\n   |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror[E0716]: temporary value dropped while borrowed\n  --> /tmp/tmpt9fvgrtt.rs:19:16\n\
    \   |\n19 |         left = sort_array(left.to_vec()).as_mut_slice();\n   |   \
    \             ^^^^^^^^^^^^^^^^^^^^^^^^^               - temporary value is freed\
    \ at the end of this statement\n   |                |\n   |                creates\
    \ a temporary which is freed while still in use\n...\n24 |         while i < left.len()\
    \ && j < right.len() {\n   |                   ---------- borrow later used here\n\
    \   |\n   = note: consider using a `let` binding to create a longer lived value\n\
    \nerror[E0716]: temporary value dropped while borrowed\n  --> /tmp/tmpt9fvgrtt.rs:20:17\n\
    \   |\n20 |         right = sort_array(right.to_vec()).as_mut_slice();\n   | \
    \                ^^^^^^^^^^^^^^^^^^^^^^^^^^               - temporary value is\
    \ freed at the end of this statement\n   |                 |\n   |           \
    \      creates a temporary which is freed while still in use\n...\n24 |      \
    \   while i < left.len() &&"
  stdout: ''
  timestamp: 1660011760
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] > array[j] {\n\
    \            array.swap(i, j);\n        }\n        i += 1;\n        j -= 1;\n\
    \    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpmchu6ryg.rs:18:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 0
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    if array.len() > 1 {\n    \
    \    let (first, last) = (array[0], array[array.len() - 1]);\n        if (first\
    \ + last) % 2 == 0 {\n            array.sort_by(|a, b| b.cmp(a));\n        } else\
    \ {\n            array.sort_by(|a, b| a.cmp(b));\n        }\n    }\n    array\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 0 {\n        array.sort();\n    } else {\n        array.sort_by(|a, b|\
    \ b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpdaax5gn8.rs:18:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if i == j && array[i]\
    \ % 2 == 0 {\n        array.reverse();\n    }\n    array\n}\n\nfn main() {\n \
    \   let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpx1j_hilv.rs:18:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 0 {\n        array.sort();\n    } else {\n        array.sort_by(|a, b|\
    \ b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpdaax5gn8.rs:18:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut sorted = false;\n \
    \   while !sorted {\n        sorted = true;\n        for i in 0..array.len() -\
    \ 1 {\n            if (array[0] + array[array.len() - 1]) % 2 == 0 {\n       \
    \         if array[i] < array[i + 1] {\n                    array.swap(i, i +\
    \ 1);\n                    sorted = false;\n                }\n            } else\
    \ {\n                if array[i] > array[i + 1] {\n                    array.swap(i,\
    \ i + 1);\n                    sorted = false;\n                }\n          \
    \  }\n        }\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpyh3_gwcf.rs:20:21

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 0 {\n        array.sort();\n    } else {\n        array.sort_by(|a, b|\
    \ b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpdaax5gn8.rs:18:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 0
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = array.clone();\n    let mut is_odd = false;\n\
    \    if array.len() > 1 {\n        is_odd = (array[0] + array[array.len() - 1])\
    \ % 2 == 1;\n    }\n    if is_odd {\n        result.sort();\n    } else {\n  \
    \      result.sort_by(|a, b| b.cmp(a));\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    let mut sorted = false;\n    while !sorted {\n   \
    \     sorted = true;\n        while i < j {\n            if array[i] > array[i\
    \ + 1] {\n                array.swap(i, i + 1);\n                sorted = false;\n\
    \            }\n            i += 1;\n        }\n        i = 0;\n        while\
    \ i < j {\n            if array[j] < array[j - 1] {\n                array.swap(j,\
    \ j - 1);\n                sorted = false;\n            }\n            j -= 1;\n\
    \        }\n        j = array.len() - 1;\n    }\n    array\n}\n\nfn main() {\n\
    \    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpoo4ykhwr.rs:18:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 0 {\n        array.sort();\n    } else {\n        array.sort_by(|a, b|\
    \ b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpdaax5gn8.rs:18:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sorted_array = array.clone();\n    sorted_array.sort();\n\
    \    if (array[0] + array[array.len() - 1]) % 2 == 0 {\n        sorted_array.reverse();\n\
    \    }\n    sorted_array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpwzledoxa.rs:18:9

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 0 {\n        array.sort();\n    } else {\n        array.sort_by(|a, b|\
    \ b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpdaax5gn8.rs:18:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 0 {\n        array.sort();\n    } else {\n        array.sort_by(|a, b|\
    \ b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpdaax5gn8.rs:18:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 0
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    if array.len() > 1 {\n    \
    \    if (array[0] + array[array.len() - 1]) % 2 == 0 {\n            array.sort_by(|a,\
    \ b| b.cmp(a));\n        } else {\n            array.sort_by(|a, b| a.cmp(b));\n\
    \        }\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 0 {\n        array.sort();\n    } else {\n        array.sort_by(|a, b|\
    \ b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpdaax5gn8.rs:18:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    let mut sorted = false;\n    while !sorted {\n   \
    \     sorted = true;\n        while i < j {\n            if array[i] > array[i\
    \ + 1] {\n                array.swap(i, i + 1);\n                sorted = false;\n\
    \            }\n            i += 1;\n        }\n        j -= 1;\n        while\
    \ i > j {\n            if array[i] < array[i - 1] {\n                array.swap(i,\
    \ i - 1);\n                sorted = false;\n            }\n            i -= 1;\n\
    \        }\n        j += 1;\n    }\n    array\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpqjwj19lz.rs:18:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    if array.len() > 1 {\n    \
    \    if array[0] + array[array.len() - 1] % 2 == 0 {\n            array.sort_by(|a,\
    \ b| b.cmp(a));\n        } else {\n            array.sort_by(|a, b| a.cmp(b));\n\
    \        }\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpdcraklrj.rs:32:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    if array.len() < 2 {\n    \
    \    return array;\n    }\n    let (mut i, mut j) = (0, array.len() - 1);\n  \
    \  while i < j {\n        if (array[i] + array[j]) % 2 == 0 {\n            array.swap(i,\
    \ j);\n        }\n        i += 1;\n        j -= 1;\n    }\n    array\n}\n\nfn\
    \ main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 4, 3, 0, 1, 5]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmpcpjxywmq.rs:35:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = array.clone();\n    if array.len() > 1\
    \ {\n        let mut i = 0;\n        let mut j = array.len() - 1;\n        while\
    \ i < j {\n            if array[i] % 2 == 0 && array[j] % 2 == 1 {\n         \
    \       result[i] = array[j];\n                result[j] = array[i];\n       \
    \         i += 1;\n                j -= 1;\n            } else if array[i] % 2\
    \ == 1 && array[j] % 2 == 0 {\n                i += 1;\n                j -= 1;\n\
    \            } else if array[i] % 2 == 1 && array[j] % 2 == 1 {\n            \
    \    i += 1;\n            } else {\n                j -= 1;\n            }\n \
    \       }\n        if array.len() % 2 == 1 {\n            result.sort();\n   \
    \     } else {\n            result.sort_by(|a, b| b.cmp(a));\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 4, 3, 2, 1, 0]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmpop9pfb6y.rs:48:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 0 {\n        array.sort();\n    } else {\n        array.sort_by(|a, b|\
    \ b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpdaax5gn8.rs:18:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 0 {\n        array.sort();\n    } else {\n        array.sort_by(|a, b|\
    \ b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpdaax5gn8.rs:18:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let len = array.len();\n  \
    \  if len == 0 {\n        return array;\n    }\n    let mut i = 0;\n    let mut\
    \ j = len - 1;\n    while i < j {\n        if array[i] > array[j] {\n        \
    \    array.swap(i, j);\n        }\n        i += 1;\n        j -= 1;\n    }\n \
    \   if len % 2 == 0 {\n        array.reverse();\n    }\n    array\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 4, 3, 0, 1, 2]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmp3sutu2y9.rs:40:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut sorted = false;\n \
    \   while !sorted {\n        sorted = true;\n        for i in 0..array.len() -\
    \ 1 {\n            if (array[0] + array[array.len() - 1]) % 2 == 0 {\n       \
    \         if array[i] < array[i + 1] {\n                    array.swap(i, i +\
    \ 1);\n                    sorted = false;\n                }\n            } else\
    \ {\n                if array[i] > array[i + 1] {\n                    array.swap(i,\
    \ i + 1);\n                    sorted = false;\n                }\n          \
    \  }\n        }\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpyh3_gwcf.rs:20:21

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 0 {\n        array.sort();\n    } else {\n        array.sort_by(|a, b|\
    \ b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpdaax5gn8.rs:18:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 0 {\n        array.sort();\n    } else {\n        array.sort_by(|a, b|\
    \ b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpdaax5gn8.rs:18:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = array.clone();\n    let sum = array[0]\
    \ + array[array.len() - 1];\n    if sum % 2 == 0 {\n        result.sort_by(|a,\
    \ b| b.cmp(a));\n    } else {\n        result.sort_by(|a, b| a.cmp(b));\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpfic5exgf.rs:17:15

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    if array.len() > 1 {\n    \
    \    let (first, last) = (array[0], array[array.len() - 1]);\n        let (mut\
    \ left, mut right) = (0, array.len() - 1);\n        while left < right {\n   \
    \         if (first + last) % 2 == 0 {\n                if array[left] < array[right]\
    \ {\n                    array.swap(left, right);\n                }\n       \
    \     } else {\n                if array[left] > array[right] {\n            \
    \        array.swap(left, right);\n                }\n            }\n        \
    \    left += 1;\n            right -= 1;\n        }\n    }\n    array\n}\n\nfn\
    \ main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 1, 0, 3, 4, 5]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmp8slxn11c.rs:41:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    let mut is_odd = (array[i] + array[j]) % 2 == 1;\n\
    \    while i < j {\n        if is_odd {\n            if array[i] % 2 == 0 {\n\
    \                i += 1;\n            } else if array[j] % 2 == 1 {\n        \
    \        j -= 1;\n            } else {\n                array.swap(i, j);\n  \
    \              i += 1;\n                j -= 1;\n            }\n        } else\
    \ {\n            if array[i] % 2 == 1 {\n                i += 1;\n           \
    \ } else if array[j] % 2 == 0 {\n                j -= 1;\n            } else {\n\
    \                array.swap(i, j);\n                i += 1;\n                j\
    \ -= 1;\n            }\n        }\n    }\n    array\n}\n\nfn main() {\n    let\
    \ candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpzrn654rg.rs:18:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 0 {\n        array.sort();\n    } else {\n        array.sort_by(|a, b|\
    \ b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpdaax5gn8.rs:18:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 0 {\n        array.sort();\n    } else {\n        array.sort_by(|a, b|\
    \ b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpdaax5gn8.rs:18:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    if array.len() > 1 {\n    \
    \    let (first, last) = (array[0], array[array.len() - 1]);\n        let (mut\
    \ left, mut right) = (0, array.len() - 1);\n        while left < right {\n   \
    \         if (first + last) % 2 == 0 {\n                if array[left] < array[right]\
    \ {\n                    array.swap(left, right);\n                }\n       \
    \     } else {\n                if array[left] > array[right] {\n            \
    \        array.swap(left, right);\n                }\n            }\n        \
    \    left += 1;\n            right -= 1;\n        }\n    }\n    array\n}\n\nfn\
    \ main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 1, 0, 3, 4, 5]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmp8slxn11c.rs:41:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 0 {\n        array.sort();\n    } else {\n        array.sort_by(|a, b|\
    \ b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpdaax5gn8.rs:18:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut first = 0;\n    let\
    \ mut last = array.len() - 1;\n    let mut sorted = false;\n    while !sorted\
    \ {\n        sorted = true;\n        for i in first..last {\n            if (array[i]\
    \ + array[last]) % 2 == 0 && array[i] > array[i + 1] {\n                array.swap(i,\
    \ i + 1);\n                sorted = false;\n            }\n        }\n       \
    \ last -= 1;\n        for i in (first..last).rev() {\n            if (array[i]\
    \ + array[last]) % 2 != 0 && array[i] < array[i + 1] {\n                array.swap(i,\
    \ i + 1);\n                sorted = false;\n            }\n        }\n       \
    \ first += 1;\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpa4g9p7fi.rs:18:20

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    let mut temp;\n    while i < j {\n        if array[i]\
    \ % 2 == 0 && array[j] % 2 == 1 {\n            temp = array[i];\n            array[i]\
    \ = array[j];\n            array[j] = temp;\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 && array[j] % 2 == 1 {\n      \
    \      i += 1;\n        } else if array[i] % 2 == 0 && array[j] % 2 == 0 {\n \
    \           j -= 1;\n        } else {\n            i += 1;\n            j -= 1;\n\
    \        }\n    }\n    if array.len() % 2 == 0 {\n        array.sort();\n    }\
    \ else {\n        array.sort_by(|a, b| b.cmp(a));\n    }\n    array\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpf2uyj2wq.rs:18:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 0 {\n        array.sort();\n    } else {\n        array.sort_by(|a, b|\
    \ b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpdaax5gn8.rs:18:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 0 {\n        array.sort();\n    } else {\n        array.sort_by(|a, b|\
    \ b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpdaax5gn8.rs:18:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let len = array.len();\n  \
    \  if len > 1 {\n        let (mut left, mut right) = array.split_at_mut(len /\
    \ 2);\n        left = sort_array(left.to_vec()).as_mut_slice();\n        right\
    \ = sort_array(right.to_vec()).as_mut_slice();\n        let mut i = 0;\n     \
    \   let mut j = 0;\n        let mut k = 0;\n        while i < left.len() && j\
    \ < right.len() {\n            if left[i] < right[j] {\n                array[k]\
    \ = left[i];\n                i += 1;\n            } else {\n                array[k]\
    \ = right[j];\n                j += 1;\n            }\n            k += 1;\n \
    \       }\n        while i < left.len() {\n            array[k] = left[i];\n \
    \           i += 1;\n            k += 1;\n        }\n        while j < right.len()\
    \ {\n            array[k] = right[j];\n            j += 1;\n            k += 1;\n\
    \        }\n    }\n    if len > 1 && (array[0] + array[len - 1]) % 2 == 0 {\n\
    \        array.reverse();\n    }\n    array\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0716]: temporary value dropped while borrowed\n  --> /tmp/tmpsy06fabz.rs:20:16\n\
    \   |\n20 |         left = sort_array(left.to_vec()).as_mut_slice();\n   |   \
    \             ^^^^^^^^^^^^^^^^^^^^^^^^^               - temporary value is freed\
    \ at the end of this statement\n   |                |\n   |                creates\
    \ a temporary which is freed while still in use\n...\n25 |         while i < left.len()\
    \ && j < right.len() {\n   |                   ---------- borrow later used here\n\
    \   |\n   = note: consider using a `let` binding to create a longer lived value\n\
    \nerror[E0716]: temporary value dropped while borrowed\n  --> /tmp/tmpsy06fabz.rs:21:17\n\
    \   |\n21 |         right = sort_array(right.to_vec()).as_mut_slice();\n   | \
    \                ^^^^^^^^^^^^^^^^^^^^^^^^^^               - temporary value is\
    \ freed at the end of this statement\n   |                 |\n   |           \
    \      creates a temporary which is freed while still in use\n...\n25 |      \
    \   while i < left.len() && j < right.len() {\n   |                          \
    \           ----------- borrow later used here\n   |\n   = note: consider using\
    \ a `let` binding to create a longer lived value\n\nerror[E0499]: cannot borrow\
    \ `array` as mutable more than once at a time\n  --> /tmp/tmpsy06fabz.rs:27:17\n\
    \   |\n19 |         let (mut left, mut right) = array.split_at_mut(len / 2);\n\
    \   |                                     --------------------------- first mutable\
    \ borrow occurs here\n...\n25 |         while i < left.len() && j < right.len()\
    \ {\n   |                   ---------- first borrow later used here\n26 |    \
    \         if left[i] < right[j] {\n27 |                 array[k] = left[i];\n\
    \   |                 ^^^^^ second mutable borrow occurs here\n\nerror[E0499]:\
    \ cannot borrow `array` as mutable more than once at a time\n  --> /tmp/tmpsy06fabz.rs:30:17\n\
    \   |\n19 |         let (mut left, mut right) = array.split_at_mut(len / 2);\n\
    \   |                                     --------------------------- first mutable\
    \ borrow occurs here\n...\n25 |         while i < left.len() && j < right.len()\
    \ {\n   |              "
  stdout: ''
  timestamp: 1660011761
- exit_code: 0
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = array.clone();\n    if result.len() >\
    \ 1 {\n        if (result[0] + result[result.len() - 1]) % 2 == 0 {\n        \
    \    result.sort_by(|a, b| b.cmp(a));\n        } else {\n            result.sort_by(|a,\
    \ b| a.cmp(b));\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    if array.len() > 1 {\n    \
    \    let mut i = 0;\n        let mut j = array.len() - 1;\n        while i < j\
    \ {\n            if array[i] % 2 == 0 && array[j] % 2 == 1 {\n               \
    \ array.swap(i, j);\n                i += 1;\n                j -= 1;\n      \
    \      } else if array[i] % 2 == 1 {\n                i += 1;\n            } else\
    \ if array[j] % 2 == 0 {\n                j -= 1;\n            } else {\n    \
    \            i += 1;\n                j -= 1;\n            }\n        }\n    \
    \    if array[i] % 2 == 0 {\n            array.sort_by(|a, b| b.cmp(a));\n   \
    \     } else {\n            array.sort_by(|a, b| a.cmp(b));\n        }\n    }\n\
    \    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 4, 3, 2, 1, 0]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmpe2u37e47.rs:47:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 0 {\n        array.sort();\n    } else {\n        array.sort_by(|a, b|\
    \ b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpdaax5gn8.rs:18:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 0 {\n        array.sort();\n    } else {\n        array.sort_by(|a, b|\
    \ b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpdaax5gn8.rs:18:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    if array.len() == 0 {\n        return array;\n   \
    \ }\n    if array.len() == 1 {\n        return array;\n    }\n    if array[0]\
    \ + array[array.len() - 1] % 2 == 0 {\n        while i < j {\n            if array[i]\
    \ > array[j] {\n                let temp = array[i];\n                array[i]\
    \ = array[j];\n                array[j] = temp;\n            }\n            i\
    \ += 1;\n            j -= 1;\n        }\n    } else {\n        while i < j {\n\
    \            if array[i] < array[j] {\n                let temp = array[i];\n\
    \                array[i] = array[j];\n                array[j] = temp;\n    \
    \        }\n            i += 1;\n            j -= 1;\n        }\n    }\n    array\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpb1t43wrw.rs:18:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 0 {\n        array.sort();\n    } else {\n        array.sort_by(|a, b|\
    \ b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpdaax5gn8.rs:18:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    if array.len() > 1 {\n    \
    \    let mut i = 0;\n        let mut j = array.len() - 1;\n        while i < j\
    \ {\n            if (array[i] + array[j]) % 2 == 0 {\n                array.swap(i,\
    \ j);\n            }\n            i += 1;\n            j -= 1;\n        }\n  \
    \      array.sort();\n    }\n    array\n}\n\nfn main() {\n    let candidate =\
    \ sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmptx0m2s36.rs:37:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    if array.len() > 1 {\n    \
    \    let mut i = 0;\n        let mut j = array.len() - 1;\n        while i < j\
    \ {\n            if array[i] % 2 == 0 && array[j] % 2 == 1 {\n               \
    \ array.swap(i, j);\n                i += 1;\n                j -= 1;\n      \
    \      } else if array[i] % 2 == 1 {\n                i += 1;\n            } else\
    \ if array[j] % 2 == 0 {\n                j -= 1;\n            } else {\n    \
    \            i += 1;\n                j -= 1;\n            }\n        }\n    \
    \    if i == j && array[i] % 2 == 0 {\n            array.swap(i, j);\n       \
    \ }\n        if (array[0] + array[array.len() - 1]) % 2 == 0 {\n            array.reverse();\n\
    \        }\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 1, 3, 0, 4, 2]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmpn6k5crvb.rs:48:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if i == j && array[i]\
    \ % 2 == 0 {\n        array.swap(i, 0);\n    }\n    array\n}\n\nfn main() {\n\
    \    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpamqa0652.rs:18:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut sorted = false;\n \
    \   while !sorted {\n        sorted = true;\n        for i in 0..array.len() -\
    \ 1 {\n            if array[i] > array[i + 1] {\n                array.swap(i,\
    \ i + 1);\n                sorted = false;\n            }\n        }\n    }\n\
    \    if array.len() > 1 && array[0] + array[array.len() - 1] % 2 == 0 {\n    \
    \    array.reverse();\n    }\n    array\n}\n\nfn main() {\n    let candidate =\
    \ sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpm8mf3x68.rs:20:21

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 0 {\n        array.sort();\n    } else {\n        array.sort_by(|a, b|\
    \ b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpdaax5gn8.rs:18:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    let mut sorted = false;\n    while !sorted {\n   \
    \     sorted = true;\n        while i < j {\n            if array[i] > array[i\
    \ + 1] {\n                array.swap(i, i + 1);\n                sorted = false;\n\
    \            }\n            i += 1;\n        }\n        i = 0;\n        while\
    \ i < j {\n            if array[j] < array[j - 1] {\n                array.swap(j,\
    \ j - 1);\n                sorted = false;\n            }\n            j -= 1;\n\
    \        }\n        j = array.len() - 1;\n    }\n    array\n}\n\nfn main() {\n\
    \    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpoo4ykhwr.rs:18:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if i == j && array[i]\
    \ % 2 == 0 {\n        array.reverse();\n    }\n    array\n}\n\nfn main() {\n \
    \   let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpx1j_hilv.rs:18:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 0
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    if array.len() > 1 {\n    \
    \    let first = array[0];\n        let last = array[array.len() - 1];\n     \
    \   if (first + last) % 2 == 0 {\n            array.sort_by(|a, b| b.cmp(a));\n\
    \        } else {\n            array.sort_by(|a, b| a.cmp(b));\n        }\n  \
    \  }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011762
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if (array[i] + array[j]) %\
    \ 2 == 0 {\n            array.swap(i, j);\n        }\n        i += 1;\n      \
    \  j -= 1;\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpfu_nz2b7.rs:18:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    let mut sorted = false;\n    while !sorted {\n   \
    \     sorted = true;\n        while i < j {\n            if array[i] > array[i\
    \ + 1] {\n                array.swap(i, i + 1);\n                sorted = false;\n\
    \            }\n            i += 1;\n        }\n        i = 0;\n        while\
    \ i < j {\n            if array[j] < array[j - 1] {\n                array.swap(j,\
    \ j - 1);\n                sorted = false;\n            }\n            j -= 1;\n\
    \        }\n        j = array.len() - 1;\n    }\n    array\n}\n\nfn main() {\n\
    \    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpoo4ykhwr.rs:18:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut index = 0;\n    let\
    \ mut sorted = false;\n    let mut order = array[0] + array[array.len() - 1];\n\
    \    if order % 2 == 0 {\n        order = -1;\n    } else {\n        order = 1;\n\
    \    }\n    while !sorted {\n        sorted = true;\n        for i in index..array.len()\
    \ - 1 {\n            if order * array[i] > order * array[i + 1] {\n          \
    \      array.swap(i, i + 1);\n                sorted = false;\n            }\n\
    \        }\n        index += 1;\n    }\n    array\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpi_l95bek.rs:19:21

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011762
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 0 {\n        array.sort();\n    } else {\n        array.sort_by(|a, b|\
    \ b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpdaax5gn8.rs:18:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 0 {\n        array.sort();\n    } else {\n        array.sort_by(|a, b|\
    \ b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpdaax5gn8.rs:18:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let len = array.len();\n  \
    \  if len == 0 {\n        return array;\n    }\n    if len == 1 {\n        return\
    \ array;\n    }\n    if array[0] + array[len - 1] % 2 == 0 {\n        array.sort_by(|a,\
    \ b| b.cmp(a));\n    } else {\n        array.sort_by(|a, b| a.cmp(b));\n    }\n\
    \    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmp0cf5qa8t.rs:37:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if i == j && array[i]\
    \ % 2 == 0 {\n        array.swap(i, 0);\n    }\n    array\n}\n\nfn main() {\n\
    \    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpamqa0652.rs:18:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] > array[j] {\n\
    \            array.swap(i, j);\n        }\n        i += 1;\n        j -= 1;\n\
    \    }\n    if array.len() % 2 == 0 {\n        array.reverse();\n    }\n    array\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpidffol2z.rs:18:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011762
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 0 {\n        array.sort();\n    } else {\n        array.sort_by(|a, b|\
    \ b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpdaax5gn8.rs:18:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let mut i = 0;\n    let mut\
    \ j = array.len() - 1;\n    while i < j {\n        if array[i] % 2 == 0 && array[j]\
    \ % 2 == 1 {\n            array.swap(i, j);\n            i += 1;\n           \
    \ j -= 1;\n        } else if array[i] % 2 == 1 {\n            i += 1;\n      \
    \  } else if array[j] % 2 == 0 {\n            j -= 1;\n        } else {\n    \
    \        i += 1;\n            j -= 1;\n        }\n    }\n    if array.len() %\
    \ 2 == 0 {\n        array.sort();\n    } else {\n        array.sort_by(|a, b|\
    \ b.cmp(a));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpdaax5gn8.rs:18:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011761
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array;\n    let len = array.len();\n  \
    \  if len == 0 {\n        return array;\n    }\n    if len == 1 {\n        return\
    \ array;\n    }\n    if array[0] + array[len - 1] % 2 == 0 {\n        array.sort_by(|a,\
    \ b| b.cmp(a));\n    } else {\n        array.sort_by(|a, b| a.cmp(b));\n    }\n\
    \    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmp0cf5qa8t.rs:37:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011761
