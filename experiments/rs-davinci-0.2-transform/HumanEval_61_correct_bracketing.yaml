name: HumanEval_61_correct_bracketing
language: rs
prompt: "/// brackets is a string of \"(\" and \")\".\n/// return True if every opening\
  \ bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
  (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n///\
  \ >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
  )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n"
tests: "}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!({left},\
  \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
  \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
  \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
  \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
  \ {right});\n    assert_eq!({left}, {right});\n}\n"
completions: ["    let mut stack = Vec::new();\n    for c in brackets.chars() {\n\
    \        match c {\n            '(' => stack.push(c),\n            ')' => {\n\
    \                if stack.pop() != Some('(') {\n                    return false;\n\
    \                }\n            }\n            _ => unreachable!(),\n        }\n\
    \    }\n    stack.is_empty()", "    let mut stack = Vec::new();\n    for c in\
    \ brackets.chars() {\n        match c {\n            '(' => stack.push(c),\n \
    \           ')' => {\n                if stack.is_empty() {\n                \
    \    return false;\n                }\n                stack.pop();\n        \
    \    }\n            _ => (),\n        }\n    }\n    stack.is_empty()", "    let\
    \ mut stack = Vec::new();\n    for c in brackets.chars() {\n        match c {\n\
    \            '(' => stack.push(c),\n            ')' => {\n                if stack.is_empty()\
    \ {\n                    return false;\n                }\n                stack.pop();\n\
    \            }\n            _ => (),\n        }\n    }\n    stack.is_empty()",
  "    let mut stack = Vec::new();\n    for c in brackets.chars() {\n        match\
    \ c {\n            '(' => stack.push(c),\n            ')' => {\n             \
    \   if stack.is_empty() {\n                    return false;\n               \
    \ }\n                stack.pop();\n            }\n            _ => (),\n     \
    \   }\n    }\n    stack.is_empty()", "    let mut stack = Vec::new();\n    for\
    \ c in brackets.chars() {\n        match c {\n            '(' => stack.push(c),\n\
    \            ')' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => (),\n        }\n    }\n    stack.is_empty()", "    let\
    \ mut stack = Vec::new();\n    for c in brackets.chars() {\n        match c {\n\
    \            '(' => stack.push(c),\n            ')' => {\n                if stack.is_empty()\
    \ {\n                    return false;\n                }\n                stack.pop();\n\
    \            }\n            _ => (),\n        }\n    }\n    stack.is_empty()",
  "    let mut stack = Vec::new();\n    for c in brackets.chars() {\n        match\
    \ c {\n            '(' => stack.push(c),\n            ')' => {\n             \
    \   if stack.is_empty() {\n                    return false;\n               \
    \ }\n                stack.pop();\n            }\n            _ => {}\n      \
    \  }\n    }\n    stack.is_empty()", "    let mut stack = Vec::new();\n    for\
    \ b in brackets.chars() {\n        match b {\n            '(' => stack.push(b),\n\
    \            ')' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => panic!(\"Invalid character\"),\n        }\n    }\n \
    \   stack.is_empty()", "    let mut stack = Vec::new();\n    for c in brackets.chars()\
    \ {\n        match c {\n            '(' => stack.push(c),\n            ')' =>\
    \ {\n                if stack.is_empty() {\n                    return false;\n\
    \                }\n                stack.pop();\n            }\n            _\
    \ => {}\n        }\n    }\n    stack.is_empty()", "    let mut stack = Vec::new();\n\
    \    for c in brackets.chars() {\n        match c {\n            '(' => stack.push(c),\n\
    \            ')' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => (),\n        }\n    }\n    stack.is_empty()", "    let\
    \ mut stack = Vec::new();\n    for c in brackets.chars() {\n        match c {\n\
    \            '(' => stack.push(c),\n            ')' => {\n                if stack.is_empty()\
    \ {\n                    return false;\n                }\n                stack.pop();\n\
    \            }\n            _ => {}\n        }\n    }\n    stack.is_empty()",
  "    let mut stack = Vec::new();\n    for c in brackets.chars() {\n        match\
    \ c {\n            '(' => stack.push(c),\n            ')' => {\n             \
    \   if stack.is_empty() {\n                    return false;\n               \
    \ }\n                stack.pop();\n            }\n            _ => (),\n     \
    \   }\n    }\n    stack.is_empty()", "    let mut stack = Vec::new();\n    for\
    \ c in brackets.chars() {\n        match c {\n            '(' => stack.push(c),\n\
    \            ')' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => (),\n        }\n    }\n    stack.is_empty()", "    let\
    \ mut stack = Vec::new();\n    for c in brackets.chars() {\n        match c {\n\
    \            '(' => stack.push(c),\n            ')' => {\n                if stack.is_empty()\
    \ {\n                    return false;\n                }\n                stack.pop();\n\
    \            }\n            _ => panic!(\"Unexpected character\"),\n        }\n\
    \    }\n    stack.is_empty()", "    let mut stack = Vec::new();\n    for c in\
    \ brackets.chars() {\n        match c {\n            '(' => stack.push(c),\n \
    \           ')' => {\n                if stack.is_empty() {\n                \
    \    return false;\n                }\n                stack.pop();\n        \
    \    }\n            _ => (),\n        }\n    }\n    stack.is_empty()", "    let\
    \ mut stack = Vec::new();\n    for c in brackets.chars() {\n        match c {\n\
    \            '(' => stack.push(c),\n            ')' => {\n                if stack.is_empty()\
    \ {\n                    return false;\n                }\n                stack.pop();\n\
    \            }\n            _ => {}\n        }\n    }\n    stack.is_empty()",
  "    let mut stack = Vec::new();\n    for c in brackets.chars() {\n        match\
    \ c {\n            '(' => stack.push(c),\n            ')' => {\n             \
    \   if stack.is_empty() {\n                    return false;\n               \
    \ }\n                stack.pop();\n            }\n            _ => (),\n     \
    \   }\n    }\n    stack.is_empty()", "    let mut stack = Vec::new();\n    for\
    \ c in brackets.chars() {\n        match c {\n            '(' => stack.push(c),\n\
    \            ')' => {\n                if stack.is_empty() {\n               \
    \     return false;\n                }\n                stack.pop();\n       \
    \     }\n            _ => {}\n        }\n    }\n    stack.is_empty()", "    let\
    \ mut stack = Vec::new();\n    for c in brackets.chars() {\n        match c {\n\
    \            '(' => stack.push(c),\n            ')' => match stack.pop() {\n \
    \               Some(_) => (),\n                None => return false,\n      \
    \      },\n            _ => (),\n        }\n    }\n    stack.is_empty()", "  \
    \  let mut stack = Vec::new();\n    for c in brackets.chars() {\n        match\
    \ c {\n            '(' => stack.push(c),\n            ')' => {\n             \
    \   if stack.is_empty() {\n                    return false;\n               \
    \ }\n                stack.pop();\n            }\n            _ => {}\n      \
    \  }\n    }\n    stack.is_empty()"]
stop_tokens:
- "\n}"
