language: rs
name: HumanEval_18_how_many_times
results:
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let string = string.as_str();\n\
    \    let substring = substring.as_str();\n    while index < string.len() {\n \
    \       if let Some(i) = string[index..].find(substring) {\n            count\
    \ += 1;\n            index += i + substring.len();\n        } else {\n       \
    \     break;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpyehby70l.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010959
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let mut string = string;\n\
    \    while index < string.len() {\n        let index_of_substring = string.find(&substring);\n\
    \        if index_of_substring.is_none() {\n            break;\n        }\n  \
    \      count += 1;\n        index += index_of_substring.unwrap() + 1;\n      \
    \  string = string[index..].to_string();\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpt8iqt235.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010959
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let mut string_chars = string.chars();\n\
    \    let substring_chars = substring.chars();\n    loop {\n        match string_chars.nth(index)\
    \ {\n            Some(x) => {\n                if x == substring_chars.clone().nth(0).unwrap()\
    \ {\n                    let mut i = 0;\n                    let mut string_chars_clone\
    \ = string_chars.clone();\n                    for c in substring_chars {\n  \
    \                      match string_chars_clone.nth(i) {\n                   \
    \         Some(x) => {\n                                if x != c {\n        \
    \                            break;\n                                }\n     \
    \                       }\n                            None => break,\n      \
    \                  }\n                        i += 1;\n                    }\n\
    \                    if i == substring.len() - 1 {\n                        count\
    \ += 1;\n                        index += i;\n                    } else {\n \
    \                       index += 1;\n                    }\n                }\
    \ else {\n                    index += 1;\n                }\n            }\n\
    \            None => break,\n        }\n    }\n    count\n}\n\nfn main() {\n \
    \   let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"\
    ), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `substring_chars`\n   --> /tmp/tmp2vee85e7.rs:16:25\n\
    \    |\n12  |     let substring_chars = substring.chars();\n    |         ---------------\
    \ move occurs because `substring_chars` has type `Chars<'_>`, which does not implement\
    \ the `Copy` trait\n...\n16  |                 if x == substring_chars.clone().nth(0).unwrap()\
    \ {\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^ value borrowed here\
    \ after move\n...\n19  |                     for c in substring_chars {\n    |\
    \                              --------------- `substring_chars` moved due to\
    \ this implicit call to `.into_iter()`, in previous iteration of loop\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `substring_chars`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660010958
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let mut string = string;\n\
    \    while index < string.len() {\n        if let Some(i) = string.find(&substring)\
    \ {\n            count += 1;\n            string = string.split_off(i + substring.len());\n\
    \        } else {\n            break;\n        }\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpivbnwmbh.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010959
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    while index < string.len()\
    \ {\n        if let Some(i) = string[index..].find(&substring) {\n           \
    \ count += 1;\n            index += i + substring.len();\n        } else {\n \
    \           break;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpu0b0_mcy.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010959
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let mut string = string;\n\
    \    let substring = substring;\n    while index != -1 {\n        index = string.find(&substring).unwrap_or(-1);\n\
    \        if index != -1 {\n            count += 1;\n            string = string[index\
    \ + substring.len()..].to_string();\n        }\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0600]: cannot apply unary operator `-` to type `usize`\n  --> /tmp/tmp2ccs9dzv.rs:14:51\n\
    \   |\n14 |         index = string.find(&substring).unwrap_or(-1);\n   |     \
    \                                              ^^\n   |                      \
    \                             |\n   |                                        \
    \           cannot apply unary operator `-`\n   |                            \
    \                       help: you may have meant the maximum value of `usize`:\
    \ `usize::MAX`\n   |\n   = note: unsigned values cannot be negated\n\nerror[E0277]:\
    \ the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmp2ccs9dzv.rs:13:20\n\
    \   |\n13 |     while index != -1 {\n   |                    ^^ the trait `Neg`\
    \ is not implemented for `usize`\n   |\n   = help: the following other types implement\
    \ trait `Neg`:\n             &f32\n             &f64\n             &i128\n   \
    \          &i16\n             &i32\n             &i64\n             &i8\n    \
    \         &isize\n           and 8 others\n\nerror[E0600]: cannot apply unary\
    \ operator `-` to type `usize`\n  --> /tmp/tmp2ccs9dzv.rs:15:21\n   |\n15 |  \
    \       if index != -1 {\n   |                     ^^\n   |                  \
    \   |\n   |                     cannot apply unary operator `-`\n   |        \
    \             help: you may have meant the maximum value of `usize`: `usize::MAX`\n\
    \   |\n   = note: unsigned values cannot be negated\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0600.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010958
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let string_len = string.len();\n\
    \    let substring_len = substring.len();\n    while index < string_len {\n  \
    \      if string[index..].starts_with(&substring) {\n            count += 1;\n\
    \            index += substring_len;\n        } else {\n            index += 1;\n\
    \        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp41mhz9rt.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010959
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   if string.len() == 0 || substring.len() == 0 {\n        return 0;\n    }\n\
    \    let mut count = 0;\n    let mut index = 0;\n    while index < string.len()\
    \ {\n        if let Some(i) = string[index..].find(&substring) {\n           \
    \ count += 1;\n            index += i + substring.len();\n        } else {\n \
    \           break;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpdsox4s04.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010959
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    while index < string.len()\
    \ {\n        if let Some(i) = string[index..].find(&substring) {\n           \
    \ count += 1;\n            index += i + substring.len();\n        } else {\n \
    \           break;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpu0b0_mcy.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010959
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut i = 0;\n    let string_len = string.len();\n\
    \    let substring_len = substring.len();\n    while i < string_len {\n      \
    \  if string[i..].starts_with(&substring) {\n            count += 1;\n       \
    \     i += substring_len;\n        } else {\n            i += 1;\n        }\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmprtlgp_fm.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010958
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let string_len = string.len();\n\
    \    let substring_len = substring.len();\n    while index < string_len {\n  \
    \      if string[index..].starts_with(&substring) {\n            count += 1;\n\
    \            index += substring_len;\n        } else {\n            index += 1;\n\
    \        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp41mhz9rt.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010959
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    while index < string.len()\
    \ {\n        if let Some(i) = string[index..].find(&substring) {\n           \
    \ count += 1;\n            index += i + substring.len();\n        } else {\n \
    \           break;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpu0b0_mcy.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010959
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let mut string = string;\n\
    \    while index < string.len() {\n        if string.starts_with(&substring) {\n\
    \            count += 1;\n            string = string.replace(&substring, \"\"\
    );\n        } else {\n            string = string.replace(string.get(index..index\
    \ + 1).unwrap(), \"\");\n        }\n    }\n    count\n}\n\nfn main() {\n    let\
    \ candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmp_zdax8i8.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010959
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut i = 0;\n    let mut j = 0;\n    let string_chars:\
    \ Vec<char> = string.chars().collect();\n    let substring_chars: Vec<char> =\
    \ substring.chars().collect();\n    let string_len = string_chars.len();\n   \
    \ let substring_len = substring_chars.len();\n    while i < string_len && j <\
    \ substring_len {\n        if string_chars[i] == substring_chars[j] {\n      \
    \      i += 1;\n            j += 1;\n        } else {\n            i = i - j +\
    \ 1;\n            j = 0;\n        }\n        if j == substring_len {\n       \
    \     count += 1;\n            j = 0;\n        }\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpco_6y5nw.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010959
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let string_len = string.len();\n\
    \    let substring_len = substring.len();\n    while index < string_len {\n  \
    \      if &string[index..index + substring_len] == substring {\n            count\
    \ += 1;\n            index += substring_len;\n        } else {\n            index\
    \ += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''byte index 10 is out of bounds of `cacacacac`'',
    library/core/src/str/mod.rs:107:9

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010958
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let mut string = string;\n\
    \    let substring = substring;\n    while index < string.len() {\n        if\
    \ string.starts_with(&substring) {\n            count += 1;\n            string\
    \ = string.chars().skip(substring.len()).collect();\n        } else {\n      \
    \      string = string.chars().skip(1).collect();\n        }\n        index +=\
    \ 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp25349b_n.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010959
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let string_len = string.len();\n\
    \    let substring_len = substring.len();\n    while index < string_len {\n  \
    \      let mut i = 0;\n        while i < substring_len && index + i < string_len\
    \ && string.chars().nth(index + i) == substring.chars().nth(i) {\n           \
    \ i += 1;\n        }\n        if i == substring_len {\n            count += 1;\n\
    \            index += i;\n        } else {\n            index += 1;\n        }\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpiod_tsen.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010958
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    while index < string.len()\
    \ {\n        let mut i = index;\n        let mut j = 0;\n        while i < string.len()\
    \ && j < substring.len() && string.chars().nth(i) == substring.chars().nth(j)\
    \ {\n            i += 1;\n            j += 1;\n        }\n        if j == substring.len()\
    \ {\n            count += 1;\n        }\n        index += 1;\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010959
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let mut string_chars = string.chars();\n\
    \    let substring_chars = substring.chars();\n    while let Some(c) = string_chars.nth(index)\
    \ {\n        if c == substring_chars.next().unwrap() {\n            let mut i\
    \ = 0;\n            let mut string_chars_clone = string_chars.clone();\n     \
    \       let mut substring_chars_clone = substring_chars.clone();\n           \
    \ while let Some(c) = string_chars_clone.next() {\n                if c == substring_chars_clone.next().unwrap()\
    \ {\n                    i += 1;\n                } else {\n                 \
    \   break;\n                }\n            }\n            if i == substring.len()\
    \ - 1 {\n                count += 1;\n                index += substring.len()\
    \ - 1;\n            }\n        }\n        index += 1;\n    }\n    count\n}\n\n\
    fn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `substring_chars` as mutable, as it is not\
    \ declared as mutable\n  --> /tmp/tmp1qmmuf1a.rs:14:17\n   |\n12 |     let substring_chars\
    \ = substring.chars();\n   |         --------------- help: consider changing this\
    \ to be mutable: `mut substring_chars`\n13 |     while let Some(c) = string_chars.nth(index)\
    \ {\n14 |         if c == substring_chars.next().unwrap() {\n   |            \
    \     ^^^^^^^^^^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0596`.\n"
  stdout: ''
  timestamp: 1660010958
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    while index < string.len()\
    \ {\n        if let Some(i) = string[index..].find(&substring) {\n           \
    \ count += 1;\n            index += i + substring.len();\n        } else {\n \
    \           break;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpu0b0_mcy.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010959
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let string_len = string.len();\n\
    \    let substring_len = substring.len();\n    while index < string_len {\n  \
    \      if string[index..].starts_with(&substring) {\n            count += 1;\n\
    \            index += substring_len;\n        } else {\n            index += 1;\n\
    \        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp41mhz9rt.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010959
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let string_len = string.len();\n\
    \    let substring_len = substring.len();\n    while index < string_len {\n  \
    \      let mut i = 0;\n        while i < substring_len && index + i < string_len\
    \ && string.chars().nth(index + i) == substring.chars().nth(i) {\n           \
    \ i += 1;\n        }\n        if i == substring_len {\n            count += 1;\n\
    \            index += i;\n        } else {\n            index += 1;\n        }\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpiod_tsen.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010958
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let mut string = string;\n\
    \    while let Some(pos) = string.find(&substring) {\n        count += 1;\n  \
    \      index += pos + 1;\n        string = string[index..].to_string();\n    }\n\
    \    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''byte index 4 is out of bounds of `xyx`'',
    library/core/src/str/mod.rs:107:9

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010959
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let string_len = string.len();\n\
    \    let substring_len = substring.len();\n    while index < string_len {\n  \
    \      if string[index..].starts_with(&substring) {\n            count += 1;\n\
    \            index += substring_len;\n        } else {\n            index += 1;\n\
    \        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp41mhz9rt.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010959
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let string_chars: Vec<char>\
    \ = string.chars().collect();\n    let substring_chars: Vec<char> = substring.chars().collect();\n\
    \    let substring_len = substring_chars.len();\n    while index < string_chars.len()\
    \ {\n        if string_chars[index] == substring_chars[0] {\n            let mut\
    \ is_substring = true;\n            for i in 1..substring_len {\n            \
    \    if index + i >= string_chars.len() || string_chars[index + i] != substring_chars[i]\
    \ {\n                    is_substring = false;\n                    break;\n \
    \               }\n            }\n            if is_substring {\n            \
    \    count += 1;\n                index += substring_len;\n            } else\
    \ {\n                index += 1;\n            }\n        } else {\n          \
    \  index += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpk4vy_hmu.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010959
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut start = 0;\n    let string_len = string.len();\n\
    \    let substring_len = substring.len();\n    while start + substring_len <=\
    \ string_len {\n        if &string[start..start + substring_len] == substring\
    \ {\n            count += 1;\n            start += substring_len;\n        } else\
    \ {\n            start += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpr9njf02l.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010958
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    while index < string.len()\
    \ {\n        let mut sub_index = 0;\n        while sub_index < substring.len()\
    \ && index + sub_index < string.len() {\n            if string.chars().nth(index\
    \ + sub_index) != substring.chars().nth(sub_index) {\n                break;\n\
    \            }\n            sub_index += 1;\n        }\n        if sub_index ==\
    \ substring.len() {\n            count += 1;\n            index += sub_index;\n\
    \        } else {\n            index += 1;\n        }\n    }\n    count\n}\n\n\
    fn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpqracf_ay.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010959
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut i = 0;\n    let mut j = 0;\n    let string_chars:\
    \ Vec<char> = string.chars().collect();\n    let substring_chars: Vec<char> =\
    \ substring.chars().collect();\n    let string_len = string_chars.len();\n   \
    \ let substring_len = substring_chars.len();\n    while i < string_len {\n   \
    \     if string_chars[i] == substring_chars[j] {\n            j += 1;\n      \
    \      if j == substring_len {\n                count += 1;\n                j\
    \ = 0;\n            }\n        } else {\n            j = 0;\n        }\n     \
    \   i += 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpxr9mx4k0.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010959
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let mut string = string;\n\
    \    let substring = substring;\n    while index < string.len() {\n        if\
    \ string.starts_with(&substring) {\n            count += 1;\n            string\
    \ = string.chars().skip(substring.len()).collect();\n        } else {\n      \
    \      string = string.chars().skip(1).collect();\n        }\n        index +=\
    \ 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp25349b_n.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010959
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut i = 0;\n    let mut j = 0;\n    let mut string_chars\
    \ = string.chars();\n    let mut substring_chars = substring.chars();\n    while\
    \ let Some(c) = string_chars.next() {\n        if c == substring_chars.next().unwrap()\
    \ {\n            j += 1;\n            if j == substring.len() {\n            \
    \    count += 1;\n                j = 0;\n                substring_chars = substring.chars();\n\
    \            }\n        } else {\n            j = 0;\n            substring_chars\
    \ = substring.chars();\n        }\n        i += 1;\n        if i == string.len()\
    \ {\n            break;\n        }\n    }\n    count\n}\n\nfn main() {\n    let\
    \ candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp0pyilusz.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010958
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let string_len = string.len();\n\
    \    let substring_len = substring.len();\n    while index < string_len {\n  \
    \      if &string[index..index + substring_len] == substring {\n            count\
    \ += 1;\n            index += substring_len;\n        } else {\n            index\
    \ += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''byte index 10 is out of bounds of `cacacacac`'',
    library/core/src/str/mod.rs:107:9

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010958
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let string = string.as_str();\n\
    \    let substring = substring.as_str();\n    while index < string.len() {\n \
    \       if let Some(i) = string[index..].find(substring) {\n            count\
    \ += 1;\n            index += i + substring.len();\n        } else {\n       \
    \     break;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpyehby70l.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010959
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    while index < string.len()\
    \ {\n        let mut i = 0;\n        while i < substring.len() && index + i <\
    \ string.len() {\n            if string.chars().nth(index + i) != substring.chars().nth(i)\
    \ {\n                break;\n            }\n            i += 1;\n        }\n \
    \       if i == substring.len() {\n            count += 1;\n            index\
    \ += i;\n        } else {\n            index += 1;\n        }\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmprb0hjc65.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010958
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut start = 0;\n    let mut end = substring.len();\n\
    \    let mut found = true;\n    while found {\n        found = false;\n      \
    \  for i in start..end {\n            if string.chars().nth(i).unwrap() == substring.chars().nth(i\
    \ - start).unwrap() {\n                found = true;\n            } else {\n \
    \               found = false;\n                break;\n            }\n      \
    \  }\n        if found {\n            count += 1;\n            start += 1;\n \
    \           end += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let\
    \ candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''called `Option::unwrap()` on a `None` value'',
    /tmp/tmp2h_gppkt.rs:16:38

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010959
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let mut string = string;\n\
    \    while let Some(i) = string.find(&substring) {\n        count += 1;\n    \
    \    index += i + 1;\n        string = string[index..].to_string();\n    }\n \
    \   count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''byte index 4 is out of bounds of `xyx`'',
    library/core/src/str/mod.rs:107:9

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010959
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut idx = 0;\n    let string_len = string.len();\n\
    \    let substring_len = substring.len();\n    while idx < string_len {\n    \
    \    if &string[idx..idx + substring_len] == substring {\n            count +=\
    \ 1;\n            idx += substring_len;\n        } else {\n            idx +=\
    \ 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''byte index 10 is out of bounds of `cacacacac`'',
    library/core/src/str/mod.rs:107:9

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010959
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    while index < string.len()\
    \ {\n        if string[index..].starts_with(&substring) {\n            count +=\
    \ 1;\n            index += substring.len();\n        } else {\n            index\
    \ += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp3oebdd3d.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010959
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let mut string = string;\n\
    \    while let Some(i) = string.find(&substring) {\n        count += 1;\n    \
    \    index += i + 1;\n        string = string[index..].to_string();\n    }\n \
    \   count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''byte index 4 is out of bounds of `xyx`'',
    library/core/src/str/mod.rs:107:9

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010959
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut start = 0;\n    let mut end = substring.len();\n\
    \    while end <= string.len() {\n        if string[start..end] == substring {\n\
    \            count += 1;\n        }\n        start += 1;\n        end += 1;\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010959
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let string_len = string.len();\n    let substring_len\
    \ = substring.len();\n    if string_len < substring_len {\n        return 0;\n\
    \    }\n    for i in 0..(string_len - substring_len + 1) {\n        if string[i..(i\
    \ + substring_len)] == substring {\n            count += 1;\n        }\n    }\n\
    \    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010959
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let string_len = string.len();\n\
    \    let substring_len = substring.len();\n    while index < string_len {\n  \
    \      if string[index..].starts_with(&substring) {\n            count += 1;\n\
    \            index += substring_len;\n        } else {\n            index += 1;\n\
    \        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp41mhz9rt.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010959
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let mut string = string;\n\
    \    let substring = substring;\n    while index < string.len() {\n        if\
    \ string.starts_with(&substring) {\n            count += 1;\n            string\
    \ = string.split_off(substring.len());\n        } else {\n            string =\
    \ string.split_off(1);\n        }\n        index += 1;\n    }\n    count\n}\n\n\
    fn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmptv3kwi3m.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010959
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let string_len = string.len();\n\
    \    let substring_len = substring.len();\n    if string_len == 0 || substring_len\
    \ == 0 {\n        return 0;\n    }\n    while index < string_len {\n        if\
    \ &string[index..index + substring_len] == substring {\n            count += 1;\n\
    \            index += substring_len;\n        } else {\n            index += 1;\n\
    \        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''byte index 10 is out of bounds of `cacacacac`'',
    library/core/src/str/mod.rs:107:9

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010959
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let mut string = string;\n\
    \    let substring = substring;\n    while index < string.len() {\n        let\
    \ index_opt = string.find(&substring);\n        match index_opt {\n          \
    \  Some(index) => {\n                count += 1;\n                string = string[index\
    \ + substring.len()..].to_string();\n            }\n            None => {\n  \
    \              break;\n            }\n        }\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpcxt3xrmr.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010959
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut i = 0;\n    while i < string.len() {\n   \
    \     if string[i..].starts_with(&substring) {\n            count += 1;\n    \
    \        i += substring.len();\n        } else {\n            i += 1;\n      \
    \  }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmptxvwynid.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010959
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut start = 0;\n    let mut end = substring.len();\n\
    \    let len = string.len();\n    while end <= len {\n        if string[start..end]\
    \ == substring {\n            count += 1;\n            start += 1;\n         \
    \   end += 1;\n        } else {\n            start += 1;\n            end += 1;\n\
    \        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010959
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    while index < string.len()\
    \ {\n        let found = string[index..].find(&substring);\n        if found.is_none()\
    \ {\n            break;\n        }\n        count += 1;\n        index += found.unwrap()\
    \ + substring.len();\n    }\n    count\n}\n\nfn main() {\n    let candidate =\
    \ how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmptny1i13d.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010959
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let mut string = string;\n\
    \    while let Some(i) = string.find(&substring) {\n        count += 1;\n    \
    \    index += i + 1;\n        string = string[index..].to_string();\n    }\n \
    \   count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''byte index 4 is out of bounds of `xyx`'',
    library/core/src/str/mod.rs:107:9

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010959
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let string_length = string.len();\n\
    \    let substring_length = substring.len();\n    while index <= string_length\
    \ - substring_length {\n        if &string[index..index + substring_length] ==\
    \ substring {\n            count += 1;\n            index += substring_length;\n\
    \        } else {\n            index += 1;\n        }\n    }\n    count\n}\n\n\
    fn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmp7j_2jmew.rs:13:20

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010959
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let mut string = string;\n\
    \    while let Some(i) = string.find(&substring) {\n        count += 1;\n    \
    \    index += i + 1;\n        string = string[index..].to_string();\n    }\n \
    \   count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''byte index 4 is out of bounds of `xyx`'',
    library/core/src/str/mod.rs:107:9

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010959
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let mut string = string;\n\
    \    while let Some(i) = string.find(&substring) {\n        count += 1;\n    \
    \    index += i + 1;\n        string = string[index..].to_string();\n    }\n \
    \   count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''byte index 4 is out of bounds of `xyx`'',
    library/core/src/str/mod.rs:107:9

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010959
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    while index < string.len()\
    \ {\n        if let Some(i) = string[index..].find(&substring) {\n           \
    \ count += 1;\n            index += i + substring.len();\n        } else {\n \
    \           break;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpu0b0_mcy.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010959
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let mut string = string;\n\
    \    let substring = substring;\n    while index < string.len() {\n        let\
    \ index_option = string.find(&substring);\n        match index_option {\n    \
    \        Some(index) => {\n                count += 1;\n                string\
    \ = string[index + substring.len()..].to_string();\n            }\n          \
    \  None => {\n                break;\n            }\n        }\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpony434eq.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010959
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let mut string = string;\n\
    \    let substring = substring;\n    while index < string.len() {\n        if\
    \ string.starts_with(&substring) {\n            count += 1;\n            string\
    \ = string.replace(substring.as_str(), \"\");\n        } else {\n            string\
    \ = string.replace(string.get(0..1).unwrap(), \"\");\n        }\n        index\
    \ += 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmplecm6tcz.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010959
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut i = 0;\n    let mut j = 0;\n    let mut string_chars\
    \ = string.chars();\n    let mut substring_chars = substring.chars();\n    while\
    \ let Some(c) = string_chars.next() {\n        if c == substring_chars.next().unwrap()\
    \ {\n            j += 1;\n            if j == substring.len() {\n            \
    \    count += 1;\n                j = 0;\n                substring_chars = substring.chars();\n\
    \            }\n        } else {\n            j = 0;\n            substring_chars\
    \ = substring.chars();\n        }\n        i += 1;\n        if i == string.len()\
    \ {\n            break;\n        }\n    }\n    count\n}\n\nfn main() {\n    let\
    \ candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp0pyilusz.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010958
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let mut string = string;\n\
    \    while index < string.len() {\n        if string.starts_with(&substring) {\n\
    \            count += 1;\n            string = string.chars().skip(substring.len()).collect();\n\
    \        } else {\n            string = string.chars().skip(1).collect();\n  \
    \      }\n        index += 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpmdmvx_un.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010959
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let mut string = string;\n\
    \    while index < string.len() {\n        let index_of_substring = string.find(&substring);\n\
    \        if index_of_substring.is_none() {\n            break;\n        }\n  \
    \      let index_of_substring = index_of_substring.unwrap();\n        count +=\
    \ 1;\n        index += index_of_substring + substring.len();\n        string =\
    \ string[index_of_substring + substring.len()..].to_string();\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `4`', /tmp/tmpr3zsfxwi.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010959
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    while index < string.len()\
    \ {\n        if let Some(i) = string[index..].find(&substring) {\n           \
    \ count += 1;\n            index += i + substring.len();\n        } else {\n \
    \           break;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpu0b0_mcy.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010959
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let mut string = string;\n\
    \    let substring = substring;\n    while index < string.len() {\n        let\
    \ index_opt = string.find(&substring);\n        match index_opt {\n          \
    \  Some(index) => {\n                count += 1;\n                string = string[index\
    \ + substring.len()..].to_string();\n            }\n            None => break,\n\
    \        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp89jsy3tg.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010959
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    while index < string.len()\
    \ {\n        let mut i = 0;\n        while i < substring.len() && index + i <\
    \ string.len() {\n            if string.chars().nth(index + i) != substring.chars().nth(i)\
    \ {\n                break;\n            }\n            i += 1;\n        }\n \
    \       if i == substring.len() {\n            count += 1;\n            index\
    \ += i;\n        } else {\n            index += 1;\n        }\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmprb0hjc65.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010958
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let string_length = string.len();\n\
    \    let substring_length = substring.len();\n    while index < string_length\
    \ {\n        if string[index..].starts_with(&substring) {\n            count +=\
    \ 1;\n            index += substring_length;\n        } else {\n            index\
    \ += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp998j_1vh.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010959
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let mut string = string;\n\
    \    let substring = substring;\n    while index < string.len() {\n        let\
    \ mut index_substring = 0;\n        let mut index_string = index;\n        while\
    \ index_substring < substring.len() && index_string < string.len() {\n       \
    \     if substring.chars().nth(index_substring) == string.chars().nth(index_string)\
    \ {\n                index_substring += 1;\n                index_string += 1;\n\
    \            } else {\n                break;\n            }\n        }\n    \
    \    if index_substring == substring.len() {\n            count += 1;\n      \
    \      string = string.chars().skip(index_string).collect();\n            index\
    \ = 0;\n        } else {\n            index += 1;\n        }\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmph0dasavd.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010959
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut start = 0;\n    let mut end = substring.len();\n\
    \    while end <= string.len() {\n        if &string[start..end] == substring\
    \ {\n            count += 1;\n        }\n        start += 1;\n        end += 1;\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010959
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut string_index = 0;\n    let mut substring_index\
    \ = 0;\n    let string_len = string.len();\n    let substring_len = substring.len();\n\
    \    let mut string_chars = string.chars();\n    let mut substring_chars = substring.chars();\n\
    \    let mut string_char = string_chars.next();\n    let mut substring_char =\
    \ substring_chars.next();\n    while string_index < string_len && substring_index\
    \ < substring_len {\n        if string_char == substring_char {\n            string_char\
    \ = string_chars.next();\n            substring_char = substring_chars.next();\n\
    \            string_index += 1;\n            substring_index += 1;\n        }\
    \ else {\n            string_char = string_chars.next();\n            string_index\
    \ += 1;\n            substring_index = 0;\n            substring_chars = substring.chars();\n\
    \            substring_char = substring_chars.next();\n        }\n        if substring_index\
    \ == substring_len {\n            count += 1;\n            substring_index = 0;\n\
    \            substring_chars = substring.chars();\n            substring_char\
    \ = substring_chars.next();\n        }\n    }\n    count\n}\n\nfn main() {\n \
    \   let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"\
    ), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpsggp6_v_.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010959
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let string_len = string.len();\n\
    \    let substring_len = substring.len();\n    while index < string_len {\n  \
    \      if string[index..].starts_with(&substring) {\n            count += 1;\n\
    \            index += substring_len;\n        } else {\n            index += 1;\n\
    \        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp41mhz9rt.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010959
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut start = 0;\n    let mut end = substring.len();\n\
    \    while end <= string.len() {\n        if string[start..end] == substring {\n\
    \            count += 1;\n        }\n        start += 1;\n        end += 1;\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010959
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let mut string = string;\n\
    \    let substring = substring;\n    while index < string.len() {\n        if\
    \ string.starts_with(&substring) {\n            count += 1;\n            string\
    \ = string.chars().skip(substring.len()).collect();\n        } else {\n      \
    \      string = string.chars().skip(1).collect();\n        }\n        index +=\
    \ 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp25349b_n.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010959
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut start_index = 0;\n    let mut end_index =\
    \ substring.len();\n    let string_len = string.len();\n    let substring_len\
    \ = substring.len();\n    while end_index <= string_len {\n        if string[start_index..end_index]\
    \ == substring {\n            count += 1;\n            start_index += 1;\n   \
    \         end_index += 1;\n        } else {\n            start_index += 1;\n \
    \           end_index += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n \
    \   let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"\
    ), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010959
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    while index < string.len()\
    \ {\n        let mut found = false;\n        for (i, c) in substring.chars().enumerate()\
    \ {\n            if index + i >= string.len() {\n                break;\n    \
    \        }\n            if c != string.chars().nth(index + i).unwrap() {\n   \
    \             break;\n            }\n            if i == substring.len() - 1 {\n\
    \                found = true;\n            }\n        }\n        if found {\n\
    \            count += 1;\n            index += substring.len();\n        } else\
    \ {\n            index += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp9z953xf1.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010959
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut start = 0;\n    while let Some(index) = string[start..].find(&substring)\
    \ {\n        count += 1;\n        start = start + index + 1;\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010959
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    while index < string.len()\
    \ {\n        if let Some(i) = string[index..].find(&substring) {\n           \
    \ count += 1;\n            index += i + substring.len();\n        } else {\n \
    \           break;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpu0b0_mcy.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010959
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut string_iter = string.chars();\n    let mut\
    \ substring_iter = substring.chars();\n    let mut current_char = string_iter.next();\n\
    \    let mut current_substring_char = substring_iter.next();\n    while current_char.is_some()\
    \ {\n        if current_char.unwrap() == current_substring_char.unwrap() {\n \
    \           let mut current_char_clone = current_char.clone();\n            let\
    \ mut current_substring_char_clone = current_substring_char.clone();\n       \
    \     while current_char_clone.is_some() && current_substring_char_clone.is_some()\
    \ {\n                if current_char_clone.unwrap() == current_substring_char_clone.unwrap()\
    \ {\n                    current_char_clone = string_iter.next();\n          \
    \          current_substring_char_clone = substring_iter.next();\n           \
    \     } else {\n                    break;\n                }\n            }\n\
    \            if current_substring_char_clone.is_none() {\n                count\
    \ += 1;\n                current_substring_char = substring.chars().next();\n\
    \            }\n        }\n        current_char = string_iter.next();\n    }\n\
    \    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010959
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let string_len = string.len();\n\
    \    let substring_len = substring.len();\n    while index < string_len {\n  \
    \      let sub_index = string[index..].find(&substring);\n        if sub_index.is_none()\
    \ {\n            break;\n        }\n        count += 1;\n        index += sub_index.unwrap()\
    \ + substring_len;\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp8lbh1jjb.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010959
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let mut string = string;\n\
    \    let substring = substring;\n    while index < string.len() {\n        let\
    \ index_of_substring = string.find(&substring);\n        if index_of_substring\
    \ == None {\n            break;\n        }\n        count += 1;\n        index\
    \ = index_of_substring.unwrap() + 1;\n        string = string[index..].to_string();\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `4`', /tmp/tmpj6cv9ksj.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010959
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut start = 0;\n    let mut end = substring.len();\n\
    \    let mut string_chars = string.chars();\n    let mut substring_chars = substring.chars();\n\
    \    let mut string_chars_iter = string_chars.by_ref();\n    let mut substring_chars_iter\
    \ = substring_chars.by_ref();\n    while let Some(string_char) = string_chars_iter.next()\
    \ {\n        if string_char == substring_chars_iter.next().unwrap() {\n      \
    \      if substring_chars_iter.clone().count() == 0 {\n                count +=\
    \ 1;\n                substring_chars_iter = substring_chars.by_ref();\n     \
    \       }\n        } else {\n            substring_chars_iter = substring_chars.by_ref();\n\
    \        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''called `Option::unwrap()` on a `None` value'',
    /tmp/tmp1dk5m6uk.rs:17:55

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010960
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let string_len = string.len();\n\
    \    let substring_len = substring.len();\n    while index < string_len {\n  \
    \      if string[index..].starts_with(&substring) {\n            count += 1;\n\
    \            index += substring_len;\n        } else {\n            index += 1;\n\
    \        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp41mhz9rt.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010959
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut start = 0;\n    let mut end = substring.len();\n\
    \    while end <= string.len() {\n        if string[start..end] == substring {\n\
    \            count += 1;\n        }\n        start += 1;\n        end += 1;\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010959
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let string_len = string.len();\n\
    \    let substring_len = substring.len();\n    while index < string_len {\n  \
    \      if string.get(index..index + substring_len) == Some(&substring) {\n   \
    \         count += 1;\n            index += substring_len;\n        } else {\n\
    \            index += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let\
    \ candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp2tz73h3v.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010959
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let mut string = string;\n\
    \    while index < string.len() {\n        if string.starts_with(&substring) {\n\
    \            count += 1;\n            string = string.chars().skip(substring.len()).collect();\n\
    \        } else {\n            string = string.chars().skip(1).collect();\n  \
    \      }\n        index += 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpmdmvx_un.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010959
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let string_len = string.len();\n\
    \    let substring_len = substring.len();\n    while index < string_len {\n  \
    \      let slice = &string[index..];\n        if slice.starts_with(&substring)\
    \ {\n            count += 1;\n            index += substring_len;\n        } else\
    \ {\n            index += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpx_n8h_l9.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010959
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    while index < string.len()\
    \ {\n        let found = string[index..].find(&substring);\n        if found.is_none()\
    \ {\n            break;\n        }\n        count += 1;\n        index += found.unwrap()\
    \ + substring.len();\n    }\n    count\n}\n\nfn main() {\n    let candidate =\
    \ how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmptny1i13d.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010959
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    while index < string.len()\
    \ {\n        let found = string[index..].find(&substring);\n        if found.is_none()\
    \ {\n            break;\n        }\n        count += 1;\n        index += found.unwrap()\
    \ + substring.len();\n    }\n    count\n}\n\nfn main() {\n    let candidate =\
    \ how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmptny1i13d.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010959
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut i = 0;\n    let mut j = 0;\n    let mut string_chars\
    \ = string.chars();\n    let mut substring_chars = substring.chars();\n    while\
    \ let Some(string_char) = string_chars.next() {\n        if string_char == substring_chars.next().unwrap()\
    \ {\n            j += 1;\n            if j == substring.len() {\n            \
    \    count += 1;\n                i += j;\n                j = 0;\n          \
    \      string_chars = string.chars().skip(i);\n                substring_chars\
    \ = substring.chars();\n            }\n        } else {\n            i += 1;\n\
    \            string_chars = string.chars().skip(i);\n            substring_chars\
    \ = substring.chars();\n            j = 0;\n        }\n    }\n    count\n}\n\n\
    fn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptbt_8u88.rs:21:32\n   |\n\
    12 |     let mut string_chars = string.chars();\n   |                        \
    \    -------------- expected due to this value\n...\n21 |                 string_chars\
    \ = string.chars().skip(i);\n   |                                ^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `Chars`, found struct `Skip`\n   |\n   = note: expected struct\
    \ `Chars<'_>`\n              found struct `Skip<Chars<'_>>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmptbt_8u88.rs:26:28\n   |\n12 |     let mut string_chars\
    \ = string.chars();\n   |                            -------------- expected due\
    \ to this value\n...\n26 |             string_chars = string.chars().skip(i);\n\
    \   |                            ^^^^^^^^^^^^^^^^^^^^^^ expected struct `Chars`,\
    \ found struct `Skip`\n   |\n   = note: expected struct `Chars<'_>`\n        \
    \      found struct `Skip<Chars<'_>>`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010959
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    while index < string.len()\
    \ {\n        if let Some(i) = string[index..].find(&substring) {\n           \
    \ count += 1;\n            index += i + substring.len();\n        } else {\n \
    \           break;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpu0b0_mcy.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010959
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut start = 0;\n    let mut end = substring.len();\n\
    \    while end <= string.len() {\n        if string[start..end] == substring {\n\
    \            count += 1;\n        }\n        start += 1;\n        end += 1;\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010959
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let string_len = string.len();\n\
    \    let substring_len = substring.len();\n    while index < string_len {\n  \
    \      if string[index..].starts_with(&substring) {\n            count += 1;\n\
    \            index += substring_len;\n        } else {\n            index += 1;\n\
    \        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp41mhz9rt.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010959
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut current_index = 0;\n    let mut current_substring_index\
    \ = 0;\n    let string_chars: Vec<char> = string.chars().collect();\n    let substring_chars:\
    \ Vec<char> = substring.chars().collect();\n    while current_index < string_chars.len()\
    \ {\n        if string_chars[current_index] == substring_chars[current_substring_index]\
    \ {\n            current_substring_index += 1;\n            if current_substring_index\
    \ == substring_chars.len() {\n                count += 1;\n                current_substring_index\
    \ = 0;\n            }\n        } else {\n            current_substring_index =\
    \ 0;\n        }\n        current_index += 1;\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmptho_cfpz.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010960
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    while index < string.len()\
    \ {\n        if let Some(i) = string[index..].find(&substring) {\n           \
    \ count += 1;\n            index += i + substring.len();\n        } else {\n \
    \           break;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpu0b0_mcy.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010959
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let mut string = string;\n\
    \    let substring_len = substring.len();\n    while index != -1 {\n        index\
    \ = string.find(&substring).unwrap_or(-1);\n        if index != -1 {\n       \
    \     count += 1;\n            string = string[index + substring_len..].to_string();\n\
    \        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0600]: cannot apply unary operator `-` to type `usize`\n  --> /tmp/tmpdsidc11s.rs:14:51\n\
    \   |\n14 |         index = string.find(&substring).unwrap_or(-1);\n   |     \
    \                                              ^^\n   |                      \
    \                             |\n   |                                        \
    \           cannot apply unary operator `-`\n   |                            \
    \                       help: you may have meant the maximum value of `usize`:\
    \ `usize::MAX`\n   |\n   = note: unsigned values cannot be negated\n\nerror[E0277]:\
    \ the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpdsidc11s.rs:13:20\n\
    \   |\n13 |     while index != -1 {\n   |                    ^^ the trait `Neg`\
    \ is not implemented for `usize`\n   |\n   = help: the following other types implement\
    \ trait `Neg`:\n             &f32\n             &f64\n             &i128\n   \
    \          &i16\n             &i32\n             &i64\n             &i8\n    \
    \         &isize\n           and 8 others\n\nerror[E0600]: cannot apply unary\
    \ operator `-` to type `usize`\n  --> /tmp/tmpdsidc11s.rs:15:21\n   |\n15 |  \
    \       if index != -1 {\n   |                     ^^\n   |                  \
    \   |\n   |                     cannot apply unary operator `-`\n   |        \
    \             help: you may have meant the maximum value of `usize`: `usize::MAX`\n\
    \   |\n   = note: unsigned values cannot be negated\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0600.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010959
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut start = 0;\n    let mut end = substring.len();\n\
    \    while end <= string.len() {\n        if string[start..end] == substring {\n\
    \            count += 1;\n        }\n        start += 1;\n        end += 1;\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010959
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let mut string_chars = string.chars();\n\
    \    let substring_chars = substring.chars();\n    loop {\n        match string_chars.nth(index)\
    \ {\n            Some(c) => {\n                if c == substring_chars.next().unwrap()\
    \ {\n                    let mut i = index + 1;\n                    let mut sub_chars\
    \ = substring_chars.clone();\n                    loop {\n                   \
    \     match string_chars.nth(i) {\n                            Some(c) => {\n\
    \                                if c == sub_chars.next().unwrap() {\n       \
    \                             i += 1;\n                                } else\
    \ {\n                                    break;\n                            \
    \    }\n                            }\n                            None => break,\n\
    \                        }\n                    }\n                    if sub_chars.next()\
    \ == None {\n                        count += 1;\n                    }\n    \
    \            }\n                index += 1;\n            }\n            None =>\
    \ break,\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `substring_chars` as mutable, as it is not\
    \ declared as mutable\n  --> /tmp/tmp5kugpyqa.rs:16:25\n   |\n12 |     let substring_chars\
    \ = substring.chars();\n   |         --------------- help: consider changing this\
    \ to be mutable: `mut substring_chars`\n...\n16 |                 if c == substring_chars.next().unwrap()\
    \ {\n   |                         ^^^^^^^^^^^^^^^^^^^^^^ cannot borrow as mutable\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1660010959
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut start = 0;\n    let mut end = substring.len();\n\
    \    while end <= string.len() {\n        if &string[start..end] == substring\
    \ {\n            count += 1;\n        }\n        start += 1;\n        end += 1;\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010959
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let mut string = string;\n\
    \    while index < string.len() {\n        let index = string.find(&substring);\n\
    \        if index.is_none() {\n            break;\n        }\n        count +=\
    \ 1;\n        string = string.split_off(index.unwrap() + substring.len());\n \
    \   }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp8rgwluth.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010960
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let mut string_chars = string.chars();\n\
    \    let substring_chars = substring.chars();\n    let mut substring_iter = substring_chars.clone();\n\
    \    let mut substring_first_char = substring_iter.next();\n    let mut string_first_char\
    \ = string_chars.next();\n    loop {\n        if substring_first_char == string_first_char\
    \ {\n            let mut substring_iter = substring_chars.clone();\n         \
    \   let mut string_iter = string_chars.clone();\n            let mut substring_char\
    \ = substring_iter.next();\n            let mut string_char = string_iter.next();\n\
    \            loop {\n                if substring_char == string_char {\n    \
    \                substring_char = substring_iter.next();\n                   \
    \ string_char = string_iter.next();\n                    if substring_char ==\
    \ None {\n                        count += 1;\n                        break;\n\
    \                    }\n                } else {\n                    break;\n\
    \                }\n            }\n        }\n        string_first_char = string_chars.next();\n\
    \        if string_first_char == None {\n            break;\n        }\n     \
    \   index += 1;\n        let mut string_chars = string.chars();\n        for _\
    \ in 0..index {\n            string_chars.next();\n        }\n        string_first_char\
    \ = string_chars.next();\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmppks9v6ww.rs:52:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010960
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let mut string_chars = string.chars();\n\
    \    let substring_chars = substring.chars();\n    loop {\n        match string_chars.nth(index)\
    \ {\n            Some(c) => {\n                if c == substring_chars.nth(0).unwrap()\
    \ {\n                    let mut i = 0;\n                    let mut string_chars_clone\
    \ = string_chars.clone();\n                    let mut substring_chars_clone =\
    \ substring_chars.clone();\n                    loop {\n                     \
    \   match substring_chars_clone.nth(i) {\n                            Some(c)\
    \ => {\n                                match string_chars_clone.nth(i) {\n  \
    \                                  Some(c2) => {\n                           \
    \             if c != c2 {\n                                            break;\n\
    \                                        }\n                                 \
    \   }\n                                    None => break,\n                  \
    \              }\n                            }\n                            None\
    \ => {\n                                count += 1;\n                        \
    \        index += 1;\n                                break;\n               \
    \             }\n                        }\n                        i += 1;\n\
    \                    }\n                }\n            }\n            None =>\
    \ break,\n        }\n        index += 1;\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `substring_chars` as mutable, as it is not\
    \ declared as mutable\n  --> /tmp/tmp8n5urxb3.rs:16:25\n   |\n12 |     let substring_chars\
    \ = substring.chars();\n   |         --------------- help: consider changing this\
    \ to be mutable: `mut substring_chars`\n...\n16 |                 if c == substring_chars.nth(0).unwrap()\
    \ {\n   |                         ^^^^^^^^^^^^^^^^^^^^^^ cannot borrow as mutable\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1660010959
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let string_len = string.len();\n\
    \    let substring_len = substring.len();\n    while index < string_len {\n  \
    \      let slice = &string[index..];\n        if slice.starts_with(&substring)\
    \ {\n            count += 1;\n            index += substring_len;\n        } else\
    \ {\n            index += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpx_n8h_l9.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010959
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut start = 0;\n    while let Some(index) = string[start..].find(&substring)\
    \ {\n        count += 1;\n        start = start + index + 1;\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010959
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    while index < string.len()\
    \ {\n        let mut i = index;\n        let mut j = 0;\n        while i < string.len()\
    \ && j < substring.len() && string.chars().nth(i) == substring.chars().nth(j)\
    \ {\n            i += 1;\n            j += 1;\n        }\n        if j == substring.len()\
    \ {\n            count += 1;\n        }\n        index += 1;\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010959
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    while index < string.len()\
    \ {\n        let slice = &string[index..];\n        if slice.starts_with(&substring)\
    \ {\n            count += 1;\n            index += substring.len();\n        }\
    \ else {\n            index += 1;\n        }\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp4p3ho821.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010960
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let string_len = string.len();\n\
    \    let substring_len = substring.len();\n    while index < string_len {\n  \
    \      let slice = &string[index..];\n        if slice.starts_with(&substring)\
    \ {\n            count += 1;\n            index += substring_len;\n        } else\
    \ {\n            index += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpx_n8h_l9.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010959
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let string_len = string.len();\n\
    \    let substring_len = substring.len();\n    while index < string_len {\n  \
    \      if &string[index..index + substring_len] == substring {\n            count\
    \ += 1;\n            index += substring_len;\n        } else {\n            index\
    \ += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''byte index 10 is out of bounds of `cacacacac`'',
    library/core/src/str/mod.rs:107:9

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010958
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let string_len = string.len();\n\
    \    let substring_len = substring.len();\n    while index < string_len {\n  \
    \      let slice = &string[index..];\n        if slice.starts_with(&substring)\
    \ {\n            count += 1;\n            index += substring_len;\n        } else\
    \ {\n            index += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpx_n8h_l9.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010959
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let string_len = string.len();\n\
    \    let substring_len = substring.len();\n    while index < string_len {\n  \
    \      if &string[index..index + substring_len] == substring {\n            count\
    \ += 1;\n            index += substring_len;\n        } else {\n            index\
    \ += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''byte index 10 is out of bounds of `cacacacac`'',
    library/core/src/str/mod.rs:107:9

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010958
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let string_len = string.len();\n\
    \    let substring_len = substring.len();\n    while index < string_len {\n  \
    \      let slice = &string[index..];\n        if slice.starts_with(&substring)\
    \ {\n            count += 1;\n            index += substring_len;\n        } else\
    \ {\n            index += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpx_n8h_l9.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010959
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let mut string = string;\n\
    \    while index < string.len() {\n        let index_opt = string.find(&substring);\n\
    \        if index_opt.is_none() {\n            break;\n        }\n        let\
    \ index = index_opt.unwrap();\n        count += 1;\n        string = string[index\
    \ + substring.len()..].to_string();\n    }\n    count\n}\n\nfn main() {\n    let\
    \ candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpyht_nkb3.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010960
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut start = 0;\n    let mut end = substring.len();\n\
    \    while end <= string.len() {\n        if string[start..end] == substring {\n\
    \            count += 1;\n        }\n        start += 1;\n        end += 1;\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010959
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut i = 0;\n    let mut j = 0;\n    let mut string_chars\
    \ = string.chars();\n    let mut substring_chars = substring.chars();\n    let\
    \ mut string_char = string_chars.next();\n    let mut substring_char = substring_chars.next();\n\
    \    while let Some(s) = string_char {\n        if s == substring_char.unwrap()\
    \ {\n            i += 1;\n            j += 1;\n            if i == substring.len()\
    \ {\n                count += 1;\n                i = 0;\n                j =\
    \ 0;\n                substring_chars = substring.chars();\n                substring_char\
    \ = substring_chars.next();\n            }\n        } else {\n            i =\
    \ 0;\n            j += 1;\n            substring_chars = substring.chars();\n\
    \            substring_char = substring_chars.next();\n        }\n        string_char\
    \ = string_chars.nth(j);\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpmv5_a_nq.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010960
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let mut string = string;\n\
    \    while index < string.len() {\n        if string.starts_with(&substring) {\n\
    \            count += 1;\n            string = string.chars().skip(substring.len()).collect();\n\
    \        } else {\n            string = string.chars().skip(1).collect();\n  \
    \      }\n        index += 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpmdmvx_un.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010959
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    while index != -1 {\n    \
    \    index = string.find(&substring);\n        if index != -1 {\n            count\
    \ += 1;\n            string.drain(..index + substring.len());\n        }\n   \
    \ }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_3nofyeu.rs:12:17\n   |\n\
    10 |     let mut index = 0;\n   |                     - expected due to this value\n\
    11 |     while index != -1 {\n12 |         index = string.find(&substring);\n\
    \   |                 ^^^^^^^^^^^^^^^^^^^^^^^ expected integer, found enum `Option`\n\
    \   |\n   = note: expected type `{integer}`\n              found enum `Option<usize>`\n\
    \nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmp_3nofyeu.rs:11:20\n\
    \   |\n11 |     while index != -1 {\n   |                    ^^ the trait `Neg`\
    \ is not implemented for `usize`\n   |\n   = help: the following other types implement\
    \ trait `Neg`:\n             &f32\n             &f64\n             &i128\n   \
    \          &i16\n             &i32\n             &i64\n             &i8\n    \
    \         &isize\n           and 8 others\n\nerror[E0277]: the trait bound `usize:\
    \ Neg` is not satisfied\n  --> /tmp/tmp_3nofyeu.rs:13:21\n   |\n13 |         if\
    \ index != -1 {\n   |                     ^^ the trait `Neg` is not implemented\
    \ for `usize`\n   |\n   = help: the following other types implement trait `Neg`:\n\
    \             &f32\n             &f64\n             &i128\n             &i16\n\
    \             &i32\n             &i64\n             &i8\n             &isize\n\
    \           and 8 others\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010959
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut start = 0;\n    let mut end = substring.len();\n\
    \    while end <= string.len() {\n        if &string[start..end] == substring\
    \ {\n            count += 1;\n        }\n        start += 1;\n        end += 1;\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010959
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    while index < string.len()\
    \ {\n        if string[index..].starts_with(&substring) {\n            count +=\
    \ 1;\n            index += substring.len();\n        } else {\n            index\
    \ += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp3oebdd3d.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010959
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let string_len = string.len();\n\
    \    let substring_len = substring.len();\n    while index < string_len {\n  \
    \      let mut i = 0;\n        while i < substring_len && index + i < string_len\
    \ && string.chars().nth(index + i) == substring.chars().nth(i) {\n           \
    \ i += 1;\n        }\n        if i == substring_len {\n            count += 1;\n\
    \            index += i;\n        } else {\n            index += 1;\n        }\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpiod_tsen.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010958
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut i = 0;\n    let len = substring.len();\n \
    \   while i < string.len() {\n        if string[i..].starts_with(&substring) {\n\
    \            count += 1;\n            i += len;\n        } else {\n          \
    \  i += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate =\
    \ how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpzlm0y2ju.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010960
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let string_len = string.len();\n\
    \    let substring_len = substring.len();\n    while index < string_len {\n  \
    \      if &string[index..index + substring_len] == substring {\n            count\
    \ += 1;\n            index += substring_len;\n        } else {\n            index\
    \ += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''byte index 10 is out of bounds of `cacacacac`'',
    library/core/src/str/mod.rs:107:9

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010958
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let string_len = string.len();\n\
    \    let substring_len = substring.len();\n    while index < string_len {\n  \
    \      if string[index..].starts_with(&substring) {\n            count += 1;\n\
    \            index += substring_len;\n        } else {\n            index += 1;\n\
    \        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp41mhz9rt.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010959
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    while index < string.len()\
    \ {\n        let mut found = false;\n        for (i, c) in substring.chars().enumerate()\
    \ {\n            if index + i >= string.len() {\n                break;\n    \
    \        }\n            if string.chars().nth(index + i).unwrap() == c {\n   \
    \             found = true;\n            } else {\n                found = false;\n\
    \                break;\n            }\n        }\n        if found {\n      \
    \      count += 1;\n            index += substring.len();\n        } else {\n\
    \            index += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let\
    \ candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `4`', /tmp/tmpxqr4a8tl.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010960
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    while index < string.len()\
    \ {\n        if let Some(i) = string[index..].find(&substring) {\n           \
    \ count += 1;\n            index += i + substring.len();\n        } else {\n \
    \           break;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpu0b0_mcy.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010959
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut i = 0;\n    let mut j = 0;\n    let mut string_chars\
    \ = string.chars();\n    let mut substring_chars = substring.chars();\n    loop\
    \ {\n        if let Some(c) = string_chars.next() {\n            if c == substring_chars.nth(j).unwrap()\
    \ {\n                j += 1;\n                if j == substring.len() {\n    \
    \                count += 1;\n                    j = 0;\n                }\n\
    \            } else {\n                j = 0;\n            }\n            i +=\
    \ 1;\n        } else {\n            break;\n        }\n    }\n    count\n}\n\n\
    fn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''called `Option::unwrap()` on a `None` value'',
    /tmp/tmpzyyoxn4z.rs:16:44

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010960
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let mut string_chars = string.chars();\n\
    \    let substring_chars = substring.chars();\n    while let Some(c) = string_chars.nth(index)\
    \ {\n        if c == substring_chars.clone().next().unwrap() {\n            let\
    \ mut i = 0;\n            let mut string_chars_clone = string_chars.clone();\n\
    \            for s in substring_chars {\n                if s != string_chars_clone.next().unwrap()\
    \ {\n                    break;\n                }\n                i += 1;\n\
    \            }\n            if i == substring.len() {\n                count +=\
    \ 1;\n                index += i - 1;\n            }\n        }\n        index\
    \ += 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `substring_chars`\n   --> /tmp/tmp8b5yu8vq.rs:14:17\n\
    \    |\n12  |     let substring_chars = substring.chars();\n    |         ---------------\
    \ move occurs because `substring_chars` has type `Chars<'_>`, which does not implement\
    \ the `Copy` trait\n13  |     while let Some(c) = string_chars.nth(index) {\n\
    14  |         if c == substring_chars.clone().next().unwrap() {\n    |       \
    \          ^^^^^^^^^^^^^^^^^^^^^^^ value borrowed here after move\n...\n17  |\
    \             for s in substring_chars {\n    |                      ---------------\
    \ `substring_chars` moved due to this implicit call to `.into_iter()`, in previous\
    \ iteration of loop\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `substring_chars`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660010959
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut i = 0;\n    let string_len = string.len();\n\
    \    let substring_len = substring.len();\n    while i < string_len {\n      \
    \  if &string[i..i + substring_len] == substring {\n            count += 1;\n\
    \            i += substring_len;\n        } else {\n            i += 1;\n    \
    \    }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''byte index 10 is out of bounds of `cacacacac`'',
    library/core/src/str/mod.rs:107:9

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010960
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut start = 0;\n    let mut end = substring.len();\n\
    \    while end <= string.len() {\n        if string[start..end] == substring {\n\
    \            count += 1;\n        }\n        start += 1;\n        end += 1;\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010959
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let string_len = string.len();\n\
    \    let substring_len = substring.len();\n    while index < string_len {\n  \
    \      if string[index..].starts_with(&substring) {\n            count += 1;\n\
    \            index += substring_len;\n        } else {\n            index += 1;\n\
    \        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp41mhz9rt.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010959
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let mut string = string;\n\
    \    while index != -1 {\n        index = string.find(&substring).unwrap_or(-1);\n\
    \        if index != -1 {\n            count += 1;\n            string = string[index\
    \ + 1..].to_string();\n        }\n    }\n    count\n}\n\nfn main() {\n    let\
    \ candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0600]: cannot apply unary operator `-` to type `usize`\n  --> /tmp/tmpz98fp9aq.rs:13:51\n\
    \   |\n13 |         index = string.find(&substring).unwrap_or(-1);\n   |     \
    \                                              ^^\n   |                      \
    \                             |\n   |                                        \
    \           cannot apply unary operator `-`\n   |                            \
    \                       help: you may have meant the maximum value of `usize`:\
    \ `usize::MAX`\n   |\n   = note: unsigned values cannot be negated\n\nerror[E0277]:\
    \ the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpz98fp9aq.rs:12:20\n\
    \   |\n12 |     while index != -1 {\n   |                    ^^ the trait `Neg`\
    \ is not implemented for `usize`\n   |\n   = help: the following other types implement\
    \ trait `Neg`:\n             &f32\n             &f64\n             &i128\n   \
    \          &i16\n             &i32\n             &i64\n             &i8\n    \
    \         &isize\n           and 8 others\n\nerror[E0600]: cannot apply unary\
    \ operator `-` to type `usize`\n  --> /tmp/tmpz98fp9aq.rs:14:21\n   |\n14 |  \
    \       if index != -1 {\n   |                     ^^\n   |                  \
    \   |\n   |                     cannot apply unary operator `-`\n   |        \
    \             help: you may have meant the maximum value of `usize`: `usize::MAX`\n\
    \   |\n   = note: unsigned values cannot be negated\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0600.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010959
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let mut string_chars = string.chars();\n\
    \    let substring_chars = substring.chars();\n    let mut substring_chars_iter\
    \ = substring_chars.clone();\n    let mut substring_chars_iter_next = substring_chars_iter.next();\n\
    \    while let Some(string_char) = string_chars.next() {\n        if let Some(substring_char)\
    \ = substring_chars_iter_next {\n            if string_char == substring_char\
    \ {\n                substring_chars_iter_next = substring_chars_iter.next();\n\
    \                if substring_chars_iter_next.is_none() {\n                  \
    \  count += 1;\n                    substring_chars_iter = substring_chars.clone();\n\
    \                    substring_chars_iter_next = substring_chars_iter.next();\n\
    \                }\n            } else {\n                substring_chars_iter\
    \ = substring_chars.clone();\n                substring_chars_iter_next = substring_chars_iter.next();\n\
    \            }\n        }\n        index += 1;\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpndp8pr_c.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010960
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    while index < string.len()\
    \ {\n        if let Some(i) = string[index..].find(&substring) {\n           \
    \ count += 1;\n            index += i + substring.len();\n        } else {\n \
    \           break;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpu0b0_mcy.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010959
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let string_len = string.len();\n\
    \    let substring_len = substring.len();\n    while index < string_len {\n  \
    \      if &string[index..index + substring_len] == substring {\n            count\
    \ += 1;\n            index += substring_len;\n        } else {\n            index\
    \ += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''byte index 10 is out of bounds of `cacacacac`'',
    library/core/src/str/mod.rs:107:9

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010958
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    while index < string.len()\
    \ {\n        let mut found = false;\n        for (i, c) in substring.chars().enumerate()\
    \ {\n            if index + i >= string.len() {\n                break;\n    \
    \        }\n            if string.chars().nth(index + i).unwrap() == c {\n   \
    \             found = true;\n            } else {\n                found = false;\n\
    \                break;\n            }\n        }\n        if found {\n      \
    \      count += 1;\n            index += substring.len();\n        } else {\n\
    \            index += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let\
    \ candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `4`', /tmp/tmpxqr4a8tl.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010960
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let mut string_chars = string.chars();\n\
    \    let substring_chars = substring.chars();\n    let mut substring_iter = substring_chars.clone();\n\
    \    let mut substring_iter_clone = substring_chars.clone();\n    let mut substring_iter_clone_clone\
    \ = substring_chars.clone();\n    let mut substring_iter_clone_clone_clone = substring_chars.clone();\n\
    \    let mut substring_iter_clone_clone_clone_clone = substring_chars.clone();\n\
    \    let mut substring_iter_clone_clone_clone_clone_clone = substring_chars.clone();\n\
    \    let mut substring_iter_clone_clone_clone_clone_clone_clone = substring_chars.clone();\n\
    \    let mut substring_iter_clone_clone_clone_clone_clone_clone_clone = substring_chars.clone();\n\
    \    let mut substring_iter_clone_clone_clone_clone_clone_clone_clone_clone =\
    \ substring_chars.clone();\n    let mut substring_iter_clone_clone_clone_clone_clone_clone_clone_clone_clone\
    \ = substring_chars.clone();\n    let mut substring_iter_clone_clone_clone_clone_clone_clone_clone_clone_clone_clone\
    \ = substring_chars.clone();\n    let mut substring_iter_clone_clone_clone_clone_clone_clone_clone_clone_clone_clone_clone\
    \ = substring_chars.clone();\n    let mut substring_iter_clone_clone_clone_clone_clone_clone_clone_clone_clone_clone_clone_clone\
    \ = substring_chars.clone();\n    let mut substring_iter_clone_clone_clone_clone_clone_clone_clone_clone_clone_clone_clone_clone_clone\
    \ = substring_chars.clone();\n    let mut substring_iter_clone_clone_clone_clone_clone_clone_clone_clone_clone_clone_clone_clone_clone_clone\
    \ = substring_chars.clone();\n   \n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpy2xbz676.rs:8:57\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |    --------------\
    \                                       ^^^^^ expected `isize`, found `()`\n \
    \ |    |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010959
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut start = 0;\n    let mut end = substring.len();\n\
    \    while end <= string.len() {\n        if string[start..end] == substring {\n\
    \            count += 1;\n        }\n        start += 1;\n        end += 1;\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010959
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut i = 0;\n    let mut j = 0;\n    let mut string_chars\
    \ = string.chars();\n    let mut substring_chars = substring.chars();\n    let\
    \ mut string_char = string_chars.next();\n    let mut substring_char = substring_chars.next();\n\
    \    while string_char.is_some() {\n        if string_char == substring_char {\n\
    \            i += 1;\n            j += 1;\n            string_char = string_chars.next();\n\
    \            substring_char = substring_chars.next();\n        } else {\n    \
    \        i += 1;\n            j = 0;\n            string_char = string_chars.next();\n\
    \            substring_chars = substring.chars();\n            substring_char\
    \ = substring_chars.next();\n        }\n        if substring_char.is_none() {\n\
    \            count += 1;\n            substring_chars = substring.chars();\n \
    \           substring_char = substring_chars.next();\n        }\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpfs_87uoz.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010960
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    while index < string.len()\
    \ {\n        let mut i = index;\n        let mut j = 0;\n        while i < string.len()\
    \ && j < substring.len() && string.chars().nth(i) == substring.chars().nth(j)\
    \ {\n            i += 1;\n            j += 1;\n        }\n        if j == substring.len()\
    \ {\n            count += 1;\n        }\n        index += 1;\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010959
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut last_index = 0;\n    while last_index != -1\
    \ {\n        last_index = string.find(substring.as_str()).unwrap_or(-1);\n   \
    \     if last_index != -1 {\n            count += 1;\n            string.drain(0..last_index\
    \ + substring.len());\n        }\n    }\n    count\n}\n\nfn main() {\n    let\
    \ candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0600]: cannot apply unary operator `-` to type `usize`\n  --> /tmp/tmpdteqrwvu.rs:12:64\n\
    \   |\n12 |         last_index = string.find(substring.as_str()).unwrap_or(-1);\n\
    \   |                                                                ^^\n   |\
    \                                                                |\n   |     \
    \                                                           cannot apply unary\
    \ operator `-`\n   |                                                         \
    \       help: you may have meant the maximum value of `usize`: `usize::MAX`\n\
    \   |\n   = note: unsigned values cannot be negated\n\nerror[E0277]: the trait\
    \ bound `usize: Neg` is not satisfied\n  --> /tmp/tmpdteqrwvu.rs:11:25\n   |\n\
    11 |     while last_index != -1 {\n   |                         ^^ the trait `Neg`\
    \ is not implemented for `usize`\n   |\n   = help: the following other types implement\
    \ trait `Neg`:\n             &f32\n             &f64\n             &i128\n   \
    \          &i16\n             &i32\n             &i64\n             &i8\n    \
    \         &isize\n           and 8 others\n\nerror[E0600]: cannot apply unary\
    \ operator `-` to type `usize`\n  --> /tmp/tmpdteqrwvu.rs:13:26\n   |\n13 |  \
    \       if last_index != -1 {\n   |                          ^^\n   |        \
    \                  |\n   |                          cannot apply unary operator\
    \ `-`\n   |                          help: you may have meant the maximum value\
    \ of `usize`: `usize::MAX`\n   |\n   = note: unsigned values cannot be negated\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0600.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010959
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    while index < string.len()\
    \ {\n        if let Some(i) = string[index..].find(&substring) {\n           \
    \ count += 1;\n            index += i + substring.len();\n        } else {\n \
    \           break;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpu0b0_mcy.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010959
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut start = 0;\n    let mut end = substring.len();\n\
    \    let len = string.len();\n    while end <= len {\n        if &string[start..end]\
    \ == substring {\n            count += 1;\n            start += 1;\n         \
    \   end += 1;\n        } else {\n            start += 1;\n            end += 1;\n\
    \        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010960
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let string_len = string.len();\n\
    \    let substring_len = substring.len();\n    while index < string_len {\n  \
    \      if &string[index..index + substring_len] == substring {\n            count\
    \ += 1;\n            index += substring_len;\n        } else {\n            index\
    \ += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''byte index 10 is out of bounds of `cacacacac`'',
    library/core/src/str/mod.rs:107:9

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010958
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let string_len = string.len();\n\
    \    let substring_len = substring.len();\n    while index < string_len {\n  \
    \      let slice = &string[index..];\n        if slice.starts_with(&substring)\
    \ {\n            count += 1;\n            index += substring_len;\n        } else\
    \ {\n            index += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpx_n8h_l9.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010959
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let mut string = string;\n\
    \    let substring = substring;\n    while index < string.len() {\n        if\
    \ let Some(i) = string.find(&substring) {\n            count += 1;\n         \
    \   string = string.chars().skip(i + substring.len()).collect();\n        } else\
    \ {\n            break;\n        }\n    }\n    count\n}\n\nfn main() {\n    let\
    \ candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpwb5p_1h6.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010960
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    while index < string.len()\
    \ {\n        let mut i = index;\n        let mut j = 0;\n        while i < string.len()\
    \ && j < substring.len() && string.chars().nth(i) == substring.chars().nth(j)\
    \ {\n            i += 1;\n            j += 1;\n        }\n        if j == substring.len()\
    \ {\n            count += 1;\n        }\n        index += 1;\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010959
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let string_len = string.len();\n\
    \    let substring_len = substring.len();\n    while index < string_len {\n  \
    \      if string[index..].starts_with(&substring) {\n            count += 1;\n\
    \            index += substring_len;\n        } else {\n            index += 1;\n\
    \        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp41mhz9rt.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010959
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let mut string = string;\n\
    \    while index < string.len() {\n        if let Some(i) = string.find(&substring)\
    \ {\n            count += 1;\n            string = string.split_off(i + substring.len());\n\
    \        } else {\n            break;\n        }\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpivbnwmbh.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010959
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let mut string = string;\n\
    \    let substring = substring;\n    let substring_len = substring.len();\n  \
    \  while index < string.len() {\n        if string.starts_with(&substring) {\n\
    \            count += 1;\n            string = string.chars().skip(substring_len).collect();\n\
    \        } else {\n            string = string.chars().skip(1).collect();\n  \
    \      }\n        index += 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmptlscz4of.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010960
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let mut string = string;\n\
    \    while index < string.len() {\n        if let Some(i) = string.find(&substring)\
    \ {\n            count += 1;\n            string = string.chars().skip(i + substring.len()).collect();\n\
    \        } else {\n            break;\n        }\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpn5o_ug5h.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010960
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    while index < string.len()\
    \ {\n        if let Some(i) = string[index..].find(&substring) {\n           \
    \ count += 1;\n            index += i + substring.len();\n        } else {\n \
    \           break;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpu0b0_mcy.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010959
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let mut string = string;\n\
    \    while index != -1 {\n        index = string.find(&substring).unwrap_or(-1);\n\
    \        if index != -1 {\n            count += 1;\n            string = string[index\
    \ + 1..].to_string();\n        }\n    }\n    count\n}\n\nfn main() {\n    let\
    \ candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0600]: cannot apply unary operator `-` to type `usize`\n  --> /tmp/tmpz98fp9aq.rs:13:51\n\
    \   |\n13 |         index = string.find(&substring).unwrap_or(-1);\n   |     \
    \                                              ^^\n   |                      \
    \                             |\n   |                                        \
    \           cannot apply unary operator `-`\n   |                            \
    \                       help: you may have meant the maximum value of `usize`:\
    \ `usize::MAX`\n   |\n   = note: unsigned values cannot be negated\n\nerror[E0277]:\
    \ the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpz98fp9aq.rs:12:20\n\
    \   |\n12 |     while index != -1 {\n   |                    ^^ the trait `Neg`\
    \ is not implemented for `usize`\n   |\n   = help: the following other types implement\
    \ trait `Neg`:\n             &f32\n             &f64\n             &i128\n   \
    \          &i16\n             &i32\n             &i64\n             &i8\n    \
    \         &isize\n           and 8 others\n\nerror[E0600]: cannot apply unary\
    \ operator `-` to type `usize`\n  --> /tmp/tmpz98fp9aq.rs:14:21\n   |\n14 |  \
    \       if index != -1 {\n   |                     ^^\n   |                  \
    \   |\n   |                     cannot apply unary operator `-`\n   |        \
    \             help: you may have meant the maximum value of `usize`: `usize::MAX`\n\
    \   |\n   = note: unsigned values cannot be negated\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0600.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010959
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let string_len = string.len();\n\
    \    let substring_len = substring.len();\n    while index < string_len {\n  \
    \      let mut i = 0;\n        while i < substring_len && index + i < string_len\
    \ && string.chars().nth(index + i) == substring.chars().nth(i) {\n           \
    \ i += 1;\n        }\n        if i == substring_len {\n            count += 1;\n\
    \            index += i;\n        } else {\n            index += 1;\n        }\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpiod_tsen.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010958
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    while index < string.len()\
    \ {\n        if let Some(i) = string[index..].find(&substring) {\n           \
    \ count += 1;\n            index += i + substring.len();\n        } else {\n \
    \           break;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpu0b0_mcy.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010959
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    while index < string.len()\
    \ {\n        let mut i = 0;\n        while i < substring.len() && index + i <\
    \ string.len() {\n            if string.chars().nth(index + i) != substring.chars().nth(i)\
    \ {\n                break;\n            }\n            i += 1;\n        }\n \
    \       if i == substring.len() {\n            count += 1;\n            index\
    \ += i;\n        } else {\n            index += 1;\n        }\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmprb0hjc65.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010958
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let string_len = string.len();\n\
    \    let substring_len = substring.len();\n    while index < string_len {\n  \
    \      let sub_string = &string[index..index + substring_len];\n        if sub_string\
    \ == substring {\n            count += 1;\n            index += substring_len;\n\
    \        } else {\n            index += 1;\n        }\n    }\n    count\n}\n\n\
    fn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''byte index 10 is out of bounds of `cacacacac`'',
    library/core/src/str/mod.rs:107:9

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010960
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let mut string = string;\n\
    \    let substring = substring;\n    while index < string.len() {\n        if\
    \ let Some(i) = string.find(&substring) {\n            count += 1;\n         \
    \   string = string.split_off(i + substring.len());\n        } else {\n      \
    \      break;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpteqjvy49.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010960
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let string_len = string.len();\n    let substring_len\
    \ = substring.len();\n    let mut i = 0;\n    while i < string_len {\n       \
    \ let mut j = 0;\n        while j < substring_len && i + j < string_len && string.chars().nth(i\
    \ + j).unwrap() == substring.chars().nth(j).unwrap() {\n            j += 1;\n\
    \        }\n        if j == substring_len {\n            count += 1;\n       \
    \     i += j;\n        } else {\n            i += 1;\n        }\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpfaox2pla.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010960
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut start = 0;\n    let mut end = substring.len();\n\
    \    while end <= string.len() {\n        if string[start..end] == substring {\n\
    \            count += 1;\n        }\n        start += 1;\n        end += 1;\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010959
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let mut string = string;\n\
    \    let substring = substring;\n    while index < string.len() {\n        if\
    \ let Some(i) = string.find(&substring) {\n            count += 1;\n         \
    \   string = string.split_off(i + substring.len());\n        } else {\n      \
    \      break;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpteqjvy49.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010960
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut i = 0;\n    let mut j = 0;\n    let mut string_chars\
    \ = string.chars();\n    let mut substring_chars = substring.chars();\n    let\
    \ mut string_char = string_chars.next();\n    let mut substring_char = substring_chars.next();\n\
    \    while let Some(string_char) = string_char {\n        if let Some(substring_char)\
    \ = substring_char {\n            if string_char == substring_char {\n       \
    \         i += 1;\n                j += 1;\n                substring_char = substring_chars.next();\n\
    \            } else {\n                i = 0;\n                j = 0;\n      \
    \          substring_chars = substring.chars();\n                substring_char\
    \ = substring_chars.next();\n            }\n        } else {\n            count\
    \ += 1;\n            i = 0;\n            j = 0;\n            substring_chars =\
    \ substring.chars();\n            substring_char = substring_chars.next();\n \
    \       }\n        string_char = string_chars.next();\n    }\n    count\n}\n\n\
    fn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptysqxq3_.rs:21:34\n   |\n\
    17 |         if let Some(substring_char) = substring_char {\n   |            \
    \         -------------- expected due to the type of this binding\n...\n21 | \
    \                substring_char = substring_chars.next();\n   |              \
    \                    ^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmptysqxq3_.rs:26:34\n   |\n17 |\
    \         if let Some(substring_char) = substring_char {\n   |               \
    \      -------------- expected due to the type of this binding\n...\n26 |    \
    \             substring_char = substring_chars.next();\n   |                 \
    \                 ^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmptysqxq3_.rs:35:23\n   |\n16 |\
    \     while let Some(string_char) = string_char {\n   |                    -----------\
    \ expected due to the type of this binding\n...\n35 |         string_char = string_chars.next();\n\
    \   |                       ^^^^^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<char>`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010960
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut start = 0;\n    while start < string.len()\
    \ {\n        let found = string[start..].find(&substring);\n        if found.is_none()\
    \ {\n            break;\n        }\n        count += 1;\n        start += found.unwrap()\
    \ + substring.len();\n    }\n    count\n}\n\nfn main() {\n    let candidate =\
    \ how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpi8blk_a0.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010960
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let mut string = string;\n\
    \    while index < string.len() {\n        if string.starts_with(&substring) {\n\
    \            count += 1;\n            string = string.chars().skip(substring.len()).collect();\n\
    \        } else {\n            string = string.chars().skip(1).collect();\n  \
    \      }\n        index += 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpmdmvx_un.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010959
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let mut string = string;\n\
    \    let substring = substring;\n    while index < string.len() {\n        let\
    \ index_opt = string.find(&substring);\n        match index_opt {\n          \
    \  Some(index) => {\n                count += 1;\n                string = string[index\
    \ + substring.len()..].to_string();\n            }\n            None => break,\n\
    \        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp89jsy3tg.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010959
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    while index < string.len()\
    \ {\n        if let Some(i) = string[index..].find(&substring) {\n           \
    \ count += 1;\n            index += i + substring.len();\n        } else {\n \
    \           break;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpu0b0_mcy.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010959
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut start_index = 0;\n    let mut index = 0;\n\
    \    while index < string.len() {\n        if &string[index..index + substring.len()]\
    \ == substring {\n            count += 1;\n            start_index = index + substring.len();\n\
    \            index = start_index;\n        } else {\n            index += 1;\n\
    \        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''byte index 10 is out of bounds of `cacacacac`'',
    library/core/src/str/mod.rs:107:9

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010960
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let string_len = string.len();\n\
    \    let substring_len = substring.len();\n    while index < string_len {\n  \
    \      if string[index..].starts_with(&substring) {\n            count += 1;\n\
    \            index += substring_len;\n        } else {\n            index += 1;\n\
    \        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp41mhz9rt.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010959
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut start = 0;\n    let string_len = string.len();\n\
    \    let substring_len = substring.len();\n    while start + substring_len <=\
    \ string_len {\n        if &string[start..start + substring_len] == substring\
    \ {\n            count += 1;\n            start += substring_len;\n        } else\
    \ {\n            start += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpr9njf02l.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010958
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut i = 0;\n    let mut j = 0;\n    let mut string\
    \ = string.chars().collect::<Vec<char>>();\n    let substring = substring.chars().collect::<Vec<char>>();\n\
    \    while i < string.len() {\n        if string[i] == substring[j] {\n      \
    \      j += 1;\n            if j == substring.len() {\n                count +=\
    \ 1;\n                j = 0;\n            }\n        } else {\n            j =\
    \ 0;\n        }\n        i += 1;\n    }\n    count\n}\n\nfn main() {\n    let\
    \ candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmptxr9jh3v.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010960
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    while index < string.len()\
    \ {\n        if string[index..].starts_with(&substring) {\n            count +=\
    \ 1;\n            index += substring.len();\n        } else {\n            index\
    \ += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp3oebdd3d.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010959
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let mut string = string;\n\
    \    while let Some(i) = string.find(&substring) {\n        count += 1;\n    \
    \    index += i + 1;\n        string = string[index..].to_string();\n    }\n \
    \   count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''byte index 4 is out of bounds of `xyx`'',
    library/core/src/str/mod.rs:107:9

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010959
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let string_len = string.len();\n\
    \    let substring_len = substring.len();\n    while index < string_len {\n  \
    \      let slice = &string[index..];\n        if slice.starts_with(&substring)\
    \ {\n            count += 1;\n            index += substring_len;\n        } else\
    \ {\n            index += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpx_n8h_l9.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010959
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    while index < string.len()\
    \ {\n        let sub_index = string[index..].find(&substring);\n        if sub_index.is_none()\
    \ {\n            break;\n        }\n        index += sub_index.unwrap();\n   \
    \     count += 1;\n        index += substring.len();\n    }\n    count\n}\n\n\
    fn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpm_jcm8sk.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010960
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let mut string = string;\n\
    \    let substring = substring;\n    while index < string.len() {\n        if\
    \ string.starts_with(&substring) {\n            count += 1;\n            string\
    \ = string.chars().skip(substring.len()).collect();\n        } else {\n      \
    \      string = string.chars().skip(1).collect();\n        }\n        index +=\
    \ 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp25349b_n.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010959
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let string_len = string.len();\n\
    \    let substring_len = substring.len();\n    let mut string_chars = string.chars();\n\
    \    let mut substring_chars = substring.chars();\n    let mut string_char = string_chars.next();\n\
    \    let mut substring_char = substring_chars.next();\n    while string_char.is_some()\
    \ {\n        if string_char == substring_char {\n            let mut string_chars_clone\
    \ = string_chars.clone();\n            let mut substring_chars_clone = substring_chars.clone();\n\
    \            let mut string_char_clone = string_chars_clone.next();\n        \
    \    let mut substring_char_clone = substring_chars_clone.next();\n          \
    \  let mut string_chars_clone_index = index + 1;\n            let mut substring_chars_clone_index\
    \ = 1;\n            while string_char_clone == substring_char_clone {\n      \
    \          if substring_chars_clone_index == substring_len {\n               \
    \     count += 1;\n                    break;\n                }\n           \
    \     string_char_clone = string_chars_clone.next();\n                substring_char_clone\
    \ = substring_chars_clone.next();\n                string_chars_clone_index +=\
    \ 1;\n                substring_chars_clone_index += 1;\n            }\n     \
    \   }\n        string_char = string_chars.next();\n        substring_char = substring_chars.next();\n\
    \        index += 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate =\
    \ how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmp6j9mrctu.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010960
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut i = 0;\n    while i < string.len() {\n   \
    \     if string[i..].starts_with(&substring) {\n            count += 1;\n    \
    \        i += substring.len();\n        } else {\n            i += 1;\n      \
    \  }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmptxvwynid.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010959
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let mut string_chars = string.chars();\n\
    \    let mut substring_chars = substring.chars();\n    let mut substring_first_char\
    \ = substring_chars.next();\n    let mut substring_second_char = substring_chars.next();\n\
    \    let mut string_char = string_chars.nth(index);\n    while let Some(string_char)\
    \ = string_char {\n        if let Some(substring_first_char) = substring_first_char\
    \ {\n            if string_char == substring_first_char {\n                if\
    \ let Some(substring_second_char) = substring_second_char {\n                \
    \    if let Some(string_second_char) = string_chars.nth(index + 1) {\n       \
    \                 if string_second_char == substring_second_char {\n         \
    \                   count += 1;\n                        }\n                 \
    \   }\n                }\n            }\n        }\n        index += 1;\n    \
    \    string_char = string_chars.nth(index);\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbg1u9kim.rs:29:23\n   |\n\
    16 |     while let Some(string_char) = string_char {\n   |                   \
    \ ----------- expected due to the type of this binding\n...\n29 |         string_char\
    \ = string_chars.nth(index);\n   |                       ^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<char>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010960
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut start = 0;\n    let mut end = substring.len();\n\
    \    let string_len = string.len();\n    let substring_len = substring.len();\n\
    \    while end <= string_len {\n        if string[start..end] == substring {\n\
    \            count += 1;\n            start += 1;\n            end += 1;\n   \
    \     } else {\n            start += 1;\n            end += 1;\n        }\n  \
    \  }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010960
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut start = 0;\n    let mut end = substring.len();\n\
    \    loop {\n        if end > string.len() {\n            break;\n        }\n\
    \        let s = &string[start..end];\n        if s == substring {\n         \
    \   count += 1;\n        }\n        start += 1;\n        end += 1;\n    }\n  \
    \  count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010960
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    while index < string.len()\
    \ {\n        if let Some(i) = string[index..].find(&substring) {\n           \
    \ count += 1;\n            index += i + substring.len();\n        } else {\n \
    \           break;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpu0b0_mcy.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010959
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    while index < string.len()\
    \ {\n        if let Some(i) = string[index..].find(&substring) {\n           \
    \ count += 1;\n            index += i + substring.len();\n        } else {\n \
    \           break;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpu0b0_mcy.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010959
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut start = 0;\n    let mut end = substring.len();\n\
    \    while end <= string.len() {\n        if string[start..end] == substring {\n\
    \            count += 1;\n        }\n        start += 1;\n        end += 1;\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010959
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    while index < string.len()\
    \ {\n        if let Some(i) = string[index..].find(&substring) {\n           \
    \ count += 1;\n            index += i + substring.len();\n        } else {\n \
    \           break;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpu0b0_mcy.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010959
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut i = 0;\n    let string_len = string.len();\n\
    \    let substring_len = substring.len();\n    while i < string_len {\n      \
    \  if string[i..].starts_with(&substring) {\n            count += 1;\n       \
    \     i += substring_len;\n        } else {\n            i += 1;\n        }\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmprtlgp_fm.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010958
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut i = 0;\n    let string_len = string.len();\n\
    \    let substring_len = substring.len();\n    while i < string_len {\n      \
    \  if &string[i..i + substring_len] == substring {\n            count += 1;\n\
    \            i += substring_len;\n        } else {\n            i += 1;\n    \
    \    }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''byte index 10 is out of bounds of `cacacacac`'',
    library/core/src/str/mod.rs:107:9

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010960
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut start = 0;\n    let mut end = substring.len();\n\
    \    let string_len = string.len();\n    let substring_len = substring.len();\n\
    \    while end <= string_len {\n        if string[start..end] == substring {\n\
    \            count += 1;\n            start += 1;\n            end += 1;\n   \
    \     } else {\n            start += 1;\n            end += 1;\n        }\n  \
    \  }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010960
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut i = 0;\n    let mut j = 0;\n    let mut string_chars\
    \ = string.chars();\n    let mut substring_chars = substring.chars();\n    let\
    \ mut string_char = string_chars.next();\n    let mut substring_char = substring_chars.next();\n\
    \    while let Some(c) = string_char {\n        if c == substring_char.unwrap()\
    \ {\n            i += 1;\n            j += 1;\n            string_char = string_chars.next();\n\
    \            substring_char = substring_chars.next();\n            if j == substring.len()\
    \ {\n                count += 1;\n                j = 0;\n                substring_chars\
    \ = substring.chars();\n                substring_char = substring_chars.next();\n\
    \            }\n        } else {\n            i += 1;\n            string_char\
    \ = string_chars.next();\n            substring_chars = substring.chars();\n \
    \           substring_char = substring_chars.next();\n            j = 0;\n   \
    \     }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpyse8w5qz.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010960
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    while index < string.len()\
    \ {\n        let mut found = false;\n        for (i, c) in substring.chars().enumerate()\
    \ {\n            if index + i < string.len() && string.chars().nth(index + i).unwrap()\
    \ == c {\n                found = true;\n            } else {\n              \
    \  found = false;\n                break;\n            }\n        }\n        if\
    \ found {\n            count += 1;\n            index += substring.len();\n  \
    \      } else {\n            index += 1;\n        }\n    }\n    count\n}\n\nfn\
    \ main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpn1bzx9ax.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010960
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let mut string = string;\n\
    \    while index < string.len() {\n        if string.starts_with(&substring) {\n\
    \            count += 1;\n            string = string.chars().skip(substring.len()).collect();\n\
    \        } else {\n            string = string.chars().skip(1).collect();\n  \
    \      }\n        index += 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpmdmvx_un.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010959
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let mut string = string;\n\
    \    while index < string.len() {\n        let index_opt = string.find(&substring);\n\
    \        match index_opt {\n            Some(index) => {\n                count\
    \ += 1;\n                string = string[index + substring.len()..].to_string();\n\
    \            }\n            None => break,\n        }\n    }\n    count\n}\n\n\
    fn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpa7fisj3z.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010960
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let mut string = string;\n\
    \    while let Some(i) = string.find(&substring) {\n        count += 1;\n    \
    \    index += i + 1;\n        string = string[index..].to_string();\n    }\n \
    \   count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''byte index 4 is out of bounds of `xyx`'',
    library/core/src/str/mod.rs:107:9

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010959
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut start = 0;\n    let mut end = substring.len();\n\
    \    let string_len = string.len();\n    let substring_len = substring.len();\n\
    \    while end <= string_len {\n        let slice = &string[start..end];\n   \
    \     if slice == substring {\n            count += 1;\n            start += 1;\n\
    \            end += 1;\n        } else {\n            start += 1;\n          \
    \  end += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010960
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let string_length = string.len();\n\
    \    let substring_length = substring.len();\n    while index < string_length\
    \ {\n        if string[index..].starts_with(&substring) {\n            count +=\
    \ 1;\n            index += substring_length;\n        } else {\n            index\
    \ += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp998j_1vh.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010959
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    while index < string.len()\
    \ {\n        let mut found = false;\n        for (i, c) in substring.chars().enumerate()\
    \ {\n            if index + i >= string.len() {\n                break;\n    \
    \        }\n            if string.chars().nth(index + i).unwrap() == c {\n   \
    \             found = true;\n            } else {\n                found = false;\n\
    \                break;\n            }\n        }\n        if found {\n      \
    \      count += 1;\n            index += substring.len();\n        } else {\n\
    \            index += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let\
    \ candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `4`', /tmp/tmpxqr4a8tl.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010960
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut start = 0;\n    let mut end = substring.len();\n\
    \    while end <= string.len() {\n        if string[start..end] == substring {\n\
    \            count += 1;\n        }\n        start += 1;\n        end += 1;\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010959
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    while index < string.len()\
    \ {\n        if string[index..].starts_with(&substring) {\n            count +=\
    \ 1;\n            index += substring.len();\n        } else {\n            index\
    \ += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp3oebdd3d.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010959
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    while index < string.len()\
    \ {\n        let slice = &string[index..];\n        if slice.starts_with(&substring)\
    \ {\n            count += 1;\n            index += substring.len();\n        }\
    \ else {\n            index += 1;\n        }\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp4p3ho821.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010960
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let mut string = string;\n\
    \    let substring = substring;\n    while index < string.len() {\n        if\
    \ string.starts_with(&substring) {\n            count += 1;\n            string\
    \ = string.chars().skip(substring.len()).collect();\n        } else {\n      \
    \      string = string.chars().skip(1).collect();\n        }\n        index +=\
    \ 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp25349b_n.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010959
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    while index < string.len()\
    \ {\n        let mut i = 0;\n        while i < substring.len() && index + i <\
    \ string.len() {\n            if string.chars().nth(index + i) != substring.chars().nth(i)\
    \ {\n                break;\n            }\n            i += 1;\n        }\n \
    \       if i == substring.len() {\n            count += 1;\n            index\
    \ += 1;\n        } else {\n            index += 1;\n        }\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010960
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let string_len = string.len();\n\
    \    let substring_len = substring.len();\n    while index < string_len {\n  \
    \      if string[index..].starts_with(&substring) {\n            count += 1;\n\
    \            index += substring_len;\n        } else {\n            index += 1;\n\
    \        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp41mhz9rt.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010959
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut start = 0;\n    let mut end = substring.len();\n\
    \    while end <= string.len() {\n        if &string[start..end] == substring\
    \ {\n            count += 1;\n        }\n        start += 1;\n        end += 1;\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010959
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    while index < string.len()\
    \ {\n        if let Some(i) = string[index..].find(&substring) {\n           \
    \ count += 1;\n            index += i + substring.len();\n        } else {\n \
    \           break;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpu0b0_mcy.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010959
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut start = 0;\n    while let Some(i) = string[start..].find(&substring)\
    \ {\n        count += 1;\n        start = start + i + 1;\n    }\n    count\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010960
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let string_len = string.len();\n\
    \    let substring_len = substring.len();\n    while index < string_len {\n  \
    \      if string[index..].starts_with(&substring) {\n            count += 1;\n\
    \            index += substring_len;\n        } else {\n            index += 1;\n\
    \        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp41mhz9rt.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010959
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    while index < string.len()\
    \ {\n        let mut found = false;\n        for (i, c) in substring.chars().enumerate()\
    \ {\n            if index + i >= string.len() {\n                break;\n    \
    \        }\n            if string.chars().nth(index + i).unwrap() == c {\n   \
    \             found = true;\n            } else {\n                found = false;\n\
    \                break;\n            }\n        }\n        if found {\n      \
    \      count += 1;\n            index += substring.len();\n        } else {\n\
    \            index += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let\
    \ candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `4`', /tmp/tmpxqr4a8tl.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010960
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut pos = 0;\n    let string = string.as_str();\n\
    \    let substring = substring.as_str();\n    while let Some(i) = string[pos..].find(substring)\
    \ {\n        count += 1;\n        pos += i + 1;\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010960
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let string_len = string.len();\n\
    \    let substring_len = substring.len();\n    while index < string_len {\n  \
    \      let mut i = 0;\n        while i < substring_len && index + i < string_len\
    \ && string.chars().nth(index + i) == substring.chars().nth(i) {\n           \
    \ i += 1;\n        }\n        if i == substring_len {\n            count += 1;\n\
    \            index += 1;\n        } else {\n            index += 1;\n        }\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010960
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut index = 0;\n    let string_len = string.len();\n\
    \    let substring_len = substring.len();\n    while index < string_len {\n  \
    \      let sub_index = string[index..].find(&substring);\n        if sub_index.is_none()\
    \ {\n            break;\n        }\n        count += 1;\n        index += sub_index.unwrap()\
    \ + substring_len;\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp8lbh1jjb.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010959
